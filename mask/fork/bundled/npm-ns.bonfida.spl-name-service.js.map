{"version":3,"file":"bundled/npm-ns.bonfida.spl-name-service.js","mappings":";;;;;;AAAa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B,GAAG,0BAA0B,GAAG,6BAA6B,GAAG,8BAA8B,GAAG,0BAA0B;AACrJ,kBAAkB,mBAAO,CAAC,KAAiB;AAC3C,uBAAuB,mBAAO,CAAC,KAAgB;AAC/C,gBAAgB,mBAAO,CAAC,KAAS;AACjC,cAAc,mBAAO,CAAC,KAAO;AAC7B,gBAAgB,mBAAO,CAAC,KAAS;AACjC,oBAAoB,mBAAO,CAAC,IAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0BAA0B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,aAAa;AACrE;AACA;AACA,0BAA0B;;;;;;;;ACzIb;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wCAAwC,GAAG,sCAAsC,GAAG,4BAA4B,GAAG,wBAAwB,GAAG,4BAA4B,GAAG,2BAA2B,GAAG,2BAA2B,GAAG,mBAAmB,GAAG,uBAAuB;AACtR,kBAAkB,mBAAO,CAAC,KAAiB;AAC3C;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,wCAAwC;;;;;;;;ACvC3B;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB;AACzB,sBAAsB,mBAAO,CAAC,KAAsB;AACpD,gBAAgB,mBAAO,CAAC,KAAS;AACjC,kBAAkB,mBAAO,CAAC,KAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,yBAAyB;;;;;;;;AClBZ;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,KAAS;AAC9B,aAAa,mBAAO,CAAC,KAAY;AACjC,aAAa,mBAAO,CAAC,KAAS;AAC9B,aAAa,mBAAO,CAAC,KAAoB;AACzC,aAAa,mBAAO,CAAC,KAAU;AAC/B,aAAa,mBAAO,CAAC,KAAS;AAC9B,aAAa,mBAAO,CAAC,KAAgB;AACrC,aAAa,mBAAO,CAAC,IAAO;AAC5B,aAAa,mBAAO,CAAC,KAAmB;AACxC,aAAa,mBAAO,CAAC,IAAa;AAClC,aAAa,mBAAO,CAAC,KAAO;AAC5B,aAAa,mBAAO,CAAC,KAAU;AAC/B,aAAa,mBAAO,CAAC,KAAgB;AACrC,aAAa,mBAAO,CAAC,KAAW;;;;;;;;;AC7BnB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B,GAAG,yBAAyB,GAAG,2BAA2B,GAAG,yBAAyB,GAAG,yBAAyB;AAC7I,kBAAkB,mBAAO,CAAC,KAAiB;AAC3C,oBAAoB,mBAAO,CAAC,KAAmB;AAC/C,cAAc,mBAAO,CAAC,KAAO;AAC7B,gBAAgB,mBAAO,CAAC,KAAO;AAC/B,oBAAoB,mBAAO,CAAC,IAAa;AACzC;AACA;AACA,QAAQ,MAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,4CAA4C,MAAM;AAClD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,4CAA4C,MAAM;AAClD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,yBAAyB;AACzB;AACA;AACA,QAAQ,MAAM;AACd;AACA;AACA;AACA;AACA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,yBAAyB;AACzB;AACA,qBAAqB,MAAM;AAC3B,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,2BAA2B;AAC3B;AACA,qBAAqB,MAAM;AAC3B,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;ACtRa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,GAAG,iBAAiB;AACrC,gCAAgC,mBAAO,CAAC,KAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,MAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,cAAc;AACpE;AACA;AACA;AACA,6BAA6B,eAAe;AAC5C;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,MAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,cAAc;AACpE;AACA;AACA;AACA,6BAA6B,eAAe;AAC5C;AACA;AACA;AACA,iBAAiB;;;;;;;;;ACpEJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,wBAAwB,GAAG,mBAAmB,GAAG,yBAAyB;AACjG,kBAAkB,mBAAO,CAAC,KAAiB;AAC3C,oBAAoB,mBAAO,CAAC,KAAmB;AAC/C;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,mBAAmB,GAAG,MAAM;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB;;;;;;;;ACjEP;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB,GAAG,oBAAoB,GAAG,qBAAqB,GAAG,oBAAoB,GAAG,yBAAyB,GAAG,wBAAwB,GAAG,uBAAuB,GAAG,uBAAuB,GAAG,wBAAwB,GAAG,oBAAoB,GAAG,sBAAsB,GAAG,qBAAqB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,wBAAwB,GAAG,qBAAqB,GAAG,iBAAiB;AACtb,iBAAiB,mBAAO,CAAC,KAAgB;AACzC,gBAAgB,mBAAO,CAAC,KAAS;AACjC,gBAAgB,mBAAO,CAAC,KAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,UAAU,WAAW;AACrB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;;;;;;;;AChMT;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,GAAG,sBAAsB;AACxC,kBAAkB,mBAAO,CAAC,KAAiB;AAC3C,iBAAiB,mBAAO,CAAC,KAAU;AACnC,gBAAgB,mBAAO,CAAC,KAAS;AACjC,gBAAgB,mBAAO,CAAC,KAAS;AACjC,oBAAoB,mBAAO,CAAC,KAAW;AACvC,iBAAiB,mBAAO,CAAC,KAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,qBAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,MAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;;;;;;;ACxDF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,YAAY,GAAG,iBAAiB,GAAG,yBAAyB;AAC5D,kBAAkB,mBAAO,CAAC,KAAiB;AAC3C,gBAAgB,mBAAO,CAAC,KAAO;AAC/B,cAAc,mBAAO,CAAC,IAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gCAAgC;AAC9D,8BAA8B,gCAAgC;AAC9D;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;AC9Ga;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B,GAAG,4BAA4B,GAAG,iBAAiB;AAC/E,kBAAkB,mBAAO,CAAC,KAAiB;AAC3C,gBAAgB,mBAAO,CAAC,KAAS;AACjC,gBAAgB,mBAAO,CAAC,KAAS;AACjC,iBAAiB;AACjB;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,YAAY,4BAA4B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;;;;;;;;;ACzBf;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oCAAoC,GAAG,mCAAmC,GAAG,8BAA8B,GAAG,gDAAgD,GAAG,+BAA+B,GAAG,0BAA0B,GAAG,6BAA6B,GAAG,6BAA6B,GAAG,4BAA4B,GAAG,iCAAiC,GAAG,qCAAqC;AACxY,kBAAkB,mBAAO,CAAC,KAAiB;AAC3C,oBAAoB,mBAAO,CAAC,IAAa;AACzC,mBAAmB,mBAAO,CAAC,KAAY;AACvC,uBAAuB,mBAAO,CAAC,KAAgB;AAC/C,gBAAgB,mBAAO,CAAC,KAAS;AACjC,gBAAgB,mBAAO,CAAC,KAAS;AACjC,cAAc,mBAAO,CAAC,KAAO;AAC7B,gBAAgB,mBAAO,CAAC,KAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,gGAAgG,SAAS;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,+CAA+C,MAAM;AACrD,aAAa;AACb,SAAS;AACT;AACA,gGAAgG,SAAS;AACzG;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,MAAM;AACtC;AACA;AACA,oCAAoC;;;;;;;;AC1NvB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B,cAAc,KAAK;;;;;;;;;ACzBrC;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+BAA+B,GAAG,qBAAqB,GAAG,oBAAoB,GAAG,sBAAsB,GAAG,iCAAiC,GAAG,2BAA2B,GAAG,4BAA4B,GAAG,yBAAyB,GAAG,qBAAqB,GAAG,oBAAoB;AACnR,kBAAkB,mBAAO,CAAC,KAAiB;AAC3C,gCAAgC,mBAAO,CAAC,KAAO;AAC/C,eAAe,mBAAO,CAAC,KAAqB;AAC5C,oBAAoB,mBAAO,CAAC,IAAa;AACzC,gBAAgB,mBAAO,CAAC,KAAS;AACjC,oBAAoB,mBAAO,CAAC,IAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,mCAAmC,MAAM;AACzC,WAAW,MAAM;AACjB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,MAAM;AACzB;AACA;AACA;AACA;AACA;AACA,mBAAmB,MAAM;AACzB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL,+BAA+B,QAAQ,wHAAwH;AAC/J;AACA,sBAAsB;AACtB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B;AACA,gBAAgB,oBAAoB;AACpC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,wBAAwB;AACxB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,+BAA+B;;;;;;;;ACvLlB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B,GAAG,0BAA0B,GAAG,6BAA6B,GAAG,8BAA8B,GAAG,0BAA0B;AACrJ,kBAAkB,mBAAO,CAAC,KAAiB;AAC3C,uBAAuB,mBAAO,CAAC,KAAgB;AAC/C,gBAAgB,mBAAO,CAAC,KAAS;AACjC,cAAc,mBAAO,CAAC,KAAO;AAC7B,gBAAgB,mBAAO,CAAC,IAAS;AACjC,oBAAoB,mBAAO,CAAC,KAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0BAA0B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,aAAa;AACrE;AACA;AACA,0BAA0B;;;;;;;;ACzIb;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wCAAwC,GAAG,sCAAsC,GAAG,4BAA4B,GAAG,wBAAwB,GAAG,4BAA4B,GAAG,2BAA2B,GAAG,2BAA2B,GAAG,mBAAmB,GAAG,uBAAuB;AACtR,kBAAkB,mBAAO,CAAC,KAAiB;AAC3C;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,wCAAwC;;;;;;;;ACvC3B;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB;AACzB,sBAAsB,mBAAO,CAAC,KAAsB;AACpD,gBAAgB,mBAAO,CAAC,IAAS;AACjC,kBAAkB,mBAAO,CAAC,KAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,yBAAyB;;;;;;;;AClBZ;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,IAAS;AAC9B,aAAa,mBAAO,CAAC,KAAY;AACjC,aAAa,mBAAO,CAAC,KAAS;AAC9B,aAAa,mBAAO,CAAC,KAAoB;AACzC,aAAa,mBAAO,CAAC,KAAU;AAC/B,aAAa,mBAAO,CAAC,IAAS;AAC9B,aAAa,mBAAO,CAAC,KAAgB;AACrC,aAAa,mBAAO,CAAC,KAAO;AAC5B,aAAa,mBAAO,CAAC,KAAmB;AACxC,aAAa,mBAAO,CAAC,KAAa;AAClC,aAAa,mBAAO,CAAC,KAAO;AAC5B,aAAa,mBAAO,CAAC,KAAU;AAC/B,aAAa,mBAAO,CAAC,KAAgB;AACrC,aAAa,mBAAO,CAAC,KAAW;;;;;;;;;AC7BnB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B,GAAG,yBAAyB,GAAG,2BAA2B,GAAG,yBAAyB,GAAG,yBAAyB;AAC7I,kBAAkB,mBAAO,CAAC,KAAiB;AAC3C,oBAAoB,mBAAO,CAAC,KAAmB;AAC/C,cAAc,mBAAO,CAAC,KAAO;AAC7B,gBAAgB,mBAAO,CAAC,KAAO;AAC/B,oBAAoB,mBAAO,CAAC,KAAa;AACzC;AACA;AACA,QAAQ,MAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,4CAA4C,MAAM;AAClD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,4CAA4C,MAAM;AAClD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,yBAAyB;AACzB;AACA;AACA,QAAQ,MAAM;AACd;AACA;AACA;AACA;AACA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,yBAAyB;AACzB;AACA,qBAAqB,MAAM;AAC3B,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,2BAA2B;AAC3B;AACA,qBAAqB,MAAM;AAC3B,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;ACtRa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,GAAG,iBAAiB;AACrC,gCAAgC,mBAAO,CAAC,KAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,MAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,cAAc;AACpE;AACA;AACA;AACA,6BAA6B,eAAe;AAC5C;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,MAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,cAAc;AACpE;AACA;AACA;AACA,6BAA6B,eAAe;AAC5C;AACA;AACA;AACA,iBAAiB;;;;;;;;;ACpEJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,wBAAwB,GAAG,mBAAmB,GAAG,yBAAyB;AACjG,kBAAkB,mBAAO,CAAC,KAAiB;AAC3C,oBAAoB,mBAAO,CAAC,KAAmB;AAC/C;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,mBAAmB,GAAG,MAAM;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB;;;;;;;;ACjEP;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB,GAAG,oBAAoB,GAAG,qBAAqB,GAAG,oBAAoB,GAAG,yBAAyB,GAAG,wBAAwB,GAAG,uBAAuB,GAAG,uBAAuB,GAAG,wBAAwB,GAAG,oBAAoB,GAAG,sBAAsB,GAAG,qBAAqB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,wBAAwB,GAAG,qBAAqB,GAAG,iBAAiB;AACtb,iBAAiB,mBAAO,CAAC,KAAgB;AACzC,gBAAgB,mBAAO,CAAC,IAAS;AACjC,gBAAgB,mBAAO,CAAC,KAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,UAAU,WAAW;AACrB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;;;;;;;;AChMT;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,GAAG,sBAAsB;AACxC,kBAAkB,mBAAO,CAAC,KAAiB;AAC3C,iBAAiB,mBAAO,CAAC,KAAU;AACnC,gBAAgB,mBAAO,CAAC,IAAS;AACjC,gBAAgB,mBAAO,CAAC,KAAS;AACjC,oBAAoB,mBAAO,CAAC,KAAW;AACvC,iBAAiB,mBAAO,CAAC,KAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,qBAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,MAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;;;;;;;ACxDF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,YAAY,GAAG,iBAAiB,GAAG,yBAAyB;AAC5D,kBAAkB,mBAAO,CAAC,KAAiB;AAC3C,gBAAgB,mBAAO,CAAC,KAAO;AAC/B,cAAc,mBAAO,CAAC,KAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gCAAgC;AAC9D,8BAA8B,gCAAgC;AAC9D;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;AC9Ga;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B,GAAG,4BAA4B,GAAG,iBAAiB;AAC/E,kBAAkB,mBAAO,CAAC,KAAiB;AAC3C,gBAAgB,mBAAO,CAAC,IAAS;AACjC,gBAAgB,mBAAO,CAAC,KAAS;AACjC,iBAAiB;AACjB;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,YAAY,4BAA4B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;;;;;;;;;ACzBf;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oCAAoC,GAAG,mCAAmC,GAAG,8BAA8B,GAAG,gDAAgD,GAAG,+BAA+B,GAAG,0BAA0B,GAAG,6BAA6B,GAAG,6BAA6B,GAAG,4BAA4B,GAAG,iCAAiC,GAAG,qCAAqC;AACxY,kBAAkB,mBAAO,CAAC,KAAiB;AAC3C,oBAAoB,mBAAO,CAAC,KAAa;AACzC,mBAAmB,mBAAO,CAAC,KAAY;AACvC,uBAAuB,mBAAO,CAAC,KAAgB;AAC/C,gBAAgB,mBAAO,CAAC,KAAS;AACjC,gBAAgB,mBAAO,CAAC,IAAS;AACjC,cAAc,mBAAO,CAAC,KAAO;AAC7B,gBAAgB,mBAAO,CAAC,KAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,gGAAgG,SAAS;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,+CAA+C,MAAM;AACrD,aAAa;AACb,SAAS;AACT;AACA,gGAAgG,SAAS;AACzG;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,MAAM;AACtC;AACA;AACA,oCAAoC;;;;;;;;AC1NvB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B,cAAc,KAAK;;;;;;;;;ACzBrC;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+BAA+B,GAAG,qBAAqB,GAAG,oBAAoB,GAAG,sBAAsB,GAAG,iCAAiC,GAAG,2BAA2B,GAAG,4BAA4B,GAAG,yBAAyB,GAAG,qBAAqB,GAAG,oBAAoB;AACnR,kBAAkB,mBAAO,CAAC,KAAiB;AAC3C,gCAAgC,mBAAO,CAAC,KAAO;AAC/C,eAAe,mBAAO,CAAC,KAAqB;AAC5C,oBAAoB,mBAAO,CAAC,KAAa;AACzC,gBAAgB,mBAAO,CAAC,KAAS;AACjC,oBAAoB,mBAAO,CAAC,KAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,mCAAmC,MAAM;AACzC,WAAW,MAAM;AACjB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,MAAM;AACzB;AACA;AACA;AACA;AACA;AACA,mBAAmB,MAAM;AACzB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL,+BAA+B,QAAQ,wHAAwH;AAC/J;AACA,sBAAsB;AACtB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B;AACA,gBAAgB,oBAAoB;AACpC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,wBAAwB;AACxB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,+BAA+B","sources":["webpack://mask-network/./node_modules/.pnpm/@bonfida+spl-name-service@0.1.50_@solana+buffer-layout@4.0.1_@solana+spl-token@0.1.8_@solana+_pcnm6ddhsndtai733dtxa7aqtq/node_modules/@bonfida/spl-name-service/dist/bindings.js","webpack://mask-network/./node_modules/.pnpm/@bonfida+spl-name-service@0.1.50_@solana+buffer-layout@4.0.1_@solana+spl-token@0.1.8_@solana+_pcnm6ddhsndtai733dtxa7aqtq/node_modules/@bonfida/spl-name-service/dist/constants.js","webpack://mask-network/./node_modules/.pnpm/@bonfida+spl-name-service@0.1.50_@solana+buffer-layout@4.0.1_@solana+spl-token@0.1.8_@solana+_pcnm6ddhsndtai733dtxa7aqtq/node_modules/@bonfida/spl-name-service/dist/favorite-domain.js","webpack://mask-network/./node_modules/.pnpm/@bonfida+spl-name-service@0.1.50_@solana+buffer-layout@4.0.1_@solana+spl-token@0.1.8_@solana+_pcnm6ddhsndtai733dtxa7aqtq/node_modules/@bonfida/spl-name-service/dist/index.js","webpack://mask-network/./node_modules/.pnpm/@bonfida+spl-name-service@0.1.50_@solana+buffer-layout@4.0.1_@solana+spl-token@0.1.8_@solana+_pcnm6ddhsndtai733dtxa7aqtq/node_modules/@bonfida/spl-name-service/dist/instructions.js","webpack://mask-network/./node_modules/.pnpm/@bonfida+spl-name-service@0.1.50_@solana+buffer-layout@4.0.1_@solana+spl-token@0.1.8_@solana+_pcnm6ddhsndtai733dtxa7aqtq/node_modules/@bonfida/spl-name-service/dist/int.js","webpack://mask-network/./node_modules/.pnpm/@bonfida+spl-name-service@0.1.50_@solana+buffer-layout@4.0.1_@solana+spl-token@0.1.8_@solana+_pcnm6ddhsndtai733dtxa7aqtq/node_modules/@bonfida/spl-name-service/dist/nft.js","webpack://mask-network/./node_modules/.pnpm/@bonfida+spl-name-service@0.1.50_@solana+buffer-layout@4.0.1_@solana+spl-token@0.1.8_@solana+_pcnm6ddhsndtai733dtxa7aqtq/node_modules/@bonfida/spl-name-service/dist/record.js","webpack://mask-network/./node_modules/.pnpm/@bonfida+spl-name-service@0.1.50_@solana+buffer-layout@4.0.1_@solana+spl-token@0.1.8_@solana+_pcnm6ddhsndtai733dtxa7aqtq/node_modules/@bonfida/spl-name-service/dist/resolve.js","webpack://mask-network/./node_modules/.pnpm/@bonfida+spl-name-service@0.1.50_@solana+buffer-layout@4.0.1_@solana+spl-token@0.1.8_@solana+_pcnm6ddhsndtai733dtxa7aqtq/node_modules/@bonfida/spl-name-service/dist/state.js","webpack://mask-network/./node_modules/.pnpm/@bonfida+spl-name-service@0.1.50_@solana+buffer-layout@4.0.1_@solana+spl-token@0.1.8_@solana+_pcnm6ddhsndtai733dtxa7aqtq/node_modules/@bonfida/spl-name-service/dist/tokens.js","webpack://mask-network/./node_modules/.pnpm/@bonfida+spl-name-service@0.1.50_@solana+buffer-layout@4.0.1_@solana+spl-token@0.1.8_@solana+_pcnm6ddhsndtai733dtxa7aqtq/node_modules/@bonfida/spl-name-service/dist/twitter_bindings.js","webpack://mask-network/./node_modules/.pnpm/@bonfida+spl-name-service@0.1.50_@solana+buffer-layout@4.0.1_@solana+spl-token@0.1.8_@solana+_pcnm6ddhsndtai733dtxa7aqtq/node_modules/@bonfida/spl-name-service/dist/types/record.js","webpack://mask-network/./node_modules/.pnpm/@bonfida+spl-name-service@0.1.50_@solana+buffer-layout@4.0.1_@solana+spl-token@0.1.8_@solana+_pcnm6ddhsndtai733dtxa7aqtq/node_modules/@bonfida/spl-name-service/dist/utils.js","webpack://mask-network/./node_modules/.pnpm/@bonfida+spl-name-service@0.1.50_@solana+buffer-layout@4.0.1_@solana+spl-token@0.1.8_@solana+_ylhstqpjm6h3kcba65atu6jfhu/node_modules/@bonfida/spl-name-service/dist/bindings.js","webpack://mask-network/./node_modules/.pnpm/@bonfida+spl-name-service@0.1.50_@solana+buffer-layout@4.0.1_@solana+spl-token@0.1.8_@solana+_ylhstqpjm6h3kcba65atu6jfhu/node_modules/@bonfida/spl-name-service/dist/constants.js","webpack://mask-network/./node_modules/.pnpm/@bonfida+spl-name-service@0.1.50_@solana+buffer-layout@4.0.1_@solana+spl-token@0.1.8_@solana+_ylhstqpjm6h3kcba65atu6jfhu/node_modules/@bonfida/spl-name-service/dist/favorite-domain.js","webpack://mask-network/./node_modules/.pnpm/@bonfida+spl-name-service@0.1.50_@solana+buffer-layout@4.0.1_@solana+spl-token@0.1.8_@solana+_ylhstqpjm6h3kcba65atu6jfhu/node_modules/@bonfida/spl-name-service/dist/index.js","webpack://mask-network/./node_modules/.pnpm/@bonfida+spl-name-service@0.1.50_@solana+buffer-layout@4.0.1_@solana+spl-token@0.1.8_@solana+_ylhstqpjm6h3kcba65atu6jfhu/node_modules/@bonfida/spl-name-service/dist/instructions.js","webpack://mask-network/./node_modules/.pnpm/@bonfida+spl-name-service@0.1.50_@solana+buffer-layout@4.0.1_@solana+spl-token@0.1.8_@solana+_ylhstqpjm6h3kcba65atu6jfhu/node_modules/@bonfida/spl-name-service/dist/int.js","webpack://mask-network/./node_modules/.pnpm/@bonfida+spl-name-service@0.1.50_@solana+buffer-layout@4.0.1_@solana+spl-token@0.1.8_@solana+_ylhstqpjm6h3kcba65atu6jfhu/node_modules/@bonfida/spl-name-service/dist/nft.js","webpack://mask-network/./node_modules/.pnpm/@bonfida+spl-name-service@0.1.50_@solana+buffer-layout@4.0.1_@solana+spl-token@0.1.8_@solana+_ylhstqpjm6h3kcba65atu6jfhu/node_modules/@bonfida/spl-name-service/dist/record.js","webpack://mask-network/./node_modules/.pnpm/@bonfida+spl-name-service@0.1.50_@solana+buffer-layout@4.0.1_@solana+spl-token@0.1.8_@solana+_ylhstqpjm6h3kcba65atu6jfhu/node_modules/@bonfida/spl-name-service/dist/resolve.js","webpack://mask-network/./node_modules/.pnpm/@bonfida+spl-name-service@0.1.50_@solana+buffer-layout@4.0.1_@solana+spl-token@0.1.8_@solana+_ylhstqpjm6h3kcba65atu6jfhu/node_modules/@bonfida/spl-name-service/dist/state.js","webpack://mask-network/./node_modules/.pnpm/@bonfida+spl-name-service@0.1.50_@solana+buffer-layout@4.0.1_@solana+spl-token@0.1.8_@solana+_ylhstqpjm6h3kcba65atu6jfhu/node_modules/@bonfida/spl-name-service/dist/tokens.js","webpack://mask-network/./node_modules/.pnpm/@bonfida+spl-name-service@0.1.50_@solana+buffer-layout@4.0.1_@solana+spl-token@0.1.8_@solana+_ylhstqpjm6h3kcba65atu6jfhu/node_modules/@bonfida/spl-name-service/dist/twitter_bindings.js","webpack://mask-network/./node_modules/.pnpm/@bonfida+spl-name-service@0.1.50_@solana+buffer-layout@4.0.1_@solana+spl-token@0.1.8_@solana+_ylhstqpjm6h3kcba65atu6jfhu/node_modules/@bonfida/spl-name-service/dist/types/record.js","webpack://mask-network/./node_modules/.pnpm/@bonfida+spl-name-service@0.1.50_@solana+buffer-layout@4.0.1_@solana+spl-token@0.1.8_@solana+_ylhstqpjm6h3kcba65atu6jfhu/node_modules/@bonfida/spl-name-service/dist/utils.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.registerDomainName = exports.deleteNameRegistry = exports.transferNameOwnership = exports.updateNameRegistryData = exports.createNameRegistry = void 0;\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst instructions_1 = require(\"./instructions\");\nconst state_1 = require(\"./state\");\nconst int_1 = require(\"./int\");\nconst utils_1 = require(\"./utils\");\nconst constants_1 = require(\"./constants\");\n/**\n * Creates a name account with the given rent budget, allocated space, owner and class.\n *\n * @param connection The solana connection object to the RPC node\n * @param name The name of the new account\n * @param space The space in bytes allocated to the account\n * @param payerKey The allocation cost payer\n * @param nameOwner The pubkey to be set as owner of the new name account\n * @param lamports The budget to be set for the name account. If not specified, it'll be the minimum for rent exemption\n * @param nameClass The class of this new name\n * @param parentName The parent name of the new name. If specified its owner needs to sign\n * @returns\n */\nasync function createNameRegistry(connection, name, space, payerKey, nameOwner, lamports, nameClass, parentName) {\n    const hashed_name = await (0, utils_1.getHashedName)(name);\n    const nameAccountKey = await (0, utils_1.getNameAccountKey)(hashed_name, nameClass, parentName);\n    const balance = lamports\n        ? lamports\n        : await connection.getMinimumBalanceForRentExemption(space);\n    let nameParentOwner;\n    if (parentName) {\n        const { registry: parentAccount } = await (0, utils_1.getNameOwner)(connection, parentName);\n        nameParentOwner = parentAccount.owner;\n    }\n    const createNameInstr = (0, instructions_1.createInstruction)(constants_1.NAME_PROGRAM_ID, web3_js_1.SystemProgram.programId, nameAccountKey, nameOwner, payerKey, hashed_name, \n    //@ts-ignore\n    new int_1.Numberu64(balance), \n    //@ts-ignore\n    new int_1.Numberu32(space), nameClass, parentName, nameParentOwner);\n    return createNameInstr;\n}\nexports.createNameRegistry = createNameRegistry;\n/**\n * Overwrite the data of the given name registry.\n *\n * @param connection The solana connection object to the RPC node\n * @param name The name of the name registry to update\n * @param offset The offset to which the data should be written into the registry\n * @param input_data The data to be written\n * @param nameClass The class of this name, if it exsists\n * @param nameParent The parent name of this name, if it exists\n */\nasync function updateNameRegistryData(connection, name, offset, input_data, nameClass, nameParent) {\n    const hashed_name = await (0, utils_1.getHashedName)(name);\n    const nameAccountKey = await (0, utils_1.getNameAccountKey)(hashed_name, nameClass, nameParent);\n    let signer;\n    if (nameClass) {\n        signer = nameClass;\n    }\n    else {\n        signer = (await state_1.NameRegistryState.retrieve(connection, nameAccountKey))\n            .registry.owner;\n    }\n    const updateInstr = (0, instructions_1.updateInstruction)(constants_1.NAME_PROGRAM_ID, nameAccountKey, \n    //@ts-ignore\n    new int_1.Numberu32(offset), input_data, signer);\n    return updateInstr;\n}\nexports.updateNameRegistryData = updateNameRegistryData;\n/**\n * Change the owner of a given name account.\n *\n * @param connection The solana connection object to the RPC node\n * @param name The name of the name account\n * @param newOwner The new owner to be set\n * @param curentNameOwner the current name Owner\n * @param nameClass The class of this name, if it exsists\n * @param nameParent The parent name of this name, if it exists\n * @param parentOwner Parent name owner\n * @returns\n */\nasync function transferNameOwnership(connection, name, newOwner, nameClass, nameParent, parentOwner) {\n    const hashed_name = await (0, utils_1.getHashedName)(name);\n    const nameAccountKey = await (0, utils_1.getNameAccountKey)(hashed_name, nameClass, nameParent);\n    let curentNameOwner;\n    if (nameClass) {\n        curentNameOwner = nameClass;\n    }\n    else {\n        curentNameOwner = (await state_1.NameRegistryState.retrieve(connection, nameAccountKey)).registry.owner;\n    }\n    const transferInstr = (0, instructions_1.transferInstruction)(constants_1.NAME_PROGRAM_ID, nameAccountKey, newOwner, curentNameOwner, nameClass, nameParent, parentOwner);\n    return transferInstr;\n}\nexports.transferNameOwnership = transferNameOwnership;\n/**\n * Delete the name account and transfer the rent to the target.\n *\n * @param connection The solana connection object to the RPC node\n * @param name The name of the name account\n * @param refundTargetKey The refund destination address\n * @param nameClass The class of this name, if it exsists\n * @param nameParent The parent name of this name, if it exists\n * @returns\n */\nasync function deleteNameRegistry(connection, name, refundTargetKey, nameClass, nameParent) {\n    const hashed_name = await (0, utils_1.getHashedName)(name);\n    const nameAccountKey = await (0, utils_1.getNameAccountKey)(hashed_name, nameClass, nameParent);\n    let nameOwner;\n    if (nameClass) {\n        nameOwner = nameClass;\n    }\n    else {\n        nameOwner = (await state_1.NameRegistryState.retrieve(connection, nameAccountKey))\n            .registry.owner;\n    }\n    const changeAuthoritiesInstr = (0, instructions_1.deleteInstruction)(constants_1.NAME_PROGRAM_ID, nameAccountKey, refundTargetKey, nameOwner);\n    return changeAuthoritiesInstr;\n}\nexports.deleteNameRegistry = deleteNameRegistry;\n/**\n * This function can be used to register a .sol domain\n * @param name The domain name to register e.g bonfida if you want to register bonfida.sol\n * @param space The domain name account size (max 10kB)\n * @param buyer The public key of the buyer\n * @param buyerTokenAccount The buyer FIDA token account\n * @returns\n */\nconst registerDomainName = async (name, space, buyer, buyerTokenAccount) => {\n    const [centralState] = await web3_js_1.PublicKey.findProgramAddress([constants_1.REGISTER_PROGRAM_ID.toBuffer()], constants_1.REGISTER_PROGRAM_ID);\n    const hashed = await (0, utils_1.getHashedName)(name);\n    const nameAccount = await (0, utils_1.getNameAccountKey)(hashed, undefined, constants_1.ROOT_DOMAIN_ACCOUNT);\n    const hashedReverseLookup = await (0, utils_1.getHashedName)(nameAccount.toBase58());\n    const reverseLookupAccount = await (0, utils_1.getNameAccountKey)(hashedReverseLookup, centralState);\n    const [derived_state] = await web3_js_1.PublicKey.findProgramAddress([nameAccount.toBuffer()], constants_1.REGISTER_PROGRAM_ID);\n    const ix = new instructions_1.createV2Instruction({ name, space }).getInstruction(constants_1.REGISTER_PROGRAM_ID, web3_js_1.SYSVAR_RENT_PUBKEY, constants_1.NAME_PROGRAM_ID, constants_1.ROOT_DOMAIN_ACCOUNT, nameAccount, reverseLookupAccount, centralState, buyer, buyerTokenAccount, constants_1.BONFIDA_FIDA_BNB, derived_state);\n    return [[], [ix]];\n};\nexports.registerDomainName = registerDomainName;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TWITTER_ROOT_PARENT_REGISTRY_KEY = exports.TWITTER_VERIFICATION_AUTHORITY = exports.REVERSE_LOOKUP_CLASS = exports.BONFIDA_FIDA_BNB = exports.PYTH_FIDDA_PRICE_ACC = exports.REGISTER_PROGRAM_ID = exports.ROOT_DOMAIN_ACCOUNT = exports.HASH_PREFIX = exports.NAME_PROGRAM_ID = void 0;\nconst web3_js_1 = require(\"@solana/web3.js\");\n/**\n * The Solana Name Service program ID\n */\nexports.NAME_PROGRAM_ID = new web3_js_1.PublicKey(\"namesLPneVptA9Z5rqUDD9tMTWEJwofgaYwp8cawRkX\");\n/**\n * Hash prefix used to derive domain name addresses\n */\nexports.HASH_PREFIX = \"SPL Name Service\";\n/**\n * The `.sol` TLD\n */\nexports.ROOT_DOMAIN_ACCOUNT = new web3_js_1.PublicKey(\"58PwtjSDuFHuUkYjH9BYnnQKHfwo9reZhC2zMJv9JPkx\");\n/**\n * The Registry program ID\n */\nexports.REGISTER_PROGRAM_ID = new web3_js_1.PublicKey(\"jCebN34bUfdeUYJT13J1yG16XWQpt5PDx6Mse9GUqhR\");\n/**\n * The FIDA Pyth price feed\n */\nexports.PYTH_FIDDA_PRICE_ACC = new web3_js_1.PublicKey(\"ETp9eKXVv1dWwHSpsXRUuXHmw24PwRkttCGVgpZEY9zF\");\n/**\n * The FIDA buy and burn address\n */\nexports.BONFIDA_FIDA_BNB = new web3_js_1.PublicKey(\"AUoZ3YAhV3b2rZeEH93UMZHXUZcTramBvb4d9YEVySkc\");\n/**\n * The reverse look up class\n */\nexports.REVERSE_LOOKUP_CLASS = new web3_js_1.PublicKey(\"33m47vH6Eav6jr5Ry86XjhRft2jRBLDnDgPSHoquXi2Z\");\n/**\n * The `.twitter` TLD authority\n */\nexports.TWITTER_VERIFICATION_AUTHORITY = new web3_js_1.PublicKey(\"FvPH7PrVrLGKPfqaf3xJodFTjZriqrAXXLTVWEorTFBi\");\n/**\n * The `.twitter` TLD\n */\nexports.TWITTER_ROOT_PARENT_REGISTRY_KEY = new web3_js_1.PublicKey(\"4YcexoW3r78zz16J2aqmukBLRwGq6rAvWzJpkYAXqebv\");\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getFavoriteDomain = void 0;\nconst name_offers_1 = require(\"@bonfida/name-offers\");\nconst utils_1 = require(\"./utils\");\nconst web3_js_1 = require(\"@solana/web3.js\");\n/**\n * This function can be used to retrieve the favorite domain of a user\n * @param connection The Solana RPC connection object\n * @param owner The owner you want to retrieve the favorite domain for\n * @returns\n */\nconst getFavoriteDomain = async (connection, owner) => {\n    const [favKey] = await name_offers_1.FavouriteDomain.getKey(name_offers_1.NAME_OFFERS_ID, new web3_js_1.PublicKey(owner));\n    const favorite = await name_offers_1.FavouriteDomain.retrieve(connection, favKey);\n    const reverse = await (0, utils_1.performReverseLookup)(connection, favorite.nameAccount);\n    return { domain: favorite.nameAccount, reverse };\n};\nexports.getFavoriteDomain = getFavoriteDomain;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./utils\"), exports);\n__exportStar(require(\"./bindings\"), exports);\n__exportStar(require(\"./state\"), exports);\n__exportStar(require(\"./twitter_bindings\"), exports);\n__exportStar(require(\"./tokens\"), exports);\n__exportStar(require(\"./utils\"), exports);\n__exportStar(require(\"./instructions\"), exports);\n__exportStar(require(\"./nft\"), exports);\n__exportStar(require(\"./favorite-domain\"), exports);\n__exportStar(require(\"./constants\"), exports);\n__exportStar(require(\"./int\"), exports);\n__exportStar(require(\"./record\"), exports);\n__exportStar(require(\"./types/record\"), exports);\n__exportStar(require(\"./resolve\"), exports);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createV2Instruction = exports.deleteInstruction = exports.transferInstruction = exports.updateInstruction = exports.createInstruction = void 0;\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst spl_token_1 = require(\"@solana/spl-token\");\nconst int_1 = require(\"./int\");\nconst borsh_1 = require(\"borsh\");\nconst constants_1 = require(\"./constants\");\nfunction createInstruction(nameProgramId, systemProgramId, nameKey, nameOwnerKey, payerKey, hashed_name, lamports, space, nameClassKey, nameParent, nameParentOwner) {\n    const buffers = [\n        Buffer.from(Int8Array.from([0])),\n        //@ts-ignore\n        new int_1.Numberu32(hashed_name.length).toBuffer(),\n        hashed_name,\n        lamports.toBuffer(),\n        space.toBuffer(),\n    ];\n    const data = Buffer.concat(buffers);\n    const keys = [\n        {\n            pubkey: systemProgramId,\n            isSigner: false,\n            isWritable: false,\n        },\n        {\n            pubkey: payerKey,\n            isSigner: true,\n            isWritable: true,\n        },\n        {\n            pubkey: nameKey,\n            isSigner: false,\n            isWritable: true,\n        },\n        {\n            pubkey: nameOwnerKey,\n            isSigner: false,\n            isWritable: false,\n        },\n    ];\n    if (nameClassKey) {\n        keys.push({\n            pubkey: nameClassKey,\n            isSigner: true,\n            isWritable: false,\n        });\n    }\n    else {\n        keys.push({\n            pubkey: new web3_js_1.PublicKey(Buffer.alloc(32)),\n            isSigner: false,\n            isWritable: false,\n        });\n    }\n    if (nameParent) {\n        keys.push({\n            pubkey: nameParent,\n            isSigner: false,\n            isWritable: false,\n        });\n    }\n    else {\n        keys.push({\n            pubkey: new web3_js_1.PublicKey(Buffer.alloc(32)),\n            isSigner: false,\n            isWritable: false,\n        });\n    }\n    if (nameParentOwner) {\n        keys.push({\n            pubkey: nameParentOwner,\n            isSigner: true,\n            isWritable: false,\n        });\n    }\n    return new web3_js_1.TransactionInstruction({\n        keys,\n        programId: nameProgramId,\n        data,\n    });\n}\nexports.createInstruction = createInstruction;\nfunction updateInstruction(nameProgramId, nameAccountKey, offset, input_data, nameUpdateSigner) {\n    const buffers = [\n        Buffer.from(Int8Array.from([1])),\n        offset.toBuffer(),\n        //@ts-ignore\n        new int_1.Numberu32(input_data.length).toBuffer(),\n        input_data,\n    ];\n    const data = Buffer.concat(buffers);\n    const keys = [\n        {\n            pubkey: nameAccountKey,\n            isSigner: false,\n            isWritable: true,\n        },\n        {\n            pubkey: nameUpdateSigner,\n            isSigner: true,\n            isWritable: false,\n        },\n    ];\n    return new web3_js_1.TransactionInstruction({\n        keys,\n        programId: nameProgramId,\n        data,\n    });\n}\nexports.updateInstruction = updateInstruction;\nfunction transferInstruction(nameProgramId, nameAccountKey, newOwnerKey, currentNameOwnerKey, nameClassKey, nameParent, parentOwner) {\n    const buffers = [Buffer.from(Int8Array.from([2])), newOwnerKey.toBuffer()];\n    const data = Buffer.concat(buffers);\n    const keys = [\n        {\n            pubkey: nameAccountKey,\n            isSigner: false,\n            isWritable: true,\n        },\n        {\n            pubkey: parentOwner ? parentOwner : currentNameOwnerKey,\n            isSigner: true,\n            isWritable: false,\n        },\n    ];\n    if (nameClassKey) {\n        keys.push({\n            pubkey: nameClassKey,\n            isSigner: true,\n            isWritable: false,\n        });\n    }\n    if (parentOwner && nameParent) {\n        if (!nameClassKey) {\n            keys.push({\n                pubkey: web3_js_1.PublicKey.default,\n                isSigner: false,\n                isWritable: false,\n            });\n        }\n        keys.push({\n            pubkey: nameParent,\n            isSigner: false,\n            isWritable: false,\n        });\n    }\n    return new web3_js_1.TransactionInstruction({\n        keys,\n        programId: nameProgramId,\n        data,\n    });\n}\nexports.transferInstruction = transferInstruction;\nfunction deleteInstruction(nameProgramId, nameAccountKey, refundTargetKey, nameOwnerKey) {\n    const buffers = [Buffer.from(Int8Array.from([3]))];\n    const data = Buffer.concat(buffers);\n    const keys = [\n        {\n            pubkey: nameAccountKey,\n            isSigner: false,\n            isWritable: true,\n        },\n        {\n            pubkey: nameOwnerKey,\n            isSigner: true,\n            isWritable: false,\n        },\n        {\n            pubkey: refundTargetKey,\n            isSigner: false,\n            isWritable: true,\n        },\n    ];\n    return new web3_js_1.TransactionInstruction({\n        keys,\n        programId: nameProgramId,\n        data,\n    });\n}\nexports.deleteInstruction = deleteInstruction;\nclass createV2Instruction {\n    constructor(obj) {\n        this.tag = 9;\n        this.name = obj.name;\n        this.space = obj.space;\n    }\n    serialize() {\n        return (0, borsh_1.serialize)(createV2Instruction.schema, this);\n    }\n    getInstruction(programId, rentSysvarAccount, nameProgramId, rootDomain, nameAccount, reverseLookupAccount, centralState, buyer, buyerTokenAccount, fidaVault, state) {\n        const data = Buffer.from(this.serialize());\n        const keys = [\n            {\n                pubkey: rentSysvarAccount,\n                isSigner: false,\n                isWritable: false,\n            },\n            {\n                pubkey: nameProgramId,\n                isSigner: false,\n                isWritable: false,\n            },\n            {\n                pubkey: rootDomain,\n                isSigner: false,\n                isWritable: false,\n            },\n            {\n                pubkey: nameAccount,\n                isSigner: false,\n                isWritable: true,\n            },\n            {\n                pubkey: reverseLookupAccount,\n                isSigner: false,\n                isWritable: true,\n            },\n            {\n                pubkey: web3_js_1.SystemProgram.programId,\n                isSigner: false,\n                isWritable: false,\n            },\n            {\n                pubkey: centralState,\n                isSigner: false,\n                isWritable: false,\n            },\n            {\n                pubkey: buyer,\n                isSigner: true,\n                isWritable: true,\n            },\n            {\n                pubkey: buyerTokenAccount,\n                isSigner: false,\n                isWritable: true,\n            },\n            {\n                pubkey: constants_1.PYTH_FIDDA_PRICE_ACC,\n                isSigner: false,\n                isWritable: false,\n            },\n            {\n                pubkey: fidaVault,\n                isSigner: false,\n                isWritable: true,\n            },\n            {\n                pubkey: spl_token_1.TOKEN_PROGRAM_ID,\n                isSigner: false,\n                isWritable: false,\n            },\n            {\n                pubkey: state,\n                isSigner: false,\n                isWritable: false,\n            },\n        ];\n        return new web3_js_1.TransactionInstruction({\n            keys,\n            programId,\n            data,\n        });\n    }\n}\nexports.createV2Instruction = createV2Instruction;\ncreateV2Instruction.schema = new Map([\n    [\n        createV2Instruction,\n        {\n            kind: \"struct\",\n            fields: [\n                [\"tag\", \"u8\"],\n                [\"name\", \"string\"],\n                [\"space\", \"u32\"],\n            ],\n        },\n    ],\n]);\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Numberu64 = exports.Numberu32 = void 0;\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nclass Numberu32 extends bn_js_1.default {\n    /**\n     * Convert to Buffer representation\n     */\n    toBuffer() {\n        const a = super.toArray().reverse();\n        const b = Buffer.from(a);\n        if (b.length === 4) {\n            return b;\n        }\n        if (b.length > 4) {\n            throw new Error(\"Numberu32 too large\");\n        }\n        const zeroPad = Buffer.alloc(4);\n        b.copy(zeroPad);\n        return zeroPad;\n    }\n    /**\n     * Construct a Numberu64 from Buffer representation\n     */\n    static fromBuffer(buffer) {\n        if (buffer.length !== 4) {\n            throw new Error(`Invalid buffer length: ${buffer.length}`);\n        }\n        return new bn_js_1.default([...buffer]\n            .reverse()\n            .map((i) => `00${i.toString(16)}`.slice(-2))\n            .join(\"\"), 16);\n    }\n}\nexports.Numberu32 = Numberu32;\nclass Numberu64 extends bn_js_1.default {\n    /**\n     * Convert to Buffer representation\n     */\n    toBuffer() {\n        const a = super.toArray().reverse();\n        const b = Buffer.from(a);\n        if (b.length === 8) {\n            return b;\n        }\n        if (b.length > 8) {\n            throw new Error(\"Numberu64 too large\");\n        }\n        const zeroPad = Buffer.alloc(8);\n        b.copy(zeroPad);\n        return zeroPad;\n    }\n    /**\n     * Construct a Numberu64 from Buffer representation\n     */\n    static fromBuffer(buffer) {\n        if (buffer.length !== 8) {\n            throw new Error(`Invalid buffer length: ${buffer.length}`);\n        }\n        return new bn_js_1.default([...buffer]\n            .reverse()\n            .map((i) => `00${i.toString(16)}`.slice(-2))\n            .join(\"\"), 16);\n    }\n}\nexports.Numberu64 = Numberu64;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.retrieveNfts = exports.retrieveNftOwner = exports.MINT_PREFIX = exports.NAME_TOKENIZER_ID = void 0;\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst spl_token_1 = require(\"@solana/spl-token\");\n/**\n * Mainnet program ID\n */\nexports.NAME_TOKENIZER_ID = new web3_js_1.PublicKey(\"nftD3vbNkNqfj2Sd3HZwbpw4BxxKWr4AjGb9X38JeZk\");\n/**\n * PDA prefix\n */\nexports.MINT_PREFIX = Buffer.from(\"tokenized_name\");\n/**\n * This function can be used to retrieve the owner of a tokenized domain name\n *\n * @param connection The solana connection object to the RPC node\n * @param nameAccount The key of the domain name\n * @returns\n */\nconst retrieveNftOwner = async (connection, nameAccount) => {\n    var _a;\n    try {\n        const [mint] = await web3_js_1.PublicKey.findProgramAddress([exports.MINT_PREFIX, nameAccount.toBuffer()], exports.NAME_TOKENIZER_ID);\n        const mintInfo = await (0, spl_token_1.getMint)(connection, mint);\n        if (mintInfo.supply.toString() === \"0\") {\n            return undefined;\n        }\n        const { value } = await connection.getTokenLargestAccounts(mint);\n        const holder = (_a = value.find((e) => e.amount === \"1\")) === null || _a === void 0 ? void 0 : _a.address;\n        if (!holder) {\n            return undefined;\n        }\n        const info = await connection.getAccountInfo(holder);\n        if (!info || !info.data) {\n            return undefined;\n        }\n        return new web3_js_1.PublicKey(info.data.slice(32, 64));\n    }\n    catch {\n        return undefined;\n    }\n};\nexports.retrieveNftOwner = retrieveNftOwner;\n/**\n * This function can be used to retrieve all the tokenized domains name\n *\n * @param connection The solana connection object to the RPC node\n * @returns\n */\nconst retrieveNfts = async (connection) => {\n    const filters = [\n        {\n            memcmp: {\n                offset: 0,\n                bytes: \"3\",\n            },\n        },\n    ];\n    const result = await connection.getProgramAccounts(exports.NAME_TOKENIZER_ID, {\n        filters,\n    });\n    const offset = 1 + 1 + 32 + 32;\n    return result.map((e) => new web3_js_1.PublicKey(e.account.data.slice(offset, offset + 32)));\n};\nexports.retrieveNfts = retrieveNfts;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getPointRecord = exports.getSolRecord = exports.getShdwRecord = exports.getPicRecord = exports.getTelegramRecord = exports.getTwitterRecord = exports.getRedditRecord = exports.getGithubRecord = exports.getDiscordRecord = exports.getUrlRecord = exports.getEmailRecord = exports.getDogeRecord = exports.getLtcRecord = exports.getBtcRecord = exports.getEthRecord = exports.getArweaveRecord = exports.getIpfsRecord = exports.getRecord = void 0;\nconst record_1 = require(\"./types/record\");\nconst utils_1 = require(\"./utils\");\nconst state_1 = require(\"./state\");\n/**\n * This function can be used to retrieve a specified record for the given domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @param record The record to search for\n * @returns\n */\nconst getRecord = async (connection, domain, record) => {\n    var _a, _b;\n    const { pubkey } = await (0, utils_1.getDomainKey)(record + \".\" + domain, true);\n    let { registry } = await state_1.NameRegistryState.retrieve(connection, pubkey);\n    // Remove trailling 0s\n    const idx = (_a = registry.data) === null || _a === void 0 ? void 0 : _a.indexOf(0x00);\n    registry.data = (_b = registry.data) === null || _b === void 0 ? void 0 : _b.slice(0, idx);\n    return registry;\n};\nexports.getRecord = getRecord;\n/**\n * This function can be used to retrieve the IPFS record of a domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @returns\n */\nconst getIpfsRecord = async (connection, domain) => {\n    return await (0, exports.getRecord)(connection, domain, record_1.Record.IPFS);\n};\nexports.getIpfsRecord = getIpfsRecord;\n/**\n * This function can be used to retrieve the Arweave record of a domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @returns\n */\nconst getArweaveRecord = async (connection, domain) => {\n    return await (0, exports.getRecord)(connection, domain, record_1.Record.ARWV);\n};\nexports.getArweaveRecord = getArweaveRecord;\n/**\n * This function can be used to retrieve the ETH record of a domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @returns\n */\nconst getEthRecord = async (connection, domain) => {\n    return await (0, exports.getRecord)(connection, domain, record_1.Record.ETH);\n};\nexports.getEthRecord = getEthRecord;\n/**\n * This function can be used to retrieve the BTC record of a domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @returns\n */\nconst getBtcRecord = async (connection, domain) => {\n    return await (0, exports.getRecord)(connection, domain, record_1.Record.BTC);\n};\nexports.getBtcRecord = getBtcRecord;\n/**\n * This function can be used to retrieve the LTC record of a domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @returns\n */\nconst getLtcRecord = async (connection, domain) => {\n    return await (0, exports.getRecord)(connection, domain, record_1.Record.LTC);\n};\nexports.getLtcRecord = getLtcRecord;\n/**\n * This function can be used to retrieve the DOGE record of a domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @returns\n */\nconst getDogeRecord = async (connection, domain) => {\n    return await (0, exports.getRecord)(connection, domain, record_1.Record.DOGE);\n};\nexports.getDogeRecord = getDogeRecord;\n/**\n * This function can be used to retrieve the email record of a domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @returns\n */\nconst getEmailRecord = async (connection, domain) => {\n    return await (0, exports.getRecord)(connection, domain, record_1.Record.Email);\n};\nexports.getEmailRecord = getEmailRecord;\n/**\n * This function can be used to retrieve the URL record of a domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @returns\n */\nconst getUrlRecord = async (connection, domain) => {\n    return await (0, exports.getRecord)(connection, domain, record_1.Record.Url);\n};\nexports.getUrlRecord = getUrlRecord;\n/**\n * This function can be used to retrieve the Discord record of a domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @returns\n */\nconst getDiscordRecord = async (connection, domain) => {\n    return await (0, exports.getRecord)(connection, domain, record_1.Record.Discord);\n};\nexports.getDiscordRecord = getDiscordRecord;\n/**\n * This function can be used to retrieve the Github record of a domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @returns\n */\nconst getGithubRecord = async (connection, domain) => {\n    return await (0, exports.getRecord)(connection, domain, record_1.Record.Github);\n};\nexports.getGithubRecord = getGithubRecord;\n/**\n * This function can be used to retrieve the Reddit record of a domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @returns\n */\nconst getRedditRecord = async (connection, domain) => {\n    return await (0, exports.getRecord)(connection, domain, record_1.Record.Reddit);\n};\nexports.getRedditRecord = getRedditRecord;\n/**\n * This function can be used to retrieve the Twitter record of a domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @returns\n */\nconst getTwitterRecord = async (connection, domain) => {\n    return await (0, exports.getRecord)(connection, domain, record_1.Record.Twitter);\n};\nexports.getTwitterRecord = getTwitterRecord;\n/**\n * This function can be used to retrieve the Telegram record of a domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @returns\n */\nconst getTelegramRecord = async (connection, domain) => {\n    return await (0, exports.getRecord)(connection, domain, record_1.Record.Telegram);\n};\nexports.getTelegramRecord = getTelegramRecord;\n/**\n * This function can be used to retrieve the pic record of a domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @returns\n */\nconst getPicRecord = async (connection, domain) => {\n    return await (0, exports.getRecord)(connection, domain, record_1.Record.Pic);\n};\nexports.getPicRecord = getPicRecord;\n/**\n * This function can be used to retrieve the SHDW record of a domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @returns\n */\nconst getShdwRecord = async (connection, domain) => {\n    return await (0, exports.getRecord)(connection, domain, record_1.Record.SHDW);\n};\nexports.getShdwRecord = getShdwRecord;\n/**\n * This function can be used to retrieve the SOL record of a domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @returns\n */\nconst getSolRecord = async (connection, domain) => {\n    return await (0, exports.getRecord)(connection, domain, record_1.Record.SOL);\n};\nexports.getSolRecord = getSolRecord;\n/**\n * This function can be used to retrieve the POINT record of a domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @returns\n */\nconst getPointRecord = async (connection, domain) => {\n    return await (0, exports.getRecord)(connection, domain, record_1.Record.POINT);\n};\nexports.getPointRecord = getPointRecord;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolve = exports.checkSolRecord = void 0;\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst record_1 = require(\"./record\");\nconst utils_1 = require(\"./utils\");\nconst state_1 = require(\"./state\");\nconst tweetnacl_1 = require(\"tweetnacl\");\nconst record_2 = require(\"./types/record\");\n/**\n * This function can be used to verify the validity of a SOL record\n * @param record The record data to verify\n * @param signedRecord The signed data\n * @param pubkey The public key of the signer\n * @returns\n */\nconst checkSolRecord = (record, signedRecord, pubkey) => {\n    return tweetnacl_1.sign.detached.verify(record, signedRecord, pubkey.toBytes());\n};\nexports.checkSolRecord = checkSolRecord;\n/**\n * This function can be used to resolve a domain name to transfer funds\n * @param connection The Solana RPC connection object\n * @param domain The domain to resolve\n * @returns\n */\nconst resolve = async (connection, domain) => {\n    var _a;\n    const { pubkey } = await (0, utils_1.getDomainKey)(domain);\n    const { registry, nftOwner } = await state_1.NameRegistryState.retrieve(connection, pubkey);\n    if (nftOwner) {\n        return nftOwner;\n    }\n    try {\n        const recordKey = await (0, utils_1.getDomainKey)(record_2.Record.SOL + \".\" + domain, true);\n        const solRecord = await (0, record_1.getSolRecord)(connection, domain);\n        if (((_a = solRecord.data) === null || _a === void 0 ? void 0 : _a.length) !== 96) {\n            throw new Error(\"Invalid SOL record data\");\n        }\n        const encoder = new TextEncoder();\n        const expectedBuffer = Buffer.concat([\n            solRecord.data.slice(0, 32),\n            recordKey.pubkey.toBuffer(),\n        ]);\n        const expected = encoder.encode(expectedBuffer.toString(\"hex\"));\n        const valid = (0, exports.checkSolRecord)(expected, solRecord.data.slice(32), registry.owner);\n        if (!valid) {\n            throw new Error(\"Signature invalid\");\n        }\n        return new web3_js_1.PublicKey(solRecord.data.slice(0, 32));\n    }\n    catch (err) {\n        console.log(err);\n    }\n    return registry.owner;\n};\nexports.resolve = resolve;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Mint = exports.TokenData = exports.NameRegistryState = void 0;\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst borsh_1 = require(\"borsh\");\nconst nft_1 = require(\"./nft\");\nclass NameRegistryState {\n    constructor(obj) {\n        this.parentName = new web3_js_1.PublicKey(obj.parentName);\n        this.owner = new web3_js_1.PublicKey(obj.owner);\n        this.class = new web3_js_1.PublicKey(obj.class);\n    }\n    static async retrieve(connection, nameAccountKey) {\n        var _a;\n        const nameAccount = await connection.getAccountInfo(nameAccountKey);\n        if (!nameAccount) {\n            throw new Error(\"Invalid name account provided\");\n        }\n        let res = (0, borsh_1.deserializeUnchecked)(this.schema, NameRegistryState, nameAccount.data);\n        res.data = (_a = nameAccount.data) === null || _a === void 0 ? void 0 : _a.slice(this.HEADER_LEN);\n        const nftOwner = await (0, nft_1.retrieveNftOwner)(connection, nameAccountKey);\n        return { registry: res, nftOwner };\n    }\n    static async _retrieveBatch(connection, nameAccountKeys) {\n        const nameAccounts = await connection.getMultipleAccountsInfo(nameAccountKeys);\n        const fn = (data) => {\n            if (!data)\n                return undefined;\n            const res = (0, borsh_1.deserializeUnchecked)(this.schema, NameRegistryState, data);\n            res.data = data === null || data === void 0 ? void 0 : data.slice(this.HEADER_LEN);\n            return res;\n        };\n        return nameAccounts.map((e) => fn(e === null || e === void 0 ? void 0 : e.data));\n    }\n    static async retrieveBatch(connection, nameAccountKeys) {\n        let result = [];\n        while (nameAccountKeys.length > 0) {\n            result.push(...(await this._retrieveBatch(connection, nameAccountKeys.splice(0, 100))));\n        }\n        return result;\n    }\n}\nexports.NameRegistryState = NameRegistryState;\nNameRegistryState.HEADER_LEN = 96;\nNameRegistryState.schema = new Map([\n    [\n        NameRegistryState,\n        {\n            kind: \"struct\",\n            fields: [\n                [\"parentName\", [32]],\n                [\"owner\", [32]],\n                [\"class\", [32]],\n            ],\n        },\n    ],\n]);\nclass TokenData {\n    constructor(obj) {\n        this.name = obj.name;\n        this.ticker = obj.ticker;\n        this.mint = obj.mint;\n        this.decimals = obj.decimals;\n        this.website = obj === null || obj === void 0 ? void 0 : obj.website;\n        this.logoUri = obj === null || obj === void 0 ? void 0 : obj.logoUri;\n    }\n    serialize() {\n        return (0, borsh_1.serialize)(TokenData.schema, this);\n    }\n    static deserialize(data) {\n        return (0, borsh_1.deserializeUnchecked)(TokenData.schema, TokenData, data);\n    }\n}\nexports.TokenData = TokenData;\nTokenData.schema = new Map([\n    [\n        TokenData,\n        {\n            kind: \"struct\",\n            fields: [\n                [\"name\", \"string\"],\n                [\"ticker\", \"string\"],\n                [\"mint\", [32]],\n                [\"decimals\", \"u8\"],\n                [\"website\", { kind: \"option\", type: \"string\" }],\n                [\"logoUri\", { kind: \"option\", type: \"string\" }],\n            ],\n        },\n    ],\n]);\nclass Mint {\n    constructor(obj) {\n        this.mint = obj.mint;\n    }\n    serialize() {\n        return (0, borsh_1.serialize)(Mint.schema, this);\n    }\n    static deserialize(data) {\n        return (0, borsh_1.deserializeUnchecked)(Mint.schema, Mint, data);\n    }\n}\nexports.Mint = Mint;\nMint.schema = new Map([\n    [\n        Mint,\n        {\n            kind: \"struct\",\n            fields: [[\"mint\", [32]]],\n        },\n    ],\n]);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getTokenInfoFromName = exports.getTokenInfoFromMint = exports.TOKEN_TLD = void 0;\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst utils_1 = require(\"./utils\");\nconst state_1 = require(\"./state\");\nexports.TOKEN_TLD = new web3_js_1.PublicKey(\"6NSu2tci4apRKQtt257bAVcvqYjB3zV2H1dWo56vgpa6\");\nconst getTokenInfoFromMint = async (connection, mint) => {\n    const nameKey = await (0, utils_1.getNameAccountKey)(await (0, utils_1.getHashedName)(mint.toBase58()), undefined, exports.TOKEN_TLD);\n    const { registry } = await state_1.NameRegistryState.retrieve(connection, nameKey);\n    if (!registry.data) {\n        throw new Error(\"Invalid account data\");\n    }\n    return state_1.TokenData.deserialize(registry.data);\n};\nexports.getTokenInfoFromMint = getTokenInfoFromMint;\nconst getTokenInfoFromName = async (connection, name) => {\n    const reverseNameKey = await (0, utils_1.getNameAccountKey)(await (0, utils_1.getHashedName)(name), undefined, exports.TOKEN_TLD);\n    const { registry: reverseRegistry } = await state_1.NameRegistryState.retrieve(connection, reverseNameKey);\n    if (!reverseRegistry.data) {\n        throw new Error(\"Invalid account data\");\n    }\n    const mint = new web3_js_1.PublicKey(state_1.Mint.deserialize(reverseRegistry.data).mint);\n    return await (0, exports.getTokenInfoFromMint)(connection, mint);\n};\nexports.getTokenInfoFromName = getTokenInfoFromName;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createReverseTwitterRegistry = exports.ReverseTwitterRegistryState = exports.getTwitterRegistryData = exports.getTwitterHandleandRegistryKeyViaFilters = exports.getHandleAndRegistryKey = exports.getTwitterRegistry = exports.getTwitterRegistryKey = exports.deleteTwitterRegistry = exports.changeVerifiedPubkey = exports.changeTwitterRegistryData = exports.createVerifiedTwitterRegistry = void 0;\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst constants_1 = require(\"./constants\");\nconst bindings_1 = require(\"./bindings\");\nconst instructions_1 = require(\"./instructions\");\nconst state_1 = require(\"./state\");\nconst utils_1 = require(\"./utils\");\nconst int_1 = require(\"./int\");\nconst borsh_1 = require(\"borsh\");\n////////////////////////////////////////////////////\n// Bindings\n// Signed by the authority, the payer and the verified pubkey\nasync function createVerifiedTwitterRegistry(connection, twitterHandle, verifiedPubkey, space, // The space that the user will have to write data into the verified registry\npayerKey) {\n    // Create user facing registry\n    const hashedTwitterHandle = await (0, utils_1.getHashedName)(twitterHandle);\n    const twitterHandleRegistryKey = await (0, utils_1.getNameAccountKey)(hashedTwitterHandle, undefined, constants_1.TWITTER_ROOT_PARENT_REGISTRY_KEY);\n    const lamports = await connection.getMinimumBalanceForRentExemption(space + state_1.NameRegistryState.HEADER_LEN);\n    let instructions = [\n        (0, instructions_1.createInstruction)(constants_1.NAME_PROGRAM_ID, web3_js_1.SystemProgram.programId, twitterHandleRegistryKey, verifiedPubkey, payerKey, hashedTwitterHandle, \n        //@ts-ignore\n        new int_1.Numberu64(lamports), \n        //@ts-ignore\n        new int_1.Numberu32(space), undefined, constants_1.TWITTER_ROOT_PARENT_REGISTRY_KEY, constants_1.TWITTER_VERIFICATION_AUTHORITY // Twitter authority acts as owner of the parent for all user-facing registries\n        ),\n    ];\n    instructions = instructions.concat(await createReverseTwitterRegistry(connection, twitterHandle, twitterHandleRegistryKey, verifiedPubkey, payerKey));\n    return instructions;\n}\nexports.createVerifiedTwitterRegistry = createVerifiedTwitterRegistry;\n// Overwrite the data that is written in the user facing registry\n// Signed by the verified pubkey\nasync function changeTwitterRegistryData(twitterHandle, verifiedPubkey, offset, // The offset at which to write the input data into the NameRegistryData\ninput_data) {\n    const hashedTwitterHandle = await (0, utils_1.getHashedName)(twitterHandle);\n    const twitterHandleRegistryKey = await (0, utils_1.getNameAccountKey)(hashedTwitterHandle, undefined, constants_1.TWITTER_ROOT_PARENT_REGISTRY_KEY);\n    const instructions = [\n        (0, instructions_1.updateInstruction)(constants_1.NAME_PROGRAM_ID, twitterHandleRegistryKey, \n        //@ts-ignore\n        new int_1.Numberu32(offset), input_data, verifiedPubkey),\n    ];\n    return instructions;\n}\nexports.changeTwitterRegistryData = changeTwitterRegistryData;\n// Change the verified pubkey for a given twitter handle\n// Signed by the Authority, the verified pubkey and the payer\nasync function changeVerifiedPubkey(connection, twitterHandle, currentVerifiedPubkey, newVerifiedPubkey, payerKey) {\n    const hashedTwitterHandle = await (0, utils_1.getHashedName)(twitterHandle);\n    const twitterHandleRegistryKey = await (0, utils_1.getNameAccountKey)(hashedTwitterHandle, undefined, constants_1.TWITTER_ROOT_PARENT_REGISTRY_KEY);\n    // Transfer the user-facing registry ownership\n    let instructions = [\n        (0, instructions_1.transferInstruction)(constants_1.NAME_PROGRAM_ID, twitterHandleRegistryKey, newVerifiedPubkey, currentVerifiedPubkey, undefined),\n    ];\n    // Delete the current reverse registry\n    const currentHashedVerifiedPubkey = await (0, utils_1.getHashedName)(currentVerifiedPubkey.toString());\n    const currentReverseRegistryKey = await (0, utils_1.getNameAccountKey)(currentHashedVerifiedPubkey, constants_1.TWITTER_VERIFICATION_AUTHORITY, undefined);\n    instructions.push(await (0, bindings_1.deleteNameRegistry)(connection, currentVerifiedPubkey.toString(), payerKey, constants_1.TWITTER_VERIFICATION_AUTHORITY, constants_1.TWITTER_ROOT_PARENT_REGISTRY_KEY));\n    // Create the new reverse registry\n    instructions = instructions.concat(await createReverseTwitterRegistry(connection, twitterHandle, twitterHandleRegistryKey, newVerifiedPubkey, payerKey));\n    return instructions;\n}\nexports.changeVerifiedPubkey = changeVerifiedPubkey;\n// Delete the verified registry for a given twitter handle\n// Signed by the verified pubkey\nasync function deleteTwitterRegistry(twitterHandle, verifiedPubkey) {\n    const hashedTwitterHandle = await (0, utils_1.getHashedName)(twitterHandle);\n    const twitterHandleRegistryKey = await (0, utils_1.getNameAccountKey)(hashedTwitterHandle, undefined, constants_1.TWITTER_ROOT_PARENT_REGISTRY_KEY);\n    const hashedVerifiedPubkey = await (0, utils_1.getHashedName)(verifiedPubkey.toString());\n    const reverseRegistryKey = await (0, utils_1.getNameAccountKey)(hashedVerifiedPubkey, constants_1.TWITTER_VERIFICATION_AUTHORITY, constants_1.TWITTER_ROOT_PARENT_REGISTRY_KEY);\n    const instructions = [\n        // Delete the user facing registry\n        (0, instructions_1.deleteInstruction)(constants_1.NAME_PROGRAM_ID, twitterHandleRegistryKey, verifiedPubkey, verifiedPubkey),\n        // Delete the reverse registry\n        (0, instructions_1.deleteInstruction)(constants_1.NAME_PROGRAM_ID, reverseRegistryKey, verifiedPubkey, verifiedPubkey),\n    ];\n    return instructions;\n}\nexports.deleteTwitterRegistry = deleteTwitterRegistry;\n//////////////////////////////////////////\n// Getter Functions\n// Returns the key of the user-facing registry\nasync function getTwitterRegistryKey(twitter_handle) {\n    const hashedTwitterHandle = await (0, utils_1.getHashedName)(twitter_handle);\n    return await (0, utils_1.getNameAccountKey)(hashedTwitterHandle, undefined, constants_1.TWITTER_ROOT_PARENT_REGISTRY_KEY);\n}\nexports.getTwitterRegistryKey = getTwitterRegistryKey;\nasync function getTwitterRegistry(connection, twitter_handle) {\n    const hashedTwitterHandle = await (0, utils_1.getHashedName)(twitter_handle);\n    const twitterHandleRegistryKey = await (0, utils_1.getNameAccountKey)(hashedTwitterHandle, undefined, constants_1.TWITTER_ROOT_PARENT_REGISTRY_KEY);\n    const { registry } = await state_1.NameRegistryState.retrieve(connection, twitterHandleRegistryKey);\n    return registry;\n}\nexports.getTwitterRegistry = getTwitterRegistry;\nasync function getHandleAndRegistryKey(connection, verifiedPubkey) {\n    const hashedVerifiedPubkey = await (0, utils_1.getHashedName)(verifiedPubkey.toString());\n    const reverseRegistryKey = await (0, utils_1.getNameAccountKey)(hashedVerifiedPubkey, constants_1.TWITTER_VERIFICATION_AUTHORITY, constants_1.TWITTER_ROOT_PARENT_REGISTRY_KEY);\n    let reverseRegistryState = await ReverseTwitterRegistryState.retrieve(connection, reverseRegistryKey);\n    return [\n        reverseRegistryState.twitterHandle,\n        new web3_js_1.PublicKey(reverseRegistryState.twitterRegistryKey),\n    ];\n}\nexports.getHandleAndRegistryKey = getHandleAndRegistryKey;\n// Uses the RPC node filtering feature, execution speed may vary\nasync function getTwitterHandleandRegistryKeyViaFilters(connection, verifiedPubkey) {\n    const filters = [\n        {\n            memcmp: {\n                offset: 0,\n                bytes: constants_1.TWITTER_ROOT_PARENT_REGISTRY_KEY.toBase58(),\n            },\n        },\n        {\n            memcmp: {\n                offset: 32,\n                bytes: verifiedPubkey.toBase58(),\n            },\n        },\n        {\n            memcmp: {\n                offset: 64,\n                bytes: constants_1.TWITTER_VERIFICATION_AUTHORITY.toBase58(),\n            },\n        },\n    ];\n    const filteredAccounts = await connection.getProgramAccounts(constants_1.NAME_PROGRAM_ID, { filters });\n    for (const f of filteredAccounts) {\n        if (f.account.data.length > state_1.NameRegistryState.HEADER_LEN + 32) {\n            let data = f.account.data.slice(state_1.NameRegistryState.HEADER_LEN);\n            let state = (0, borsh_1.deserializeUnchecked)(ReverseTwitterRegistryState.schema, ReverseTwitterRegistryState, data);\n            return [state.twitterHandle, new web3_js_1.PublicKey(state.twitterRegistryKey)];\n        }\n    }\n    throw new Error(\"Registry not found.\");\n}\nexports.getTwitterHandleandRegistryKeyViaFilters = getTwitterHandleandRegistryKeyViaFilters;\n// Uses the RPC node filtering feature, execution speed may vary\n// Does not give you the handle, but is an alternative to getHandlesAndKeysFromVerifiedPubkey + getTwitterRegistry to get the data\nasync function getTwitterRegistryData(connection, verifiedPubkey) {\n    const filters = [\n        {\n            memcmp: {\n                offset: 0,\n                bytes: constants_1.TWITTER_ROOT_PARENT_REGISTRY_KEY.toBase58(),\n            },\n        },\n        {\n            memcmp: {\n                offset: 32,\n                bytes: verifiedPubkey.toBase58(),\n            },\n        },\n        {\n            memcmp: {\n                offset: 64,\n                bytes: new web3_js_1.PublicKey(Buffer.alloc(32, 0)).toBase58(),\n            },\n        },\n    ];\n    const filteredAccounts = await connection.getProgramAccounts(constants_1.NAME_PROGRAM_ID, { filters });\n    if (filteredAccounts.length > 1) {\n        throw new Error(\"Found more than one registry.\");\n    }\n    return filteredAccounts[0].account.data.slice(state_1.NameRegistryState.HEADER_LEN);\n}\nexports.getTwitterRegistryData = getTwitterRegistryData;\n//////////////////////////////////////////////\n// Utils\nclass ReverseTwitterRegistryState {\n    constructor(obj) {\n        this.twitterRegistryKey = obj.twitterRegistryKey;\n        this.twitterHandle = obj.twitterHandle;\n    }\n    static async retrieve(connection, reverseTwitterAccountKey) {\n        let reverseTwitterAccount = await connection.getAccountInfo(reverseTwitterAccountKey, \"processed\");\n        if (!reverseTwitterAccount) {\n            throw new Error(\"Invalid reverse Twitter account provided\");\n        }\n        let res = (0, borsh_1.deserializeUnchecked)(this.schema, ReverseTwitterRegistryState, reverseTwitterAccount.data.slice(state_1.NameRegistryState.HEADER_LEN));\n        return res;\n    }\n}\nexports.ReverseTwitterRegistryState = ReverseTwitterRegistryState;\nReverseTwitterRegistryState.schema = new Map([\n    [\n        ReverseTwitterRegistryState,\n        {\n            kind: \"struct\",\n            fields: [\n                [\"twitterRegistryKey\", [32]],\n                [\"twitterHandle\", \"string\"],\n            ],\n        },\n    ],\n]);\nasync function createReverseTwitterRegistry(connection, twitterHandle, twitterRegistryKey, verifiedPubkey, payerKey) {\n    // Create the reverse lookup registry\n    const hashedVerifiedPubkey = await (0, utils_1.getHashedName)(verifiedPubkey.toString());\n    const reverseRegistryKey = await (0, utils_1.getNameAccountKey)(hashedVerifiedPubkey, constants_1.TWITTER_VERIFICATION_AUTHORITY, constants_1.TWITTER_ROOT_PARENT_REGISTRY_KEY);\n    let reverseTwitterRegistryStateBuff = (0, borsh_1.serialize)(ReverseTwitterRegistryState.schema, new ReverseTwitterRegistryState({\n        twitterRegistryKey: twitterRegistryKey.toBytes(),\n        twitterHandle,\n    }));\n    return [\n        (0, instructions_1.createInstruction)(constants_1.NAME_PROGRAM_ID, web3_js_1.SystemProgram.programId, reverseRegistryKey, verifiedPubkey, payerKey, hashedVerifiedPubkey, new int_1.Numberu64(\n        //@ts-ignore\n        await connection.getMinimumBalanceForRentExemption(reverseTwitterRegistryStateBuff.length + state_1.NameRegistryState.HEADER_LEN)), \n        //@ts-ignore\n        new int_1.Numberu32(reverseTwitterRegistryStateBuff.length), constants_1.TWITTER_VERIFICATION_AUTHORITY, // Twitter authority acts as class for all reverse-lookup registries\n        constants_1.TWITTER_ROOT_PARENT_REGISTRY_KEY, // Reverse registries are also children of the root\n        constants_1.TWITTER_VERIFICATION_AUTHORITY),\n        (0, instructions_1.updateInstruction)(constants_1.NAME_PROGRAM_ID, reverseRegistryKey, \n        //@ts-ignore\n        new int_1.Numberu32(0), Buffer.from(reverseTwitterRegistryStateBuff), constants_1.TWITTER_VERIFICATION_AUTHORITY),\n    ];\n}\nexports.createReverseTwitterRegistry = createReverseTwitterRegistry;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Record = void 0;\n/**\n * List of SNS Records\n */\nvar Record;\n(function (Record) {\n    Record[\"IPFS\"] = \"IPFS\";\n    Record[\"ARWV\"] = \"ARWV\";\n    Record[\"SOL\"] = \"SOL\";\n    Record[\"ETH\"] = \"ETH\";\n    Record[\"BTC\"] = \"BTC\";\n    Record[\"LTC\"] = \"LTC\";\n    Record[\"DOGE\"] = \"DOGE\";\n    Record[\"Email\"] = \"email\";\n    Record[\"Url\"] = \"url\";\n    Record[\"Discord\"] = \"discord\";\n    Record[\"Github\"] = \"github\";\n    Record[\"Reddit\"] = \"reddit\";\n    Record[\"Twitter\"] = \"twitter\";\n    Record[\"Telegram\"] = \"telegram\";\n    Record[\"Pic\"] = \"pic\";\n    Record[\"SHDW\"] = \"SHDW\";\n    Record[\"POINT\"] = \"POINT\";\n})(Record = exports.Record || (exports.Record = {}));\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getAllRegisteredDomains = exports.getAllDomains = exports.getDomainKey = exports.findSubdomains = exports.performReverseLookupBatch = exports.getDNSRecordAddress = exports.performReverseLookup = exports.getNameAccountKey = exports.getHashedName = exports.getNameOwner = void 0;\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst sha2_1 = require(\"@ethersproject/sha2\");\nconst constants_1 = require(\"./constants\");\nconst state_1 = require(\"./state\");\nconst constants_2 = require(\"./constants\");\nasync function getNameOwner(connection, nameAccountKey) {\n    const nameAccount = await connection.getAccountInfo(nameAccountKey);\n    if (!nameAccount) {\n        throw new Error(\"Unable to find the given account.\");\n    }\n    return state_1.NameRegistryState.retrieve(connection, nameAccountKey);\n}\nexports.getNameOwner = getNameOwner;\nasync function getHashedName(name) {\n    const input = constants_1.HASH_PREFIX + name;\n    const str = (0, sha2_1.sha256)(Buffer.from(input, \"utf8\")).slice(2);\n    return Buffer.from(str, \"hex\");\n}\nexports.getHashedName = getHashedName;\nasync function getNameAccountKey(hashed_name, nameClass, nameParent) {\n    const seeds = [hashed_name];\n    if (nameClass) {\n        seeds.push(nameClass.toBuffer());\n    }\n    else {\n        seeds.push(Buffer.alloc(32));\n    }\n    if (nameParent) {\n        seeds.push(nameParent.toBuffer());\n    }\n    else {\n        seeds.push(Buffer.alloc(32));\n    }\n    const [nameAccountKey] = await web3_js_1.PublicKey.findProgramAddress(seeds, constants_1.NAME_PROGRAM_ID);\n    return nameAccountKey;\n}\nexports.getNameAccountKey = getNameAccountKey;\nasync function performReverseLookup(connection, nameAccount) {\n    const hashedReverseLookup = await getHashedName(nameAccount.toBase58());\n    const reverseLookupAccount = await getNameAccountKey(hashedReverseLookup, constants_2.REVERSE_LOOKUP_CLASS);\n    const { registry } = await state_1.NameRegistryState.retrieve(connection, reverseLookupAccount);\n    if (!registry.data) {\n        throw \"Could not retrieve name data\";\n    }\n    const nameLength = new bn_js_1.default(registry.data.slice(0, 4), \"le\").toNumber();\n    return registry.data.slice(4, 4 + nameLength).toString();\n}\nexports.performReverseLookup = performReverseLookup;\nasync function getDNSRecordAddress(nameAccount, type) {\n    const hashedName = await getHashedName(\"\\0\".concat(type));\n    const recordAccount = await getNameAccountKey(hashedName, undefined, nameAccount);\n    return recordAccount;\n}\nexports.getDNSRecordAddress = getDNSRecordAddress;\nasync function performReverseLookupBatch(connection, nameAccounts) {\n    let reverseLookupAccounts = [];\n    for (let nameAccount of nameAccounts) {\n        const hashedReverseLookup = await getHashedName(nameAccount.toBase58());\n        const reverseLookupAccount = await getNameAccountKey(hashedReverseLookup, constants_2.REVERSE_LOOKUP_CLASS);\n        reverseLookupAccounts.push(reverseLookupAccount);\n    }\n    let names = await state_1.NameRegistryState.retrieveBatch(connection, reverseLookupAccounts);\n    return names.map((name) => {\n        if (name === undefined || name.data === undefined) {\n            return undefined;\n        }\n        let nameLength = new bn_js_1.default(name.data.slice(0, 4), \"le\").toNumber();\n        return name.data.slice(4, 4 + nameLength).toString();\n    });\n}\nexports.performReverseLookupBatch = performReverseLookupBatch;\n/**\n *\n * @param connection The Solana RPC connection object\n * @param parentKey The parent you want to find sub-domains for\n * @returns\n */\nconst findSubdomains = async (connection, parentKey) => {\n    const filters = [\n        {\n            memcmp: {\n                offset: 0,\n                bytes: parentKey.toBase58(),\n            },\n        },\n        {\n            memcmp: {\n                offset: 64,\n                bytes: constants_2.REVERSE_LOOKUP_CLASS.toBase58(),\n            },\n        },\n    ];\n    const result = await connection.getProgramAccounts(constants_1.NAME_PROGRAM_ID, {\n        filters,\n    });\n    return result.map((e) => { var _a; return (_a = e.account.data.slice(97).toString(\"utf-8\")) === null || _a === void 0 ? void 0 : _a.split(\"\\0\").join(\"\"); });\n};\nexports.findSubdomains = findSubdomains;\nconst _derive = async (name, parent = constants_1.ROOT_DOMAIN_ACCOUNT) => {\n    let hashed = await getHashedName(name);\n    let pubkey = await getNameAccountKey(hashed, undefined, parent);\n    return { pubkey, hashed };\n};\n/**\n * This function can be used to compute the public key of a domain or subdomain\n * @param domain The domain to compute the public key for (e.g `bonfida.sol`, `dex.bonfida.sol`)\n * @returns\n */\nconst getDomainKey = async (domain, record = false) => {\n    if (domain.endsWith(\".sol\")) {\n        domain = domain.slice(0, -4);\n    }\n    const splitted = domain.split(\".\");\n    if (splitted.length === 2) {\n        const prefix = Buffer.from([record ? 1 : 0]).toString();\n        const sub = prefix.concat(splitted[0]);\n        const { pubkey: parentKey } = await _derive(splitted[1]);\n        const result = await _derive(sub, parentKey);\n        return { ...result, isSub: true, parent: parentKey };\n    }\n    else if (splitted.length > 2) {\n        throw new Error(\"Invalid derivation input\");\n    }\n    const result = await _derive(domain, constants_1.ROOT_DOMAIN_ACCOUNT);\n    return { ...result, isSub: false, parent: undefined };\n};\nexports.getDomainKey = getDomainKey;\n/**\n * This function can be used to retrieve all domain names owned by `wallet`\n * @param connection The Solana RPC connection object\n * @param wallet The wallet you want to search domain names for\n * @returns\n */\nasync function getAllDomains(connection, wallet) {\n    const filters = [\n        {\n            memcmp: {\n                offset: 32,\n                bytes: wallet.toBase58(),\n            },\n        },\n        {\n            memcmp: {\n                offset: 0,\n                bytes: constants_1.ROOT_DOMAIN_ACCOUNT.toBase58(),\n            },\n        },\n    ];\n    const accounts = await connection.getProgramAccounts(constants_1.NAME_PROGRAM_ID, {\n        filters,\n    });\n    return accounts.map((a) => a.pubkey);\n}\nexports.getAllDomains = getAllDomains;\n/**\n * This function can be used to retrieve all the registered `.sol` domains.\n * The account data is sliced to avoid enormous payload and only the owner is returned\n * @param connection The Solana RPC connection object\n * @returns\n */\nconst getAllRegisteredDomains = async (connection) => {\n    const filters = [\n        {\n            memcmp: {\n                offset: 0,\n                bytes: constants_1.ROOT_DOMAIN_ACCOUNT.toBase58(),\n            },\n        },\n    ];\n    const dataSlice = { offset: 32, length: 32 };\n    const accounts = await connection.getProgramAccounts(constants_1.NAME_PROGRAM_ID, {\n        dataSlice,\n        filters,\n    });\n    return accounts;\n};\nexports.getAllRegisteredDomains = getAllRegisteredDomains;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.registerDomainName = exports.deleteNameRegistry = exports.transferNameOwnership = exports.updateNameRegistryData = exports.createNameRegistry = void 0;\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst instructions_1 = require(\"./instructions\");\nconst state_1 = require(\"./state\");\nconst int_1 = require(\"./int\");\nconst utils_1 = require(\"./utils\");\nconst constants_1 = require(\"./constants\");\n/**\n * Creates a name account with the given rent budget, allocated space, owner and class.\n *\n * @param connection The solana connection object to the RPC node\n * @param name The name of the new account\n * @param space The space in bytes allocated to the account\n * @param payerKey The allocation cost payer\n * @param nameOwner The pubkey to be set as owner of the new name account\n * @param lamports The budget to be set for the name account. If not specified, it'll be the minimum for rent exemption\n * @param nameClass The class of this new name\n * @param parentName The parent name of the new name. If specified its owner needs to sign\n * @returns\n */\nasync function createNameRegistry(connection, name, space, payerKey, nameOwner, lamports, nameClass, parentName) {\n    const hashed_name = await (0, utils_1.getHashedName)(name);\n    const nameAccountKey = await (0, utils_1.getNameAccountKey)(hashed_name, nameClass, parentName);\n    const balance = lamports\n        ? lamports\n        : await connection.getMinimumBalanceForRentExemption(space);\n    let nameParentOwner;\n    if (parentName) {\n        const { registry: parentAccount } = await (0, utils_1.getNameOwner)(connection, parentName);\n        nameParentOwner = parentAccount.owner;\n    }\n    const createNameInstr = (0, instructions_1.createInstruction)(constants_1.NAME_PROGRAM_ID, web3_js_1.SystemProgram.programId, nameAccountKey, nameOwner, payerKey, hashed_name, \n    //@ts-ignore\n    new int_1.Numberu64(balance), \n    //@ts-ignore\n    new int_1.Numberu32(space), nameClass, parentName, nameParentOwner);\n    return createNameInstr;\n}\nexports.createNameRegistry = createNameRegistry;\n/**\n * Overwrite the data of the given name registry.\n *\n * @param connection The solana connection object to the RPC node\n * @param name The name of the name registry to update\n * @param offset The offset to which the data should be written into the registry\n * @param input_data The data to be written\n * @param nameClass The class of this name, if it exsists\n * @param nameParent The parent name of this name, if it exists\n */\nasync function updateNameRegistryData(connection, name, offset, input_data, nameClass, nameParent) {\n    const hashed_name = await (0, utils_1.getHashedName)(name);\n    const nameAccountKey = await (0, utils_1.getNameAccountKey)(hashed_name, nameClass, nameParent);\n    let signer;\n    if (nameClass) {\n        signer = nameClass;\n    }\n    else {\n        signer = (await state_1.NameRegistryState.retrieve(connection, nameAccountKey))\n            .registry.owner;\n    }\n    const updateInstr = (0, instructions_1.updateInstruction)(constants_1.NAME_PROGRAM_ID, nameAccountKey, \n    //@ts-ignore\n    new int_1.Numberu32(offset), input_data, signer);\n    return updateInstr;\n}\nexports.updateNameRegistryData = updateNameRegistryData;\n/**\n * Change the owner of a given name account.\n *\n * @param connection The solana connection object to the RPC node\n * @param name The name of the name account\n * @param newOwner The new owner to be set\n * @param curentNameOwner the current name Owner\n * @param nameClass The class of this name, if it exsists\n * @param nameParent The parent name of this name, if it exists\n * @param parentOwner Parent name owner\n * @returns\n */\nasync function transferNameOwnership(connection, name, newOwner, nameClass, nameParent, parentOwner) {\n    const hashed_name = await (0, utils_1.getHashedName)(name);\n    const nameAccountKey = await (0, utils_1.getNameAccountKey)(hashed_name, nameClass, nameParent);\n    let curentNameOwner;\n    if (nameClass) {\n        curentNameOwner = nameClass;\n    }\n    else {\n        curentNameOwner = (await state_1.NameRegistryState.retrieve(connection, nameAccountKey)).registry.owner;\n    }\n    const transferInstr = (0, instructions_1.transferInstruction)(constants_1.NAME_PROGRAM_ID, nameAccountKey, newOwner, curentNameOwner, nameClass, nameParent, parentOwner);\n    return transferInstr;\n}\nexports.transferNameOwnership = transferNameOwnership;\n/**\n * Delete the name account and transfer the rent to the target.\n *\n * @param connection The solana connection object to the RPC node\n * @param name The name of the name account\n * @param refundTargetKey The refund destination address\n * @param nameClass The class of this name, if it exsists\n * @param nameParent The parent name of this name, if it exists\n * @returns\n */\nasync function deleteNameRegistry(connection, name, refundTargetKey, nameClass, nameParent) {\n    const hashed_name = await (0, utils_1.getHashedName)(name);\n    const nameAccountKey = await (0, utils_1.getNameAccountKey)(hashed_name, nameClass, nameParent);\n    let nameOwner;\n    if (nameClass) {\n        nameOwner = nameClass;\n    }\n    else {\n        nameOwner = (await state_1.NameRegistryState.retrieve(connection, nameAccountKey))\n            .registry.owner;\n    }\n    const changeAuthoritiesInstr = (0, instructions_1.deleteInstruction)(constants_1.NAME_PROGRAM_ID, nameAccountKey, refundTargetKey, nameOwner);\n    return changeAuthoritiesInstr;\n}\nexports.deleteNameRegistry = deleteNameRegistry;\n/**\n * This function can be used to register a .sol domain\n * @param name The domain name to register e.g bonfida if you want to register bonfida.sol\n * @param space The domain name account size (max 10kB)\n * @param buyer The public key of the buyer\n * @param buyerTokenAccount The buyer FIDA token account\n * @returns\n */\nconst registerDomainName = async (name, space, buyer, buyerTokenAccount) => {\n    const [centralState] = await web3_js_1.PublicKey.findProgramAddress([constants_1.REGISTER_PROGRAM_ID.toBuffer()], constants_1.REGISTER_PROGRAM_ID);\n    const hashed = await (0, utils_1.getHashedName)(name);\n    const nameAccount = await (0, utils_1.getNameAccountKey)(hashed, undefined, constants_1.ROOT_DOMAIN_ACCOUNT);\n    const hashedReverseLookup = await (0, utils_1.getHashedName)(nameAccount.toBase58());\n    const reverseLookupAccount = await (0, utils_1.getNameAccountKey)(hashedReverseLookup, centralState);\n    const [derived_state] = await web3_js_1.PublicKey.findProgramAddress([nameAccount.toBuffer()], constants_1.REGISTER_PROGRAM_ID);\n    const ix = new instructions_1.createV2Instruction({ name, space }).getInstruction(constants_1.REGISTER_PROGRAM_ID, web3_js_1.SYSVAR_RENT_PUBKEY, constants_1.NAME_PROGRAM_ID, constants_1.ROOT_DOMAIN_ACCOUNT, nameAccount, reverseLookupAccount, centralState, buyer, buyerTokenAccount, constants_1.BONFIDA_FIDA_BNB, derived_state);\n    return [[], [ix]];\n};\nexports.registerDomainName = registerDomainName;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TWITTER_ROOT_PARENT_REGISTRY_KEY = exports.TWITTER_VERIFICATION_AUTHORITY = exports.REVERSE_LOOKUP_CLASS = exports.BONFIDA_FIDA_BNB = exports.PYTH_FIDDA_PRICE_ACC = exports.REGISTER_PROGRAM_ID = exports.ROOT_DOMAIN_ACCOUNT = exports.HASH_PREFIX = exports.NAME_PROGRAM_ID = void 0;\nconst web3_js_1 = require(\"@solana/web3.js\");\n/**\n * The Solana Name Service program ID\n */\nexports.NAME_PROGRAM_ID = new web3_js_1.PublicKey(\"namesLPneVptA9Z5rqUDD9tMTWEJwofgaYwp8cawRkX\");\n/**\n * Hash prefix used to derive domain name addresses\n */\nexports.HASH_PREFIX = \"SPL Name Service\";\n/**\n * The `.sol` TLD\n */\nexports.ROOT_DOMAIN_ACCOUNT = new web3_js_1.PublicKey(\"58PwtjSDuFHuUkYjH9BYnnQKHfwo9reZhC2zMJv9JPkx\");\n/**\n * The Registry program ID\n */\nexports.REGISTER_PROGRAM_ID = new web3_js_1.PublicKey(\"jCebN34bUfdeUYJT13J1yG16XWQpt5PDx6Mse9GUqhR\");\n/**\n * The FIDA Pyth price feed\n */\nexports.PYTH_FIDDA_PRICE_ACC = new web3_js_1.PublicKey(\"ETp9eKXVv1dWwHSpsXRUuXHmw24PwRkttCGVgpZEY9zF\");\n/**\n * The FIDA buy and burn address\n */\nexports.BONFIDA_FIDA_BNB = new web3_js_1.PublicKey(\"AUoZ3YAhV3b2rZeEH93UMZHXUZcTramBvb4d9YEVySkc\");\n/**\n * The reverse look up class\n */\nexports.REVERSE_LOOKUP_CLASS = new web3_js_1.PublicKey(\"33m47vH6Eav6jr5Ry86XjhRft2jRBLDnDgPSHoquXi2Z\");\n/**\n * The `.twitter` TLD authority\n */\nexports.TWITTER_VERIFICATION_AUTHORITY = new web3_js_1.PublicKey(\"FvPH7PrVrLGKPfqaf3xJodFTjZriqrAXXLTVWEorTFBi\");\n/**\n * The `.twitter` TLD\n */\nexports.TWITTER_ROOT_PARENT_REGISTRY_KEY = new web3_js_1.PublicKey(\"4YcexoW3r78zz16J2aqmukBLRwGq6rAvWzJpkYAXqebv\");\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getFavoriteDomain = void 0;\nconst name_offers_1 = require(\"@bonfida/name-offers\");\nconst utils_1 = require(\"./utils\");\nconst web3_js_1 = require(\"@solana/web3.js\");\n/**\n * This function can be used to retrieve the favorite domain of a user\n * @param connection The Solana RPC connection object\n * @param owner The owner you want to retrieve the favorite domain for\n * @returns\n */\nconst getFavoriteDomain = async (connection, owner) => {\n    const [favKey] = await name_offers_1.FavouriteDomain.getKey(name_offers_1.NAME_OFFERS_ID, new web3_js_1.PublicKey(owner));\n    const favorite = await name_offers_1.FavouriteDomain.retrieve(connection, favKey);\n    const reverse = await (0, utils_1.performReverseLookup)(connection, favorite.nameAccount);\n    return { domain: favorite.nameAccount, reverse };\n};\nexports.getFavoriteDomain = getFavoriteDomain;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./utils\"), exports);\n__exportStar(require(\"./bindings\"), exports);\n__exportStar(require(\"./state\"), exports);\n__exportStar(require(\"./twitter_bindings\"), exports);\n__exportStar(require(\"./tokens\"), exports);\n__exportStar(require(\"./utils\"), exports);\n__exportStar(require(\"./instructions\"), exports);\n__exportStar(require(\"./nft\"), exports);\n__exportStar(require(\"./favorite-domain\"), exports);\n__exportStar(require(\"./constants\"), exports);\n__exportStar(require(\"./int\"), exports);\n__exportStar(require(\"./record\"), exports);\n__exportStar(require(\"./types/record\"), exports);\n__exportStar(require(\"./resolve\"), exports);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createV2Instruction = exports.deleteInstruction = exports.transferInstruction = exports.updateInstruction = exports.createInstruction = void 0;\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst spl_token_1 = require(\"@solana/spl-token\");\nconst int_1 = require(\"./int\");\nconst borsh_1 = require(\"borsh\");\nconst constants_1 = require(\"./constants\");\nfunction createInstruction(nameProgramId, systemProgramId, nameKey, nameOwnerKey, payerKey, hashed_name, lamports, space, nameClassKey, nameParent, nameParentOwner) {\n    const buffers = [\n        Buffer.from(Int8Array.from([0])),\n        //@ts-ignore\n        new int_1.Numberu32(hashed_name.length).toBuffer(),\n        hashed_name,\n        lamports.toBuffer(),\n        space.toBuffer(),\n    ];\n    const data = Buffer.concat(buffers);\n    const keys = [\n        {\n            pubkey: systemProgramId,\n            isSigner: false,\n            isWritable: false,\n        },\n        {\n            pubkey: payerKey,\n            isSigner: true,\n            isWritable: true,\n        },\n        {\n            pubkey: nameKey,\n            isSigner: false,\n            isWritable: true,\n        },\n        {\n            pubkey: nameOwnerKey,\n            isSigner: false,\n            isWritable: false,\n        },\n    ];\n    if (nameClassKey) {\n        keys.push({\n            pubkey: nameClassKey,\n            isSigner: true,\n            isWritable: false,\n        });\n    }\n    else {\n        keys.push({\n            pubkey: new web3_js_1.PublicKey(Buffer.alloc(32)),\n            isSigner: false,\n            isWritable: false,\n        });\n    }\n    if (nameParent) {\n        keys.push({\n            pubkey: nameParent,\n            isSigner: false,\n            isWritable: false,\n        });\n    }\n    else {\n        keys.push({\n            pubkey: new web3_js_1.PublicKey(Buffer.alloc(32)),\n            isSigner: false,\n            isWritable: false,\n        });\n    }\n    if (nameParentOwner) {\n        keys.push({\n            pubkey: nameParentOwner,\n            isSigner: true,\n            isWritable: false,\n        });\n    }\n    return new web3_js_1.TransactionInstruction({\n        keys,\n        programId: nameProgramId,\n        data,\n    });\n}\nexports.createInstruction = createInstruction;\nfunction updateInstruction(nameProgramId, nameAccountKey, offset, input_data, nameUpdateSigner) {\n    const buffers = [\n        Buffer.from(Int8Array.from([1])),\n        offset.toBuffer(),\n        //@ts-ignore\n        new int_1.Numberu32(input_data.length).toBuffer(),\n        input_data,\n    ];\n    const data = Buffer.concat(buffers);\n    const keys = [\n        {\n            pubkey: nameAccountKey,\n            isSigner: false,\n            isWritable: true,\n        },\n        {\n            pubkey: nameUpdateSigner,\n            isSigner: true,\n            isWritable: false,\n        },\n    ];\n    return new web3_js_1.TransactionInstruction({\n        keys,\n        programId: nameProgramId,\n        data,\n    });\n}\nexports.updateInstruction = updateInstruction;\nfunction transferInstruction(nameProgramId, nameAccountKey, newOwnerKey, currentNameOwnerKey, nameClassKey, nameParent, parentOwner) {\n    const buffers = [Buffer.from(Int8Array.from([2])), newOwnerKey.toBuffer()];\n    const data = Buffer.concat(buffers);\n    const keys = [\n        {\n            pubkey: nameAccountKey,\n            isSigner: false,\n            isWritable: true,\n        },\n        {\n            pubkey: parentOwner ? parentOwner : currentNameOwnerKey,\n            isSigner: true,\n            isWritable: false,\n        },\n    ];\n    if (nameClassKey) {\n        keys.push({\n            pubkey: nameClassKey,\n            isSigner: true,\n            isWritable: false,\n        });\n    }\n    if (parentOwner && nameParent) {\n        if (!nameClassKey) {\n            keys.push({\n                pubkey: web3_js_1.PublicKey.default,\n                isSigner: false,\n                isWritable: false,\n            });\n        }\n        keys.push({\n            pubkey: nameParent,\n            isSigner: false,\n            isWritable: false,\n        });\n    }\n    return new web3_js_1.TransactionInstruction({\n        keys,\n        programId: nameProgramId,\n        data,\n    });\n}\nexports.transferInstruction = transferInstruction;\nfunction deleteInstruction(nameProgramId, nameAccountKey, refundTargetKey, nameOwnerKey) {\n    const buffers = [Buffer.from(Int8Array.from([3]))];\n    const data = Buffer.concat(buffers);\n    const keys = [\n        {\n            pubkey: nameAccountKey,\n            isSigner: false,\n            isWritable: true,\n        },\n        {\n            pubkey: nameOwnerKey,\n            isSigner: true,\n            isWritable: false,\n        },\n        {\n            pubkey: refundTargetKey,\n            isSigner: false,\n            isWritable: true,\n        },\n    ];\n    return new web3_js_1.TransactionInstruction({\n        keys,\n        programId: nameProgramId,\n        data,\n    });\n}\nexports.deleteInstruction = deleteInstruction;\nclass createV2Instruction {\n    constructor(obj) {\n        this.tag = 9;\n        this.name = obj.name;\n        this.space = obj.space;\n    }\n    serialize() {\n        return (0, borsh_1.serialize)(createV2Instruction.schema, this);\n    }\n    getInstruction(programId, rentSysvarAccount, nameProgramId, rootDomain, nameAccount, reverseLookupAccount, centralState, buyer, buyerTokenAccount, fidaVault, state) {\n        const data = Buffer.from(this.serialize());\n        const keys = [\n            {\n                pubkey: rentSysvarAccount,\n                isSigner: false,\n                isWritable: false,\n            },\n            {\n                pubkey: nameProgramId,\n                isSigner: false,\n                isWritable: false,\n            },\n            {\n                pubkey: rootDomain,\n                isSigner: false,\n                isWritable: false,\n            },\n            {\n                pubkey: nameAccount,\n                isSigner: false,\n                isWritable: true,\n            },\n            {\n                pubkey: reverseLookupAccount,\n                isSigner: false,\n                isWritable: true,\n            },\n            {\n                pubkey: web3_js_1.SystemProgram.programId,\n                isSigner: false,\n                isWritable: false,\n            },\n            {\n                pubkey: centralState,\n                isSigner: false,\n                isWritable: false,\n            },\n            {\n                pubkey: buyer,\n                isSigner: true,\n                isWritable: true,\n            },\n            {\n                pubkey: buyerTokenAccount,\n                isSigner: false,\n                isWritable: true,\n            },\n            {\n                pubkey: constants_1.PYTH_FIDDA_PRICE_ACC,\n                isSigner: false,\n                isWritable: false,\n            },\n            {\n                pubkey: fidaVault,\n                isSigner: false,\n                isWritable: true,\n            },\n            {\n                pubkey: spl_token_1.TOKEN_PROGRAM_ID,\n                isSigner: false,\n                isWritable: false,\n            },\n            {\n                pubkey: state,\n                isSigner: false,\n                isWritable: false,\n            },\n        ];\n        return new web3_js_1.TransactionInstruction({\n            keys,\n            programId,\n            data,\n        });\n    }\n}\nexports.createV2Instruction = createV2Instruction;\ncreateV2Instruction.schema = new Map([\n    [\n        createV2Instruction,\n        {\n            kind: \"struct\",\n            fields: [\n                [\"tag\", \"u8\"],\n                [\"name\", \"string\"],\n                [\"space\", \"u32\"],\n            ],\n        },\n    ],\n]);\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Numberu64 = exports.Numberu32 = void 0;\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nclass Numberu32 extends bn_js_1.default {\n    /**\n     * Convert to Buffer representation\n     */\n    toBuffer() {\n        const a = super.toArray().reverse();\n        const b = Buffer.from(a);\n        if (b.length === 4) {\n            return b;\n        }\n        if (b.length > 4) {\n            throw new Error(\"Numberu32 too large\");\n        }\n        const zeroPad = Buffer.alloc(4);\n        b.copy(zeroPad);\n        return zeroPad;\n    }\n    /**\n     * Construct a Numberu64 from Buffer representation\n     */\n    static fromBuffer(buffer) {\n        if (buffer.length !== 4) {\n            throw new Error(`Invalid buffer length: ${buffer.length}`);\n        }\n        return new bn_js_1.default([...buffer]\n            .reverse()\n            .map((i) => `00${i.toString(16)}`.slice(-2))\n            .join(\"\"), 16);\n    }\n}\nexports.Numberu32 = Numberu32;\nclass Numberu64 extends bn_js_1.default {\n    /**\n     * Convert to Buffer representation\n     */\n    toBuffer() {\n        const a = super.toArray().reverse();\n        const b = Buffer.from(a);\n        if (b.length === 8) {\n            return b;\n        }\n        if (b.length > 8) {\n            throw new Error(\"Numberu64 too large\");\n        }\n        const zeroPad = Buffer.alloc(8);\n        b.copy(zeroPad);\n        return zeroPad;\n    }\n    /**\n     * Construct a Numberu64 from Buffer representation\n     */\n    static fromBuffer(buffer) {\n        if (buffer.length !== 8) {\n            throw new Error(`Invalid buffer length: ${buffer.length}`);\n        }\n        return new bn_js_1.default([...buffer]\n            .reverse()\n            .map((i) => `00${i.toString(16)}`.slice(-2))\n            .join(\"\"), 16);\n    }\n}\nexports.Numberu64 = Numberu64;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.retrieveNfts = exports.retrieveNftOwner = exports.MINT_PREFIX = exports.NAME_TOKENIZER_ID = void 0;\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst spl_token_1 = require(\"@solana/spl-token\");\n/**\n * Mainnet program ID\n */\nexports.NAME_TOKENIZER_ID = new web3_js_1.PublicKey(\"nftD3vbNkNqfj2Sd3HZwbpw4BxxKWr4AjGb9X38JeZk\");\n/**\n * PDA prefix\n */\nexports.MINT_PREFIX = Buffer.from(\"tokenized_name\");\n/**\n * This function can be used to retrieve the owner of a tokenized domain name\n *\n * @param connection The solana connection object to the RPC node\n * @param nameAccount The key of the domain name\n * @returns\n */\nconst retrieveNftOwner = async (connection, nameAccount) => {\n    var _a;\n    try {\n        const [mint] = await web3_js_1.PublicKey.findProgramAddress([exports.MINT_PREFIX, nameAccount.toBuffer()], exports.NAME_TOKENIZER_ID);\n        const mintInfo = await (0, spl_token_1.getMint)(connection, mint);\n        if (mintInfo.supply.toString() === \"0\") {\n            return undefined;\n        }\n        const { value } = await connection.getTokenLargestAccounts(mint);\n        const holder = (_a = value.find((e) => e.amount === \"1\")) === null || _a === void 0 ? void 0 : _a.address;\n        if (!holder) {\n            return undefined;\n        }\n        const info = await connection.getAccountInfo(holder);\n        if (!info || !info.data) {\n            return undefined;\n        }\n        return new web3_js_1.PublicKey(info.data.slice(32, 64));\n    }\n    catch {\n        return undefined;\n    }\n};\nexports.retrieveNftOwner = retrieveNftOwner;\n/**\n * This function can be used to retrieve all the tokenized domains name\n *\n * @param connection The solana connection object to the RPC node\n * @returns\n */\nconst retrieveNfts = async (connection) => {\n    const filters = [\n        {\n            memcmp: {\n                offset: 0,\n                bytes: \"3\",\n            },\n        },\n    ];\n    const result = await connection.getProgramAccounts(exports.NAME_TOKENIZER_ID, {\n        filters,\n    });\n    const offset = 1 + 1 + 32 + 32;\n    return result.map((e) => new web3_js_1.PublicKey(e.account.data.slice(offset, offset + 32)));\n};\nexports.retrieveNfts = retrieveNfts;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getPointRecord = exports.getSolRecord = exports.getShdwRecord = exports.getPicRecord = exports.getTelegramRecord = exports.getTwitterRecord = exports.getRedditRecord = exports.getGithubRecord = exports.getDiscordRecord = exports.getUrlRecord = exports.getEmailRecord = exports.getDogeRecord = exports.getLtcRecord = exports.getBtcRecord = exports.getEthRecord = exports.getArweaveRecord = exports.getIpfsRecord = exports.getRecord = void 0;\nconst record_1 = require(\"./types/record\");\nconst utils_1 = require(\"./utils\");\nconst state_1 = require(\"./state\");\n/**\n * This function can be used to retrieve a specified record for the given domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @param record The record to search for\n * @returns\n */\nconst getRecord = async (connection, domain, record) => {\n    var _a, _b;\n    const { pubkey } = await (0, utils_1.getDomainKey)(record + \".\" + domain, true);\n    let { registry } = await state_1.NameRegistryState.retrieve(connection, pubkey);\n    // Remove trailling 0s\n    const idx = (_a = registry.data) === null || _a === void 0 ? void 0 : _a.indexOf(0x00);\n    registry.data = (_b = registry.data) === null || _b === void 0 ? void 0 : _b.slice(0, idx);\n    return registry;\n};\nexports.getRecord = getRecord;\n/**\n * This function can be used to retrieve the IPFS record of a domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @returns\n */\nconst getIpfsRecord = async (connection, domain) => {\n    return await (0, exports.getRecord)(connection, domain, record_1.Record.IPFS);\n};\nexports.getIpfsRecord = getIpfsRecord;\n/**\n * This function can be used to retrieve the Arweave record of a domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @returns\n */\nconst getArweaveRecord = async (connection, domain) => {\n    return await (0, exports.getRecord)(connection, domain, record_1.Record.ARWV);\n};\nexports.getArweaveRecord = getArweaveRecord;\n/**\n * This function can be used to retrieve the ETH record of a domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @returns\n */\nconst getEthRecord = async (connection, domain) => {\n    return await (0, exports.getRecord)(connection, domain, record_1.Record.ETH);\n};\nexports.getEthRecord = getEthRecord;\n/**\n * This function can be used to retrieve the BTC record of a domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @returns\n */\nconst getBtcRecord = async (connection, domain) => {\n    return await (0, exports.getRecord)(connection, domain, record_1.Record.BTC);\n};\nexports.getBtcRecord = getBtcRecord;\n/**\n * This function can be used to retrieve the LTC record of a domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @returns\n */\nconst getLtcRecord = async (connection, domain) => {\n    return await (0, exports.getRecord)(connection, domain, record_1.Record.LTC);\n};\nexports.getLtcRecord = getLtcRecord;\n/**\n * This function can be used to retrieve the DOGE record of a domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @returns\n */\nconst getDogeRecord = async (connection, domain) => {\n    return await (0, exports.getRecord)(connection, domain, record_1.Record.DOGE);\n};\nexports.getDogeRecord = getDogeRecord;\n/**\n * This function can be used to retrieve the email record of a domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @returns\n */\nconst getEmailRecord = async (connection, domain) => {\n    return await (0, exports.getRecord)(connection, domain, record_1.Record.Email);\n};\nexports.getEmailRecord = getEmailRecord;\n/**\n * This function can be used to retrieve the URL record of a domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @returns\n */\nconst getUrlRecord = async (connection, domain) => {\n    return await (0, exports.getRecord)(connection, domain, record_1.Record.Url);\n};\nexports.getUrlRecord = getUrlRecord;\n/**\n * This function can be used to retrieve the Discord record of a domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @returns\n */\nconst getDiscordRecord = async (connection, domain) => {\n    return await (0, exports.getRecord)(connection, domain, record_1.Record.Discord);\n};\nexports.getDiscordRecord = getDiscordRecord;\n/**\n * This function can be used to retrieve the Github record of a domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @returns\n */\nconst getGithubRecord = async (connection, domain) => {\n    return await (0, exports.getRecord)(connection, domain, record_1.Record.Github);\n};\nexports.getGithubRecord = getGithubRecord;\n/**\n * This function can be used to retrieve the Reddit record of a domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @returns\n */\nconst getRedditRecord = async (connection, domain) => {\n    return await (0, exports.getRecord)(connection, domain, record_1.Record.Reddit);\n};\nexports.getRedditRecord = getRedditRecord;\n/**\n * This function can be used to retrieve the Twitter record of a domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @returns\n */\nconst getTwitterRecord = async (connection, domain) => {\n    return await (0, exports.getRecord)(connection, domain, record_1.Record.Twitter);\n};\nexports.getTwitterRecord = getTwitterRecord;\n/**\n * This function can be used to retrieve the Telegram record of a domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @returns\n */\nconst getTelegramRecord = async (connection, domain) => {\n    return await (0, exports.getRecord)(connection, domain, record_1.Record.Telegram);\n};\nexports.getTelegramRecord = getTelegramRecord;\n/**\n * This function can be used to retrieve the pic record of a domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @returns\n */\nconst getPicRecord = async (connection, domain) => {\n    return await (0, exports.getRecord)(connection, domain, record_1.Record.Pic);\n};\nexports.getPicRecord = getPicRecord;\n/**\n * This function can be used to retrieve the SHDW record of a domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @returns\n */\nconst getShdwRecord = async (connection, domain) => {\n    return await (0, exports.getRecord)(connection, domain, record_1.Record.SHDW);\n};\nexports.getShdwRecord = getShdwRecord;\n/**\n * This function can be used to retrieve the SOL record of a domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @returns\n */\nconst getSolRecord = async (connection, domain) => {\n    return await (0, exports.getRecord)(connection, domain, record_1.Record.SOL);\n};\nexports.getSolRecord = getSolRecord;\n/**\n * This function can be used to retrieve the POINT record of a domain name\n * @param connection The Solana RPC connection object\n * @param domain The .sol domain name\n * @returns\n */\nconst getPointRecord = async (connection, domain) => {\n    return await (0, exports.getRecord)(connection, domain, record_1.Record.POINT);\n};\nexports.getPointRecord = getPointRecord;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolve = exports.checkSolRecord = void 0;\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst record_1 = require(\"./record\");\nconst utils_1 = require(\"./utils\");\nconst state_1 = require(\"./state\");\nconst tweetnacl_1 = require(\"tweetnacl\");\nconst record_2 = require(\"./types/record\");\n/**\n * This function can be used to verify the validity of a SOL record\n * @param record The record data to verify\n * @param signedRecord The signed data\n * @param pubkey The public key of the signer\n * @returns\n */\nconst checkSolRecord = (record, signedRecord, pubkey) => {\n    return tweetnacl_1.sign.detached.verify(record, signedRecord, pubkey.toBytes());\n};\nexports.checkSolRecord = checkSolRecord;\n/**\n * This function can be used to resolve a domain name to transfer funds\n * @param connection The Solana RPC connection object\n * @param domain The domain to resolve\n * @returns\n */\nconst resolve = async (connection, domain) => {\n    var _a;\n    const { pubkey } = await (0, utils_1.getDomainKey)(domain);\n    const { registry, nftOwner } = await state_1.NameRegistryState.retrieve(connection, pubkey);\n    if (nftOwner) {\n        return nftOwner;\n    }\n    try {\n        const recordKey = await (0, utils_1.getDomainKey)(record_2.Record.SOL + \".\" + domain, true);\n        const solRecord = await (0, record_1.getSolRecord)(connection, domain);\n        if (((_a = solRecord.data) === null || _a === void 0 ? void 0 : _a.length) !== 96) {\n            throw new Error(\"Invalid SOL record data\");\n        }\n        const encoder = new TextEncoder();\n        const expectedBuffer = Buffer.concat([\n            solRecord.data.slice(0, 32),\n            recordKey.pubkey.toBuffer(),\n        ]);\n        const expected = encoder.encode(expectedBuffer.toString(\"hex\"));\n        const valid = (0, exports.checkSolRecord)(expected, solRecord.data.slice(32), registry.owner);\n        if (!valid) {\n            throw new Error(\"Signature invalid\");\n        }\n        return new web3_js_1.PublicKey(solRecord.data.slice(0, 32));\n    }\n    catch (err) {\n        console.log(err);\n    }\n    return registry.owner;\n};\nexports.resolve = resolve;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Mint = exports.TokenData = exports.NameRegistryState = void 0;\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst borsh_1 = require(\"borsh\");\nconst nft_1 = require(\"./nft\");\nclass NameRegistryState {\n    constructor(obj) {\n        this.parentName = new web3_js_1.PublicKey(obj.parentName);\n        this.owner = new web3_js_1.PublicKey(obj.owner);\n        this.class = new web3_js_1.PublicKey(obj.class);\n    }\n    static async retrieve(connection, nameAccountKey) {\n        var _a;\n        const nameAccount = await connection.getAccountInfo(nameAccountKey);\n        if (!nameAccount) {\n            throw new Error(\"Invalid name account provided\");\n        }\n        let res = (0, borsh_1.deserializeUnchecked)(this.schema, NameRegistryState, nameAccount.data);\n        res.data = (_a = nameAccount.data) === null || _a === void 0 ? void 0 : _a.slice(this.HEADER_LEN);\n        const nftOwner = await (0, nft_1.retrieveNftOwner)(connection, nameAccountKey);\n        return { registry: res, nftOwner };\n    }\n    static async _retrieveBatch(connection, nameAccountKeys) {\n        const nameAccounts = await connection.getMultipleAccountsInfo(nameAccountKeys);\n        const fn = (data) => {\n            if (!data)\n                return undefined;\n            const res = (0, borsh_1.deserializeUnchecked)(this.schema, NameRegistryState, data);\n            res.data = data === null || data === void 0 ? void 0 : data.slice(this.HEADER_LEN);\n            return res;\n        };\n        return nameAccounts.map((e) => fn(e === null || e === void 0 ? void 0 : e.data));\n    }\n    static async retrieveBatch(connection, nameAccountKeys) {\n        let result = [];\n        while (nameAccountKeys.length > 0) {\n            result.push(...(await this._retrieveBatch(connection, nameAccountKeys.splice(0, 100))));\n        }\n        return result;\n    }\n}\nexports.NameRegistryState = NameRegistryState;\nNameRegistryState.HEADER_LEN = 96;\nNameRegistryState.schema = new Map([\n    [\n        NameRegistryState,\n        {\n            kind: \"struct\",\n            fields: [\n                [\"parentName\", [32]],\n                [\"owner\", [32]],\n                [\"class\", [32]],\n            ],\n        },\n    ],\n]);\nclass TokenData {\n    constructor(obj) {\n        this.name = obj.name;\n        this.ticker = obj.ticker;\n        this.mint = obj.mint;\n        this.decimals = obj.decimals;\n        this.website = obj === null || obj === void 0 ? void 0 : obj.website;\n        this.logoUri = obj === null || obj === void 0 ? void 0 : obj.logoUri;\n    }\n    serialize() {\n        return (0, borsh_1.serialize)(TokenData.schema, this);\n    }\n    static deserialize(data) {\n        return (0, borsh_1.deserializeUnchecked)(TokenData.schema, TokenData, data);\n    }\n}\nexports.TokenData = TokenData;\nTokenData.schema = new Map([\n    [\n        TokenData,\n        {\n            kind: \"struct\",\n            fields: [\n                [\"name\", \"string\"],\n                [\"ticker\", \"string\"],\n                [\"mint\", [32]],\n                [\"decimals\", \"u8\"],\n                [\"website\", { kind: \"option\", type: \"string\" }],\n                [\"logoUri\", { kind: \"option\", type: \"string\" }],\n            ],\n        },\n    ],\n]);\nclass Mint {\n    constructor(obj) {\n        this.mint = obj.mint;\n    }\n    serialize() {\n        return (0, borsh_1.serialize)(Mint.schema, this);\n    }\n    static deserialize(data) {\n        return (0, borsh_1.deserializeUnchecked)(Mint.schema, Mint, data);\n    }\n}\nexports.Mint = Mint;\nMint.schema = new Map([\n    [\n        Mint,\n        {\n            kind: \"struct\",\n            fields: [[\"mint\", [32]]],\n        },\n    ],\n]);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getTokenInfoFromName = exports.getTokenInfoFromMint = exports.TOKEN_TLD = void 0;\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst utils_1 = require(\"./utils\");\nconst state_1 = require(\"./state\");\nexports.TOKEN_TLD = new web3_js_1.PublicKey(\"6NSu2tci4apRKQtt257bAVcvqYjB3zV2H1dWo56vgpa6\");\nconst getTokenInfoFromMint = async (connection, mint) => {\n    const nameKey = await (0, utils_1.getNameAccountKey)(await (0, utils_1.getHashedName)(mint.toBase58()), undefined, exports.TOKEN_TLD);\n    const { registry } = await state_1.NameRegistryState.retrieve(connection, nameKey);\n    if (!registry.data) {\n        throw new Error(\"Invalid account data\");\n    }\n    return state_1.TokenData.deserialize(registry.data);\n};\nexports.getTokenInfoFromMint = getTokenInfoFromMint;\nconst getTokenInfoFromName = async (connection, name) => {\n    const reverseNameKey = await (0, utils_1.getNameAccountKey)(await (0, utils_1.getHashedName)(name), undefined, exports.TOKEN_TLD);\n    const { registry: reverseRegistry } = await state_1.NameRegistryState.retrieve(connection, reverseNameKey);\n    if (!reverseRegistry.data) {\n        throw new Error(\"Invalid account data\");\n    }\n    const mint = new web3_js_1.PublicKey(state_1.Mint.deserialize(reverseRegistry.data).mint);\n    return await (0, exports.getTokenInfoFromMint)(connection, mint);\n};\nexports.getTokenInfoFromName = getTokenInfoFromName;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createReverseTwitterRegistry = exports.ReverseTwitterRegistryState = exports.getTwitterRegistryData = exports.getTwitterHandleandRegistryKeyViaFilters = exports.getHandleAndRegistryKey = exports.getTwitterRegistry = exports.getTwitterRegistryKey = exports.deleteTwitterRegistry = exports.changeVerifiedPubkey = exports.changeTwitterRegistryData = exports.createVerifiedTwitterRegistry = void 0;\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst constants_1 = require(\"./constants\");\nconst bindings_1 = require(\"./bindings\");\nconst instructions_1 = require(\"./instructions\");\nconst state_1 = require(\"./state\");\nconst utils_1 = require(\"./utils\");\nconst int_1 = require(\"./int\");\nconst borsh_1 = require(\"borsh\");\n////////////////////////////////////////////////////\n// Bindings\n// Signed by the authority, the payer and the verified pubkey\nasync function createVerifiedTwitterRegistry(connection, twitterHandle, verifiedPubkey, space, // The space that the user will have to write data into the verified registry\npayerKey) {\n    // Create user facing registry\n    const hashedTwitterHandle = await (0, utils_1.getHashedName)(twitterHandle);\n    const twitterHandleRegistryKey = await (0, utils_1.getNameAccountKey)(hashedTwitterHandle, undefined, constants_1.TWITTER_ROOT_PARENT_REGISTRY_KEY);\n    const lamports = await connection.getMinimumBalanceForRentExemption(space + state_1.NameRegistryState.HEADER_LEN);\n    let instructions = [\n        (0, instructions_1.createInstruction)(constants_1.NAME_PROGRAM_ID, web3_js_1.SystemProgram.programId, twitterHandleRegistryKey, verifiedPubkey, payerKey, hashedTwitterHandle, \n        //@ts-ignore\n        new int_1.Numberu64(lamports), \n        //@ts-ignore\n        new int_1.Numberu32(space), undefined, constants_1.TWITTER_ROOT_PARENT_REGISTRY_KEY, constants_1.TWITTER_VERIFICATION_AUTHORITY // Twitter authority acts as owner of the parent for all user-facing registries\n        ),\n    ];\n    instructions = instructions.concat(await createReverseTwitterRegistry(connection, twitterHandle, twitterHandleRegistryKey, verifiedPubkey, payerKey));\n    return instructions;\n}\nexports.createVerifiedTwitterRegistry = createVerifiedTwitterRegistry;\n// Overwrite the data that is written in the user facing registry\n// Signed by the verified pubkey\nasync function changeTwitterRegistryData(twitterHandle, verifiedPubkey, offset, // The offset at which to write the input data into the NameRegistryData\ninput_data) {\n    const hashedTwitterHandle = await (0, utils_1.getHashedName)(twitterHandle);\n    const twitterHandleRegistryKey = await (0, utils_1.getNameAccountKey)(hashedTwitterHandle, undefined, constants_1.TWITTER_ROOT_PARENT_REGISTRY_KEY);\n    const instructions = [\n        (0, instructions_1.updateInstruction)(constants_1.NAME_PROGRAM_ID, twitterHandleRegistryKey, \n        //@ts-ignore\n        new int_1.Numberu32(offset), input_data, verifiedPubkey),\n    ];\n    return instructions;\n}\nexports.changeTwitterRegistryData = changeTwitterRegistryData;\n// Change the verified pubkey for a given twitter handle\n// Signed by the Authority, the verified pubkey and the payer\nasync function changeVerifiedPubkey(connection, twitterHandle, currentVerifiedPubkey, newVerifiedPubkey, payerKey) {\n    const hashedTwitterHandle = await (0, utils_1.getHashedName)(twitterHandle);\n    const twitterHandleRegistryKey = await (0, utils_1.getNameAccountKey)(hashedTwitterHandle, undefined, constants_1.TWITTER_ROOT_PARENT_REGISTRY_KEY);\n    // Transfer the user-facing registry ownership\n    let instructions = [\n        (0, instructions_1.transferInstruction)(constants_1.NAME_PROGRAM_ID, twitterHandleRegistryKey, newVerifiedPubkey, currentVerifiedPubkey, undefined),\n    ];\n    // Delete the current reverse registry\n    const currentHashedVerifiedPubkey = await (0, utils_1.getHashedName)(currentVerifiedPubkey.toString());\n    const currentReverseRegistryKey = await (0, utils_1.getNameAccountKey)(currentHashedVerifiedPubkey, constants_1.TWITTER_VERIFICATION_AUTHORITY, undefined);\n    instructions.push(await (0, bindings_1.deleteNameRegistry)(connection, currentVerifiedPubkey.toString(), payerKey, constants_1.TWITTER_VERIFICATION_AUTHORITY, constants_1.TWITTER_ROOT_PARENT_REGISTRY_KEY));\n    // Create the new reverse registry\n    instructions = instructions.concat(await createReverseTwitterRegistry(connection, twitterHandle, twitterHandleRegistryKey, newVerifiedPubkey, payerKey));\n    return instructions;\n}\nexports.changeVerifiedPubkey = changeVerifiedPubkey;\n// Delete the verified registry for a given twitter handle\n// Signed by the verified pubkey\nasync function deleteTwitterRegistry(twitterHandle, verifiedPubkey) {\n    const hashedTwitterHandle = await (0, utils_1.getHashedName)(twitterHandle);\n    const twitterHandleRegistryKey = await (0, utils_1.getNameAccountKey)(hashedTwitterHandle, undefined, constants_1.TWITTER_ROOT_PARENT_REGISTRY_KEY);\n    const hashedVerifiedPubkey = await (0, utils_1.getHashedName)(verifiedPubkey.toString());\n    const reverseRegistryKey = await (0, utils_1.getNameAccountKey)(hashedVerifiedPubkey, constants_1.TWITTER_VERIFICATION_AUTHORITY, constants_1.TWITTER_ROOT_PARENT_REGISTRY_KEY);\n    const instructions = [\n        // Delete the user facing registry\n        (0, instructions_1.deleteInstruction)(constants_1.NAME_PROGRAM_ID, twitterHandleRegistryKey, verifiedPubkey, verifiedPubkey),\n        // Delete the reverse registry\n        (0, instructions_1.deleteInstruction)(constants_1.NAME_PROGRAM_ID, reverseRegistryKey, verifiedPubkey, verifiedPubkey),\n    ];\n    return instructions;\n}\nexports.deleteTwitterRegistry = deleteTwitterRegistry;\n//////////////////////////////////////////\n// Getter Functions\n// Returns the key of the user-facing registry\nasync function getTwitterRegistryKey(twitter_handle) {\n    const hashedTwitterHandle = await (0, utils_1.getHashedName)(twitter_handle);\n    return await (0, utils_1.getNameAccountKey)(hashedTwitterHandle, undefined, constants_1.TWITTER_ROOT_PARENT_REGISTRY_KEY);\n}\nexports.getTwitterRegistryKey = getTwitterRegistryKey;\nasync function getTwitterRegistry(connection, twitter_handle) {\n    const hashedTwitterHandle = await (0, utils_1.getHashedName)(twitter_handle);\n    const twitterHandleRegistryKey = await (0, utils_1.getNameAccountKey)(hashedTwitterHandle, undefined, constants_1.TWITTER_ROOT_PARENT_REGISTRY_KEY);\n    const { registry } = await state_1.NameRegistryState.retrieve(connection, twitterHandleRegistryKey);\n    return registry;\n}\nexports.getTwitterRegistry = getTwitterRegistry;\nasync function getHandleAndRegistryKey(connection, verifiedPubkey) {\n    const hashedVerifiedPubkey = await (0, utils_1.getHashedName)(verifiedPubkey.toString());\n    const reverseRegistryKey = await (0, utils_1.getNameAccountKey)(hashedVerifiedPubkey, constants_1.TWITTER_VERIFICATION_AUTHORITY, constants_1.TWITTER_ROOT_PARENT_REGISTRY_KEY);\n    let reverseRegistryState = await ReverseTwitterRegistryState.retrieve(connection, reverseRegistryKey);\n    return [\n        reverseRegistryState.twitterHandle,\n        new web3_js_1.PublicKey(reverseRegistryState.twitterRegistryKey),\n    ];\n}\nexports.getHandleAndRegistryKey = getHandleAndRegistryKey;\n// Uses the RPC node filtering feature, execution speed may vary\nasync function getTwitterHandleandRegistryKeyViaFilters(connection, verifiedPubkey) {\n    const filters = [\n        {\n            memcmp: {\n                offset: 0,\n                bytes: constants_1.TWITTER_ROOT_PARENT_REGISTRY_KEY.toBase58(),\n            },\n        },\n        {\n            memcmp: {\n                offset: 32,\n                bytes: verifiedPubkey.toBase58(),\n            },\n        },\n        {\n            memcmp: {\n                offset: 64,\n                bytes: constants_1.TWITTER_VERIFICATION_AUTHORITY.toBase58(),\n            },\n        },\n    ];\n    const filteredAccounts = await connection.getProgramAccounts(constants_1.NAME_PROGRAM_ID, { filters });\n    for (const f of filteredAccounts) {\n        if (f.account.data.length > state_1.NameRegistryState.HEADER_LEN + 32) {\n            let data = f.account.data.slice(state_1.NameRegistryState.HEADER_LEN);\n            let state = (0, borsh_1.deserializeUnchecked)(ReverseTwitterRegistryState.schema, ReverseTwitterRegistryState, data);\n            return [state.twitterHandle, new web3_js_1.PublicKey(state.twitterRegistryKey)];\n        }\n    }\n    throw new Error(\"Registry not found.\");\n}\nexports.getTwitterHandleandRegistryKeyViaFilters = getTwitterHandleandRegistryKeyViaFilters;\n// Uses the RPC node filtering feature, execution speed may vary\n// Does not give you the handle, but is an alternative to getHandlesAndKeysFromVerifiedPubkey + getTwitterRegistry to get the data\nasync function getTwitterRegistryData(connection, verifiedPubkey) {\n    const filters = [\n        {\n            memcmp: {\n                offset: 0,\n                bytes: constants_1.TWITTER_ROOT_PARENT_REGISTRY_KEY.toBase58(),\n            },\n        },\n        {\n            memcmp: {\n                offset: 32,\n                bytes: verifiedPubkey.toBase58(),\n            },\n        },\n        {\n            memcmp: {\n                offset: 64,\n                bytes: new web3_js_1.PublicKey(Buffer.alloc(32, 0)).toBase58(),\n            },\n        },\n    ];\n    const filteredAccounts = await connection.getProgramAccounts(constants_1.NAME_PROGRAM_ID, { filters });\n    if (filteredAccounts.length > 1) {\n        throw new Error(\"Found more than one registry.\");\n    }\n    return filteredAccounts[0].account.data.slice(state_1.NameRegistryState.HEADER_LEN);\n}\nexports.getTwitterRegistryData = getTwitterRegistryData;\n//////////////////////////////////////////////\n// Utils\nclass ReverseTwitterRegistryState {\n    constructor(obj) {\n        this.twitterRegistryKey = obj.twitterRegistryKey;\n        this.twitterHandle = obj.twitterHandle;\n    }\n    static async retrieve(connection, reverseTwitterAccountKey) {\n        let reverseTwitterAccount = await connection.getAccountInfo(reverseTwitterAccountKey, \"processed\");\n        if (!reverseTwitterAccount) {\n            throw new Error(\"Invalid reverse Twitter account provided\");\n        }\n        let res = (0, borsh_1.deserializeUnchecked)(this.schema, ReverseTwitterRegistryState, reverseTwitterAccount.data.slice(state_1.NameRegistryState.HEADER_LEN));\n        return res;\n    }\n}\nexports.ReverseTwitterRegistryState = ReverseTwitterRegistryState;\nReverseTwitterRegistryState.schema = new Map([\n    [\n        ReverseTwitterRegistryState,\n        {\n            kind: \"struct\",\n            fields: [\n                [\"twitterRegistryKey\", [32]],\n                [\"twitterHandle\", \"string\"],\n            ],\n        },\n    ],\n]);\nasync function createReverseTwitterRegistry(connection, twitterHandle, twitterRegistryKey, verifiedPubkey, payerKey) {\n    // Create the reverse lookup registry\n    const hashedVerifiedPubkey = await (0, utils_1.getHashedName)(verifiedPubkey.toString());\n    const reverseRegistryKey = await (0, utils_1.getNameAccountKey)(hashedVerifiedPubkey, constants_1.TWITTER_VERIFICATION_AUTHORITY, constants_1.TWITTER_ROOT_PARENT_REGISTRY_KEY);\n    let reverseTwitterRegistryStateBuff = (0, borsh_1.serialize)(ReverseTwitterRegistryState.schema, new ReverseTwitterRegistryState({\n        twitterRegistryKey: twitterRegistryKey.toBytes(),\n        twitterHandle,\n    }));\n    return [\n        (0, instructions_1.createInstruction)(constants_1.NAME_PROGRAM_ID, web3_js_1.SystemProgram.programId, reverseRegistryKey, verifiedPubkey, payerKey, hashedVerifiedPubkey, new int_1.Numberu64(\n        //@ts-ignore\n        await connection.getMinimumBalanceForRentExemption(reverseTwitterRegistryStateBuff.length + state_1.NameRegistryState.HEADER_LEN)), \n        //@ts-ignore\n        new int_1.Numberu32(reverseTwitterRegistryStateBuff.length), constants_1.TWITTER_VERIFICATION_AUTHORITY, // Twitter authority acts as class for all reverse-lookup registries\n        constants_1.TWITTER_ROOT_PARENT_REGISTRY_KEY, // Reverse registries are also children of the root\n        constants_1.TWITTER_VERIFICATION_AUTHORITY),\n        (0, instructions_1.updateInstruction)(constants_1.NAME_PROGRAM_ID, reverseRegistryKey, \n        //@ts-ignore\n        new int_1.Numberu32(0), Buffer.from(reverseTwitterRegistryStateBuff), constants_1.TWITTER_VERIFICATION_AUTHORITY),\n    ];\n}\nexports.createReverseTwitterRegistry = createReverseTwitterRegistry;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Record = void 0;\n/**\n * List of SNS Records\n */\nvar Record;\n(function (Record) {\n    Record[\"IPFS\"] = \"IPFS\";\n    Record[\"ARWV\"] = \"ARWV\";\n    Record[\"SOL\"] = \"SOL\";\n    Record[\"ETH\"] = \"ETH\";\n    Record[\"BTC\"] = \"BTC\";\n    Record[\"LTC\"] = \"LTC\";\n    Record[\"DOGE\"] = \"DOGE\";\n    Record[\"Email\"] = \"email\";\n    Record[\"Url\"] = \"url\";\n    Record[\"Discord\"] = \"discord\";\n    Record[\"Github\"] = \"github\";\n    Record[\"Reddit\"] = \"reddit\";\n    Record[\"Twitter\"] = \"twitter\";\n    Record[\"Telegram\"] = \"telegram\";\n    Record[\"Pic\"] = \"pic\";\n    Record[\"SHDW\"] = \"SHDW\";\n    Record[\"POINT\"] = \"POINT\";\n})(Record = exports.Record || (exports.Record = {}));\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getAllRegisteredDomains = exports.getAllDomains = exports.getDomainKey = exports.findSubdomains = exports.performReverseLookupBatch = exports.getDNSRecordAddress = exports.performReverseLookup = exports.getNameAccountKey = exports.getHashedName = exports.getNameOwner = void 0;\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst sha2_1 = require(\"@ethersproject/sha2\");\nconst constants_1 = require(\"./constants\");\nconst state_1 = require(\"./state\");\nconst constants_2 = require(\"./constants\");\nasync function getNameOwner(connection, nameAccountKey) {\n    const nameAccount = await connection.getAccountInfo(nameAccountKey);\n    if (!nameAccount) {\n        throw new Error(\"Unable to find the given account.\");\n    }\n    return state_1.NameRegistryState.retrieve(connection, nameAccountKey);\n}\nexports.getNameOwner = getNameOwner;\nasync function getHashedName(name) {\n    const input = constants_1.HASH_PREFIX + name;\n    const str = (0, sha2_1.sha256)(Buffer.from(input, \"utf8\")).slice(2);\n    return Buffer.from(str, \"hex\");\n}\nexports.getHashedName = getHashedName;\nasync function getNameAccountKey(hashed_name, nameClass, nameParent) {\n    const seeds = [hashed_name];\n    if (nameClass) {\n        seeds.push(nameClass.toBuffer());\n    }\n    else {\n        seeds.push(Buffer.alloc(32));\n    }\n    if (nameParent) {\n        seeds.push(nameParent.toBuffer());\n    }\n    else {\n        seeds.push(Buffer.alloc(32));\n    }\n    const [nameAccountKey] = await web3_js_1.PublicKey.findProgramAddress(seeds, constants_1.NAME_PROGRAM_ID);\n    return nameAccountKey;\n}\nexports.getNameAccountKey = getNameAccountKey;\nasync function performReverseLookup(connection, nameAccount) {\n    const hashedReverseLookup = await getHashedName(nameAccount.toBase58());\n    const reverseLookupAccount = await getNameAccountKey(hashedReverseLookup, constants_2.REVERSE_LOOKUP_CLASS);\n    const { registry } = await state_1.NameRegistryState.retrieve(connection, reverseLookupAccount);\n    if (!registry.data) {\n        throw \"Could not retrieve name data\";\n    }\n    const nameLength = new bn_js_1.default(registry.data.slice(0, 4), \"le\").toNumber();\n    return registry.data.slice(4, 4 + nameLength).toString();\n}\nexports.performReverseLookup = performReverseLookup;\nasync function getDNSRecordAddress(nameAccount, type) {\n    const hashedName = await getHashedName(\"\\0\".concat(type));\n    const recordAccount = await getNameAccountKey(hashedName, undefined, nameAccount);\n    return recordAccount;\n}\nexports.getDNSRecordAddress = getDNSRecordAddress;\nasync function performReverseLookupBatch(connection, nameAccounts) {\n    let reverseLookupAccounts = [];\n    for (let nameAccount of nameAccounts) {\n        const hashedReverseLookup = await getHashedName(nameAccount.toBase58());\n        const reverseLookupAccount = await getNameAccountKey(hashedReverseLookup, constants_2.REVERSE_LOOKUP_CLASS);\n        reverseLookupAccounts.push(reverseLookupAccount);\n    }\n    let names = await state_1.NameRegistryState.retrieveBatch(connection, reverseLookupAccounts);\n    return names.map((name) => {\n        if (name === undefined || name.data === undefined) {\n            return undefined;\n        }\n        let nameLength = new bn_js_1.default(name.data.slice(0, 4), \"le\").toNumber();\n        return name.data.slice(4, 4 + nameLength).toString();\n    });\n}\nexports.performReverseLookupBatch = performReverseLookupBatch;\n/**\n *\n * @param connection The Solana RPC connection object\n * @param parentKey The parent you want to find sub-domains for\n * @returns\n */\nconst findSubdomains = async (connection, parentKey) => {\n    const filters = [\n        {\n            memcmp: {\n                offset: 0,\n                bytes: parentKey.toBase58(),\n            },\n        },\n        {\n            memcmp: {\n                offset: 64,\n                bytes: constants_2.REVERSE_LOOKUP_CLASS.toBase58(),\n            },\n        },\n    ];\n    const result = await connection.getProgramAccounts(constants_1.NAME_PROGRAM_ID, {\n        filters,\n    });\n    return result.map((e) => { var _a; return (_a = e.account.data.slice(97).toString(\"utf-8\")) === null || _a === void 0 ? void 0 : _a.split(\"\\0\").join(\"\"); });\n};\nexports.findSubdomains = findSubdomains;\nconst _derive = async (name, parent = constants_1.ROOT_DOMAIN_ACCOUNT) => {\n    let hashed = await getHashedName(name);\n    let pubkey = await getNameAccountKey(hashed, undefined, parent);\n    return { pubkey, hashed };\n};\n/**\n * This function can be used to compute the public key of a domain or subdomain\n * @param domain The domain to compute the public key for (e.g `bonfida.sol`, `dex.bonfida.sol`)\n * @returns\n */\nconst getDomainKey = async (domain, record = false) => {\n    if (domain.endsWith(\".sol\")) {\n        domain = domain.slice(0, -4);\n    }\n    const splitted = domain.split(\".\");\n    if (splitted.length === 2) {\n        const prefix = Buffer.from([record ? 1 : 0]).toString();\n        const sub = prefix.concat(splitted[0]);\n        const { pubkey: parentKey } = await _derive(splitted[1]);\n        const result = await _derive(sub, parentKey);\n        return { ...result, isSub: true, parent: parentKey };\n    }\n    else if (splitted.length > 2) {\n        throw new Error(\"Invalid derivation input\");\n    }\n    const result = await _derive(domain, constants_1.ROOT_DOMAIN_ACCOUNT);\n    return { ...result, isSub: false, parent: undefined };\n};\nexports.getDomainKey = getDomainKey;\n/**\n * This function can be used to retrieve all domain names owned by `wallet`\n * @param connection The Solana RPC connection object\n * @param wallet The wallet you want to search domain names for\n * @returns\n */\nasync function getAllDomains(connection, wallet) {\n    const filters = [\n        {\n            memcmp: {\n                offset: 32,\n                bytes: wallet.toBase58(),\n            },\n        },\n        {\n            memcmp: {\n                offset: 0,\n                bytes: constants_1.ROOT_DOMAIN_ACCOUNT.toBase58(),\n            },\n        },\n    ];\n    const accounts = await connection.getProgramAccounts(constants_1.NAME_PROGRAM_ID, {\n        filters,\n    });\n    return accounts.map((a) => a.pubkey);\n}\nexports.getAllDomains = getAllDomains;\n/**\n * This function can be used to retrieve all the registered `.sol` domains.\n * The account data is sliced to avoid enormous payload and only the owner is returned\n * @param connection The Solana RPC connection object\n * @returns\n */\nconst getAllRegisteredDomains = async (connection) => {\n    const filters = [\n        {\n            memcmp: {\n                offset: 0,\n                bytes: constants_1.ROOT_DOMAIN_ACCOUNT.toBase58(),\n            },\n        },\n    ];\n    const dataSlice = { offset: 32, length: 32 };\n    const accounts = await connection.getProgramAccounts(constants_1.NAME_PROGRAM_ID, {\n        dataSlice,\n        filters,\n    });\n    return accounts;\n};\nexports.getAllRegisteredDomains = getAllRegisteredDomains;\n"],"names":[],"sourceRoot":"","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27]}