(globalThis["webpackChunkmask_network"] = globalThis["webpackChunkmask_network"] || []).push([[2105],{

/***/ 49668:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   P: () => (/* binding */ ARTHSWAP_CUSTOM_BASES),
/* harmony export */   T: () => (/* binding */ ARTHSWAP_BASE_AGAINST_TOKENS)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46854);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24770);

/**
 * Some tokens can only be swapped via certain pairs,
 * so we override the list of bases that are considered for these tokens.
 */ const ARTHSWAP_CUSTOM_BASES = {};
const ARTHSWAP_BASE_AGAINST_TOKENS = {
    ..._masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WNATIVE_ONLY */ .HL,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Astar]: [
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WNATIVE */ .FX,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDC */ .gn,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDT */ .AA
    ].map((x)=>x[_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Astar])
};


/***/ }),

/***/ 34458:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   h: () => (/* binding */ ASTAREXCHANGE_BASE_AGAINST_TOKENS),
/* harmony export */   x: () => (/* binding */ ASTAREXCHANGE_CUSTOM_BASES)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46854);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24770);

/**
 * Some tokens can only be swapped via certain pairs,
 * so we override the list of bases that are considered for these tokens.
 */ const ASTAREXCHANGE_CUSTOM_BASES = {};
const ASTAREXCHANGE_BASE_AGAINST_TOKENS = {
    ..._masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WNATIVE_ONLY */ .HL,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Astar]: [
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WNATIVE */ .FX,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDC */ .gn,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDT */ .AA
    ].map((x)=>x[_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Astar])
};


/***/ }),

/***/ 25835:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   P: () => (/* binding */ MDEX_CUSTOM_BASES),
/* harmony export */   R: () => (/* binding */ MDEX_BASE_AGAINST_TOKENS)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46854);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24770);

/**
 * Some tokens can only be swapped via certain pairs,
 * so we override the list of bases that are considered for these tokens.
 */ const MDEX_CUSTOM_BASES = {};
const MDEX_BASE_AGAINST_TOKENS = {
    ..._masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WNATIVE_ONLY */ .HL,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet]: [
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WNATIVE */ .FX,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .DAI */ .h1,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDC */ .gn,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDT */ .AA
    ].map((x)=>x[_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet]),
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.BSC]: [
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WNATIVE */ .FX,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .DAI */ .h1,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDC */ .gn,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDT */ .AA
    ].map((x)=>x[_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.BSC])
};


/***/ }),

/***/ 12134:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D: () => (/* binding */ PANCAKESWAP_BASE_AGAINST_TOKENS),
/* harmony export */   t: () => (/* binding */ PANCAKESWAP_CUSTOM_BASES)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46854);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24770);

/**
 * Some tokens can only be swapped via certain pairs,
 * so we override the list of bases that are considered for these tokens.
 */ const PANCAKESWAP_CUSTOM_BASES = {};
const PANCAKESWAP_BASE_AGAINST_TOKENS = {
    ..._masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WNATIVE_ONLY */ .HL,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.BSC]: [
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WNATIVE */ .FX,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .DAI */ .h1,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .BUSD */ .lz,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .BTCB */ .nB,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .UST */ .bi,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ETHER */ .c0
    ].map((x)=>x[_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.BSC])
};


/***/ }),

/***/ 91280:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   G: () => (/* binding */ PANGOLIN_CUSTOM_BASES),
/* harmony export */   h: () => (/* binding */ PANGOLIN_BASE_AGAINST_TOKENS)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46854);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24770);

/**
 * Some tokens can only be swapped via certain pairs,
 * so we override the list of bases that are considered for these tokens.
 */ const PANGOLIN_CUSTOM_BASES = {};
const PANGOLIN_BASE_AGAINST_TOKENS = {
    ..._masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WNATIVE_ONLY */ .HL,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Avalanche]: [
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WNATIVE */ .FX,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .DAIe */ .Lq,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .PNG */ .yI,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDTe */ ._c,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDCe */ .tB,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ETHER */ .c0,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WBTCe */ .MI
    ].map((x)=>x[_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Avalanche])
};


/***/ }),

/***/ 56065:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   P: () => (/* binding */ QUICKSWAP_BASE_AGAINST_TOKENS),
/* harmony export */   j: () => (/* binding */ QUICKSWAP_CUSTOM_BASES)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46854);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24770);

/**
 * Some tokens can only be swapped via certain pairs,
 * so we override the list of bases that are considered for these tokens.
 */ const QUICKSWAP_CUSTOM_BASES = {};
const QUICKSWAP_BASE_AGAINST_TOKENS = {
    ..._masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WNATIVE_ONLY */ .HL,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Matic]: [
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WNATIVE */ .FX,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .DAI */ .h1,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDC */ .gn,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDT */ .AA,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .QUICK */ .xZ,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ETHER */ .c0,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WBTC */ .ML,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .maUSDC */ .J6
    ].map((x)=>x[_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Matic])
};


/***/ }),

/***/ 62569:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   S: () => (/* binding */ SUSHISWAP_BASE_AGAINST_TOKENS),
/* harmony export */   v: () => (/* binding */ SUSHISWAP_CUSTOM_BASES)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46854);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24770);

/**
 * Some tokens can only be swapped via certain pairs,
 * so we override the list of bases that are considered for these tokens.
 */ const SUSHISWAP_CUSTOM_BASES = {};
const SUSHISWAP_BASE_AGAINST_TOKENS = {
    ..._masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WNATIVE_ONLY */ .HL,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet]: [
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WNATIVE */ .FX,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .DAI */ .h1,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDC */ .gn,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDT */ .AA,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WBTC */ .ML,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .RUNE */ .uj,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .NFTX */ .lK,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .STETH */ ._S
    ].map((x)=>x[_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet]),
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Matic]: [
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WNATIVE */ .FX,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDC */ .gn,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WBTC */ .ML,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .DAI */ .h1,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDT */ .AA
    ].map((x)=>x[_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Matic]),
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.BSC]: [
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WNATIVE */ .FX,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .DAI */ .h1,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .BUSD */ .lz,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDC */ .gn,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDT */ .AA,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .BTCB */ .nB
    ].map((x)=>x[_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.BSC]),
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.xDai]: [
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WNATIVE */ .FX,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDC */ .gn,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDT */ .AA,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WBTC */ .ML
    ].map((x)=>x[_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.xDai]),
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Celo]: [
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WNATIVE */ .FX,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .CUSD */ .PX,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .CEUR */ .Th
    ].map((x)=>x[_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Celo]),
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Fantom]: [
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WNATIVE */ .FX,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .DAI */ .h1,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDC */ .gn,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .fUSDT */ .Hh,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WBTC */ .ML
    ].map((x)=>x[_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Fantom]),
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Avalanche]: [
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WNATIVE */ .FX,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .DAI */ .h1,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDC */ .gn,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WBTC */ .ML,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDT */ .AA
    ].map((x)=>x[_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Avalanche]),
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Optimism]: [
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WNATIVE */ .FX,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .DAI */ .h1,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDC */ .gn,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WBTC */ .ML,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDT */ .AA
    ].map((x)=>x[_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Optimism])
};


/***/ }),

/***/ 9640:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Bq: () => (/* binding */ SLIPPAGE_MIN),
/* harmony export */   Gh: () => (/* binding */ BLOCK_TIME_SCALE),
/* harmony export */   IS: () => (/* binding */ ONE_BIPS),
/* harmony export */   JB: () => (/* binding */ MIN_SLIPPAGE),
/* harmony export */   Nd: () => (/* binding */ SLIPPAGE_DEFAULT),
/* harmony export */   PM: () => (/* binding */ BIPS_BASE),
/* harmony export */   Q9: () => (/* binding */ SLIPPAGE_MAX),
/* harmony export */   _P: () => (/* binding */ MIN_GAS_LIMIT),
/* harmony export */   ag: () => (/* binding */ DEFAULT_TRANSACTION_DEADLINE),
/* harmony export */   j2: () => (/* binding */ MAX_SLIPPAGE),
/* harmony export */   rI: () => (/* binding */ MINIMUM_AMOUNT),
/* harmony export */   rV: () => (/* binding */ L2_TRANSACTION_DEADLINE)
/* harmony export */ });
/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10149);
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29763);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(24770);



const MIN_GAS_LIMIT = '150000';
const MIN_SLIPPAGE = 50;
// 0.5%
const MAX_SLIPPAGE = 500;
// 5%
const BIPS_BASE = new bignumber_js__WEBPACK_IMPORTED_MODULE_0__/* .BigNumber */ .O(10000);
const ONE_BIPS = _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_1__/* .ONE */ .ry.dividedBy(BIPS_BASE);
const SLIPPAGE_MIN = 10;
// bips
const SLIPPAGE_DEFAULT = 50;
// bips
const SLIPPAGE_MAX = 2000;
// bips
const DEFAULT_TRANSACTION_DEADLINE = 30 * /* minutes */ 60;
/* seconds */ const L2_TRANSACTION_DEADLINE = 60 * /* minutes */ 5;
/* seconds */ const MINIMUM_AMOUNT = new bignumber_js__WEBPACK_IMPORTED_MODULE_0__/* .BigNumber */ .O('1e-6');
const BLOCK_TIME_SCALE = {
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ChainId */ .a_.Mainnet]: 3,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ChainId */ .a_.Ropsten]: 3,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ChainId */ .a_.Rinkeby]: 3,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ChainId */ .a_.Gorli]: 3,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ChainId */ .a_.Kovan]: 3,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ChainId */ .a_.BSC]: 6,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ChainId */ .a_.BSCT]: 6,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ChainId */ .a_.Base]: 6,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ChainId */ .a_.Base_Goerli]: 6,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ChainId */ .a_.Matic]: 6,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ChainId */ .a_.Mumbai]: 6,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ChainId */ .a_.Arbitrum]: 6,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ChainId */ .a_.Arbitrum_Rinkeby]: 6,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ChainId */ .a_.xDai]: 6,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ChainId */ .a_.Avalanche]: 6,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ChainId */ .a_.Avalanche_Fuji]: 6,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ChainId */ .a_.Celo]: 6,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ChainId */ .a_.Fantom]: 6,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ChainId */ .a_.Aurora]: 6,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ChainId */ .a_.Aurora_Testnet]: 6,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ChainId */ .a_.Fuse]: 6,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ChainId */ .a_.Boba]: 6,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ChainId */ .a_.Metis]: 6,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ChainId */ .a_.Optimism]: 6,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ChainId */ .a_.Optimism_Kovan]: 6,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ChainId */ .a_.Optimism_Goerli]: 6,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ChainId */ .a_.Conflux]: 6,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ChainId */ .a_.Astar]: 6,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ChainId */ .a_.ZKSync_Alpha_Testnet]: 6,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ChainId */ .a_.Crossbell]: 6,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ChainId */ .a_.Moonbeam]: 6,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ChainId */ .a_.Invalid]: 0
};


/***/ }),

/***/ 72128:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   X: () => (/* binding */ TRADERJOE_BASE_AGAINST_TOKENS),
/* harmony export */   b: () => (/* binding */ TRADERJOE_CUSTOM_BASES)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46854);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24770);

/**
 * Some tokens can only be swapped via certain pairs,
 * so we override the list of bases that are considered for these tokens.
 */ const TRADERJOE_CUSTOM_BASES = {};
const TRADERJOE_BASE_AGAINST_TOKENS = {
    ..._masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WNATIVE_ONLY */ .HL,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Avalanche]: [
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WNATIVE */ .FX,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .DAIe */ .Lq,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDTe */ ._c,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDCe */ .tB,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WBTCe */ .MI
    ].map((x)=>x[_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Avalanche])
};


/***/ }),

/***/ 33370:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ TRISOLARIS_CUSTOM_BASES),
/* harmony export */   m: () => (/* binding */ TRISOLARIS_BASE_AGAINST_TOKENS)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46854);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24770);

/**
 * Some tokens can only be swapped via certain pairs,
 * so we override the list of bases that are considered for these tokens.
 */ const TRISOLARIS_CUSTOM_BASES = {};
const TRISOLARIS_BASE_AGAINST_TOKENS = {
    ..._masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WNATIVE_ONLY */ .HL,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Matic]: [
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WNATIVE */ .FX,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDC */ .gn,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WBTC */ .ML,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .DAI */ .h1,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDT */ .AA
    ].map((x)=>x[_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Matic]),
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Aurora]: [
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WNATIVE */ .FX,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .DAI */ .h1,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDT */ .AA,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDC */ .gn,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WBTC */ .ML
    ].map((x)=>x[_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Aurora])
};


/***/ }),

/***/ 30604:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   QQ: () => (/* binding */ UNISWAP_CUSTOM_BASES),
/* harmony export */   Ru: () => (/* binding */ BETTER_TRADE_LESS_HOPS_THRESHOLD),
/* harmony export */   Zw: () => (/* binding */ INPUT_FRACTION_AFTER_FEE),
/* harmony export */   dJ: () => (/* binding */ UNISWAP_BIPS_BASE),
/* harmony export */   fI: () => (/* binding */ ZERO_PERCENT),
/* harmony export */   s9: () => (/* binding */ MAX_HOP),
/* harmony export */   u7: () => (/* binding */ UNISWAP_BASE_AGAINST_TOKENS),
/* harmony export */   yC: () => (/* binding */ ONE_HUNDRED_PERCENT)
/* harmony export */ });
/* harmony import */ var _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(51944);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24770);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(46854);


const UNISWAP_BIPS_BASE = 10000;
/**
 * Some tokens can only be swapped via certain pairs,
 * so we override the list of bases that are considered for these tokens.
 */ const UNISWAP_CUSTOM_BASES = {
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet]: {
        [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .AMPL */ .s5[_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet].address]: [
            _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .DAI */ .h1,
            _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .WNATIVE */ .FX
        ].map((x)=>x[_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet])
    },
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Matic]: {
        [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .AMPL */ .s5[_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Matic].address]: [
            _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .DAI */ .h1,
            _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .WNATIVE */ .FX
        ].map((x)=>x[_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Matic])
    }
};
const UNISWAP_BASE_AGAINST_TOKENS = {
    ..._masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .WNATIVE_ONLY */ .HL,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet]: [
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .WNATIVE */ .FX,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .DAI */ .h1,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .USDC */ .gn,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .USDT */ .AA,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .WBTC */ .ML
    ].map((x)=>x[_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet]),
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Matic]: [
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .WNATIVE */ .FX,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .DAI */ .h1,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .USDC */ .gn,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .USDT */ .AA,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .WBTC */ .ML
    ].map((x)=>x[_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Matic]),
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Optimism]: [
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .WNATIVE */ .FX,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .DAI */ .h1,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .USDC */ .gn,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .USDT */ .AA,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .WBTC */ .ML,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__.OP
    ].map((x)=>x[_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Optimism])
};
const MAX_HOP = 3;
// used to ensure the user doesn't send so much ETH so they end up with <.01
const BETTER_TRADE_LESS_HOPS_THRESHOLD = new _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__/* .Percent */ .gG(50, 10000);
const BASE_FEE = new _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__/* .Percent */ .gG(30, 10000);
const ZERO_PERCENT = new _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__/* .Percent */ .gG(0);
const ONE_HUNDRED_PERCENT = new _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_0__/* .Percent */ .gG(1);
const INPUT_FRACTION_AFTER_FEE = ONE_HUNDRED_PERCENT.subtract(BASE_FEE);


/***/ }),

/***/ 41438:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E: () => (/* binding */ VERSA_CUSTOM_BASES),
/* harmony export */   c: () => (/* binding */ VERSA_BASE_AGAINST_TOKENS)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46854);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24770);

/**
 * Some tokens can only be swapped via certain pairs,
 * so we override the list of bases that are considered for these tokens.
 */ const VERSA_CUSTOM_BASES = {};
const VERSA_BASE_AGAINST_TOKENS = {
    ..._masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WNATIVE_ONLY */ .HL,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Astar]: [
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WNATIVE */ .FX,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDC */ .gn,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDT */ .AA,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .BUSD */ .lz,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .VERSA */ .k
    ].map((x)=>x[_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Astar])
};


/***/ }),

/***/ 55175:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   N: () => (/* binding */ WANNASWAP_BASE_AGAINST_TOKENS),
/* harmony export */   z: () => (/* binding */ WANNASWAP_CUSTOM_BASES)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46854);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24770);

/**
 * Some tokens can only be swapped via certain pairs,
 * so we override the list of bases that are considered for these tokens.
 */ const WANNASWAP_CUSTOM_BASES = {};
const WANNASWAP_BASE_AGAINST_TOKENS = {
    ..._masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WNATIVE_ONLY */ .HL,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Aurora]: [
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WNATIVE */ .FX,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WANNA */ .lB,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .DAI */ .h1,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDC */ .gn,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDT */ .AA,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WBTC */ .ML
    ].map((x)=>x[_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Aurora])
};


/***/ }),

/***/ 82131:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   I: () => (/* binding */ YUMISWAP_CUSTOM_BASES),
/* harmony export */   n: () => (/* binding */ YUMISWAP_BASE_AGAINST_TOKENS)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46854);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24770);

/**
 * Some tokens can only be swapped via certain pairs,
 * so we override the list of bases that are considered for these tokens.
 */ const YUMISWAP_CUSTOM_BASES = {};
const YUMISWAP_BASE_AGAINST_TOKENS = {
    ..._masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WNATIVE_ONLY */ .HL,
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Astar]: [
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WNATIVE */ .FX,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDC */ .gn,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDT */ .AA,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .YUMI */ ._$,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .DAI */ .h1,
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .xYUMI */ .Xm
    ].map((x)=>x[_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Astar])
};


/***/ }),

/***/ 40214:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   b: () => (/* binding */ swapCallParameters)
/* harmony export */ });
/* harmony import */ var _uniswap_v2_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19779);
/* harmony import */ var _masknet_public_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(64455);


// Pangolin and TraderJoe have modified uniswap contracts
function swapCallParameters(trade, options, tradeProvider) {
    const parameters = _uniswap_v2_sdk__WEBPACK_IMPORTED_MODULE_0__/* .Router */ .F0.swapCallParameters(trade, options);
    if (tradeProvider === _masknet_public_api__WEBPACK_IMPORTED_MODULE_1__/* .TradeProvider */ .z4.PANGOLIN || tradeProvider === _masknet_public_api__WEBPACK_IMPORTED_MODULE_1__/* .TradeProvider */ .z4.TRADERJOE) {
        switch(parameters.methodName){
            case 'WETH':
                parameters.methodName = 'WAVAX';
                break;
            case 'swapTokensForExactETH':
                parameters.methodName = 'swapTokensForExactAVAX';
                break;
            case 'swapExactTokensForETHSupportingFeeOnTransferTokens':
                /* cspell:disable-next-line */ parameters.methodName = 'swapExactTokensForAVAXSupportingFeeOnTransferTokens';
                break;
            case 'swapExactTokensForETH':
                parameters.methodName = 'swapExactTokensForAVAX';
                break;
            case 'swapExactETHForTokensSupportingFeeOnTransferTokens':
                /* cspell:disable-next-line */ parameters.methodName = 'swapExactAVAXForTokensSupportingFeeOnTransferTokens';
                break;
            case 'swapExactETHForTokens':
                parameters.methodName = 'swapExactAVAXForTokens';
                break;
        }
    }
    return parameters;
}


/***/ }),

/***/ 63713:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   J: () => (/* binding */ swapErrorToUserReadableMessage)
/* harmony export */ });
function swapErrorToUserReadableMessage(error) {
    let reason;
    while(error){
        reason = error.reason ?? error.message ?? reason;
        error = error.error ?? error.data?.originalError;
    }
    if (reason?.startsWith('execution reverted: ')) reason = reason.slice('execution reverted: '.length);
    switch(reason){
        case 'UniswapV2Router: EXPIRED':
            return 'The transaction could not be sent because the deadline has passed. Please check that your transaction deadline is not too low.';
        case 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT':
        case 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT':
            return 'This transaction will not succeed either due to price movement or fee on transfer.';
        case 'TransferHelper: TRANSFER_FROM_FAILED':
            return 'The input token cannot be transferred. There may be an issue with the input token.';
        case 'UniswapV2: TRANSFER_FAILED':
            return 'The output token cannot be transferred. There may be an issue with the output token.';
        case 'UniswapV2: K':
            return 'The Uniswap invariant x*y=k was not satisfied by the swap. This usually means one of the tokens you are swapping incorporates custom behavior on transfer.';
        case 'Too little received':
        case 'Too much requested':
        case 'STF':
            return 'This transaction will not succeed due to price movement.';
        case 'TF':
            return 'The output token cannot be transferred. There may be an issue with the output token.';
        default:
            if (reason?.includes('undefined is not an object')) {
                console.error(error, reason);
                return 'An error occurred when trying to execute this swap. You may need to increase your slippage tolerance. If that does not work, there may be an incompatibility with the token you are trading.';
            }
            return `Unknown error${reason ? `: "${reason}"` : ''}.`;
    }
}


/***/ }),

/***/ 17489:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  O: () => (/* binding */ Bancor)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/urlcat@3.1.0_patch_hash=5r5xyq4zgcnqugwsrx4lxq2i4e/node_modules/urlcat/dist/index.mjs
var dist = __webpack_require__(78757);
// EXTERNAL MODULE: ./node_modules/.pnpm/bignumber.js@9.1.2/node_modules/bignumber.js/bignumber.mjs
var bignumber = __webpack_require__(10149);
// EXTERNAL MODULE: ./node_modules/.pnpm/web3-utils@1.10.2/node_modules/web3-utils/lib/index.js
var lib = __webpack_require__(84976);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/pick.js + 1 modules
var pick = __webpack_require__(27043);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/constants/constants.ts
var constants = __webpack_require__(33026);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/address.ts
var address = __webpack_require__(65327);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/token.ts
var token = __webpack_require__(48289);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/libs/ContractTransaction.ts
var ContractTransaction = __webpack_require__(21704);
// EXTERNAL MODULE: ./packages/public-api/src/web.ts
var web = __webpack_require__(64455);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/number.ts
var number = __webpack_require__(29763);
// EXTERNAL MODULE: ./packages/web3-providers/src/types/Trader.ts
var Trader = __webpack_require__(53520);
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/fetchJSON.ts
var fetchJSON = __webpack_require__(11834);
// EXTERNAL MODULE: ./packages/web3-providers/src/entry.ts
var entry = __webpack_require__(62322);
// EXTERNAL MODULE: ./packages/plugins/Trader/src/constants/trader.ts
var trader = __webpack_require__(9640);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/types/index.ts
var types = __webpack_require__(24770);
;// CONCATENATED MODULE: ./packages/plugins/Trader/src/constants/bancor.ts

const BANCOR_API_BASE_URL = {
    [types/* ChainId */.a_.Mainnet]: 'https://api-v2.bancor.network',
    [types/* ChainId */.a_.Ropsten]: 'https://serve-ropsten-ptdczarhfq-nw.a.run.app'
};

;// CONCATENATED MODULE: ./packages/plugins/Trader/src/providers/Bancor.ts











const roundDecimal = (value, decimals)=>{
    return Math.round(Number(value || 0) * Math.pow(10, decimals)) / Math.pow(10, decimals);
};
const calculateMinimumReturn = ({ toToken, toAmount, slippage })=>{
    const toWei = (0,number/* rightShift */.pu)(toAmount || '0', toToken.decimals);
    const slippageWei = new bignumber/* BigNumber */.O(slippage).dividedBy(trader/* BIPS_BASE */.PM);
    const minReturnWei = toWei.times(number/* ONE */.ry.minus(slippageWei));
    return (0,number/* leftShift */.w5)(minReturnWei, toToken.decimals).toFixed();
};
class BancorAPI {
    provider = web/* TradeProvider */.z4.BANCOR;
    async swapTransactionBancor(request) {
        const baseUrl = BANCOR_API_BASE_URL[request.chainId];
        const url = (0,dist/* default */.ZP)(baseUrl, '/transactions/swap', {
            source_dlt_type: 'ethereum',
            source_dlt_id: (0,lib.toChecksumAddress)(request.fromToken.address),
            target_dlt_type: 'ethereum',
            target_dlt_id: (0,lib.toChecksumAddress)(request.toToken.address),
            amount: roundDecimal(request.fromAmount, request.fromToken.decimals),
            min_return: roundDecimal(request.minimumReceived, request.toToken.decimals),
            user_source_dlt_id: request.user
        });
        return (0,fetchJSON/* fetchJSON */.ZV)(url);
    }
    async swapBancor(request) {
        const baseUrl = BANCOR_API_BASE_URL[request.chainId];
        const { fromToken, toToken, slippage } = request;
        const url = (0,dist/* default */.ZP)(baseUrl, '/pricing/target-amount', {
            source_dlt_type: 'ethereum',
            source_dlt_id: request.fromToken?.address,
            target_dlt_type: 'ethereum',
            target_dlt_id: request.toToken?.address,
            amount: roundDecimal(request.fromAmount, request.fromToken.decimals)
        });
        const response = await (0,fetchJSON/* fetchJSON */.ZV)(url);
        const validationErrorResponse = response;
        if (validationErrorResponse.error) {
            throw new Error(validationErrorResponse.error?.messages?.[0] || 'Unknown Error');
        }
        const { amount } = response;
        const toAmount = amount;
        const fromAmount = request.fromAmount;
        return {
            ...request,
            toAmount,
            fromAmount,
            minimumReceived: calculateMinimumReturn({
                toToken,
                toAmount,
                slippage
            }),
            fromTokenSymbol: fromToken.symbol,
            toTokenSymbol: toToken.symbol
        };
    }
    async getTrade(chainId, account, inputAmount, slippage, inputToken, outputToken) {
        const { BANCOR_ETH_ADDRESS } = (0,constants/* getTraderConstants */.Gr)(chainId);
        if (!inputToken || !outputToken || (0,number/* isZero */.Fr)(inputAmount) || !BANCOR_ETH_ADDRESS) return null;
        const fromToken = (0,address/* isNativeTokenAddress */.qw)(inputToken.address) ? {
            ...inputToken,
            address: BANCOR_ETH_ADDRESS
        } : inputToken;
        const toToken = (0,address/* isNativeTokenAddress */.qw)(outputToken.address) ? {
            ...outputToken,
            address: BANCOR_ETH_ADDRESS
        } : outputToken;
        return this.swapBancor({
            strategy: Trader/* TraderAPI */.N.TradeStrategy.ExactIn,
            fromToken,
            toToken,
            fromAmount: (0,number/* leftShift */.w5)(inputAmount, inputToken.decimals).toFixed(),
            toAmount: '0',
            slippage,
            user: account,
            chainId: chainId,
            minimumReceived: '0'
        });
    }
    async getTradeInfo(chainId, account, inputAmount_, slippage, inputToken, outputToken) {
        try {
            const trade = await this.getTrade(chainId, account, inputAmount_, slippage, inputToken, outputToken);
            if (!trade) return null;
            const inputAmountWei = (0,number/* rightShift */.pu)(trade.fromAmount || '0', inputToken?.decimals);
            const outputAmountWei = (0,number/* rightShift */.pu)(trade.toAmount || '0', outputToken?.decimals);
            const minimumReceivedWei = (0,number/* rightShift */.pu)(trade.minimumReceived, outputToken?.decimals);
            const computed = {
                strategy: Trader/* TraderAPI */.N.TradeStrategy.ExactIn,
                inputToken,
                outputToken,
                inputAmount: inputAmountWei,
                outputAmount: outputAmountWei,
                executionPrice: number/* ZERO */.xE,
                fee: number/* ZERO */.xE,
                maximumSold: inputAmountWei,
                minimumReceived: minimumReceivedWei,
                priceImpact: number/* ZERO */.xE,
                trade_: {
                    ...trade
                }
            };
            try {
                const gas = await this.getTradeGasLimit(account, chainId, computed);
                return {
                    gas,
                    value: computed,
                    provider: this.provider
                };
            } catch  {
                return {
                    value: computed,
                    provider: this.provider
                };
            }
        } catch (error) {
            if (error instanceof Error) {
                return {
                    value: null,
                    error,
                    provider: this.provider
                };
            }
            return null;
        }
    }
    async getNativeWrapperTradeInfo(chainId, account, inputAmount, inputToken, outputToken) {
        const { WNATIVE_ADDRESS } = (0,constants/* getTokenConstants */.aV)(chainId);
        const tradeAmount = new bignumber/* BigNumber */.O(inputAmount || '0');
        if (tradeAmount.isZero() || !inputToken || !outputToken || !WNATIVE_ADDRESS) return null;
        const wrapperContract = entry/* ContractReadonly */.$u.getWETHContract(WNATIVE_ADDRESS, {
            chainId
        });
        const computed = {
            strategy: Trader/* TraderAPI */.N.TradeStrategy.ExactIn,
            inputToken,
            outputToken,
            inputAmount: tradeAmount,
            outputAmount: tradeAmount,
            executionPrice: number/* ZERO */.xE,
            maximumSold: number/* ZERO */.xE,
            minimumReceived: tradeAmount,
            priceImpact: number/* ZERO */.xE,
            fee: number/* ZERO */.xE,
            trade_: {
                isWrap: (0,token/* isNativeTokenSchemaType */.SC)(inputToken.schema),
                isNativeTokenWrapper: true
            }
        };
        try {
            const tx = await new ContractTransaction/* ContractTransaction */.D(wrapperContract).fillAll(wrapperContract?.methods.deposit(), {
                from: account,
                value: tradeAmount.toFixed()
            });
            const gas = tx.gas ?? '0';
            return {
                gas,
                provider: this.provider,
                value: computed
            };
        } catch  {
            return {
                value: computed,
                provider: this.provider
            };
        }
    }
    async getTradeGasLimit(account, chainId, tradeComputed) {
        if (!account || !tradeComputed?.trade_) return '0';
        const trade = tradeComputed.trade_;
        const data = await this.swapTransactionBancor(trade);
        // Note that if approval is required, the API will also return the necessary approval transaction.
        const transaction = data.length === 1 ? data[0] : data[1];
        return entry/* Web3Readonly */.MJ.estimateTransaction((0,pick/* default */.Z)(transaction.transaction, [
            'to',
            'data',
            'value',
            'from'
        ]), 0, {
            chainId
        });
    }
}
const Bancor = new BancorAPI();


/***/ }),

/***/ 22733:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   I: () => (/* binding */ currentSlippageSettings)
/* harmony export */ });
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6938);
/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(22325);
/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9640);


/**
 * The slippage tolerance of trader
 */ const currentSlippageSettings = (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_0__/* .createGlobalSettings */ .TI)(`${_constants_index_js__WEBPACK_IMPORTED_MODULE_1__/* .PLUGIN_ID */ .U}+slippageTolerance`, _constants_index_js__WEBPACK_IMPORTED_MODULE_2__/* .SLIPPAGE_DEFAULT */ .Nd);


/***/ }),

/***/ 6780:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  AF: () => (/* binding */ AllProviderTradeActionType),
  TX: () => (/* binding */ AllProviderTradeContext)
});

// UNUSED EXPORTS: INITIAL_STATE, useAllProviderTradeContext

// EXTERNAL MODULE: ./node_modules/.pnpm/react@0.0.0-experimental-0a360642d-20230711/node_modules/react/index.js
var react = __webpack_require__(78996);
// EXTERNAL MODULE: ./node_modules/.pnpm/unstated-next@1.1.0/node_modules/unstated-next/dist/unstated-next.mjs
var unstated_next = __webpack_require__(54225);
// EXTERNAL MODULE: ./packages/web3-hooks/base/src/useContext.tsx + 1 modules
var useContext = __webpack_require__(14162);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/number.ts
var number = __webpack_require__(29763);
// EXTERNAL MODULE: ./packages/public-api/src/web.ts
var web = __webpack_require__(64455);
// EXTERNAL MODULE: ./node_modules/.pnpm/react-use@17.4.0_react-dom@0.0.0-experimental-0a360642d-20230711_react@0.0.0-experimental-0a360642d-20230711/node_modules/react-use/esm/useAsyncRetry.js
var useAsyncRetry = __webpack_require__(77219);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/isSameAddress.ts
var isSameAddress = __webpack_require__(74765);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/constants/constants.ts
var constants = __webpack_require__(33026);
// EXTERNAL MODULE: ./packages/web3-hooks/base/src/useWeb3Others.ts
var useWeb3Others = __webpack_require__(81128);
// EXTERNAL MODULE: ./packages/shared-base/src/types/PluginID.ts
var PluginID = __webpack_require__(24835);
;// CONCATENATED MODULE: ./packages/plugins/Trader/src/trader/native/useTrade.ts





function useTrade(inputToken, outputToken) {
    const { chainId: targetChainId } = (0,useContext/* useChainContext */.ql)();
    const { pluginID } = (0,useContext/* useNetworkContext */.gK)();
    const WNATIVE_ADDRESS = (0,constants/* useTokenConstant */.oo)(targetChainId, 'WNATIVE_ADDRESS');
    const Others = (0,useWeb3Others/* useWeb3Others */.v)();
    // to mimic the same interface with other trade providers
    return (0,useAsyncRetry/* default */.Z)(async ()=>{
        if (!inputToken || !outputToken || pluginID !== PluginID/* NetworkPluginID */.F.PLUGIN_EVM) return false;
        // none of the tokens is native token
        if (!Others.isNativeTokenSchemaType(inputToken.schema) && !Others.isNativeTokenSchemaType(outputToken.schema)) return false;
        // none of the tokens is wrapped native token
        if (!(0,isSameAddress/* isSameAddress */.W)(inputToken.address, WNATIVE_ADDRESS) && !(0,isSameAddress/* isSameAddress */.W)(outputToken.address, WNATIVE_ADDRESS)) return false;
        return true;
    }, [
        WNATIVE_ADDRESS,
        inputToken,
        outputToken,
        pluginID,
        Others.isNativeTokenSchemaType
    ]);
}

// EXTERNAL MODULE: ./packages/web3-hooks/base/src/useNetwork.ts
var useNetwork = __webpack_require__(70858);
// EXTERNAL MODULE: ./packages/web3-hooks/base/src/useBeat.ts
var useBeat = __webpack_require__(42938);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/clamp.js
var clamp = __webpack_require__(47494);
// EXTERNAL MODULE: ./packages/shared-base-ui/src/hooks/useValueRef.ts
var useValueRef = __webpack_require__(84271);
// EXTERNAL MODULE: ./packages/plugins/Trader/src/settings.ts
var settings = __webpack_require__(22733);
// EXTERNAL MODULE: ./packages/plugins/Trader/src/constants/trader.ts
var trader = __webpack_require__(9640);
;// CONCATENATED MODULE: ./packages/plugins/Trader/src/trader/useSlippageTolerance.ts




function useSlippageTolerance() {
    const slippage_ = (0,useValueRef/* useValueRef */.E)(settings/* currentSlippageSettings */.I);
    return (0,clamp/* default */.Z)(slippage_, trader/* SLIPPAGE_MIN */.Bq, trader/* SLIPPAGE_MAX */.Q9);
}

// EXTERNAL MODULE: ./node_modules/.pnpm/@masknet+kit@0.1.2/node_modules/@masknet/kit/esm/index.js + 1 modules
var esm = __webpack_require__(30898);
// EXTERNAL MODULE: ./packages/shared-base/src/constants.ts
var src_constants = __webpack_require__(52033);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/types/index.ts
var types = __webpack_require__(24770);
;// CONCATENATED MODULE: ./packages/plugins/Trader/src/helpers/getEVMAvailableTraderProviders.ts




function getEVMAvailableTraderProviders(networkType) {
    if (!networkType) return src_constants/* EMPTY_LIST */.rP;
    switch(networkType){
        case types/* NetworkType */.td.Ethereum:
            return [
                web/* TradeProvider */.z4.UNISWAP_V2,
                web/* TradeProvider */.z4.UNISWAP_V3,
                web/* TradeProvider */.z4.SUSHISWAP,
                web/* TradeProvider */.z4.ZRX,
                web/* TradeProvider */.z4.DODO,
                web/* TradeProvider */.z4.BANCOR,
                web/* TradeProvider */.z4.OPENOCEAN,
                web/* TradeProvider */.z4.MDEX
            ];
        case types/* NetworkType */.td.Polygon:
            return [
                web/* TradeProvider */.z4.UNISWAP_V3,
                web/* TradeProvider */.z4.QUICKSWAP,
                web/* TradeProvider */.z4.SUSHISWAP,
                web/* TradeProvider */.z4.DODO,
                web/* TradeProvider */.z4.ZRX,
                web/* TradeProvider */.z4.OPENOCEAN,
                web/* TradeProvider */.z4.TRISOLARIS
            ];
        case types/* NetworkType */.td.Binance:
            return [
                web/* TradeProvider */.z4.PANCAKESWAP,
                web/* TradeProvider */.z4.SUSHISWAP,
                web/* TradeProvider */.z4.DODO,
                web/* TradeProvider */.z4.ZRX,
                web/* TradeProvider */.z4.OPENOCEAN,
                web/* TradeProvider */.z4.MDEX
            ];
        case types/* NetworkType */.td.Base:
            return src_constants/* EMPTY_LIST */.rP;
        case types/* NetworkType */.td.Arbitrum:
            return [
                web/* TradeProvider */.z4.UNISWAP_V3,
                web/* TradeProvider */.z4.OPENOCEAN,
                web/* TradeProvider */.z4.DODO
            ];
        case types/* NetworkType */.td.xDai:
            return [
                web/* TradeProvider */.z4.SUSHISWAP,
                web/* TradeProvider */.z4.OPENOCEAN
            ];
        case types/* NetworkType */.td.Avalanche:
            return [
                web/* TradeProvider */.z4.SUSHISWAP,
                web/* TradeProvider */.z4.OPENOCEAN,
                web/* TradeProvider */.z4.TRADERJOE,
                web/* TradeProvider */.z4.PANGOLIN
            ];
        case types/* NetworkType */.td.Celo:
            return [
                web/* TradeProvider */.z4.SUSHISWAP
            ];
        case types/* NetworkType */.td.Fantom:
            return [
                web/* TradeProvider */.z4.SUSHISWAP
            ];
        case types/* NetworkType */.td.Optimism:
            return [
                web/* TradeProvider */.z4.UNISWAP_V3
            ];
        case types/* NetworkType */.td.Aurora:
            return [
                web/* TradeProvider */.z4.DODO,
                web/* TradeProvider */.z4.WANNASWAP,
                web/* TradeProvider */.z4.TRISOLARIS
            ];
        case types/* NetworkType */.td.Astar:
            return [
                web/* TradeProvider */.z4.ARTHSWAP,
                web/* TradeProvider */.z4.VERSA,
                web/* TradeProvider */.z4.ASTAREXCHANGE,
                web/* TradeProvider */.z4.YUMISWAP
            ];
        case types/* NetworkType */.td.Scroll:
        case types/* NetworkType */.td.Boba:
        case types/* NetworkType */.td.Fuse:
        case types/* NetworkType */.td.Metis:
        case types/* NetworkType */.td.Conflux:
        case types/* NetworkType */.td.Moonbeam:
        case types/* NetworkType */.td.CustomNetwork:
            console.error('To be implement network:', networkType);
            return src_constants/* EMPTY_LIST */.rP;
        default:
            (0,esm/* safeUnreachable */.P)(networkType);
            return src_constants/* EMPTY_LIST */.rP;
    }
}

// EXTERNAL MODULE: ./node_modules/.pnpm/web3-utils@1.10.2/node_modules/web3-utils/lib/index.js
var lib = __webpack_require__(84976);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/flatMap.js
var flatMap = __webpack_require__(81412);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/compact.js
var compact = __webpack_require__(72845);
// EXTERNAL MODULE: ./node_modules/.pnpm/bignumber.js@9.1.2/node_modules/bignumber.js/bignumber.mjs
var bignumber = __webpack_require__(10149);
// EXTERNAL MODULE: ./node_modules/.pnpm/@uniswap+sdk-core@3.0.1/node_modules/@uniswap/sdk-core/dist/sdk-core.esm.js
var sdk_core_esm = __webpack_require__(51944);
// EXTERNAL MODULE: ./node_modules/.pnpm/@uniswap+v2-sdk@3.0.0-alpha.2/node_modules/@uniswap/v2-sdk/dist/v2-sdk.esm.js
var v2_sdk_esm = __webpack_require__(19779);
// EXTERNAL MODULE: ./node_modules/.pnpm/@uniswap+v3-sdk@3.9.0_patch_hash=i674dmxu47nk67u5bur7yueebu_hardhat@2.17.2/node_modules/@uniswap/v3-sdk/dist/v3-sdk.esm.js
var v3_sdk_esm = __webpack_require__(466);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/isValidChainId.ts
var isValidChainId = __webpack_require__(37049);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/token.ts
var token = __webpack_require__(48289);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/libs/ContractTransaction.ts
var ContractTransaction = __webpack_require__(21704);
// EXTERNAL MODULE: ./packages/web3-providers/src/entry.ts
var entry = __webpack_require__(62322);
// EXTERNAL MODULE: ./packages/web3-providers/src/types/Trader.ts
var Trader = __webpack_require__(53520);
// EXTERNAL MODULE: ./packages/plugins/Trader/src/constants/uniswap.ts
var uniswap = __webpack_require__(30604);
// EXTERNAL MODULE: ./packages/plugins/Trader/src/constants/sushiswap.ts
var sushiswap = __webpack_require__(62569);
// EXTERNAL MODULE: ./packages/plugins/Trader/src/constants/quickswap.ts
var quickswap = __webpack_require__(56065);
// EXTERNAL MODULE: ./packages/plugins/Trader/src/constants/pancakeswap.ts
var pancakeswap = __webpack_require__(12134);
// EXTERNAL MODULE: ./packages/plugins/Trader/src/constants/traderjoe.ts
var traderjoe = __webpack_require__(72128);
// EXTERNAL MODULE: ./packages/plugins/Trader/src/constants/pangolindex.ts
var pangolindex = __webpack_require__(91280);
// EXTERNAL MODULE: ./packages/plugins/Trader/src/constants/wannaswap.ts
var wannaswap = __webpack_require__(55175);
// EXTERNAL MODULE: ./packages/plugins/Trader/src/constants/trisolaris.ts
var trisolaris = __webpack_require__(33370);
// EXTERNAL MODULE: ./packages/plugins/Trader/src/constants/mdex.ts
var mdex = __webpack_require__(25835);
// EXTERNAL MODULE: ./packages/plugins/Trader/src/constants/arthswap.ts
var arthswap = __webpack_require__(49668);
// EXTERNAL MODULE: ./packages/plugins/Trader/src/constants/versa.ts
var versa = __webpack_require__(41438);
// EXTERNAL MODULE: ./packages/plugins/Trader/src/constants/astarexchange.ts
var astarexchange = __webpack_require__(34458);
// EXTERNAL MODULE: ./packages/plugins/Trader/src/constants/yumiswap.ts
var yumiswap = __webpack_require__(82131);
;// CONCATENATED MODULE: ./packages/plugins/Trader/src/helpers/getTradeContext.ts




function getTradeContext(chainId, tradeProvider) {
    const DEX_TRADE = (0,constants/* getTraderConstants */.Gr)(chainId);
    switch(tradeProvider){
        case web/* TradeProvider */.z4.UNISWAP_V2:
            return {
                TYPE: tradeProvider,
                IS_UNISWAP_V2_LIKE: true,
                GRAPH_API: DEX_TRADE.UNISWAP_V2_THEGRAPH,
                INIT_CODE_HASH: DEX_TRADE.UNISWAP_V2_INIT_CODE_HASH,
                ROUTER_CONTRACT_ADDRESS: DEX_TRADE.UNISWAP_V2_ROUTER_ADDRESS,
                SPENDER_CONTRACT_ADDRESS: DEX_TRADE.UNISWAP_V2_ROUTER_ADDRESS,
                FACTORY_CONTRACT_ADDRESS: DEX_TRADE.UNISWAP_V2_FACTORY_ADDRESS,
                AGAINST_TOKENS: uniswap/* UNISWAP_BASE_AGAINST_TOKENS */.u7,
                ADDITIONAL_TOKENS: {},
                CUSTOM_TOKENS: uniswap/* UNISWAP_CUSTOM_BASES */.QQ
            };
        case web/* TradeProvider */.z4.UNISWAP_V3:
            return {
                TYPE: tradeProvider,
                IS_UNISWAP_V3_LIKE: true,
                GRAPH_API: DEX_TRADE.UNISWAP_V3_THEGRAPH,
                INIT_CODE_HASH: DEX_TRADE.UNISWAP_V3_INIT_CODE_HASH,
                ROUTER_CONTRACT_ADDRESS: DEX_TRADE.UNISWAP_SWAP_ROUTER_ADDRESS,
                SPENDER_CONTRACT_ADDRESS: DEX_TRADE.UNISWAP_SWAP_ROUTER_ADDRESS,
                FACTORY_CONTRACT_ADDRESS: DEX_TRADE.UNISWAP_V3_FACTORY_ADDRESS,
                AGAINST_TOKENS: uniswap/* UNISWAP_BASE_AGAINST_TOKENS */.u7,
                ADDITIONAL_TOKENS: {},
                CUSTOM_TOKENS: uniswap/* UNISWAP_CUSTOM_BASES */.QQ
            };
        case web/* TradeProvider */.z4.SUSHISWAP:
            return {
                TYPE: tradeProvider,
                IS_UNISWAP_V2_LIKE: true,
                GRAPH_API: DEX_TRADE.SUSHISWAP_THEGRAPH,
                INIT_CODE_HASH: DEX_TRADE.SUSHISWAP_INIT_CODE_HASH,
                ROUTER_CONTRACT_ADDRESS: DEX_TRADE.SUSHISWAP_ROUTER_ADDRESS,
                SPENDER_CONTRACT_ADDRESS: DEX_TRADE.SUSHISWAP_ROUTER_ADDRESS,
                FACTORY_CONTRACT_ADDRESS: DEX_TRADE.SUSHISWAP_FACTORY_ADDRESS,
                AGAINST_TOKENS: sushiswap/* SUSHISWAP_BASE_AGAINST_TOKENS */.S,
                ADDITIONAL_TOKENS: {},
                CUSTOM_TOKENS: sushiswap/* SUSHISWAP_CUSTOM_BASES */.v
            };
        case web/* TradeProvider */.z4.QUICKSWAP:
            return {
                TYPE: tradeProvider,
                IS_UNISWAP_V2_LIKE: true,
                GRAPH_API: DEX_TRADE.QUICKSWAP_THEGRAPH,
                INIT_CODE_HASH: DEX_TRADE.QUICKSWAP_INIT_CODE_HASH,
                ROUTER_CONTRACT_ADDRESS: DEX_TRADE.QUICKSWAP_ROUTER_ADDRESS,
                SPENDER_CONTRACT_ADDRESS: DEX_TRADE.QUICKSWAP_ROUTER_ADDRESS,
                FACTORY_CONTRACT_ADDRESS: DEX_TRADE.QUICKSWAP_FACTORY_ADDRESS,
                AGAINST_TOKENS: quickswap/* QUICKSWAP_BASE_AGAINST_TOKENS */.P,
                ADDITIONAL_TOKENS: {},
                CUSTOM_TOKENS: quickswap/* QUICKSWAP_CUSTOM_BASES */.j
            };
        case web/* TradeProvider */.z4.PANCAKESWAP:
            return {
                TYPE: tradeProvider,
                IS_UNISWAP_V2_LIKE: true,
                GRAPH_API: DEX_TRADE.PANCAKESWAP_THEGRAPH,
                INIT_CODE_HASH: DEX_TRADE.PANCAKESWAP_INIT_CODE_HASH,
                ROUTER_CONTRACT_ADDRESS: DEX_TRADE.PANCAKESWAP_ROUTER_ADDRESS,
                SPENDER_CONTRACT_ADDRESS: DEX_TRADE.PANCAKESWAP_ROUTER_ADDRESS,
                FACTORY_CONTRACT_ADDRESS: DEX_TRADE.PANCAKESWAP_FACTORY_ADDRESS,
                AGAINST_TOKENS: pancakeswap/* PANCAKESWAP_BASE_AGAINST_TOKENS */.D,
                ADDITIONAL_TOKENS: {},
                CUSTOM_TOKENS: pancakeswap/* PANCAKESWAP_CUSTOM_BASES */.t
            };
        case web/* TradeProvider */.z4.TRADERJOE:
            return {
                TYPE: tradeProvider,
                IS_UNISWAP_V2_LIKE: true,
                GRAPH_API: DEX_TRADE.TRADERJOE_THEGRAPH,
                INIT_CODE_HASH: DEX_TRADE.TRADERJOE_INIT_CODE_HASH,
                ROUTER_CONTRACT_ADDRESS: DEX_TRADE.TRADERJOE_ROUTER_ADDRESS,
                SPENDER_CONTRACT_ADDRESS: DEX_TRADE.TRADERJOE_ROUTER_ADDRESS,
                FACTORY_CONTRACT_ADDRESS: DEX_TRADE.TRADERJOE_FACTORY_ADDRESS,
                AGAINST_TOKENS: traderjoe/* TRADERJOE_BASE_AGAINST_TOKENS */.X,
                ADDITIONAL_TOKENS: {},
                CUSTOM_TOKENS: traderjoe/* TRADERJOE_CUSTOM_BASES */.b
            };
        case web/* TradeProvider */.z4.PANGOLIN:
            return {
                TYPE: tradeProvider,
                IS_UNISWAP_V2_LIKE: true,
                GRAPH_API: DEX_TRADE.PANGOLIN_THEGRAPH,
                INIT_CODE_HASH: DEX_TRADE.PANGOLIN_INIT_CODE_HASH,
                ROUTER_CONTRACT_ADDRESS: DEX_TRADE.PANGOLIN_ROUTER_ADDRESS,
                SPENDER_CONTRACT_ADDRESS: DEX_TRADE.PANGOLIN_ROUTER_ADDRESS,
                FACTORY_CONTRACT_ADDRESS: DEX_TRADE.PANGOLIN_FACTORY_ADDRESS,
                AGAINST_TOKENS: pangolindex/* PANGOLIN_BASE_AGAINST_TOKENS */.h,
                ADDITIONAL_TOKENS: {},
                CUSTOM_TOKENS: pangolindex/* PANGOLIN_CUSTOM_BASES */.G
            };
        case web/* TradeProvider */.z4.WANNASWAP:
            return {
                TYPE: tradeProvider,
                IS_UNISWAP_V2_LIKE: true,
                GRAPH_API: DEX_TRADE.WANNASWAP_THEGRAPH,
                INIT_CODE_HASH: DEX_TRADE.WANNASWAP_INIT_CODE_HASH,
                ROUTER_CONTRACT_ADDRESS: DEX_TRADE.WANNASWAP_ROUTER_V2_ADDRESS,
                SPENDER_CONTRACT_ADDRESS: DEX_TRADE.WANNASWAP_ROUTER_V2_ADDRESS,
                FACTORY_CONTRACT_ADDRESS: DEX_TRADE.WANNASWAP_FACTORY_ADDRESS,
                AGAINST_TOKENS: wannaswap/* WANNASWAP_BASE_AGAINST_TOKENS */.N,
                ADDITIONAL_TOKENS: {},
                CUSTOM_TOKENS: wannaswap/* WANNASWAP_CUSTOM_BASES */.z
            };
        case web/* TradeProvider */.z4.TRISOLARIS:
            return {
                TYPE: tradeProvider,
                IS_UNISWAP_V2_LIKE: true,
                GRAPH_API: DEX_TRADE.TRISOLARIS_THEGRAPH,
                INIT_CODE_HASH: DEX_TRADE.TRISOLARIS_INIT_CODE_HASH,
                ROUTER_CONTRACT_ADDRESS: DEX_TRADE.TRISOLARIS_ROUTER_ADDRESS,
                SPENDER_CONTRACT_ADDRESS: DEX_TRADE.TRISOLARIS_ROUTER_ADDRESS,
                FACTORY_CONTRACT_ADDRESS: DEX_TRADE.TRISOLARIS_FACTORY_ADDRESS,
                AGAINST_TOKENS: trisolaris/* TRISOLARIS_BASE_AGAINST_TOKENS */.m,
                ADDITIONAL_TOKENS: {},
                CUSTOM_TOKENS: trisolaris/* TRISOLARIS_CUSTOM_BASES */.c
            };
        case web/* TradeProvider */.z4.MDEX:
            return {
                TYPE: tradeProvider,
                IS_UNISWAP_V2_LIKE: true,
                GRAPH_API: DEX_TRADE.MDEX_THEGRAPH,
                INIT_CODE_HASH: DEX_TRADE.MDEX_INIT_CODE_HASH,
                ROUTER_CONTRACT_ADDRESS: DEX_TRADE.MDEX_ROUTER_ADDRESS,
                SPENDER_CONTRACT_ADDRESS: DEX_TRADE.MDEX_ROUTER_ADDRESS,
                FACTORY_CONTRACT_ADDRESS: DEX_TRADE.MDEX_FACTORY_ADDRESS,
                AGAINST_TOKENS: mdex/* MDEX_BASE_AGAINST_TOKENS */.R,
                ADDITIONAL_TOKENS: {},
                CUSTOM_TOKENS: mdex/* MDEX_CUSTOM_BASES */.P
            };
        case web/* TradeProvider */.z4.ARTHSWAP:
            return {
                TYPE: tradeProvider,
                IS_UNISWAP_V2_LIKE: true,
                GRAPH_API: DEX_TRADE.ARTHSWAP_THEGRAPH,
                INIT_CODE_HASH: DEX_TRADE.ARTHSWAP_INIT_CODE_HASH,
                ROUTER_CONTRACT_ADDRESS: DEX_TRADE.ARTHSWAP_ROUTER_ADDRESS,
                SPENDER_CONTRACT_ADDRESS: DEX_TRADE.ARTHSWAP_ROUTER_ADDRESS,
                FACTORY_CONTRACT_ADDRESS: DEX_TRADE.ARTHSWAP_FACTORY_ADDRESS,
                AGAINST_TOKENS: arthswap/* ARTHSWAP_BASE_AGAINST_TOKENS */.T,
                ADDITIONAL_TOKENS: {},
                CUSTOM_TOKENS: arthswap/* ARTHSWAP_CUSTOM_BASES */.P
            };
        case web/* TradeProvider */.z4.VERSA:
            return {
                TYPE: tradeProvider,
                IS_UNISWAP_V2_LIKE: true,
                GRAPH_API: DEX_TRADE.VERSA_THEGRAPH,
                INIT_CODE_HASH: DEX_TRADE.VERSA_INIT_CODE_HASH,
                ROUTER_CONTRACT_ADDRESS: DEX_TRADE.VERSA_ROUTER_ADDRESS,
                SPENDER_CONTRACT_ADDRESS: DEX_TRADE.VERSA_ROUTER_ADDRESS,
                FACTORY_CONTRACT_ADDRESS: DEX_TRADE.VERSA_FACTORY_ADDRESS,
                AGAINST_TOKENS: versa/* VERSA_BASE_AGAINST_TOKENS */.c,
                ADDITIONAL_TOKENS: {},
                CUSTOM_TOKENS: versa/* VERSA_CUSTOM_BASES */.E
            };
        case web/* TradeProvider */.z4.ASTAREXCHANGE:
            return {
                TYPE: tradeProvider,
                IS_UNISWAP_V2_LIKE: true,
                GRAPH_API: DEX_TRADE.ASTAREXCHANGE_THEGRAPH,
                INIT_CODE_HASH: DEX_TRADE.ASTAREXCHANGE_INIT_CODE_HASH,
                ROUTER_CONTRACT_ADDRESS: DEX_TRADE.ASTAREXCHANGE_ROUTER_ADDRESS,
                SPENDER_CONTRACT_ADDRESS: DEX_TRADE.ASTAREXCHANGE_ROUTER_ADDRESS,
                FACTORY_CONTRACT_ADDRESS: DEX_TRADE.ASTAREXCHANGE_FACTORY_ADDRESS,
                AGAINST_TOKENS: astarexchange/* ASTAREXCHANGE_BASE_AGAINST_TOKENS */.h,
                ADDITIONAL_TOKENS: {},
                CUSTOM_TOKENS: astarexchange/* ASTAREXCHANGE_CUSTOM_BASES */.x
            };
        case web/* TradeProvider */.z4.YUMISWAP:
            return {
                TYPE: tradeProvider,
                IS_UNISWAP_V2_LIKE: true,
                GRAPH_API: DEX_TRADE.YUMISWAP_THEGRAPH,
                INIT_CODE_HASH: DEX_TRADE.YUMISWAP_INIT_CODE_HASH,
                ROUTER_CONTRACT_ADDRESS: DEX_TRADE.YUMISWAP_ROUTER_ADDRESS,
                SPENDER_CONTRACT_ADDRESS: DEX_TRADE.YUMISWAP_ROUTER_ADDRESS,
                FACTORY_CONTRACT_ADDRESS: DEX_TRADE.YUMISWAP_FACTORY_ADDRESS,
                AGAINST_TOKENS: yumiswap/* YUMISWAP_BASE_AGAINST_TOKENS */.n,
                ADDITIONAL_TOKENS: {},
                CUSTOM_TOKENS: yumiswap/* YUMISWAP_CUSTOM_BASES */.I
            };
        case web/* TradeProvider */.z4.ZRX:
            return {
                TYPE: tradeProvider
            };
        case web/* TradeProvider */.z4.DODO:
            return {
                TYPE: tradeProvider,
                SPENDER_CONTRACT_ADDRESS: DEX_TRADE.DODO_EXCHANGE_PROXY_ADDRESS
            };
        case web/* TradeProvider */.z4.BANCOR:
            return {
                TYPE: tradeProvider,
                SPENDER_CONTRACT_ADDRESS: DEX_TRADE.BANCOR_EXCHANGE_PROXY_ADDRESS
            };
        case web/* TradeProvider */.z4.OPENOCEAN:
            return {
                TYPE: tradeProvider,
                SPENDER_CONTRACT_ADDRESS: DEX_TRADE.OPENOCEAN_EXCHANGE_PROXY_ADDRESS
            };
        default:
            if (tradeProvider) (0,esm/* unreachable */.t1)(tradeProvider);
            return null;
    }
}

// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/memoize.js
var memoize = __webpack_require__(43434);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/formatter.ts
var formatter = __webpack_require__(41487);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/constants/tokens.ts
var tokens = __webpack_require__(46854);
;// CONCATENATED MODULE: ./packages/plugins/Trader/src/helpers/toUniswapChainId.ts
function toUniswapChainId(chainId) {
    return chainId;
}

;// CONCATENATED MODULE: ./packages/plugins/Trader/src/helpers/toUniswapToken.ts




function toUniswapToken(chainId, token) {
    return new sdk_core_esm/* Token */.WU(toUniswapChainId(chainId), (0,formatter/* formatEthereumAddress */.j8)(token.address), token.decimals, token.symbol, token.name);
}
const toUniswapTokenMemo = (0,memoize/* default */.Z)((chainId)=>toUniswapToken(chainId, tokens/* WNATIVE */.FX[chainId]));

;// CONCATENATED MODULE: ./packages/web3-shared/evm/src/helpers/getCreate2Address.ts

function getCreate2Address(fromAddress, salt, initCode) {
    // Concatenate and hash the formula components
    const formula = [
        '0xff',
        fromAddress.toLowerCase(),
        salt,
        initCode
    ].map((x)=>x.slice(2)).join('');
    const addressBytes = (0,lib.keccak256)(`0x${formula}`);
    // Get the last 20 bytes (40 characters) and prefix with 0x
    return (0,lib.toChecksumAddress)(addressBytes.slice(-40));
}

// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/pack.ts
var pack = __webpack_require__(69066);
;// CONCATENATED MODULE: ./packages/plugins/Trader/src/helpers/getPairAddress.ts


/** cache[token0Address][token1Address] = value  */ const map = new Map();
// This is a dynamically version of address generate algorithm borrowed from the Pair class of uniswap-skd
function getPairAddress(factoryAddress, initCodeHash, tokenA, tokenB) {
    if (!tokenA || !tokenB) return '';
    const tokens = tokenA.sortsBefore(tokenB) ? [
        tokenA,
        tokenB
    ] : [
        tokenB,
        tokenA
    ];
    // does safety checks
    let cache = map.get(initCodeHash);
    const token0Addr = tokens[0].address;
    const token1Addr = tokens[1].address;
    if (cache?.[token0Addr]?.[token1Addr] === undefined) {
        cache = {
            ...cache,
            [token0Addr]: {
                ...cache?.[token0Addr],
                [token1Addr]: getCreate2Address(factoryAddress, (0,lib.keccak256)((0,pack/* pack */.P)([
                    'address',
                    'address'
                ], [
                    token0Addr,
                    token1Addr
                ])), initCodeHash)
            }
        };
        map.set(initCodeHash, cache);
    }
    return cache[token0Addr][token1Addr];
}

// EXTERNAL MODULE: ./packages/plugins/Trader/src/helpers/swapCallParameters.ts
var swapCallParameters = __webpack_require__(40214);
;// CONCATENATED MODULE: ./packages/plugins/Trader/src/helpers/ExtendedEther.ts



class ExtendedEther extends sdk_core_esm/* Ether */.sf {
    get wrapped() {
        if (this.chainId in tokens/* WNATIVE */.FX) return toUniswapTokenMemo(this.chainId);
        throw new Error('Unsupported chain ID');
    }
    static _cachedEther = {};
    static onChain(chainId) {
        return this._cachedEther[chainId] ?? (this._cachedEther[chainId] = new ExtendedEther(chainId));
    }
}

;// CONCATENATED MODULE: ./packages/plugins/Trader/src/helpers/toUniswapCurrency.ts




function toUniswapCurrency(chainId, token) {
    try {
        if (!token || !chainId) return;
        const extendedEther = ExtendedEther.onChain(chainId);
        const weth = toUniswapToken(chainId, tokens/* WNATIVE */.FX[chainId]);
        if (weth && (0,isSameAddress/* isSameAddress */.W)(token.address, weth.address)) return weth;
        return token.schema === types/* SchemaType */.XQ.Native ? extendedEther : toUniswapToken(chainId, token);
    } catch  {
        return;
    }
}

;// CONCATENATED MODULE: ./packages/plugins/Trader/src/helpers/toUniswapCurrencyAmount.ts



function toUniswapCurrencyAmount(chainId, token, amount) {
    if (!token || !amount || !chainId) return;
    const currency = toUniswapCurrency(chainId, token);
    if (!currency) return;
    try {
        if ((0,number/* isGreaterThan */.T1)(amount, 0)) return sdk_core_esm/* CurrencyAmount */.ih.fromRawAmount(currency, amount);
    } catch  {
        return;
    }
    return;
}

;// CONCATENATED MODULE: ./packages/plugins/Trader/src/helpers/isTradeBetter.ts

function isTradeBetter(tradeA, tradeB, minimumDelta = uniswap/* ZERO_PERCENT */.fI) {
    if (tradeA && !tradeB) return false;
    if (tradeB && !tradeA) return true;
    if (!tradeA || !tradeB) return undefined;
    if (tradeA.tradeType !== tradeB.tradeType || !tradeA.inputAmount.currency.equals(tradeB.inputAmount.currency) || !tradeB.outputAmount.currency.equals(tradeB.outputAmount.currency)) {
        throw new Error('Comparing incomparable trades');
    }
    if (minimumDelta.equalTo(uniswap/* ZERO_PERCENT */.fI)) {
        return tradeA.executionPrice.lessThan(tradeB.executionPrice);
    } else {
        return tradeA.executionPrice.asFraction.multiply(minimumDelta.add(uniswap/* ONE_HUNDRED_PERCENT */.yC)).lessThan(tradeB.executionPrice);
    }
}

;// CONCATENATED MODULE: ./packages/plugins/Trader/src/helpers/computeRealizedLPFeePercent.ts



// computes realized lp fee as a percent
function computeRealizedLPFeePercent(trade) {
    if (trade instanceof v2_sdk_esm/* Trade */.ho) {
        // for each hop in our trade, take away the x*y=k price impact from 0.3% fees
        // e.g. for 3 tokens/2 hops: 1 - ((1 - .03) * (1-.03))
        const percent = uniswap/* ONE_HUNDRED_PERCENT */.yC.subtract(trade.route.pairs.reduce((currentFee)=>currentFee.multiply(uniswap/* INPUT_FRACTION_AFTER_FEE */.Zw), uniswap/* ONE_HUNDRED_PERCENT */.yC));
        return new sdk_core_esm/* Percent */.gG(percent.numerator, percent.denominator);
    } else {
        const percent = uniswap/* ONE_HUNDRED_PERCENT */.yC.subtract(trade.route.pools.reduce((currentFee, pool)=>currentFee.multiply(uniswap/* ONE_HUNDRED_PERCENT */.yC.subtract(new sdk_core_esm/* Fraction */.iA(pool.fee, 1000000))), uniswap/* ONE_HUNDRED_PERCENT */.yC));
        return new sdk_core_esm/* Percent */.gG(percent.numerator, percent.denominator);
    }
}

;// CONCATENATED MODULE: ./packages/plugins/Trader/src/helpers/toUniswapPercent.ts

function toUniswapPercent(numerator, denominator) {
    return new sdk_core_esm/* Percent */.gG(numerator, denominator);
}

;// CONCATENATED MODULE: ./packages/plugins/Trader/src/helpers/uniswapCurrencyAmountTo.ts

function uniswapCurrencyAmountTo(currencyAmount) {
    return (0,number/* pow10 */.wA)(currencyAmount.currency.decimals).multipliedBy(currencyAmount.toFixed());
}

;// CONCATENATED MODULE: ./packages/plugins/Trader/src/helpers/uniswapPriceTo.ts

function uniswapPriceTo(price) {
    return new bignumber/* BigNumber */.O(price.scalar.numerator.toString()).dividedBy(price.scalar.denominator.toString());
}

;// CONCATENATED MODULE: ./packages/plugins/Trader/src/helpers/uniswapPercentTo.ts

function uniswapPercentTo(percent) {
    return new bignumber/* BigNumber */.O(percent.toFixed(2)).dividedBy(100);
}

// EXTERNAL MODULE: ./packages/web3-shared/base/src/specs/index.ts
var specs = __webpack_require__(62649);
;// CONCATENATED MODULE: ./packages/plugins/Trader/src/helpers/uniswapChainIdTo.ts
function uniswapChainIdTo(chainId) {
    return chainId;
}

;// CONCATENATED MODULE: ./packages/plugins/Trader/src/helpers/uniswapTokenTo.ts



function uniswapTokenTo(token) {
    return {
        type: specs/* TokenType */.iv.Fungible,
        name: token.name,
        symbol: token.symbol,
        decimals: token.decimals,
        address: (0,formatter/* formatEthereumAddress */.j8)(token.address),
        chainId: uniswapChainIdTo(token.chainId),
        schema: [
            'eth',
            'matic',
            'bnb'
        ].includes(token.name?.toLowerCase() ?? '') ? types/* SchemaType */.XQ.Native : types/* SchemaType */.XQ.ERC20,
        id: token.symbol
    };
}

// EXTERNAL MODULE: ./packages/plugins/Trader/src/helpers/swapErrorToUserReadableMessage.ts
var swapErrorToUserReadableMessage = __webpack_require__(63713);
;// CONCATENATED MODULE: ./packages/plugins/Trader/src/types/uniswap.ts
var PairState;
(function(PairState) {
    PairState[PairState["NOT_EXISTS"] = 0] = "NOT_EXISTS";
    PairState[PairState["EXISTS"] = 1] = "EXISTS";
    PairState[PairState["INVALID"] = 2] = "INVALID";
})(PairState || (PairState = {}));
var PoolState;
(function(PoolState) {
    PoolState[PoolState["LOADING"] = 0] = "LOADING";
    PoolState[PoolState["NOT_EXISTS"] = 1] = "NOT_EXISTS";
    PoolState[PoolState["EXISTS"] = 2] = "EXISTS";
    PoolState[PoolState["INVALID"] = 3] = "INVALID";
})(PoolState || (PoolState = {}));

;// CONCATENATED MODULE: ./packages/plugins/Trader/src/providers/UniSwapV2.ts














class UniSwapV2LikeAPI {
    provider;
    constructor(provider){
        this.provider = provider;
    }
    getAllCommonPairs(chainId, currencyA, currencyB) {
        const chainIdValid = (0,isValidChainId/* isValidChainId */.J)(chainId);
        const context = getTradeContext(chainId, this.provider);
        const [tokenA, tokenB] = chainIdValid ? [
            currencyA?.wrapped,
            currencyB?.wrapped
        ] : [
            undefined,
            undefined
        ];
        if (!tokenA || !tokenB || !context?.FACTORY_CONTRACT_ADDRESS || !context.INIT_CODE_HASH) return src_constants/* EMPTY_LIST */.rP;
        const bases = !chainIdValid ? [] : [
            ...context?.AGAINST_TOKENS?.[chainId] ?? [],
            ...tokenA ? context?.ADDITIONAL_TOKENS?.[chainId]?.[tokenA.address] ?? [] : [],
            ...tokenB ? context?.ADDITIONAL_TOKENS?.[chainId]?.[tokenB.address] ?? [] : []
        ].map((x)=>toUniswapToken(chainId, x));
        const basePairs = (0,flatMap/* default */.Z)(bases, (base)=>bases.map((otherBase)=>[
                    base,
                    otherBase
                ]));
        return [
            // the direct pair
            [
                tokenA,
                tokenB
            ],
            // token A against all bases
            ...bases.map((base)=>[
                    tokenA,
                    base
                ]),
            // token B against all bases
            ...bases.map((base)=>[
                    tokenB,
                    base
                ]),
            // each base against all bases
            ...basePairs
        ].filter((tokens)=>!!(tokens[0] && tokens[1])).filter(([t0, t1])=>t0.address !== t1.address).filter(([tokenA, tokenB])=>{
            if (!chainIdValid) return true;
            const customBases = context?.CUSTOM_TOKENS?.[chainId];
            const customBasesA = customBases?.[tokenA.address]?.map((x)=>toUniswapToken(chainId, x));
            const customBasesB = customBases?.[tokenB.address]?.map((x)=>toUniswapToken(chainId, x));
            if (!customBasesA && !customBasesB) return true;
            if (customBasesA && !customBasesA.find((base)=>tokenB.equals(base))) return false;
            if (customBasesB && !customBasesB.find((base)=>tokenA.equals(base))) return false;
            return true;
        });
    }
    async getPairs(chainId, tokenPairs) {
        const context = getTradeContext(chainId, this.provider);
        if (!context) return src_constants/* EMPTY_LIST */.rP;
        const { FACTORY_CONTRACT_ADDRESS, INIT_CODE_HASH } = context;
        if (!FACTORY_CONTRACT_ADDRESS || !INIT_CODE_HASH) return src_constants/* EMPTY_LIST */.rP;
        const listOfPairAddress = tokenPairs.map(([tokenA, tokenB])=>tokenA && tokenB && !tokenA.equals(tokenB) ? getPairAddress(FACTORY_CONTRACT_ADDRESS, INIT_CODE_HASH, tokenA, tokenB) : undefined);
        const contracts = (0,compact/* default */.Z)((0,compact/* default */.Z)([
            ...new Set(listOfPairAddress)
        ]).map((address)=>entry/* ContractReadonly */.$u.getPairContract(address, {
                chainId
            })));
        const names = Array.from({
            length: contracts.length
        }).fill('getReserves');
        const calls = entry/* Multicall */.mG.createMultipleContractSingleData(contracts, names, []);
        const results = await entry/* Multicall */.mG.call(chainId, contracts, names, calls);
        if (!results) return src_constants/* EMPTY_LIST */.rP;
        // compose reserves from multicall results
        const listOfReserves = results.map((x, i)=>{
            if (x.error || !x.value) return undefined;
            return {
                id: contracts[i].options.address,
                reserve0: x.value._reserve0,
                reserve1: x.value._reserve1
            };
        }).filter((value)=>value !== undefined);
        return listOfPairAddress.map((address, i)=>{
            try {
                const tokenA = tokenPairs[i][0];
                const tokenB = tokenPairs[i][1];
                if (!tokenA || !tokenB || tokenA.equals(tokenB)) return [
                    PairState.INVALID,
                    null
                ];
                const { reserve0, reserve1 } = listOfReserves.find((x)=>x.id.toLowerCase() === address?.toLowerCase()) ?? {};
                if (!reserve0 || !reserve1) return [
                    PairState.NOT_EXISTS,
                    null
                ];
                const [token0, token1] = tokenA.sortsBefore(tokenB) ? [
                    tokenA,
                    tokenB
                ] : [
                    tokenB,
                    tokenA
                ];
                return [
                    PairState.EXISTS,
                    new v2_sdk_esm/* Pair */.sO(sdk_core_esm/* CurrencyAmount */.ih.fromRawAmount(token0, reserve0), sdk_core_esm/* CurrencyAmount */.ih.fromRawAmount(token1, reserve1))
                ];
            } catch  {
                return [];
            }
        });
    }
    async getSwapParameters(chainId, account, trade, allowedSlippage = trader/* SLIPPAGE_DEFAULT */.Nd) {
        const context = getTradeContext(chainId, this.provider);
        const timestamp = await entry/* Web3Readonly */.MJ.getBlockTimestamp({
            chainId
        });
        const timestamp_ = new bignumber/* BigNumber */.O(timestamp ?? '0');
        const deadline = timestamp_.plus(chainId === types/* ChainId */.a_.Mainnet ? trader/* DEFAULT_TRANSACTION_DEADLINE */.ag : trader/* L2_TRANSACTION_DEADLINE */.rV);
        const routerV2Contract = entry/* ContractReadonly */.$u.getRouterV2Contract(context?.ROUTER_CONTRACT_ADDRESS, {
            chainId
        });
        const swapRouterContract = entry/* ContractReadonly */.$u.getSwapRouterContract(context?.ROUTER_CONTRACT_ADDRESS, {
            chainId
        });
        if (!trade?.trade_) return [];
        const { trade_ } = trade;
        const allowedSlippage_ = new sdk_core_esm/* Percent */.gG(allowedSlippage, uniswap/* UNISWAP_BIPS_BASE */.dJ);
        if (trade_ instanceof v2_sdk_esm/* Trade */.ho) {
            if (!routerV2Contract) return [];
            const parameters = [
                (0,swapCallParameters/* swapCallParameters */.b)(trade_, {
                    feeOnTransfer: false,
                    allowedSlippage: allowedSlippage_,
                    recipient: account,
                    ttl: deadline.toNumber()
                }, this.provider)
            ];
            if (trade_.tradeType === sdk_core_esm/* TradeType */.YL.EXACT_INPUT) parameters.push((0,swapCallParameters/* swapCallParameters */.b)(trade_, {
                feeOnTransfer: true,
                allowedSlippage: allowedSlippage_,
                recipient: account,
                ttl: deadline.toNumber()
            }, this.provider));
            return parameters.map(({ methodName, args, value })=>{
                return {
                    address: routerV2Contract.options.address,
                    calldata: routerV2Contract.methods[methodName](// @ts-expect-error unsafe call
                    ...args).encodeABI(),
                    value
                };
            });
        } else {
            if (!swapRouterContract) return [];
            const { value, calldata } = v3_sdk_esm/* SwapRouter */.cH.swapCallParameters(trade_, {
                recipient: account,
                slippageTolerance: allowedSlippage_,
                deadline: deadline.toNumber()
            });
            return [
                {
                    address: swapRouterContract.options.address,
                    calldata,
                    value
                }
            ];
        }
    }
    getTrade(inputAmount, chainId, inputToken, outputToken) {
        const isTradable = !(0,number/* isZero */.Fr)(inputAmount);
        const isNotAvailable = !isTradable || !inputToken || !outputToken;
        const inputCurrency = toUniswapCurrency(chainId, inputToken);
        const outputCurrency = toUniswapCurrency(chainId, outputToken);
        const tradeAmount = toUniswapCurrencyAmount(chainId, inputToken, inputAmount);
        return {
            isNotAvailable,
            tradeAmount,
            inputCurrency,
            outputCurrency
        };
    }
    async getBestTradeExactIn(chainId, currencyAmountIn, currencyOut) {
        const currencyA = currencyAmountIn?.currency;
        const currencyB = currencyOut;
        const allCurrencyCombinations = this.getAllCommonPairs(chainId, currencyA, currencyB);
        const allPairs = await this.getPairs(chainId, allCurrencyCombinations);
        const filtered = new Map();
        for (const [state, pair] of allPairs){
            // filter out invalid pairs
            if (state !== PairState.EXISTS) continue;
            if (!pair) continue;
            // filter out duplicated pairs
            const { address } = pair.liquidityToken;
            if (filtered.has(address)) continue;
            filtered.set(pair.liquidityToken.address, pair);
        }
        const allowedPairs = [
            ...filtered.values()
        ];
        if (currencyAmountIn && currencyOut && allowedPairs.length > 0) {
            let bestTradeSoFar = null;
            for(let i = 1; i <= uniswap/* MAX_HOP */.s9; i += 1){
                const currentTrade = v2_sdk_esm/* Trade */.ho.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, {
                    maxHops: i,
                    maxNumResults: 1
                })[0] ?? null;
                // if current trade is best yet, save it
                if (isTradeBetter(bestTradeSoFar, currentTrade, uniswap/* BETTER_TRADE_LESS_HOPS_THRESHOLD */.Ru)) {
                    bestTradeSoFar = currentTrade;
                }
            }
            return bestTradeSoFar;
        }
        return null;
    }
    async getTradeInfo(chainId, account, inputAmount_, slippage, inputToken, outputToken) {
        try {
            const { isNotAvailable, tradeAmount, outputCurrency } = this.getTrade(inputAmount_, chainId, inputToken, outputToken);
            if (isNotAvailable || !tradeAmount || !outputCurrency) return null;
            const trade = await this.getBestTradeExactIn(chainId, tradeAmount, outputCurrency);
            if (!trade) return null;
            const realizedLPFeePercent = computeRealizedLPFeePercent(trade);
            const realizedLPFee = trade.inputAmount.multiply(realizedLPFeePercent);
            const priceImpact = trade.priceImpact.subtract(realizedLPFeePercent);
            const percent_ = toUniswapPercent(slippage, 10000);
            const computed = {
                strategy: Trader/* TraderAPI */.N.TradeStrategy.ExactIn,
                inputToken,
                outputToken,
                inputAmount: uniswapCurrencyAmountTo(trade.inputAmount),
                outputAmount: uniswapCurrencyAmountTo(trade.outputAmount),
                executionPrice: uniswapPriceTo(trade.executionPrice),
                priceImpact: uniswapPercentTo(priceImpact ?? trade.priceImpact),
                path: trade instanceof v2_sdk_esm/* Trade */.ho ? trade.route.path.map((x)=>[
                        uniswapTokenTo(x)
                    ]) : [],
                maximumSold: uniswapCurrencyAmountTo(trade.maximumAmountIn(percent_)),
                minimumReceived: uniswapCurrencyAmountTo(trade.minimumAmountOut(percent_)),
                fee: realizedLPFee ? uniswapCurrencyAmountTo(realizedLPFee) : number/* ZERO */.xE,
                trade_: trade
            };
            try {
                const gas = await this.getTradeGasLimit(account, chainId, computed);
                return {
                    gas,
                    value: computed,
                    provider: this.provider
                };
            } catch  {
                return {
                    value: computed,
                    provider: this.provider
                };
            }
        } catch (error) {
            if (error instanceof Error) {
                return {
                    value: null,
                    error,
                    provider: this.provider
                };
            }
            return null;
        }
    }
    async getNativeWrapperTradeInfo(chainId, account, inputAmount, inputToken, outputToken) {
        const { WNATIVE_ADDRESS } = (0,constants/* getTokenConstants */.aV)(chainId);
        const tradeAmount = new bignumber/* BigNumber */.O(inputAmount || '0');
        if (tradeAmount.isZero() || !inputToken || !outputToken || !WNATIVE_ADDRESS) return null;
        const wrapperContract = entry/* ContractReadonly */.$u.getWETHContract(WNATIVE_ADDRESS, {
            chainId
        });
        const computed = {
            strategy: Trader/* TraderAPI */.N.TradeStrategy.ExactIn,
            inputToken,
            outputToken,
            inputAmount: tradeAmount,
            outputAmount: tradeAmount,
            executionPrice: number/* ZERO */.xE,
            maximumSold: number/* ZERO */.xE,
            minimumReceived: tradeAmount,
            priceImpact: number/* ZERO */.xE,
            fee: number/* ZERO */.xE,
            trade_: {
                isWrap: (0,token/* isNativeTokenSchemaType */.SC)(inputToken.schema),
                isNativeTokenWrapper: true
            }
        };
        try {
            const tx = await new ContractTransaction/* ContractTransaction */.D(wrapperContract).fillAll(wrapperContract?.methods.deposit(), {
                from: account,
                value: tradeAmount.toFixed()
            });
            const gas = tx.gas ?? '0';
            return {
                gas,
                provider: this.provider,
                value: computed
            };
        } catch  {
            return {
                value: computed,
                provider: this.provider
            };
        }
    }
    async getTradeGasLimit(account, chainId, trade) {
        const tradeParameters = await this.getSwapParameters(chainId, account, trade);
        // step 1: estimate each trade parameter
        const estimatedCalls = await Promise.all(tradeParameters.map(async (x)=>{
            const { address, calldata, value } = x;
            const config = {
                from: account,
                to: address,
                data: calldata,
                ...!value || /^0x0*$/.test(value) ? {} : {
                    value: (0,lib.toHex)(value)
                }
            };
            try {
                const gas = await entry/* Web3Readonly */.MJ.estimateTransaction(config, 0, {
                    chainId
                });
                return {
                    call: x,
                    gasEstimate: gas ?? '0'
                };
            } catch (error) {
                return entry/* Web3Readonly */.MJ.callTransaction(config, {
                    chainId
                }).then(()=>{
                    return {
                        call: x,
                        error: new Error('Gas estimate failed')
                    };
                }).catch((error)=>{
                    return {
                        call: x,
                        error: new Error((0,swapErrorToUserReadableMessage/* swapErrorToUserReadableMessage */.J)(error))
                    };
                });
            }
        }));
        // a successful estimation is a bignumber gas estimate and the next call is also a bignumber gas estimate
        let bestCallOption = estimatedCalls.find((el, ix, list)=>'gasEstimate' in el && (ix === list.length - 1 || 'gasEstimate' in list[ix + 1]));
        // check if any calls errored with a recognizable error
        if (!bestCallOption) {
            const errorCalls = estimatedCalls.filter((call)=>'error' in call);
            if (errorCalls.length > 0) {
                return;
            }
            const firstNoErrorCall = estimatedCalls.find((call)=>!('error' in call));
            if (!firstNoErrorCall) {
                return;
            }
            bestCallOption = firstNoErrorCall;
        }
        return 'gasEstimate' in bestCallOption ? (0,number/* toFixed */.FH)(bestCallOption.gasEstimate) : '0';
    }
}

;// CONCATENATED MODULE: ./packages/plugins/Trader/src/trader/useUniswapV2Like.ts






function useUniswapV2Like(traderProvider, inputAmount_, scale, inputToken, outputToken, temporarySlippage, isNativeTokenWrapper) {
    const { chainId, account } = (0,useContext/* useChainContext */.ql)();
    const network = (0,useNetwork/* useNetwork */.L)(undefined, chainId);
    const slippageSetting = useSlippageTolerance();
    const slippage = (0,react.useMemo)(()=>{
        return temporarySlippage ? temporarySlippage : slippageSetting;
    }, [
        temporarySlippage,
        slippageSetting
    ]);
    const provider = (0,react.useMemo)(()=>{
        if (!network) return;
        const providers = getEVMAvailableTraderProviders(network.type);
        if (!providers.includes(traderProvider)) return;
        return new UniSwapV2LikeAPI(traderProvider);
    }, [
        traderProvider,
        network
    ]);
    return (0,useBeat/* useCustomBlockBeatRetry */.Xg)(PluginID/* NetworkPluginID */.F.PLUGIN_EVM, async ()=>{
        if (!provider) return;
        return isNativeTokenWrapper ? provider.getNativeWrapperTradeInfo(chainId, account, inputAmount_, inputToken, outputToken) : provider.getTradeInfo(chainId, account, inputAmount_, slippage, inputToken, outputToken);
    }, [
        inputAmount_,
        isNativeTokenWrapper,
        chainId,
        account,
        provider,
        inputToken,
        outputToken
    ], scale);
}

;// CONCATENATED MODULE: ./packages/plugins/Trader/src/trending/useAvailableTraderProviders.ts




function useAvailableTraderProviders(targetChainId) {
    const { chainId } = (0,useContext/* useChainContext */.ql)({
        chainId: targetChainId
    });
    const { pluginID } = (0,useContext/* useNetworkContext */.gK)();
    const Others = (0,useWeb3Others/* useWeb3Others */.v)();
    const networkType = Others.chainResolver.networkType(chainId);
    return (0,react.useMemo)(()=>{
        switch(pluginID){
            case PluginID/* NetworkPluginID */.F.PLUGIN_EVM:
                return getEVMAvailableTraderProviders(networkType);
            case PluginID/* NetworkPluginID */.F.PLUGIN_FLOW:
            case PluginID/* NetworkPluginID */.F.PLUGIN_SOLANA:
            default:
                return src_constants/* EMPTY_LIST */.rP;
        }
    }, [
        networkType,
        pluginID
    ]);
}

;// CONCATENATED MODULE: ./packages/plugins/Trader/src/helpers/computeAllRoutes.ts

function computeAllRoutes(currencyIn, currencyOut, pools, chainId, currentPath = [], allPaths = [], startCurrencyIn = currencyIn, maxHops = 2) {
    const tokenIn = currencyIn?.wrapped;
    const tokenOut = currencyOut?.wrapped;
    if (!tokenIn || !tokenOut) throw new Error('Missing tokenIn/tokenOut');
    try {
        for (const pool of pools){
            if (currentPath.includes(pool) || !pool.involvesToken(tokenIn)) continue;
            const outputToken = pool.token0.equals(tokenIn) ? pool.token1 : pool.token0;
            if (outputToken.equals(tokenOut)) {
                allPaths.push(new v3_sdk_esm/* Route */.AW([
                    ...currentPath,
                    pool
                ], startCurrencyIn, currencyOut));
            } else if (maxHops > 1) {
                computeAllRoutes(outputToken, currencyOut, pools, chainId, [
                    ...currentPath,
                    pool
                ], allPaths, startCurrencyIn, maxHops - 1);
            }
        }
    } catch  {
        return [];
    }
    return allPaths;
}

;// CONCATENATED MODULE: ./packages/plugins/Trader/src/providers/UniSwapV3.ts












class UniSwapV3LikeAPI extends UniSwapV2LikeAPI {
    constructor(){
        super(web/* TradeProvider */.z4.UNISWAP_V3);
    }
    getPoolAddresses(transformed, context) {
        try {
            return transformed.map((value)=>{
                if (!context?.IS_UNISWAP_V3_LIKE) return '';
                if (!context?.FACTORY_CONTRACT_ADDRESS || !value) return '';
                return (0,v3_sdk_esm/* computePoolAddress */.d_)({
                    factoryAddress: context.FACTORY_CONTRACT_ADDRESS,
                    tokenA: value[0],
                    tokenB: value[1],
                    fee: value[2]
                });
            });
        } catch  {
            return [];
        }
    }
    getQuoteExactInInputs(routes, amountIn) {
        try {
            return routes.map((route)=>[
                    (0,v3_sdk_esm/* encodeRouteToPath */.xK)(route, false),
                    amountIn ? `0x${amountIn.quotient.toString(16)}` : undefined
                ]);
        } catch  {
            return [];
        }
    }
    async getPools(chainId, poolKeys) {
        const context = getTradeContext(chainId, this.provider);
        if (!context) return src_constants/* EMPTY_LIST */.rP;
        const transformed = poolKeys.map(([currencyA, currencyB, feeAmount])=>{
            if (!chainId || !currencyA || !currencyB || !feeAmount) return null;
            const tokenA = currencyA?.wrapped;
            const tokenB = currencyB?.wrapped;
            if (!tokenA || !tokenB || tokenA.equals(tokenB)) return null;
            const [token0, token1] = tokenA.sortsBefore(tokenB) ? [
                tokenA,
                tokenB
            ] : [
                tokenB,
                tokenA
            ];
            return [
                token0,
                token1,
                feeAmount
            ];
        });
        const poolAddresses = this.getPoolAddresses(transformed, context);
        const poolContracts = (0,compact/* default */.Z)(poolAddresses.map((x)=>entry/* ContractReadonly */.$u.getPoolStateV3(x, {
                chainId
            })));
        const slot0sCalls = entry/* Multicall */.mG.createMultipleContractSingleData(poolContracts, Array.from({
            length: poolContracts.length
        }).fill('slot0'), []);
        const liquiditiesCalls = entry/* Multicall */.mG.createMultipleContractSingleData(poolContracts, Array.from({
            length: poolContracts.length
        }).fill('liquidity'), []);
        const slot0s = await entry/* Multicall */.mG.call(chainId, poolContracts, Array.from({
            length: poolContracts.length
        }).fill('slot0'), slot0sCalls);
        const liquidities = await entry/* Multicall */.mG.call(chainId, poolContracts, Array.from({
            length: poolContracts.length
        }).fill('liquidity'), liquiditiesCalls);
        return poolKeys.map((_key, index)=>{
            const [token0, token1, fee] = transformed[index] ?? [];
            if (!token0 || !token1 || !fee) return [
                PoolState.INVALID,
                null
            ];
            const { value: slot0, error: slot0Error } = slot0s[index] ?? {};
            const { value: liquidity, error: liquidityError } = liquidities[index] ?? {};
            if (slot0Error || liquidityError) return [
                PoolState.INVALID,
                null
            ];
            if (!slot0 || !liquidity) return [
                PoolState.NOT_EXISTS,
                null
            ];
            if ((0,number/* isZero */.Fr)(slot0.sqrtPriceX96 ?? 0)) return [
                PoolState.NOT_EXISTS,
                null
            ];
            try {
                return [
                    PoolState.EXISTS,
                    new v3_sdk_esm/* Pool */.Kg(token0, token1, fee, slot0.sqrtPriceX96, liquidity[0], Number.parseInt(slot0.tick, 10))
                ];
            } catch (error) {
                console.error('Error when constructing the pool', error);
                return [
                    PoolState.NOT_EXISTS,
                    null
                ];
            }
        });
    }
    async getBestTradeExactIn(chainId, currencyAmountIn, currencyOut) {
        const { UNISWAP_V3_QUOTER_ADDRESS } = (0,constants/* getTraderConstants */.Gr)(chainId);
        if (!UNISWAP_V3_QUOTER_ADDRESS) return null;
        const quoterContract = entry/* ContractReadonly */.$u.getQuoterContract(UNISWAP_V3_QUOTER_ADDRESS, {
            chainId
        });
        const allCurrencyCombinations = this.getAllCommonPairs(chainId, currencyAmountIn?.currency, currencyOut);
        const allCurrencyCombinationsWithAllFees = allCurrencyCombinations.flatMap(([tokenA, tokenB])=>[
                [
                    tokenA,
                    tokenB,
                    v3_sdk_esm/* FeeAmount */.lk.LOW
                ],
                [
                    tokenA,
                    tokenB,
                    v3_sdk_esm/* FeeAmount */.lk.MEDIUM
                ],
                [
                    tokenA,
                    tokenB,
                    v3_sdk_esm/* FeeAmount */.lk.HIGH
                ]
            ]);
        const pools = await this.getPools(chainId, allCurrencyCombinationsWithAllFees);
        const swapPools = pools.filter((tuple)=>{
            return tuple[0] === PoolState.EXISTS && tuple[1] !== null;
        }).map(([, pool])=>pool);
        const routers = computeAllRoutes(currencyAmountIn.currency, currencyOut, swapPools, chainId, [], [], currencyAmountIn?.currency, 2);
        const quoteExactInInputs = this.getQuoteExactInInputs(routers, currencyAmountIn);
        if (!quoterContract) return null;
        const quotesCalls = entry/* Multicall */.mG.createSingleContractMultipleData(quoterContract, Array.from({
            length: quoteExactInInputs.length
        }).fill('quoteExactInput'), quoteExactInInputs);
        const quotesResults = await entry/* Multicall */.mG.call(chainId, Array.from({
            length: quoteExactInInputs.length
        }).map(()=>quoterContract), Array.from({
            length: quoteExactInInputs.length
        }).fill('quoteExactInput'), quotesCalls);
        const asyncBestTrade = (()=>{
            if (!currencyAmountIn || !currencyOut) {
                return {
                    value: undefined,
                    loading: false,
                    error: new Error('Invalid trade info.')
                };
            }
            if (routers.length && !quotesResults.length) {
                return {
                    value: undefined,
                    loading: true,
                    error: undefined
                };
            }
            const { bestRoute, amountOut } = quotesResults.filter((x)=>x.succeed).reduce((currentBest, { value }, i)=>{
                if (!value) return currentBest;
                if (currentBest.amountOut === null) {
                    return {
                        bestRoute: routers[i],
                        amountOut: value
                    };
                } else if (new bignumber/* BigNumber */.O(currentBest.amountOut).lt(value)) {
                    return {
                        bestRoute: routers[i],
                        amountOut: value
                    };
                }
                return currentBest;
            }, {
                bestRoute: null,
                amountOut: null
            });
            if (!bestRoute || !amountOut) {
                return {
                    value: undefined,
                    loading: false,
                    error: new Error('No route found.')
                };
            }
            try {
                return {
                    value: v3_sdk_esm/* Trade */.ho.createUncheckedTrade({
                        route: bestRoute,
                        tradeType: sdk_core_esm/* TradeType */.YL.EXACT_INPUT,
                        inputAmount: currencyAmountIn,
                        outputAmount: sdk_core_esm/* CurrencyAmount */.ih.fromRawAmount(currencyOut, amountOut)
                    }),
                    loading: false,
                    error: undefined
                };
            } catch  {
                return {
                    value: undefined,
                    loading: false,
                    error: new Error('Uniswap SDK Error')
                };
            }
        })();
        if (!asyncBestTrade.value) return null;
        return asyncBestTrade.value;
    }
}

;// CONCATENATED MODULE: ./packages/plugins/Trader/src/trader/useUniSwapV3Like.ts







function useUniswapV3Like(inputAmount_, scale, inputToken, outputToken, temporarySlippage, isNativeTokenWrapper) {
    const { chainId, account } = (0,useContext/* useChainContext */.ql)();
    const network = (0,useNetwork/* useNetwork */.L)(undefined, chainId);
    const slippageSetting = useSlippageTolerance();
    const slippage = (0,react.useMemo)(()=>{
        return temporarySlippage ? temporarySlippage : slippageSetting;
    }, [
        temporarySlippage,
        slippageSetting
    ]);
    const provider = (0,react.useMemo)(()=>{
        if (!network) return;
        const providers = getEVMAvailableTraderProviders(network.type);
        if (!providers.includes(web/* TradeProvider */.z4.UNISWAP_V3)) return;
        return new UniSwapV3LikeAPI();
    }, [
        network
    ]);
    return (0,useBeat/* useCustomBlockBeatRetry */.Xg)(PluginID/* NetworkPluginID */.F.PLUGIN_EVM, async ()=>{
        if (!provider) return;
        return isNativeTokenWrapper ? provider.getNativeWrapperTradeInfo(chainId, account, inputAmount_, inputToken, outputToken) : provider.getTradeInfo(chainId, account, inputAmount_, slippage, inputToken, outputToken);
    }, [
        inputAmount_,
        isNativeTokenWrapper,
        chainId,
        account,
        provider,
        inputToken,
        outputToken
    ], scale);
}

// EXTERNAL MODULE: ./node_modules/.pnpm/urlcat@3.1.0_patch_hash=5r5xyq4zgcnqugwsrx4lxq2i4e/node_modules/urlcat/dist/index.mjs
var dist = __webpack_require__(78757);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/head.js
var head = __webpack_require__(81755);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/pick.js + 1 modules
var pick = __webpack_require__(27043);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/address.ts
var address = __webpack_require__(65327);
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/fetchJSON.ts
var fetchJSON = __webpack_require__(11834);
;// CONCATENATED MODULE: ./packages/plugins/Trader/src/constants/0x.ts
const ZRX_NATIVE_TOKEN_ADDRESS = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee';
const ZRX_AFFILIATE_ADDRESS = '0x934B510D4C9103E6a87AEf13b816fb080286D649';

;// CONCATENATED MODULE: ./packages/plugins/Trader/src/providers/ZeroX.ts











const ZRX_BASE_URL = 'https://zrx-proxy.r2d2.to/';
function getNativeTokenLabel(networkType) {
    switch(networkType){
        case types/* NetworkType */.td.Ethereum:
            return 'ETH';
        case types/* NetworkType */.td.Binance:
        case types/* NetworkType */.td.Base:
        case types/* NetworkType */.td.Polygon:
        case types/* NetworkType */.td.Arbitrum:
        case types/* NetworkType */.td.xDai:
        case types/* NetworkType */.td.Celo:
        case types/* NetworkType */.td.Fantom:
        case types/* NetworkType */.td.Aurora:
        case types/* NetworkType */.td.Boba:
        case types/* NetworkType */.td.Fuse:
        case types/* NetworkType */.td.Metis:
        case types/* NetworkType */.td.Avalanche:
        case types/* NetworkType */.td.Optimism:
        case types/* NetworkType */.td.Conflux:
        case types/* NetworkType */.td.Astar:
        case types/* NetworkType */.td.Scroll:
        case types/* NetworkType */.td.Moonbeam:
        case types/* NetworkType */.td.CustomNetwork:
            return ZRX_NATIVE_TOKEN_ADDRESS;
        default:
            (0,esm/* safeUnreachable */.P)(networkType);
            return '';
    }
}
class ZeroX_API {
    provider = web/* TradeProvider */.z4.ZRX;
    async swapQuote(request, chainId) {
        const params = {};
        Object.entries(request).map(([key, value])=>{
            params[key] = value;
        });
        if (request.slippagePercentage) params.slippagePercentage = new bignumber/* BigNumber */.O(request.slippagePercentage).dividedBy(trader/* BIPS_BASE */.PM).toFixed();
        if (request.buyTokenPercentageFee) params.buyTokenPercentageFee = new bignumber/* BigNumber */.O(request.buyTokenPercentageFee).dividedBy(100).toFixed();
        params.affiliateAddress = ZRX_AFFILIATE_ADDRESS;
        const response_ = await (0,fetchJSON/* fetchJSON */.ZV)((0,dist/* default */.ZP)(ZRX_BASE_URL, 'swap/v1/quote', {
            ...params,
            chain_id: chainId
        }));
        const validationErrorResponse = response_;
        if (validationErrorResponse.code) throw new Error((0,head/* default */.Z)(validationErrorResponse.validationErrors)?.reason ?? 'Unknown Error');
        const serverErrorResponse = response_;
        if (serverErrorResponse.reason) throw new Error((0,head/* default */.Z)(validationErrorResponse.validationErrors)?.reason || 'Unknown Error');
        const successResponse = response_;
        return successResponse;
    }
    async getTrade(chainId, account, inputAmount, slippage, inputToken, outputToken) {
        if ((0,number/* isZero */.Fr)(inputAmount) || !inputToken || !outputToken) return null;
        const networkType = entry/* ChainResolver */.iv.networkType(chainId);
        if (!networkType) return;
        const sellToken = (0,address/* isNativeTokenAddress */.qw)(inputToken.address) ? getNativeTokenLabel(networkType) : inputToken.address;
        const buyToken = (0,address/* isNativeTokenAddress */.qw)(outputToken.address) ? getNativeTokenLabel(networkType) : outputToken.address;
        return this.swapQuote({
            sellToken,
            buyToken,
            takerAddress: account,
            sellAmount: inputAmount,
            buyAmount: void 0,
            skipValidation: true,
            slippagePercentage: slippage,
            affiliateAddress: ZRX_AFFILIATE_ADDRESS
        }, chainId);
    }
    async getTradeInfo(chainId, account, inputAmount_, slippage, inputToken, outputToken) {
        try {
            const trade = await this.getTrade(chainId, account, inputAmount_, slippage, inputToken, outputToken);
            if (!trade) return null;
            const inputAmount = new bignumber/* BigNumber */.O(trade.sellAmount);
            const outputAmount = new bignumber/* BigNumber */.O(trade.buyAmount);
            const computed = {
                strategy: Trader/* TraderAPI */.N.TradeStrategy.ExactIn,
                inputToken,
                outputToken,
                inputAmount,
                outputAmount,
                executionPrice: new bignumber/* BigNumber */.O(trade.price),
                fee: new bignumber/* BigNumber */.O(trade.minimumProtocolFee),
                maximumSold: new bignumber/* BigNumber */.O(trade.sellAmount),
                minimumReceived: outputAmount,
                // minimumProtocolFee
                priceImpact: number/* ZERO */.xE,
                trade_: {
                    ...trade,
                    buyAmount: outputAmount.toFixed()
                }
            };
            try {
                const gas = await this.getTradeGasLimit(account, chainId, computed);
                return {
                    gas,
                    value: computed,
                    provider: this.provider
                };
            } catch  {
                return {
                    value: computed,
                    provider: this.provider
                };
            }
        } catch (error) {
            if (error instanceof Error) {
                return {
                    value: null,
                    error,
                    provider: this.provider
                };
            }
            return null;
        }
    }
    async getNativeWrapperTradeInfo(chainId, account, inputAmount, inputToken, outputToken) {
        const { WNATIVE_ADDRESS } = (0,constants/* getTokenConstants */.aV)(chainId);
        const tradeAmount = new bignumber/* BigNumber */.O(inputAmount || '0');
        if (tradeAmount.isZero() || !inputToken || !outputToken || !WNATIVE_ADDRESS) return null;
        const wrapperContract = entry/* ContractReadonly */.$u.getWETHContract(WNATIVE_ADDRESS, {
            chainId
        });
        const computed = {
            strategy: Trader/* TraderAPI */.N.TradeStrategy.ExactIn,
            inputToken,
            outputToken,
            inputAmount: tradeAmount,
            outputAmount: tradeAmount,
            executionPrice: number/* ZERO */.xE,
            maximumSold: number/* ZERO */.xE,
            minimumReceived: tradeAmount,
            priceImpact: number/* ZERO */.xE,
            fee: number/* ZERO */.xE,
            trade_: {
                isWrap: (0,token/* isNativeTokenSchemaType */.SC)(inputToken.schema),
                isNativeTokenWrapper: true
            }
        };
        try {
            const tx = await new ContractTransaction/* ContractTransaction */.D(wrapperContract).fillAll(wrapperContract?.methods.deposit(), {
                from: account,
                value: tradeAmount.toFixed()
            });
            const gas = tx.gas ?? '0';
            return {
                gas,
                provider: this.provider,
                value: computed
            };
        } catch  {
            return {
                value: computed,
                provider: this.provider
            };
        }
    }
    async getTradeGasLimit(account, chainId, trade) {
        if (!account || !trade.trade_) return '0';
        const config = {
            from: account,
            ...(0,pick/* default */.Z)(trade.trade_, 'to', 'data', 'value')
        };
        return entry/* Web3Readonly */.MJ.estimateTransaction(config, 0, {
            chainId
        });
    }
}
const ZeroX = new ZeroX_API();

;// CONCATENATED MODULE: ./packages/plugins/Trader/src/trader/useZeroX.ts







function useZeroX(inputAmount_, scale, inputToken, outputToken, temporarySlippage, isNativeTokenWrapper) {
    const { chainId, account } = (0,useContext/* useChainContext */.ql)();
    const network = (0,useNetwork/* useNetwork */.L)(undefined, chainId);
    const slippageSetting = useSlippageTolerance();
    const slippage = (0,react.useMemo)(()=>{
        return temporarySlippage ? temporarySlippage : slippageSetting;
    }, [
        temporarySlippage,
        slippageSetting
    ]);
    const provider = (0,react.useMemo)(()=>{
        if (!network) return;
        const providers = getEVMAvailableTraderProviders(network.type);
        if (!providers.includes(web/* TradeProvider */.z4.ZRX)) return;
        return ZeroX;
    }, [
        network
    ]);
    return (0,useBeat/* useCustomBlockBeatRetry */.Xg)(PluginID/* NetworkPluginID */.F.PLUGIN_EVM, async ()=>{
        if (!provider) return;
        return isNativeTokenWrapper ? provider.getNativeWrapperTradeInfo(chainId, account, inputAmount_, inputToken, outputToken) : provider.getTradeInfo(chainId, account, inputAmount_, slippage, inputToken, outputToken);
    }, [
        inputAmount_,
        isNativeTokenWrapper,
        chainId,
        account,
        provider,
        inputToken,
        outputToken
    ], scale);
}

// EXTERNAL MODULE: ./packages/web3-shared/evm/src/libs/ProviderURL.ts
var ProviderURL = __webpack_require__(23865);
;// CONCATENATED MODULE: ./packages/plugins/Trader/src/constants/openocean.ts

const OPENOCEAN_BASE_URL = 'https://ethapi.openocean.finance/v2/';
// https://docs.openocean.finance/api/openocean-dex-api-2.0
const OPENOCEAN_SUPPORTED_CHAINS = [
    types/* ChainId */.a_.Mainnet,
    types/* ChainId */.a_.BSC,
    types/* ChainId */.a_.xDai,
    types/* ChainId */.a_.Matic,
    types/* ChainId */.a_.Fantom,
    types/* ChainId */.a_.Arbitrum,
    types/* ChainId */.a_.Avalanche
];

;// CONCATENATED MODULE: ./packages/plugins/Trader/src/providers/OpenOcean.ts










class OpenOceanAPI {
    provider = web/* TradeProvider */.z4.OPENOCEAN;
    async swapOO(request) {
        const payload = await (0,fetchJSON/* fetchJSON */.ZV)((0,dist/* default */.ZP)(OPENOCEAN_BASE_URL, `/${request.chainId}/swap`, {
            inTokenSymbol: request.toToken?.symbol,
            inTokenAddress: request.fromToken?.address,
            outTokenSymbol: request.toToken?.symbol,
            outTokenAddress: request.toToken?.address,
            amount: request.fromAmount,
            gasPrice: 5000000000,
            slippage: request.slippage,
            disabledDexIds: '',
            account: request.userAddr,
            referrer: (0,constants/* getOpenOceanConstants */.hc)(request.chainId).REFERRER_ADDRESS?.toLowerCase(),
            disableRfq: '1'
        }));
        const { data, outAmount, minOutAmount, to, value, estimatedGas } = payload;
        const _resAmount = (0,number/* leftShift */.w5)(outAmount, request.toToken.decimals).toNumber();
        const _fromAmount = (0,number/* leftShift */.w5)(request.fromAmount, request.fromToken.decimals).toNumber();
        return {
            data,
            estimatedGas,
            targetApproveAddr: request.fromToken.address,
            targetDecimals: request.fromToken.decimals,
            resAmount: _resAmount,
            fromAmount: _fromAmount,
            resPricePerFromToken: +(_fromAmount / _resAmount).toFixed(8),
            resPricePerToToken: +(_resAmount / _fromAmount).toFixed(8),
            to,
            value,
            slippage: request.slippage,
            fromTokenSymbol: request.fromToken.symbol,
            toTokenSymbol: request.toToken.symbol,
            minOutAmount
        };
    }
    async getTrade(chainId, account, inputAmount, slippage, inputToken, outputToken) {
        const { OPENOCEAN_ETH_ADDRESS } = (0,constants/* getTraderConstants */.Gr)(chainId);
        if ((0,number/* isZero */.Fr)(inputAmount) || !inputToken || !outputToken || !OPENOCEAN_SUPPORTED_CHAINS.includes(chainId)) return null;
        const sellToken = (0,address/* isNativeTokenAddress */.qw)(inputToken.address) ? {
            ...inputToken,
            address: OPENOCEAN_ETH_ADDRESS ?? ''
        } : inputToken;
        const buyToken = (0,address/* isNativeTokenAddress */.qw)(outputToken.address) ? {
            ...outputToken,
            address: OPENOCEAN_ETH_ADDRESS ?? ''
        } : outputToken;
        return this.swapOO({
            isNativeSellToken: (0,address/* isNativeTokenAddress */.qw)(inputToken.address),
            fromToken: sellToken,
            toToken: buyToken,
            fromAmount: inputAmount,
            slippage,
            userAddr: account,
            rpc: ProviderURL/* ProviderURL */.C.from(chainId),
            chainId
        });
    }
    async getTradeInfo(chainId, account, inputAmount_, slippage, inputToken, outputToken) {
        try {
            const trade = await this.getTrade(chainId, account, inputAmount_, slippage, inputToken, outputToken);
            if (!trade || !inputToken || !outputToken) return null;
            const inputAmount = new bignumber/* BigNumber */.O(trade.fromAmount).multipliedBy((0,number/* pow10 */.wA)(inputToken.decimals)).integerValue();
            const executionPrice = new bignumber/* BigNumber */.O(trade.resPricePerToToken);
            const outputAmount = new bignumber/* BigNumber */.O(trade.resAmount).multipliedBy((0,number/* pow10 */.wA)(outputToken.decimals)).integerValue();
            const priceImpact = new bignumber/* BigNumber */.O(trade.priceImpact ?? 0);
            const computed = {
                strategy: Trader/* TraderAPI */.N.TradeStrategy.ExactIn,
                inputToken,
                outputToken,
                inputAmount,
                outputAmount,
                executionPrice,
                fee: number/* ZERO */.xE,
                maximumSold: inputAmount,
                minimumReceived: new bignumber/* BigNumber */.O(trade.minOutAmount),
                // minimumProtocolFee
                priceImpact,
                trade_: {
                    ...trade
                }
            };
            try {
                const gas = await this.getTradeGasLimit(account, chainId, computed);
                return {
                    gas,
                    value: computed,
                    provider: this.provider
                };
            } catch  {
                return {
                    value: computed,
                    provider: this.provider
                };
            }
        } catch (error) {
            if (error instanceof Error) {
                return {
                    value: null,
                    error,
                    provider: this.provider
                };
            }
            return null;
        }
    }
    async getNativeWrapperTradeInfo(chainId, account, inputAmount, inputToken, outputToken) {
        const { WNATIVE_ADDRESS } = (0,constants/* getTokenConstants */.aV)(chainId);
        const tradeAmount = new bignumber/* BigNumber */.O(inputAmount || '0');
        if (tradeAmount.isZero() || !inputToken || !outputToken || !WNATIVE_ADDRESS) return null;
        const wrapperContract = entry/* ContractReadonly */.$u.getWETHContract(WNATIVE_ADDRESS, {
            chainId
        });
        const computed = {
            strategy: Trader/* TraderAPI */.N.TradeStrategy.ExactIn,
            inputToken,
            outputToken,
            inputAmount: tradeAmount,
            outputAmount: tradeAmount,
            executionPrice: number/* ZERO */.xE,
            maximumSold: number/* ZERO */.xE,
            minimumReceived: tradeAmount,
            priceImpact: number/* ZERO */.xE,
            fee: number/* ZERO */.xE,
            trade_: {
                isWrap: (0,token/* isNativeTokenSchemaType */.SC)(inputToken.schema),
                isNativeTokenWrapper: true
            }
        };
        try {
            const tx = await new ContractTransaction/* ContractTransaction */.D(wrapperContract).fillAll(wrapperContract?.methods.deposit(), {
                from: account,
                value: tradeAmount.toFixed()
            });
            const gas = tx.gas ?? '0';
            return {
                gas,
                provider: this.provider,
                value: computed
            };
        } catch  {
            return {
                value: computed,
                provider: this.provider
            };
        }
    }
    getTradeGasLimit(account, chainId, tradeComputed) {
        if (!tradeComputed.trade_?.estimatedGas) return tradeComputed.trade_?.estimatedGas;
        const config = {
            from: account,
            ...(0,pick/* default */.Z)(tradeComputed.trade_, [
                'to',
                'data',
                'value'
            ])
        };
        if (!config.value) return '0';
        return entry/* Web3Readonly */.MJ.estimateTransaction(config, 0, {
            chainId
        });
    }
}
const OpenOcean = new OpenOceanAPI();

;// CONCATENATED MODULE: ./packages/plugins/Trader/src/trader/useOpenOcean.ts







function useOpenOcean(inputAmount_, scale, inputToken, outputToken, temporarySlippage, isNativeTokenWrapper) {
    const { chainId, account } = (0,useContext/* useChainContext */.ql)();
    const network = (0,useNetwork/* useNetwork */.L)(undefined, chainId);
    const slippageSetting = useSlippageTolerance();
    const slippage = (0,react.useMemo)(()=>{
        return temporarySlippage ? temporarySlippage : slippageSetting;
    }, [
        temporarySlippage,
        slippageSetting
    ]);
    const provider = (0,react.useMemo)(()=>{
        if (!network) return;
        const providers = getEVMAvailableTraderProviders(network.type);
        if (!providers.includes(web/* TradeProvider */.z4.OPENOCEAN)) return;
        return OpenOcean;
    }, [
        network
    ]);
    return (0,useBeat/* useCustomBlockBeatRetry */.Xg)(PluginID/* NetworkPluginID */.F.PLUGIN_EVM, async ()=>{
        if (!provider) return;
        return isNativeTokenWrapper ? provider.getNativeWrapperTradeInfo(chainId, account, inputAmount_, inputToken, outputToken) : provider.getTradeInfo(chainId, account, inputAmount_, slippage, inputToken, outputToken);
    }, [
        inputAmount_,
        isNativeTokenWrapper,
        chainId,
        account,
        provider,
        inputToken,
        outputToken
    ], scale);
}

// EXTERNAL MODULE: ./packages/plugins/Trader/src/providers/Bancor.ts + 1 modules
var Bancor = __webpack_require__(17489);
;// CONCATENATED MODULE: ./packages/plugins/Trader/src/trader/useBancor.ts







function useBancor(inputAmount_, scale, inputToken, outputToken, temporarySlippage, isNativeTokenWrapper) {
    const { chainId, account } = (0,useContext/* useChainContext */.ql)();
    const network = (0,useNetwork/* useNetwork */.L)(undefined, chainId);
    const slippageSetting = useSlippageTolerance();
    const slippage = (0,react.useMemo)(()=>{
        return temporarySlippage ? temporarySlippage : slippageSetting;
    }, [
        temporarySlippage,
        slippageSetting
    ]);
    const provider = (0,react.useMemo)(()=>{
        if (!network) return;
        const providers = getEVMAvailableTraderProviders(network.type);
        if (!providers.includes(web/* TradeProvider */.z4.BANCOR)) return;
        return Bancor/* Bancor */.O;
    }, [
        network
    ]);
    return (0,useBeat/* useCustomBlockBeatRetry */.Xg)(PluginID/* NetworkPluginID */.F.PLUGIN_EVM, async ()=>{
        if (!provider) return;
        return isNativeTokenWrapper ? provider.getNativeWrapperTradeInfo(chainId, account, inputAmount_, inputToken, outputToken) : provider.getTradeInfo(chainId, account, inputAmount_, slippage, inputToken, outputToken);
    }, [
        inputAmount_,
        isNativeTokenWrapper,
        chainId,
        account,
        provider,
        inputToken,
        outputToken
    ], scale);
}

;// CONCATENATED MODULE: ./packages/plugins/Trader/src/trader/useAllTradeComputed.ts










function useAllTradeComputed(inputAmount, scale, inputToken, outputToken, temporarySlippage) {
    const { chainId } = (0,useContext/* useChainContext */.ql)();
    const inputTokenProduct = (0,number/* pow10 */.wA)(inputToken?.decimals ?? 0);
    const inputAmount_ = (0,number/* multipliedBy */.$q)(inputAmount || '0', inputTokenProduct).integerValue().toFixed();
    const tradeProviders = useAvailableTraderProviders(chainId);
    // NATIVE-WNATIVE pair
    const { value: isNativeTokenWrapper } = useTrade(inputToken, outputToken);
    // uniswap-v2
    const uniswapV2 = useUniswapV2Like(web/* TradeProvider */.z4.UNISWAP_V2, inputAmount_, scale, inputToken, outputToken, temporarySlippage, isNativeTokenWrapper);
    // sushi swap
    const sushiSwap = useUniswapV2Like(web/* TradeProvider */.z4.SUSHISWAP, inputAmount_, scale, inputToken, outputToken, temporarySlippage, isNativeTokenWrapper);
    // quick swap
    const quickSwap = useUniswapV2Like(web/* TradeProvider */.z4.QUICKSWAP, inputAmount_, scale, inputToken, outputToken, temporarySlippage, isNativeTokenWrapper);
    // pancake swap
    const pancakeSwap = useUniswapV2Like(web/* TradeProvider */.z4.PANCAKESWAP, inputAmount_, scale, inputToken, outputToken, temporarySlippage, isNativeTokenWrapper);
    // uniswap-v3 like providers
    const uniswapV3 = useUniswapV3Like(inputAmount_, scale, inputToken, outputToken, temporarySlippage, isNativeTokenWrapper);
    // zrx
    const zrx = useZeroX(inputAmount_, scale, inputToken, outputToken, temporarySlippage, isNativeTokenWrapper);
    // bancor
    const bancor = useBancor(inputAmount_, scale, inputToken, outputToken, temporarySlippage, isNativeTokenWrapper);
    // traderjoe
    const traderJoe = useUniswapV2Like(web/* TradeProvider */.z4.TRADERJOE, inputAmount_, scale, inputToken, outputToken, temporarySlippage, isNativeTokenWrapper);
    // pangolindex
    const pangolindex = useUniswapV2Like(web/* TradeProvider */.z4.PANGOLIN, inputAmount_, scale, inputToken, outputToken, temporarySlippage, isNativeTokenWrapper);
    // openocean
    const openocean = useOpenOcean(inputAmount_, scale, inputToken, outputToken, temporarySlippage, isNativeTokenWrapper);
    // trisolaris
    const trisolaris = useUniswapV2Like(web/* TradeProvider */.z4.TRISOLARIS, inputAmount_, scale, inputToken, outputToken, temporarySlippage, isNativeTokenWrapper);
    // WannaSwap
    const wannaswap = useUniswapV2Like(web/* TradeProvider */.z4.WANNASWAP, inputAmount_, scale, inputToken, outputToken, temporarySlippage, isNativeTokenWrapper);
    // Mdex
    const mdex = useUniswapV2Like(web/* TradeProvider */.z4.MDEX, inputAmount_, scale, inputToken, outputToken, temporarySlippage, isNativeTokenWrapper);
    // Arthswap
    const arthswap = useUniswapV2Like(web/* TradeProvider */.z4.ARTHSWAP, inputAmount_, scale, inputToken, outputToken, temporarySlippage, isNativeTokenWrapper);
    // Versa Finance
    const versa = useUniswapV2Like(web/* TradeProvider */.z4.VERSA, inputAmount_, scale, inputToken, outputToken, temporarySlippage, isNativeTokenWrapper);
    // Astar Exchange
    const astarexchange = useUniswapV2Like(web/* TradeProvider */.z4.ASTAREXCHANGE, inputAmount_, scale, inputToken, outputToken, temporarySlippage, isNativeTokenWrapper);
    // Yumi Swap
    const yumiswap = useUniswapV2Like(web/* TradeProvider */.z4.YUMISWAP, inputAmount_, scale, inputToken, outputToken, temporarySlippage, isNativeTokenWrapper);
    const all = [
        uniswapV2,
        sushiSwap,
        quickSwap,
        pancakeSwap,
        uniswapV3,
        zrx,
        traderJoe,
        bancor,
        pangolindex,
        openocean,
        wannaswap,
        trisolaris,
        mdex,
        arthswap,
        versa,
        astarexchange,
        yumiswap
    ];
    return all.filter((x)=>{
        return tradeProviders.some((provider)=>provider === x.value?.provider) && !!x.value;
    });
}

;// CONCATENATED MODULE: ./packages/plugins/Trader/src/trader/useAllProviderTradeContext.ts





const INITIAL_STATE = {
    inputAmount: '',
    inputTokenBalance: '0',
    outputTokenBalance: '0'
};
var AllProviderTradeActionType;
(function(AllProviderTradeActionType) {
    AllProviderTradeActionType[AllProviderTradeActionType["UPDATE_INPUT_TOKEN"] = 0] = "UPDATE_INPUT_TOKEN";
    AllProviderTradeActionType[AllProviderTradeActionType["UPDATE_OUTPUT_TOKEN"] = 1] = "UPDATE_OUTPUT_TOKEN";
    AllProviderTradeActionType[AllProviderTradeActionType["UPDATE_INPUT_AMOUNT"] = 2] = "UPDATE_INPUT_AMOUNT";
    AllProviderTradeActionType[AllProviderTradeActionType["UPDATE_INPUT_TOKEN_BALANCE"] = 3] = "UPDATE_INPUT_TOKEN_BALANCE";
    AllProviderTradeActionType[AllProviderTradeActionType["UPDATE_OUTPUT_TOKEN_BALANCE"] = 4] = "UPDATE_OUTPUT_TOKEN_BALANCE";
    AllProviderTradeActionType[AllProviderTradeActionType["SWITCH_TOKEN"] = 5] = "SWITCH_TOKEN";
})(AllProviderTradeActionType || (AllProviderTradeActionType = {}));
function reducer(state, action) {
    switch(action.type){
        case AllProviderTradeActionType.UPDATE_INPUT_TOKEN:
            return {
                ...state,
                inputToken: action.token,
                inputTokenBalance: action.balance ?? state.inputTokenBalance
            };
        case AllProviderTradeActionType.UPDATE_OUTPUT_TOKEN:
            return {
                ...state,
                outputToken: action.token
            };
        case AllProviderTradeActionType.UPDATE_INPUT_AMOUNT:
            return {
                ...state,
                inputAmount: action.amount
            };
        case AllProviderTradeActionType.UPDATE_INPUT_TOKEN_BALANCE:
            return {
                ...state,
                inputTokenBalance: action.balance
            };
        case AllProviderTradeActionType.UPDATE_OUTPUT_TOKEN_BALANCE:
            return {
                ...state,
                outputTokenBalance: action.balance
            };
        case AllProviderTradeActionType.SWITCH_TOKEN:
            return {
                ...state,
                inputToken: action.inputToken,
                outputToken: action.outputToken,
                inputTokenBalance: action.inputBalance,
                outputTokenBalance: action.outputBalance,
                inputAmount: ''
            };
        default:
            return state;
    }
}
function useAllProviderTradeContext() {
    const { chainId } = (0,useContext/* useChainContext */.ql)();
    const [openConfirmDialog, setOpenConfirmDialog] = (0,react.useState)(false);
    const [tradeStore, dispatchTradeStore] = (0,react.useReducer)(reducer, INITIAL_STATE);
    const [isSwapping, setIsSwapping] = (0,react.useState)(false);
    const [temporarySlippage, setTemporarySlippage] = (0,react.useState)();
    const { inputAmount, inputToken, outputToken } = tradeStore;
    const allTradeComputed = useAllTradeComputed(inputAmount, openConfirmDialog ? 1 : trader/* BLOCK_TIME_SCALE */.Gh[chainId] || 1, inputToken, outputToken, temporarySlippage);
    return {
        isSwapping,
        setIsSwapping,
        tradeState: [
            tradeStore,
            dispatchTradeStore
        ],
        temporarySlippage,
        setTemporarySlippage,
        allTradeComputed,
        openConfirmDialog,
        setOpenConfirmDialog
    };
}
const AllProviderTradeContext = (0,unstated_next/* createContainer */.f)(useAllProviderTradeContext);


/***/ }),

/***/ 19628:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  L: () => (/* binding */ EthereumERC20TokenApprovedBoundary)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/react@0.0.0-experimental-0a360642d-20230711/node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(49603);
// EXTERNAL MODULE: ./node_modules/.pnpm/react@0.0.0-experimental-0a360642d-20230711/node_modules/react/index.js
var react = __webpack_require__(78996);
// EXTERNAL MODULE: ./node_modules/.pnpm/@masknet+kit@0.1.2/node_modules/@masknet/kit/esm/index.js + 1 modules
var esm = __webpack_require__(30898);
// EXTERNAL MODULE: ./packages/shared/src/UI/components/TokenIcon/index.tsx
var TokenIcon = __webpack_require__(95621);
// EXTERNAL MODULE: ./packages/shared-base/src/types/PluginID.ts
var PluginID = __webpack_require__(24835);
// EXTERNAL MODULE: ./packages/theme/src/UIHelper/makeStyles.ts
var makeStyles = __webpack_require__(23615);
// EXTERNAL MODULE: ./packages/theme/src/Components/ActionButton/index.tsx
var ActionButton = __webpack_require__(90097);
// EXTERNAL MODULE: ./packages/theme/src/Components/WrappedComponents/ShadowRootTooltip.ts
var ShadowRootTooltip = __webpack_require__(27966);
// EXTERNAL MODULE: ./packages/web3-hooks/base/src/useContext.tsx + 1 modules
var useContext = __webpack_require__(14162);
// EXTERNAL MODULE: ./packages/web3-hooks/base/src/useFungibleTokenBalance.ts
var useFungibleTokenBalance = __webpack_require__(88572);
// EXTERNAL MODULE: ./packages/web3-hooks/base/src/useFungibleTokenSpenders.ts
var useFungibleTokenSpenders = __webpack_require__(54165);
// EXTERNAL MODULE: ./packages/web3-hooks/evm/src/useERC20TokenApproveCallback.ts
var useERC20TokenApproveCallback = __webpack_require__(13414);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/number.ts
var number = __webpack_require__(29763);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/isSameAddress.ts
var isSameAddress = __webpack_require__(74765);
// EXTERNAL MODULE: ./node_modules/.pnpm/@mui+material@5.10.8_@emotion+react@11.11.1_@emotion+styled@11.11.0_@types+react@18.2.21_reac_i4im6kvy6ed7iuhqcafkffcuku/node_modules/@mui/material/esm/utils/createSvgIcon.js
var createSvgIcon = __webpack_require__(57058);
;// CONCATENATED MODULE: ./node_modules/.pnpm/@mui+icons-material@5.10.6_@mui+material@5.10.8_@types+react@18.2.21_react@0.0.0-experimental-0a360642d-20230711/node_modules/@mui/icons-material/esm/HelpOutline.js


/* harmony default export */ const HelpOutline = ((0,createSvgIcon/* default */.Z)( /*#__PURE__*/(0,jsx_runtime.jsx)("path", {
  d: "M11 18h2v-2h-2v2zm1-16C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-2.21 0-4 1.79-4 4h2c0-1.1.9-2 2-2s2 .9 2 2c0 2-3 1.75-3 5h2c0-2.25 3-2.5 3-5 0-2.21-1.79-4-4-4z"
}), 'HelpOutline'));
// EXTERNAL MODULE: ./packages/shared/src/locales/i18n_generated.ts
var i18n_generated = __webpack_require__(8772);
;// CONCATENATED MODULE: ./packages/shared/src/UI/components/EthereumERC20TokenApprovedBoundary/index.tsx











const useStyles = (0,makeStyles/* makeStyles */.Z)()((theme, _, refs)=>({
        icon: {},
        button: {
            whiteSpace: 'nowrap',
            // increase selector priority over button's
            [`.${refs.icon}`]: {
                width: 18,
                height: 18,
                fontSize: 10
            }
        },
        helpIcon: {
            width: 18,
            height: 18
        }
    }));
function EthereumERC20TokenApprovedBoundary(props) {
    const { children = null, amount, balance, spender, token, infiniteUnlockContent, contractName, showHelperToken = true, failedContent, callback } = props;
    const t = (0,i18n_generated/* useSharedTrans */.j)();
    const { classes } = useStyles(undefined, {
        props
    });
    const { account, chainId } = (0,useContext/* useChainContext */.ql)({
        chainId: token?.chainId
    });
    const { data: tokenBalance } = (0,useFungibleTokenBalance/* useFungibleTokenBalance */.V)(PluginID/* NetworkPluginID */.F.PLUGIN_EVM, token?.address, {
        chainId
    });
    const { data: spenders, isLoading: spendersLoading, isError, refetch } = (0,useFungibleTokenSpenders/* useFungibleTokenSpenders */.D)(PluginID/* NetworkPluginID */.F.PLUGIN_EVM, {
        chainId,
        account
    });
    const approveAmount = balance || tokenBalance || amount;
    const [{ type: approveStateType, allowance }, transactionState, approveCallback] = (0,useERC20TokenApproveCallback/* useERC20TokenApproveCallback */.S)(token?.address ?? '', approveAmount, spender ?? '', ()=>{
        callback?.();
        refetch();
    }, token?.chainId);
    const approved = (0,react.useMemo)(()=>{
        if ((0,number/* isGte */.sK)(allowance, amount)) return true;
        if (!token?.address || !spenders?.length) return false;
        return spenders.some((x)=>{
            return (0,isSameAddress/* isSameAddress */.W)(x.tokenInfo.address, token.address) && (0,isSameAddress/* isSameAddress */.W)(x.address, spender) && (0,number/* isGte */.sK)((0,number/* rightShift */.pu)(x.amount || 0, x.tokenInfo.decimals || token.decimals), amount);
        });
    }, [
        allowance,
        amount,
        spenders,
        token?.address,
        token?.decimals,
        spender
    ]);
    const loading = spendersLoading || approveStateType === useERC20TokenApproveCallback/* ApproveStateType */.i.UPDATING || transactionState.loadingApprove || transactionState.loading;
    const onApprove = (0,react.useCallback)(async ()=>{
        if (approved || loading) return;
        await approveCallback(true);
    }, [
        approved,
        loading,
        approveCallback
    ]);
    // not a valid erc20 token, please given token as undefined
    if (!token) return /*#__PURE__*/ (0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
        children: typeof children === 'function' ? children(allowance) : children
    });
    if (isError) return /*#__PURE__*/ (0,jsx_runtime.jsx)(ActionButton/* ActionButton */.K, {
        className: classes.button,
        fullWidth: true,
        variant: "contained",
        onClick: ()=>refetch(),
        ...props.ActionButtonProps,
        children: failedContent ?? t.wallet_load_retry({
            symbol: token.symbol ?? token.name ?? 'Token'
        })
    });
    if (loading || !approved) return /*#__PURE__*/ (0,jsx_runtime.jsx)(ActionButton/* ActionButton */.K, {
        loading: loading,
        className: classes.button,
        fullWidth: true,
        variant: "contained",
        startIcon: /*#__PURE__*/ (0,jsx_runtime.jsx)(TokenIcon/* TokenIcon */.T, {
            className: classes.icon,
            address: token.address,
            chainId: token.chainId,
            name: token.name,
            disableDefaultIcon: true
        }),
        endIcon: showHelperToken ? /*#__PURE__*/ (0,jsx_runtime.jsx)(ShadowRootTooltip/* ShadowRootTooltip */.p, {
            title: t.plugin_wallet_token_infinite_unlock_tips({
                provider: contractName ?? '',
                symbol: token.symbol
            }),
            placement: "top",
            arrow: true,
            leaveDelay: 2000,
            disableInteractive: true,
            disableFocusListener: true,
            disableTouchListener: true,
            children: /*#__PURE__*/ (0,jsx_runtime.jsx)(HelpOutline, {
                className: classes.helpIcon
            })
        }) : null,
        onClick: onApprove,
        ...props.ActionButtonProps,
        children: infiniteUnlockContent ?? t.plugin_wallet_token_infinite_unlock({
            symbol: token.symbol
        })
    });
    if (approved) return /*#__PURE__*/ (0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
        children: typeof children === 'function' ? children(allowance) : children
    });
    (0,esm/* unreachable */.t1)(approved);
}


/***/ }),

/***/ 24981:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  T: () => (/* binding */ WalletConnectedBoundary)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/react@0.0.0-experimental-0a360642d-20230711/node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(49603);
// EXTERNAL MODULE: ./packages/theme/src/UIHelper/makeStyles.ts
var makeStyles = __webpack_require__(23615);
// EXTERNAL MODULE: ./packages/theme/src/Components/ActionButton/index.tsx
var ActionButton = __webpack_require__(90097);
// EXTERNAL MODULE: ./packages/shared/src/locales/i18n_generated.ts
var i18n_generated = __webpack_require__(8772);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/number.ts
var number = __webpack_require__(29763);
// EXTERNAL MODULE: ./packages/web3-hooks/base/src/useContext.tsx + 1 modules
var useContext = __webpack_require__(14162);
// EXTERNAL MODULE: ./packages/web3-hooks/base/src/useWallet.ts
var useWallet = __webpack_require__(98170);
// EXTERNAL MODULE: ./packages/web3-hooks/base/src/useNativeTokenBalance.ts
var useNativeTokenBalance = __webpack_require__(5480);
// EXTERNAL MODULE: ./node_modules/.pnpm/use-subscription@1.8.0_react@0.0.0-experimental-0a360642d-20230711/node_modules/use-subscription/index.js
var use_subscription = __webpack_require__(15628);
// EXTERNAL MODULE: ./packages/shared-base/src/Subscriptions/index.ts
var Subscriptions = __webpack_require__(15019);
// EXTERNAL MODULE: ./packages/web3-hooks/base/src/useWeb3State.ts
var useWeb3State = __webpack_require__(83977);
;// CONCATENATED MODULE: ./packages/web3-hooks/base/src/useRiskWarningApproved.ts



function useRiskWarningApproved(pluginID) {
    const { RiskWarning } = (0,useWeb3State/* useWeb3State */.d)(pluginID);
    return (0,use_subscription.useSubscription)(RiskWarning?.approved ?? Subscriptions/* FALSE */.Dv);
}

// EXTERNAL MODULE: ./node_modules/.pnpm/react-use@17.4.0_react-dom@0.0.0-experimental-0a360642d-20230711_react@0.0.0-experimental-0a360642d-20230711/node_modules/react-use/esm/useAsync.js
var useAsync = __webpack_require__(17735);
// EXTERNAL MODULE: ./packages/web3-providers/src/entry.ts
var entry = __webpack_require__(62322);
// EXTERNAL MODULE: ./packages/shared-base/src/types/PluginID.ts
var PluginID = __webpack_require__(24835);
// EXTERNAL MODULE: ./packages/shared/src/UI/modals/modals.ts
var modals = __webpack_require__(25127);
;// CONCATENATED MODULE: ./packages/shared/src/UI/components/WalletConnectedBoundary/index.tsx









const useStyles = (0,makeStyles/* makeStyles */.Z)()({
    button: {
        margin: 0
    }
});
function WalletConnectedBoundary(props) {
    const { children = null, offChain = false, hideRiskWarningConfirmed = false, expectedChainId } = props;
    const t = (0,i18n_generated/* useSharedTrans */.j)();
    const { classes, cx } = useStyles(undefined, {
        props
    });
    const { pluginID } = (0,useContext/* useNetworkContext */.gK)();
    const { account, chainId: chainIdValid } = (0,useContext/* useChainContext */.ql)({
        chainId: expectedChainId
    });
    const wallet = (0,useWallet/* useWallet */.O)();
    const { value: smartPayChainId } = (0,useAsync/* default */.Z)(async ()=>entry/* SmartPayBundler */.Pp.getSupportedChainId(), []);
    const nativeTokenBalance = (0,useNativeTokenBalance/* useNativeTokenBalance */.h)(undefined, {
        chainId: chainIdValid
    });
    const approved = useRiskWarningApproved();
    const buttonClass = cx(classes.button, classes.connectWallet);
    if (!account) return /*#__PURE__*/ (0,jsx_runtime.jsx)(ActionButton/* ActionButton */.K, {
        startIcon: props.startIcon,
        className: buttonClass,
        fullWidth: true,
        onClick: ()=>modals/* SelectProviderModal */.ge.open(),
        ...props.ActionButtonProps,
        children: t.plugin_wallet_connect_a_wallet()
    });
    if (!approved && !hideRiskWarningConfirmed && pluginID === PluginID/* NetworkPluginID */.F.PLUGIN_EVM) return /*#__PURE__*/ (0,jsx_runtime.jsx)(ActionButton/* ActionButton */.K, {
        className: buttonClass,
        fullWidth: true,
        variant: "contained",
        onClick: ()=>{
            modals/* WalletRiskWarningModal */.L5.open({
                account,
                pluginID
            });
        },
        ...props.ActionButtonProps,
        children: t.plugin_wallet_confirm_risk_warning()
    });
    if (!(wallet?.owner && chainIdValid === smartPayChainId) && (0,number/* isZero */.Fr)(nativeTokenBalance.value ?? '0') && !offChain) return /*#__PURE__*/ (0,jsx_runtime.jsx)(ActionButton/* ActionButton */.K, {
        className: buttonClass,
        disabled: !nativeTokenBalance.error,
        fullWidth: true,
        variant: "contained",
        onClick: nativeTokenBalance.retry,
        ...props.ActionButtonProps,
        children: nativeTokenBalance.loading ? t.plugin_wallet_update_gas_fee() : t.plugin_wallet_no_gas_fee()
    });
    if (!chainIdValid && !offChain) return /*#__PURE__*/ (0,jsx_runtime.jsx)(ActionButton/* ActionButton */.K, {
        className: buttonClass,
        disabled: true,
        fullWidth: true,
        variant: "contained",
        ...props.ActionButtonProps,
        children: t.plugin_wallet_invalid_network()
    });
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
        children: children
    });
}


/***/ }),

/***/ 72116:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ Action)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(49603);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(78996);
/* harmony import */ var _mui_material__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(78130);
/* harmony import */ var _mui_material__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6764);
/* harmony import */ var _locales_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8772);
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(66584);





const Action = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(function Action({ children, openSelectWalletDialog }) {
    const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();
    const t = (0,_locales_index_js__WEBPACK_IMPORTED_MODULE_2__/* .useSharedTrans */ .j)();
    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_mui_material__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z, {
        display: "flex",
        columnGap: 16,
        minWidth: !_masknet_shared_base__WEBPACK_IMPORTED_MODULE_4__/* .Sniffings */ .Y.is_popup_page ? 276 : 176,
        ref: ref,
        children: children ?? /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_mui_material__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z, {
            fullWidth: true,
            onClick: openSelectWalletDialog,
            children: t.wallet_status_button_change()
        })
    });
});


/***/ }),

/***/ 708:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ PluginWalletStatusBar)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(49603);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(78996);
/* harmony import */ var _mui_material__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(78056);
/* harmony import */ var _mui_material__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(78130);
/* harmony import */ var _mui_material__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(6764);
/* harmony import */ var _masknet_icons__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(8311);
/* harmony import */ var _masknet_theme__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23615);
/* harmony import */ var _masknet_theme__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(23935);
/* harmony import */ var _masknet_web3_hooks_base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(14162);
/* harmony import */ var _masknet_web3_hooks_base__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(98170);
/* harmony import */ var _masknet_web3_hooks_base__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(84305);
/* harmony import */ var _masknet_web3_hooks_base__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(20701);
/* harmony import */ var _masknet_web3_hooks_base__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(6379);
/* harmony import */ var _masknet_web3_hooks_base__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(81128);
/* harmony import */ var _masknet_web3_hooks_base__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(60574);
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(66584);
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(62649);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(24770);
/* harmony import */ var _locales_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(8772);
/* harmony import */ var _WalletDescription_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(58307);
/* harmony import */ var _Action_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(72116);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(25127);













const useStyles = (0,_masknet_theme__WEBPACK_IMPORTED_MODULE_2__/* .makeStyles */ .Z)()((theme)=>({
        root: {
            boxSizing: 'content-box',
            display: 'flex',
            backgroundColor: _masknet_shared_base__WEBPACK_IMPORTED_MODULE_3__/* .Sniffings */ .Y.is_dashboard_page ? _masknet_theme__WEBPACK_IMPORTED_MODULE_4__/* .MaskColorVar */ .Z.mainBackground : (0,_mui_material__WEBPACK_IMPORTED_MODULE_5__/* .alpha */ .Fq)(theme.palette.maskColor.bottom, 0.8),
            boxShadow: theme.palette.mode === 'dark' ? '0px 0px 20px rgba(255, 255, 255, 0.12)' : '0px 0px 20px rgba(0, 0, 0, 0.05)',
            backdropFilter: 'blur(16px)',
            padding: theme.spacing(2),
            borderRadius: '0 0 12px 12px',
            alignItems: 'center',
            justifyContent: 'space-between',
            flex: 1,
            maxHeight: 40
        },
        connection: {
            width: 18,
            height: 18,
            marginRight: 8
        }
    }));
const PluginWalletStatusBarWithoutContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ className, onClick, expectedPluginID, expectedChainId, children, requiredSupportChainIds, requiredSupportPluginID })=>{
    const t = (0,_locales_index_js__WEBPACK_IMPORTED_MODULE_6__/* .useSharedTrans */ .j)();
    const { classes, cx } = useStyles();
    const { pluginID } = (0,_masknet_web3_hooks_base__WEBPACK_IMPORTED_MODULE_7__/* .useNetworkContext */ .gK)();
    const { account, chainId, providerType } = (0,_masknet_web3_hooks_base__WEBPACK_IMPORTED_MODULE_7__/* .useChainContext */ .ql)();
    const wallet = (0,_masknet_web3_hooks_base__WEBPACK_IMPORTED_MODULE_8__/* .useWallet */ .O)(pluginID);
    const providerDescriptor = (0,_masknet_web3_hooks_base__WEBPACK_IMPORTED_MODULE_9__/* .useProviderDescriptor */ .f)();
    const networkDescriptor = (0,_masknet_web3_hooks_base__WEBPACK_IMPORTED_MODULE_10__/* .useNetworkDescriptor */ .V)(pluginID, chainId);
    const expectedNetworkDescriptor = (0,_masknet_web3_hooks_base__WEBPACK_IMPORTED_MODULE_10__/* .useNetworkDescriptor */ .V)(expectedPluginID, expectedChainId);
    const { data: domain } = (0,_masknet_web3_hooks_base__WEBPACK_IMPORTED_MODULE_11__/* .useReverseAddress */ .$)(pluginID, account);
    const Others = (0,_masknet_web3_hooks_base__WEBPACK_IMPORTED_MODULE_12__/* .useWeb3Others */ .v)();
    const openSelectProviderDialog = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{
        _index_js__WEBPACK_IMPORTED_MODULE_13__/* .SelectProviderModal */ .ge.open({
            requiredSupportChainIds,
            requiredSupportPluginID
        });
    }, [
        expectedNetworkDescriptor,
        requiredSupportChainIds,
        requiredSupportPluginID
    ]);
    const pendingTransactions = (0,_masknet_web3_hooks_base__WEBPACK_IMPORTED_MODULE_14__/* .useRecentTransactions */ .S)(pluginID, _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_15__.TransactionStatusType.NOT_DEPEND);
    const walletName = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{
        if (domain) return domain;
        if (providerType === _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_16__/* .ProviderType */ .lP.MaskWallet && wallet?.name) return wallet?.name;
        return providerDescriptor?.name || Others.formatAddress(account, 4);
    }, [
        account,
        domain,
        providerType,
        wallet?.name,
        providerDescriptor?.name,
        Others.formatAddress
    ]);
    if (!account) {
        return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_mui_material__WEBPACK_IMPORTED_MODULE_17__/* ["default"] */ .Z, {
            className: cx(classes.root, className),
            children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_mui_material__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .Z, {
                fullWidth: true,
                onClick: openSelectProviderDialog,
                children: [
                    /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_masknet_icons__WEBPACK_IMPORTED_MODULE_19__.Wallet, {
                        className: classes.connection
                    }),
                    " ",
                    t.plugin_wallet_connect_a_wallet()
                ]
            })
        });
    }
    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_mui_material__WEBPACK_IMPORTED_MODULE_17__/* ["default"] */ .Z, {
        className: cx(classes.root, className),
        children: [
            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_WalletDescription_js__WEBPACK_IMPORTED_MODULE_20__/* .WalletDescription */ .a, {
                pending: !!pendingTransactions.length,
                providerIcon: providerDescriptor?.icon,
                networkIcon: networkDescriptor?.icon,
                iconFilterColor: providerDescriptor?.iconFilterColor,
                name: walletName,
                formattedAddress: Others.formatAddress(account, 4),
                addressLink: Others.explorerResolver.addressLink(chainId, account),
                onClick: onClick ?? openSelectProviderDialog,
                onPendingClick: ()=>_index_js__WEBPACK_IMPORTED_MODULE_13__/* .WalletStatusModal */ .L9.open()
            }),
            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_Action_js__WEBPACK_IMPORTED_MODULE_21__/* .Action */ .a, {
                openSelectWalletDialog: openSelectProviderDialog,
                children: children
            })
        ]
    });
});
PluginWalletStatusBarWithoutContext.displayName = 'PluginWalletStatusBarWithoutContext';
const PluginWalletStatusBar = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)((props)=>{
    const children = /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_masknet_web3_hooks_base__WEBPACK_IMPORTED_MODULE_7__/* .RevokeChainContextProvider */ .fw, {
        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PluginWalletStatusBarWithoutContext, {
            ...props
        })
    });
    return props.actualPluginID ? /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_masknet_web3_hooks_base__WEBPACK_IMPORTED_MODULE_7__/* .NetworkContextProvider */ .f6, {
        value: props.actualPluginID,
        children: children
    }) : children;
});
PluginWalletStatusBar.displayName = 'PluginWalletStatusBar';


/***/ }),

/***/ 58307:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ WalletDescription)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(49603);
/* harmony import */ var _masknet_theme__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23615);
/* harmony import */ var _masknet_theme__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(20419);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(78996);
/* harmony import */ var _mui_material__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(78056);
/* harmony import */ var _mui_material__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(78130);
/* harmony import */ var _mui_material__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(7387);
/* harmony import */ var _mui_material__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(90138);
/* harmony import */ var _masknet_shared__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(98748);
/* harmony import */ var _masknet_shared__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(98662);
/* harmony import */ var _masknet_icons__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(8311);
/* harmony import */ var _locales_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8772);







const useStyles = (0,_masknet_theme__WEBPACK_IMPORTED_MODULE_2__/* .makeStyles */ .Z)()((theme)=>({
        root: {
            display: 'flex',
            alignItems: 'center',
            columnGap: 4,
            cursor: 'pointer'
        },
        description: {
            marginLeft: 10
        },
        walletName: {
            display: 'flex',
            alignItems: 'center',
            columnGap: 4,
            color: theme.palette.maskColor.main,
            fontWeight: 700,
            lineHeight: '18px'
        },
        address: {
            color: theme.palette.maskColor.second,
            lineHeight: '18px',
            display: 'flex',
            alignItems: 'center',
            columnGap: 2
        },
        pending: {
            display: 'flex',
            alignItems: 'center',
            gap: 2,
            borderRadius: 2,
            padding: '2px 4px',
            backgroundColor: (0,_mui_material__WEBPACK_IMPORTED_MODULE_3__/* .alpha */ .Fq)(theme.palette.maskColor.warn, 0.1),
            color: theme.palette.maskColor.warn,
            lineHeight: '18px'
        },
        progress: {
            color: theme.palette.maskColor.warn
        },
        linkIcon: {
            color: theme.palette.maskColor.second,
            cursor: 'pointer',
            height: 14
        }
    }));
const WalletDescription = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ onClick, providerIcon, networkIcon, iconFilterColor, name, address, formattedAddress, addressLink, onPendingClick, pending, verified })=>{
    const { classes } = useStyles();
    const t = (0,_locales_index_js__WEBPACK_IMPORTED_MODULE_4__/* .useSharedTrans */ .j)();
    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_mui_material__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z, {
        onClick: onClick,
        className: classes.root,
        children: [
            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_masknet_shared__WEBPACK_IMPORTED_MODULE_6__/* .WalletIcon */ .o, {
                size: 30,
                badgeSize: 12,
                mainIcon: providerIcon ?? networkIcon,
                badgeIcon: providerIcon ? networkIcon : undefined,
                iconFilterColor: iconFilterColor
            }),
            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_mui_material__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z, {
                className: classes.description,
                children: [
                    /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_mui_material__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z, {
                        className: classes.walletName,
                        children: [
                            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", {
                                children: name
                            }),
                            verified ? /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_masknet_icons__WEBPACK_IMPORTED_MODULE_8__.Verification, {
                                size: 18
                            }) : null,
                            onPendingClick ? /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_masknet_icons__WEBPACK_IMPORTED_MODULE_8__.ArrowDrop, {}) : null
                        ]
                    }),
                    /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_mui_material__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z, {
                        className: classes.address,
                        children: [
                            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", {
                                children: formattedAddress
                            }),
                            address ? /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_masknet_shared__WEBPACK_IMPORTED_MODULE_9__/* .CopyButton */ .q, {
                                size: 14,
                                className: classes.linkIcon,
                                text: address
                            }) : null,
                            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_mui_material__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z, {
                                href: addressLink,
                                target: "_blank",
                                title: "View on Explorer",
                                rel: "noopener noreferrer",
                                onClick: (event)=>{
                                    event.stopPropagation();
                                },
                                className: classes.linkIcon,
                                children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_masknet_icons__WEBPACK_IMPORTED_MODULE_8__.LinkOut, {
                                    size: 14,
                                    className: classes.linkIcon
                                })
                            }),
                            pending ? /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", {
                                className: classes.pending,
                                onClick: (e)=>{
                                    e.stopPropagation();
                                    onPendingClick?.();
                                },
                                children: [
                                    t.recent_transaction_pending(),
                                    /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_masknet_theme__WEBPACK_IMPORTED_MODULE_11__/* .LoadingBase */ .S, {
                                        size: 12,
                                        className: classes.progress
                                    })
                                ]
                            }) : null
                        ]
                    })
                ]
            })
        ]
    });
});


/***/ }),

/***/ 42938:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Xg: () => (/* binding */ useCustomBlockBeatRetry),
/* harmony export */   gm: () => (/* binding */ useSingleBlockBeatRetry)
/* harmony export */ });
/* unused harmony exports useBeat, useBeatRetry, useDoubleBlockBeatRetry */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78996);
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99732);
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(77219);
/* harmony import */ var _useContext_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(14162);
/* harmony import */ var _useWeb3Others_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(81128);




const DEFAULT_SINGLE_BLOCK_DELAY = 10 * 1000;
// 10 seconds
const DEFAULT_DOUBLE_BLOCK_DELAY = DEFAULT_SINGLE_BLOCK_DELAY * 2;
function useBeat(delay = 1000) {
    const [beat, setBeat] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);
    const [, , reset] = (0,react_use__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(()=>{
        setBeat((x)=>(x + 1) % Number.MAX_SAFE_INTEGER);
        reset();
    }, delay);
    return beat;
}
/**
 * @deprecated Use react-query with refetchInterval
 */ function useBeatRetry(fn, delay = 1000, deps = []) {
    const beat = useBeat(delay);
    return (0,react_use__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(fn, deps.concat(beat));
}
function useSingleBlockBeatRetry(pluginID, fn, deps = []) {
    const { chainId } = (0,_useContext_js__WEBPACK_IMPORTED_MODULE_3__/* .useChainContext */ .ql)();
    const Others = (0,_useWeb3Others_js__WEBPACK_IMPORTED_MODULE_4__/* .useWeb3Others */ .v)(pluginID);
    return useBeatRetry(fn, Others.getAverageBlockDelay?.(chainId) ?? DEFAULT_SINGLE_BLOCK_DELAY, deps);
}
function useDoubleBlockBeatRetry(pluginID, fn, deps = []) {
    const { chainId } = useChainContext();
    const Others = useWeb3Others(pluginID);
    return useBeatRetry(fn, Others.getAverageBlockDelay?.(chainId, 2) ?? DEFAULT_DOUBLE_BLOCK_DELAY, deps);
}
function useCustomBlockBeatRetry(pluginID, fn, deps = [], scale = 1) {
    const { chainId } = (0,_useContext_js__WEBPACK_IMPORTED_MODULE_3__/* .useChainContext */ .ql)();
    const Others = (0,_useWeb3Others_js__WEBPACK_IMPORTED_MODULE_4__/* .useWeb3Others */ .v)(pluginID);
    return useBeatRetry(fn, Others.getAverageBlockDelay?.(chainId, scale) ?? DEFAULT_DOUBLE_BLOCK_DELAY, deps);
}


/***/ }),

/***/ 54165:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D: () => (/* binding */ useFungibleTokenSpenders)
/* harmony export */ });
/* harmony import */ var _tanstack_react_query__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(39333);
/* harmony import */ var _useContext_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14162);
/* harmony import */ var _useWeb3Hub_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61811);



function useFungibleTokenSpenders(pluginID, options) {
    const { account, chainId } = (0,_useContext_js__WEBPACK_IMPORTED_MODULE_0__/* .useChainContext */ .ql)({
        account: options?.account,
        chainId: options?.chainId
    });
    const Hub = (0,_useWeb3Hub_js__WEBPACK_IMPORTED_MODULE_1__/* .useWeb3Hub */ .h)(pluginID, {
        account,
        chainId,
        ...options
    });
    return (0,_tanstack_react_query__WEBPACK_IMPORTED_MODULE_2__/* .useQuery */ .a)({
        queryKey: [
            'fungible-tokens',
            'spenders',
            chainId,
            account
        ],
        enabled: true,
        queryFn: async ()=>Hub.getFungibleTokenSpenders(chainId, account)
    });
}


/***/ }),

/***/ 5480:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   h: () => (/* binding */ useNativeTokenBalance)
/* harmony export */ });
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(77219);
/* harmony import */ var _useContext_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14162);
/* harmony import */ var _useWeb3Connection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96732);



function useNativeTokenBalance(pluginID, options) {
    const { account } = (0,_useContext_js__WEBPACK_IMPORTED_MODULE_0__/* .useChainContext */ .ql)({
        account: options?.account
    });
    const Web3 = (0,_useWeb3Connection_js__WEBPACK_IMPORTED_MODULE_1__/* .useWeb3Connection */ .T)(pluginID, {
        account,
        ...options
    });
    return (0,react_use__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(async ()=>{
        return Web3.getNativeTokenBalance();
    }, [
        account,
        Web3
    ]);
}


/***/ }),

/***/ 61918:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   n: () => (/* binding */ useERC20TokenAllowance)
/* harmony export */ });
/* harmony import */ var _masknet_web3_providers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62322);
/* harmony import */ var _masknet_web3_hooks_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14162);
/* harmony import */ var _tanstack_react_query__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(39333);



function useERC20TokenAllowance(address, spender, options) {
    const { account, chainId } = (0,_masknet_web3_hooks_base__WEBPACK_IMPORTED_MODULE_1__/* .useChainContext */ .ql)({
        account: options?.account,
        chainId: options?.chainId
    });
    return (0,_tanstack_react_query__WEBPACK_IMPORTED_MODULE_2__/* .useQuery */ .a)({
        queryKey: [
            'erc20-allowance',
            address,
            account,
            spender
        ],
        queryFn: async ()=>{
            if (!account || !address || !spender) return '0';
            return _masknet_web3_providers__WEBPACK_IMPORTED_MODULE_0__/* .Contract */ .CH.getERC20Contract(address, {
                chainId
            })?.methods.allowance(account, spender).call({
                from: account
            });
        },
        refetchInterval: 30 * 1000
    });
}


/***/ }),

/***/ 13414:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   S: () => (/* binding */ useERC20TokenApproveCallback),
/* harmony export */   i: () => (/* binding */ ApproveStateType)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78996);
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(82897);
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(24835);
/* harmony import */ var _masknet_web3_providers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(62322);
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29763);
/* harmony import */ var _masknet_web3_hooks_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(14162);
/* harmony import */ var _masknet_web3_hooks_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(88572);
/* harmony import */ var _useERC20TokenAllowance_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(61918);







const MaxUint256 = (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .toFixed */ .FH)('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');
var ApproveStateType;
(function(ApproveStateType) {
    ApproveStateType[ApproveStateType["UNKNOWN"] = 0] = "UNKNOWN";
    ApproveStateType[ApproveStateType["NOT_APPROVED"] = 1] = "NOT_APPROVED";
    ApproveStateType[ApproveStateType["UPDATING"] = 2] = "UPDATING";
    ApproveStateType[ApproveStateType["PENDING"] = 3] = "PENDING";
    ApproveStateType[ApproveStateType["APPROVED"] = 4] = "APPROVED";
    ApproveStateType[ApproveStateType["FAILED"] = 5] = "FAILED";
})(ApproveStateType || (ApproveStateType = {}));
function useERC20TokenApproveCallback(address, amount, spender, callback, tokenChainId) {
    const { account, chainId } = (0,_masknet_web3_hooks_base__WEBPACK_IMPORTED_MODULE_3__/* .useChainContext */ .ql)();
    // read the approved information from the chain
    const { data: balance = '0', isLoading: loadingBalance, error: errorBalance, refetch: revalidateBalance } = (0,_masknet_web3_hooks_base__WEBPACK_IMPORTED_MODULE_4__/* .useFungibleTokenBalance */ .V)(_masknet_shared_base__WEBPACK_IMPORTED_MODULE_5__/* .NetworkPluginID */ .F.PLUGIN_EVM, address, {
        chainId: tokenChainId
    });
    const { data: allowance = '0', isLoading: loadingAllowance, error: errorAllowance, refetch: revalidateAllowance } = (0,_useERC20TokenAllowance_js__WEBPACK_IMPORTED_MODULE_6__/* .useERC20TokenAllowance */ .n)(address, spender, {
        chainId: tokenChainId
    });
    // the computed approve state
    const approveStateType = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{
        if (!amount || !spender) return ApproveStateType.UNKNOWN;
        if (loadingBalance || loadingAllowance) return ApproveStateType.UPDATING;
        if (errorBalance || errorAllowance) return ApproveStateType.FAILED;
        return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .isLessThan */ .FI)(allowance, amount) || allowance === amount && (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .isZero */ .Fr)(amount) ? ApproveStateType.NOT_APPROVED : ApproveStateType.APPROVED;
    }, [
        amount,
        spender,
        balance,
        allowance,
        errorBalance,
        errorAllowance,
        loadingAllowance,
        loadingBalance
    ]);
    const [state, approveCallback] = (0,react_use__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(async (useExact = false, isRevoke = false)=>{
        if (approveStateType === ApproveStateType.UNKNOWN || !amount || !spender) {
            return;
        }
        // error: failed to approve token
        if (approveStateType !== ApproveStateType.NOT_APPROVED && !isRevoke) {
            return;
        }
        if (tokenChainId !== chainId) {
            await _masknet_web3_providers__WEBPACK_IMPORTED_MODULE_1__/* .Web3 */ .Bv.switchChain?.(tokenChainId ?? chainId);
        }
        const hash = await _masknet_web3_providers__WEBPACK_IMPORTED_MODULE_1__/* .Web3 */ .Bv.approveFungibleToken(address, spender, useExact ? amount : MaxUint256, {
            chainId: tokenChainId
        });
        const receipt = await _masknet_web3_providers__WEBPACK_IMPORTED_MODULE_1__/* .Web3 */ .Bv.confirmTransaction(hash, {
            chainId: tokenChainId,
            signal: AbortSignal.timeout(5 * 60 * 1000)
        });
        if (receipt) {
            callback?.();
            revalidateBalance();
            revalidateAllowance();
        }
    }, [
        account,
        amount,
        spender,
        address,
        approveStateType,
        tokenChainId,
        chainId
    ]);
    const resetCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{
        revalidateBalance();
        revalidateAllowance();
    }, [
        revalidateBalance
    ]);
    return [
        {
            type: approveStateType,
            allowance,
            amount,
            spender,
            balance
        },
        {
            ...state,
            loading: loadingAllowance || loadingBalance || state.loading,
            loadingApprove: state.loading
        },
        approveCallback,
        resetCallback
    ];
}


/***/ }),

/***/ 53520:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   N: () => (/* binding */ TraderAPI)
/* harmony export */ });
var TraderAPI;
(function(TraderAPI) {
    let TradeStrategy;
    (function(TradeStrategy) {
        TradeStrategy[TradeStrategy["ExactIn"] = 0] = "ExactIn";
        TradeStrategy[TradeStrategy["ExactOut"] = 1] = "ExactOut";
    })(TradeStrategy = TraderAPI.TradeStrategy || (TraderAPI.TradeStrategy = {}));
})(TraderAPI || (TraderAPI = {}));


/***/ }),

/***/ 69066:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   P: () => (/* binding */ pack)
/* harmony export */ });
/* harmony import */ var web3_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(84976);
/* harmony import */ var web3_utils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(web3_utils__WEBPACK_IMPORTED_MODULE_0__);

function pack(types, values) {
    if (types.length !== values.length) {
        throw new Error('Number of types does not match number of values.');
    }
    let result = '0x';
    for(let i = 0; i < types.length; i += 1){
        switch(types[i]){
            case 'address':
                result += values[i].slice(2).padStart(40, '0');
                break;
            case 'uint256':
                result += BigInt(values[i]).toString(16).padStart(64, '0');
                break;
            case 'bytes32':
                result += (0,web3_utils__WEBPACK_IMPORTED_MODULE_0__.utf8ToHex)(values[i]).slice(2).padStart(64, '0');
                break;
            case 'bool':
                result += values[i] ? '01' : '00';
                break;
            // ... you can continue adding more cases for other data types
            default:
                throw new Error(`Unsupported type ${types[i]}`);
        }
    }
    return result;
}


/***/ }),

/***/ 75574:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   id: () => (/* binding */ id)
/* harmony export */ });
/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(76950);
/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60468);


function id(text) {
    return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_0__/* .keccak256 */ .w)((0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__/* .toUtf8Bytes */ .Y0)(text));
}


/***/ }),

/***/ 14622:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  wn: () => (/* binding */ keccak256),
  P2: () => (/* binding */ pack)
});

// UNUSED EXPORTS: sha256

// EXTERNAL MODULE: ./node_modules/.pnpm/@ethersproject+bignumber@5.7.0/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js + 1 modules
var bignumber = __webpack_require__(79771);
// EXTERNAL MODULE: ./node_modules/.pnpm/@ethersproject+bytes@5.7.0/node_modules/@ethersproject/bytes/lib.esm/index.js
var lib_esm = __webpack_require__(87737);
// EXTERNAL MODULE: ./node_modules/.pnpm/@ethersproject+keccak256@5.7.0/node_modules/@ethersproject/keccak256/lib.esm/index.js
var keccak256_lib_esm = __webpack_require__(76950);
// EXTERNAL MODULE: ./node_modules/.pnpm/@ethersproject+strings@5.7.0/node_modules/@ethersproject/strings/lib.esm/utf8.js + 1 modules
var utf8 = __webpack_require__(60468);
// EXTERNAL MODULE: ./node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js + 1 modules
var logger_lib_esm = __webpack_require__(43288);
;// CONCATENATED MODULE: ./node_modules/.pnpm/@ethersproject+solidity@5.7.0/node_modules/@ethersproject/solidity/lib.esm/_version.js
const version = "solidity/5.7.0";

;// CONCATENATED MODULE: ./node_modules/.pnpm/@ethersproject+solidity@5.7.0/node_modules/@ethersproject/solidity/lib.esm/index.js






const regexBytes = new RegExp("^bytes([0-9]+)$");
const regexNumber = new RegExp("^(u?int)([0-9]*)$");
const regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
const Zeros = "0000000000000000000000000000000000000000000000000000000000000000";


const logger = new logger_lib_esm/* Logger */.Yd(version);
function _pack(type, value, isArray) {
    switch (type) {
        case "address":
            if (isArray) {
                return (0,lib_esm/* zeroPad */.Bu)(value, 32);
            }
            return (0,lib_esm/* arrayify */.lE)(value);
        case "string":
            return (0,utf8/* toUtf8Bytes */.Y0)(value);
        case "bytes":
            return (0,lib_esm/* arrayify */.lE)(value);
        case "bool":
            value = (value ? "0x01" : "0x00");
            if (isArray) {
                return (0,lib_esm/* zeroPad */.Bu)(value, 32);
            }
            return (0,lib_esm/* arrayify */.lE)(value);
    }
    let match = type.match(regexNumber);
    if (match) {
        //let signed = (match[1] === "int")
        let size = parseInt(match[2] || "256");
        if ((match[2] && String(size) !== match[2]) || (size % 8 !== 0) || size === 0 || size > 256) {
            logger.throwArgumentError("invalid number type", "type", type);
        }
        if (isArray) {
            size = 256;
        }
        value = bignumber/* BigNumber */.O$.from(value).toTwos(size);
        return (0,lib_esm/* zeroPad */.Bu)(value, size / 8);
    }
    match = type.match(regexBytes);
    if (match) {
        const size = parseInt(match[1]);
        if (String(size) !== match[1] || size === 0 || size > 32) {
            logger.throwArgumentError("invalid bytes type", "type", type);
        }
        if ((0,lib_esm/* arrayify */.lE)(value).byteLength !== size) {
            logger.throwArgumentError(`invalid value for ${type}`, "value", value);
        }
        if (isArray) {
            return (0,lib_esm/* arrayify */.lE)((value + Zeros).substring(0, 66));
        }
        return value;
    }
    match = type.match(regexArray);
    if (match && Array.isArray(value)) {
        const baseType = match[1];
        const count = parseInt(match[2] || String(value.length));
        if (count != value.length) {
            logger.throwArgumentError(`invalid array length for ${type}`, "value", value);
        }
        const result = [];
        value.forEach(function (value) {
            result.push(_pack(baseType, value, true));
        });
        return (0,lib_esm/* concat */.zo)(result);
    }
    return logger.throwArgumentError("invalid type", "type", type);
}
// @TODO: Array Enum
function pack(types, values) {
    if (types.length != values.length) {
        logger.throwArgumentError("wrong number of values; expected ${ types.length }", "values", values);
    }
    const tight = [];
    types.forEach(function (type, index) {
        tight.push(_pack(type, values[index]));
    });
    return (0,lib_esm/* hexlify */.Dv)((0,lib_esm/* concat */.zo)(tight));
}
function keccak256(types, values) {
    return (0,keccak256_lib_esm/* keccak256 */.w)(pack(types, values));
}
function sha256(types, values) {
    return hashSha256(pack(types, values));
}


/***/ }),

/***/ 24316:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var isProduction = "production" === 'production';
var prefix = 'Invariant failed';
function invariant(condition, message) {
    if (condition) {
        return;
    }
    if (isProduction) {
        throw new Error(prefix);
    }
    throw new Error(prefix + ": " + (message || ''));
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (invariant);


/***/ }),

/***/ 35950:
/***/ ((module) => {

/*
 *  toFormat v2.0.0
 *  Adds a toFormat instance method to big.js or decimal.js
 *  Copyright (c) 2017 Michael Mclaughlin
 *  MIT Licence
 */

 /*
 * Adds a `toFormat` method to `Ctor.prototype` and a `format` object to `Ctor`, where `Ctor` is
 * a big number constructor such as `Decimal` (decimal.js) or `Big` (big.js).
 */
function toFormat(Ctor) {
  'use strict';

  /*
   *  Returns a string representing the value of this big number in fixed-point notation to `dp`
   *  decimal places using rounding mode `rm`, and formatted according to the properties of the
   * `fmt`, `this.format` and `this.constructor.format` objects, in that order of precedence.
   *
   *  Example:
   *
   *  x = new Decimal('123456789.987654321')
   *
   *  // Add a format object to the constructor...
   *  Decimal.format = {
   *    decimalSeparator: '.',
   *    groupSeparator: ',',
   *    groupSize: 3,
   *    secondaryGroupSize: 0,
   *    fractionGroupSeparator: '',     // '\xA0' non-breaking space
   *    fractionGroupSize : 0
   *  }
   *
   *  x.toFormat();                // 123,456,789.987654321
   *  x.toFormat(2, 1);            // 123,456,789.98
   *
   *  // And/or add a format object to the big number itself...
   *  x.format = {
   *    decimalSeparator: ',',
   *    groupSeparator: '',
   *  }
   *
   *  x.toFormat();                // 123456789,987654321
   *
   *  format = {
   *    decimalSeparator: '.',
   *    groupSeparator: ' ',
   *    groupSize: 3,
   *    fractionGroupSeparator: ' ',     // '\xA0' non-breaking space
   *    fractionGroupSize : 5
   *  }

   *  // And/or pass a format object to the method call.
   *  x.toFormat(format);          // 123 456 789.98765 4321
   *  x.toFormat(4, format);       // 123 456 789.9877
   *  x.toFormat(2, 1, format);    // 123 456 789.98
   *
   *  [dp] {number} Decimal places. Integer.
   *  [rm] {number} Rounding mode. Integer, 0 to 8. (Ignored if using big.js.)
   *  [fmt] {Object} A format object.
   *
   */
  Ctor.prototype.toFormat = function toFormat(dp, rm, fmt) {

    if (!this.e && this.e !== 0) return this.toString();   // Infinity/NaN

    var arr, g1, g2, i,
      u,                             // undefined
      nd,                            // number of integer digits
      intd,                          // integer digits
      intp,                          // integer part
      fracp,                         // fraction part
      dsep,                          // decimalSeparator
      gsep,                          // groupSeparator
      gsize,                         // groupSize
      sgsize,                        // secondaryGroupSize
      fgsep,                         // fractionGroupSeparator
      fgsize,                        // fractionGroupSize
      tfmt = this.format || {},
      cfmt = this.constructor.format || {};

    if (dp != u) {
      if (typeof dp == 'object') {
        fmt = dp;
        dp = u;
      } else if (rm != u) {
        if (typeof rm == 'object') {
          fmt = rm;
          rm = u;
        } else if (typeof fmt != 'object') {
          fmt = {};
        }
      } else {
        fmt = {};
      }
    } else {
      fmt = {};
    }

    arr = this.toFixed(dp, rm).split('.');
    intp = arr[0];
    fracp = arr[1];
    intd = this.s < 0 ? intp.slice(1) : intp;
    nd = intd.length;

    dsep = fmt.decimalSeparator;
    if (dsep == u) {
      dsep = tfmt.decimalSeparator;
      if (dsep == u) {
        dsep = cfmt.decimalSeparator;
        if (dsep == u) dsep = '.';
      }
    }

    gsep = fmt.groupSeparator;
    if (gsep == u) {
      gsep = tfmt.groupSeparator;
      if (gsep == u) gsep = cfmt.groupSeparator;
    }

    if (gsep) {
      gsize = fmt.groupSize;
      if (gsize == u) {
        gsize = tfmt.groupSize;
        if (gsize == u) {
          gsize = cfmt.groupSize;
          if (gsize == u) gsize = 0;
        }
      }

      sgsize = fmt.secondaryGroupSize;
      if (sgsize == u) {
        sgsize = tfmt.secondaryGroupSize;
        if (sgsize == u) {
          sgsize = cfmt.secondaryGroupSize;
          if (sgsize == u) sgsize = 0;
        }
      }

      if (sgsize) {
        g1 = +sgsize;
        g2 = +gsize;
        nd -= g2;
      } else {
        g1 = +gsize;
        g2 = +sgsize;
      }

      if (g1 > 0 && nd > 0) {
        i = nd % g1 || g1;
        intp = intd.substr(0, i);
        for (; i < nd; i += g1) intp += gsep + intd.substr(i, g1);
        if (g2 > 0) intp += gsep + intd.slice(i);
        if (this.s < 0) intp = '-' + intp;
      }
    }

    if (fracp) {
      fgsep = fmt.fractionGroupSeparator;
      if (fgsep == u) {
        fgsep = tfmt.fractionGroupSeparator;
        if (fgsep == u) fgsep = cfmt.fractionGroupSeparator;
      }

      if (fgsep) {
        fgsize = fmt.fractionGroupSize;
        if (fgsize == u) {
          fgsize = tfmt.fractionGroupSize;
          if (fgsize == u) {
            fgsize = cfmt.fractionGroupSize;
            if (fgsize == u) fgsize = 0;
          }
        }

        fgsize = +fgsize;

        if (fgsize) {
          fracp = fracp.replace(new RegExp('\\d{' + fgsize + '}\\B', 'g'), '$&' + fgsep);
        }
      }

      return intp + dsep + fracp;
    } else {

      return intp;
    }
  };

  Ctor.format = {
    decimalSeparator: '.',
    groupSeparator: ',',
    groupSize: 3,
    secondaryGroupSize: 0,
    fractionGroupSeparator: '',
    fractionGroupSize: 0
  };

  return Ctor;
}

if ( true && module.exports) module.exports = toFormat;


/***/ })

}]);
//# sourceMappingURL=chunk.2105.js.map