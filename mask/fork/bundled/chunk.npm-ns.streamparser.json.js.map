{"version":3,"file":"bundled/chunk.npm-ns.streamparser.json.js","mappings":";;;;;;;;;;AAAO,IAAI,aAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAE,aAAO,KAAK,aAAO,KAAK;AACpB,MAAM,sBAAgB;AAC7B,KAAK,aAAO,kBAAkB,aAAO;AACrC,KAAK,aAAO,mBAAmB,aAAO;AACtC,KAAK,aAAO,WAAW,aAAO;AAC9B,KAAK,aAAO,wBAAwB,aAAO;AAC3C,KAAK,aAAO,wBAAwB,aAAO;AAC3C,KAAK,aAAO,wBAAwB,aAAO;AAC3C,KAAK,aAAO,wBAAwB,aAAO;AAC3C,KAAK,aAAO,wBAAwB,aAAO;AAC3C;;;AChHA,IAAI,mBAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAE,mBAAS,KAAK,mBAAS,KAAK;AACxB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAe,mEAAS,IAAC;;;AC/BoC;AACkB;AAC5B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,6BAA6B,qDAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACe,MAAM,mBAAS;AAC9B;AACA;AACA;AACA,kCAAkC;AAClC,oCAAoC;AACpC,oDAAoD;AACpD;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,uBAAuB,iBAAiB,EAAE,aAAa,mCAAmC;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG,mCAAmC;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvlBO,IAAI,4BAAe;AAC1B;AACA;AACA;AACA,CAAC,EAAE,4BAAe,KAAK,4BAAe,KAAK;;;ACJQ;AACc;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA,MAAM,uBAAW;AACjB;AACA;AACA;AACA;AACO,+BAA+B,qDAAK;AAC3C;AACA;AACA;AACA;AACA;AACA;AACe,MAAM,uBAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,EAAE,uBAAW;AAC1D;AACA;AACA;AACA;AACA;AACA,oEAAoE,KAAK;AACzE;AACA;AACA,oEAAoE,KAAK;AACzE;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,kBAAkB,GAAG,sBAAsB,aAAa,qCAAqC;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,qCAAqC;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC1Q2C;AACI;AAChC;AACf,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC1CuC;;;ACAiB;AACe;AACM;AACpC;AACe;AACY;AACI;AACP;AACC","sources":["webpack://mask-network/./node_modules/.pnpm/@streamparser+json@0.0.15/node_modules/@streamparser/json/dist/mjs/utils/utf-8.js","webpack://mask-network/./node_modules/.pnpm/@streamparser+json@0.0.15/node_modules/@streamparser/json/dist/mjs/utils/types/tokenType.js","webpack://mask-network/./node_modules/.pnpm/@streamparser+json@0.0.15/node_modules/@streamparser/json/dist/mjs/tokenizer.js","webpack://mask-network/./node_modules/.pnpm/@streamparser+json@0.0.15/node_modules/@streamparser/json/dist/mjs/utils/types/stackElement.js","webpack://mask-network/./node_modules/.pnpm/@streamparser+json@0.0.15/node_modules/@streamparser/json/dist/mjs/tokenparser.js","webpack://mask-network/./node_modules/.pnpm/@streamparser+json@0.0.15/node_modules/@streamparser/json/dist/mjs/jsonparser.js","webpack://mask-network/./node_modules/.pnpm/@streamparser+json@0.0.15/node_modules/@streamparser/json/dist/mjs/utils/types/parsedTokenInfo.js","webpack://mask-network/./node_modules/.pnpm/@streamparser+json@0.0.15/node_modules/@streamparser/json/dist/mjs/index.js"],"sourcesContent":["export var charset;\n(function (charset) {\n    charset[charset[\"BACKSPACE\"] = 8] = \"BACKSPACE\";\n    charset[charset[\"FORM_FEED\"] = 12] = \"FORM_FEED\";\n    charset[charset[\"NEWLINE\"] = 10] = \"NEWLINE\";\n    charset[charset[\"CARRIAGE_RETURN\"] = 13] = \"CARRIAGE_RETURN\";\n    charset[charset[\"TAB\"] = 9] = \"TAB\";\n    charset[charset[\"SPACE\"] = 32] = \"SPACE\";\n    charset[charset[\"EXCLAMATION_MARK\"] = 33] = \"EXCLAMATION_MARK\";\n    charset[charset[\"QUOTATION_MARK\"] = 34] = \"QUOTATION_MARK\";\n    charset[charset[\"NUMBER_SIGN\"] = 35] = \"NUMBER_SIGN\";\n    charset[charset[\"DOLLAR_SIGN\"] = 36] = \"DOLLAR_SIGN\";\n    charset[charset[\"PERCENT_SIGN\"] = 37] = \"PERCENT_SIGN\";\n    charset[charset[\"AMPERSAND\"] = 38] = \"AMPERSAND\";\n    charset[charset[\"APOSTROPHE\"] = 39] = \"APOSTROPHE\";\n    charset[charset[\"LEFT_PARENTHESIS\"] = 40] = \"LEFT_PARENTHESIS\";\n    charset[charset[\"RIGHT_PARENTHESIS\"] = 41] = \"RIGHT_PARENTHESIS\";\n    charset[charset[\"ASTERISK\"] = 42] = \"ASTERISK\";\n    charset[charset[\"PLUS_SIGN\"] = 43] = \"PLUS_SIGN\";\n    charset[charset[\"COMMA\"] = 44] = \"COMMA\";\n    charset[charset[\"HYPHEN_MINUS\"] = 45] = \"HYPHEN_MINUS\";\n    charset[charset[\"FULL_STOP\"] = 46] = \"FULL_STOP\";\n    charset[charset[\"SOLIDUS\"] = 47] = \"SOLIDUS\";\n    charset[charset[\"DIGIT_ZERO\"] = 48] = \"DIGIT_ZERO\";\n    charset[charset[\"DIGIT_ONE\"] = 49] = \"DIGIT_ONE\";\n    charset[charset[\"DIGIT_TWO\"] = 50] = \"DIGIT_TWO\";\n    charset[charset[\"DIGIT_THREE\"] = 51] = \"DIGIT_THREE\";\n    charset[charset[\"DIGIT_FOUR\"] = 52] = \"DIGIT_FOUR\";\n    charset[charset[\"DIGIT_FIVE\"] = 53] = \"DIGIT_FIVE\";\n    charset[charset[\"DIGIT_SIX\"] = 54] = \"DIGIT_SIX\";\n    charset[charset[\"DIGIT_SEVEN\"] = 55] = \"DIGIT_SEVEN\";\n    charset[charset[\"DIGIT_EIGHT\"] = 56] = \"DIGIT_EIGHT\";\n    charset[charset[\"DIGIT_NINE\"] = 57] = \"DIGIT_NINE\";\n    charset[charset[\"COLON\"] = 58] = \"COLON\";\n    charset[charset[\"SEMICOLON\"] = 59] = \"SEMICOLON\";\n    charset[charset[\"LESS_THAN_SIGN\"] = 60] = \"LESS_THAN_SIGN\";\n    charset[charset[\"EQUALS_SIGN\"] = 61] = \"EQUALS_SIGN\";\n    charset[charset[\"GREATER_THAN_SIGN\"] = 62] = \"GREATER_THAN_SIGN\";\n    charset[charset[\"QUESTION_MARK\"] = 63] = \"QUESTION_MARK\";\n    charset[charset[\"COMMERCIAL_AT\"] = 64] = \"COMMERCIAL_AT\";\n    charset[charset[\"LATIN_CAPITAL_LETTER_A\"] = 65] = \"LATIN_CAPITAL_LETTER_A\";\n    charset[charset[\"LATIN_CAPITAL_LETTER_B\"] = 66] = \"LATIN_CAPITAL_LETTER_B\";\n    charset[charset[\"LATIN_CAPITAL_LETTER_C\"] = 67] = \"LATIN_CAPITAL_LETTER_C\";\n    charset[charset[\"LATIN_CAPITAL_LETTER_D\"] = 68] = \"LATIN_CAPITAL_LETTER_D\";\n    charset[charset[\"LATIN_CAPITAL_LETTER_E\"] = 69] = \"LATIN_CAPITAL_LETTER_E\";\n    charset[charset[\"LATIN_CAPITAL_LETTER_F\"] = 70] = \"LATIN_CAPITAL_LETTER_F\";\n    charset[charset[\"LATIN_CAPITAL_LETTER_G\"] = 71] = \"LATIN_CAPITAL_LETTER_G\";\n    charset[charset[\"LATIN_CAPITAL_LETTER_H\"] = 72] = \"LATIN_CAPITAL_LETTER_H\";\n    charset[charset[\"LATIN_CAPITAL_LETTER_I\"] = 73] = \"LATIN_CAPITAL_LETTER_I\";\n    charset[charset[\"LATIN_CAPITAL_LETTER_J\"] = 74] = \"LATIN_CAPITAL_LETTER_J\";\n    charset[charset[\"LATIN_CAPITAL_LETTER_K\"] = 75] = \"LATIN_CAPITAL_LETTER_K\";\n    charset[charset[\"LATIN_CAPITAL_LETTER_L\"] = 76] = \"LATIN_CAPITAL_LETTER_L\";\n    charset[charset[\"LATIN_CAPITAL_LETTER_M\"] = 77] = \"LATIN_CAPITAL_LETTER_M\";\n    charset[charset[\"LATIN_CAPITAL_LETTER_N\"] = 78] = \"LATIN_CAPITAL_LETTER_N\";\n    charset[charset[\"LATIN_CAPITAL_LETTER_O\"] = 79] = \"LATIN_CAPITAL_LETTER_O\";\n    charset[charset[\"LATIN_CAPITAL_LETTER_P\"] = 80] = \"LATIN_CAPITAL_LETTER_P\";\n    charset[charset[\"LATIN_CAPITAL_LETTER_Q\"] = 81] = \"LATIN_CAPITAL_LETTER_Q\";\n    charset[charset[\"LATIN_CAPITAL_LETTER_R\"] = 82] = \"LATIN_CAPITAL_LETTER_R\";\n    charset[charset[\"LATIN_CAPITAL_LETTER_S\"] = 83] = \"LATIN_CAPITAL_LETTER_S\";\n    charset[charset[\"LATIN_CAPITAL_LETTER_T\"] = 84] = \"LATIN_CAPITAL_LETTER_T\";\n    charset[charset[\"LATIN_CAPITAL_LETTER_U\"] = 85] = \"LATIN_CAPITAL_LETTER_U\";\n    charset[charset[\"LATIN_CAPITAL_LETTER_V\"] = 86] = \"LATIN_CAPITAL_LETTER_V\";\n    charset[charset[\"LATIN_CAPITAL_LETTER_W\"] = 87] = \"LATIN_CAPITAL_LETTER_W\";\n    charset[charset[\"LATIN_CAPITAL_LETTER_X\"] = 88] = \"LATIN_CAPITAL_LETTER_X\";\n    charset[charset[\"LATIN_CAPITAL_LETTER_Y\"] = 89] = \"LATIN_CAPITAL_LETTER_Y\";\n    charset[charset[\"LATIN_CAPITAL_LETTER_Z\"] = 90] = \"LATIN_CAPITAL_LETTER_Z\";\n    charset[charset[\"LEFT_SQUARE_BRACKET\"] = 91] = \"LEFT_SQUARE_BRACKET\";\n    charset[charset[\"REVERSE_SOLIDUS\"] = 92] = \"REVERSE_SOLIDUS\";\n    charset[charset[\"RIGHT_SQUARE_BRACKET\"] = 93] = \"RIGHT_SQUARE_BRACKET\";\n    charset[charset[\"CIRCUMFLEX_ACCENT\"] = 94] = \"CIRCUMFLEX_ACCENT\";\n    charset[charset[\"LOW_LINE\"] = 95] = \"LOW_LINE\";\n    charset[charset[\"GRAVE_ACCENT\"] = 96] = \"GRAVE_ACCENT\";\n    charset[charset[\"LATIN_SMALL_LETTER_A\"] = 97] = \"LATIN_SMALL_LETTER_A\";\n    charset[charset[\"LATIN_SMALL_LETTER_B\"] = 98] = \"LATIN_SMALL_LETTER_B\";\n    charset[charset[\"LATIN_SMALL_LETTER_C\"] = 99] = \"LATIN_SMALL_LETTER_C\";\n    charset[charset[\"LATIN_SMALL_LETTER_D\"] = 100] = \"LATIN_SMALL_LETTER_D\";\n    charset[charset[\"LATIN_SMALL_LETTER_E\"] = 101] = \"LATIN_SMALL_LETTER_E\";\n    charset[charset[\"LATIN_SMALL_LETTER_F\"] = 102] = \"LATIN_SMALL_LETTER_F\";\n    charset[charset[\"LATIN_SMALL_LETTER_G\"] = 103] = \"LATIN_SMALL_LETTER_G\";\n    charset[charset[\"LATIN_SMALL_LETTER_H\"] = 104] = \"LATIN_SMALL_LETTER_H\";\n    charset[charset[\"LATIN_SMALL_LETTER_I\"] = 105] = \"LATIN_SMALL_LETTER_I\";\n    charset[charset[\"LATIN_SMALL_LETTER_J\"] = 106] = \"LATIN_SMALL_LETTER_J\";\n    charset[charset[\"LATIN_SMALL_LETTER_K\"] = 107] = \"LATIN_SMALL_LETTER_K\";\n    charset[charset[\"LATIN_SMALL_LETTER_L\"] = 108] = \"LATIN_SMALL_LETTER_L\";\n    charset[charset[\"LATIN_SMALL_LETTER_M\"] = 109] = \"LATIN_SMALL_LETTER_M\";\n    charset[charset[\"LATIN_SMALL_LETTER_N\"] = 110] = \"LATIN_SMALL_LETTER_N\";\n    charset[charset[\"LATIN_SMALL_LETTER_O\"] = 111] = \"LATIN_SMALL_LETTER_O\";\n    charset[charset[\"LATIN_SMALL_LETTER_P\"] = 112] = \"LATIN_SMALL_LETTER_P\";\n    charset[charset[\"LATIN_SMALL_LETTER_Q\"] = 113] = \"LATIN_SMALL_LETTER_Q\";\n    charset[charset[\"LATIN_SMALL_LETTER_R\"] = 114] = \"LATIN_SMALL_LETTER_R\";\n    charset[charset[\"LATIN_SMALL_LETTER_S\"] = 115] = \"LATIN_SMALL_LETTER_S\";\n    charset[charset[\"LATIN_SMALL_LETTER_T\"] = 116] = \"LATIN_SMALL_LETTER_T\";\n    charset[charset[\"LATIN_SMALL_LETTER_U\"] = 117] = \"LATIN_SMALL_LETTER_U\";\n    charset[charset[\"LATIN_SMALL_LETTER_V\"] = 118] = \"LATIN_SMALL_LETTER_V\";\n    charset[charset[\"LATIN_SMALL_LETTER_W\"] = 119] = \"LATIN_SMALL_LETTER_W\";\n    charset[charset[\"LATIN_SMALL_LETTER_X\"] = 120] = \"LATIN_SMALL_LETTER_X\";\n    charset[charset[\"LATIN_SMALL_LETTER_Y\"] = 121] = \"LATIN_SMALL_LETTER_Y\";\n    charset[charset[\"LATIN_SMALL_LETTER_Z\"] = 122] = \"LATIN_SMALL_LETTER_Z\";\n    charset[charset[\"LEFT_CURLY_BRACKET\"] = 123] = \"LEFT_CURLY_BRACKET\";\n    charset[charset[\"VERTICAL_LINE\"] = 124] = \"VERTICAL_LINE\";\n    charset[charset[\"RIGHT_CURLY_BRACKET\"] = 125] = \"RIGHT_CURLY_BRACKET\";\n    charset[charset[\"TILDE\"] = 126] = \"TILDE\";\n})(charset || (charset = {}));\nexport const escapedSequences = {\n    [charset.QUOTATION_MARK]: charset.QUOTATION_MARK,\n    [charset.REVERSE_SOLIDUS]: charset.REVERSE_SOLIDUS,\n    [charset.SOLIDUS]: charset.SOLIDUS,\n    [charset.LATIN_SMALL_LETTER_B]: charset.BACKSPACE,\n    [charset.LATIN_SMALL_LETTER_F]: charset.FORM_FEED,\n    [charset.LATIN_SMALL_LETTER_N]: charset.NEWLINE,\n    [charset.LATIN_SMALL_LETTER_R]: charset.CARRIAGE_RETURN,\n    [charset.LATIN_SMALL_LETTER_T]: charset.TAB,\n};\n","var TokenType;\n(function (TokenType) {\n    TokenType[TokenType[\"LEFT_BRACE\"] = 0] = \"LEFT_BRACE\";\n    TokenType[TokenType[\"RIGHT_BRACE\"] = 1] = \"RIGHT_BRACE\";\n    TokenType[TokenType[\"LEFT_BRACKET\"] = 2] = \"LEFT_BRACKET\";\n    TokenType[TokenType[\"RIGHT_BRACKET\"] = 3] = \"RIGHT_BRACKET\";\n    TokenType[TokenType[\"COLON\"] = 4] = \"COLON\";\n    TokenType[TokenType[\"COMMA\"] = 5] = \"COMMA\";\n    TokenType[TokenType[\"TRUE\"] = 6] = \"TRUE\";\n    TokenType[TokenType[\"FALSE\"] = 7] = \"FALSE\";\n    TokenType[TokenType[\"NULL\"] = 8] = \"NULL\";\n    TokenType[TokenType[\"STRING\"] = 9] = \"STRING\";\n    TokenType[TokenType[\"NUMBER\"] = 10] = \"NUMBER\";\n    TokenType[TokenType[\"SEPARATOR\"] = 11] = \"SEPARATOR\";\n})(TokenType || (TokenType = {}));\nexport function TokenTypeToString(tokenType) {\n    return [\n        \"LEFT_BRACE\",\n        \"RIGHT_BRACE\",\n        \"LEFT_BRACKET\",\n        \"RIGHT_BRACKET\",\n        \"COLON\",\n        \"COMMA\",\n        \"TRUE\",\n        \"FALSE\",\n        \"NULL\",\n        \"STRING\",\n        \"NUMBER\",\n        \"SEPARATOR\",\n    ][tokenType];\n}\nexport default TokenType;\n","import { charset, escapedSequences } from \"./utils/utf-8.js\";\nimport { NonBufferedString, BufferedString, } from \"./utils/bufferedString.js\";\nimport TokenType from \"./utils/types/tokenType.js\";\n// Tokenizer States\nvar TokenizerStates;\n(function (TokenizerStates) {\n    TokenizerStates[TokenizerStates[\"START\"] = 0] = \"START\";\n    TokenizerStates[TokenizerStates[\"ENDED\"] = 1] = \"ENDED\";\n    TokenizerStates[TokenizerStates[\"ERROR\"] = 2] = \"ERROR\";\n    TokenizerStates[TokenizerStates[\"TRUE1\"] = 3] = \"TRUE1\";\n    TokenizerStates[TokenizerStates[\"TRUE2\"] = 4] = \"TRUE2\";\n    TokenizerStates[TokenizerStates[\"TRUE3\"] = 5] = \"TRUE3\";\n    TokenizerStates[TokenizerStates[\"FALSE1\"] = 6] = \"FALSE1\";\n    TokenizerStates[TokenizerStates[\"FALSE2\"] = 7] = \"FALSE2\";\n    TokenizerStates[TokenizerStates[\"FALSE3\"] = 8] = \"FALSE3\";\n    TokenizerStates[TokenizerStates[\"FALSE4\"] = 9] = \"FALSE4\";\n    TokenizerStates[TokenizerStates[\"NULL1\"] = 10] = \"NULL1\";\n    TokenizerStates[TokenizerStates[\"NULL2\"] = 11] = \"NULL2\";\n    TokenizerStates[TokenizerStates[\"NULL3\"] = 12] = \"NULL3\";\n    TokenizerStates[TokenizerStates[\"STRING_DEFAULT\"] = 13] = \"STRING_DEFAULT\";\n    TokenizerStates[TokenizerStates[\"STRING_AFTER_BACKSLASH\"] = 14] = \"STRING_AFTER_BACKSLASH\";\n    TokenizerStates[TokenizerStates[\"STRING_UNICODE_DIGIT_1\"] = 15] = \"STRING_UNICODE_DIGIT_1\";\n    TokenizerStates[TokenizerStates[\"STRING_UNICODE_DIGIT_2\"] = 16] = \"STRING_UNICODE_DIGIT_2\";\n    TokenizerStates[TokenizerStates[\"STRING_UNICODE_DIGIT_3\"] = 17] = \"STRING_UNICODE_DIGIT_3\";\n    TokenizerStates[TokenizerStates[\"STRING_UNICODE_DIGIT_4\"] = 18] = \"STRING_UNICODE_DIGIT_4\";\n    TokenizerStates[TokenizerStates[\"STRING_INCOMPLETE_CHAR\"] = 19] = \"STRING_INCOMPLETE_CHAR\";\n    TokenizerStates[TokenizerStates[\"NUMBER_AFTER_INITIAL_MINUS\"] = 20] = \"NUMBER_AFTER_INITIAL_MINUS\";\n    TokenizerStates[TokenizerStates[\"NUMBER_AFTER_INITIAL_ZERO\"] = 21] = \"NUMBER_AFTER_INITIAL_ZERO\";\n    TokenizerStates[TokenizerStates[\"NUMBER_AFTER_INITIAL_NON_ZERO\"] = 22] = \"NUMBER_AFTER_INITIAL_NON_ZERO\";\n    TokenizerStates[TokenizerStates[\"NUMBER_AFTER_FULL_STOP\"] = 23] = \"NUMBER_AFTER_FULL_STOP\";\n    TokenizerStates[TokenizerStates[\"NUMBER_AFTER_DECIMAL\"] = 24] = \"NUMBER_AFTER_DECIMAL\";\n    TokenizerStates[TokenizerStates[\"NUMBER_AFTER_E\"] = 25] = \"NUMBER_AFTER_E\";\n    TokenizerStates[TokenizerStates[\"NUMBER_AFTER_E_AND_SIGN\"] = 26] = \"NUMBER_AFTER_E_AND_SIGN\";\n    TokenizerStates[TokenizerStates[\"NUMBER_AFTER_E_AND_DIGIT\"] = 27] = \"NUMBER_AFTER_E_AND_DIGIT\";\n    TokenizerStates[TokenizerStates[\"SEPARATOR\"] = 28] = \"SEPARATOR\";\n})(TokenizerStates || (TokenizerStates = {}));\nfunction TokenizerStateToString(tokenizerState) {\n    return [\n        \"START\",\n        \"ENDED\",\n        \"ERROR\",\n        \"TRUE1\",\n        \"TRUE2\",\n        \"TRUE3\",\n        \"FALSE1\",\n        \"FALSE2\",\n        \"FALSE3\",\n        \"FALSE4\",\n        \"NULL1\",\n        \"NULL2\",\n        \"NULL3\",\n        \"STRING_DEFAULT\",\n        \"STRING_AFTER_BACKSLASH\",\n        \"STRING_UNICODE_DIGIT_1\",\n        \"STRING_UNICODE_DIGIT_2\",\n        \"STRING_UNICODE_DIGIT_3\",\n        \"STRING_UNICODE_DIGIT_4\",\n        \"STRING_INCOMPLETE_CHAR\",\n        \"NUMBER_AFTER_INITIAL_MINUS\",\n        \"NUMBER_AFTER_INITIAL_ZERO\",\n        \"NUMBER_AFTER_INITIAL_NON_ZERO\",\n        \"NUMBER_AFTER_FULL_STOP\",\n        \"NUMBER_AFTER_DECIMAL\",\n        \"NUMBER_AFTER_E\",\n        \"NUMBER_AFTER_E_AND_SIGN\",\n        \"NUMBER_AFTER_E_AND_DIGIT\",\n        \"SEPARATOR\",\n    ][tokenizerState];\n}\nconst defaultOpts = {\n    stringBufferSize: 0,\n    numberBufferSize: 0,\n    separator: undefined,\n};\nexport class TokenizerError extends Error {\n    constructor(message) {\n        super(message);\n        // Typescript is broken. This is a workaround\n        Object.setPrototypeOf(this, TokenizerError.prototype);\n    }\n}\nexport default class Tokenizer {\n    constructor(opts) {\n        this.state = TokenizerStates.START;\n        this.separatorIndex = 0;\n        this.bytes_remaining = 0; // number of bytes remaining in multi byte utf8 char to read after split boundary\n        this.bytes_in_sequence = 0; // bytes in multi byte utf8 char to read\n        this.char_split_buffer = new Uint8Array(4); // for rebuilding chars split before boundary is reached\n        this.encoder = new TextEncoder();\n        this.offset = -1;\n        opts = Object.assign(Object.assign({}, defaultOpts), opts);\n        this.bufferedString =\n            opts.stringBufferSize && opts.stringBufferSize > 4\n                ? new BufferedString(opts.stringBufferSize)\n                : new NonBufferedString();\n        this.bufferedNumber =\n            opts.numberBufferSize && opts.numberBufferSize > 0\n                ? new BufferedString(opts.numberBufferSize)\n                : new NonBufferedString();\n        this.separator = opts.separator;\n        this.separatorBytes = opts.separator\n            ? this.encoder.encode(opts.separator)\n            : undefined;\n    }\n    get isEnded() {\n        return this.state === TokenizerStates.ENDED;\n    }\n    write(input) {\n        try {\n            let buffer;\n            if (input instanceof Uint8Array) {\n                buffer = input;\n            }\n            else if (typeof input === \"string\") {\n                buffer = this.encoder.encode(input);\n            }\n            else if ((typeof input === \"object\" && \"buffer\" in input) ||\n                Array.isArray(input)) {\n                buffer = Uint8Array.from(input);\n            }\n            else {\n                throw new TypeError(\"Unexpected type. The `write` function only accepts Arrays, TypedArrays and Strings.\");\n            }\n            for (let i = 0; i < buffer.length; i += 1) {\n                const n = buffer[i]; // get current byte from buffer\n                switch (this.state) {\n                    case TokenizerStates.START:\n                        this.offset += 1;\n                        if (this.separatorBytes && n === this.separatorBytes[0]) {\n                            if (this.separatorBytes.length === 1) {\n                                this.state = TokenizerStates.START;\n                                this.onToken({\n                                    token: TokenType.SEPARATOR,\n                                    value: this.separator,\n                                    offset: this.offset + this.separatorBytes.length - 1,\n                                });\n                                continue;\n                            }\n                            this.state = TokenizerStates.SEPARATOR;\n                            continue;\n                        }\n                        if (n === charset.SPACE ||\n                            n === charset.NEWLINE ||\n                            n === charset.CARRIAGE_RETURN ||\n                            n === charset.TAB) {\n                            // whitespace\n                            continue;\n                        }\n                        if (n === charset.LEFT_CURLY_BRACKET) {\n                            this.onToken({\n                                token: TokenType.LEFT_BRACE,\n                                value: \"{\",\n                                offset: this.offset,\n                            });\n                            continue;\n                        }\n                        if (n === charset.RIGHT_CURLY_BRACKET) {\n                            this.onToken({\n                                token: TokenType.RIGHT_BRACE,\n                                value: \"}\",\n                                offset: this.offset,\n                            });\n                            continue;\n                        }\n                        if (n === charset.LEFT_SQUARE_BRACKET) {\n                            this.onToken({\n                                token: TokenType.LEFT_BRACKET,\n                                value: \"[\",\n                                offset: this.offset,\n                            });\n                            continue;\n                        }\n                        if (n === charset.RIGHT_SQUARE_BRACKET) {\n                            this.onToken({\n                                token: TokenType.RIGHT_BRACKET,\n                                value: \"]\",\n                                offset: this.offset,\n                            });\n                            continue;\n                        }\n                        if (n === charset.COLON) {\n                            this.onToken({\n                                token: TokenType.COLON,\n                                value: \":\",\n                                offset: this.offset,\n                            });\n                            continue;\n                        }\n                        if (n === charset.COMMA) {\n                            this.onToken({\n                                token: TokenType.COMMA,\n                                value: \",\",\n                                offset: this.offset,\n                            });\n                            continue;\n                        }\n                        if (n === charset.LATIN_SMALL_LETTER_T) {\n                            this.state = TokenizerStates.TRUE1;\n                            continue;\n                        }\n                        if (n === charset.LATIN_SMALL_LETTER_F) {\n                            this.state = TokenizerStates.FALSE1;\n                            continue;\n                        }\n                        if (n === charset.LATIN_SMALL_LETTER_N) {\n                            this.state = TokenizerStates.NULL1;\n                            continue;\n                        }\n                        if (n === charset.QUOTATION_MARK) {\n                            this.bufferedString.reset();\n                            this.state = TokenizerStates.STRING_DEFAULT;\n                            continue;\n                        }\n                        if (n >= charset.DIGIT_ONE && n <= charset.DIGIT_NINE) {\n                            this.bufferedNumber.reset();\n                            this.bufferedNumber.appendChar(n);\n                            this.state = TokenizerStates.NUMBER_AFTER_INITIAL_NON_ZERO;\n                            continue;\n                        }\n                        if (n === charset.DIGIT_ZERO) {\n                            this.bufferedNumber.reset();\n                            this.bufferedNumber.appendChar(n);\n                            this.state = TokenizerStates.NUMBER_AFTER_INITIAL_ZERO;\n                            continue;\n                        }\n                        if (n === charset.HYPHEN_MINUS) {\n                            this.bufferedNumber.reset();\n                            this.bufferedNumber.appendChar(n);\n                            this.state = TokenizerStates.NUMBER_AFTER_INITIAL_MINUS;\n                            continue;\n                        }\n                        break;\n                    // STRING\n                    case TokenizerStates.STRING_DEFAULT:\n                        if (n === charset.QUOTATION_MARK) {\n                            const string = this.bufferedString.toString();\n                            this.state = TokenizerStates.START;\n                            this.onToken({\n                                token: TokenType.STRING,\n                                value: string,\n                                offset: this.offset,\n                            });\n                            this.offset += this.bufferedString.byteLength + 1;\n                            continue;\n                        }\n                        if (n === charset.REVERSE_SOLIDUS) {\n                            this.state = TokenizerStates.STRING_AFTER_BACKSLASH;\n                            continue;\n                        }\n                        if (n >= 128) {\n                            // Parse multi byte (>=128) chars one at a time\n                            if (n >= 194 && n <= 223) {\n                                this.bytes_in_sequence = 2;\n                            }\n                            else if (n <= 239) {\n                                this.bytes_in_sequence = 3;\n                            }\n                            else {\n                                this.bytes_in_sequence = 4;\n                            }\n                            if (this.bytes_in_sequence <= buffer.length - i) {\n                                // if bytes needed to complete char fall outside buffer length, we have a boundary split\n                                this.bufferedString.appendBuf(buffer, i, i + this.bytes_in_sequence);\n                                i += this.bytes_in_sequence - 1;\n                                continue;\n                            }\n                            this.bytes_remaining = i + this.bytes_in_sequence - buffer.length;\n                            this.char_split_buffer.set(buffer.subarray(i));\n                            i = buffer.length - 1;\n                            this.state = TokenizerStates.STRING_INCOMPLETE_CHAR;\n                            continue;\n                        }\n                        if (n >= charset.SPACE) {\n                            this.bufferedString.appendChar(n);\n                            continue;\n                        }\n                        break;\n                    case TokenizerStates.STRING_INCOMPLETE_CHAR:\n                        // check for carry over of a multi byte char split between data chunks\n                        // & fill temp buffer it with start of this data chunk up to the boundary limit set in the last iteration\n                        this.char_split_buffer.set(buffer.subarray(i, i + this.bytes_remaining), this.bytes_in_sequence - this.bytes_remaining);\n                        this.bufferedString.appendBuf(this.char_split_buffer, 0, this.bytes_in_sequence);\n                        i = this.bytes_remaining - 1;\n                        this.state = TokenizerStates.STRING_DEFAULT;\n                        continue;\n                    case TokenizerStates.STRING_AFTER_BACKSLASH:\n                        const controlChar = escapedSequences[n];\n                        if (controlChar) {\n                            this.bufferedString.appendChar(controlChar);\n                            this.state = TokenizerStates.STRING_DEFAULT;\n                            continue;\n                        }\n                        if (n === charset.LATIN_SMALL_LETTER_U) {\n                            this.unicode = \"\";\n                            this.state = TokenizerStates.STRING_UNICODE_DIGIT_1;\n                            continue;\n                        }\n                        break;\n                    case TokenizerStates.STRING_UNICODE_DIGIT_1:\n                    case TokenizerStates.STRING_UNICODE_DIGIT_2:\n                    case TokenizerStates.STRING_UNICODE_DIGIT_3:\n                        if ((n >= charset.DIGIT_ZERO && n <= charset.DIGIT_NINE) ||\n                            (n >= charset.LATIN_CAPITAL_LETTER_A &&\n                                n <= charset.LATIN_CAPITAL_LETTER_F) ||\n                            (n >= charset.LATIN_SMALL_LETTER_A &&\n                                n <= charset.LATIN_SMALL_LETTER_F)) {\n                            this.unicode += String.fromCharCode(n);\n                            this.state += 1;\n                            continue;\n                        }\n                        break;\n                    case TokenizerStates.STRING_UNICODE_DIGIT_4:\n                        if ((n >= charset.DIGIT_ZERO && n <= charset.DIGIT_NINE) ||\n                            (n >= charset.LATIN_CAPITAL_LETTER_A &&\n                                n <= charset.LATIN_CAPITAL_LETTER_F) ||\n                            (n >= charset.LATIN_SMALL_LETTER_A &&\n                                n <= charset.LATIN_SMALL_LETTER_F)) {\n                            const intVal = parseInt(this.unicode + String.fromCharCode(n), 16);\n                            if (this.highSurrogate === undefined) {\n                                if (intVal >= 0xd800 && intVal <= 0xdbff) {\n                                    //<55296,56319> - highSurrogate\n                                    this.highSurrogate = intVal;\n                                }\n                                else {\n                                    this.bufferedString.appendBuf(this.encoder.encode(String.fromCharCode(intVal)));\n                                }\n                            }\n                            else {\n                                if (intVal >= 0xdc00 && intVal <= 0xdfff) {\n                                    //<56320,57343> - lowSurrogate\n                                    this.bufferedString.appendBuf(this.encoder.encode(String.fromCharCode(this.highSurrogate, intVal)));\n                                }\n                                else {\n                                    this.bufferedString.appendBuf(this.encoder.encode(String.fromCharCode(this.highSurrogate)));\n                                }\n                                this.highSurrogate = undefined;\n                            }\n                            this.state = TokenizerStates.STRING_DEFAULT;\n                            continue;\n                        }\n                        break;\n                    // Number\n                    case TokenizerStates.NUMBER_AFTER_INITIAL_MINUS:\n                        if (n === charset.DIGIT_ZERO) {\n                            this.bufferedNumber.appendChar(n);\n                            this.state = TokenizerStates.NUMBER_AFTER_INITIAL_ZERO;\n                            continue;\n                        }\n                        if (n >= charset.DIGIT_ONE && n <= charset.DIGIT_NINE) {\n                            this.bufferedNumber.appendChar(n);\n                            this.state = TokenizerStates.NUMBER_AFTER_INITIAL_NON_ZERO;\n                            continue;\n                        }\n                        break;\n                    case TokenizerStates.NUMBER_AFTER_INITIAL_ZERO:\n                        if (n === charset.FULL_STOP) {\n                            this.bufferedNumber.appendChar(n);\n                            this.state = TokenizerStates.NUMBER_AFTER_FULL_STOP;\n                            continue;\n                        }\n                        if (n === charset.LATIN_SMALL_LETTER_E ||\n                            n === charset.LATIN_CAPITAL_LETTER_E) {\n                            this.bufferedNumber.appendChar(n);\n                            this.state = TokenizerStates.NUMBER_AFTER_E;\n                            continue;\n                        }\n                        i -= 1;\n                        this.state = TokenizerStates.START;\n                        this.emitNumber();\n                        continue;\n                    case TokenizerStates.NUMBER_AFTER_INITIAL_NON_ZERO:\n                        if (n >= charset.DIGIT_ZERO && n <= charset.DIGIT_NINE) {\n                            this.bufferedNumber.appendChar(n);\n                            continue;\n                        }\n                        if (n === charset.FULL_STOP) {\n                            this.bufferedNumber.appendChar(n);\n                            this.state = TokenizerStates.NUMBER_AFTER_FULL_STOP;\n                            continue;\n                        }\n                        if (n === charset.LATIN_SMALL_LETTER_E ||\n                            n === charset.LATIN_CAPITAL_LETTER_E) {\n                            this.bufferedNumber.appendChar(n);\n                            this.state = TokenizerStates.NUMBER_AFTER_E;\n                            continue;\n                        }\n                        i -= 1;\n                        this.state = TokenizerStates.START;\n                        this.emitNumber();\n                        continue;\n                    case TokenizerStates.NUMBER_AFTER_FULL_STOP:\n                        if (n >= charset.DIGIT_ZERO && n <= charset.DIGIT_NINE) {\n                            this.bufferedNumber.appendChar(n);\n                            this.state = TokenizerStates.NUMBER_AFTER_DECIMAL;\n                            continue;\n                        }\n                        break;\n                    case TokenizerStates.NUMBER_AFTER_DECIMAL:\n                        if (n >= charset.DIGIT_ZERO && n <= charset.DIGIT_NINE) {\n                            this.bufferedNumber.appendChar(n);\n                            continue;\n                        }\n                        if (n === charset.LATIN_SMALL_LETTER_E ||\n                            n === charset.LATIN_CAPITAL_LETTER_E) {\n                            this.bufferedNumber.appendChar(n);\n                            this.state = TokenizerStates.NUMBER_AFTER_E;\n                            continue;\n                        }\n                        i -= 1;\n                        this.state = TokenizerStates.START;\n                        this.emitNumber();\n                        continue;\n                    // @ts-ignore fall through case\n                    case TokenizerStates.NUMBER_AFTER_E:\n                        if (n === charset.PLUS_SIGN || n === charset.HYPHEN_MINUS) {\n                            this.bufferedNumber.appendChar(n);\n                            this.state = TokenizerStates.NUMBER_AFTER_E_AND_SIGN;\n                            continue;\n                        }\n                    // Allow cascading\n                    case TokenizerStates.NUMBER_AFTER_E_AND_SIGN:\n                        if (n >= charset.DIGIT_ZERO && n <= charset.DIGIT_NINE) {\n                            this.bufferedNumber.appendChar(n);\n                            this.state = TokenizerStates.NUMBER_AFTER_E_AND_DIGIT;\n                            continue;\n                        }\n                        break;\n                    case TokenizerStates.NUMBER_AFTER_E_AND_DIGIT:\n                        if (n >= charset.DIGIT_ZERO && n <= charset.DIGIT_NINE) {\n                            this.bufferedNumber.appendChar(n);\n                            continue;\n                        }\n                        i -= 1;\n                        this.state = TokenizerStates.START;\n                        this.emitNumber();\n                        continue;\n                    // TRUE\n                    case TokenizerStates.TRUE1:\n                        if (n === charset.LATIN_SMALL_LETTER_R) {\n                            this.state = TokenizerStates.TRUE2;\n                            continue;\n                        }\n                        break;\n                    case TokenizerStates.TRUE2:\n                        if (n === charset.LATIN_SMALL_LETTER_U) {\n                            this.state = TokenizerStates.TRUE3;\n                            continue;\n                        }\n                        break;\n                    case TokenizerStates.TRUE3:\n                        if (n === charset.LATIN_SMALL_LETTER_E) {\n                            this.state = TokenizerStates.START;\n                            this.onToken({\n                                token: TokenType.TRUE,\n                                value: true,\n                                offset: this.offset,\n                            });\n                            this.offset += 3;\n                            continue;\n                        }\n                        break;\n                    // FALSE\n                    case TokenizerStates.FALSE1:\n                        if (n === charset.LATIN_SMALL_LETTER_A) {\n                            this.state = TokenizerStates.FALSE2;\n                            continue;\n                        }\n                        break;\n                    case TokenizerStates.FALSE2:\n                        if (n === charset.LATIN_SMALL_LETTER_L) {\n                            this.state = TokenizerStates.FALSE3;\n                            continue;\n                        }\n                        break;\n                    case TokenizerStates.FALSE3:\n                        if (n === charset.LATIN_SMALL_LETTER_S) {\n                            this.state = TokenizerStates.FALSE4;\n                            continue;\n                        }\n                        break;\n                    case TokenizerStates.FALSE4:\n                        if (n === charset.LATIN_SMALL_LETTER_E) {\n                            this.state = TokenizerStates.START;\n                            this.onToken({\n                                token: TokenType.FALSE,\n                                value: false,\n                                offset: this.offset,\n                            });\n                            this.offset += 4;\n                            continue;\n                        }\n                        break;\n                    // NULL\n                    case TokenizerStates.NULL1:\n                        if (n === charset.LATIN_SMALL_LETTER_U) {\n                            this.state = TokenizerStates.NULL2;\n                            continue;\n                        }\n                        break;\n                    case TokenizerStates.NULL2:\n                        if (n === charset.LATIN_SMALL_LETTER_L) {\n                            this.state = TokenizerStates.NULL3;\n                            continue;\n                        }\n                        break;\n                    case TokenizerStates.NULL3:\n                        if (n === charset.LATIN_SMALL_LETTER_L) {\n                            this.state = TokenizerStates.START;\n                            this.onToken({\n                                token: TokenType.NULL,\n                                value: null,\n                                offset: this.offset,\n                            });\n                            this.offset += 3;\n                            continue;\n                        }\n                        break;\n                    case TokenizerStates.SEPARATOR:\n                        this.separatorIndex += 1;\n                        if (!this.separatorBytes ||\n                            n !== this.separatorBytes[this.separatorIndex]) {\n                            break;\n                        }\n                        if (this.separatorIndex === this.separatorBytes.length - 1) {\n                            this.state = TokenizerStates.START;\n                            this.onToken({\n                                token: TokenType.SEPARATOR,\n                                value: this.separator,\n                                offset: this.offset + this.separatorIndex,\n                            });\n                            this.separatorIndex = 0;\n                        }\n                        continue;\n                    case TokenizerStates.ENDED:\n                        if (n === charset.SPACE ||\n                            n === charset.NEWLINE ||\n                            n === charset.CARRIAGE_RETURN ||\n                            n === charset.TAB) {\n                            // whitespace\n                            continue;\n                        }\n                }\n                throw new TokenizerError(`Unexpected \"${String.fromCharCode(n)}\" at position \"${i}\" in state ${TokenizerStateToString(this.state)}`);\n            }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (err) {\n            this.error(err);\n        }\n    }\n    emitNumber() {\n        this.onToken({\n            token: TokenType.NUMBER,\n            value: this.parseNumber(this.bufferedNumber.toString()),\n            offset: this.offset,\n        });\n        this.offset += this.bufferedNumber.byteLength - 1;\n    }\n    parseNumber(numberStr) {\n        return Number(numberStr);\n    }\n    error(err) {\n        if (this.state !== TokenizerStates.ENDED) {\n            this.state = TokenizerStates.ERROR;\n        }\n        this.onError(err);\n    }\n    end() {\n        switch (this.state) {\n            case TokenizerStates.NUMBER_AFTER_INITIAL_ZERO:\n            case TokenizerStates.NUMBER_AFTER_INITIAL_NON_ZERO:\n            case TokenizerStates.NUMBER_AFTER_DECIMAL:\n            case TokenizerStates.NUMBER_AFTER_E_AND_DIGIT:\n                this.state = TokenizerStates.ENDED;\n                this.emitNumber();\n                this.onEnd();\n                break;\n            case TokenizerStates.START:\n            case TokenizerStates.ERROR:\n            case TokenizerStates.SEPARATOR:\n                this.state = TokenizerStates.ENDED;\n                this.onEnd();\n                break;\n            default:\n                this.error(new TokenizerError(`Tokenizer ended in the middle of a token (state: ${TokenizerStateToString(this.state)}). Either not all the data was received or the data was invalid.`));\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    onToken(parsedToken) {\n        // Override me\n        throw new TokenizerError('Can\\'t emit tokens before the \"onToken\" callback has been set up.');\n    }\n    onError(err) {\n        // Override me\n        throw err;\n    }\n    onEnd() {\n        // Override me\n    }\n}\n","export var TokenParserMode;\n(function (TokenParserMode) {\n    TokenParserMode[TokenParserMode[\"OBJECT\"] = 0] = \"OBJECT\";\n    TokenParserMode[TokenParserMode[\"ARRAY\"] = 1] = \"ARRAY\";\n})(TokenParserMode || (TokenParserMode = {}));\n","import TokenType from \"./utils/types/tokenType.js\";\nimport { TokenParserMode, } from \"./utils/types/stackElement.js\";\n// Parser States\nvar TokenParserState;\n(function (TokenParserState) {\n    TokenParserState[TokenParserState[\"VALUE\"] = 0] = \"VALUE\";\n    TokenParserState[TokenParserState[\"KEY\"] = 1] = \"KEY\";\n    TokenParserState[TokenParserState[\"COLON\"] = 2] = \"COLON\";\n    TokenParserState[TokenParserState[\"COMMA\"] = 3] = \"COMMA\";\n    TokenParserState[TokenParserState[\"ENDED\"] = 4] = \"ENDED\";\n    TokenParserState[TokenParserState[\"ERROR\"] = 5] = \"ERROR\";\n    TokenParserState[TokenParserState[\"SEPARATOR\"] = 6] = \"SEPARATOR\";\n})(TokenParserState || (TokenParserState = {}));\nfunction TokenParserStateToString(state) {\n    return [\"VALUE\", \"KEY\", \"COLON\", \"COMMA\", \"ENDED\", \"ERROR\", \"SEPARATOR\"][state];\n}\nconst defaultOpts = {\n    paths: undefined,\n    keepStack: true,\n    separator: undefined,\n};\nexport class TokenParserError extends Error {\n    constructor(message) {\n        super(message);\n        // Typescript is broken. This is a workaround\n        Object.setPrototypeOf(this, TokenParserError.prototype);\n    }\n}\nexport default class TokenParser {\n    constructor(opts) {\n        this.state = TokenParserState.VALUE;\n        this.mode = undefined;\n        this.key = undefined;\n        this.value = undefined;\n        this.stack = [];\n        opts = Object.assign(Object.assign({}, defaultOpts), opts);\n        if (opts.paths) {\n            this.paths = opts.paths.map((path) => {\n                if (path === undefined || path === \"$*\")\n                    return undefined;\n                if (!path.startsWith(\"$\"))\n                    throw new TokenParserError(`Invalid selector \"${path}\". Should start with \"$\".`);\n                const pathParts = path.split(\".\").slice(1);\n                if (pathParts.includes(\"\"))\n                    throw new TokenParserError(`Invalid selector \"${path}\". \"..\" syntax not supported.`);\n                return pathParts;\n            });\n        }\n        this.keepStack = opts.keepStack || false;\n        this.separator = opts.separator;\n    }\n    shouldEmit() {\n        if (!this.paths)\n            return true;\n        return this.paths.some((path) => {\n            var _a;\n            if (path === undefined)\n                return true;\n            if (path.length !== this.stack.length)\n                return false;\n            for (let i = 0; i < path.length - 1; i++) {\n                const selector = path[i];\n                const key = this.stack[i + 1].key;\n                if (selector === \"*\")\n                    continue;\n                if (selector !== key)\n                    return false;\n            }\n            const selector = path[path.length - 1];\n            if (selector === \"*\")\n                return true;\n            return selector === ((_a = this.key) === null || _a === void 0 ? void 0 : _a.toString());\n        });\n    }\n    push() {\n        this.stack.push({\n            key: this.key,\n            value: this.value,\n            mode: this.mode,\n            emit: this.shouldEmit(),\n        });\n    }\n    pop() {\n        const value = this.value;\n        let emit;\n        ({\n            key: this.key,\n            value: this.value,\n            mode: this.mode,\n            emit,\n        } = this.stack.pop());\n        this.state =\n            this.mode !== undefined ? TokenParserState.COMMA : TokenParserState.VALUE;\n        this.emit(value, emit);\n    }\n    emit(value, emit) {\n        if (!this.keepStack &&\n            this.value &&\n            this.stack.every((item) => !item.emit)) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            delete this.value[this.key];\n        }\n        if (emit) {\n            this.onValue({\n                value: value,\n                key: this.key,\n                parent: this.value,\n                stack: this.stack,\n            });\n        }\n        if (this.stack.length === 0) {\n            if (this.separator) {\n                this.state = TokenParserState.SEPARATOR;\n            }\n            else if (this.separator === undefined) {\n                this.end();\n            }\n            // else if separator === '', expect next JSON object.\n        }\n    }\n    get isEnded() {\n        return this.state === TokenParserState.ENDED;\n    }\n    write({ token, value }) {\n        try {\n            if (this.state === TokenParserState.VALUE) {\n                if (token === TokenType.STRING ||\n                    token === TokenType.NUMBER ||\n                    token === TokenType.TRUE ||\n                    token === TokenType.FALSE ||\n                    token === TokenType.NULL) {\n                    if (this.mode === TokenParserMode.OBJECT) {\n                        this.value[this.key] = value;\n                        this.state = TokenParserState.COMMA;\n                    }\n                    else if (this.mode === TokenParserMode.ARRAY) {\n                        this.value.push(value);\n                        this.state = TokenParserState.COMMA;\n                    }\n                    this.emit(value, this.shouldEmit());\n                    return;\n                }\n                if (token === TokenType.LEFT_BRACE) {\n                    this.push();\n                    if (this.mode === TokenParserMode.OBJECT) {\n                        this.value = this.value[this.key] = {};\n                    }\n                    else if (this.mode === TokenParserMode.ARRAY) {\n                        const val = {};\n                        this.value.push(val);\n                        this.value = val;\n                    }\n                    else {\n                        this.value = {};\n                    }\n                    this.mode = TokenParserMode.OBJECT;\n                    this.state = TokenParserState.KEY;\n                    this.key = undefined;\n                    return;\n                }\n                if (token === TokenType.LEFT_BRACKET) {\n                    this.push();\n                    if (this.mode === TokenParserMode.OBJECT) {\n                        this.value = this.value[this.key] = [];\n                    }\n                    else if (this.mode === TokenParserMode.ARRAY) {\n                        const val = [];\n                        this.value.push(val);\n                        this.value = val;\n                    }\n                    else {\n                        this.value = [];\n                    }\n                    this.mode = TokenParserMode.ARRAY;\n                    this.state = TokenParserState.VALUE;\n                    this.key = 0;\n                    return;\n                }\n                if (this.mode === TokenParserMode.ARRAY &&\n                    token === TokenType.RIGHT_BRACKET &&\n                    this.value.length === 0) {\n                    this.pop();\n                    return;\n                }\n            }\n            if (this.state === TokenParserState.KEY) {\n                if (token === TokenType.STRING) {\n                    this.key = value;\n                    this.state = TokenParserState.COLON;\n                    return;\n                }\n                if (token === TokenType.RIGHT_BRACE &&\n                    Object.keys(this.value).length === 0) {\n                    this.pop();\n                    return;\n                }\n            }\n            if (this.state === TokenParserState.COLON) {\n                if (token === TokenType.COLON) {\n                    this.state = TokenParserState.VALUE;\n                    return;\n                }\n            }\n            if (this.state === TokenParserState.COMMA) {\n                if (token === TokenType.COMMA) {\n                    if (this.mode === TokenParserMode.ARRAY) {\n                        this.state = TokenParserState.VALUE;\n                        this.key += 1;\n                        return;\n                    }\n                    /* istanbul ignore else */\n                    if (this.mode === TokenParserMode.OBJECT) {\n                        this.state = TokenParserState.KEY;\n                        return;\n                    }\n                }\n                if ((token === TokenType.RIGHT_BRACE &&\n                    this.mode === TokenParserMode.OBJECT) ||\n                    (token === TokenType.RIGHT_BRACKET &&\n                        this.mode === TokenParserMode.ARRAY)) {\n                    this.pop();\n                    return;\n                }\n            }\n            if (this.state === TokenParserState.SEPARATOR) {\n                if (token === TokenType.SEPARATOR && value === this.separator) {\n                    this.state = TokenParserState.VALUE;\n                    return;\n                }\n            }\n            throw new TokenParserError(`Unexpected ${TokenType[token]} (${JSON.stringify(value)}) in state ${TokenParserStateToString(this.state)}`);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (err) {\n            this.error(err);\n        }\n    }\n    error(err) {\n        if (this.state !== TokenParserState.ENDED) {\n            this.state = TokenParserState.ERROR;\n        }\n        this.onError(err);\n    }\n    end() {\n        if ((this.state !== TokenParserState.VALUE &&\n            this.state !== TokenParserState.SEPARATOR) ||\n            this.stack.length > 0) {\n            this.error(new Error(`Parser ended in mid-parsing (state: ${TokenParserStateToString(this.state)}). Either not all the data was received or the data was invalid.`));\n        }\n        else {\n            this.state = TokenParserState.ENDED;\n            this.onEnd();\n        }\n    }\n    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\n    onValue(parsedElementInfo) {\n        // Override me\n        throw new TokenParserError('Can\\'t emit data before the \"onValue\" callback has been set up.');\n    }\n    onError(err) {\n        // Override me\n        throw err;\n    }\n    onEnd() {\n        // Override me\n    }\n}\n","import Tokenizer, {} from \"./tokenizer.js\";\nimport TokenParser, {} from \"./tokenparser.js\";\nexport default class JSONParser {\n    constructor(opts = {}) {\n        this.tokenizer = new Tokenizer(opts);\n        this.tokenParser = new TokenParser(opts);\n        this.tokenizer.onToken = this.tokenParser.write.bind(this.tokenParser);\n        this.tokenizer.onEnd = () => {\n            if (!this.tokenParser.isEnded)\n                this.tokenParser.end();\n        };\n        this.tokenParser.onError = this.tokenizer.error.bind(this.tokenizer);\n        this.tokenParser.onEnd = () => {\n            if (!this.tokenizer.isEnded)\n                this.tokenizer.end();\n        };\n    }\n    get isEnded() {\n        return this.tokenizer.isEnded && this.tokenParser.isEnded;\n    }\n    write(input) {\n        this.tokenizer.write(input);\n    }\n    end() {\n        this.tokenizer.end();\n    }\n    set onToken(cb) {\n        this.tokenizer.onToken = cb;\n    }\n    set onValue(cb) {\n        this.tokenParser.onValue = cb;\n    }\n    set onError(cb) {\n        this.tokenizer.onError = cb;\n    }\n    set onEnd(cb) {\n        this.tokenParser.onEnd = () => {\n            if (!this.tokenizer.isEnded)\n                this.tokenizer.end();\n            cb.call(this.tokenParser);\n        };\n    }\n}\n","import TokenType from \"./tokenType.js\";\n","export { default as JSONParser } from \"./jsonparser.js\";\nexport { default as Tokenizer, TokenizerError, } from \"./tokenizer.js\";\nexport { default as TokenParser, TokenParserError, } from \"./tokenparser.js\";\nexport * as utf8 from \"./utils/utf-8.js\";\nexport * as JsonTypes from \"./utils/types/jsonTypes.js\";\nexport * as ParsedTokenInfo from \"./utils/types/parsedTokenInfo.js\";\nexport * as ParsedElementInfo from \"./utils/types/parsedElementInfo.js\";\nexport { TokenParserMode, } from \"./utils/types/stackElement.js\";\nexport { default as TokenType } from \"./utils/types/tokenType.js\";\n"],"names":[],"sourceRoot":"","x_google_ignoreList":[0,1,2,3,4,5,6,7]}