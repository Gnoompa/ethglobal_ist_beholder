{"version":3,"file":"bundled/npm-ns.dimensiondev.holoflows-kit.js","mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA,SAAS,yCAAyC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,kCAAkC,0BAA0B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,SAAS;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrUyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B;AACrC,sBAAsB,6DAAO;AAC7B;AACA,YAAY,uEAAuE;AACnF;AACA;AACA;AACA,mCAAmC,cAAc;AACjD,oCAAoC,cAAc;AAClD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,2BAA2B,mCAAmC;AACrG;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,kCAAkC,4EAA4E;AAC9G,yBAAyB;AACzB;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA,SAAS;AACT;AACA,2BAA2B,yBAAyB;AACpD;AACA,SAAS;AACT;AACA,2BAA2B,+BAA+B;AAC1D;AACA,SAAS;AACT;AACA,2BAA2B,+CAA+C;AAC1E;AACA,SAAS;AACT;AACA,2BAA2B,0CAA0C;AACrE;AACA,SAAS;AACT;AACA,2BAA2B,uCAAuC;AAClE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,IAAI;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,gBAAgB;AAC3D,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsC;AAC+B;AACS;AACjC;AACc;AAC3D;AACA;AACA;AACO;AACP,aAAa,gFAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6BAA6B,oDAAoD,oCAAoC;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kCAAkC;AAC9D;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,4BAA4B,mCAAmC;AAC/D;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,2BAA2B;AACvF;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,gBAAgB,+CAA+C;AAC/D;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,4BAA4B,kEAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8DAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8DAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8DAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,4DAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8DAAgB;AAC5C,4BAA4B,8DAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+CAA+C,sDAAsD;AACrG;AACA;AACA;AACA,+CAA+C,+BAA+B;AAC9E;AACA;AACA;AACA,4CAA4C,8BAA8B;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA,2CAA2C,8DAAK;AAChD;AACA;AACA;AACA;AACA,2CAA2C,iDAAiD;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,mCAAmC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,4DAAQ;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sFAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,YAAY;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAA4C;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,uBAAuB;AACvB,YAAY,gBAAgB,IAAI,KAAK,uCAAuC;AAC5E;AACA,YAAY,IAAsC;AAClD,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;;AClpBwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACO,8BAA8B,4IAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI,YAAY;AACzB;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChCwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACO,sCAAsC,4IAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qDAAqD;AACnF;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC9EA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,uEAAuE,sBAAsB,aAAa,mBAAmB;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,6EAA6E,sBAAsB,aAAa,mBAAmB;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5NA;AACA;AACyC;AACM;AACY;AACe;AACnE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6DAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAa,CAAC,8DAAW;AACrC;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,sDAAsD,QAAQ;AAC9D;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,gBAAgB;AACrE,gDAAgD,gBAAgB;AAChE;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oEAAa,CAAC,8DAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,wCAAwC;AAClG;AACA,0DAA0D,sCAAsC;AAChG;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qEAAc;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,6BAA6B,YAAY;AACzC,iDAAiD,cAAc,kBAAkB,mBAAmB;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gFAAiB;AACtC;AACA;AACA;AACA;AAC+B;AAC/B;AACA;AACA;AACA,YAAY,wBAAwB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qEAAc;AAC/B;AACA;AACA;AACA;AACA,mBAAmB,8DAAW;AAC9B;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,8DAAW;AACzD,8CAA8C,8DAAW;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,YAAY;AACzE;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,uBAAuB,mEAAa,IAAI,MAAM;AAC9C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,aAAa;AACzC;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,qBAAqB,qEAAc;AACnC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;;AC1X+C;AAC/C;AACO;AACP,wBAAwB,6DAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,iDAAiD,8DAAI;AACrD;AACA,8DAA8D,YAAY;AAC1E;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA","sources":["webpack://mask-network/./node_modules/.pnpm/@dimensiondev+holoflows-kit@0.9.0-20230307045856-46252fb/node_modules/@dimensiondev/holoflows-kit/es/DOM/LiveSelector.js","webpack://mask-network/./node_modules/.pnpm/@dimensiondev+holoflows-kit@0.9.0-20230307045856-46252fb/node_modules/@dimensiondev/holoflows-kit/es/DOM/Proxy.js","webpack://mask-network/./node_modules/.pnpm/@dimensiondev+holoflows-kit@0.9.0-20230307045856-46252fb/node_modules/@dimensiondev/holoflows-kit/es/DOM/Watcher.js","webpack://mask-network/./node_modules/.pnpm/@dimensiondev+holoflows-kit@0.9.0-20230307045856-46252fb/node_modules/@dimensiondev/holoflows-kit/es/DOM/Watchers/IntervalWatcher.js","webpack://mask-network/./node_modules/.pnpm/@dimensiondev+holoflows-kit@0.9.0-20230307045856-46252fb/node_modules/@dimensiondev/holoflows-kit/es/DOM/Watchers/MutationObserverWatcher.js","webpack://mask-network/./node_modules/.pnpm/@dimensiondev+holoflows-kit@0.9.0-20230307045856-46252fb/node_modules/@dimensiondev/holoflows-kit/es/Extension/Context.js","webpack://mask-network/./node_modules/.pnpm/@dimensiondev+holoflows-kit@0.9.0-20230307045856-46252fb/node_modules/@dimensiondev/holoflows-kit/es/Extension/MessageChannel.js","webpack://mask-network/./node_modules/.pnpm/@dimensiondev+holoflows-kit@0.9.0-20230307045856-46252fb/node_modules/@dimensiondev/holoflows-kit/es/util/EventTarget.js","webpack://mask-network/./node_modules/.pnpm/@dimensiondev+holoflows-kit@0.9.0-20230307045856-46252fb/node_modules/@dimensiondev/holoflows-kit/es/util/requestIdleCallback.js","webpack://mask-network/./node_modules/.pnpm/@dimensiondev+holoflows-kit@0.9.0-20230307045856-46252fb/node_modules/@dimensiondev/holoflows-kit/es/util/timeout.js"],"sourcesContent":["/**\n * Create a live selector that can continuously select the element you want.\n *\n * @remarks\n * Call {@link LiveSelector.evaluate | #evaluate} to evaluate the element. Falsy value will be ignored.\n *\n * @param T - Type of Element that LiveSelector contains\n *\n * @example\n * ```ts\n * const ls = new LiveSelector().querySelectorAll('a').map(x => x.href)\n * ls.evaluate() // returns all urls at the current time.\n * ```\n */\nexport class LiveSelector {\n    initialElements;\n    /**\n     * Create a new LiveSelector.\n     *\n     * @param initialElements - provides initial results, equals to `.replace(() => initialElements)`\n     */\n    constructor(initialElements = []) {\n        this.initialElements = initialElements;\n    }\n    /**\n     * Let developer knows where does this LiveSelector created.\n     */\n    stack = new Error().stack;\n    /**\n     * Is this LiveSelector run in the SingleMode\n     */\n    isSingleMode = false;\n    /**\n     * Enable single mode. Only 1 result will be emitted.\n     */\n    enableSingleMode() {\n        this.isSingleMode = true;\n        return this;\n    }\n    /**\n     * Record a method call into {@link LiveSelector.selectorChain}\n     */\n    appendSelectorChain = (type) => (param) => {\n        this.selectorChain.push({ type: type, param: param });\n        return this;\n    };\n    /**\n     * Records of previous calls on LiveSelector\n     */\n    selectorChain = [];\n    /**\n     * Clone this LiveSelector and return a new LiveSelector.\n     * @returns a new LiveSelector with same action\n     * @example\n     * ```ts\n     * ls.clone()\n     * ```\n     */\n    clone() {\n        const ls = new LiveSelector(this.initialElements);\n        ls.selectorChain.push(...this.selectorChain);\n        ls.isSingleMode = this.isSingleMode;\n        return ls;\n    }\n    querySelector(selector) {\n        return this.appendSelectorChain('querySelector')(selector);\n    }\n    querySelectorAll(selector) {\n        return this.appendSelectorChain('querySelectorAll')(selector);\n    }\n    getElementsByClassName(className) {\n        return this.appendSelectorChain('getElementsByClassName')(className);\n    }\n    getElementsByTagName(tag) {\n        return this.appendSelectorChain('getElementsByTagName')(tag);\n    }\n    closest(selectors) {\n        return this.appendSelectorChain('closest')(selectors);\n    }\n    filter(f) {\n        return this.appendSelectorChain('filter')(f);\n    }\n    /**\n     * Calls a defined callback function on each element of a LiveSelector, and continues with the results.\n     *\n     * @param callbackfn - Map function\n     * @example\n     * ```ts\n     * ls.map(x => x.parentElement)\n     * ```\n     */\n    map(callbackfn) {\n        return this.appendSelectorChain('map')(callbackfn);\n    }\n    /**\n     * Combines two LiveSelector.\n     * @param newEle - Additional LiveSelector to combine.\n     * @param NextType - Next type generic for LiveSelector\n     *\n     * @example\n     * ```ts\n     * ls.concat(new LiveSelector().querySelector('#root'))\n     * ```\n     */\n    concat(newEle) {\n        return this.appendSelectorChain('concat')(newEle);\n    }\n    /**\n     * Reverses the elements in an Array.\n     *\n     * @example\n     * ```ts\n     * ls.reverse()\n     * ```\n     */\n    reverse() {\n        return this.appendSelectorChain('reverse')(undefined);\n    }\n    /**\n     * Returns a section of an array.\n     * @param start - The beginning of the specified portion of the array.\n     * @param end - The end of the specified portion of the array.\n     *\n     * @example\n     * ```ts\n     * ls.slice(2, 4)\n     * ```\n     */\n    slice(start, end) {\n        return this.appendSelectorChain('slice')([start, end]);\n    }\n    /**\n     * Sorts an array.\n     * @param compareFn - The name of the function used to determine the order of the elements. If omitted, the elements are sorted in ascending, ASCII character order.\n     *\n     * @example\n     * ```ts\n     * ls.sort((a, b) => a.innerText.length - b.innerText.length)\n     * ```\n     */\n    sort(compareFn) {\n        return this.appendSelectorChain('sort')(compareFn);\n    }\n    /**\n     * Flat T[][] to T[]\n     *\n     * @example\n     * ```ts\n     * ls.flat()\n     * ```\n     */\n    flat() {\n        return this.appendSelectorChain('flat')(undefined);\n    }\n    /**\n     * Select only nth element\n     *\n     * @param n - Select only nth element, allow negative number.\n     * @example\n     * ```ts\n     * ls.at(-1)\n     * ```\n     */\n    at(n) {\n        if (typeof n !== 'number')\n            throw new Error('n must be a number');\n        if (this.isSingleMode)\n            throw new Error('LiveSelector.nth() is not available in SingleMode');\n        return this.appendSelectorChain('at')(n);\n    }\n    /**\n     * Replace the whole array.\n     *\n     * @example\n     * ```ts\n     * ls.replace(x => lodash.dropRight(x, 2))\n     * ```\n     *\n     * @param f - returns new array.\n     */\n    replace(f) {\n        return this.appendSelectorChain('replace')(f);\n    }\n    //#endregion\n    //#region Build\n    /**\n     * Evaluate selector expression\n     */\n    evaluate() {\n        let arr = this.initialElements;\n        function isElementArray(x) {\n            // Do a simple check\n            return x[0] instanceof Element;\n        }\n        function nonNull(x) {\n            return x !== null && x !== undefined;\n        }\n        function unique(x) {\n            return Array.from(new Set(x));\n        }\n        let previouslyNulled = false;\n        for (const op of this.selectorChain) {\n            // if in single mode, drop other results.\n            if (this.isSingleMode && arr.length > 1)\n                arr = [arr[0]];\n            switch (op.type) {\n                case 'querySelector': {\n                    if (!previouslyNulled) {\n                        if (arr.length === 0) {\n                            const e = document.querySelector(op.param);\n                            if (e)\n                                arr = unique(arr.concat(e));\n                            else\n                                previouslyNulled = true;\n                        }\n                        else if (isElementArray(arr)) {\n                            arr = unique(arr.map((e) => e.querySelector(op.param)).filter(nonNull));\n                            if (arr.length === 0)\n                                previouslyNulled = true;\n                        }\n                        else\n                            throw new TypeError('Call querySelector on non-Element item!');\n                    }\n                    break;\n                }\n                case 'getElementsByTagName':\n                case 'getElementsByClassName':\n                case 'querySelectorAll': {\n                    if (!previouslyNulled) {\n                        []; // Fix editor syntax highlight\n                        if (arr.length === 0) {\n                            const e = document[op.type](op.param);\n                            arr = unique(arr.concat(...e));\n                            if (e.length === 0)\n                                previouslyNulled = true;\n                        }\n                        else if (isElementArray(arr)) {\n                            let newArr = [];\n                            for (const e of arr) {\n                                newArr = newArr.concat(Array.from(e[op.type](op.param)));\n                            }\n                            arr = unique(newArr.filter(nonNull));\n                            if (arr.length === 0)\n                                previouslyNulled = true;\n                        }\n                        else\n                            throw new TypeError(`Call ${op.type} on non-Element item!`);\n                    }\n                    break;\n                }\n                case 'closest':\n                    if (arr.length === 0) {\n                        break;\n                    }\n                    else if (isElementArray(arr)) {\n                        const newArr = arr;\n                        const selector = op.param;\n                        function findParent(node, y) {\n                            if (y < 0)\n                                throw new TypeError('Cannot use `.closet` with a negative number');\n                            if (y === 0)\n                                return node;\n                            if (!node.parentElement)\n                                return null;\n                            return findParent(node.parentElement, y - 1);\n                        }\n                        if (typeof selector === 'number') {\n                            arr = unique(newArr.map((e) => findParent(e, selector)).filter(nonNull));\n                        }\n                        else {\n                            arr = unique(newArr.map((x) => x.closest(selector)).filter(nonNull));\n                        }\n                    }\n                    else {\n                        throw new TypeError('Cannot use `.closet on non-Element`');\n                    }\n                    break;\n                case 'filter':\n                    arr = arr.filter((e, i, a) => op.param(e, i, [...a])).filter(nonNull);\n                    break;\n                case 'map':\n                    arr = arr.map((e, i, a) => op.param(e, i, [...a])).filter(nonNull);\n                    break;\n                case 'concat':\n                    arr = arr.concat(op.param.evaluate());\n                    break;\n                case 'reverse':\n                    arr = Array.from(arr).reverse();\n                    break;\n                case 'slice': {\n                    const [start, end] = op.param;\n                    arr = arr.slice(start, end);\n                    break;\n                }\n                case 'sort':\n                    arr = Array.from(arr).sort(op.param);\n                    break;\n                case 'at': {\n                    arr = [at(arr, op.param)].filter(nonNull);\n                    break;\n                }\n                case 'flat':\n                    arr = [].concat(...arr);\n                    break;\n                case 'replace':\n                    arr = op.param(Array.from(arr));\n                    break;\n                default:\n                    throw new TypeError('Unknown operation type');\n            }\n        }\n        if (this.isSingleMode)\n            return arr.filter(nonNull)[0];\n        return arr.filter(nonNull);\n    }\n}\n// https://github.com/tc39/proposal-relative-indexing-method\nfunction at(arr, n) {\n    /* eslint-disable @typescript-eslint/strict-boolean-expressions */\n    n = Math.trunc(n) || 0;\n    if (n < 0)\n        n += arr.length;\n    if (n < 0 || n >= arr.length)\n        return undefined;\n    return arr[n];\n}\n","import { Emitter } from '@servie/events';\n/**\n * DOMProxy provide an interface that be stable even dom is changed.\n *\n * @remarks\n *\n * DOMProxy provide 3 nodes. `before`, `current` and `after`.\n * `current` is a fake dom node powered by Proxy,\n * it will forward all your operations to the `realCurrent`.\n *\n * `before` and `after` is a true `span` that always point to before and after of `realCurrent`\n *\n * Special Handlers:\n *\n * *forward*: forward to current `realCurrent`\n *\n * *undo*: undo effect when `realCurrent` changes\n *\n * *move*: move effect to new `realCurrent`\n *\n * - style (forward, undo, move)\n * - addEventListener (forward, undo, move)\n * - appendChild (forward, undo, move)\n */\nexport function DOMProxy(options = {}) {\n    const event = new Emitter();\n    // Options\n    const { createAfter, createBefore, afterShadowRootInit, beforeShadowRootInit } = {\n        ...{\n            createAfter: () => document.createElement('span'),\n            createBefore: () => document.createElement('span'),\n            afterShadowRootInit: { mode: 'open' },\n            beforeShadowRootInit: { mode: 'open' },\n        },\n        ...options,\n    };\n    //\n    let isDestroyed = false;\n    // Nodes\n    let virtualBefore = null;\n    let virtualBeforeShadow = null;\n    const defaultCurrent = document.createElement('div');\n    let current = defaultCurrent;\n    let virtualAfter = null;\n    let virtualAfterShadow = null;\n    /** All changes applied on the `proxy` */\n    const changes = [];\n    /** Proxy Traps */\n    const proxyTraps = {\n        get: (t, key, r) => {\n            const current_ = current;\n            if (typeof current_[key] === 'function')\n                return new Proxy(current_[key], {\n                    apply: (target, thisArg, args) => {\n                        changes.push({ type: 'callMethods', op: { name: key, param: args, thisArg } });\n                        return current_[key](...args);\n                    },\n                });\n            else if (key === 'style')\n                return new Proxy(current.style, {\n                    set: (t, styleKey, styleValue, r) => {\n                        changes.push({\n                            type: 'modifyStyle',\n                            op: { name: styleKey, value: styleValue, originalValue: current_.style[styleKey] },\n                        });\n                        current_.style[styleKey] = styleValue;\n                        return true;\n                    },\n                });\n            return current_[key];\n        },\n        deleteProperty: (t, key) => {\n            changes.push({ type: 'delete', op: key });\n            return Reflect.deleteProperty(current, key);\n        },\n        set: (t, key, value, r) => {\n            changes.push({ type: 'set', op: [key, value] });\n            return (current[key] = value);\n        },\n        defineProperty: (t, key, attributes) => {\n            changes.push({ type: 'defineProperty', op: [key, attributes] });\n            return Reflect.defineProperty(current, key, attributes);\n        },\n        preventExtensions: (t) => {\n            changes.push({ type: 'preventExtensions', op: undefined });\n            return Reflect.preventExtensions(current);\n        },\n        setPrototypeOf: (t, prototype) => {\n            changes.push({ type: 'setPrototypeOf', op: prototype });\n            return Reflect.setPrototypeOf(current, prototype);\n        },\n    };\n    const proxy = Proxy.revocable(defaultCurrent, proxyTraps);\n    function hasStyle(e) {\n        return 'style' in e;\n    }\n    /** Call before realCurrent change */\n    function undoEffects(nextCurrent) {\n        for (const change of changes) {\n            if (change.type === 'callMethods') {\n                const attr = change.op.name;\n                if (attr === 'addEventListener') {\n                    current.removeEventListener(...change.op.param);\n                }\n                else if (attr === 'appendChild') {\n                    if (!nextCurrent) {\n                        const node = change.op.thisArg[0];\n                        if (node !== undefined)\n                            current.removeChild(node);\n                    }\n                }\n            }\n            else if (change.type === 'modifyStyle') {\n                const { name, value, originalValue } = change.op;\n                if (hasStyle(current)) {\n                    current.style[name] = originalValue;\n                }\n            }\n        }\n    }\n    /** Call after realCurrent change */\n    function redoEffects() {\n        if (current === defaultCurrent)\n            return;\n        const t = {};\n        for (const change of changes) {\n            if (change.type === 'setPrototypeOf')\n                Reflect.setPrototypeOf(current, change.op);\n            else if (change.type === 'preventExtensions')\n                Reflect.preventExtensions(current);\n            else if (change.type === 'defineProperty')\n                Reflect.defineProperty(current, change.op[0], change.op[1]);\n            else if (change.type === 'set')\n                Reflect.set(current, change.op[0], change.op[1], t);\n            else if (change.type === 'delete')\n                Reflect.deleteProperty(current, change.op);\n            else if (change.type === 'callMethods') {\n                const replayable = ['appendChild', 'addEventListener', 'before', 'after'];\n                const key = change.op.name;\n                if (replayable.indexOf(key) !== -1) {\n                    if (current[key] !== undefined) {\n                        ;\n                        current[key](...change.op.param);\n                    }\n                    else {\n                        console.warn(current, `doesn't have method \"${key}\", replay failed.`);\n                    }\n                }\n            }\n            else if (change.type === 'modifyStyle') {\n                ;\n                current.style[change.op.name] = change.op.value;\n            }\n        }\n    }\n    // MutationObserver\n    const noop = () => { };\n    let observerCallback = noop;\n    let mutationObserverInit = undefined;\n    let observer = null;\n    function reObserve(reinit) {\n        observer && observer.disconnect();\n        if (observerCallback === noop || current === defaultCurrent)\n            return;\n        if (reinit || !observer)\n            observer = new MutationObserver(observerCallback);\n        observer.observe(current, mutationObserverInit);\n    }\n    const DOMProxyObject = {\n        observer: {\n            set callback(v) {\n                if (v === undefined)\n                    v = noop;\n                observerCallback = v;\n                reObserve(true);\n            },\n            get callback() {\n                return observerCallback;\n            },\n            get init() {\n                return mutationObserverInit;\n            },\n            set init(v) {\n                mutationObserverInit = v;\n                reObserve(false);\n            },\n            get observer() {\n                return observer;\n            },\n        },\n        get destroyed() {\n            return isDestroyed;\n        },\n        get before() {\n            if (isDestroyed)\n                throw new TypeError('Try to access `before` node after DOMProxy is destroyed');\n            if (!virtualBefore) {\n                virtualBefore = createBefore();\n                if (current instanceof Element)\n                    current.before(virtualBefore);\n            }\n            return virtualBefore;\n        },\n        get beforeShadow() {\n            if (!virtualBeforeShadow)\n                virtualBeforeShadow = this.before.attachShadow(beforeShadowRootInit);\n            return virtualBeforeShadow;\n        },\n        get current() {\n            if (isDestroyed)\n                throw new TypeError('Try to access `current` node after DOMProxy is destroyed');\n            return proxy.proxy;\n        },\n        get after() {\n            if (isDestroyed)\n                throw new TypeError('Try to access `after` node after DOMProxy is destroyed');\n            if (!virtualAfter) {\n                virtualAfter = createAfter();\n                if (current instanceof Element)\n                    current.after(virtualAfter);\n            }\n            return virtualAfter;\n        },\n        get afterShadow() {\n            if (!virtualAfterShadow)\n                virtualAfterShadow = this.after.attachShadow(afterShadowRootInit);\n            return virtualAfterShadow;\n        },\n        has(type) {\n            if (type === 'before')\n                return virtualBefore;\n            else if (type === 'after')\n                return virtualAfter;\n            else if (type === 'afterShadow')\n                return virtualAfterShadow;\n            else if (type === 'beforeShadow')\n                return virtualBeforeShadow;\n            else\n                return null;\n        },\n        get realCurrent() {\n            if (isDestroyed)\n                return null;\n            if (current === defaultCurrent)\n                return null;\n            return current;\n        },\n        set realCurrent(node) {\n            const old = current;\n            if (isDestroyed)\n                throw new TypeError('You can not set current for a destroyed proxy');\n            if (node === current)\n                return;\n            if ((node === virtualAfter || node === virtualBefore) && node !== null) {\n                console.warn(\"In the DOMProxy, you're setting .realCurrent to this DOMProxy's virtualAfter or virtualBefore. Doing this may cause bugs. If you're confused with this warning, check your rules for LiveSelector.\", this);\n            }\n            undoEffects(node);\n            reObserve(false);\n            if (node === null || node === undefined) {\n                current = defaultCurrent;\n                if (virtualBefore)\n                    virtualBefore.remove();\n                if (virtualAfter)\n                    virtualAfter.remove();\n            }\n            else {\n                current = node;\n                if (virtualAfter && current instanceof Element)\n                    current.after(virtualAfter);\n                if (virtualBefore && current instanceof Element)\n                    current.before(virtualBefore);\n                redoEffects();\n            }\n            event.emit('currentChanged', { new: node, old });\n        },\n        destroy() {\n            observer && observer.disconnect();\n            isDestroyed = true;\n            proxy.revoke();\n            virtualBeforeShadow = null;\n            virtualAfterShadow = null;\n            if (virtualBefore)\n                virtualBefore.remove();\n            if (virtualAfter)\n                virtualAfter.remove();\n            virtualBefore = null;\n            virtualAfter = null;\n            current = defaultCurrent;\n        },\n    };\n    Object.defineProperties(event, Object.getOwnPropertyDescriptors(DOMProxyObject));\n    return event;\n}\n","/**\n * WatcherClass provides an abstract implementation of a watcher to the LiveSelector\n *\n * You should extend it and implement your own watch logic.\n *\n * Built-in watcher:\n *\n * - Mutation Observer watcher (based on MutationObserver api, watch DOM changes)\n * - Interval watcher (based on time interval)\n * - Event watcher (based on addEventListener)\n */\nimport { DOMProxy } from './Proxy.js';\nimport { requestIdleCallback } from '../util/requestIdleCallback.js';\nimport { isNil, uniqWith, intersectionWith, differenceWith } from 'lodash-es';\nimport { timeout } from '../util/timeout.js';\nimport { createEventTarget } from '../util/EventTarget.js';\n/**\n * Use LiveSelector to watch dom change\n */\nexport class Watcher {\n    events = createEventTarget();\n    /**\n     * The liveSelector that this object holds.\n     */\n    liveSelector;\n    constructor(liveSelector) {\n        this.liveSelector = liveSelector.clone();\n    }\n    //#region How to start and stop the watcher\n    /** Let the watcher start to watching */\n    startWatch(...args) {\n        this.isWatching = true;\n        this._warning_forget_watch_.ignored = true;\n        this.watcherChecker();\n        return this;\n    }\n    /** Stop the watcher */\n    stopWatch(...args) {\n        this.isWatching = false;\n    }\n    /** Is the watcher running */\n    isWatching = false;\n    //#endregion\n    //#region useForeach\n    /** Saved useForeach */\n    useForeachFn;\n    /**\n     * Just like React hooks. Provide callbacks for each node changes.\n     *\n     * @param forEachFunction - You can return a set of functions that will be called on changes.\n     *\n     * @remarks\n     *\n     * Return value of `fn`\n     *\n     * - `void`: No-op\n     *\n     * - `((oldNode: T) => void)`: it will be called when the node is removed.\n     *\n     * - `{ onRemove?: (old: T) => void; onTargetChanged?: (newNode: T, oldNode: T) => void; onNodeMutation?: (node: T) => void }`,\n     *\n     * - - `onRemove` will be called when node is removed.\n     *\n     * - - `onTargetChanged` will be called when the node is still existing but target has changed.\n     *\n     * - - `onNodeMutation` will be called when the node is the same, but it inner content or attributes are modified.\n     *\n     * @example\n     * ```\n     * // ? if your LiveSelector return Element\n     * watcher.useForeach((node, key, meta) => {\n     *     console.log(node.innerHTML) // when a new key is found\n     *     return {\n     *         onRemove() { console.log('The node is gone!') },\n     *         onTargetChanged() {\n     *             console.log('Key is the same, but the node has changed!')\n     *             console.log(node.innerHTML) // `node` is still the latest node!\n     *             // appendChild, addEventListener will not lost too!\n     *         },\n     *         onNodeMutation() {\n     *             console.log('Key and node are both the same, but node has been mutated.')\n     *         }\n     *     }\n     * })\n     *\n     * // ? if your LiveSelector does not return Element but something else\n     * watcher.useForeach((value, key) => {\n     *     console.log(value) // your value here.\n     *     return {\n     *         onRemove() { console.log('The value is gone!') },\n     *         onTargetChanged(value) {\n     *             console.log('Key is the same, but the value has changed!')\n     *             console.log(value) // New value\n     *         }\n     *     }\n     * })\n     *\n     * ```\n     */\n    useForeach(forEach) {\n        if (this.useForeachFn) {\n            console.warn(\"You can't chain useForeach currently. The old one will be replaced.\");\n        }\n        this.useForeachFn = forEach;\n        return this;\n    }\n    //#endregion\n    //#region .then()\n    defaultStarterForThen() {\n        this.startWatch();\n    }\n    /**\n     * Start the watcher, once it emitted data, stop watching.\n     * @param map - Map function transform T to Result\n     * @param options - Options for watcher\n     *\n     * @remarks This is an implementation of `PromiseLike`\n     *\n     * @example\n     * ```ts\n     * const value = await watcher\n     * const value2 = await watcher(undefined, undefined, { minimalResultsRequired: 5 })\n     * ```\n     */\n    // The PromiseLike<T> interface\n    then(onfulfilled, onrejected, options = {}) {\n        this.defaultStarterForThen();\n        const { minimalResultsRequired, timeout: timeoutTime } = {\n            ...{\n                minimalResultsRequired: 1,\n                timeout: Infinity,\n            },\n            ...options,\n        };\n        let done = () => { };\n        const then = async () => {\n            if (minimalResultsRequired < 1)\n                throw new TypeError('Invalid minimalResultsRequired, must equal to or bigger than 1');\n            if (this.singleMode && minimalResultsRequired > 1) {\n                console.warn('In single mode, the watcher will ignore the option minimalResultsRequired');\n            }\n            const result = this.liveSelector.evaluate();\n            if (Array.isArray(result) && result.length >= minimalResultsRequired) {\n                // If we get the value now, return it\n                return result;\n            }\n            else if (this.singleMode) {\n                // If in single mode, return the value now\n                return result;\n            }\n            // Or return a promise to wait the value\n            return new Promise((resolve, reject) => {\n                done = (state, val) => {\n                    this.stopWatch();\n                    this.removeListener('onIteration', f);\n                    if (state)\n                        resolve(val);\n                    else\n                        reject(val);\n                };\n                const f = (v) => {\n                    const nodes = Array.from(v.current.values());\n                    if (this.singleMode && nodes.length >= 1) {\n                        return done(true, nodes[0]);\n                    }\n                    if (nodes.length < minimalResultsRequired)\n                        return;\n                    return done(true, nodes);\n                };\n                this.addListener('onIteration', f);\n            });\n        };\n        const withTimeout = timeout(then(), timeoutTime);\n        withTimeout.finally(() => done(false, new Error('timeout')));\n        return withTimeout.then(onfulfilled, onrejected);\n    }\n    //#endregion\n    //#region Multiple mode\n    /** Found key list of last watch */\n    lastKeyList = [];\n    /** Found Node list of last watch */\n    lastNodeList = [];\n    /** Saved callback map of last watch */\n    lastCallbackMap = new Map();\n    /** Saved DOMProxy of last watch */\n    lastDOMProxyMap = new Map();\n    /** Find node from the given list by key */\n    findNodeFromListByKey = (list, keys) => (key) => {\n        const i = keys.findIndex((x) => this.keyComparer(x, key));\n        if (i === -1)\n            return null;\n        return list[i];\n    };\n    /** Watcher callback with single mode is off */\n    normalModeWatcherCallback(currentIteration) {\n        /** Key list in this iteration */\n        const thisKeyList = this.mapNodeToKey === defaultMapNodeToKey ? currentIteration : currentIteration.map(this.mapNodeToKey);\n        //#region Warn about repeated keys\n        {\n            const uniq = uniqWith(thisKeyList, this.keyComparer);\n            if (uniq.length < thisKeyList.length) {\n                this._warning_repeated_keys.warn(() => console.warn('There are repeated keys in your watcher. uniqKeys:', uniq, 'allKeys:', thisKeyList, ', to omit this warning, call `.omitWarningForRepeatedKeys()`'));\n            }\n        }\n        //#endregion\n        // New maps for the next generation\n        /** Next generation Callback map */\n        const nextCallbackMap = new Map();\n        /** Next generation DOMProxy map */\n        const nextDOMProxyMap = new Map();\n        //#region Key is gone\n        // Do: Delete node\n        const findFromLast = this.findNodeFromListByKey(this.lastNodeList, this.lastKeyList);\n        const goneKeys = differenceWith(this.lastKeyList, thisKeyList, this.keyComparer);\n        {\n            for (const oldKey of goneKeys) {\n                const proxy = this.lastDOMProxyMap.get(oldKey);\n                const callbacks = this.lastCallbackMap.get(oldKey);\n                const node = findFromLast(oldKey);\n                this.requestIdleCallback(() => {\n                    applyUseForeachCallback(callbacks)('remove')(node);\n                    if (proxy)\n                        proxy.destroy();\n                }, \n                // Delete node don't need a short timeout.\n                { timeout: 2000 });\n            }\n        }\n        //#endregion\n        //#region Key is new\n        // Do: Add node\n        const findFromNew = this.findNodeFromListByKey(currentIteration, thisKeyList);\n        const newKeys = differenceWith(thisKeyList, this.lastKeyList, this.keyComparer);\n        {\n            for (const newKey of newKeys) {\n                if (!this.useForeachFn)\n                    break;\n                const value = findFromNew(newKey);\n                if (value instanceof Node) {\n                    const proxy = DOMProxy(this.domProxyOption);\n                    proxy.realCurrent = value;\n                    // This step must be sync.\n                    const callbacks = this.useForeachFn(proxy.current, newKey, proxy);\n                    if (hasMutationCallback(callbacks) && !proxy.observer.callback) {\n                        proxy.observer.init = {\n                            subtree: true,\n                            childList: true,\n                            characterData: true,\n                            attributes: true,\n                        };\n                        proxy.observer.callback = (m) => callbacks.onNodeMutation?.(value, m);\n                    }\n                    nextCallbackMap.set(newKey, callbacks);\n                    nextDOMProxyMap.set(newKey, proxy);\n                }\n                else {\n                    const callbacks = this.useForeachFn(value, newKey, undefined);\n                    applyUseForeachCallback(callbacks)('warn mutation')(this._warning_mutation_);\n                    nextCallbackMap.set(newKey, callbacks);\n                }\n            }\n        }\n        //#endregion\n        //#region Key is the same, but node is changed\n        // Do: Change reference\n        const oldSameKeys = intersectionWith(this.lastKeyList, thisKeyList, this.keyComparer);\n        const newSameKeys = intersectionWith(thisKeyList, this.lastKeyList, this.keyComparer);\n        const changedNodes = oldSameKeys\n            .map((x) => [findFromLast(x), findFromNew(x), x, newSameKeys.find((newK) => this.keyComparer(newK, x))])\n            .filter(([a, b]) => this.valueComparer(a, b) === false);\n        for (const [oldNode, newNode, oldKey, newKey] of changedNodes) {\n            const fn = this.lastCallbackMap.get(oldKey);\n            if (newNode instanceof Node) {\n                const proxy = this.lastDOMProxyMap.get(oldKey);\n                proxy.realCurrent = newNode;\n            }\n            // This should be ordered. So keep it sync now.\n            applyUseForeachCallback(fn)('target change')(newNode, oldNode);\n        }\n        //#endregion\n        // Key is the same, node is the same\n        // Do: nothing\n        // #region Final: Copy the same keys\n        for (const newKey of newSameKeys) {\n            const oldKey = oldSameKeys.find((oldKey) => this.keyComparer(newKey, oldKey));\n            nextCallbackMap.set(newKey, this.lastCallbackMap.get(oldKey));\n            nextDOMProxyMap.set(newKey, this.lastDOMProxyMap.get(oldKey));\n        }\n        this.lastCallbackMap = nextCallbackMap;\n        this.lastDOMProxyMap = nextDOMProxyMap;\n        this.lastKeyList = thisKeyList;\n        this.lastNodeList = currentIteration;\n        if (this.events.has('onIteration') && changedNodes.length + goneKeys.length + newKeys.length > 0) {\n            // Make a copy to prevent modifications\n            const newMap = new Map(newKeys.map((key) => [key, findFromNew(key)]));\n            const removedMap = new Map(goneKeys.map((key) => [key, findFromLast(key)]));\n            const currentMap = new Map(thisKeyList.map((key) => [key, findFromNew(key)]));\n            this.events.emit('onIteration', {\n                new: newMap,\n                removed: removedMap,\n                current: currentMap,\n            });\n        }\n        if (this.events.has('onChange'))\n            for (const [oldNode, newNode, oldKey, newKey] of changedNodes) {\n                this.events.emit('onChange', { oldValue: oldNode, newValue: newNode, oldKey, newKey });\n            }\n        if (this.events.has('onRemove'))\n            for (const key of goneKeys) {\n                this.events.emit('onRemove', { key, value: findFromLast(key) });\n            }\n        if (this.events.has('onAdd'))\n            for (const key of newKeys) {\n                this.events.emit('onAdd', { key, value: findFromNew(key) });\n            }\n        // For firstDOMProxy\n        const first = currentIteration[0];\n        if (first instanceof Node) {\n            this._firstDOMProxy.realCurrent = first;\n        }\n        else if (first === undefined || first === null) {\n            this._firstDOMProxy.realCurrent = null;\n        }\n        //#endregion\n        //#region Prompt developer to open single mode\n        if (currentIteration.length > 1)\n            this._warning_single_mode.ignored = true;\n        if (currentIteration.length === 1)\n            this._warning_single_mode.warn();\n        //#endregion\n    }\n    //#endregion\n    //#region Single mode\n    /**\n     * Is the single mode is on.\n     */\n    get singleMode() {\n        // @ts-ignore\n        return this.liveSelector.isSingleMode;\n    }\n    /** Last iteration value for single mode */\n    singleModeLastValue;\n    /** Does it has a last iteration value in single mode? */\n    singleModeHasLastValue = false;\n    /** Callback for single mode */\n    singleModeCallback;\n    /** Watcher callback for single mode */\n    singleModeWatcherCallback(firstValue) {\n        if (firstValue === undefined) {\n            this.firstDOMProxy.realCurrent = null;\n        }\n        if (firstValue instanceof Node) {\n            this.firstDOMProxy.realCurrent = firstValue;\n        }\n        if (hasMutationCallback(this.singleModeCallback) && !this._firstDOMProxy.observer.callback) {\n            this._firstDOMProxy.observer.init = { attributes: true, characterData: true, subtree: true };\n            this._firstDOMProxy.observer.callback = (e) => hasMutationCallback(this.singleModeCallback) &&\n                this.singleModeCallback.onNodeMutation(this._firstDOMProxy.current, e);\n        }\n        // ? Case: value is gone\n        if (this.singleModeHasLastValue && isNil(firstValue)) {\n            applyUseForeachCallback(this.singleModeCallback)('remove')(this.singleModeLastValue);\n            if (this.singleModeLastValue instanceof Node) {\n                this._firstDOMProxy.realCurrent = null;\n            }\n            this.events.emit('onRemove', { key: undefined, value: this.singleModeLastValue });\n            this.singleModeLastValue = undefined;\n            this.singleModeHasLastValue = false;\n        }\n        // ? Case: value is new\n        else if (!this.singleModeHasLastValue && Boolean(firstValue)) {\n            if (this.useForeachFn) {\n                if (firstValue instanceof Node) {\n                    this.singleModeCallback = this.useForeachFn(this.firstDOMProxy.current, undefined, this.firstDOMProxy);\n                }\n                else {\n                    this.singleModeCallback = this.useForeachFn(firstValue, undefined, undefined);\n                    applyUseForeachCallback(this.singleModeCallback)('warn mutation')(this._warning_mutation_);\n                }\n            }\n            this.events.emit('onAdd', { key: undefined, value: firstValue });\n            this.singleModeLastValue = firstValue;\n            this.singleModeHasLastValue = true;\n        }\n        // ? Case: value has changed\n        else if (this.singleModeHasLastValue && !this.valueComparer(this.singleModeLastValue, firstValue)) {\n            applyUseForeachCallback(this.singleModeCallback)('target change')(firstValue, this.singleModeLastValue);\n            this.events.emit('onChange', {\n                newKey: undefined,\n                oldKey: undefined,\n                newValue: firstValue,\n                oldValue: this.singleModeLastValue,\n            });\n            this.singleModeLastValue = firstValue;\n            this.singleModeHasLastValue = true;\n        }\n        // ? Case: value is not changed\n        else {\n            // ? Do nothing\n        }\n        return;\n    }\n    //#endregion\n    //#region Watcher callback\n    /** Should be called every watch */\n    watcherChecker = (deadline) => {\n        if (!this.isWatching)\n            return;\n        setTimeout(() => {\n            const thisNodes = this.liveSelector.evaluate();\n            if (this.singleMode)\n                return this.singleModeWatcherCallback(thisNodes);\n            else\n                return this.normalModeWatcherCallback(thisNodes);\n        }, 0);\n    };\n    //#endregion\n    //#region LiveSelector settings\n    /**\n     * The dom proxy option used in DOMProxy()\n     */\n    domProxyOption = {};\n    /**\n     * Set option for DOMProxy\n     * @param option - DOMProxy options\n     */\n    setDOMProxyOption(option) {\n        this.domProxyOption = option;\n        const oldProxy = this._firstDOMProxy;\n        if (oldProxy.has('after') ||\n            oldProxy.has('before') ||\n            oldProxy.has('afterShadow') ||\n            oldProxy.has('beforeShadow') ||\n            oldProxy.realCurrent) {\n            console.warn(\"Don't set DOMProxy before using it.\");\n        }\n        this._firstDOMProxy = DOMProxy(option);\n        return this;\n    }\n    //#endregion\n    //#region events\n    addListener(type, callback, options) {\n        this.events.add(type, callback, options);\n        return this;\n    }\n    removeListener(type, callback) {\n        this.events.remove(type, callback);\n        return this;\n    }\n    //#endregion\n    //#region firstDOMProxy\n    /** The first DOMProxy */\n    _firstDOMProxy = DOMProxy(this.domProxyOption);\n    /**\n     * This DOMProxy always point to the first node in the LiveSelector\n     */\n    get firstDOMProxy() {\n        return this._firstDOMProxy;\n    }\n    //#endregion\n    //#region Watcher settings\n    /**\n     * Map `Node -> Key`, in case of you don't want the default behavior\n     */\n    mapNodeToKey = defaultMapNodeToKey;\n    /**\n     * Compare between `key` and `key`, in case of you don't want the default behavior\n     */\n    keyComparer = defaultEqualityComparer;\n    /**\n     * Compare between `value` and `value`, in case of you don't want the default behavior\n     */\n    valueComparer = defaultEqualityComparer;\n    /**\n     * To help identify same nodes in different iteration,\n     * you need to implement a map function that map `node` to `key`\n     *\n     * If the key is changed, the same node will call through `forEachRemove` then `forEach`\n     *\n     * @param keyAssigner - map `node` to `key`, defaults to `node => node`\n     *\n     * @example\n     * ```ts\n     * watcher.assignKeys(node => node.innerText)\n     * ```\n     */\n    assignKeys(keyAssigner) {\n        this.noNeedInSingleMode(this.assignKeys.name);\n        this.mapNodeToKey = keyAssigner;\n        return this;\n    }\n    /**\n     * To help identify same nodes in different iteration,\n     * you need to implement a map function to compare `node` and `key`\n     *\n     * You probably don't need this.\n     *\n     * @param keyComparer - compare between two keys, defaults to `===`\n     * @param valueComparer - compare between two value, defaults to `===`\n     *\n     * @example\n     * ```ts\n     * watcher.setComparer(\n     *     (a, b) => JSON.stringify(a) === JSON.stringify(b),\n     *     (a, b) => a.equals(b)\n     * )\n     * ```\n     */\n    setComparer(keyComparer, valueComparer) {\n        if (keyComparer)\n            this.noNeedInSingleMode(this.setComparer.name);\n        if (keyComparer)\n            this.keyComparer = keyComparer;\n        if (valueComparer)\n            this.valueComparer = valueComparer;\n        return this;\n    }\n    //#endregion\n    //#region Schedule a watcher callback run\n    isWatcherCheckerRunning = false;\n    needCheckerRunAgainAfterCurrentSchedule = false;\n    /**\n     * Schedule a watcher check\n     */\n    scheduleWatcherCheck = () => {\n        if (this.isWatcherCheckerRunning) {\n            this.needCheckerRunAgainAfterCurrentSchedule = true;\n            return;\n        }\n        this.isWatcherCheckerRunning = true;\n        this.watcherChecker();\n        // Now watcherChecker is sync so this path will run at most once.\n        while (this.needCheckerRunAgainAfterCurrentSchedule) {\n            this.watcherChecker();\n            this.needCheckerRunAgainAfterCurrentSchedule = false;\n        }\n        this.isWatcherCheckerRunning = false;\n    };\n    //#endregion\n    //#region Utils\n    /**\n     * Get DOMProxy by key.\n     * DOMProxy will be unavailable if it is deleted\n     * @param key - Key used to find DOMProxy\n     */\n    getDOMProxyByKey(key) {\n        this.noNeedInSingleMode(this.getDOMProxyByKey.name);\n        return this.lastDOMProxyMap.get([...this.lastDOMProxyMap.keys()].find((_) => this.keyComparer(_, key))) || null;\n    }\n    /** window.requestIdleCallback, or polyfill. */\n    requestIdleCallback = requestIdleCallback;\n    /** For debug usage. Just keep it. */\n    stack = new Error().stack ?? '';\n    //#endregion\n    //#region Warnings\n    /**\n     * Warning to remember if developer forget to call the startWatch.\n     */\n    _warning_forget_watch_ = warning({\n        fn: (stack) => console.warn('Did you forget to call `.startWatch()`?\\n', stack),\n    });\n    /**\n     * If you're expecting Watcher may not be called, call this function, this will omit the warning.\n     */\n    omitWarningForForgetWatch() {\n        this._warning_forget_watch_.ignored = true;\n        return this;\n    }\n    _warning_repeated_keys = warning({ once: true });\n    /**\n     * If you're expecting repeating keys, call this function, this will omit the warning.\n     */\n    omitWarningForRepeatedKeys() {\n        this.noNeedInSingleMode(this.omitWarningForRepeatedKeys.name);\n        this._warning_repeated_keys.ignored = true;\n        return this;\n    }\n    _warning_single_mode = warning({\n        once: 15,\n        fn(stack) {\n            console.warn(`Your watcher seems like only watching 1 node.\nIf you can make sure there is only 1 node to watch, call \\`.enableSingleMode()\\` on the watcher.\nOr to ignore this message, call \\`.dismissSingleModeWarning()\\` on the watcher.\\n`, stack);\n        },\n    });\n    /**\n     * Dismiss the warning that let you enable single mode but the warning is false positive.\n     */\n    dismissSingleModeWarning() {\n        this._warning_single_mode.ignored = true;\n        return this;\n    }\n    noNeedInSingleMode(method) {\n        if (this.singleMode)\n            console.warn(`Method ${method} has no effect in SingleMode watcher`);\n    }\n    _warning_mutation_ = warning({\n        fn(stack) {\n            console.warn('When watcher is watching LiveSelector<not Node>, onNodeMutation will not be ignored\\n', stack);\n        },\n    });\n}\n//#region Default implementations\nfunction defaultEqualityComparer(a, b) {\n    return a === b;\n}\nfunction defaultMapNodeToKey(node) {\n    return node;\n}\nfunction hasMutationCallback(x) {\n    if (typeof x !== 'object' || x === null)\n        return false;\n    if ('onNodeMutation' in x && typeof x.onNodeMutation === 'function')\n        return true;\n    return false;\n}\nfunction applyUseForeachCallback(callback) {\n    const cb = callback;\n    let remove, change, mutation;\n    if (typeof cb === 'function')\n        remove = cb;\n    else if (cb !== undefined) {\n        const { onNodeMutation, onRemove, onTargetChanged } = cb;\n        [remove, change, mutation] = [onRemove, onTargetChanged, onNodeMutation];\n    }\n    return ((type) => (...args) => {\n        if (type === 'remove')\n            remove && remove(...args);\n        else if (type === 'target change')\n            change && change(...args);\n        else if (type === 'warn mutation')\n            mutation && args[0]();\n    });\n}\nfunction warning(_ = {}) {\n    const { dev, once, fn } = { ...{ dev: false, once: true, fn: () => { } }, ..._ };\n    if (dev)\n        if (process.env.NODE_ENV !== 'development')\n            return { warn(f = fn) { }, ignored: true, stack: '' };\n    const [_0, _1, _2, ...lines] = (new Error().stack ?? '').split('\\n');\n    const stack = lines.join('\\n');\n    let warned = 0;\n    const obj = {\n        ignored: false,\n        stack,\n        warn(f = fn) {\n            if (obj.ignored)\n                return;\n            if (warned > 0 && Boolean(once))\n                return;\n            if (typeof once === 'number' && warned <= once)\n                return;\n            warned = warned + 1;\n            f(stack);\n        },\n    };\n    return obj;\n}\n//#endregion\n","import { Watcher } from '../Watcher.js';\n/**\n * A watcher based on time interval.\n *\n * @example\n * ```ts\n * new IntervalWatcher(ls)\n * .useForeach(node => {\n *     console.log(node)\n * })\n * .startWatch(1000)\n * ```\n */\nexport class IntervalWatcher extends Watcher {\n    timer;\n    /** Start to watch the LiveSelector at a interval(ms). */\n    startWatch(interval, signal) {\n        super.startWatch();\n        this.timer = setInterval(this.scheduleWatcherCheck, interval);\n        signal?.addEventListener('abort', () => {\n            this.stopWatch();\n        }, { once: true });\n        return this;\n    }\n    /**\n     * {@inheritdoc Watcher.stopWatch}\n     */\n    stopWatch() {\n        super.stopWatch();\n        if (this.timer)\n            clearInterval(this.timer);\n    }\n}\n","import { Watcher } from '../Watcher.js';\n/**\n * A watcher based on MutationObserver\n *\n * @example\n * ```ts\n * new MutationObserverWatcher(ls)\n *     .useForeach(node => {\n *         console.log(node)\n *     })\n *     .startWatch()\n * ```\n */\nexport class MutationObserverWatcher extends Watcher {\n    liveSelector;\n    consistentWatchRoot;\n    stopWatchOnDisconnected;\n    constructor(\n    /** LiveSelector that this object holds */\n    liveSelector, \n    /**\n     * If you know the element is always inside of a node, set this option.\n     * This may improve performance.\n     */\n    consistentWatchRoot = document.body, \n    /**\n     * Call stopWatch() when the consistentWatchRoot disconnected.\n     */\n    stopWatchOnDisconnected = false) {\n        super(liveSelector);\n        this.liveSelector = liveSelector;\n        this.consistentWatchRoot = consistentWatchRoot;\n        this.stopWatchOnDisconnected = stopWatchOnDisconnected;\n        setTimeout(this._warning_forget_watch_.warn, 5000);\n    }\n    /** Observe whole document change */\n    observer = new MutationObserver((mutations, observer) => {\n        if (this.consistentWatchRoot.isConnected === false && this.stopWatchOnDisconnected === true) {\n            return this.stopWatch();\n        }\n        this.requestIdleCallback(this.scheduleWatcherCheck);\n    });\n    /**\n     * Start an MutationObserverWatcher.\n     *\n     * @remarks\n     * You must provide a reasonable MutationObserverInit to reduce dom events.\n     *\n     * https://mdn.io/MutationObserverInit\n     */\n    startWatch(options, signal) {\n        signal?.addEventListener('abort', () => {\n            this.stopWatch();\n        }, { once: true });\n        super.startWatch();\n        this.isWatching = true;\n        const watch = (root) => {\n            this.observer.observe(root || document.body, options);\n            this.scheduleWatcherCheck();\n        };\n        if (document.readyState !== 'complete' && this.consistentWatchRoot === null) {\n            document.addEventListener('readystatechange', () => document.readyState !== 'complete' && watch());\n        }\n        else\n            watch(this.consistentWatchRoot);\n        return this;\n    }\n    defaultStarterForThen() {\n        if (!this.isWatching)\n            this.startWatch({ subtree: true, childList: true, characterData: true });\n    }\n    /**\n     * {@inheritdoc Watcher.stopWatch}\n     */\n    stopWatch() {\n        super.stopWatch();\n        this.observer.disconnect();\n    }\n}\n","/* eslint-disable no-bitwise */\n/* eslint-disable @typescript-eslint/strict-boolean-expressions */\n/** Current running environment of Web Extension */\nexport var Environment;\n(function (Environment) {\n    Environment[Environment[\"NONE\"] = 0] = \"NONE\";\n    /** has browser as a global variable */ Environment[Environment[\"HasBrowserAPI\"] = 2] = \"HasBrowserAPI\";\n    /** URL protocol ends with \"-extension:\" */ Environment[Environment[\"ExtensionProtocol\"] = 4] = \"ExtensionProtocol\";\n    /** Current running context is Content Script */ Environment[Environment[\"ContentScript\"] = 8] = \"ContentScript\";\n    // userScript = 1 << 4,\n    /** URL of the manifest.background, generated background page, or manifest v3 service worker */\n    Environment[Environment[\"ManifestBackground\"] = 64] = \"ManifestBackground\";\n    /** URL is listed in the manifest.options_ui */ Environment[Environment[\"ManifestOptions\"] = 128] = \"ManifestOptions\";\n    /**\n     * URL is listed in the manifest.browser_action\n     * @deprecated It will be removed in manifest v3. Use ManifestAction instead */ Environment[Environment[\"ManifestBrowserAction\"] = 256] = \"ManifestBrowserAction\";\n    /** URL is listed in the manifest.action */ Environment[Environment[\"ManifestAction\"] = 256] = \"ManifestAction\";\n    /**\n     * URL is listed in the manifest.page_action\n     * @deprecated Suggest to define browser_action instead.\n     */ Environment[Environment[\"ManifestPageAction\"] = 512] = \"ManifestPageAction\";\n    /** URL is listed in the manifest.devtools_page */ Environment[Environment[\"ManifestDevTools\"] = 1024] = \"ManifestDevTools\";\n    /** URL is listed in the manifest.sidebar_action. Firefox Only */ Environment[Environment[\"ManifestSidebar\"] = 2048] = \"ManifestSidebar\";\n    /** URL is listed in the manifest.chrome_url_overrides.newtab */ Environment[Environment[\"ManifestOverridesNewTab\"] = 4096] = \"ManifestOverridesNewTab\";\n    /** URL is listed in the manifest.chrome_url_overrides.bookmarks */ Environment[Environment[\"ManifestOverridesBookmarks\"] = 8192] = \"ManifestOverridesBookmarks\";\n    /** URL is listed in the manifest.chrome_url_overrides.history */ Environment[Environment[\"ManifestOverridesHistory\"] = 16384] = \"ManifestOverridesHistory\";\n    // DO NOT USE value that bigger than 1 << 20\n})(Environment = Environment || (Environment = {}));\nlet result;\n/**\n * Get the current running environment\n * @remarks You can use the global variable `__holoflows_kit_get_environment_debug__` to overwrite the return value if the current hostname is localhost or 127.0.0.1\n */\nexport function getEnvironment() {\n    if (result !== undefined)\n        return result;\n    try {\n        if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {\n            const val = __holoflows_kit_get_environment_debug__;\n            if (val !== undefined)\n                return Number(val);\n        }\n    }\n    catch { }\n    let flag = Environment.NONE;\n    // Scheme test\n    try {\n        const scheme = location.protocol;\n        if (scheme.endsWith('-extension:'))\n            flag |= Environment.ExtensionProtocol;\n    }\n    catch { }\n    // @ts-ignore\n    const chromeLike = isChromeLike();\n    if (!isBrowserLike() && chromeLike) {\n        console.error([\n            \"Cannot find 'browser'. This library does not work with 'chrome' namespace.\",\n            'Please use the polyfill (https://www.npmjs.com/package/webextension-polyfill)',\n        ].join('\\n'));\n    }\n    const browser = getBrowserLikeNS();\n    // Browser API test\n    if (browser) {\n        flag |= Environment.HasBrowserAPI;\n        if (!(flag & Environment.ExtensionProtocol))\n            flag |= Environment.ContentScript;\n        else {\n            try {\n                const manifest = browser.runtime.getManifest();\n                const current = location.pathname;\n                const background = manifest.background\n                    ? 'service_worker' in manifest.background\n                        ? manifest.background.service_worker\n                        : 'page' in manifest.background\n                            ? manifest.background.page\n                            : '/_generated_background_page.html'\n                    : '';\n                const options = manifest.options_ui?.page;\n                if (current === normalize(background))\n                    flag |= Environment.ManifestBackground;\n                // TODO: this property support i18n. What will I get when call browser.runtime.getManifest()?\n                if (current === normalize(manifest.browser_action?.default_popup))\n                    flag |= Environment.ManifestAction;\n                if (current === normalize(manifest.sidebar_action?.default_panel))\n                    flag |= Environment.ManifestSidebar;\n                if (current === normalize(options))\n                    flag |= Environment.ManifestOptions;\n                if (current === normalize(manifest.devtools_page))\n                    flag |= Environment.ManifestDevTools;\n                if (current === normalize(manifest.page_action?.default_popup))\n                    flag |= Environment.ManifestPageAction;\n                // TODO: this property support i18n.\n                // @ts-expect-error https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/manifest.json/chrome_url_overrides\n                const { bookmarks, history, newtab } = manifest.chrome_url_overrides || {};\n                if (current === normalize(bookmarks))\n                    flag |= Environment.ManifestOverridesBookmarks;\n                if (current === normalize(history))\n                    flag |= Environment.ManifestOverridesHistory;\n                if (current === normalize(newtab))\n                    flag |= Environment.ManifestOverridesNewTab;\n            }\n            catch { }\n        }\n    }\n    return (result = flag);\n    function normalize(x) {\n        if (x === undefined)\n            return '_';\n        try {\n            // on firefox it is a full qualified URL\n            return new URL(x).pathname;\n        }\n        catch {\n            // on chrome it is unmodified\n            if (x[0] !== '/')\n                return '/' + x;\n            return x;\n        }\n    }\n}\nfunction isChromeLike() {\n    try {\n        return !!chrome.runtime.getURL;\n    }\n    catch { }\n    return false;\n}\nfunction isBrowserLike() {\n    try {\n        return !!browser.runtime.getURL;\n    }\n    catch { }\n    return false;\n}\nfunction getBrowserLikeNS() {\n    try {\n        if (typeof browser.runtime.getURL === 'function')\n            return browser;\n    }\n    catch { }\n    try {\n        if (typeof chrome.runtime.getURL === 'function')\n            return chrome;\n    }\n    catch { }\n    return undefined;\n}\n/**\n * Print the Environment bit flag in a human-readable format\n * @param e - Printing environment bit flag\n */\nexport function printEnvironment(e = getEnvironment()) {\n    const flag = [];\n    if (Environment.ContentScript & e)\n        flag.push('ContentScript');\n    if (Environment.ExtensionProtocol & e)\n        flag.push('ExtensionProtocol');\n    if (Environment.HasBrowserAPI & e)\n        flag.push('HasBrowserAPI');\n    if (Environment.ManifestBackground & e)\n        flag.push('ManifestBackground');\n    if (Environment.ManifestDevTools & e)\n        flag.push('ManifestDevTools');\n    if (Environment.ManifestOptions & e)\n        flag.push('ManifestOptions');\n    if (Environment.ManifestPageAction & e)\n        flag.push('ManifestPageAction');\n    if (Environment.ManifestOverridesBookmarks & e)\n        flag.push('ManifestOverridesBookmarks');\n    if (Environment.ManifestOverridesHistory & e)\n        flag.push('ManifestOverridesHistory');\n    if (Environment.ManifestOverridesNewTab & e)\n        flag.push('ManifestOverridesNewTab');\n    if (Environment.ManifestAction & e)\n        flag.push('ManifestBrowserAction');\n    if (Environment.ManifestSidebar & e)\n        flag.push('ManifestSidebar');\n    return flag.join('|');\n}\n/**\n * Assert the current environment satisfy the expectation\n * @param env - The expected environment\n */\nexport function assertEnvironment(env) {\n    if (!isEnvironment(env))\n        throw new TypeError(`Running in the wrong context, (expected ${printEnvironment(env)}, actually ${printEnvironment()})`);\n}\nassertEnvironment.oneOf = (...args) => {\n    return assertEnvironment(args.reduce((p, c) => p | c));\n};\nassertEnvironment.allOf = (...args) => {\n    return args.map(assertEnvironment);\n};\n/**\n * Assert the current environment NOT satisfy the rejected flags\n * @param env - The rejected environment\n */\nexport function assertNotEnvironment(env) {\n    if (getEnvironment() & env)\n        throw new TypeError(`Running in wrong context, (expected not match ${printEnvironment(env)}, actually ${printEnvironment()})`);\n}\nassertNotEnvironment.oneOf = (...args) => {\n    return assertNotEnvironment(args.reduce((p, c) => p | c));\n};\nassertNotEnvironment.allOf = (...args) => {\n    return args.map(assertNotEnvironment);\n};\n/**\n * Check if the current environment satisfy the expectation\n * @param env - The expectation environment\n */\nexport function isEnvironment(env) {\n    const now = getEnvironment();\n    return Boolean(env & now);\n}\nisEnvironment.oneOf = (...args) => {\n    return isEnvironment(args.reduce((p, c) => p | c));\n};\nisEnvironment.allOf = (...args) => {\n    return args.map(isEnvironment);\n};\n","/* eslint-disable @typescript-eslint/strict-boolean-expressions */\n/* eslint-disable no-bitwise */\nimport { Emitter } from '@servie/events';\nimport { EventIterator } from 'event-iterator';\nimport { createEventTarget } from '../util/EventTarget.js';\nimport { Environment, getEnvironment, isEnvironment } from './Context.js';\nexport var MessageTarget;\n(function (MessageTarget) {\n    /** Current execution context */ MessageTarget[MessageTarget[\"IncludeLocal\"] = 1048576] = \"IncludeLocal\";\n    MessageTarget[MessageTarget[\"LocalOnly\"] = 2097152] = \"LocalOnly\";\n    /** Visible page, maybe have more than 1 page. */ MessageTarget[MessageTarget[\"VisiblePageOnly\"] = 4194304] = \"VisiblePageOnly\";\n    /** Page that has focus (devtools not included), 0 or 1 page. */ MessageTarget[MessageTarget[\"FocusedPageOnly\"] = 8388608] = \"FocusedPageOnly\";\n    /** Send to external. */ MessageTarget[MessageTarget[\"External\"] = 16777216] = \"External\";\n    /** Externals not included */ MessageTarget[MessageTarget[\"Broadcast\"] = 2] = \"Broadcast\";\n    MessageTarget[MessageTarget[\"All\"] = 1048578] = \"All\";\n})(MessageTarget = MessageTarget || (MessageTarget = {}));\n// Only available in background page\nconst backgroundOnlyLivingPorts = new Map();\n// Only be set in other pages\nlet currentTabID = -1;\nlet externalMode = false;\n// Shared global\nlet postMessage = undefined;\nconst domainRegistry = new Emitter();\nconst constant = '@holoflows/kit/WebExtensionMessage/setup';\nclass WebExtensionMessage {\n    // Only execute once.\n    static setup(id) {\n        if (id)\n            externalMode = true;\n        if (isEnvironment(Environment.ManifestBackground)) {\n            // Wait for other pages to connect\n            browser.runtime.onConnect.addListener((port) => {\n                if (port.name !== constant)\n                    return; // not for ours\n                const sender = port.sender;\n                backgroundOnlyLivingPorts.set(port, { sender });\n                backgroundPortBoarding(port, sender);\n            });\n            WebExtensionMessage.setup = () => { };\n            postMessage = backgroundPageMessageHandler;\n        }\n        else {\n            function reconnect() {\n                const port = id\n                    ? // @ts-ignore\n                        chrome.runtime.connect(id, { name: constant })\n                    : browser.runtime.connect({ name: constant });\n                postMessage = otherEnvMessageHandler.bind(port);\n                // don't reconnect when external connect\n                otherEnvPortBoarding(port, id ? () => { } : reconnect);\n            }\n            reconnect();\n            WebExtensionMessage.setup = () => { };\n        }\n    }\n    static acceptExternalConnectFns = new Set();\n    /** If the connection is not accepted, it will be passed to the next handler until it is handled or no more handlers */\n    static acceptExternalConnect(acceptExternalConnectFn) {\n        this.acceptExternalConnectFns.add(acceptExternalConnectFn);\n        if (!isEnvironment(Environment.ManifestBackground))\n            return;\n        // Wait for other pages to connect\n        // @ts-ignore\n        const c = chrome;\n        c.runtime.onConnectExternal.addListener((port) => {\n            if (port.name !== constant)\n                return; // not for ours\n            const sender = port.sender;\n            if (!sender)\n                return port.disconnect();\n            let accepted = false;\n            for (const each of this.acceptExternalConnectFns) {\n                const result = each(sender);\n                if (!result)\n                    continue;\n                if (result === true)\n                    backgroundOnlyLivingPorts.set(port, { sender, external: true, environment: 0 });\n                else\n                    backgroundOnlyLivingPorts.set(port, { sender, environment: result.acceptAs });\n                accepted = true;\n                break;\n            }\n            if (!accepted)\n                return port.disconnect();\n            backgroundPortBoarding(port, sender);\n        });\n        this.acceptExternalConnect = (f) => void this.acceptExternalConnectFns.add(f);\n        postMessage = backgroundPageMessageHandler;\n    }\n    #domain;\n    /** Same message name within different domain won't collide with each other. */\n    get domain() {\n        return this.#domain;\n    }\n    /**\n     * @param options - WebExtensionMessage options\n     */\n    constructor(options) {\n        // invoke the warning if needed\n        getEnvironment();\n        try {\n            if (options?.externalExtensionID) {\n                WebExtensionMessage.setup(options.externalExtensionID);\n            }\n            else {\n                typeof browser === 'object' && browser && WebExtensionMessage.setup(undefined);\n            }\n        }\n        catch (e) {\n            console.error('Setup failed', e);\n        }\n        const domain = (this.#domain = options?.domain ?? '');\n        domainRegistry.on(domain, async (payload) => {\n            if (!isInternalMessageType(payload))\n                return;\n            const { event, target } = payload;\n            let { data } = payload;\n            if (!shouldAcceptThisMessage(target))\n                return;\n            data = await this.serialization.deserialization(data);\n            if (this.enableLog) {\n                this.log(...this.logFormatter(this, event, data));\n            }\n            this.#eventRegistry.emit(event, data);\n        });\n    }\n    //#region Simple API\n    #events = (() => {\n        const set = (event) => {\n            const value = UnboundedRegistry(this, event, this.#eventRegistry);\n            Object.defineProperty(container, event, {\n                configurable: true,\n                value,\n            });\n            return value;\n        };\n        const container = {\n            __proto__: new Proxy({}, {\n                get(target, key) {\n                    if (typeof key === 'symbol')\n                        return undefined;\n                    return set(key);\n                },\n            }),\n        };\n        return new Proxy(container, {\n            setPrototypeOf: (t, p) => p === null,\n            getPrototypeOf: () => null,\n            getOwnPropertyDescriptor: (t, key) => {\n                if (typeof key === 'symbol')\n                    return undefined;\n                set(key);\n                return Object.getOwnPropertyDescriptor(container, key);\n            },\n        });\n    })();\n    /** Event listeners */\n    get events() {\n        return this.#events;\n    }\n    //#endregion\n    // declare readonly eventTarget: { readonly [key in keyof Message]: UnboundedRegister<Message[key], EventTargetRegister<Message>> }\n    // declare readonly eventEmitter: { readonly [key in keyof Message]: UnboundedRegister<Message[key], EventEmitterRegister<Message>> }\n    /**\n     * Watch new tabs created and get event listener register of that tab.\n     *\n     * This API only works in the BackgroundPage.\n     */\n    serialization = { deserialization: (x) => x, serialization: (x) => x };\n    logFormatter = (instance, key, data) => {\n        return [\n            `%cReceive%c %c${String(key)}`,\n            'background: rgba(0, 255, 255, 0.6); color: black; padding: 0px 6px; border-radius: 4px;',\n            '',\n            'text-decoration: underline',\n            data,\n        ];\n    };\n    enableLog = false;\n    log = console.log;\n    #eventRegistry = createEventTarget();\n    get eventRegistry() {\n        return this.#eventRegistry.emitter;\n    }\n}\nexport { WebExtensionMessage };\nfunction isInternalMessageType(e) {\n    if (typeof e !== 'object' || e === null)\n        return false;\n    const { domain, event, target } = e;\n    // Message is not for us\n    if (typeof domain !== 'string')\n        return false;\n    if (typeof event !== 'string')\n        return false;\n    if (typeof target !== 'object' || target === null)\n        return false;\n    return true;\n}\nfunction shouldAcceptThisMessage(target) {\n    if (target.kind === 'tab')\n        return target.id === currentTabID && currentTabID !== -1;\n    if (target.kind === 'port')\n        return true;\n    const flag = target.target;\n    if (flag & (MessageTarget.IncludeLocal | MessageTarget.LocalOnly))\n        return true;\n    const here = getEnvironment();\n    if (flag & MessageTarget.FocusedPageOnly)\n        return typeof document === 'object' && document?.hasFocus?.();\n    if (flag & MessageTarget.VisiblePageOnly) {\n        // background page has document.visibilityState === 'visible' for reason I don't know why\n        if (here & Environment.ManifestBackground)\n            return false;\n        return typeof document === 'object' && document?.visibilityState === 'visible';\n    }\n    if (externalMode)\n        return true; // skip mode checking for external connection\n    return Boolean(here & flag);\n}\n//#endregion\nfunction UnboundedRegistry(instance, eventName, eventListener) {\n    //#region Batch message\n    let pausing = false;\n    const pausingMap = new Map();\n    //#endregion\n    async function send(target, data) {\n        if (typeof target !== 'number')\n            throw new TypeError('target must be a bit flag of MessageTarget | Environment');\n        if (pausing) {\n            const list = pausingMap.get(target) || [];\n            pausingMap.set(target, list);\n            list.push(data);\n            return;\n        }\n        postMessage({\n            data: await instance.serialization.serialization(data),\n            domain: instance.domain,\n            event: eventName,\n            target: { kind: 'target', target },\n        });\n    }\n    function on(cb, options) {\n        return eventListener.add(eventName, cb, options);\n    }\n    function off(cb) {\n        eventListener.remove(eventName, cb);\n    }\n    function pause() {\n        pausing = true;\n        return async (reducer = (x) => x) => {\n            pausing = false;\n            for (const [target, list] of pausingMap) {\n                try {\n                    await Promise.all(reducer(list).map((x) => send(target, x)));\n                }\n                finally {\n                    pausingMap.clear();\n                }\n            }\n        };\n    }\n    const self = {\n        send,\n        sendToLocal: send.bind(null, MessageTarget.LocalOnly),\n        sendToBackgroundPage: send.bind(null, Environment.ManifestBackground),\n        sendToContentScripts: send.bind(null, Environment.ContentScript),\n        sendToVisiblePages: send.bind(null, MessageTarget.VisiblePageOnly),\n        sendToFocusedPage: send.bind(null, MessageTarget.FocusedPageOnly),\n        sendByBroadcast: send.bind(null, MessageTarget.Broadcast),\n        sendToAll: send.bind(null, MessageTarget.All),\n        bind(target, signal) {\n            return {\n                on: (callback, options) => {\n                    const off = on(callback, options);\n                    signal?.addEventListener('abort', off, { once: true });\n                    return off;\n                },\n                off,\n                send: (data) => send(target, data),\n                pause,\n            };\n        },\n        on,\n        off,\n        pause,\n        async *[Symbol.asyncIterator]() {\n            yield* new EventIterator(({ push }) => this.on(push));\n        },\n    };\n    return self;\n}\nfunction backgroundPageMessageHandler(data) {\n    // receive payload from the other side\n    if (!isInternalMessageType(data))\n        return;\n    if (data.target.kind === 'tab') {\n        for (const [port, { sender }] of backgroundOnlyLivingPorts) {\n            if (data.target.id !== sender?.tab?.id)\n                continue;\n            return port.postMessage(data);\n        }\n    }\n    else if (data.target.kind === 'port') {\n        data.target.port.postMessage(data);\n    }\n    else {\n        const flag = data.target.target;\n        // Also dispatch this message to background page itself. shouldAcceptThisMessage will help us to filter the message\n        domainRegistry.emit(data.domain, data);\n        if (flag & MessageTarget.LocalOnly)\n            return;\n        for (const [port, { environment }] of backgroundOnlyLivingPorts) {\n            if (port === this)\n                continue; // Not sending to the source.\n            if (environment === undefined)\n                continue;\n            try {\n                if (environment & flag)\n                    port.postMessage(data);\n                // they will handle this by thyself\n                else if (flag & (MessageTarget.FocusedPageOnly | MessageTarget.VisiblePageOnly))\n                    port.postMessage(data);\n            }\n            catch (e) {\n                console.error(e);\n            }\n        }\n    }\n}\nfunction otherEnvMessageHandler(payload) {\n    if (typeof payload !== 'object')\n        return this.postMessage(payload);\n    const bound = payload.target;\n    if (bound.kind === 'tab')\n        return this.postMessage(payload);\n    if (bound.kind === 'port')\n        throw new Error('Unreachable case: bound type = port in non-background script');\n    const target = bound.target;\n    if (target & (MessageTarget.IncludeLocal | MessageTarget.LocalOnly)) {\n        domainRegistry.emit(payload.domain, payload);\n        if (target & MessageTarget.LocalOnly)\n            return;\n        bound.target &= ~MessageTarget.IncludeLocal; // unset IncludeLocal\n    }\n    this.postMessage(payload);\n}\n/** The port need to be initialized before use. */\nfunction backgroundPortBoarding(port, sender) {\n    // let the client know it's tab id\n    // sender.tab might be undefined if it is a popup\n    port.postMessage(sender?.tab?.id ?? -1);\n    // Client will report it's environment flag on connection\n    port.onMessage.addListener(function environmentListener(x) {\n        const obj = backgroundOnlyLivingPorts.get(port);\n        if (typeof obj.environment === 'undefined')\n            obj.environment = Number(x);\n        port.onMessage.removeListener(environmentListener);\n    });\n    port.onMessage.addListener(backgroundPageMessageHandler.bind(port));\n    port.onDisconnect.addListener(() => backgroundOnlyLivingPorts.delete(port));\n}\nfunction otherEnvPortBoarding(port, reconnect) {\n    // report self environment\n    port.postMessage(getEnvironment());\n    // server will send self tab ID on connected\n    port.onMessage.addListener(function tabIDListener(x) {\n        currentTabID = Number(x);\n        port.onMessage.removeListener(tabIDListener);\n    });\n    port.onMessage.addListener((data) => {\n        if (!isInternalMessageType(data))\n            return;\n        domainRegistry.emit(data.domain, data);\n    });\n    // ? Will it cause infinite loop?\n    port.onDisconnect.addListener(reconnect);\n}\n","import { Emitter, once } from '@servie/events';\n/** @internal */\nexport function createEventTarget() {\n    const emitter = new Emitter();\n    const offWeakMap = new Map();\n    function getOff(key) {\n        if (offWeakMap.has(key))\n            return offWeakMap.get(key);\n        const off = new WeakMap();\n        offWeakMap.set(key, off);\n        return off;\n    }\n    return {\n        has(key) {\n            return (emitter.$[key]?.size ?? 0) > 0;\n        },\n        add(event, callback, options) {\n            const off = options?.once === true ? once(emitter, event, callback) : emitter.on(event, callback);\n            getOff(event).set(callback, off);\n            options?.signal?.addEventListener('abort', off, { once: true });\n            return off;\n        },\n        remove(event, callback) {\n            getOff(event).get(callback)?.();\n        },\n        emitter,\n        emit(type, ...args) {\n            emitter.emit(type, ...args);\n        },\n    };\n}\n","/**\n * @param fn - function to execute\n * @param timeout - timeout\n */\nexport function requestIdleCallback(fn, timeout) {\n    if ('requestIdleCallback' in window) {\n        return window.requestIdleCallback(fn);\n    }\n    const start = Date.now();\n    return setTimeout(() => {\n        fn({\n            didTimeout: false,\n            timeRemaining: function () {\n                return Math.max(0, 50 - (Date.now() - start));\n            },\n        });\n    }, 1);\n}\n","/**\n * Accept a promise and then set a timeout on it. After `time` ms, it will reject.\n * @param promise - The promise that you want to set time limit on.\n * @param time - Time before timeout. In `ms`.\n * @param rejectReason - When reject, show a reason. Defaults to `\"timeout\"`\n *\n * @internal\n */\nexport const timeout = (promise, time, rejectReason) => {\n    if (!Number.isFinite(time))\n        return (async () => promise)();\n    let timer;\n    const race = Promise.race([\n        promise,\n        new Promise((r, reject) => {\n            timer = setTimeout(() => reject(new Error(rejectReason ?? 'timeout')), time);\n        }),\n    ]);\n    race.finally(() => clearTimeout(timer));\n    return race;\n};\n"],"names":[],"sourceRoot":"","x_google_ignoreList":[]}