"use strict";
(globalThis["webpackChunkmask_network"] = globalThis["webpackChunkmask_network"] || []).push([[2735],{

/***/ 20374:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Account: () => (/* binding */ Account),
/* harmony export */   AddressLookupTableAccount: () => (/* binding */ AddressLookupTableAccount),
/* harmony export */   AddressLookupTableInstruction: () => (/* binding */ AddressLookupTableInstruction),
/* harmony export */   AddressLookupTableProgram: () => (/* binding */ AddressLookupTableProgram),
/* harmony export */   Authorized: () => (/* binding */ Authorized),
/* harmony export */   BLOCKHASH_CACHE_TIMEOUT_MS: () => (/* binding */ BLOCKHASH_CACHE_TIMEOUT_MS),
/* harmony export */   BPF_LOADER_DEPRECATED_PROGRAM_ID: () => (/* binding */ BPF_LOADER_DEPRECATED_PROGRAM_ID),
/* harmony export */   BPF_LOADER_PROGRAM_ID: () => (/* binding */ BPF_LOADER_PROGRAM_ID),
/* harmony export */   BpfLoader: () => (/* binding */ BpfLoader),
/* harmony export */   COMPUTE_BUDGET_INSTRUCTION_LAYOUTS: () => (/* binding */ COMPUTE_BUDGET_INSTRUCTION_LAYOUTS),
/* harmony export */   ComputeBudgetInstruction: () => (/* binding */ ComputeBudgetInstruction),
/* harmony export */   ComputeBudgetProgram: () => (/* binding */ ComputeBudgetProgram),
/* harmony export */   Connection: () => (/* binding */ Connection),
/* harmony export */   Ed25519Program: () => (/* binding */ Ed25519Program),
/* harmony export */   Enum: () => (/* binding */ Enum),
/* harmony export */   EpochSchedule: () => (/* binding */ EpochSchedule),
/* harmony export */   FeeCalculatorLayout: () => (/* binding */ FeeCalculatorLayout),
/* harmony export */   Keypair: () => (/* binding */ Keypair),
/* harmony export */   LAMPORTS_PER_SOL: () => (/* binding */ LAMPORTS_PER_SOL),
/* harmony export */   LOOKUP_TABLE_INSTRUCTION_LAYOUTS: () => (/* binding */ LOOKUP_TABLE_INSTRUCTION_LAYOUTS),
/* harmony export */   Loader: () => (/* binding */ Loader),
/* harmony export */   Lockup: () => (/* binding */ Lockup),
/* harmony export */   MAX_SEED_LENGTH: () => (/* binding */ MAX_SEED_LENGTH),
/* harmony export */   Message: () => (/* binding */ Message),
/* harmony export */   MessageAccountKeys: () => (/* binding */ MessageAccountKeys),
/* harmony export */   MessageV0: () => (/* binding */ MessageV0),
/* harmony export */   NONCE_ACCOUNT_LENGTH: () => (/* binding */ NONCE_ACCOUNT_LENGTH),
/* harmony export */   NonceAccount: () => (/* binding */ NonceAccount),
/* harmony export */   PACKET_DATA_SIZE: () => (/* binding */ PACKET_DATA_SIZE),
/* harmony export */   PUBLIC_KEY_LENGTH: () => (/* binding */ PUBLIC_KEY_LENGTH),
/* harmony export */   PublicKey: () => (/* binding */ PublicKey),
/* harmony export */   SIGNATURE_LENGTH_IN_BYTES: () => (/* binding */ SIGNATURE_LENGTH_IN_BYTES),
/* harmony export */   SOLANA_SCHEMA: () => (/* binding */ SOLANA_SCHEMA),
/* harmony export */   STAKE_CONFIG_ID: () => (/* binding */ STAKE_CONFIG_ID),
/* harmony export */   STAKE_INSTRUCTION_LAYOUTS: () => (/* binding */ STAKE_INSTRUCTION_LAYOUTS),
/* harmony export */   SYSTEM_INSTRUCTION_LAYOUTS: () => (/* binding */ SYSTEM_INSTRUCTION_LAYOUTS),
/* harmony export */   SYSVAR_CLOCK_PUBKEY: () => (/* binding */ SYSVAR_CLOCK_PUBKEY),
/* harmony export */   SYSVAR_EPOCH_SCHEDULE_PUBKEY: () => (/* binding */ SYSVAR_EPOCH_SCHEDULE_PUBKEY),
/* harmony export */   SYSVAR_INSTRUCTIONS_PUBKEY: () => (/* binding */ SYSVAR_INSTRUCTIONS_PUBKEY),
/* harmony export */   SYSVAR_RECENT_BLOCKHASHES_PUBKEY: () => (/* binding */ SYSVAR_RECENT_BLOCKHASHES_PUBKEY),
/* harmony export */   SYSVAR_RENT_PUBKEY: () => (/* binding */ SYSVAR_RENT_PUBKEY),
/* harmony export */   SYSVAR_REWARDS_PUBKEY: () => (/* binding */ SYSVAR_REWARDS_PUBKEY),
/* harmony export */   SYSVAR_SLOT_HASHES_PUBKEY: () => (/* binding */ SYSVAR_SLOT_HASHES_PUBKEY),
/* harmony export */   SYSVAR_SLOT_HISTORY_PUBKEY: () => (/* binding */ SYSVAR_SLOT_HISTORY_PUBKEY),
/* harmony export */   SYSVAR_STAKE_HISTORY_PUBKEY: () => (/* binding */ SYSVAR_STAKE_HISTORY_PUBKEY),
/* harmony export */   Secp256k1Program: () => (/* binding */ Secp256k1Program),
/* harmony export */   SendTransactionError: () => (/* binding */ SendTransactionError),
/* harmony export */   SolanaJSONRPCError: () => (/* binding */ SolanaJSONRPCError),
/* harmony export */   SolanaJSONRPCErrorCode: () => (/* binding */ SolanaJSONRPCErrorCode),
/* harmony export */   StakeAuthorizationLayout: () => (/* binding */ StakeAuthorizationLayout),
/* harmony export */   StakeInstruction: () => (/* binding */ StakeInstruction),
/* harmony export */   StakeProgram: () => (/* binding */ StakeProgram),
/* harmony export */   Struct: () => (/* binding */ Struct),
/* harmony export */   SystemInstruction: () => (/* binding */ SystemInstruction),
/* harmony export */   SystemProgram: () => (/* binding */ SystemProgram),
/* harmony export */   Transaction: () => (/* binding */ Transaction),
/* harmony export */   TransactionExpiredBlockheightExceededError: () => (/* binding */ TransactionExpiredBlockheightExceededError),
/* harmony export */   TransactionExpiredNonceInvalidError: () => (/* binding */ TransactionExpiredNonceInvalidError),
/* harmony export */   TransactionExpiredTimeoutError: () => (/* binding */ TransactionExpiredTimeoutError),
/* harmony export */   TransactionInstruction: () => (/* binding */ TransactionInstruction),
/* harmony export */   TransactionMessage: () => (/* binding */ TransactionMessage),
/* harmony export */   TransactionStatus: () => (/* binding */ TransactionStatus),
/* harmony export */   VALIDATOR_INFO_KEY: () => (/* binding */ VALIDATOR_INFO_KEY),
/* harmony export */   VERSION_PREFIX_MASK: () => (/* binding */ VERSION_PREFIX_MASK),
/* harmony export */   VOTE_PROGRAM_ID: () => (/* binding */ VOTE_PROGRAM_ID),
/* harmony export */   ValidatorInfo: () => (/* binding */ ValidatorInfo),
/* harmony export */   VersionedMessage: () => (/* binding */ VersionedMessage),
/* harmony export */   VersionedTransaction: () => (/* binding */ VersionedTransaction),
/* harmony export */   VoteAccount: () => (/* binding */ VoteAccount),
/* harmony export */   VoteAuthorizationLayout: () => (/* binding */ VoteAuthorizationLayout),
/* harmony export */   VoteInit: () => (/* binding */ VoteInit),
/* harmony export */   VoteInstruction: () => (/* binding */ VoteInstruction),
/* harmony export */   VoteProgram: () => (/* binding */ VoteProgram),
/* harmony export */   clusterApiUrl: () => (/* binding */ clusterApiUrl),
/* harmony export */   sendAndConfirmRawTransaction: () => (/* binding */ sendAndConfirmRawTransaction),
/* harmony export */   sendAndConfirmTransaction: () => (/* binding */ sendAndConfirmTransaction)
/* harmony export */ });
/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7661);
/* harmony import */ var _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30690);
/* harmony import */ var _noble_ed25519__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2691);
/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(73182);
/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(bn_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(30721);
/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(bs58__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(70006);
/* harmony import */ var borsh__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(71433);
/* harmony import */ var borsh__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(borsh__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(2208);
/* harmony import */ var bigint_buffer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(76470);
/* harmony import */ var superstruct__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(94700);
/* harmony import */ var jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(97233);
/* harmony import */ var jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var rpc_websockets_dist_lib_client__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(24630);
/* harmony import */ var rpc_websockets_dist_lib_client_websocket_browser__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(29650);
/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(55311);
/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(67538);
/* harmony import */ var _noble_secp256k1__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(59906);


















/**
 * A 64 byte secret key, the first 32 bytes of which is the
 * private scalar and the last 32 bytes is the public key.
 * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
 */

_noble_ed25519__WEBPACK_IMPORTED_MODULE_2__/* .utils */ .P6.sha512Sync = (...m) => (0,_noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__/* .sha512 */ .o)(_noble_ed25519__WEBPACK_IMPORTED_MODULE_2__/* .utils */ .P6.concatBytes(...m));
const generatePrivateKey = _noble_ed25519__WEBPACK_IMPORTED_MODULE_2__/* .utils */ .P6.randomPrivateKey;
const generateKeypair = () => {
  const privateScalar = _noble_ed25519__WEBPACK_IMPORTED_MODULE_2__/* .utils */ .P6.randomPrivateKey();
  const publicKey = getPublicKey(privateScalar);
  const secretKey = new Uint8Array(64);
  secretKey.set(privateScalar);
  secretKey.set(publicKey, 32);
  return {
    publicKey,
    secretKey
  };
};
const getPublicKey = _noble_ed25519__WEBPACK_IMPORTED_MODULE_2__/* .sync */ .Z_.getPublicKey;
function isOnCurve(publicKey) {
  try {
    _noble_ed25519__WEBPACK_IMPORTED_MODULE_2__/* .Point */ .E9.fromHex(publicKey, true /* strict */);
    return true;
  } catch {
    return false;
  }
}
const sign = (message, secretKey) => _noble_ed25519__WEBPACK_IMPORTED_MODULE_2__/* .sync */ .Z_.sign(message, secretKey.slice(0, 32));
const verify = _noble_ed25519__WEBPACK_IMPORTED_MODULE_2__/* .sync */ .Z_.verify;

const toBuffer = arr => {
  if (buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.isBuffer(arr)) {
    return arr;
  } else if (arr instanceof Uint8Array) {
    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
  } else {
    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(arr);
  }
};

// Class wrapping a plain object
class Struct {
  constructor(properties) {
    Object.assign(this, properties);
  }
  encode() {
    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from((0,borsh__WEBPACK_IMPORTED_MODULE_6__.serialize)(SOLANA_SCHEMA, this));
  }
  static decode(data) {
    return (0,borsh__WEBPACK_IMPORTED_MODULE_6__.deserialize)(SOLANA_SCHEMA, this, data);
  }
  static decodeUnchecked(data) {
    return (0,borsh__WEBPACK_IMPORTED_MODULE_6__.deserializeUnchecked)(SOLANA_SCHEMA, this, data);
  }
}

// Class representing a Rust-compatible enum, since enums are only strings or
// numbers in pure JS
class Enum extends Struct {
  constructor(properties) {
    super(properties);
    this.enum = '';
    if (Object.keys(properties).length !== 1) {
      throw new Error('Enum can only take single value');
    }
    Object.keys(properties).map(key => {
      this.enum = key;
    });
  }
}
const SOLANA_SCHEMA = new Map();

let _Symbol$toStringTag;

/**
 * Maximum length of derived pubkey seed
 */
const MAX_SEED_LENGTH = 32;

/**
 * Size of public key in bytes
 */
const PUBLIC_KEY_LENGTH = 32;

/**
 * Value to be converted into public key
 */

function isPublicKeyData(value) {
  return value._bn !== undefined;
}

// local counter used by PublicKey.unique()
let uniquePublicKeyCounter = 1;

/**
 * A public key
 */
_Symbol$toStringTag = Symbol.toStringTag;
class PublicKey extends Struct {
  /** @internal */

  /**
   * Create a new PublicKey object
   * @param value ed25519 public key as buffer or base-58 encoded string
   */
  constructor(value) {
    super({});
    this._bn = void 0;
    if (isPublicKeyData(value)) {
      this._bn = value._bn;
    } else {
      if (typeof value === 'string') {
        // assume base 58 encoding by default
        const decoded = bs58__WEBPACK_IMPORTED_MODULE_4___default().decode(value);
        if (decoded.length != PUBLIC_KEY_LENGTH) {
          throw new Error(`Invalid public key input`);
        }
        this._bn = new (bn_js__WEBPACK_IMPORTED_MODULE_3___default())(decoded);
      } else {
        this._bn = new (bn_js__WEBPACK_IMPORTED_MODULE_3___default())(value);
      }
      if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) {
        throw new Error(`Invalid public key input`);
      }
    }
  }

  /**
   * Returns a unique PublicKey for tests and benchmarks using a counter
   */
  static unique() {
    const key = new PublicKey(uniquePublicKeyCounter);
    uniquePublicKeyCounter += 1;
    return new PublicKey(key.toBuffer());
  }

  /**
   * Default public key value. The base58-encoded string representation is all ones (as seen below)
   * The underlying BN number is 32 bytes that are all zeros
   */

  /**
   * Checks if two publicKeys are equal
   */
  equals(publicKey) {
    return this._bn.eq(publicKey._bn);
  }

  /**
   * Return the base-58 representation of the public key
   */
  toBase58() {
    return bs58__WEBPACK_IMPORTED_MODULE_4___default().encode(this.toBytes());
  }
  toJSON() {
    return this.toBase58();
  }

  /**
   * Return the byte array representation of the public key in big endian
   */
  toBytes() {
    const buf = this.toBuffer();
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }

  /**
   * Return the Buffer representation of the public key in big endian
   */
  toBuffer() {
    const b = this._bn.toArrayLike(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer);
    if (b.length === PUBLIC_KEY_LENGTH) {
      return b;
    }
    const zeroPad = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(32);
    b.copy(zeroPad, 32 - b.length);
    return zeroPad;
  }
  get [_Symbol$toStringTag]() {
    return `PublicKey(${this.toString()})`;
  }

  /**
   * Return the base-58 representation of the public key
   */
  toString() {
    return this.toBase58();
  }

  /**
   * Derive a public key from another key, a seed, and a program ID.
   * The program ID will also serve as the owner of the public key, giving
   * it permission to write data to the account.
   */
  /* eslint-disable require-await */
  static async createWithSeed(fromPublicKey, seed, programId) {
    const buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([fromPublicKey.toBuffer(), buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(seed), programId.toBuffer()]);
    const publicKeyBytes = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_5__/* .sha256 */ .J)(buffer);
    return new PublicKey(publicKeyBytes);
  }

  /**
   * Derive a program address from seeds and a program ID.
   */
  /* eslint-disable require-await */
  static createProgramAddressSync(seeds, programId) {
    let buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(0);
    seeds.forEach(function (seed) {
      if (seed.length > MAX_SEED_LENGTH) {
        throw new TypeError(`Max seed length exceeded`);
      }
      buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([buffer, toBuffer(seed)]);
    });
    buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([buffer, programId.toBuffer(), buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from('ProgramDerivedAddress')]);
    const publicKeyBytes = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_5__/* .sha256 */ .J)(buffer);
    if (isOnCurve(publicKeyBytes)) {
      throw new Error(`Invalid seeds, address must fall off the curve`);
    }
    return new PublicKey(publicKeyBytes);
  }

  /**
   * Async version of createProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link createProgramAddressSync} instead
   */
  /* eslint-disable require-await */
  static async createProgramAddress(seeds, programId) {
    return this.createProgramAddressSync(seeds, programId);
  }

  /**
   * Find a valid program address
   *
   * Valid program addresses must fall off the ed25519 curve.  This function
   * iterates a nonce until it finds one that when combined with the seeds
   * results in a valid program address.
   */
  static findProgramAddressSync(seeds, programId) {
    let nonce = 255;
    let address;
    while (nonce != 0) {
      try {
        const seedsWithNonce = seeds.concat(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([nonce]));
        address = this.createProgramAddressSync(seedsWithNonce, programId);
      } catch (err) {
        if (err instanceof TypeError) {
          throw err;
        }
        nonce--;
        continue;
      }
      return [address, nonce];
    }
    throw new Error(`Unable to find a viable program address nonce`);
  }

  /**
   * Async version of findProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link findProgramAddressSync} instead
   */
  static async findProgramAddress(seeds, programId) {
    return this.findProgramAddressSync(seeds, programId);
  }

  /**
   * Check that a pubkey is on the ed25519 curve.
   */
  static isOnCurve(pubkeyData) {
    const pubkey = new PublicKey(pubkeyData);
    return isOnCurve(pubkey.toBytes());
  }
}
PublicKey.default = new PublicKey('11111111111111111111111111111111');
SOLANA_SCHEMA.set(PublicKey, {
  kind: 'struct',
  fields: [['_bn', 'u256']]
});

/**
 * An account key pair (public and secret keys).
 *
 * @deprecated since v1.10.0, please use {@link Keypair} instead.
 */
class Account {
  /** @internal */

  /** @internal */

  /**
   * Create a new Account object
   *
   * If the secretKey parameter is not provided a new key pair is randomly
   * created for the account
   *
   * @param secretKey Secret key for the account
   */
  constructor(secretKey) {
    this._publicKey = void 0;
    this._secretKey = void 0;
    if (secretKey) {
      const secretKeyBuffer = toBuffer(secretKey);
      if (secretKey.length !== 64) {
        throw new Error('bad secret key size');
      }
      this._publicKey = secretKeyBuffer.slice(32, 64);
      this._secretKey = secretKeyBuffer.slice(0, 32);
    } else {
      this._secretKey = toBuffer(generatePrivateKey());
      this._publicKey = toBuffer(getPublicKey(this._secretKey));
    }
  }

  /**
   * The public key for this account
   */
  get publicKey() {
    return new PublicKey(this._publicKey);
  }

  /**
   * The **unencrypted** secret key for this account. The first 32 bytes
   * is the private scalar and the last 32 bytes is the public key.
   * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
   */
  get secretKey() {
    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([this._secretKey, this._publicKey], 64);
  }
}

const BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey('BPFLoader1111111111111111111111111111111111');

/**
 * Maximum over-the-wire size of a Transaction
 *
 * 1280 is IPv6 minimum MTU
 * 40 bytes is the size of the IPv6 header
 * 8 bytes is the size of the fragment header
 */
const PACKET_DATA_SIZE = 1280 - 40 - 8;
const VERSION_PREFIX_MASK = 0x7f;
const SIGNATURE_LENGTH_IN_BYTES = 64;

class TransactionExpiredBlockheightExceededError extends Error {
  constructor(signature) {
    super(`Signature ${signature} has expired: block height exceeded.`);
    this.signature = void 0;
    this.signature = signature;
  }
}
Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype, 'name', {
  value: 'TransactionExpiredBlockheightExceededError'
});
class TransactionExpiredTimeoutError extends Error {
  constructor(signature, timeoutSeconds) {
    super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is ` + 'unknown if it succeeded or failed. Check signature ' + `${signature} using the Solana Explorer or CLI tools.`);
    this.signature = void 0;
    this.signature = signature;
  }
}
Object.defineProperty(TransactionExpiredTimeoutError.prototype, 'name', {
  value: 'TransactionExpiredTimeoutError'
});
class TransactionExpiredNonceInvalidError extends Error {
  constructor(signature) {
    super(`Signature ${signature} has expired: the nonce is no longer valid.`);
    this.signature = void 0;
    this.signature = signature;
  }
}
Object.defineProperty(TransactionExpiredNonceInvalidError.prototype, 'name', {
  value: 'TransactionExpiredNonceInvalidError'
});

class MessageAccountKeys {
  constructor(staticAccountKeys, accountKeysFromLookups) {
    this.staticAccountKeys = void 0;
    this.accountKeysFromLookups = void 0;
    this.staticAccountKeys = staticAccountKeys;
    this.accountKeysFromLookups = accountKeysFromLookups;
  }
  keySegments() {
    const keySegments = [this.staticAccountKeys];
    if (this.accountKeysFromLookups) {
      keySegments.push(this.accountKeysFromLookups.writable);
      keySegments.push(this.accountKeysFromLookups.readonly);
    }
    return keySegments;
  }
  get(index) {
    for (const keySegment of this.keySegments()) {
      if (index < keySegment.length) {
        return keySegment[index];
      } else {
        index -= keySegment.length;
      }
    }
    return;
  }
  get length() {
    return this.keySegments().flat().length;
  }
  compileInstructions(instructions) {
    // Bail early if any account indexes would overflow a u8
    const U8_MAX = 255;
    if (this.length > U8_MAX + 1) {
      throw new Error('Account index overflow encountered during compilation');
    }
    const keyIndexMap = new Map();
    this.keySegments().flat().forEach((key, index) => {
      keyIndexMap.set(key.toBase58(), index);
    });
    const findKeyIndex = key => {
      const keyIndex = keyIndexMap.get(key.toBase58());
      if (keyIndex === undefined) throw new Error('Encountered an unknown instruction account key during compilation');
      return keyIndex;
    };
    return instructions.map(instruction => {
      return {
        programIdIndex: findKeyIndex(instruction.programId),
        accountKeyIndexes: instruction.keys.map(meta => findKeyIndex(meta.pubkey)),
        data: instruction.data
      };
    });
  }
}

/**
 * Layout for a public key
 */
const publicKey = (property = 'publicKey') => {
  return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .blob */ .Ik(32, property);
};

/**
 * Layout for a signature
 */
const signature = (property = 'signature') => {
  return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .blob */ .Ik(64, property);
};
/**
 * Layout for a Rust String type
 */
const rustString = (property = 'string') => {
  const rsl = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('length'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('lengthPadding'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .blob */ .Ik(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .offset */ .cv(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq(), -8), 'chars')], property);
  const _decode = rsl.decode.bind(rsl);
  const _encode = rsl.encode.bind(rsl);
  const rslShim = rsl;
  rslShim.decode = (b, offset) => {
    const data = _decode(b, offset);
    return data['chars'].toString();
  };
  rslShim.encode = (str, b, offset) => {
    const data = {
      chars: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(str, 'utf8')
    };
    return _encode(data, b, offset);
  };
  rslShim.alloc = str => {
    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq().span + _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq().span + buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(str, 'utf8').length;
  };
  return rslShim;
};

/**
 * Layout for an Authorized object
 */
const authorized = (property = 'authorized') => {
  return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([publicKey('staker'), publicKey('withdrawer')], property);
};

/**
 * Layout for a Lockup object
 */
const lockup = (property = 'lockup') => {
  return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .ns64 */ .gM('unixTimestamp'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .ns64 */ .gM('epoch'), publicKey('custodian')], property);
};

/**
 *  Layout for a VoteInit object
 */
const voteInit = (property = 'voteInit') => {
  return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([publicKey('nodePubkey'), publicKey('authorizedVoter'), publicKey('authorizedWithdrawer'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__.u8('commission')], property);
};

/**
 *  Layout for a VoteAuthorizeWithSeedArgs object
 */
const voteAuthorizeWithSeedArgs = (property = 'voteAuthorizeWithSeedArgs') => {
  return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('voteAuthorizationType'), publicKey('currentAuthorityDerivedKeyOwnerPubkey'), rustString('currentAuthorityDerivedKeySeed'), publicKey('newAuthorized')], property);
};
function getAlloc(type, fields) {
  const getItemAlloc = item => {
    if (item.span >= 0) {
      return item.span;
    } else if (typeof item.alloc === 'function') {
      return item.alloc(fields[item.property]);
    } else if ('count' in item && 'elementLayout' in item) {
      const field = fields[item.property];
      if (Array.isArray(field)) {
        return field.length * getItemAlloc(item.elementLayout);
      }
    } else if ('fields' in item) {
      // This is a `Structure` whose size needs to be recursively measured.
      return getAlloc({
        layout: item
      }, fields[item.property]);
    }
    // Couldn't determine allocated size of layout
    return 0;
  };
  let alloc = 0;
  type.layout.fields.forEach(item => {
    alloc += getItemAlloc(item);
  });
  return alloc;
}

function decodeLength(bytes) {
  let len = 0;
  let size = 0;
  for (;;) {
    let elem = bytes.shift();
    len |= (elem & 0x7f) << size * 7;
    size += 1;
    if ((elem & 0x80) === 0) {
      break;
    }
  }
  return len;
}
function encodeLength(bytes, len) {
  let rem_len = len;
  for (;;) {
    let elem = rem_len & 0x7f;
    rem_len >>= 7;
    if (rem_len == 0) {
      bytes.push(elem);
      break;
    } else {
      elem |= 0x80;
      bytes.push(elem);
    }
  }
}

function assert (condition, message) {
  if (!condition) {
    throw new Error(message || 'Assertion failed');
  }
}

class CompiledKeys {
  constructor(payer, keyMetaMap) {
    this.payer = void 0;
    this.keyMetaMap = void 0;
    this.payer = payer;
    this.keyMetaMap = keyMetaMap;
  }
  static compile(instructions, payer) {
    const keyMetaMap = new Map();
    const getOrInsertDefault = pubkey => {
      const address = pubkey.toBase58();
      let keyMeta = keyMetaMap.get(address);
      if (keyMeta === undefined) {
        keyMeta = {
          isSigner: false,
          isWritable: false,
          isInvoked: false
        };
        keyMetaMap.set(address, keyMeta);
      }
      return keyMeta;
    };
    const payerKeyMeta = getOrInsertDefault(payer);
    payerKeyMeta.isSigner = true;
    payerKeyMeta.isWritable = true;
    for (const ix of instructions) {
      getOrInsertDefault(ix.programId).isInvoked = true;
      for (const accountMeta of ix.keys) {
        const keyMeta = getOrInsertDefault(accountMeta.pubkey);
        keyMeta.isSigner || (keyMeta.isSigner = accountMeta.isSigner);
        keyMeta.isWritable || (keyMeta.isWritable = accountMeta.isWritable);
      }
    }
    return new CompiledKeys(payer, keyMetaMap);
  }
  getMessageComponents() {
    const mapEntries = [...this.keyMetaMap.entries()];
    assert(mapEntries.length <= 256, 'Max static account keys length exceeded');
    const writableSigners = mapEntries.filter(([, meta]) => meta.isSigner && meta.isWritable);
    const readonlySigners = mapEntries.filter(([, meta]) => meta.isSigner && !meta.isWritable);
    const writableNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && meta.isWritable);
    const readonlyNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && !meta.isWritable);
    const header = {
      numRequiredSignatures: writableSigners.length + readonlySigners.length,
      numReadonlySignedAccounts: readonlySigners.length,
      numReadonlyUnsignedAccounts: readonlyNonSigners.length
    };

    // sanity checks
    {
      assert(writableSigners.length > 0, 'Expected at least one writable signer key');
      const [payerAddress] = writableSigners[0];
      assert(payerAddress === this.payer.toBase58(), 'Expected first writable signer key to be the fee payer');
    }
    const staticAccountKeys = [...writableSigners.map(([address]) => new PublicKey(address)), ...readonlySigners.map(([address]) => new PublicKey(address)), ...writableNonSigners.map(([address]) => new PublicKey(address)), ...readonlyNonSigners.map(([address]) => new PublicKey(address))];
    return [header, staticAccountKeys];
  }
  extractTableLookup(lookupTable) {
    const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, keyMeta => !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);
    const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, keyMeta => !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);

    // Don't extract lookup if no keys were found
    if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {
      return;
    }
    return [{
      accountKey: lookupTable.key,
      writableIndexes,
      readonlyIndexes
    }, {
      writable: drainedWritableKeys,
      readonly: drainedReadonlyKeys
    }];
  }

  /** @internal */
  drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {
    const lookupTableIndexes = new Array();
    const drainedKeys = new Array();
    for (const [address, keyMeta] of this.keyMetaMap.entries()) {
      if (keyMetaFilter(keyMeta)) {
        const key = new PublicKey(address);
        const lookupTableIndex = lookupTableEntries.findIndex(entry => entry.equals(key));
        if (lookupTableIndex >= 0) {
          assert(lookupTableIndex < 256, 'Max lookup table index exceeded');
          lookupTableIndexes.push(lookupTableIndex);
          drainedKeys.push(key);
          this.keyMetaMap.delete(address);
        }
      }
    }
    return [lookupTableIndexes, drainedKeys];
  }
}

/**
 * An instruction to execute by a program
 *
 * @property {number} programIdIndex
 * @property {number[]} accounts
 * @property {string} data
 */

/**
 * List of instructions to be processed atomically
 */
class Message {
  constructor(args) {
    this.header = void 0;
    this.accountKeys = void 0;
    this.recentBlockhash = void 0;
    this.instructions = void 0;
    this.indexToProgramIds = new Map();
    this.header = args.header;
    this.accountKeys = args.accountKeys.map(account => new PublicKey(account));
    this.recentBlockhash = args.recentBlockhash;
    this.instructions = args.instructions;
    this.instructions.forEach(ix => this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));
  }
  get version() {
    return 'legacy';
  }
  get staticAccountKeys() {
    return this.accountKeys;
  }
  get compiledInstructions() {
    return this.instructions.map(ix => ({
      programIdIndex: ix.programIdIndex,
      accountKeyIndexes: ix.accounts,
      data: bs58__WEBPACK_IMPORTED_MODULE_4___default().decode(ix.data)
    }));
  }
  get addressTableLookups() {
    return [];
  }
  getAccountKeys() {
    return new MessageAccountKeys(this.staticAccountKeys);
  }
  static compile(args) {
    const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
    const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
    const accountKeys = new MessageAccountKeys(staticAccountKeys);
    const instructions = accountKeys.compileInstructions(args.instructions).map(ix => ({
      programIdIndex: ix.programIdIndex,
      accounts: ix.accountKeyIndexes,
      data: bs58__WEBPACK_IMPORTED_MODULE_4___default().encode(ix.data)
    }));
    return new Message({
      header,
      accountKeys: staticAccountKeys,
      recentBlockhash: args.recentBlockhash,
      instructions
    });
  }
  isAccountSigner(index) {
    return index < this.header.numRequiredSignatures;
  }
  isAccountWritable(index) {
    const numSignedAccounts = this.header.numRequiredSignatures;
    if (index >= this.header.numRequiredSignatures) {
      const unsignedAccountIndex = index - numSignedAccounts;
      const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;
      const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
      return unsignedAccountIndex < numWritableUnsignedAccounts;
    } else {
      const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
      return index < numWritableSignedAccounts;
    }
  }
  isProgramId(index) {
    return this.indexToProgramIds.has(index);
  }
  programIds() {
    return [...this.indexToProgramIds.values()];
  }
  nonProgramIds() {
    return this.accountKeys.filter((_, index) => !this.isProgramId(index));
  }
  serialize() {
    const numKeys = this.accountKeys.length;
    let keyCount = [];
    encodeLength(keyCount, numKeys);
    const instructions = this.instructions.map(instruction => {
      const {
        accounts,
        programIdIndex
      } = instruction;
      const data = Array.from(bs58__WEBPACK_IMPORTED_MODULE_4___default().decode(instruction.data));
      let keyIndicesCount = [];
      encodeLength(keyIndicesCount, accounts.length);
      let dataCount = [];
      encodeLength(dataCount, data.length);
      return {
        programIdIndex,
        keyIndicesCount: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(keyIndicesCount),
        keyIndices: accounts,
        dataLength: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(dataCount),
        data
      };
    });
    let instructionCount = [];
    encodeLength(instructionCount, instructions.length);
    let instructionBuffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(PACKET_DATA_SIZE);
    buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(instructionCount).copy(instructionBuffer);
    let instructionBufferLength = instructionCount.length;
    instructions.forEach(instruction => {
      const instructionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__.u8('programIdIndex'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .blob */ .Ik(instruction.keyIndicesCount.length, 'keyIndicesCount'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .seq */ .A9(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__.u8('keyIndex'), instruction.keyIndices.length, 'keyIndices'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .blob */ .Ik(instruction.dataLength.length, 'dataLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .seq */ .A9(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__.u8('userdatum'), instruction.data.length, 'data')]);
      const length = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);
      instructionBufferLength += length;
    });
    instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
    const signDataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .blob */ .Ik(1, 'numRequiredSignatures'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .blob */ .Ik(1, 'numReadonlySignedAccounts'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .blob */ .Ik(1, 'numReadonlyUnsignedAccounts'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .blob */ .Ik(keyCount.length, 'keyCount'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .seq */ .A9(publicKey('key'), numKeys, 'keys'), publicKey('recentBlockhash')]);
    const transaction = {
      numRequiredSignatures: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([this.header.numRequiredSignatures]),
      numReadonlySignedAccounts: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([this.header.numReadonlySignedAccounts]),
      numReadonlyUnsignedAccounts: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
      keyCount: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(keyCount),
      keys: this.accountKeys.map(key => toBuffer(key.toBytes())),
      recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_4___default().decode(this.recentBlockhash)
    };
    let signData = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(2048);
    const length = signDataLayout.encode(transaction, signData);
    instructionBuffer.copy(signData, length);
    return signData.slice(0, length + instructionBuffer.length);
  }

  /**
   * Decode a compiled message into a Message object.
   */
  static from(buffer) {
    // Slice up wire data
    let byteArray = [...buffer];
    const numRequiredSignatures = byteArray.shift();
    if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {
      throw new Error('Versioned messages must be deserialized with VersionedMessage.deserialize()');
    }
    const numReadonlySignedAccounts = byteArray.shift();
    const numReadonlyUnsignedAccounts = byteArray.shift();
    const accountCount = decodeLength(byteArray);
    let accountKeys = [];
    for (let i = 0; i < accountCount; i++) {
      const account = byteArray.slice(0, PUBLIC_KEY_LENGTH);
      byteArray = byteArray.slice(PUBLIC_KEY_LENGTH);
      accountKeys.push(new PublicKey(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(account)));
    }
    const recentBlockhash = byteArray.slice(0, PUBLIC_KEY_LENGTH);
    byteArray = byteArray.slice(PUBLIC_KEY_LENGTH);
    const instructionCount = decodeLength(byteArray);
    let instructions = [];
    for (let i = 0; i < instructionCount; i++) {
      const programIdIndex = byteArray.shift();
      const accountCount = decodeLength(byteArray);
      const accounts = byteArray.slice(0, accountCount);
      byteArray = byteArray.slice(accountCount);
      const dataLength = decodeLength(byteArray);
      const dataSlice = byteArray.slice(0, dataLength);
      const data = bs58__WEBPACK_IMPORTED_MODULE_4___default().encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(dataSlice));
      byteArray = byteArray.slice(dataLength);
      instructions.push({
        programIdIndex,
        accounts,
        data
      });
    }
    const messageArgs = {
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_4___default().encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(recentBlockhash)),
      accountKeys,
      instructions
    };
    return new Message(messageArgs);
  }
}

/**
 * Message constructor arguments
 */

class MessageV0 {
  constructor(args) {
    this.header = void 0;
    this.staticAccountKeys = void 0;
    this.recentBlockhash = void 0;
    this.compiledInstructions = void 0;
    this.addressTableLookups = void 0;
    this.header = args.header;
    this.staticAccountKeys = args.staticAccountKeys;
    this.recentBlockhash = args.recentBlockhash;
    this.compiledInstructions = args.compiledInstructions;
    this.addressTableLookups = args.addressTableLookups;
  }
  get version() {
    return 0;
  }
  get numAccountKeysFromLookups() {
    let count = 0;
    for (const lookup of this.addressTableLookups) {
      count += lookup.readonlyIndexes.length + lookup.writableIndexes.length;
    }
    return count;
  }
  getAccountKeys(args) {
    let accountKeysFromLookups;
    if (args && 'accountKeysFromLookups' in args && args.accountKeysFromLookups) {
      if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) {
        throw new Error('Failed to get account keys because of a mismatch in the number of account keys from lookups');
      }
      accountKeysFromLookups = args.accountKeysFromLookups;
    } else if (args && 'addressLookupTableAccounts' in args && args.addressLookupTableAccounts) {
      accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);
    } else if (this.addressTableLookups.length > 0) {
      throw new Error('Failed to get account keys because address table lookups were not resolved');
    }
    return new MessageAccountKeys(this.staticAccountKeys, accountKeysFromLookups);
  }
  isAccountSigner(index) {
    return index < this.header.numRequiredSignatures;
  }
  isAccountWritable(index) {
    const numSignedAccounts = this.header.numRequiredSignatures;
    const numStaticAccountKeys = this.staticAccountKeys.length;
    if (index >= numStaticAccountKeys) {
      const lookupAccountKeysIndex = index - numStaticAccountKeys;
      const numWritableLookupAccountKeys = this.addressTableLookups.reduce((count, lookup) => count + lookup.writableIndexes.length, 0);
      return lookupAccountKeysIndex < numWritableLookupAccountKeys;
    } else if (index >= this.header.numRequiredSignatures) {
      const unsignedAccountIndex = index - numSignedAccounts;
      const numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;
      const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
      return unsignedAccountIndex < numWritableUnsignedAccounts;
    } else {
      const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
      return index < numWritableSignedAccounts;
    }
  }
  resolveAddressTableLookups(addressLookupTableAccounts) {
    const accountKeysFromLookups = {
      writable: [],
      readonly: []
    };
    for (const tableLookup of this.addressTableLookups) {
      const tableAccount = addressLookupTableAccounts.find(account => account.key.equals(tableLookup.accountKey));
      if (!tableAccount) {
        throw new Error(`Failed to find address lookup table account for table key ${tableLookup.accountKey.toBase58()}`);
      }
      for (const index of tableLookup.writableIndexes) {
        if (index < tableAccount.state.addresses.length) {
          accountKeysFromLookups.writable.push(tableAccount.state.addresses[index]);
        } else {
          throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);
        }
      }
      for (const index of tableLookup.readonlyIndexes) {
        if (index < tableAccount.state.addresses.length) {
          accountKeysFromLookups.readonly.push(tableAccount.state.addresses[index]);
        } else {
          throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);
        }
      }
    }
    return accountKeysFromLookups;
  }
  static compile(args) {
    const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
    const addressTableLookups = new Array();
    const accountKeysFromLookups = {
      writable: new Array(),
      readonly: new Array()
    };
    const lookupTableAccounts = args.addressLookupTableAccounts || [];
    for (const lookupTable of lookupTableAccounts) {
      const extractResult = compiledKeys.extractTableLookup(lookupTable);
      if (extractResult !== undefined) {
        const [addressTableLookup, {
          writable,
          readonly
        }] = extractResult;
        addressTableLookups.push(addressTableLookup);
        accountKeysFromLookups.writable.push(...writable);
        accountKeysFromLookups.readonly.push(...readonly);
      }
    }
    const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
    const accountKeys = new MessageAccountKeys(staticAccountKeys, accountKeysFromLookups);
    const compiledInstructions = accountKeys.compileInstructions(args.instructions);
    return new MessageV0({
      header,
      staticAccountKeys,
      recentBlockhash: args.recentBlockhash,
      compiledInstructions,
      addressTableLookups
    });
  }
  serialize() {
    const encodedStaticAccountKeysLength = Array();
    encodeLength(encodedStaticAccountKeysLength, this.staticAccountKeys.length);
    const serializedInstructions = this.serializeInstructions();
    const encodedInstructionsLength = Array();
    encodeLength(encodedInstructionsLength, this.compiledInstructions.length);
    const serializedAddressTableLookups = this.serializeAddressTableLookups();
    const encodedAddressTableLookupsLength = Array();
    encodeLength(encodedAddressTableLookupsLength, this.addressTableLookups.length);
    const messageLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__.u8('prefix'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__.u8('numRequiredSignatures'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__.u8('numReadonlySignedAccounts'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__.u8('numReadonlyUnsignedAccounts')], 'header'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .blob */ .Ik(encodedStaticAccountKeysLength.length, 'staticAccountKeysLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .seq */ .A9(publicKey(), this.staticAccountKeys.length, 'staticAccountKeys'), publicKey('recentBlockhash'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .blob */ .Ik(encodedInstructionsLength.length, 'instructionsLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .blob */ .Ik(serializedInstructions.length, 'serializedInstructions'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .blob */ .Ik(encodedAddressTableLookupsLength.length, 'addressTableLookupsLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .blob */ .Ik(serializedAddressTableLookups.length, 'serializedAddressTableLookups')]);
    const serializedMessage = new Uint8Array(PACKET_DATA_SIZE);
    const MESSAGE_VERSION_0_PREFIX = 1 << 7;
    const serializedMessageLength = messageLayout.encode({
      prefix: MESSAGE_VERSION_0_PREFIX,
      header: this.header,
      staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),
      staticAccountKeys: this.staticAccountKeys.map(key => key.toBytes()),
      recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_4___default().decode(this.recentBlockhash),
      instructionsLength: new Uint8Array(encodedInstructionsLength),
      serializedInstructions,
      addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),
      serializedAddressTableLookups
    }, serializedMessage);
    return serializedMessage.slice(0, serializedMessageLength);
  }
  serializeInstructions() {
    let serializedLength = 0;
    const serializedInstructions = new Uint8Array(PACKET_DATA_SIZE);
    for (const instruction of this.compiledInstructions) {
      const encodedAccountKeyIndexesLength = Array();
      encodeLength(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);
      const encodedDataLength = Array();
      encodeLength(encodedDataLength, instruction.data.length);
      const instructionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__.u8('programIdIndex'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .blob */ .Ik(encodedAccountKeyIndexesLength.length, 'encodedAccountKeyIndexesLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .seq */ .A9(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__.u8(), instruction.accountKeyIndexes.length, 'accountKeyIndexes'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .blob */ .Ik(encodedDataLength.length, 'encodedDataLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .blob */ .Ik(instruction.data.length, 'data')]);
      serializedLength += instructionLayout.encode({
        programIdIndex: instruction.programIdIndex,
        encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),
        accountKeyIndexes: instruction.accountKeyIndexes,
        encodedDataLength: new Uint8Array(encodedDataLength),
        data: instruction.data
      }, serializedInstructions, serializedLength);
    }
    return serializedInstructions.slice(0, serializedLength);
  }
  serializeAddressTableLookups() {
    let serializedLength = 0;
    const serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE);
    for (const lookup of this.addressTableLookups) {
      const encodedWritableIndexesLength = Array();
      encodeLength(encodedWritableIndexesLength, lookup.writableIndexes.length);
      const encodedReadonlyIndexesLength = Array();
      encodeLength(encodedReadonlyIndexesLength, lookup.readonlyIndexes.length);
      const addressTableLookupLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([publicKey('accountKey'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .blob */ .Ik(encodedWritableIndexesLength.length, 'encodedWritableIndexesLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .seq */ .A9(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__.u8(), lookup.writableIndexes.length, 'writableIndexes'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .blob */ .Ik(encodedReadonlyIndexesLength.length, 'encodedReadonlyIndexesLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .seq */ .A9(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__.u8(), lookup.readonlyIndexes.length, 'readonlyIndexes')]);
      serializedLength += addressTableLookupLayout.encode({
        accountKey: lookup.accountKey.toBytes(),
        encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),
        writableIndexes: lookup.writableIndexes,
        encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),
        readonlyIndexes: lookup.readonlyIndexes
      }, serializedAddressTableLookups, serializedLength);
    }
    return serializedAddressTableLookups.slice(0, serializedLength);
  }
  static deserialize(serializedMessage) {
    let byteArray = [...serializedMessage];
    const prefix = byteArray.shift();
    const maskedPrefix = prefix & VERSION_PREFIX_MASK;
    assert(prefix !== maskedPrefix, `Expected versioned message but received legacy message`);
    const version = maskedPrefix;
    assert(version === 0, `Expected versioned message with version 0 but found version ${version}`);
    const header = {
      numRequiredSignatures: byteArray.shift(),
      numReadonlySignedAccounts: byteArray.shift(),
      numReadonlyUnsignedAccounts: byteArray.shift()
    };
    const staticAccountKeys = [];
    const staticAccountKeysLength = decodeLength(byteArray);
    for (let i = 0; i < staticAccountKeysLength; i++) {
      staticAccountKeys.push(new PublicKey(byteArray.splice(0, PUBLIC_KEY_LENGTH)));
    }
    const recentBlockhash = bs58__WEBPACK_IMPORTED_MODULE_4___default().encode(byteArray.splice(0, PUBLIC_KEY_LENGTH));
    const instructionCount = decodeLength(byteArray);
    const compiledInstructions = [];
    for (let i = 0; i < instructionCount; i++) {
      const programIdIndex = byteArray.shift();
      const accountKeyIndexesLength = decodeLength(byteArray);
      const accountKeyIndexes = byteArray.splice(0, accountKeyIndexesLength);
      const dataLength = decodeLength(byteArray);
      const data = new Uint8Array(byteArray.splice(0, dataLength));
      compiledInstructions.push({
        programIdIndex,
        accountKeyIndexes,
        data
      });
    }
    const addressTableLookupsCount = decodeLength(byteArray);
    const addressTableLookups = [];
    for (let i = 0; i < addressTableLookupsCount; i++) {
      const accountKey = new PublicKey(byteArray.splice(0, PUBLIC_KEY_LENGTH));
      const writableIndexesLength = decodeLength(byteArray);
      const writableIndexes = byteArray.splice(0, writableIndexesLength);
      const readonlyIndexesLength = decodeLength(byteArray);
      const readonlyIndexes = byteArray.splice(0, readonlyIndexesLength);
      addressTableLookups.push({
        accountKey,
        writableIndexes,
        readonlyIndexes
      });
    }
    return new MessageV0({
      header,
      staticAccountKeys,
      recentBlockhash,
      compiledInstructions,
      addressTableLookups
    });
  }
}

// eslint-disable-next-line no-redeclare
const VersionedMessage = {
  deserializeMessageVersion(serializedMessage) {
    const prefix = serializedMessage[0];
    const maskedPrefix = prefix & VERSION_PREFIX_MASK;

    // if the highest bit of the prefix is not set, the message is not versioned
    if (maskedPrefix === prefix) {
      return 'legacy';
    }

    // the lower 7 bits of the prefix indicate the message version
    return maskedPrefix;
  },
  deserialize: serializedMessage => {
    const version = VersionedMessage.deserializeMessageVersion(serializedMessage);
    if (version === 'legacy') {
      return Message.from(serializedMessage);
    }
    if (version === 0) {
      return MessageV0.deserialize(serializedMessage);
    } else {
      throw new Error(`Transaction message version ${version} deserialization is not supported`);
    }
  }
};

/**
 * Transaction signature as base-58 encoded string
 */

let TransactionStatus;

/**
 * Default (empty) signature
 */
(function (TransactionStatus) {
  TransactionStatus[TransactionStatus["BLOCKHEIGHT_EXCEEDED"] = 0] = "BLOCKHEIGHT_EXCEEDED";
  TransactionStatus[TransactionStatus["PROCESSED"] = 1] = "PROCESSED";
  TransactionStatus[TransactionStatus["TIMED_OUT"] = 2] = "TIMED_OUT";
  TransactionStatus[TransactionStatus["NONCE_INVALID"] = 3] = "NONCE_INVALID";
})(TransactionStatus || (TransactionStatus = {}));
const DEFAULT_SIGNATURE = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);

/**
 * Account metadata used to define instructions
 */

/**
 * Transaction Instruction class
 */
class TransactionInstruction {
  /**
   * Public keys to include in this transaction
   * Boolean represents whether this pubkey needs to sign the transaction
   */

  /**
   * Program Id to execute
   */

  /**
   * Program input
   */

  constructor(opts) {
    this.keys = void 0;
    this.programId = void 0;
    this.data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(0);
    this.programId = opts.programId;
    this.keys = opts.keys;
    if (opts.data) {
      this.data = opts.data;
    }
  }

  /**
   * @internal
   */
  toJSON() {
    return {
      keys: this.keys.map(({
        pubkey,
        isSigner,
        isWritable
      }) => ({
        pubkey: pubkey.toJSON(),
        isSigner,
        isWritable
      })),
      programId: this.programId.toJSON(),
      data: [...this.data]
    };
  }
}

/**
 * Pair of signature and corresponding public key
 */

/**
 * Transaction class
 */
class Transaction {
  /**
   * Signatures for the transaction.  Typically created by invoking the
   * `sign()` method
   */

  /**
   * The first (payer) Transaction signature
   */
  get signature() {
    if (this.signatures.length > 0) {
      return this.signatures[0].signature;
    }
    return null;
  }

  /**
   * The transaction fee payer
   */

  /**
   * Construct an empty Transaction
   */
  constructor(opts) {
    this.signatures = [];
    this.feePayer = void 0;
    this.instructions = [];
    this.recentBlockhash = void 0;
    this.lastValidBlockHeight = void 0;
    this.nonceInfo = void 0;
    this.minNonceContextSlot = void 0;
    this._message = void 0;
    this._json = void 0;
    if (!opts) {
      return;
    }
    if (opts.feePayer) {
      this.feePayer = opts.feePayer;
    }
    if (opts.signatures) {
      this.signatures = opts.signatures;
    }
    if (Object.prototype.hasOwnProperty.call(opts, 'nonceInfo')) {
      const {
        minContextSlot,
        nonceInfo
      } = opts;
      this.minNonceContextSlot = minContextSlot;
      this.nonceInfo = nonceInfo;
    } else if (Object.prototype.hasOwnProperty.call(opts, 'lastValidBlockHeight')) {
      const {
        blockhash,
        lastValidBlockHeight
      } = opts;
      this.recentBlockhash = blockhash;
      this.lastValidBlockHeight = lastValidBlockHeight;
    } else {
      const {
        recentBlockhash,
        nonceInfo
      } = opts;
      if (nonceInfo) {
        this.nonceInfo = nonceInfo;
      }
      this.recentBlockhash = recentBlockhash;
    }
  }

  /**
   * @internal
   */
  toJSON() {
    return {
      recentBlockhash: this.recentBlockhash || null,
      feePayer: this.feePayer ? this.feePayer.toJSON() : null,
      nonceInfo: this.nonceInfo ? {
        nonce: this.nonceInfo.nonce,
        nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
      } : null,
      instructions: this.instructions.map(instruction => instruction.toJSON()),
      signers: this.signatures.map(({
        publicKey
      }) => {
        return publicKey.toJSON();
      })
    };
  }

  /**
   * Add one or more instructions to this Transaction
   */
  add(...items) {
    if (items.length === 0) {
      throw new Error('No instructions');
    }
    items.forEach(item => {
      if ('instructions' in item) {
        this.instructions = this.instructions.concat(item.instructions);
      } else if ('data' in item && 'programId' in item && 'keys' in item) {
        this.instructions.push(item);
      } else {
        this.instructions.push(new TransactionInstruction(item));
      }
    });
    return this;
  }

  /**
   * Compile transaction data
   */
  compileMessage() {
    if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {
      return this._message;
    }
    let recentBlockhash;
    let instructions;
    if (this.nonceInfo) {
      recentBlockhash = this.nonceInfo.nonce;
      if (this.instructions[0] != this.nonceInfo.nonceInstruction) {
        instructions = [this.nonceInfo.nonceInstruction, ...this.instructions];
      } else {
        instructions = this.instructions;
      }
    } else {
      recentBlockhash = this.recentBlockhash;
      instructions = this.instructions;
    }
    if (!recentBlockhash) {
      throw new Error('Transaction recentBlockhash required');
    }
    if (instructions.length < 1) {
      console.warn('No instructions provided');
    }
    let feePayer;
    if (this.feePayer) {
      feePayer = this.feePayer;
    } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {
      // Use implicit fee payer
      feePayer = this.signatures[0].publicKey;
    } else {
      throw new Error('Transaction fee payer required');
    }
    for (let i = 0; i < instructions.length; i++) {
      if (instructions[i].programId === undefined) {
        throw new Error(`Transaction instruction index ${i} has undefined program id`);
      }
    }
    const programIds = [];
    const accountMetas = [];
    instructions.forEach(instruction => {
      instruction.keys.forEach(accountMeta => {
        accountMetas.push({
          ...accountMeta
        });
      });
      const programId = instruction.programId.toString();
      if (!programIds.includes(programId)) {
        programIds.push(programId);
      }
    });

    // Append programID account metas
    programIds.forEach(programId => {
      accountMetas.push({
        pubkey: new PublicKey(programId),
        isSigner: false,
        isWritable: false
      });
    });

    // Cull duplicate account metas
    const uniqueMetas = [];
    accountMetas.forEach(accountMeta => {
      const pubkeyString = accountMeta.pubkey.toString();
      const uniqueIndex = uniqueMetas.findIndex(x => {
        return x.pubkey.toString() === pubkeyString;
      });
      if (uniqueIndex > -1) {
        uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;
        uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;
      } else {
        uniqueMetas.push(accountMeta);
      }
    });

    // Sort. Prioritizing first by signer, then by writable
    uniqueMetas.sort(function (x, y) {
      if (x.isSigner !== y.isSigner) {
        // Signers always come before non-signers
        return x.isSigner ? -1 : 1;
      }
      if (x.isWritable !== y.isWritable) {
        // Writable accounts always come before read-only accounts
        return x.isWritable ? -1 : 1;
      }
      // Otherwise, sort by pubkey, stringwise.
      return x.pubkey.toBase58().localeCompare(y.pubkey.toBase58());
    });

    // Move fee payer to the front
    const feePayerIndex = uniqueMetas.findIndex(x => {
      return x.pubkey.equals(feePayer);
    });
    if (feePayerIndex > -1) {
      const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);
      payerMeta.isSigner = true;
      payerMeta.isWritable = true;
      uniqueMetas.unshift(payerMeta);
    } else {
      uniqueMetas.unshift({
        pubkey: feePayer,
        isSigner: true,
        isWritable: true
      });
    }

    // Disallow unknown signers
    for (const signature of this.signatures) {
      const uniqueIndex = uniqueMetas.findIndex(x => {
        return x.pubkey.equals(signature.publicKey);
      });
      if (uniqueIndex > -1) {
        if (!uniqueMetas[uniqueIndex].isSigner) {
          uniqueMetas[uniqueIndex].isSigner = true;
          console.warn('Transaction references a signature that is unnecessary, ' + 'only the fee payer and instruction signer accounts should sign a transaction. ' + 'This behavior is deprecated and will throw an error in the next major version release.');
        }
      } else {
        throw new Error(`unknown signer: ${signature.publicKey.toString()}`);
      }
    }
    let numRequiredSignatures = 0;
    let numReadonlySignedAccounts = 0;
    let numReadonlyUnsignedAccounts = 0;

    // Split out signing from non-signing keys and count header values
    const signedKeys = [];
    const unsignedKeys = [];
    uniqueMetas.forEach(({
      pubkey,
      isSigner,
      isWritable
    }) => {
      if (isSigner) {
        signedKeys.push(pubkey.toString());
        numRequiredSignatures += 1;
        if (!isWritable) {
          numReadonlySignedAccounts += 1;
        }
      } else {
        unsignedKeys.push(pubkey.toString());
        if (!isWritable) {
          numReadonlyUnsignedAccounts += 1;
        }
      }
    });
    const accountKeys = signedKeys.concat(unsignedKeys);
    const compiledInstructions = instructions.map(instruction => {
      const {
        data,
        programId
      } = instruction;
      return {
        programIdIndex: accountKeys.indexOf(programId.toString()),
        accounts: instruction.keys.map(meta => accountKeys.indexOf(meta.pubkey.toString())),
        data: bs58__WEBPACK_IMPORTED_MODULE_4___default().encode(data)
      };
    });
    compiledInstructions.forEach(instruction => {
      assert(instruction.programIdIndex >= 0);
      instruction.accounts.forEach(keyIndex => assert(keyIndex >= 0));
    });
    return new Message({
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      accountKeys,
      recentBlockhash,
      instructions: compiledInstructions
    });
  }

  /**
   * @internal
   */
  _compile() {
    const message = this.compileMessage();
    const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);
    if (this.signatures.length === signedKeys.length) {
      const valid = this.signatures.every((pair, index) => {
        return signedKeys[index].equals(pair.publicKey);
      });
      if (valid) return message;
    }
    this.signatures = signedKeys.map(publicKey => ({
      signature: null,
      publicKey
    }));
    return message;
  }

  /**
   * Get a buffer of the Transaction data that need to be covered by signatures
   */
  serializeMessage() {
    return this._compile().serialize();
  }

  /**
   * Get the estimated fee associated with a transaction
   */
  async getEstimatedFee(connection) {
    return (await connection.getFeeForMessage(this.compileMessage())).value;
  }

  /**
   * Specify the public keys which will be used to sign the Transaction.
   * The first signer will be used as the transaction fee payer account.
   *
   * Signatures can be added with either `partialSign` or `addSignature`
   *
   * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be
   * specified and it can be set in the Transaction constructor or with the
   * `feePayer` property.
   */
  setSigners(...signers) {
    if (signers.length === 0) {
      throw new Error('No signers');
    }
    const seen = new Set();
    this.signatures = signers.filter(publicKey => {
      const key = publicKey.toString();
      if (seen.has(key)) {
        return false;
      } else {
        seen.add(key);
        return true;
      }
    }).map(publicKey => ({
      signature: null,
      publicKey
    }));
  }

  /**
   * Sign the Transaction with the specified signers. Multiple signatures may
   * be applied to a Transaction. The first signature is considered "primary"
   * and is used identify and confirm transactions.
   *
   * If the Transaction `feePayer` is not set, the first signer will be used
   * as the transaction fee payer account.
   *
   * Transaction fields should not be modified after the first call to `sign`,
   * as doing so may invalidate the signature and cause the Transaction to be
   * rejected.
   *
   * The Transaction must be assigned a valid `recentBlockhash` before invoking this method
   */
  sign(...signers) {
    if (signers.length === 0) {
      throw new Error('No signers');
    }

    // Dedupe signers
    const seen = new Set();
    const uniqueSigners = [];
    for (const signer of signers) {
      const key = signer.publicKey.toString();
      if (seen.has(key)) {
        continue;
      } else {
        seen.add(key);
        uniqueSigners.push(signer);
      }
    }
    this.signatures = uniqueSigners.map(signer => ({
      signature: null,
      publicKey: signer.publicKey
    }));
    const message = this._compile();
    this._partialSign(message, ...uniqueSigners);
  }

  /**
   * Partially sign a transaction with the specified accounts. All accounts must
   * correspond to either the fee payer or a signer account in the transaction
   * instructions.
   *
   * All the caveats from the `sign` method apply to `partialSign`
   */
  partialSign(...signers) {
    if (signers.length === 0) {
      throw new Error('No signers');
    }

    // Dedupe signers
    const seen = new Set();
    const uniqueSigners = [];
    for (const signer of signers) {
      const key = signer.publicKey.toString();
      if (seen.has(key)) {
        continue;
      } else {
        seen.add(key);
        uniqueSigners.push(signer);
      }
    }
    const message = this._compile();
    this._partialSign(message, ...uniqueSigners);
  }

  /**
   * @internal
   */
  _partialSign(message, ...signers) {
    const signData = message.serialize();
    signers.forEach(signer => {
      const signature = sign(signData, signer.secretKey);
      this._addSignature(signer.publicKey, toBuffer(signature));
    });
  }

  /**
   * Add an externally created signature to a transaction. The public key
   * must correspond to either the fee payer or a signer account in the transaction
   * instructions.
   */
  addSignature(pubkey, signature) {
    this._compile(); // Ensure signatures array is populated
    this._addSignature(pubkey, signature);
  }

  /**
   * @internal
   */
  _addSignature(pubkey, signature) {
    assert(signature.length === 64);
    const index = this.signatures.findIndex(sigpair => pubkey.equals(sigpair.publicKey));
    if (index < 0) {
      throw new Error(`unknown signer: ${pubkey.toString()}`);
    }
    this.signatures[index].signature = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signature);
  }

  /**
   * Verify signatures of a Transaction
   * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.
   * If no boolean is provided, we expect a fully signed Transaction by default.
   */
  verifySignatures(requireAllSignatures) {
    return this._verifySignatures(this.serializeMessage(), requireAllSignatures === undefined ? true : requireAllSignatures);
  }

  /**
   * @internal
   */
  _verifySignatures(signData, requireAllSignatures) {
    for (const {
      signature,
      publicKey
    } of this.signatures) {
      if (signature === null) {
        if (requireAllSignatures) {
          return false;
        }
      } else {
        if (!verify(signature, signData, publicKey.toBytes())) {
          return false;
        }
      }
    }
    return true;
  }

  /**
   * Serialize the Transaction in the wire format.
   */
  serialize(config) {
    const {
      requireAllSignatures,
      verifySignatures
    } = Object.assign({
      requireAllSignatures: true,
      verifySignatures: true
    }, config);
    const signData = this.serializeMessage();
    if (verifySignatures && !this._verifySignatures(signData, requireAllSignatures)) {
      throw new Error('Signature verification failed');
    }
    return this._serialize(signData);
  }

  /**
   * @internal
   */
  _serialize(signData) {
    const {
      signatures
    } = this;
    const signatureCount = [];
    encodeLength(signatureCount, signatures.length);
    const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
    const wireTransaction = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(transactionLength);
    assert(signatures.length < 256);
    buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signatureCount).copy(wireTransaction, 0);
    signatures.forEach(({
      signature
    }, index) => {
      if (signature !== null) {
        assert(signature.length === 64, `signature has invalid length`);
        buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signature).copy(wireTransaction, signatureCount.length + index * 64);
      }
    });
    signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
    assert(wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);
    return wireTransaction;
  }

  /**
   * Deprecated method
   * @internal
   */
  get keys() {
    assert(this.instructions.length === 1);
    return this.instructions[0].keys.map(keyObj => keyObj.pubkey);
  }

  /**
   * Deprecated method
   * @internal
   */
  get programId() {
    assert(this.instructions.length === 1);
    return this.instructions[0].programId;
  }

  /**
   * Deprecated method
   * @internal
   */
  get data() {
    assert(this.instructions.length === 1);
    return this.instructions[0].data;
  }

  /**
   * Parse a wire transaction into a Transaction object.
   */
  static from(buffer) {
    // Slice up wire data
    let byteArray = [...buffer];
    const signatureCount = decodeLength(byteArray);
    let signatures = [];
    for (let i = 0; i < signatureCount; i++) {
      const signature = byteArray.slice(0, SIGNATURE_LENGTH_IN_BYTES);
      byteArray = byteArray.slice(SIGNATURE_LENGTH_IN_BYTES);
      signatures.push(bs58__WEBPACK_IMPORTED_MODULE_4___default().encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signature)));
    }
    return Transaction.populate(Message.from(byteArray), signatures);
  }

  /**
   * Populate Transaction object from message and signatures
   */
  static populate(message, signatures = []) {
    const transaction = new Transaction();
    transaction.recentBlockhash = message.recentBlockhash;
    if (message.header.numRequiredSignatures > 0) {
      transaction.feePayer = message.accountKeys[0];
    }
    signatures.forEach((signature, index) => {
      const sigPubkeyPair = {
        signature: signature == bs58__WEBPACK_IMPORTED_MODULE_4___default().encode(DEFAULT_SIGNATURE) ? null : bs58__WEBPACK_IMPORTED_MODULE_4___default().decode(signature),
        publicKey: message.accountKeys[index]
      };
      transaction.signatures.push(sigPubkeyPair);
    });
    message.instructions.forEach(instruction => {
      const keys = instruction.accounts.map(account => {
        const pubkey = message.accountKeys[account];
        return {
          pubkey,
          isSigner: transaction.signatures.some(keyObj => keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account),
          isWritable: message.isAccountWritable(account)
        };
      });
      transaction.instructions.push(new TransactionInstruction({
        keys,
        programId: message.accountKeys[instruction.programIdIndex],
        data: bs58__WEBPACK_IMPORTED_MODULE_4___default().decode(instruction.data)
      }));
    });
    transaction._message = message;
    transaction._json = transaction.toJSON();
    return transaction;
  }
}

class TransactionMessage {
  constructor(args) {
    this.payerKey = void 0;
    this.instructions = void 0;
    this.recentBlockhash = void 0;
    this.payerKey = args.payerKey;
    this.instructions = args.instructions;
    this.recentBlockhash = args.recentBlockhash;
  }
  static decompile(message, args) {
    const {
      header,
      compiledInstructions,
      recentBlockhash
    } = message;
    const {
      numRequiredSignatures,
      numReadonlySignedAccounts,
      numReadonlyUnsignedAccounts
    } = header;
    const numWritableSignedAccounts = numRequiredSignatures - numReadonlySignedAccounts;
    assert(numWritableSignedAccounts > 0, 'Message header is invalid');
    const numWritableUnsignedAccounts = message.staticAccountKeys.length - numRequiredSignatures - numReadonlyUnsignedAccounts;
    assert(numWritableUnsignedAccounts >= 0, 'Message header is invalid');
    const accountKeys = message.getAccountKeys(args);
    const payerKey = accountKeys.get(0);
    if (payerKey === undefined) {
      throw new Error('Failed to decompile message because no account keys were found');
    }
    const instructions = [];
    for (const compiledIx of compiledInstructions) {
      const keys = [];
      for (const keyIndex of compiledIx.accountKeyIndexes) {
        const pubkey = accountKeys.get(keyIndex);
        if (pubkey === undefined) {
          throw new Error(`Failed to find key for account key index ${keyIndex}`);
        }
        const isSigner = keyIndex < numRequiredSignatures;
        let isWritable;
        if (isSigner) {
          isWritable = keyIndex < numWritableSignedAccounts;
        } else if (keyIndex < accountKeys.staticAccountKeys.length) {
          isWritable = keyIndex - numRequiredSignatures < numWritableUnsignedAccounts;
        } else {
          isWritable = keyIndex - accountKeys.staticAccountKeys.length <
          // accountKeysFromLookups cannot be undefined because we already found a pubkey for this index above
          accountKeys.accountKeysFromLookups.writable.length;
        }
        keys.push({
          pubkey,
          isSigner: keyIndex < header.numRequiredSignatures,
          isWritable
        });
      }
      const programId = accountKeys.get(compiledIx.programIdIndex);
      if (programId === undefined) {
        throw new Error(`Failed to find program id for program id index ${compiledIx.programIdIndex}`);
      }
      instructions.push(new TransactionInstruction({
        programId,
        data: toBuffer(compiledIx.data),
        keys
      }));
    }
    return new TransactionMessage({
      payerKey,
      instructions,
      recentBlockhash
    });
  }
  compileToLegacyMessage() {
    return Message.compile({
      payerKey: this.payerKey,
      recentBlockhash: this.recentBlockhash,
      instructions: this.instructions
    });
  }
  compileToV0Message(addressLookupTableAccounts) {
    return MessageV0.compile({
      payerKey: this.payerKey,
      recentBlockhash: this.recentBlockhash,
      instructions: this.instructions,
      addressLookupTableAccounts
    });
  }
}

/**
 * Versioned transaction class
 */
class VersionedTransaction {
  get version() {
    return this.message.version;
  }
  constructor(message, signatures) {
    this.signatures = void 0;
    this.message = void 0;
    if (signatures !== undefined) {
      assert(signatures.length === message.header.numRequiredSignatures, 'Expected signatures length to be equal to the number of required signatures');
      this.signatures = signatures;
    } else {
      const defaultSignatures = [];
      for (let i = 0; i < message.header.numRequiredSignatures; i++) {
        defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));
      }
      this.signatures = defaultSignatures;
    }
    this.message = message;
  }
  serialize() {
    const serializedMessage = this.message.serialize();
    const encodedSignaturesLength = Array();
    encodeLength(encodedSignaturesLength, this.signatures.length);
    const transactionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .blob */ .Ik(encodedSignaturesLength.length, 'encodedSignaturesLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .seq */ .A9(signature(), this.signatures.length, 'signatures'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .blob */ .Ik(serializedMessage.length, 'serializedMessage')]);
    const serializedTransaction = new Uint8Array(2048);
    const serializedTransactionLength = transactionLayout.encode({
      encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),
      signatures: this.signatures,
      serializedMessage
    }, serializedTransaction);
    return serializedTransaction.slice(0, serializedTransactionLength);
  }
  static deserialize(serializedTransaction) {
    let byteArray = [...serializedTransaction];
    const signatures = [];
    const signaturesLength = decodeLength(byteArray);
    for (let i = 0; i < signaturesLength; i++) {
      signatures.push(new Uint8Array(byteArray.splice(0, SIGNATURE_LENGTH_IN_BYTES)));
    }
    const message = VersionedMessage.deserialize(new Uint8Array(byteArray));
    return new VersionedTransaction(message, signatures);
  }
  sign(signers) {
    const messageData = this.message.serialize();
    const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
    for (const signer of signers) {
      const signerIndex = signerPubkeys.findIndex(pubkey => pubkey.equals(signer.publicKey));
      assert(signerIndex >= 0, `Cannot sign with non signer key ${signer.publicKey.toBase58()}`);
      this.signatures[signerIndex] = sign(messageData, signer.secretKey);
    }
  }
  addSignature(publicKey, signature) {
    assert(signature.byteLength === 64, 'Signature must be 64 bytes long');
    const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
    const signerIndex = signerPubkeys.findIndex(pubkey => pubkey.equals(publicKey));
    assert(signerIndex >= 0, `Can not add signature; \`${publicKey.toBase58()}\` is not required to sign this transaction`);
    this.signatures[signerIndex] = signature;
  }
}

const SYSVAR_CLOCK_PUBKEY = new PublicKey('SysvarC1ock11111111111111111111111111111111');
const SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey('SysvarEpochSchedu1e111111111111111111111111');
const SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey('Sysvar1nstructions1111111111111111111111111');
const SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey('SysvarRecentB1ockHashes11111111111111111111');
const SYSVAR_RENT_PUBKEY = new PublicKey('SysvarRent111111111111111111111111111111111');
const SYSVAR_REWARDS_PUBKEY = new PublicKey('SysvarRewards111111111111111111111111111111');
const SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey('SysvarS1otHashes111111111111111111111111111');
const SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey('SysvarS1otHistory11111111111111111111111111');
const SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey('SysvarStakeHistory1111111111111111111111111');

/**
 * Sign, send and confirm a transaction.
 *
 * If `commitment` option is not specified, defaults to 'max' commitment.
 *
 * @param {Connection} connection
 * @param {Transaction} transaction
 * @param {Array<Signer>} signers
 * @param {ConfirmOptions} [options]
 * @returns {Promise<TransactionSignature>}
 */
async function sendAndConfirmTransaction(connection, transaction, signers, options) {
  const sendOptions = options && {
    skipPreflight: options.skipPreflight,
    preflightCommitment: options.preflightCommitment || options.commitment,
    maxRetries: options.maxRetries,
    minContextSlot: options.minContextSlot
  };
  const signature = await connection.sendTransaction(transaction, signers, sendOptions);
  let status;
  if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {
    status = (await connection.confirmTransaction({
      abortSignal: options?.abortSignal,
      signature: signature,
      blockhash: transaction.recentBlockhash,
      lastValidBlockHeight: transaction.lastValidBlockHeight
    }, options && options.commitment)).value;
  } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {
    const {
      nonceInstruction
    } = transaction.nonceInfo;
    const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;
    status = (await connection.confirmTransaction({
      abortSignal: options?.abortSignal,
      minContextSlot: transaction.minNonceContextSlot,
      nonceAccountPubkey,
      nonceValue: transaction.nonceInfo.nonce,
      signature
    }, options && options.commitment)).value;
  } else {
    if (options?.abortSignal != null) {
      console.warn('sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was ' + 'supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` ' + 'or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.');
    }
    status = (await connection.confirmTransaction(signature, options && options.commitment)).value;
  }
  if (status.err) {
    throw new Error(`Transaction ${signature} failed (${JSON.stringify(status)})`);
  }
  return signature;
}

// zzz
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Populate a buffer of instruction data using an InstructionType
 * @internal
 */
function encodeData(type, fields) {
  const allocLength = type.layout.span >= 0 ? type.layout.span : getAlloc(type, fields);
  const data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(allocLength);
  const layoutFields = Object.assign({
    instruction: type.index
  }, fields);
  type.layout.encode(layoutFields, data);
  return data;
}

/**
 * Decode instruction data buffer using an InstructionType
 * @internal
 */
function decodeData$1(type, buffer) {
  let data;
  try {
    data = type.layout.decode(buffer);
  } catch (err) {
    throw new Error('invalid instruction; ' + err);
  }
  if (data.instruction !== type.index) {
    throw new Error(`invalid instruction; instruction index mismatch ${data.instruction} != ${type.index}`);
  }
  return data;
}

/**
 * https://github.com/solana-labs/solana/blob/90bedd7e067b5b8f3ddbb45da00a4e9cabb22c62/sdk/src/fee_calculator.rs#L7-L11
 *
 * @internal
 */
const FeeCalculatorLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .nu64 */ ._O('lamportsPerSignature');

/**
 * Calculator for transaction fees.
 *
 * @deprecated Deprecated since Solana v1.8.0.
 */

/**
 * See https://github.com/solana-labs/solana/blob/0ea2843ec9cdc517572b8e62c959f41b55cf4453/sdk/src/nonce_state.rs#L29-L32
 *
 * @internal
 */
const NonceAccountLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('version'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('state'), publicKey('authorizedPubkey'), publicKey('nonce'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([FeeCalculatorLayout], 'feeCalculator')]);
const NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;

/**
 * A durable nonce is a 32 byte value encoded as a base58 string.
 */

/**
 * NonceAccount class
 */
class NonceAccount {
  /**
   * @internal
   */
  constructor(args) {
    this.authorizedPubkey = void 0;
    this.nonce = void 0;
    this.feeCalculator = void 0;
    this.authorizedPubkey = args.authorizedPubkey;
    this.nonce = args.nonce;
    this.feeCalculator = args.feeCalculator;
  }

  /**
   * Deserialize NonceAccount from the account data.
   *
   * @param buffer account data
   * @return NonceAccount
   */
  static fromAccountData(buffer) {
    const nonceAccount = NonceAccountLayout.decode(toBuffer(buffer), 0);
    return new NonceAccount({
      authorizedPubkey: new PublicKey(nonceAccount.authorizedPubkey),
      nonce: new PublicKey(nonceAccount.nonce).toString(),
      feeCalculator: nonceAccount.feeCalculator
    });
  }
}

const encodeDecode = layout => {
  const decode = layout.decode.bind(layout);
  const encode = layout.encode.bind(layout);
  return {
    decode,
    encode
  };
};
const bigInt = length => property => {
  const layout = (0,_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .blob */ .Ik)(length, property);
  const {
    encode,
    decode
  } = encodeDecode(layout);
  const bigIntLayout = layout;
  bigIntLayout.decode = (buffer, offset) => {
    const src = decode(buffer, offset);
    return (0,bigint_buffer__WEBPACK_IMPORTED_MODULE_8__/* .toBigIntLE */ .oU)(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(src));
  };
  bigIntLayout.encode = (bigInt, buffer, offset) => {
    const src = (0,bigint_buffer__WEBPACK_IMPORTED_MODULE_8__/* .toBufferLE */ .k$)(bigInt, length);
    return encode(src, buffer, offset);
  };
  return bigIntLayout;
};
const u64 = bigInt(8);

/**
 * Create account system transaction params
 */

/**
 * System Instruction class
 */
class SystemInstruction {
  /**
   * @internal
   */
  constructor() {}

  /**
   * Decode a system instruction and retrieve the instruction type.
   */
  static decodeInstructionType(instruction) {
    this.checkProgramId(instruction.programId);
    const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction');
    const typeIndex = instructionTypeLayout.decode(instruction.data);
    let type;
    for (const [ixType, layout] of Object.entries(SYSTEM_INSTRUCTION_LAYOUTS)) {
      if (layout.index == typeIndex) {
        type = ixType;
        break;
      }
    }
    if (!type) {
      throw new Error('Instruction type incorrect; not a SystemInstruction');
    }
    return type;
  }

  /**
   * Decode a create account system instruction and retrieve the instruction params.
   */
  static decodeCreateAccount(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 2);
    const {
      lamports,
      space,
      programId
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Create, instruction.data);
    return {
      fromPubkey: instruction.keys[0].pubkey,
      newAccountPubkey: instruction.keys[1].pubkey,
      lamports,
      space,
      programId: new PublicKey(programId)
    };
  }

  /**
   * Decode a transfer system instruction and retrieve the instruction params.
   */
  static decodeTransfer(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 2);
    const {
      lamports
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, instruction.data);
    return {
      fromPubkey: instruction.keys[0].pubkey,
      toPubkey: instruction.keys[1].pubkey,
      lamports
    };
  }

  /**
   * Decode a transfer with seed system instruction and retrieve the instruction params.
   */
  static decodeTransferWithSeed(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    const {
      lamports,
      seed,
      programId
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, instruction.data);
    return {
      fromPubkey: instruction.keys[0].pubkey,
      basePubkey: instruction.keys[1].pubkey,
      toPubkey: instruction.keys[2].pubkey,
      lamports,
      seed,
      programId: new PublicKey(programId)
    };
  }

  /**
   * Decode an allocate system instruction and retrieve the instruction params.
   */
  static decodeAllocate(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 1);
    const {
      space
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, instruction.data);
    return {
      accountPubkey: instruction.keys[0].pubkey,
      space
    };
  }

  /**
   * Decode an allocate with seed system instruction and retrieve the instruction params.
   */
  static decodeAllocateWithSeed(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 1);
    const {
      base,
      seed,
      space,
      programId
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, instruction.data);
    return {
      accountPubkey: instruction.keys[0].pubkey,
      basePubkey: new PublicKey(base),
      seed,
      space,
      programId: new PublicKey(programId)
    };
  }

  /**
   * Decode an assign system instruction and retrieve the instruction params.
   */
  static decodeAssign(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 1);
    const {
      programId
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Assign, instruction.data);
    return {
      accountPubkey: instruction.keys[0].pubkey,
      programId: new PublicKey(programId)
    };
  }

  /**
   * Decode an assign with seed system instruction and retrieve the instruction params.
   */
  static decodeAssignWithSeed(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 1);
    const {
      base,
      seed,
      programId
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, instruction.data);
    return {
      accountPubkey: instruction.keys[0].pubkey,
      basePubkey: new PublicKey(base),
      seed,
      programId: new PublicKey(programId)
    };
  }

  /**
   * Decode a create account with seed system instruction and retrieve the instruction params.
   */
  static decodeCreateWithSeed(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 2);
    const {
      base,
      seed,
      lamports,
      space,
      programId
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, instruction.data);
    return {
      fromPubkey: instruction.keys[0].pubkey,
      newAccountPubkey: instruction.keys[1].pubkey,
      basePubkey: new PublicKey(base),
      seed,
      lamports,
      space,
      programId: new PublicKey(programId)
    };
  }

  /**
   * Decode a nonce initialize system instruction and retrieve the instruction params.
   */
  static decodeNonceInitialize(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    const {
      authorized
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, instruction.data);
    return {
      noncePubkey: instruction.keys[0].pubkey,
      authorizedPubkey: new PublicKey(authorized)
    };
  }

  /**
   * Decode a nonce advance system instruction and retrieve the instruction params.
   */
  static decodeNonceAdvance(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, instruction.data);
    return {
      noncePubkey: instruction.keys[0].pubkey,
      authorizedPubkey: instruction.keys[2].pubkey
    };
  }

  /**
   * Decode a nonce withdraw system instruction and retrieve the instruction params.
   */
  static decodeNonceWithdraw(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 5);
    const {
      lamports
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, instruction.data);
    return {
      noncePubkey: instruction.keys[0].pubkey,
      toPubkey: instruction.keys[1].pubkey,
      authorizedPubkey: instruction.keys[4].pubkey,
      lamports
    };
  }

  /**
   * Decode a nonce authorize system instruction and retrieve the instruction params.
   */
  static decodeNonceAuthorize(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 2);
    const {
      authorized
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, instruction.data);
    return {
      noncePubkey: instruction.keys[0].pubkey,
      authorizedPubkey: instruction.keys[1].pubkey,
      newAuthorizedPubkey: new PublicKey(authorized)
    };
  }

  /**
   * @internal
   */
  static checkProgramId(programId) {
    if (!programId.equals(SystemProgram.programId)) {
      throw new Error('invalid instruction; programId is not SystemProgram');
    }
  }

  /**
   * @internal
   */
  static checkKeyLength(keys, expectedLength) {
    if (keys.length < expectedLength) {
      throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
    }
  }
}

/**
 * An enumeration of valid SystemInstructionType's
 */

/**
 * An enumeration of valid system InstructionType's
 * @internal
 */
const SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({
  Create: {
    index: 0,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .ns64 */ .gM('lamports'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .ns64 */ .gM('space'), publicKey('programId')])
  },
  Assign: {
    index: 1,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction'), publicKey('programId')])
  },
  Transfer: {
    index: 2,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction'), u64('lamports')])
  },
  CreateWithSeed: {
    index: 3,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction'), publicKey('base'), rustString('seed'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .ns64 */ .gM('lamports'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .ns64 */ .gM('space'), publicKey('programId')])
  },
  AdvanceNonceAccount: {
    index: 4,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction')])
  },
  WithdrawNonceAccount: {
    index: 5,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .ns64 */ .gM('lamports')])
  },
  InitializeNonceAccount: {
    index: 6,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction'), publicKey('authorized')])
  },
  AuthorizeNonceAccount: {
    index: 7,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction'), publicKey('authorized')])
  },
  Allocate: {
    index: 8,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .ns64 */ .gM('space')])
  },
  AllocateWithSeed: {
    index: 9,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction'), publicKey('base'), rustString('seed'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .ns64 */ .gM('space'), publicKey('programId')])
  },
  AssignWithSeed: {
    index: 10,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction'), publicKey('base'), rustString('seed'), publicKey('programId')])
  },
  TransferWithSeed: {
    index: 11,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction'), u64('lamports'), rustString('seed'), publicKey('programId')])
  },
  UpgradeNonceAccount: {
    index: 12,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction')])
  }
});

/**
 * Factory class for transactions to interact with the System program
 */
class SystemProgram {
  /**
   * @internal
   */
  constructor() {}

  /**
   * Public key that identifies the System program
   */

  /**
   * Generate a transaction instruction that creates a new account
   */
  static createAccount(params) {
    const type = SYSTEM_INSTRUCTION_LAYOUTS.Create;
    const data = encodeData(type, {
      lamports: params.lamports,
      space: params.space,
      programId: toBuffer(params.programId.toBuffer())
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.newAccountPubkey,
        isSigner: true,
        isWritable: true
      }],
      programId: this.programId,
      data
    });
  }

  /**
   * Generate a transaction instruction that transfers lamports from one account to another
   */
  static transfer(params) {
    let data;
    let keys;
    if ('basePubkey' in params) {
      const type = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;
      data = encodeData(type, {
        lamports: BigInt(params.lamports),
        seed: params.seed,
        programId: toBuffer(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.fromPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }];
    } else {
      const type = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;
      data = encodeData(type, {
        lamports: BigInt(params.lamports)
      });
      keys = [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }];
    }
    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }

  /**
   * Generate a transaction instruction that assigns an account to a program
   */
  static assign(params) {
    let data;
    let keys;
    if ('basePubkey' in params) {
      const type = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;
      data = encodeData(type, {
        base: toBuffer(params.basePubkey.toBuffer()),
        seed: params.seed,
        programId: toBuffer(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }];
    } else {
      const type = SYSTEM_INSTRUCTION_LAYOUTS.Assign;
      data = encodeData(type, {
        programId: toBuffer(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: true,
        isWritable: true
      }];
    }
    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }

  /**
   * Generate a transaction instruction that creates a new account at
   *   an address generated with `from`, a seed, and programId
   */
  static createAccountWithSeed(params) {
    const type = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;
    const data = encodeData(type, {
      base: toBuffer(params.basePubkey.toBuffer()),
      seed: params.seed,
      lamports: params.lamports,
      space: params.space,
      programId: toBuffer(params.programId.toBuffer())
    });
    let keys = [{
      pubkey: params.fromPubkey,
      isSigner: true,
      isWritable: true
    }, {
      pubkey: params.newAccountPubkey,
      isSigner: false,
      isWritable: true
    }];
    if (params.basePubkey != params.fromPubkey) {
      keys.push({
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }

  /**
   * Generate a transaction that creates a new Nonce account
   */
  static createNonceAccount(params) {
    const transaction = new Transaction();
    if ('basePubkey' in params && 'seed' in params) {
      transaction.add(SystemProgram.createAccountWithSeed({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.noncePubkey,
        basePubkey: params.basePubkey,
        seed: params.seed,
        lamports: params.lamports,
        space: NONCE_ACCOUNT_LENGTH,
        programId: this.programId
      }));
    } else {
      transaction.add(SystemProgram.createAccount({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.noncePubkey,
        lamports: params.lamports,
        space: NONCE_ACCOUNT_LENGTH,
        programId: this.programId
      }));
    }
    const initParams = {
      noncePubkey: params.noncePubkey,
      authorizedPubkey: params.authorizedPubkey
    };
    transaction.add(this.nonceInitialize(initParams));
    return transaction;
  }

  /**
   * Generate an instruction to initialize a Nonce account
   */
  static nonceInitialize(params) {
    const type = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;
    const data = encodeData(type, {
      authorized: toBuffer(params.authorizedPubkey.toBuffer())
    });
    const instructionData = {
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }

  /**
   * Generate an instruction to advance the nonce in a Nonce account
   */
  static nonceAdvance(params) {
    const type = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;
    const data = encodeData(type);
    const instructionData = {
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }

  /**
   * Generate a transaction instruction that withdraws lamports from a Nonce account
   */
  static nonceWithdraw(params) {
    const type = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;
    const data = encodeData(type, {
      lamports: params.lamports
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }

  /**
   * Generate a transaction instruction that authorizes a new PublicKey as the authority
   * on a Nonce account.
   */
  static nonceAuthorize(params) {
    const type = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;
    const data = encodeData(type, {
      authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }

  /**
   * Generate a transaction instruction that allocates space in an account without funding
   */
  static allocate(params) {
    let data;
    let keys;
    if ('basePubkey' in params) {
      const type = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;
      data = encodeData(type, {
        base: toBuffer(params.basePubkey.toBuffer()),
        seed: params.seed,
        space: params.space,
        programId: toBuffer(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }];
    } else {
      const type = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;
      data = encodeData(type, {
        space: params.space
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: true,
        isWritable: true
      }];
    }
    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
}
SystemProgram.programId = new PublicKey('11111111111111111111111111111111');

// Keep program chunks under PACKET_DATA_SIZE, leaving enough room for the
// rest of the Transaction fields
//
// TODO: replace 300 with a proper constant for the size of the other
// Transaction fields
const CHUNK_SIZE = PACKET_DATA_SIZE - 300;

/**
 * Program loader interface
 */
class Loader {
  /**
   * @internal
   */
  constructor() {}

  /**
   * Amount of program data placed in each load Transaction
   */

  /**
   * Minimum number of signatures required to load a program not including
   * retries
   *
   * Can be used to calculate transaction fees
   */
  static getMinNumSignatures(dataLength) {
    return 2 * (
    // Every transaction requires two signatures (payer + program)
    Math.ceil(dataLength / Loader.chunkSize) + 1 +
    // Add one for Create transaction
    1) // Add one for Finalize transaction
    ;
  }

  /**
   * Loads a generic program
   *
   * @param connection The connection to use
   * @param payer System account that pays to load the program
   * @param program Account to load the program into
   * @param programId Public key that identifies the loader
   * @param data Program octets
   * @return true if program was loaded successfully, false if program was already loaded
   */
  static async load(connection, payer, program, programId, data) {
    {
      const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);

      // Fetch program account info to check if it has already been created
      const programInfo = await connection.getAccountInfo(program.publicKey, 'confirmed');
      let transaction = null;
      if (programInfo !== null) {
        if (programInfo.executable) {
          console.error('Program load failed, account is already executable');
          return false;
        }
        if (programInfo.data.length !== data.length) {
          transaction = transaction || new Transaction();
          transaction.add(SystemProgram.allocate({
            accountPubkey: program.publicKey,
            space: data.length
          }));
        }
        if (!programInfo.owner.equals(programId)) {
          transaction = transaction || new Transaction();
          transaction.add(SystemProgram.assign({
            accountPubkey: program.publicKey,
            programId
          }));
        }
        if (programInfo.lamports < balanceNeeded) {
          transaction = transaction || new Transaction();
          transaction.add(SystemProgram.transfer({
            fromPubkey: payer.publicKey,
            toPubkey: program.publicKey,
            lamports: balanceNeeded - programInfo.lamports
          }));
        }
      } else {
        transaction = new Transaction().add(SystemProgram.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: program.publicKey,
          lamports: balanceNeeded > 0 ? balanceNeeded : 1,
          space: data.length,
          programId
        }));
      }

      // If the account is already created correctly, skip this step
      // and proceed directly to loading instructions
      if (transaction !== null) {
        await sendAndConfirmTransaction(connection, transaction, [payer, program], {
          commitment: 'confirmed'
        });
      }
    }
    const dataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('offset'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('bytesLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('bytesLengthPadding'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .seq */ .A9(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__.u8('byte'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .offset */ .cv(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq(), -8), 'bytes')]);
    const chunkSize = Loader.chunkSize;
    let offset = 0;
    let array = data;
    let transactions = [];
    while (array.length > 0) {
      const bytes = array.slice(0, chunkSize);
      const data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(chunkSize + 16);
      dataLayout.encode({
        instruction: 0,
        // Load instruction
        offset,
        bytes: bytes,
        bytesLength: 0,
        bytesLengthPadding: 0
      }, data);
      const transaction = new Transaction().add({
        keys: [{
          pubkey: program.publicKey,
          isSigner: true,
          isWritable: true
        }],
        programId,
        data
      });
      transactions.push(sendAndConfirmTransaction(connection, transaction, [payer, program], {
        commitment: 'confirmed'
      }));

      // Delay between sends in an attempt to reduce rate limit errors
      if (connection._rpcEndpoint.includes('solana.com')) {
        const REQUESTS_PER_SECOND = 4;
        await sleep(1000 / REQUESTS_PER_SECOND);
      }
      offset += chunkSize;
      array = array.slice(chunkSize);
    }
    await Promise.all(transactions);

    // Finalize the account loaded with program data for execution
    {
      const dataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction')]);
      const data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(dataLayout.span);
      dataLayout.encode({
        instruction: 1 // Finalize instruction
      }, data);
      const transaction = new Transaction().add({
        keys: [{
          pubkey: program.publicKey,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: SYSVAR_RENT_PUBKEY,
          isSigner: false,
          isWritable: false
        }],
        programId,
        data
      });
      await sendAndConfirmTransaction(connection, transaction, [payer, program], {
        commitment: 'confirmed'
      });
    }

    // success
    return true;
  }
}
Loader.chunkSize = CHUNK_SIZE;

const BPF_LOADER_PROGRAM_ID = new PublicKey('BPFLoader2111111111111111111111111111111111');

/**
 * Factory class for transactions to interact with a program loader
 */
class BpfLoader {
  /**
   * Minimum number of signatures required to load a program not including
   * retries
   *
   * Can be used to calculate transaction fees
   */
  static getMinNumSignatures(dataLength) {
    return Loader.getMinNumSignatures(dataLength);
  }

  /**
   * Load a SBF program
   *
   * @param connection The connection to use
   * @param payer Account that will pay program loading fees
   * @param program Account to load the program into
   * @param elf The entire ELF containing the SBF program
   * @param loaderProgramId The program id of the BPF loader to use
   * @return true if program was loaded successfully, false if program was already loaded
   */
  static load(connection, payer, program, elf, loaderProgramId) {
    return Loader.load(connection, payer, program, loaderProgramId, elf);
  }
}

var objToString = Object.prototype.toString;
var objKeys = Object.keys || function(obj) {
		var keys = [];
		for (var name in obj) {
			keys.push(name);
		}
		return keys;
	};

function stringify(val, isArrayProp) {
	var i, max, str, keys, key, propVal, toStr;
	if (val === true) {
		return "true";
	}
	if (val === false) {
		return "false";
	}
	switch (typeof val) {
		case "object":
			if (val === null) {
				return null;
			} else if (val.toJSON && typeof val.toJSON === "function") {
				return stringify(val.toJSON(), isArrayProp);
			} else {
				toStr = objToString.call(val);
				if (toStr === "[object Array]") {
					str = '[';
					max = val.length - 1;
					for(i = 0; i < max; i++) {
						str += stringify(val[i], true) + ',';
					}
					if (max > -1) {
						str += stringify(val[i], true);
					}
					return str + ']';
				} else if (toStr === "[object Object]") {
					// only object is left
					keys = objKeys(val).sort();
					max = keys.length;
					str = "";
					i = 0;
					while (i < max) {
						key = keys[i];
						propVal = stringify(val[key], false);
						if (propVal !== undefined) {
							if (str) {
								str += ',';
							}
							str += JSON.stringify(key) + ':' + propVal;
						}
						i++;
					}
					return '{' + str + '}';
				} else {
					return JSON.stringify(val);
				}
			}
		case "function":
		case "undefined":
			return isArrayProp ? null : undefined;
		case "string":
			return JSON.stringify(val);
		default:
			return isFinite(val) ? val : null;
	}
}

var fastStableStringify = function(val) {
	var returnVal = stringify(val, false);
	if (returnVal !== undefined) {
		return ''+ returnVal;
	}
};

var fastStableStringify$1 = fastStableStringify;

const MINIMUM_SLOT_PER_EPOCH = 32;

// Returns the number of trailing zeros in the binary representation of self.
function trailingZeros(n) {
  let trailingZeros = 0;
  while (n > 1) {
    n /= 2;
    trailingZeros++;
  }
  return trailingZeros;
}

// Returns the smallest power of two greater than or equal to n
function nextPowerOfTwo(n) {
  if (n === 0) return 1;
  n--;
  n |= n >> 1;
  n |= n >> 2;
  n |= n >> 4;
  n |= n >> 8;
  n |= n >> 16;
  n |= n >> 32;
  return n + 1;
}

/**
 * Epoch schedule
 * (see https://docs.solana.com/terminology#epoch)
 * Can be retrieved with the {@link Connection.getEpochSchedule} method
 */
class EpochSchedule {
  /** The maximum number of slots in each epoch */

  /** The number of slots before beginning of an epoch to calculate a leader schedule for that epoch */

  /** Indicates whether epochs start short and grow */

  /** The first epoch with `slotsPerEpoch` slots */

  /** The first slot of `firstNormalEpoch` */

  constructor(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot) {
    this.slotsPerEpoch = void 0;
    this.leaderScheduleSlotOffset = void 0;
    this.warmup = void 0;
    this.firstNormalEpoch = void 0;
    this.firstNormalSlot = void 0;
    this.slotsPerEpoch = slotsPerEpoch;
    this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;
    this.warmup = warmup;
    this.firstNormalEpoch = firstNormalEpoch;
    this.firstNormalSlot = firstNormalSlot;
  }
  getEpoch(slot) {
    return this.getEpochAndSlotIndex(slot)[0];
  }
  getEpochAndSlotIndex(slot) {
    if (slot < this.firstNormalSlot) {
      const epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;
      const epochLen = this.getSlotsInEpoch(epoch);
      const slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);
      return [epoch, slotIndex];
    } else {
      const normalSlotIndex = slot - this.firstNormalSlot;
      const normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);
      const epoch = this.firstNormalEpoch + normalEpochIndex;
      const slotIndex = normalSlotIndex % this.slotsPerEpoch;
      return [epoch, slotIndex];
    }
  }
  getFirstSlotInEpoch(epoch) {
    if (epoch <= this.firstNormalEpoch) {
      return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;
    } else {
      return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;
    }
  }
  getLastSlotInEpoch(epoch) {
    return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;
  }
  getSlotsInEpoch(epoch) {
    if (epoch < this.firstNormalEpoch) {
      return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));
    } else {
      return this.slotsPerEpoch;
    }
  }
}

class SendTransactionError extends Error {
  constructor(message, logs) {
    super(message);
    this.logs = void 0;
    this.logs = logs;
  }
}

// Keep in sync with client/src/rpc_custom_errors.rs
// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/
const SolanaJSONRPCErrorCode = {
  JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
  JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,
  JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
  JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
  JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,
  JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
  JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
  JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
  JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
  JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
  JSON_RPC_SCAN_ERROR: -32012,
  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
  JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
  JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
  JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016
};
class SolanaJSONRPCError extends Error {
  constructor({
    code,
    message,
    data
  }, customMessage) {
    super(customMessage != null ? `${customMessage}: ${message}` : message);
    this.code = void 0;
    this.data = void 0;
    this.code = code;
    this.data = data;
    this.name = 'SolanaJSONRPCError';
  }
}

var fetchImpl = globalThis.fetch;

class RpcWebSocketClient extends rpc_websockets_dist_lib_client__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z {
  constructor(address, options, generate_request_id) {
    const webSocketFactory = url => {
      const rpc = (0,rpc_websockets_dist_lib_client_websocket_browser__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .Z)(url, {
        autoconnect: true,
        max_reconnects: 5,
        reconnect: true,
        reconnect_interval: 1000,
        ...options
      });
      if ('socket' in rpc) {
        this.underlyingSocket = rpc.socket;
      } else {
        this.underlyingSocket = rpc;
      }
      return rpc;
    };
    super(webSocketFactory, address, options, generate_request_id);
    this.underlyingSocket = void 0;
  }
  call(...args) {
    const readyState = this.underlyingSocket?.readyState;
    if (readyState === 1 /* WebSocket.OPEN */) {
      return super.call(...args);
    }
    return Promise.reject(new Error('Tried to call a JSON-RPC method `' + args[0] + '` but the socket was not `CONNECTING` or `OPEN` (`readyState` was ' + readyState + ')'));
  }
  notify(...args) {
    const readyState = this.underlyingSocket?.readyState;
    if (readyState === 1 /* WebSocket.OPEN */) {
      return super.notify(...args);
    }
    return Promise.reject(new Error('Tried to send a JSON-RPC notification `' + args[0] + '` but the socket was not `CONNECTING` or `OPEN` (`readyState` was ' + readyState + ')'));
  }
}

// TODO: These constants should be removed in favor of reading them out of a
// Syscall account

/**
 * @internal
 */
const NUM_TICKS_PER_SECOND = 160;

/**
 * @internal
 */
const DEFAULT_TICKS_PER_SLOT = 64;

/**
 * @internal
 */
const NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;

/**
 * @internal
 */
const MS_PER_SLOT = 1000 / NUM_SLOTS_PER_SECOND;

/**
 * @internal
 */

/**
 * Decode account data buffer using an AccountType
 * @internal
 */
function decodeData(type, data) {
  let decoded;
  try {
    decoded = type.layout.decode(data);
  } catch (err) {
    throw new Error('invalid instruction; ' + err);
  }
  if (decoded.typeIndex !== type.index) {
    throw new Error(`invalid account data; account type mismatch ${decoded.typeIndex} != ${type.index}`);
  }
  return decoded;
}

/// The serialized size of lookup table metadata
const LOOKUP_TABLE_META_SIZE = 56;
class AddressLookupTableAccount {
  constructor(args) {
    this.key = void 0;
    this.state = void 0;
    this.key = args.key;
    this.state = args.state;
  }
  isActive() {
    const U64_MAX = BigInt('0xffffffffffffffff');
    return this.state.deactivationSlot === U64_MAX;
  }
  static deserialize(accountData) {
    const meta = decodeData(LookupTableMetaLayout, accountData);
    const serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;
    assert(serializedAddressesLen >= 0, 'lookup table is invalid');
    assert(serializedAddressesLen % 32 === 0, 'lookup table is invalid');
    const numSerializedAddresses = serializedAddressesLen / 32;
    const {
      addresses
    } = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .seq */ .A9(publicKey(), numSerializedAddresses, 'addresses')]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE));
    return {
      deactivationSlot: meta.deactivationSlot,
      lastExtendedSlot: meta.lastExtendedSlot,
      lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,
      authority: meta.authority.length !== 0 ? new PublicKey(meta.authority[0]) : undefined,
      addresses: addresses.map(address => new PublicKey(address))
    };
  }
}
const LookupTableMetaLayout = {
  index: 1,
  layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('typeIndex'), u64('deactivationSlot'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .nu64 */ ._O('lastExtendedSlot'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__.u8('lastExtendedStartIndex'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__.u8(),
  // option
  _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .seq */ .A9(publicKey(), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .offset */ .cv(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__.u8(), -1), 'authority')])
};

const URL_RE = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
function makeWebsocketUrl(endpoint) {
  const matches = endpoint.match(URL_RE);
  if (matches == null) {
    throw TypeError(`Failed to validate endpoint URL \`${endpoint}\``);
  }
  const [_,
  // eslint-disable-line @typescript-eslint/no-unused-vars
  hostish, portWithColon, rest] = matches;
  const protocol = endpoint.startsWith('https:') ? 'wss:' : 'ws:';
  const startPort = portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);
  const websocketPort =
  // Only shift the port by +1 as a convention for ws(s) only if given endpoint
  // is explictly specifying the endpoint port (HTTP-based RPC), assuming
  // we're directly trying to connect to solana-validator's ws listening port.
  // When the endpoint omits the port, we're connecting to the protocol
  // default ports: http(80) or https(443) and it's assumed we're behind a reverse
  // proxy which manages WebSocket upgrade and backend port redirection.
  startPort == null ? '' : `:${startPort + 1}`;
  return `${protocol}//${hostish}${websocketPort}${rest}`;
}

const PublicKeyFromString = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .coerce */ .oQ)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .instance */ .eE)(PublicKey), (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(), value => new PublicKey(value));
const RawAccountDataResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .tuple */ .bc)([(0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .literal */ .i0)('base64')]);
const BufferFromRawAccountData = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .coerce */ .oQ)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .instance */ .eE)(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer), RawAccountDataResult, value => buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value[0], 'base64'));

/**
 * Attempt to use a recent blockhash for up to 30 seconds
 * @internal
 */
const BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1000;

/**
 * HACK.
 * Copied from rpc-websockets/dist/lib/client.
 * Otherwise, `yarn build` fails with:
 * https://gist.github.com/steveluscher/c057eca81d479ef705cdb53162f9971d
 */

/* @internal */
function assertEndpointUrl(putativeUrl) {
  if (/^https?:/.test(putativeUrl) === false) {
    throw new TypeError('Endpoint URL must start with `http:` or `https:`.');
  }
  return putativeUrl;
}

/** @internal */
function extractCommitmentFromConfig(commitmentOrConfig) {
  let commitment;
  let config;
  if (typeof commitmentOrConfig === 'string') {
    commitment = commitmentOrConfig;
  } else if (commitmentOrConfig) {
    const {
      commitment: specifiedCommitment,
      ...specifiedConfig
    } = commitmentOrConfig;
    commitment = specifiedCommitment;
    config = specifiedConfig;
  }
  return {
    commitment,
    config
  };
}

/**
 * @internal
 */
function createRpcResult(result) {
  return (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .union */ .G0)([(0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
    jsonrpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .literal */ .i0)('2.0'),
    id: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
    result
  }), (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
    jsonrpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .literal */ .i0)('2.0'),
    id: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
    error: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
      code: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .unknown */ ._4)(),
      message: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
      data: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .any */ .Yj)())
    })
  })]);
}
const UnknownRpcResult = createRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .unknown */ ._4)());

/**
 * @internal
 */
function jsonRpcResult(schema) {
  return (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .coerce */ .oQ)(createRpcResult(schema), UnknownRpcResult, value => {
    if ('error' in value) {
      return value;
    } else {
      return {
        ...value,
        result: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(value.result, schema)
      };
    }
  });
}

/**
 * @internal
 */
function jsonRpcResultAndContext(value) {
  return jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
    context: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
      slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()
    }),
    value
  }));
}

/**
 * @internal
 */
function notificationResultAndContext(value) {
  return (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
    context: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
      slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()
    }),
    value
  });
}

/**
 * @internal
 */
function versionedMessageFromResponse(version, response) {
  if (version === 0) {
    return new MessageV0({
      header: response.header,
      staticAccountKeys: response.accountKeys.map(accountKey => new PublicKey(accountKey)),
      recentBlockhash: response.recentBlockhash,
      compiledInstructions: response.instructions.map(ix => ({
        programIdIndex: ix.programIdIndex,
        accountKeyIndexes: ix.accounts,
        data: bs58__WEBPACK_IMPORTED_MODULE_4___default().decode(ix.data)
      })),
      addressTableLookups: response.addressTableLookups
    });
  } else {
    return new Message(response);
  }
}

/**
 * The level of commitment desired when querying state
 * <pre>
 *   'processed': Query the most recent block which has reached 1 confirmation by the connected node
 *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster
 *   'finalized': Query the most recent block which has been finalized by the cluster
 * </pre>
 */

const GetInflationGovernorResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  foundation: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  foundationTerm: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  initial: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  taper: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  terminal: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()
});

/**
 * The inflation reward for an epoch
 */

/**
 * Expected JSON RPC response for the "getInflationReward" message
 */
const GetInflationRewardResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  effectiveSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  postBalance: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()))
}))));
/**
 * Expected JSON RPC response for the "getRecentPrioritizationFees" message
 */
const GetRecentPrioritizationFeesResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  prioritizationFee: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()
}));
/**
 * Expected JSON RPC response for the "getInflationRate" message
 */
const GetInflationRateResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  total: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  validator: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  foundation: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()
});

/**
 * Information about the current epoch
 */

const GetEpochInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  slotIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  slotsInEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  absoluteSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()),
  transactionCount: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)())
});
const GetEpochScheduleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  slotsPerEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  leaderScheduleSlotOffset: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  warmup: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .boolean */ .O7)(),
  firstNormalEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  firstNormalSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()
});

/**
 * Leader schedule
 * (see https://docs.solana.com/terminology#leader-schedule)
 */

const GetLeaderScheduleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .record */ .IM)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()));

/**
 * Transaction error or null
 */
const TransactionErrorResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .union */ .G0)([(0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({}), (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)()]));

/**
 * Signature status for a transaction
 */
const SignatureStatusResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  err: TransactionErrorResult
});

/**
 * Transaction signature received notification
 */
const SignatureReceivedResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .literal */ .i0)('receivedSignature');

/**
 * Version info for a node
 */

const VersionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  'solana-core': (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
  'feature-set': (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)())
});
const SimulatedTransactionResponseStruct = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  err: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .union */ .G0)([(0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({}), (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)()])),
  logs: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)())),
  accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
    executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .boolean */ .O7)(),
    owner: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
    data: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)()),
    rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)())
  }))))),
  unitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()),
  returnData: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
    programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
    data: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .tuple */ .bc)([(0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .literal */ .i0)('base64')])
  })))
}));
/**
 * Expected JSON RPC response for the "getBlockProduction" message
 */
const BlockProductionResponseStruct = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  byIdentity: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .record */ .IM)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)())),
  range: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
    firstSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
    lastSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()
  })
}));

/**
 * A performance sample
 */

function createRpcClient(url, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent) {
  const fetch = customFetch ? customFetch : fetchImpl;
  let agent;
  {
    if (httpAgent != null) {
      console.warn('You have supplied an `httpAgent` when creating a `Connection` in a browser environment.' + 'It has been ignored; `httpAgent` is only used in Node environments.');
    }
  }
  let fetchWithMiddleware;
  if (fetchMiddleware) {
    fetchWithMiddleware = async (info, init) => {
      const modifiedFetchArgs = await new Promise((resolve, reject) => {
        try {
          fetchMiddleware(info, init, (modifiedInfo, modifiedInit) => resolve([modifiedInfo, modifiedInit]));
        } catch (error) {
          reject(error);
        }
      });
      return await fetch(...modifiedFetchArgs);
    };
  }
  const clientBrowser = new (jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_9___default())(async (request, callback) => {
    const options = {
      method: 'POST',
      body: request,
      agent,
      headers: Object.assign({
        'Content-Type': 'application/json'
      }, httpHeaders || {}, COMMON_HTTP_HEADERS)
    };
    try {
      let too_many_requests_retries = 5;
      let res;
      let waitTime = 500;
      for (;;) {
        if (fetchWithMiddleware) {
          res = await fetchWithMiddleware(url, options);
        } else {
          res = await fetch(url, options);
        }
        if (res.status !== 429 /* Too many requests */) {
          break;
        }
        if (disableRetryOnRateLimit === true) {
          break;
        }
        too_many_requests_retries -= 1;
        if (too_many_requests_retries === 0) {
          break;
        }
        console.log(`Server responded with ${res.status} ${res.statusText}.  Retrying after ${waitTime}ms delay...`);
        await sleep(waitTime);
        waitTime *= 2;
      }
      const text = await res.text();
      if (res.ok) {
        callback(null, text);
      } else {
        callback(new Error(`${res.status} ${res.statusText}: ${text}`));
      }
    } catch (err) {
      if (err instanceof Error) callback(err);
    }
  }, {});
  return clientBrowser;
}
function createRpcRequest(client) {
  return (method, args) => {
    return new Promise((resolve, reject) => {
      client.request(method, args, (err, response) => {
        if (err) {
          reject(err);
          return;
        }
        resolve(response);
      });
    });
  };
}
function createRpcBatchRequest(client) {
  return requests => {
    return new Promise((resolve, reject) => {
      // Do nothing if requests is empty
      if (requests.length === 0) resolve([]);
      const batch = requests.map(params => {
        return client.request(params.methodName, params.args);
      });
      client.request(batch, (err, response) => {
        if (err) {
          reject(err);
          return;
        }
        resolve(response);
      });
    });
  };
}

/**
 * Expected JSON RPC response for the "getInflationGovernor" message
 */
const GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);

/**
 * Expected JSON RPC response for the "getInflationRate" message
 */
const GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);

/**
 * Expected JSON RPC response for the "getRecentPrioritizationFees" message
 */
const GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult);

/**
 * Expected JSON RPC response for the "getEpochInfo" message
 */
const GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);

/**
 * Expected JSON RPC response for the "getEpochSchedule" message
 */
const GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);

/**
 * Expected JSON RPC response for the "getLeaderSchedule" message
 */
const GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);

/**
 * Expected JSON RPC response for the "minimumLedgerSlot" and "getFirstAvailableBlock" messages
 */
const SlotRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)());

/**
 * Supply
 */

/**
 * Expected JSON RPC response for the "getSupply" message
 */
const GetSupplyRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  total: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  circulating: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  nonCirculating: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  nonCirculatingAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)(PublicKeyFromString)
}));

/**
 * Token amount object which returns a token amount in different formats
 * for various client use cases.
 */

/**
 * Expected JSON RPC structure for token amounts
 */
const TokenAmountResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
  uiAmount: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()),
  decimals: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  uiAmountString: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)())
});

/**
 * Token address and balance.
 */

/**
 * Expected JSON RPC response for the "getTokenLargestAccounts" message
 */
const GetTokenLargestAccountsResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  address: PublicKeyFromString,
  amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
  uiAmount: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()),
  decimals: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  uiAmountString: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)())
})));

/**
 * Expected JSON RPC response for the "getTokenAccountsByOwner" message
 */
const GetTokenAccountsByOwner = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  pubkey: PublicKeyFromString,
  account: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
    executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .boolean */ .O7)(),
    owner: PublicKeyFromString,
    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
    data: BufferFromRawAccountData,
    rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()
  })
})));
const ParsedAccountDataResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  program: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
  parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .unknown */ ._4)(),
  space: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()
});

/**
 * Expected JSON RPC response for the "getTokenAccountsByOwner" message with parsed data
 */
const GetParsedTokenAccountsByOwner = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  pubkey: PublicKeyFromString,
  account: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
    executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .boolean */ .O7)(),
    owner: PublicKeyFromString,
    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
    data: ParsedAccountDataResult,
    rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()
  })
})));

/**
 * Pair of an account address and its balance
 */

/**
 * Expected JSON RPC response for the "getLargestAccounts" message
 */
const GetLargestAccountsRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  address: PublicKeyFromString
})));

/**
 * @internal
 */
const AccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .boolean */ .O7)(),
  owner: PublicKeyFromString,
  lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  data: BufferFromRawAccountData,
  rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()
});

/**
 * @internal
 */
const KeyedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
});
const ParsedOrRawAccountData = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .coerce */ .oQ)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .union */ .G0)([(0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .instance */ .eE)(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer), ParsedAccountDataResult]), (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .union */ .G0)([RawAccountDataResult, ParsedAccountDataResult]), value => {
  if (Array.isArray(value)) {
    return (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(value, BufferFromRawAccountData);
  } else {
    return value;
  }
});

/**
 * @internal
 */
const ParsedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .boolean */ .O7)(),
  owner: PublicKeyFromString,
  lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  data: ParsedOrRawAccountData,
  rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()
});
const KeyedParsedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  pubkey: PublicKeyFromString,
  account: ParsedAccountInfoResult
});

/**
 * @internal
 */
const StakeActivationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  state: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .union */ .G0)([(0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .literal */ .i0)('active'), (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .literal */ .i0)('inactive'), (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .literal */ .i0)('activating'), (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .literal */ .i0)('deactivating')]),
  active: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  inactive: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()
});

/**
 * Expected JSON RPC response for the "getConfirmedSignaturesForAddress2" message
 */

const GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  err: TransactionErrorResult,
  memo: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)()),
  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()))
})));

/**
 * Expected JSON RPC response for the "getSignaturesForAddress" message
 */
const GetSignaturesForAddressRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  err: TransactionErrorResult,
  memo: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)()),
  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()))
})));

/***
 * Expected JSON RPC response for the "accountNotification" message
 */
const AccountNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  result: notificationResultAndContext(AccountInfoResult)
});

/**
 * @internal
 */
const ProgramAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
});

/***
 * Expected JSON RPC response for the "programNotification" message
 */
const ProgramAccountNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  result: notificationResultAndContext(ProgramAccountInfoResult)
});

/**
 * @internal
 */
const SlotInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  parent: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  root: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()
});

/**
 * Expected JSON RPC response for the "slotNotification" message
 */
const SlotNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  result: SlotInfoResult
});

/**
 * Slot updates which can be used for tracking the live progress of a cluster.
 * - `"firstShredReceived"`: connected node received the first shred of a block.
 * Indicates that a new block that is being produced.
 * - `"completed"`: connected node has received all shreds of a block. Indicates
 * a block was recently produced.
 * - `"optimisticConfirmation"`: block was optimistically confirmed by the
 * cluster. It is not guaranteed that an optimistic confirmation notification
 * will be sent for every finalized blocks.
 * - `"root"`: the connected node rooted this block.
 * - `"createdBank"`: the connected node has started validating this block.
 * - `"frozen"`: the connected node has validated this block.
 * - `"dead"`: the connected node failed to validate this block.
 */

/**
 * @internal
 */
const SlotUpdateResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .union */ .G0)([(0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  type: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .union */ .G0)([(0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .literal */ .i0)('firstShredReceived'), (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .literal */ .i0)('completed'), (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .literal */ .i0)('optimisticConfirmation'), (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .literal */ .i0)('root')]),
  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()
}), (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  type: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .literal */ .i0)('createdBank'),
  parent: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()
}), (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  type: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .literal */ .i0)('frozen'),
  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  stats: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
    numTransactionEntries: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
    numSuccessfulTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
    numFailedTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
    maxTransactionsPerEntry: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()
  })
}), (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  type: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .literal */ .i0)('dead'),
  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  err: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)()
})]);

/**
 * Expected JSON RPC response for the "slotsUpdatesNotification" message
 */
const SlotUpdateNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  result: SlotUpdateResult
});

/**
 * Expected JSON RPC response for the "signatureNotification" message
 */
const SignatureNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  result: notificationResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .union */ .G0)([SignatureStatusResult, SignatureReceivedResult]))
});

/**
 * Expected JSON RPC response for the "rootNotification" message
 */
const RootNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  result: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()
});
const ContactInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  pubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
  gossip: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)()),
  tpu: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)()),
  rpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)()),
  version: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)())
});
const VoteAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  votePubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
  nodePubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
  activatedStake: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  epochVoteAccount: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .boolean */ .O7)(),
  epochCredits: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .tuple */ .bc)([(0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()])),
  commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  lastVote: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  rootSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)())
});

/**
 * Expected JSON RPC response for the "getVoteAccounts" message
 */
const GetVoteAccounts = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  current: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)(VoteAccountInfoResult),
  delinquent: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)(VoteAccountInfoResult)
}));
const ConfirmationStatus = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .union */ .G0)([(0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .literal */ .i0)('processed'), (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .literal */ .i0)('confirmed'), (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .literal */ .i0)('finalized')]);
const SignatureStatusResponse = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  confirmations: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()),
  err: TransactionErrorResult,
  confirmationStatus: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)(ConfirmationStatus)
});

/**
 * Expected JSON RPC response for the "getSignatureStatuses" message
 */
const GetSignatureStatusesRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)(SignatureStatusResponse)));

/**
 * Expected JSON RPC response for the "getMinimumBalanceForRentExemption" message
 */
const GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)());
const AddressTableLookupStruct = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  accountKey: PublicKeyFromString,
  writableIndexes: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()),
  readonlyIndexes: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)())
});
const ConfirmedTransactionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)()),
  message: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
    accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)()),
    header: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
      numRequiredSignatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
      numReadonlySignedAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
      numReadonlyUnsignedAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()
    }),
    instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
      accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()),
      data: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
      programIdIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()
    })),
    recentBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
    addressTableLookups: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)(AddressTableLookupStruct))
  })
});
const AnnotatedAccountKey = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  pubkey: PublicKeyFromString,
  signer: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .boolean */ .O7)(),
  writable: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .boolean */ .O7)(),
  source: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .union */ .G0)([(0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .literal */ .i0)('transaction'), (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .literal */ .i0)('lookupTable')]))
});
const ConfirmedTransactionAccountsModeResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)(AnnotatedAccountKey),
  signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)())
});
const ParsedInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .unknown */ ._4)(),
  program: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
  programId: PublicKeyFromString
});
const RawInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)(PublicKeyFromString),
  data: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
  programId: PublicKeyFromString
});
const InstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .union */ .G0)([RawInstructionResult, ParsedInstructionResult]);
const UnknownInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .union */ .G0)([(0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .unknown */ ._4)(),
  program: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
  programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)()
}), (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)()),
  data: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
  programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)()
})]);
const ParsedOrRawInstruction = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .coerce */ .oQ)(InstructionResult, UnknownInstructionResult, value => {
  if ('accounts' in value) {
    return (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(value, RawInstructionResult);
  } else {
    return (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(value, ParsedInstructionResult);
  }
});

/**
 * @internal
 */
const ParsedConfirmedTransactionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)()),
  message: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
    accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)(AnnotatedAccountKey),
    instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)(ParsedOrRawInstruction),
    recentBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
    addressTableLookups: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)(AddressTableLookupStruct)))
  })
});
const TokenBalanceResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  accountIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  mint: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
  owner: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)()),
  uiTokenAmount: TokenAmountResult
});
const LoadedAddressesResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  writable: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)(PublicKeyFromString),
  readonly: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)(PublicKeyFromString)
});

/**
 * @internal
 */
const ConfirmedTransactionMetaResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  err: TransactionErrorResult,
  fee: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  innerInstructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
    index: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
    instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
      accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()),
      data: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
      programIdIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()
    }))
  })))),
  preBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()),
  postBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()),
  logMessages: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)()))),
  preTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)(TokenBalanceResult))),
  postTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)(TokenBalanceResult))),
  loadedAddresses: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)(LoadedAddressesResult),
  computeUnitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)())
});

/**
 * @internal
 */
const ParsedConfirmedTransactionMetaResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  err: TransactionErrorResult,
  fee: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  innerInstructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
    index: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
    instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)(ParsedOrRawInstruction)
  })))),
  preBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()),
  postBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()),
  logMessages: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)()))),
  preTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)(TokenBalanceResult))),
  postTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)(TokenBalanceResult))),
  loadedAddresses: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)(LoadedAddressesResult),
  computeUnitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)())
});
const TransactionVersionStruct = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .union */ .G0)([(0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .literal */ .i0)(0), (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .literal */ .i0)('legacy')]);

/** @internal */
const RewardsResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  pubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
  lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  postBalance: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()),
  rewardType: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)()),
  commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()))
});

/**
 * Expected JSON RPC response for the "getBlock" message
 */
const GetBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
  previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
  parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
    transaction: ConfirmedTransactionResult,
    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)(ConfirmedTransactionMetaResult),
    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)(TransactionVersionStruct)
  })),
  rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)(RewardsResult)),
  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()),
  blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)())
})));

/**
 * Expected JSON RPC response for the "getBlock" message when `transactionDetails` is `none`
 */
const GetNoneModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
  previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
  parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)(RewardsResult)),
  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()),
  blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)())
})));

/**
 * Expected JSON RPC response for the "getBlock" message when `transactionDetails` is `accounts`
 */
const GetAccountsModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
  previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
  parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)(ConfirmedTransactionMetaResult),
    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)(TransactionVersionStruct)
  })),
  rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)(RewardsResult)),
  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()),
  blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)())
})));

/**
 * Expected parsed JSON RPC response for the "getBlock" message
 */
const GetParsedBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
  previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
  parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
    transaction: ParsedConfirmedTransactionResult,
    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)(ParsedConfirmedTransactionMetaResult),
    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)(TransactionVersionStruct)
  })),
  rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)(RewardsResult)),
  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()),
  blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)())
})));

/**
 * Expected parsed JSON RPC response for the "getBlock" message  when `transactionDetails` is `accounts`
 */
const GetParsedAccountsModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
  previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
  parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)(ParsedConfirmedTransactionMetaResult),
    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)(TransactionVersionStruct)
  })),
  rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)(RewardsResult)),
  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()),
  blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)())
})));

/**
 * Expected parsed JSON RPC response for the "getBlock" message  when `transactionDetails` is `none`
 */
const GetParsedNoneModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
  previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
  parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)(RewardsResult)),
  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()),
  blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)())
})));

/**
 * Expected JSON RPC response for the "getConfirmedBlock" message
 *
 * @deprecated Deprecated since Solana v1.8.0. Please use {@link GetBlockRpcResult} instead.
 */
const GetConfirmedBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
  previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
  parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
    transaction: ConfirmedTransactionResult,
    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)(ConfirmedTransactionMetaResult)
  })),
  rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)(RewardsResult)),
  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)())
})));

/**
 * Expected JSON RPC response for the "getBlock" message
 */
const GetBlockSignaturesRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
  previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
  parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)()),
  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)())
})));

/**
 * Expected JSON RPC response for the "getTransaction" message
 */
const GetTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  meta: ConfirmedTransactionMetaResult,
  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)())),
  transaction: ConfirmedTransactionResult,
  version: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)(TransactionVersionStruct)
})));

/**
 * Expected parsed JSON RPC response for the "getTransaction" message
 */
const GetParsedTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  transaction: ParsedConfirmedTransactionResult,
  meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)(ParsedConfirmedTransactionMetaResult),
  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)())),
  version: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)(TransactionVersionStruct)
})));

/**
 * Expected JSON RPC response for the "getRecentBlockhash" message
 *
 * @deprecated Deprecated since Solana v1.8.0. Please use {@link GetLatestBlockhashRpcResult} instead.
 */
const GetRecentBlockhashAndContextRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
  feeCalculator: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
    lamportsPerSignature: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()
  })
}));

/**
 * Expected JSON RPC response for the "getLatestBlockhash" message
 */
const GetLatestBlockhashRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
  lastValidBlockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()
}));
const PerfSampleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  numTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  numSlots: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)(),
  samplePeriodSecs: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()
});

/*
 * Expected JSON RPC response for "getRecentPerformanceSamples" message
 */
const GetRecentPerformanceSamplesRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)(PerfSampleResult));

/**
 * Expected JSON RPC response for the "getFeeCalculatorForBlockhash" message
 */
const GetFeeCalculatorRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  feeCalculator: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
    lamportsPerSignature: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()
  })
})));

/**
 * Expected JSON RPC response for the "requestAirdrop" message
 */
const RequestAirdropRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)());

/**
 * Expected JSON RPC response for the "sendTransaction" message
 */
const SendTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)());

/**
 * Information about the latest slot being processed by a node
 */

/**
 * @internal
 */
const LogsResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  err: TransactionErrorResult,
  logs: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)()),
  signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)()
});

/**
 * Logs result.
 */

/**
 * Expected JSON RPC response for the "logsNotification" message.
 */
const LogsNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  result: notificationResultAndContext(LogsResult),
  subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()
});

/**
 * Filter for log subscriptions.
 */

/** @internal */
const COMMON_HTTP_HEADERS = {
  'solana-client': `js/${"0.0.0-development" }`
};

/**
 * A connection to a fullnode JSON RPC endpoint
 */
class Connection {
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */

  /** @internal */

  /** @internal
   * A number that we increment every time an active connection closes.
   * Used to determine whether the same socket connection that was open
   * when an async operation started is the same one that's active when
   * its continuation fires.
   *
   */

  /** @internal */
  /** @internal */
  /** @internal */

  /** @internal */
  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /** @internal */

  /**
   * Special case.
   * After a signature is processed, RPCs automatically dispose of the
   * subscription on the server side. We need to track which of these
   * subscriptions have been disposed in such a way, so that we know
   * whether the client is dealing with a not-yet-processed signature
   * (in which case we must tear down the server subscription) or an
   * already-processed signature (in which case the client can simply
   * clear out the subscription locally without telling the server).
   *
   * NOTE: There is a proposal to eliminate this special case, here:
   * https://github.com/solana-labs/solana/issues/18892
   */
  /** @internal */

  /**
   * Establish a JSON RPC connection
   *
   * @param endpoint URL to the fullnode JSON RPC endpoint
   * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object
   */
  constructor(endpoint, _commitmentOrConfig) {
    this._commitment = void 0;
    this._confirmTransactionInitialTimeout = void 0;
    this._rpcEndpoint = void 0;
    this._rpcWsEndpoint = void 0;
    this._rpcClient = void 0;
    this._rpcRequest = void 0;
    this._rpcBatchRequest = void 0;
    this._rpcWebSocket = void 0;
    this._rpcWebSocketConnected = false;
    this._rpcWebSocketHeartbeat = null;
    this._rpcWebSocketIdleTimeout = null;
    this._rpcWebSocketGeneration = 0;
    this._disableBlockhashCaching = false;
    this._pollingBlockhash = false;
    this._blockhashInfo = {
      latestBlockhash: null,
      lastFetch: 0,
      transactionSignatures: [],
      simulatedSignatures: []
    };
    this._nextClientSubscriptionId = 0;
    this._subscriptionDisposeFunctionsByClientSubscriptionId = {};
    this._subscriptionHashByClientSubscriptionId = {};
    this._subscriptionStateChangeCallbacksByHash = {};
    this._subscriptionCallbacksByServerSubscriptionId = {};
    this._subscriptionsByHash = {};
    this._subscriptionsAutoDisposedByRpc = new Set();
    this.getBlockHeight = (() => {
      const requestPromises = {};
      return async commitmentOrConfig => {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([], commitment, undefined /* encoding */, config);
        const requestHash = fastStableStringify$1(args);
        requestPromises[requestHash] = requestPromises[requestHash] ?? (async () => {
          try {
            const unsafeRes = await this._rpcRequest('getBlockHeight', args);
            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()));
            if ('error' in res) {
              throw new SolanaJSONRPCError(res.error, 'failed to get block height information');
            }
            return res.result;
          } finally {
            delete requestPromises[requestHash];
          }
        })();
        return await requestPromises[requestHash];
      };
    })();
    let wsEndpoint;
    let httpHeaders;
    let fetch;
    let fetchMiddleware;
    let disableRetryOnRateLimit;
    let httpAgent;
    if (_commitmentOrConfig && typeof _commitmentOrConfig === 'string') {
      this._commitment = _commitmentOrConfig;
    } else if (_commitmentOrConfig) {
      this._commitment = _commitmentOrConfig.commitment;
      this._confirmTransactionInitialTimeout = _commitmentOrConfig.confirmTransactionInitialTimeout;
      wsEndpoint = _commitmentOrConfig.wsEndpoint;
      httpHeaders = _commitmentOrConfig.httpHeaders;
      fetch = _commitmentOrConfig.fetch;
      fetchMiddleware = _commitmentOrConfig.fetchMiddleware;
      disableRetryOnRateLimit = _commitmentOrConfig.disableRetryOnRateLimit;
      httpAgent = _commitmentOrConfig.httpAgent;
    }
    this._rpcEndpoint = assertEndpointUrl(endpoint);
    this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint);
    this._rpcClient = createRpcClient(endpoint, httpHeaders, fetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent);
    this._rpcRequest = createRpcRequest(this._rpcClient);
    this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);
    this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {
      autoconnect: false,
      max_reconnects: Infinity
    });
    this._rpcWebSocket.on('open', this._wsOnOpen.bind(this));
    this._rpcWebSocket.on('error', this._wsOnError.bind(this));
    this._rpcWebSocket.on('close', this._wsOnClose.bind(this));
    this._rpcWebSocket.on('accountNotification', this._wsOnAccountNotification.bind(this));
    this._rpcWebSocket.on('programNotification', this._wsOnProgramAccountNotification.bind(this));
    this._rpcWebSocket.on('slotNotification', this._wsOnSlotNotification.bind(this));
    this._rpcWebSocket.on('slotsUpdatesNotification', this._wsOnSlotUpdatesNotification.bind(this));
    this._rpcWebSocket.on('signatureNotification', this._wsOnSignatureNotification.bind(this));
    this._rpcWebSocket.on('rootNotification', this._wsOnRootNotification.bind(this));
    this._rpcWebSocket.on('logsNotification', this._wsOnLogsNotification.bind(this));
  }

  /**
   * The default commitment used for requests
   */
  get commitment() {
    return this._commitment;
  }

  /**
   * The RPC endpoint
   */
  get rpcEndpoint() {
    return this._rpcEndpoint;
  }

  /**
   * Fetch the balance for the specified public key, return with context
   */
  async getBalanceAndContext(publicKey, commitmentOrConfig) {
    /** @internal */
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([publicKey.toBase58()], commitment, undefined /* encoding */, config);
    const unsafeRes = await this._rpcRequest('getBalance', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()));
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get balance for ${publicKey.toBase58()}`);
    }
    return res.result;
  }

  /**
   * Fetch the balance for the specified public key
   */
  async getBalance(publicKey, commitmentOrConfig) {
    return await this.getBalanceAndContext(publicKey, commitmentOrConfig).then(x => x.value).catch(e => {
      throw new Error('failed to get balance of account ' + publicKey.toBase58() + ': ' + e);
    });
  }

  /**
   * Fetch the estimated production time of a block
   */
  async getBlockTime(slot) {
    const unsafeRes = await this._rpcRequest('getBlockTime', [slot]);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)())));
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get block time for slot ${slot}`);
    }
    return res.result;
  }

  /**
   * Fetch the lowest slot that the node has information about in its ledger.
   * This value may increase over time if the node is configured to purge older ledger data
   */
  async getMinimumLedgerSlot() {
    const unsafeRes = await this._rpcRequest('minimumLedgerSlot', []);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()));
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get minimum ledger slot');
    }
    return res.result;
  }

  /**
   * Fetch the slot of the lowest confirmed block that has not been purged from the ledger
   */
  async getFirstAvailableBlock() {
    const unsafeRes = await this._rpcRequest('getFirstAvailableBlock', []);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, SlotRpcResult);
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get first available block');
    }
    return res.result;
  }

  /**
   * Fetch information about the current supply
   */
  async getSupply(config) {
    let configArg = {};
    if (typeof config === 'string') {
      configArg = {
        commitment: config
      };
    } else if (config) {
      configArg = {
        ...config,
        commitment: config && config.commitment || this.commitment
      };
    } else {
      configArg = {
        commitment: this.commitment
      };
    }
    const unsafeRes = await this._rpcRequest('getSupply', [configArg]);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetSupplyRpcResult);
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get supply');
    }
    return res.result;
  }

  /**
   * Fetch the current supply of a token mint
   */
  async getTokenSupply(tokenMintAddress, commitment) {
    const args = this._buildArgs([tokenMintAddress.toBase58()], commitment);
    const unsafeRes = await this._rpcRequest('getTokenSupply', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get token supply');
    }
    return res.result;
  }

  /**
   * Fetch the current balance of a token account
   */
  async getTokenAccountBalance(tokenAddress, commitment) {
    const args = this._buildArgs([tokenAddress.toBase58()], commitment);
    const unsafeRes = await this._rpcRequest('getTokenAccountBalance', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get token account balance');
    }
    return res.result;
  }

  /**
   * Fetch all the token accounts owned by the specified account
   *
   * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>>}
   */
  async getTokenAccountsByOwner(ownerAddress, filter, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    let _args = [ownerAddress.toBase58()];
    if ('mint' in filter) {
      _args.push({
        mint: filter.mint.toBase58()
      });
    } else {
      _args.push({
        programId: filter.programId.toBase58()
      });
    }
    const args = this._buildArgs(_args, commitment, 'base64', config);
    const unsafeRes = await this._rpcRequest('getTokenAccountsByOwner', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetTokenAccountsByOwner);
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
    }
    return res.result;
  }

  /**
   * Fetch parsed token accounts owned by the specified account
   *
   * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}
   */
  async getParsedTokenAccountsByOwner(ownerAddress, filter, commitment) {
    let _args = [ownerAddress.toBase58()];
    if ('mint' in filter) {
      _args.push({
        mint: filter.mint.toBase58()
      });
    } else {
      _args.push({
        programId: filter.programId.toBase58()
      });
    }
    const args = this._buildArgs(_args, commitment, 'jsonParsed');
    const unsafeRes = await this._rpcRequest('getTokenAccountsByOwner', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetParsedTokenAccountsByOwner);
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
    }
    return res.result;
  }

  /**
   * Fetch the 20 largest accounts with their current balances
   */
  async getLargestAccounts(config) {
    const arg = {
      ...config,
      commitment: config && config.commitment || this.commitment
    };
    const args = arg.filter || arg.commitment ? [arg] : [];
    const unsafeRes = await this._rpcRequest('getLargestAccounts', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetLargestAccountsRpcResult);
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get largest accounts');
    }
    return res.result;
  }

  /**
   * Fetch the 20 largest token accounts with their current balances
   * for a given mint.
   */
  async getTokenLargestAccounts(mintAddress, commitment) {
    const args = this._buildArgs([mintAddress.toBase58()], commitment);
    const unsafeRes = await this._rpcRequest('getTokenLargestAccounts', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetTokenLargestAccountsResult);
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get token largest accounts');
    }
    return res.result;
  }

  /**
   * Fetch all the account info for the specified public key, return with context
   */
  async getAccountInfoAndContext(publicKey, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([publicKey.toBase58()], commitment, 'base64', config);
    const unsafeRes = await this._rpcRequest('getAccountInfo', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)(AccountInfoResult)));
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey.toBase58()}`);
    }
    return res.result;
  }

  /**
   * Fetch parsed account info for the specified public key
   */
  async getParsedAccountInfo(publicKey, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([publicKey.toBase58()], commitment, 'jsonParsed', config);
    const unsafeRes = await this._rpcRequest('getAccountInfo', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)(ParsedAccountInfoResult)));
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey.toBase58()}`);
    }
    return res.result;
  }

  /**
   * Fetch all the account info for the specified public key
   */
  async getAccountInfo(publicKey, commitmentOrConfig) {
    try {
      const res = await this.getAccountInfoAndContext(publicKey, commitmentOrConfig);
      return res.value;
    } catch (e) {
      throw new Error('failed to get info about account ' + publicKey.toBase58() + ': ' + e);
    }
  }

  /**
   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
   */
  async getMultipleParsedAccounts(publicKeys, rawConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(rawConfig);
    const keys = publicKeys.map(key => key.toBase58());
    const args = this._buildArgs([keys], commitment, 'jsonParsed', config);
    const unsafeRes = await this._rpcRequest('getMultipleAccounts', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)(ParsedAccountInfoResult))));
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);
    }
    return res.result;
  }

  /**
   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
   */
  async getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const keys = publicKeys.map(key => key.toBase58());
    const args = this._buildArgs([keys], commitment, 'base64', config);
    const unsafeRes = await this._rpcRequest('getMultipleAccounts', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)(AccountInfoResult))));
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);
    }
    return res.result;
  }

  /**
   * Fetch all the account info for multiple accounts specified by an array of public keys
   */
  async getMultipleAccountsInfo(publicKeys, commitmentOrConfig) {
    const res = await this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig);
    return res.value;
  }

  /**
   * Returns epoch activation information for a stake account that has been delegated
   */
  async getStakeActivation(publicKey, commitmentOrConfig, epoch) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([publicKey.toBase58()], commitment, undefined /* encoding */, {
      ...config,
      epoch: epoch != null ? epoch : config?.epoch
    });
    const unsafeRes = await this._rpcRequest('getStakeActivation', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, jsonRpcResult(StakeActivationResult));
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get Stake Activation ${publicKey.toBase58()}`);
    }
    return res.result;
  }

  /**
   * Fetch all the accounts owned by the specified program id
   *
   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}
   */
  async getProgramAccounts(programId, configOrCommitment) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(configOrCommitment);
    const {
      encoding,
      ...configWithoutEncoding
    } = config || {};
    const args = this._buildArgs([programId.toBase58()], commitment, encoding || 'base64', configWithoutEncoding);
    const unsafeRes = await this._rpcRequest('getProgramAccounts', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)(KeyedAccountInfoResult)));
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
    }
    return res.result;
  }

  /**
   * Fetch and parse all the accounts owned by the specified program id
   *
   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}
   */
  async getParsedProgramAccounts(programId, configOrCommitment) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(configOrCommitment);
    const args = this._buildArgs([programId.toBase58()], commitment, 'jsonParsed', config);
    const unsafeRes = await this._rpcRequest('getProgramAccounts', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)(KeyedParsedAccountInfoResult)));
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
    }
    return res.result;
  }
  // eslint-disable-next-line no-dupe-class-members
  async confirmTransaction(strategy, commitment) {
    let rawSignature;
    if (typeof strategy == 'string') {
      rawSignature = strategy;
    } else {
      const config = strategy;
      if (config.abortSignal?.aborted) {
        return Promise.reject(config.abortSignal.reason);
      }
      rawSignature = config.signature;
    }
    let decodedSignature;
    try {
      decodedSignature = bs58__WEBPACK_IMPORTED_MODULE_4___default().decode(rawSignature);
    } catch (err) {
      throw new Error('signature must be base58 encoded: ' + rawSignature);
    }
    assert(decodedSignature.length === 64, 'signature has invalid length');
    if (typeof strategy === 'string') {
      return await this.confirmTransactionUsingLegacyTimeoutStrategy({
        commitment: commitment || this.commitment,
        signature: rawSignature
      });
    } else if ('lastValidBlockHeight' in strategy) {
      return await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
        commitment: commitment || this.commitment,
        strategy
      });
    } else {
      return await this.confirmTransactionUsingDurableNonceStrategy({
        commitment: commitment || this.commitment,
        strategy
      });
    }
  }
  getCancellationPromise(signal) {
    return new Promise((_, reject) => {
      if (signal == null) {
        return;
      }
      if (signal.aborted) {
        reject(signal.reason);
      } else {
        signal.addEventListener('abort', () => {
          reject(signal.reason);
        });
      }
    });
  }
  getTransactionConfirmationPromise({
    commitment,
    signature
  }) {
    let signatureSubscriptionId;
    let disposeSignatureSubscriptionStateChangeObserver;
    let done = false;
    const confirmationPromise = new Promise((resolve, reject) => {
      try {
        signatureSubscriptionId = this.onSignature(signature, (result, context) => {
          signatureSubscriptionId = undefined;
          const response = {
            context,
            value: result
          };
          resolve({
            __type: TransactionStatus.PROCESSED,
            response
          });
        }, commitment);
        const subscriptionSetupPromise = new Promise(resolveSubscriptionSetup => {
          if (signatureSubscriptionId == null) {
            resolveSubscriptionSetup();
          } else {
            disposeSignatureSubscriptionStateChangeObserver = this._onSubscriptionStateChange(signatureSubscriptionId, nextState => {
              if (nextState === 'subscribed') {
                resolveSubscriptionSetup();
              }
            });
          }
        });
        (async () => {
          await subscriptionSetupPromise;
          if (done) return;
          const response = await this.getSignatureStatus(signature);
          if (done) return;
          if (response == null) {
            return;
          }
          const {
            context,
            value
          } = response;
          if (value == null) {
            return;
          }
          if (value?.err) {
            reject(value.err);
          } else {
            switch (commitment) {
              case 'confirmed':
              case 'single':
              case 'singleGossip':
                {
                  if (value.confirmationStatus === 'processed') {
                    return;
                  }
                  break;
                }
              case 'finalized':
              case 'max':
              case 'root':
                {
                  if (value.confirmationStatus === 'processed' || value.confirmationStatus === 'confirmed') {
                    return;
                  }
                  break;
                }
              // exhaust enums to ensure full coverage
              case 'processed':
              case 'recent':
            }
            done = true;
            resolve({
              __type: TransactionStatus.PROCESSED,
              response: {
                context,
                value
              }
            });
          }
        })();
      } catch (err) {
        reject(err);
      }
    });
    const abortConfirmation = () => {
      if (disposeSignatureSubscriptionStateChangeObserver) {
        disposeSignatureSubscriptionStateChangeObserver();
        disposeSignatureSubscriptionStateChangeObserver = undefined;
      }
      if (signatureSubscriptionId != null) {
        this.removeSignatureListener(signatureSubscriptionId);
        signatureSubscriptionId = undefined;
      }
    };
    return {
      abortConfirmation,
      confirmationPromise
    };
  }
  async confirmTransactionUsingBlockHeightExceedanceStrategy({
    commitment,
    strategy: {
      abortSignal,
      lastValidBlockHeight,
      signature
    }
  }) {
    let done = false;
    const expiryPromise = new Promise(resolve => {
      const checkBlockHeight = async () => {
        try {
          const blockHeight = await this.getBlockHeight(commitment);
          return blockHeight;
        } catch (_e) {
          return -1;
        }
      };
      (async () => {
        let currentBlockHeight = await checkBlockHeight();
        if (done) return;
        while (currentBlockHeight <= lastValidBlockHeight) {
          await sleep(1000);
          if (done) return;
          currentBlockHeight = await checkBlockHeight();
          if (done) return;
        }
        resolve({
          __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED
        });
      })();
    });
    const {
      abortConfirmation,
      confirmationPromise
    } = this.getTransactionConfirmationPromise({
      commitment,
      signature
    });
    const cancellationPromise = this.getCancellationPromise(abortSignal);
    let result;
    try {
      const outcome = await Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);
      if (outcome.__type === TransactionStatus.PROCESSED) {
        result = outcome.response;
      } else {
        throw new TransactionExpiredBlockheightExceededError(signature);
      }
    } finally {
      done = true;
      abortConfirmation();
    }
    return result;
  }
  async confirmTransactionUsingDurableNonceStrategy({
    commitment,
    strategy: {
      abortSignal,
      minContextSlot,
      nonceAccountPubkey,
      nonceValue,
      signature
    }
  }) {
    let done = false;
    const expiryPromise = new Promise(resolve => {
      let currentNonceValue = nonceValue;
      let lastCheckedSlot = null;
      const getCurrentNonceValue = async () => {
        try {
          const {
            context,
            value: nonceAccount
          } = await this.getNonceAndContext(nonceAccountPubkey, {
            commitment,
            minContextSlot
          });
          lastCheckedSlot = context.slot;
          return nonceAccount?.nonce;
        } catch (e) {
          // If for whatever reason we can't reach/read the nonce
          // account, just keep using the last-known value.
          return currentNonceValue;
        }
      };
      (async () => {
        currentNonceValue = await getCurrentNonceValue();
        if (done) return;
        while (true // eslint-disable-line no-constant-condition
        ) {
          if (nonceValue !== currentNonceValue) {
            resolve({
              __type: TransactionStatus.NONCE_INVALID,
              slotInWhichNonceDidAdvance: lastCheckedSlot
            });
            return;
          }
          await sleep(2000);
          if (done) return;
          currentNonceValue = await getCurrentNonceValue();
          if (done) return;
        }
      })();
    });
    const {
      abortConfirmation,
      confirmationPromise
    } = this.getTransactionConfirmationPromise({
      commitment,
      signature
    });
    const cancellationPromise = this.getCancellationPromise(abortSignal);
    let result;
    try {
      const outcome = await Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);
      if (outcome.__type === TransactionStatus.PROCESSED) {
        result = outcome.response;
      } else {
        // Double check that the transaction is indeed unconfirmed.
        let signatureStatus;
        while (true // eslint-disable-line no-constant-condition
        ) {
          const status = await this.getSignatureStatus(signature);
          if (status == null) {
            break;
          }
          if (status.context.slot < (outcome.slotInWhichNonceDidAdvance ?? minContextSlot)) {
            await sleep(400);
            continue;
          }
          signatureStatus = status;
          break;
        }
        if (signatureStatus?.value) {
          const commitmentForStatus = commitment || 'finalized';
          const {
            confirmationStatus
          } = signatureStatus.value;
          switch (commitmentForStatus) {
            case 'processed':
            case 'recent':
              if (confirmationStatus !== 'processed' && confirmationStatus !== 'confirmed' && confirmationStatus !== 'finalized') {
                throw new TransactionExpiredNonceInvalidError(signature);
              }
              break;
            case 'confirmed':
            case 'single':
            case 'singleGossip':
              if (confirmationStatus !== 'confirmed' && confirmationStatus !== 'finalized') {
                throw new TransactionExpiredNonceInvalidError(signature);
              }
              break;
            case 'finalized':
            case 'max':
            case 'root':
              if (confirmationStatus !== 'finalized') {
                throw new TransactionExpiredNonceInvalidError(signature);
              }
              break;
            default:
              // Exhaustive switch.
              // eslint-disable-next-line @typescript-eslint/no-unused-vars
              (_ => {})(commitmentForStatus);
          }
          result = {
            context: signatureStatus.context,
            value: {
              err: signatureStatus.value.err
            }
          };
        } else {
          throw new TransactionExpiredNonceInvalidError(signature);
        }
      }
    } finally {
      done = true;
      abortConfirmation();
    }
    return result;
  }
  async confirmTransactionUsingLegacyTimeoutStrategy({
    commitment,
    signature
  }) {
    let timeoutId;
    const expiryPromise = new Promise(resolve => {
      let timeoutMs = this._confirmTransactionInitialTimeout || 60 * 1000;
      switch (commitment) {
        case 'processed':
        case 'recent':
        case 'single':
        case 'confirmed':
        case 'singleGossip':
          {
            timeoutMs = this._confirmTransactionInitialTimeout || 30 * 1000;
            break;
          }
      }
      timeoutId = setTimeout(() => resolve({
        __type: TransactionStatus.TIMED_OUT,
        timeoutMs
      }), timeoutMs);
    });
    const {
      abortConfirmation,
      confirmationPromise
    } = this.getTransactionConfirmationPromise({
      commitment,
      signature
    });
    let result;
    try {
      const outcome = await Promise.race([confirmationPromise, expiryPromise]);
      if (outcome.__type === TransactionStatus.PROCESSED) {
        result = outcome.response;
      } else {
        throw new TransactionExpiredTimeoutError(signature, outcome.timeoutMs / 1000);
      }
    } finally {
      clearTimeout(timeoutId);
      abortConfirmation();
    }
    return result;
  }

  /**
   * Return the list of nodes that are currently participating in the cluster
   */
  async getClusterNodes() {
    const unsafeRes = await this._rpcRequest('getClusterNodes', []);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)(ContactInfoResult)));
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get cluster nodes');
    }
    return res.result;
  }

  /**
   * Return the list of nodes that are currently participating in the cluster
   */
  async getVoteAccounts(commitment) {
    const args = this._buildArgs([], commitment);
    const unsafeRes = await this._rpcRequest('getVoteAccounts', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetVoteAccounts);
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get vote accounts');
    }
    return res.result;
  }

  /**
   * Fetch the current slot that the node is processing
   */
  async getSlot(commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([], commitment, undefined /* encoding */, config);
    const unsafeRes = await this._rpcRequest('getSlot', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()));
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get slot');
    }
    return res.result;
  }

  /**
   * Fetch the current slot leader of the cluster
   */
  async getSlotLeader(commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([], commitment, undefined /* encoding */, config);
    const unsafeRes = await this._rpcRequest('getSlotLeader', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)()));
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get slot leader');
    }
    return res.result;
  }

  /**
   * Fetch `limit` number of slot leaders starting from `startSlot`
   *
   * @param startSlot fetch slot leaders starting from this slot
   * @param limit number of slot leaders to return
   */
  async getSlotLeaders(startSlot, limit) {
    const args = [startSlot, limit];
    const unsafeRes = await this._rpcRequest('getSlotLeaders', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)(PublicKeyFromString)));
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get slot leaders');
    }
    return res.result;
  }

  /**
   * Fetch the current status of a signature
   */
  async getSignatureStatus(signature, config) {
    const {
      context,
      value: values
    } = await this.getSignatureStatuses([signature], config);
    assert(values.length === 1);
    const value = values[0];
    return {
      context,
      value
    };
  }

  /**
   * Fetch the current statuses of a batch of signatures
   */
  async getSignatureStatuses(signatures, config) {
    const params = [signatures];
    if (config) {
      params.push(config);
    }
    const unsafeRes = await this._rpcRequest('getSignatureStatuses', params);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetSignatureStatusesRpcResult);
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get signature status');
    }
    return res.result;
  }

  /**
   * Fetch the current transaction count of the cluster
   */
  async getTransactionCount(commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([], commitment, undefined /* encoding */, config);
    const unsafeRes = await this._rpcRequest('getTransactionCount', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()));
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get transaction count');
    }
    return res.result;
  }

  /**
   * Fetch the current total currency supply of the cluster in lamports
   *
   * @deprecated Deprecated since v1.2.8. Please use {@link getSupply} instead.
   */
  async getTotalSupply(commitment) {
    const result = await this.getSupply({
      commitment,
      excludeNonCirculatingAccountsList: true
    });
    return result.value.total;
  }

  /**
   * Fetch the cluster InflationGovernor parameters
   */
  async getInflationGovernor(commitment) {
    const args = this._buildArgs([], commitment);
    const unsafeRes = await this._rpcRequest('getInflationGovernor', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetInflationGovernorRpcResult);
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get inflation');
    }
    return res.result;
  }

  /**
   * Fetch the inflation reward for a list of addresses for an epoch
   */
  async getInflationReward(addresses, epoch, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([addresses.map(pubkey => pubkey.toBase58())], commitment, undefined /* encoding */, {
      ...config,
      epoch: epoch != null ? epoch : config?.epoch
    });
    const unsafeRes = await this._rpcRequest('getInflationReward', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetInflationRewardResult);
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get inflation reward');
    }
    return res.result;
  }

  /**
   * Fetch the specific inflation values for the current epoch
   */
  async getInflationRate() {
    const unsafeRes = await this._rpcRequest('getInflationRate', []);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetInflationRateRpcResult);
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get inflation rate');
    }
    return res.result;
  }

  /**
   * Fetch the Epoch Info parameters
   */
  async getEpochInfo(commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([], commitment, undefined /* encoding */, config);
    const unsafeRes = await this._rpcRequest('getEpochInfo', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetEpochInfoRpcResult);
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get epoch info');
    }
    return res.result;
  }

  /**
   * Fetch the Epoch Schedule parameters
   */
  async getEpochSchedule() {
    const unsafeRes = await this._rpcRequest('getEpochSchedule', []);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetEpochScheduleRpcResult);
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get epoch schedule');
    }
    const epochSchedule = res.result;
    return new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot);
  }

  /**
   * Fetch the leader schedule for the current epoch
   * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}
   */
  async getLeaderSchedule() {
    const unsafeRes = await this._rpcRequest('getLeaderSchedule', []);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetLeaderScheduleRpcResult);
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get leader schedule');
    }
    return res.result;
  }

  /**
   * Fetch the minimum balance needed to exempt an account of `dataLength`
   * size from rent
   */
  async getMinimumBalanceForRentExemption(dataLength, commitment) {
    const args = this._buildArgs([dataLength], commitment);
    const unsafeRes = await this._rpcRequest('getMinimumBalanceForRentExemption', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult);
    if ('error' in res) {
      console.warn('Unable to fetch minimum balance for rent exemption');
      return 0;
    }
    return res.result;
  }

  /**
   * Fetch a recent blockhash from the cluster, return with context
   * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getLatestBlockhash} instead.
   */
  async getRecentBlockhashAndContext(commitment) {
    const args = this._buildArgs([], commitment);
    const unsafeRes = await this._rpcRequest('getRecentBlockhash', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetRecentBlockhashAndContextRpcResult);
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get recent blockhash');
    }
    return res.result;
  }

  /**
   * Fetch recent performance samples
   * @return {Promise<Array<PerfSample>>}
   */
  async getRecentPerformanceSamples(limit) {
    const unsafeRes = await this._rpcRequest('getRecentPerformanceSamples', limit ? [limit] : []);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetRecentPerformanceSamplesRpcResult);
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get recent performance samples');
    }
    return res.result;
  }

  /**
   * Fetch the fee calculator for a recent blockhash from the cluster, return with context
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getFeeForMessage} instead.
   */
  async getFeeCalculatorForBlockhash(blockhash, commitment) {
    const args = this._buildArgs([blockhash], commitment);
    const unsafeRes = await this._rpcRequest('getFeeCalculatorForBlockhash', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetFeeCalculatorRpcResult);
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get fee calculator');
    }
    const {
      context,
      value
    } = res.result;
    return {
      context,
      value: value !== null ? value.feeCalculator : null
    };
  }

  /**
   * Fetch the fee for a message from the cluster, return with context
   */
  async getFeeForMessage(message, commitment) {
    const wireMessage = toBuffer(message.serialize()).toString('base64');
    const args = this._buildArgs([wireMessage], commitment);
    const unsafeRes = await this._rpcRequest('getFeeForMessage', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)())));
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get fee for message');
    }
    if (res.result === null) {
      throw new Error('invalid blockhash');
    }
    return res.result;
  }

  /**
   * Fetch a list of prioritization fees from recent blocks.
   */
  async getRecentPrioritizationFees(config) {
    const accounts = config?.lockedWritableAccounts?.map(key => key.toBase58());
    const args = this._buildArgs(accounts?.length ? [accounts] : []);
    const unsafeRes = await this._rpcRequest('getRecentPrioritizationFees', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetRecentPrioritizationFeesRpcResult);
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get recent prioritization fees');
    }
    return res.result;
  }
  /**
   * Fetch a recent blockhash from the cluster
   * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getLatestBlockhash} instead.
   */
  async getRecentBlockhash(commitment) {
    try {
      const res = await this.getRecentBlockhashAndContext(commitment);
      return res.value;
    } catch (e) {
      throw new Error('failed to get recent blockhash: ' + e);
    }
  }

  /**
   * Fetch the latest blockhash from the cluster
   * @return {Promise<BlockhashWithExpiryBlockHeight>}
   */
  async getLatestBlockhash(commitmentOrConfig) {
    try {
      const res = await this.getLatestBlockhashAndContext(commitmentOrConfig);
      return res.value;
    } catch (e) {
      throw new Error('failed to get recent blockhash: ' + e);
    }
  }

  /**
   * Fetch the latest blockhash from the cluster
   * @return {Promise<BlockhashWithExpiryBlockHeight>}
   */
  async getLatestBlockhashAndContext(commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([], commitment, undefined /* encoding */, config);
    const unsafeRes = await this._rpcRequest('getLatestBlockhash', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetLatestBlockhashRpcResult);
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get latest blockhash');
    }
    return res.result;
  }

  /**
   * Fetch the node version
   */
  async getVersion() {
    const unsafeRes = await this._rpcRequest('getVersion', []);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, jsonRpcResult(VersionResult));
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get version');
    }
    return res.result;
  }

  /**
   * Fetch the genesis hash
   */
  async getGenesisHash() {
    const unsafeRes = await this._rpcRequest('getGenesisHash', []);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)()));
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get genesis hash');
    }
    return res.result;
  }

  /**
   * Fetch a processed block from the cluster.
   *
   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
   * setting the `maxSupportedTransactionVersion` property.
   */

  /**
   * Fetch a processed block from the cluster.
   */
  // eslint-disable-next-line no-dupe-class-members
  async getBlock(slot, rawConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(rawConfig);
    const args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined /* encoding */, config);
    const unsafeRes = await this._rpcRequest('getBlock', args);
    try {
      switch (config?.transactionDetails) {
        case 'accounts':
          {
            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetAccountsModeBlockRpcResult);
            if ('error' in res) {
              throw res.error;
            }
            return res.result;
          }
        case 'none':
          {
            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetNoneModeBlockRpcResult);
            if ('error' in res) {
              throw res.error;
            }
            return res.result;
          }
        default:
          {
            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetBlockRpcResult);
            if ('error' in res) {
              throw res.error;
            }
            const {
              result
            } = res;
            return result ? {
              ...result,
              transactions: result.transactions.map(({
                transaction,
                meta,
                version
              }) => ({
                meta,
                transaction: {
                  ...transaction,
                  message: versionedMessageFromResponse(version, transaction.message)
                },
                version
              }))
            } : null;
          }
      }
    } catch (e) {
      throw new SolanaJSONRPCError(e, 'failed to get confirmed block');
    }
  }

  /**
   * Fetch parsed transaction details for a confirmed or finalized block
   */

  // eslint-disable-next-line no-dupe-class-members
  async getParsedBlock(slot, rawConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(rawConfig);
    const args = this._buildArgsAtLeastConfirmed([slot], commitment, 'jsonParsed', config);
    const unsafeRes = await this._rpcRequest('getBlock', args);
    try {
      switch (config?.transactionDetails) {
        case 'accounts':
          {
            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetParsedAccountsModeBlockRpcResult);
            if ('error' in res) {
              throw res.error;
            }
            return res.result;
          }
        case 'none':
          {
            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetParsedNoneModeBlockRpcResult);
            if ('error' in res) {
              throw res.error;
            }
            return res.result;
          }
        default:
          {
            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetParsedBlockRpcResult);
            if ('error' in res) {
              throw res.error;
            }
            return res.result;
          }
      }
    } catch (e) {
      throw new SolanaJSONRPCError(e, 'failed to get block');
    }
  }

  /*
   * Returns the current block height of the node
   */

  /*
   * Returns recent block production information from the current or previous epoch
   */
  async getBlockProduction(configOrCommitment) {
    let extra;
    let commitment;
    if (typeof configOrCommitment === 'string') {
      commitment = configOrCommitment;
    } else if (configOrCommitment) {
      const {
        commitment: c,
        ...rest
      } = configOrCommitment;
      commitment = c;
      extra = rest;
    }
    const args = this._buildArgs([], commitment, 'base64', extra);
    const unsafeRes = await this._rpcRequest('getBlockProduction', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, BlockProductionResponseStruct);
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get block production information');
    }
    return res.result;
  }

  /**
   * Fetch a confirmed or finalized transaction from the cluster.
   *
   * @deprecated Instead, call `getTransaction` using a
   * `GetVersionedTransactionConfig` by setting the
   * `maxSupportedTransactionVersion` property.
   */

  /**
   * Fetch a confirmed or finalized transaction from the cluster.
   */
  // eslint-disable-next-line no-dupe-class-members
  async getTransaction(signature, rawConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(rawConfig);
    const args = this._buildArgsAtLeastConfirmed([signature], commitment, undefined /* encoding */, config);
    const unsafeRes = await this._rpcRequest('getTransaction', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetTransactionRpcResult);
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get transaction');
    }
    const result = res.result;
    if (!result) return result;
    return {
      ...result,
      transaction: {
        ...result.transaction,
        message: versionedMessageFromResponse(result.version, result.transaction.message)
      }
    };
  }

  /**
   * Fetch parsed transaction details for a confirmed or finalized transaction
   */
  async getParsedTransaction(signature, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed', config);
    const unsafeRes = await this._rpcRequest('getTransaction', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetParsedTransactionRpcResult);
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get transaction');
    }
    return res.result;
  }

  /**
   * Fetch parsed transaction details for a batch of confirmed transactions
   */
  async getParsedTransactions(signatures, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const batch = signatures.map(signature => {
      const args = this._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed', config);
      return {
        methodName: 'getTransaction',
        args
      };
    });
    const unsafeRes = await this._rpcBatchRequest(batch);
    const res = unsafeRes.map(unsafeRes => {
      const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetParsedTransactionRpcResult);
      if ('error' in res) {
        throw new SolanaJSONRPCError(res.error, 'failed to get transactions');
      }
      return res.result;
    });
    return res;
  }

  /**
   * Fetch transaction details for a batch of confirmed transactions.
   * Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.
   *
   * @deprecated Instead, call `getTransactions` using a
   * `GetVersionedTransactionConfig` by setting the
   * `maxSupportedTransactionVersion` property.
   */

  /**
   * Fetch transaction details for a batch of confirmed transactions.
   * Similar to {@link getParsedTransactions} but returns a {@link
   * VersionedTransactionResponse}.
   */
  // eslint-disable-next-line no-dupe-class-members
  async getTransactions(signatures, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const batch = signatures.map(signature => {
      const args = this._buildArgsAtLeastConfirmed([signature], commitment, undefined /* encoding */, config);
      return {
        methodName: 'getTransaction',
        args
      };
    });
    const unsafeRes = await this._rpcBatchRequest(batch);
    const res = unsafeRes.map(unsafeRes => {
      const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetTransactionRpcResult);
      if ('error' in res) {
        throw new SolanaJSONRPCError(res.error, 'failed to get transactions');
      }
      const result = res.result;
      if (!result) return result;
      return {
        ...result,
        transaction: {
          ...result.transaction,
          message: versionedMessageFromResponse(result.version, result.transaction.message)
        }
      };
    });
    return res;
  }

  /**
   * Fetch a list of Transactions and transaction statuses from the cluster
   * for a confirmed block.
   *
   * @deprecated Deprecated since v1.13.0. Please use {@link getBlock} instead.
   */
  async getConfirmedBlock(slot, commitment) {
    const args = this._buildArgsAtLeastConfirmed([slot], commitment);
    const unsafeRes = await this._rpcRequest('getConfirmedBlock', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetConfirmedBlockRpcResult);
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get confirmed block');
    }
    const result = res.result;
    if (!result) {
      throw new Error('Confirmed block ' + slot + ' not found');
    }
    const block = {
      ...result,
      transactions: result.transactions.map(({
        transaction,
        meta
      }) => {
        const message = new Message(transaction.message);
        return {
          meta,
          transaction: {
            ...transaction,
            message
          }
        };
      })
    };
    return {
      ...block,
      transactions: block.transactions.map(({
        transaction,
        meta
      }) => {
        return {
          meta,
          transaction: Transaction.populate(transaction.message, transaction.signatures)
        };
      })
    };
  }

  /**
   * Fetch confirmed blocks between two slots
   */
  async getBlocks(startSlot, endSlot, commitment) {
    const args = this._buildArgsAtLeastConfirmed(endSlot !== undefined ? [startSlot, endSlot] : [startSlot], commitment);
    const unsafeRes = await this._rpcRequest('getBlocks', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)())));
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get blocks');
    }
    return res.result;
  }

  /**
   * Fetch a list of Signatures from the cluster for a block, excluding rewards
   */
  async getBlockSignatures(slot, commitment) {
    const args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined, {
      transactionDetails: 'signatures',
      rewards: false
    });
    const unsafeRes = await this._rpcRequest('getBlock', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetBlockSignaturesRpcResult);
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get block');
    }
    const result = res.result;
    if (!result) {
      throw new Error('Block ' + slot + ' not found');
    }
    return result;
  }

  /**
   * Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getBlockSignatures} instead.
   */
  async getConfirmedBlockSignatures(slot, commitment) {
    const args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined, {
      transactionDetails: 'signatures',
      rewards: false
    });
    const unsafeRes = await this._rpcRequest('getConfirmedBlock', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetBlockSignaturesRpcResult);
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get confirmed block');
    }
    const result = res.result;
    if (!result) {
      throw new Error('Confirmed block ' + slot + ' not found');
    }
    return result;
  }

  /**
   * Fetch a transaction details for a confirmed transaction
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getTransaction} instead.
   */
  async getConfirmedTransaction(signature, commitment) {
    const args = this._buildArgsAtLeastConfirmed([signature], commitment);
    const unsafeRes = await this._rpcRequest('getConfirmedTransaction', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetTransactionRpcResult);
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get transaction');
    }
    const result = res.result;
    if (!result) return result;
    const message = new Message(result.transaction.message);
    const signatures = result.transaction.signatures;
    return {
      ...result,
      transaction: Transaction.populate(message, signatures)
    };
  }

  /**
   * Fetch parsed transaction details for a confirmed transaction
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getParsedTransaction} instead.
   */
  async getParsedConfirmedTransaction(signature, commitment) {
    const args = this._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed');
    const unsafeRes = await this._rpcRequest('getConfirmedTransaction', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetParsedTransactionRpcResult);
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get confirmed transaction');
    }
    return res.result;
  }

  /**
   * Fetch parsed transaction details for a batch of confirmed transactions
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getParsedTransactions} instead.
   */
  async getParsedConfirmedTransactions(signatures, commitment) {
    const batch = signatures.map(signature => {
      const args = this._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed');
      return {
        methodName: 'getConfirmedTransaction',
        args
      };
    });
    const unsafeRes = await this._rpcBatchRequest(batch);
    const res = unsafeRes.map(unsafeRes => {
      const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetParsedTransactionRpcResult);
      if ('error' in res) {
        throw new SolanaJSONRPCError(res.error, 'failed to get confirmed transactions');
      }
      return res.result;
    });
    return res;
  }

  /**
   * Fetch a list of all the confirmed signatures for transactions involving an address
   * within a specified slot range. Max range allowed is 10,000 slots.
   *
   * @deprecated Deprecated since v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.
   *
   * @param address queried address
   * @param startSlot start slot, inclusive
   * @param endSlot end slot, inclusive
   */
  async getConfirmedSignaturesForAddress(address, startSlot, endSlot) {
    let options = {};
    let firstAvailableBlock = await this.getFirstAvailableBlock();
    while (!('until' in options)) {
      startSlot--;
      if (startSlot <= 0 || startSlot < firstAvailableBlock) {
        break;
      }
      try {
        const block = await this.getConfirmedBlockSignatures(startSlot, 'finalized');
        if (block.signatures.length > 0) {
          options.until = block.signatures[block.signatures.length - 1].toString();
        }
      } catch (err) {
        if (err instanceof Error && err.message.includes('skipped')) {
          continue;
        } else {
          throw err;
        }
      }
    }
    let highestConfirmedRoot = await this.getSlot('finalized');
    while (!('before' in options)) {
      endSlot++;
      if (endSlot > highestConfirmedRoot) {
        break;
      }
      try {
        const block = await this.getConfirmedBlockSignatures(endSlot);
        if (block.signatures.length > 0) {
          options.before = block.signatures[block.signatures.length - 1].toString();
        }
      } catch (err) {
        if (err instanceof Error && err.message.includes('skipped')) {
          continue;
        } else {
          throw err;
        }
      }
    }
    const confirmedSignatureInfo = await this.getConfirmedSignaturesForAddress2(address, options);
    return confirmedSignatureInfo.map(info => info.signature);
  }

  /**
   * Returns confirmed signatures for transactions involving an
   * address backwards in time from the provided signature or most recent confirmed block
   *
   *
   * @param address queried address
   * @param options
   */
  async getConfirmedSignaturesForAddress2(address, options, commitment) {
    const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, undefined, options);
    const unsafeRes = await this._rpcRequest('getConfirmedSignaturesForAddress2', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult);
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get confirmed signatures for address');
    }
    return res.result;
  }

  /**
   * Returns confirmed signatures for transactions involving an
   * address backwards in time from the provided signature or most recent confirmed block
   *
   *
   * @param address queried address
   * @param options
   */
  async getSignaturesForAddress(address, options, commitment) {
    const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, undefined, options);
    const unsafeRes = await this._rpcRequest('getSignaturesForAddress', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, GetSignaturesForAddressRpcResult);
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, 'failed to get signatures for address');
    }
    return res.result;
  }
  async getAddressLookupTable(accountKey, config) {
    const {
      context,
      value: accountInfo
    } = await this.getAccountInfoAndContext(accountKey, config);
    let value = null;
    if (accountInfo !== null) {
      value = new AddressLookupTableAccount({
        key: accountKey,
        state: AddressLookupTableAccount.deserialize(accountInfo.data)
      });
    }
    return {
      context,
      value
    };
  }

  /**
   * Fetch the contents of a Nonce account from the cluster, return with context
   */
  async getNonceAndContext(nonceAccount, commitmentOrConfig) {
    const {
      context,
      value: accountInfo
    } = await this.getAccountInfoAndContext(nonceAccount, commitmentOrConfig);
    let value = null;
    if (accountInfo !== null) {
      value = NonceAccount.fromAccountData(accountInfo.data);
    }
    return {
      context,
      value
    };
  }

  /**
   * Fetch the contents of a Nonce account from the cluster
   */
  async getNonce(nonceAccount, commitmentOrConfig) {
    return await this.getNonceAndContext(nonceAccount, commitmentOrConfig).then(x => x.value).catch(e => {
      throw new Error('failed to get nonce for account ' + nonceAccount.toBase58() + ': ' + e);
    });
  }

  /**
   * Request an allocation of lamports to the specified address
   *
   * ```typescript
   * import { Connection, PublicKey, LAMPORTS_PER_SOL } from "@solana/web3.js";
   *
   * (async () => {
   *   const connection = new Connection("https://api.testnet.solana.com", "confirmed");
   *   const myAddress = new PublicKey("2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM");
   *   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);
   *   await connection.confirmTransaction(signature);
   * })();
   * ```
   */
  async requestAirdrop(to, lamports) {
    const unsafeRes = await this._rpcRequest('requestAirdrop', [to.toBase58(), lamports]);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, RequestAirdropRpcResult);
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, `airdrop to ${to.toBase58()} failed`);
    }
    return res.result;
  }

  /**
   * @internal
   */
  async _blockhashWithExpiryBlockHeight(disableCache) {
    if (!disableCache) {
      // Wait for polling to finish
      while (this._pollingBlockhash) {
        await sleep(100);
      }
      const timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;
      const expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;
      if (this._blockhashInfo.latestBlockhash !== null && !expired) {
        return this._blockhashInfo.latestBlockhash;
      }
    }
    return await this._pollNewBlockhash();
  }

  /**
   * @internal
   */
  async _pollNewBlockhash() {
    this._pollingBlockhash = true;
    try {
      const startTime = Date.now();
      const cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;
      const cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;
      for (let i = 0; i < 50; i++) {
        const latestBlockhash = await this.getLatestBlockhash('finalized');
        if (cachedBlockhash !== latestBlockhash.blockhash) {
          this._blockhashInfo = {
            latestBlockhash,
            lastFetch: Date.now(),
            transactionSignatures: [],
            simulatedSignatures: []
          };
          return latestBlockhash;
        }

        // Sleep for approximately half a slot
        await sleep(MS_PER_SLOT / 2);
      }
      throw new Error(`Unable to obtain a new blockhash after ${Date.now() - startTime}ms`);
    } finally {
      this._pollingBlockhash = false;
    }
  }

  /**
   * get the stake minimum delegation
   */
  async getStakeMinimumDelegation(config) {
    const {
      commitment,
      config: configArg
    } = extractCommitmentFromConfig(config);
    const args = this._buildArgs([], commitment, 'base64', configArg);
    const unsafeRes = await this._rpcRequest('getStakeMinimumDelegation', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .number */ .Rx)()));
    if ('error' in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get stake minimum delegation`);
    }
    return res.result;
  }

  /**
   * Simulate a transaction
   *
   * @deprecated Instead, call {@link simulateTransaction} with {@link
   * VersionedTransaction} and {@link SimulateTransactionConfig} parameters
   */

  /**
   * Simulate a transaction
   */
  // eslint-disable-next-line no-dupe-class-members
  async simulateTransaction(transactionOrMessage, configOrSigners, includeAccounts) {
    if ('message' in transactionOrMessage) {
      const versionedTx = transactionOrMessage;
      const wireTransaction = versionedTx.serialize();
      const encodedTransaction = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(wireTransaction).toString('base64');
      if (Array.isArray(configOrSigners) || includeAccounts !== undefined) {
        throw new Error('Invalid arguments');
      }
      const config = configOrSigners || {};
      config.encoding = 'base64';
      if (!('commitment' in config)) {
        config.commitment = this.commitment;
      }
      const args = [encodedTransaction, config];
      const unsafeRes = await this._rpcRequest('simulateTransaction', args);
      const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, SimulatedTransactionResponseStruct);
      if ('error' in res) {
        throw new Error('failed to simulate transaction: ' + res.error.message);
      }
      return res.result;
    }
    let transaction;
    if (transactionOrMessage instanceof Transaction) {
      let originalTx = transactionOrMessage;
      transaction = new Transaction();
      transaction.feePayer = originalTx.feePayer;
      transaction.instructions = transactionOrMessage.instructions;
      transaction.nonceInfo = originalTx.nonceInfo;
      transaction.signatures = originalTx.signatures;
    } else {
      transaction = Transaction.populate(transactionOrMessage);
      // HACK: this function relies on mutating the populated transaction
      transaction._message = transaction._json = undefined;
    }
    if (configOrSigners !== undefined && !Array.isArray(configOrSigners)) {
      throw new Error('Invalid arguments');
    }
    const signers = configOrSigners;
    if (transaction.nonceInfo && signers) {
      transaction.sign(...signers);
    } else {
      let disableCache = this._disableBlockhashCaching;
      for (;;) {
        const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);
        transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
        transaction.recentBlockhash = latestBlockhash.blockhash;
        if (!signers) break;
        transaction.sign(...signers);
        if (!transaction.signature) {
          throw new Error('!signature'); // should never happen
        }

        const signature = transaction.signature.toString('base64');
        if (!this._blockhashInfo.simulatedSignatures.includes(signature) && !this._blockhashInfo.transactionSignatures.includes(signature)) {
          // The signature of this transaction has not been seen before with the
          // current recentBlockhash, all done. Let's break
          this._blockhashInfo.simulatedSignatures.push(signature);
          break;
        } else {
          // This transaction would be treated as duplicate (its derived signature
          // matched to one of already recorded signatures).
          // So, we must fetch a new blockhash for a different signature by disabling
          // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).
          disableCache = true;
        }
      }
    }
    const message = transaction._compile();
    const signData = message.serialize();
    const wireTransaction = transaction._serialize(signData);
    const encodedTransaction = wireTransaction.toString('base64');
    const config = {
      encoding: 'base64',
      commitment: this.commitment
    };
    if (includeAccounts) {
      const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map(key => key.toBase58());
      config['accounts'] = {
        encoding: 'base64',
        addresses
      };
    }
    if (signers) {
      config.sigVerify = true;
    }
    const args = [encodedTransaction, config];
    const unsafeRes = await this._rpcRequest('simulateTransaction', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, SimulatedTransactionResponseStruct);
    if ('error' in res) {
      let logs;
      if ('data' in res.error) {
        logs = res.error.data.logs;
        if (logs && Array.isArray(logs)) {
          const traceIndent = '\n    ';
          const logTrace = traceIndent + logs.join(traceIndent);
          console.error(res.error.message, logTrace);
        }
      }
      throw new SendTransactionError('failed to simulate transaction: ' + res.error.message, logs);
    }
    return res.result;
  }

  /**
   * Sign and send a transaction
   *
   * @deprecated Instead, call {@link sendTransaction} with a {@link
   * VersionedTransaction}
   */

  /**
   * Sign and send a transaction
   */
  // eslint-disable-next-line no-dupe-class-members
  async sendTransaction(transaction, signersOrOptions, options) {
    if ('version' in transaction) {
      if (signersOrOptions && Array.isArray(signersOrOptions)) {
        throw new Error('Invalid arguments');
      }
      const wireTransaction = transaction.serialize();
      return await this.sendRawTransaction(wireTransaction, signersOrOptions);
    }
    if (signersOrOptions === undefined || !Array.isArray(signersOrOptions)) {
      throw new Error('Invalid arguments');
    }
    const signers = signersOrOptions;
    if (transaction.nonceInfo) {
      transaction.sign(...signers);
    } else {
      let disableCache = this._disableBlockhashCaching;
      for (;;) {
        const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);
        transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
        transaction.recentBlockhash = latestBlockhash.blockhash;
        transaction.sign(...signers);
        if (!transaction.signature) {
          throw new Error('!signature'); // should never happen
        }

        const signature = transaction.signature.toString('base64');
        if (!this._blockhashInfo.transactionSignatures.includes(signature)) {
          // The signature of this transaction has not been seen before with the
          // current recentBlockhash, all done. Let's break
          this._blockhashInfo.transactionSignatures.push(signature);
          break;
        } else {
          // This transaction would be treated as duplicate (its derived signature
          // matched to one of already recorded signatures).
          // So, we must fetch a new blockhash for a different signature by disabling
          // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).
          disableCache = true;
        }
      }
    }
    const wireTransaction = transaction.serialize();
    return await this.sendRawTransaction(wireTransaction, options);
  }

  /**
   * Send a transaction that has already been signed and serialized into the
   * wire format
   */
  async sendRawTransaction(rawTransaction, options) {
    const encodedTransaction = toBuffer(rawTransaction).toString('base64');
    const result = await this.sendEncodedTransaction(encodedTransaction, options);
    return result;
  }

  /**
   * Send a transaction that has already been signed, serialized into the
   * wire format, and encoded as a base64 string
   */
  async sendEncodedTransaction(encodedTransaction, options) {
    const config = {
      encoding: 'base64'
    };
    const skipPreflight = options && options.skipPreflight;
    const preflightCommitment = options && options.preflightCommitment || this.commitment;
    if (options && options.maxRetries != null) {
      config.maxRetries = options.maxRetries;
    }
    if (options && options.minContextSlot != null) {
      config.minContextSlot = options.minContextSlot;
    }
    if (skipPreflight) {
      config.skipPreflight = skipPreflight;
    }
    if (preflightCommitment) {
      config.preflightCommitment = preflightCommitment;
    }
    const args = [encodedTransaction, config];
    const unsafeRes = await this._rpcRequest('sendTransaction', args);
    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(unsafeRes, SendTransactionRpcResult);
    if ('error' in res) {
      let logs;
      if ('data' in res.error) {
        logs = res.error.data.logs;
      }
      throw new SendTransactionError('failed to send transaction: ' + res.error.message, logs);
    }
    return res.result;
  }

  /**
   * @internal
   */
  _wsOnOpen() {
    this._rpcWebSocketConnected = true;
    this._rpcWebSocketHeartbeat = setInterval(() => {
      // Ping server every 5s to prevent idle timeouts
      (async () => {
        try {
          await this._rpcWebSocket.notify('ping');
          // eslint-disable-next-line no-empty
        } catch {}
      })();
    }, 5000);
    this._updateSubscriptions();
  }

  /**
   * @internal
   */
  _wsOnError(err) {
    this._rpcWebSocketConnected = false;
    console.error('ws error:', err.message);
  }

  /**
   * @internal
   */
  _wsOnClose(code) {
    this._rpcWebSocketConnected = false;
    this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER;
    if (this._rpcWebSocketIdleTimeout) {
      clearTimeout(this._rpcWebSocketIdleTimeout);
      this._rpcWebSocketIdleTimeout = null;
    }
    if (this._rpcWebSocketHeartbeat) {
      clearInterval(this._rpcWebSocketHeartbeat);
      this._rpcWebSocketHeartbeat = null;
    }
    if (code === 1000) {
      // explicit close, check if any subscriptions have been made since close
      this._updateSubscriptions();
      return;
    }

    // implicit close, prepare subscriptions for auto-reconnect
    this._subscriptionCallbacksByServerSubscriptionId = {};
    Object.entries(this._subscriptionsByHash).forEach(([hash, subscription]) => {
      this._setSubscription(hash, {
        ...subscription,
        state: 'pending'
      });
    });
  }

  /**
   * @internal
   */
  _setSubscription(hash, nextSubscription) {
    const prevState = this._subscriptionsByHash[hash]?.state;
    this._subscriptionsByHash[hash] = nextSubscription;
    if (prevState !== nextSubscription.state) {
      const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash];
      if (stateChangeCallbacks) {
        stateChangeCallbacks.forEach(cb => {
          try {
            cb(nextSubscription.state);
            // eslint-disable-next-line no-empty
          } catch {}
        });
      }
    }
  }

  /**
   * @internal
   */
  _onSubscriptionStateChange(clientSubscriptionId, callback) {
    var _this$_subscriptionSt;
    const hash = this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
    if (hash == null) {
      return () => {};
    }
    const stateChangeCallbacks = (_this$_subscriptionSt = this._subscriptionStateChangeCallbacksByHash)[hash] || (_this$_subscriptionSt[hash] = new Set());
    stateChangeCallbacks.add(callback);
    return () => {
      stateChangeCallbacks.delete(callback);
      if (stateChangeCallbacks.size === 0) {
        delete this._subscriptionStateChangeCallbacksByHash[hash];
      }
    };
  }

  /**
   * @internal
   */
  async _updateSubscriptions() {
    if (Object.keys(this._subscriptionsByHash).length === 0) {
      if (this._rpcWebSocketConnected) {
        this._rpcWebSocketConnected = false;
        this._rpcWebSocketIdleTimeout = setTimeout(() => {
          this._rpcWebSocketIdleTimeout = null;
          try {
            this._rpcWebSocket.close();
          } catch (err) {
            // swallow error if socket has already been closed.
            if (err instanceof Error) {
              console.log(`Error when closing socket connection: ${err.message}`);
            }
          }
        }, 500);
      }
      return;
    }
    if (this._rpcWebSocketIdleTimeout !== null) {
      clearTimeout(this._rpcWebSocketIdleTimeout);
      this._rpcWebSocketIdleTimeout = null;
      this._rpcWebSocketConnected = true;
    }
    if (!this._rpcWebSocketConnected) {
      this._rpcWebSocket.connect();
      return;
    }
    const activeWebSocketGeneration = this._rpcWebSocketGeneration;
    const isCurrentConnectionStillActive = () => {
      return activeWebSocketGeneration === this._rpcWebSocketGeneration;
    };
    await Promise.all(
    // Don't be tempted to change this to `Object.entries`. We call
    // `_updateSubscriptions` recursively when processing the state,
    // so it's important that we look up the *current* version of
    // each subscription, every time we process a hash.
    Object.keys(this._subscriptionsByHash).map(async hash => {
      const subscription = this._subscriptionsByHash[hash];
      if (subscription === undefined) {
        // This entry has since been deleted. Skip.
        return;
      }
      switch (subscription.state) {
        case 'pending':
        case 'unsubscribed':
          if (subscription.callbacks.size === 0) {
            /**
             * You can end up here when:
             *
             * - a subscription has recently unsubscribed
             *   without having new callbacks added to it
             *   while the unsubscribe was in flight, or
             * - when a pending subscription has its
             *   listeners removed before a request was
             *   sent to the server.
             *
             * Being that nobody is interested in this
             * subscription any longer, delete it.
             */
            delete this._subscriptionsByHash[hash];
            if (subscription.state === 'unsubscribed') {
              delete this._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];
            }
            await this._updateSubscriptions();
            return;
          }
          await (async () => {
            const {
              args,
              method
            } = subscription;
            try {
              this._setSubscription(hash, {
                ...subscription,
                state: 'subscribing'
              });
              const serverSubscriptionId = await this._rpcWebSocket.call(method, args);
              this._setSubscription(hash, {
                ...subscription,
                serverSubscriptionId,
                state: 'subscribed'
              });
              this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId] = subscription.callbacks;
              await this._updateSubscriptions();
            } catch (e) {
              if (e instanceof Error) {
                console.error(`${method} error for argument`, args, e.message);
              }
              if (!isCurrentConnectionStillActive()) {
                return;
              }
              // TODO: Maybe add an 'errored' state or a retry limit?
              this._setSubscription(hash, {
                ...subscription,
                state: 'pending'
              });
              await this._updateSubscriptions();
            }
          })();
          break;
        case 'subscribed':
          if (subscription.callbacks.size === 0) {
            // By the time we successfully set up a subscription
            // with the server, the client stopped caring about it.
            // Tear it down now.
            await (async () => {
              const {
                serverSubscriptionId,
                unsubscribeMethod
              } = subscription;
              if (this._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)) {
                /**
                 * Special case.
                 * If we're dealing with a subscription that has been auto-
                 * disposed by the RPC, then we can skip the RPC call to
                 * tear down the subscription here.
                 *
                 * NOTE: There is a proposal to eliminate this special case, here:
                 * https://github.com/solana-labs/solana/issues/18892
                 */
                this._subscriptionsAutoDisposedByRpc.delete(serverSubscriptionId);
              } else {
                this._setSubscription(hash, {
                  ...subscription,
                  state: 'unsubscribing'
                });
                this._setSubscription(hash, {
                  ...subscription,
                  state: 'unsubscribing'
                });
                try {
                  await this._rpcWebSocket.call(unsubscribeMethod, [serverSubscriptionId]);
                } catch (e) {
                  if (e instanceof Error) {
                    console.error(`${unsubscribeMethod} error:`, e.message);
                  }
                  if (!isCurrentConnectionStillActive()) {
                    return;
                  }
                  // TODO: Maybe add an 'errored' state or a retry limit?
                  this._setSubscription(hash, {
                    ...subscription,
                    state: 'subscribed'
                  });
                  await this._updateSubscriptions();
                  return;
                }
              }
              this._setSubscription(hash, {
                ...subscription,
                state: 'unsubscribed'
              });
              await this._updateSubscriptions();
            })();
          }
          break;
      }
    }));
  }

  /**
   * @internal
   */
  _handleServerNotification(serverSubscriptionId, callbackArgs) {
    const callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];
    if (callbacks === undefined) {
      return;
    }
    callbacks.forEach(cb => {
      try {
        cb(
        // I failed to find a way to convince TypeScript that `cb` is of type
        // `TCallback` which is certainly compatible with `Parameters<TCallback>`.
        // See https://github.com/microsoft/TypeScript/issues/47615
        // @ts-ignore
        ...callbackArgs);
      } catch (e) {
        console.error(e);
      }
    });
  }

  /**
   * @internal
   */
  _wsOnAccountNotification(notification) {
    const {
      result,
      subscription
    } = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(notification, AccountNotificationResult);
    this._handleServerNotification(subscription, [result.value, result.context]);
  }

  /**
   * @internal
   */
  _makeSubscription(subscriptionConfig,
  /**
   * When preparing `args` for a call to `_makeSubscription`, be sure
   * to carefully apply a default `commitment` property, if necessary.
   *
   * - If the user supplied a `commitment` use that.
   * - Otherwise, if the `Connection::commitment` is set, use that.
   * - Otherwise, set it to the RPC server default: `finalized`.
   *
   * This is extremely important to ensure that these two fundamentally
   * identical subscriptions produce the same identifying hash:
   *
   * - A subscription made without specifying a commitment.
   * - A subscription made where the commitment specified is the same
   *   as the default applied to the subscription above.
   *
   * Example; these two subscriptions must produce the same hash:
   *
   * - An `accountSubscribe` subscription for `'PUBKEY'`
   * - An `accountSubscribe` subscription for `'PUBKEY'` with commitment
   *   `'finalized'`.
   *
   * See the 'making a subscription with defaulted params omitted' test
   * in `connection-subscriptions.ts` for more.
   */
  args) {
    const clientSubscriptionId = this._nextClientSubscriptionId++;
    const hash = fastStableStringify$1([subscriptionConfig.method, args]);

    const existingSubscription = this._subscriptionsByHash[hash];
    if (existingSubscription === undefined) {
      this._subscriptionsByHash[hash] = {
        ...subscriptionConfig,
        args,
        callbacks: new Set([subscriptionConfig.callback]),
        state: 'pending'
      };
    } else {
      existingSubscription.callbacks.add(subscriptionConfig.callback);
    }
    this._subscriptionHashByClientSubscriptionId[clientSubscriptionId] = hash;
    this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = async () => {
      delete this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
      delete this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
      const subscription = this._subscriptionsByHash[hash];
      assert(subscription !== undefined, `Could not find a \`Subscription\` when tearing down client subscription #${clientSubscriptionId}`);
      subscription.callbacks.delete(subscriptionConfig.callback);
      await this._updateSubscriptions();
    };
    this._updateSubscriptions();
    return clientSubscriptionId;
  }

  /**
   * Register a callback to be invoked whenever the specified account changes
   *
   * @param publicKey Public key of the account to monitor
   * @param callback Function to invoke whenever the account is changed
   * @param commitment Specify the commitment level account changes must reach before notification
   * @return subscription id
   */
  onAccountChange(publicKey, callback, commitment) {
    const args = this._buildArgs([publicKey.toBase58()], commitment || this._commitment || 'finalized',
    // Apply connection/server default.
    'base64');
    return this._makeSubscription({
      callback,
      method: 'accountSubscribe',
      unsubscribeMethod: 'accountUnsubscribe'
    }, args);
  }

  /**
   * Deregister an account notification callback
   *
   * @param id client subscription id to deregister
   */
  async removeAccountChangeListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, 'account change');
  }

  /**
   * @internal
   */
  _wsOnProgramAccountNotification(notification) {
    const {
      result,
      subscription
    } = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(notification, ProgramAccountNotificationResult);
    this._handleServerNotification(subscription, [{
      accountId: result.value.pubkey,
      accountInfo: result.value.account
    }, result.context]);
  }

  /**
   * Register a callback to be invoked whenever accounts owned by the
   * specified program change
   *
   * @param programId Public key of the program to monitor
   * @param callback Function to invoke whenever the account is changed
   * @param commitment Specify the commitment level account changes must reach before notification
   * @param filters The program account filters to pass into the RPC method
   * @return subscription id
   */
  onProgramAccountChange(programId, callback, commitment, filters) {
    const args = this._buildArgs([programId.toBase58()], commitment || this._commitment || 'finalized',
    // Apply connection/server default.
    'base64' /* encoding */, filters ? {
      filters: filters
    } : undefined /* extra */);

    return this._makeSubscription({
      callback,
      method: 'programSubscribe',
      unsubscribeMethod: 'programUnsubscribe'
    }, args);
  }

  /**
   * Deregister an account notification callback
   *
   * @param id client subscription id to deregister
   */
  async removeProgramAccountChangeListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, 'program account change');
  }

  /**
   * Registers a callback to be invoked whenever logs are emitted.
   */
  onLogs(filter, callback, commitment) {
    const args = this._buildArgs([typeof filter === 'object' ? {
      mentions: [filter.toString()]
    } : filter], commitment || this._commitment || 'finalized' // Apply connection/server default.
    );

    return this._makeSubscription({
      callback,
      method: 'logsSubscribe',
      unsubscribeMethod: 'logsUnsubscribe'
    }, args);
  }

  /**
   * Deregister a logs callback.
   *
   * @param id client subscription id to deregister.
   */
  async removeOnLogsListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, 'logs');
  }

  /**
   * @internal
   */
  _wsOnLogsNotification(notification) {
    const {
      result,
      subscription
    } = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(notification, LogsNotificationResult);
    this._handleServerNotification(subscription, [result.value, result.context]);
  }

  /**
   * @internal
   */
  _wsOnSlotNotification(notification) {
    const {
      result,
      subscription
    } = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(notification, SlotNotificationResult);
    this._handleServerNotification(subscription, [result]);
  }

  /**
   * Register a callback to be invoked upon slot changes
   *
   * @param callback Function to invoke whenever the slot changes
   * @return subscription id
   */
  onSlotChange(callback) {
    return this._makeSubscription({
      callback,
      method: 'slotSubscribe',
      unsubscribeMethod: 'slotUnsubscribe'
    }, [] /* args */);
  }

  /**
   * Deregister a slot notification callback
   *
   * @param id client subscription id to deregister
   */
  async removeSlotChangeListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, 'slot change');
  }

  /**
   * @internal
   */
  _wsOnSlotUpdatesNotification(notification) {
    const {
      result,
      subscription
    } = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(notification, SlotUpdateNotificationResult);
    this._handleServerNotification(subscription, [result]);
  }

  /**
   * Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s
   * may be useful to track live progress of a cluster.
   *
   * @param callback Function to invoke whenever the slot updates
   * @return subscription id
   */
  onSlotUpdate(callback) {
    return this._makeSubscription({
      callback,
      method: 'slotsUpdatesSubscribe',
      unsubscribeMethod: 'slotsUpdatesUnsubscribe'
    }, [] /* args */);
  }

  /**
   * Deregister a slot update notification callback
   *
   * @param id client subscription id to deregister
   */
  async removeSlotUpdateListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, 'slot update');
  }

  /**
   * @internal
   */

  async _unsubscribeClientSubscription(clientSubscriptionId, subscriptionName) {
    const dispose = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
    if (dispose) {
      await dispose();
    } else {
      console.warn('Ignored unsubscribe request because an active subscription with id ' + `\`${clientSubscriptionId}\` for '${subscriptionName}' events ` + 'could not be found.');
    }
  }
  _buildArgs(args, override, encoding, extra) {
    const commitment = override || this._commitment;
    if (commitment || encoding || extra) {
      let options = {};
      if (encoding) {
        options.encoding = encoding;
      }
      if (commitment) {
        options.commitment = commitment;
      }
      if (extra) {
        options = Object.assign(options, extra);
      }
      args.push(options);
    }
    return args;
  }

  /**
   * @internal
   */
  _buildArgsAtLeastConfirmed(args, override, encoding, extra) {
    const commitment = override || this._commitment;
    if (commitment && !['confirmed', 'finalized'].includes(commitment)) {
      throw new Error('Using Connection with default commitment: `' + this._commitment + '`, but method requires at least `confirmed`');
    }
    return this._buildArgs(args, override, encoding, extra);
  }

  /**
   * @internal
   */
  _wsOnSignatureNotification(notification) {
    const {
      result,
      subscription
    } = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(notification, SignatureNotificationResult);
    if (result.value !== 'receivedSignature') {
      /**
       * Special case.
       * After a signature is processed, RPCs automatically dispose of the
       * subscription on the server side. We need to track which of these
       * subscriptions have been disposed in such a way, so that we know
       * whether the client is dealing with a not-yet-processed signature
       * (in which case we must tear down the server subscription) or an
       * already-processed signature (in which case the client can simply
       * clear out the subscription locally without telling the server).
       *
       * NOTE: There is a proposal to eliminate this special case, here:
       * https://github.com/solana-labs/solana/issues/18892
       */
      this._subscriptionsAutoDisposedByRpc.add(subscription);
    }
    this._handleServerNotification(subscription, result.value === 'receivedSignature' ? [{
      type: 'received'
    }, result.context] : [{
      type: 'status',
      result: result.value
    }, result.context]);
  }

  /**
   * Register a callback to be invoked upon signature updates
   *
   * @param signature Transaction signature string in base 58
   * @param callback Function to invoke on signature notifications
   * @param commitment Specify the commitment level signature must reach before notification
   * @return subscription id
   */
  onSignature(signature, callback, commitment) {
    const args = this._buildArgs([signature], commitment || this._commitment || 'finalized' // Apply connection/server default.
    );

    const clientSubscriptionId = this._makeSubscription({
      callback: (notification, context) => {
        if (notification.type === 'status') {
          callback(notification.result, context);
          // Signatures subscriptions are auto-removed by the RPC service
          // so no need to explicitly send an unsubscribe message.
          try {
            this.removeSignatureListener(clientSubscriptionId);
            // eslint-disable-next-line no-empty
          } catch (_err) {
            // Already removed.
          }
        }
      },
      method: 'signatureSubscribe',
      unsubscribeMethod: 'signatureUnsubscribe'
    }, args);
    return clientSubscriptionId;
  }

  /**
   * Register a callback to be invoked when a transaction is
   * received and/or processed.
   *
   * @param signature Transaction signature string in base 58
   * @param callback Function to invoke on signature notifications
   * @param options Enable received notifications and set the commitment
   *   level that signature must reach before notification
   * @return subscription id
   */
  onSignatureWithOptions(signature, callback, options) {
    const {
      commitment,
      ...extra
    } = {
      ...options,
      commitment: options && options.commitment || this._commitment || 'finalized' // Apply connection/server default.
    };

    const args = this._buildArgs([signature], commitment, undefined /* encoding */, extra);
    const clientSubscriptionId = this._makeSubscription({
      callback: (notification, context) => {
        callback(notification, context);
        // Signatures subscriptions are auto-removed by the RPC service
        // so no need to explicitly send an unsubscribe message.
        try {
          this.removeSignatureListener(clientSubscriptionId);
          // eslint-disable-next-line no-empty
        } catch (_err) {
          // Already removed.
        }
      },
      method: 'signatureSubscribe',
      unsubscribeMethod: 'signatureUnsubscribe'
    }, args);
    return clientSubscriptionId;
  }

  /**
   * Deregister a signature notification callback
   *
   * @param id client subscription id to deregister
   */
  async removeSignatureListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, 'signature result');
  }

  /**
   * @internal
   */
  _wsOnRootNotification(notification) {
    const {
      result,
      subscription
    } = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .create */ .Ue)(notification, RootNotificationResult);
    this._handleServerNotification(subscription, [result]);
  }

  /**
   * Register a callback to be invoked upon root changes
   *
   * @param callback Function to invoke whenever the root changes
   * @return subscription id
   */
  onRootChange(callback) {
    return this._makeSubscription({
      callback,
      method: 'rootSubscribe',
      unsubscribeMethod: 'rootUnsubscribe'
    }, [] /* args */);
  }

  /**
   * Deregister a root notification callback
   *
   * @param id client subscription id to deregister
   */
  async removeRootChangeListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, 'root change');
  }
}

/**
 * Keypair signer interface
 */

/**
 * An account keypair used for signing transactions.
 */
class Keypair {
  /**
   * Create a new keypair instance.
   * Generate random keypair if no {@link Ed25519Keypair} is provided.
   *
   * @param keypair ed25519 keypair
   */
  constructor(keypair) {
    this._keypair = void 0;
    this._keypair = keypair ?? generateKeypair();
  }

  /**
   * Generate a new random keypair
   */
  static generate() {
    return new Keypair(generateKeypair());
  }

  /**
   * Create a keypair from a raw secret key byte array.
   *
   * This method should only be used to recreate a keypair from a previously
   * generated secret key. Generating keypairs from a random seed should be done
   * with the {@link Keypair.fromSeed} method.
   *
   * @throws error if the provided secret key is invalid and validation is not skipped.
   *
   * @param secretKey secret key byte array
   * @param options: skip secret key validation
   */
  static fromSecretKey(secretKey, options) {
    if (secretKey.byteLength !== 64) {
      throw new Error('bad secret key size');
    }
    const publicKey = secretKey.slice(32, 64);
    if (!options || !options.skipValidation) {
      const privateScalar = secretKey.slice(0, 32);
      const computedPublicKey = getPublicKey(privateScalar);
      for (let ii = 0; ii < 32; ii++) {
        if (publicKey[ii] !== computedPublicKey[ii]) {
          throw new Error('provided secretKey is invalid');
        }
      }
    }
    return new Keypair({
      publicKey,
      secretKey
    });
  }

  /**
   * Generate a keypair from a 32 byte seed.
   *
   * @param seed seed byte array
   */
  static fromSeed(seed) {
    const publicKey = getPublicKey(seed);
    const secretKey = new Uint8Array(64);
    secretKey.set(seed);
    secretKey.set(publicKey, 32);
    return new Keypair({
      publicKey,
      secretKey
    });
  }

  /**
   * The public key for this keypair
   */
  get publicKey() {
    return new PublicKey(this._keypair.publicKey);
  }

  /**
   * The raw secret key for this keypair
   */
  get secretKey() {
    return new Uint8Array(this._keypair.secretKey);
  }
}

/**
 * An enumeration of valid address lookup table InstructionType's
 * @internal
 */
const LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({
  CreateLookupTable: {
    index: 0,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction'), u64('recentSlot'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__.u8('bumpSeed')])
  },
  FreezeLookupTable: {
    index: 1,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction')])
  },
  ExtendLookupTable: {
    index: 2,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction'), u64(), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .seq */ .A9(publicKey(), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .offset */ .cv(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq(), -8), 'addresses')])
  },
  DeactivateLookupTable: {
    index: 3,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction')])
  },
  CloseLookupTable: {
    index: 4,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction')])
  }
});
class AddressLookupTableInstruction {
  /**
   * @internal
   */
  constructor() {}
  static decodeInstructionType(instruction) {
    this.checkProgramId(instruction.programId);
    const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction');
    const index = instructionTypeLayout.decode(instruction.data);
    let type;
    for (const [layoutType, layout] of Object.entries(LOOKUP_TABLE_INSTRUCTION_LAYOUTS)) {
      if (layout.index == index) {
        type = layoutType;
        break;
      }
    }
    if (!type) {
      throw new Error('Invalid Instruction. Should be a LookupTable Instruction');
    }
    return type;
  }
  static decodeCreateLookupTable(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeysLength(instruction.keys, 4);
    const {
      recentSlot
    } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, instruction.data);
    return {
      authority: instruction.keys[1].pubkey,
      payer: instruction.keys[2].pubkey,
      recentSlot: Number(recentSlot)
    };
  }
  static decodeExtendLookupTable(instruction) {
    this.checkProgramId(instruction.programId);
    if (instruction.keys.length < 2) {
      throw new Error(`invalid instruction; found ${instruction.keys.length} keys, expected at least 2`);
    }
    const {
      addresses
    } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable, instruction.data);
    return {
      lookupTable: instruction.keys[0].pubkey,
      authority: instruction.keys[1].pubkey,
      payer: instruction.keys.length > 2 ? instruction.keys[2].pubkey : undefined,
      addresses: addresses.map(buffer => new PublicKey(buffer))
    };
  }
  static decodeCloseLookupTable(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeysLength(instruction.keys, 3);
    return {
      lookupTable: instruction.keys[0].pubkey,
      authority: instruction.keys[1].pubkey,
      recipient: instruction.keys[2].pubkey
    };
  }
  static decodeFreezeLookupTable(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeysLength(instruction.keys, 2);
    return {
      lookupTable: instruction.keys[0].pubkey,
      authority: instruction.keys[1].pubkey
    };
  }
  static decodeDeactivateLookupTable(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeysLength(instruction.keys, 2);
    return {
      lookupTable: instruction.keys[0].pubkey,
      authority: instruction.keys[1].pubkey
    };
  }

  /**
   * @internal
   */
  static checkProgramId(programId) {
    if (!programId.equals(AddressLookupTableProgram.programId)) {
      throw new Error('invalid instruction; programId is not AddressLookupTable Program');
    }
  }
  /**
   * @internal
   */
  static checkKeysLength(keys, expectedLength) {
    if (keys.length < expectedLength) {
      throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
    }
  }
}
class AddressLookupTableProgram {
  /**
   * @internal
   */
  constructor() {}
  static createLookupTable(params) {
    const [lookupTableAddress, bumpSeed] = PublicKey.findProgramAddressSync([params.authority.toBuffer(), (0,bigint_buffer__WEBPACK_IMPORTED_MODULE_8__/* .toBufferLE */ .k$)(BigInt(params.recentSlot), 8)], this.programId);
    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;
    const data = encodeData(type, {
      recentSlot: BigInt(params.recentSlot),
      bumpSeed: bumpSeed
    });
    const keys = [{
      pubkey: lookupTableAddress,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: params.payer,
      isSigner: true,
      isWritable: true
    }, {
      pubkey: SystemProgram.programId,
      isSigner: false,
      isWritable: false
    }];
    return [new TransactionInstruction({
      programId: this.programId,
      keys: keys,
      data: data
    }), lookupTableAddress];
  }
  static freezeLookupTable(params) {
    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;
    const data = encodeData(type);
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    return new TransactionInstruction({
      programId: this.programId,
      keys: keys,
      data: data
    });
  }
  static extendLookupTable(params) {
    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;
    const data = encodeData(type, {
      addresses: params.addresses.map(addr => addr.toBytes())
    });
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    if (params.payer) {
      keys.push({
        pubkey: params.payer,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: SystemProgram.programId,
        isSigner: false,
        isWritable: false
      });
    }
    return new TransactionInstruction({
      programId: this.programId,
      keys: keys,
      data: data
    });
  }
  static deactivateLookupTable(params) {
    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;
    const data = encodeData(type);
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    return new TransactionInstruction({
      programId: this.programId,
      keys: keys,
      data: data
    });
  }
  static closeLookupTable(params) {
    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;
    const data = encodeData(type);
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: params.recipient,
      isSigner: false,
      isWritable: true
    }];
    return new TransactionInstruction({
      programId: this.programId,
      keys: keys,
      data: data
    });
  }
}
AddressLookupTableProgram.programId = new PublicKey('AddressLookupTab1e1111111111111111111111111');

/**
 * Compute Budget Instruction class
 */
class ComputeBudgetInstruction {
  /**
   * @internal
   */
  constructor() {}

  /**
   * Decode a compute budget instruction and retrieve the instruction type.
   */
  static decodeInstructionType(instruction) {
    this.checkProgramId(instruction.programId);
    const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__.u8('instruction');
    const typeIndex = instructionTypeLayout.decode(instruction.data);
    let type;
    for (const [ixType, layout] of Object.entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS)) {
      if (layout.index == typeIndex) {
        type = ixType;
        break;
      }
    }
    if (!type) {
      throw new Error('Instruction type incorrect; not a ComputeBudgetInstruction');
    }
    return type;
  }

  /**
   * Decode request units compute budget instruction and retrieve the instruction params.
   */
  static decodeRequestUnits(instruction) {
    this.checkProgramId(instruction.programId);
    const {
      units,
      additionalFee
    } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, instruction.data);
    return {
      units,
      additionalFee
    };
  }

  /**
   * Decode request heap frame compute budget instruction and retrieve the instruction params.
   */
  static decodeRequestHeapFrame(instruction) {
    this.checkProgramId(instruction.programId);
    const {
      bytes
    } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, instruction.data);
    return {
      bytes
    };
  }

  /**
   * Decode set compute unit limit compute budget instruction and retrieve the instruction params.
   */
  static decodeSetComputeUnitLimit(instruction) {
    this.checkProgramId(instruction.programId);
    const {
      units
    } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, instruction.data);
    return {
      units
    };
  }

  /**
   * Decode set compute unit price compute budget instruction and retrieve the instruction params.
   */
  static decodeSetComputeUnitPrice(instruction) {
    this.checkProgramId(instruction.programId);
    const {
      microLamports
    } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, instruction.data);
    return {
      microLamports
    };
  }

  /**
   * @internal
   */
  static checkProgramId(programId) {
    if (!programId.equals(ComputeBudgetProgram.programId)) {
      throw new Error('invalid instruction; programId is not ComputeBudgetProgram');
    }
  }
}

/**
 * An enumeration of valid ComputeBudgetInstructionType's
 */

/**
 * An enumeration of valid ComputeBudget InstructionType's
 * @internal
 */
const COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({
  RequestUnits: {
    index: 0,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__.u8('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('units'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('additionalFee')])
  },
  RequestHeapFrame: {
    index: 1,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__.u8('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('bytes')])
  },
  SetComputeUnitLimit: {
    index: 2,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__.u8('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('units')])
  },
  SetComputeUnitPrice: {
    index: 3,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__.u8('instruction'), u64('microLamports')])
  }
});

/**
 * Factory class for transaction instructions to interact with the Compute Budget program
 */
class ComputeBudgetProgram {
  /**
   * @internal
   */
  constructor() {}

  /**
   * Public key that identifies the Compute Budget program
   */

  /**
   * @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}
   */
  static requestUnits(params) {
    const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;
    const data = encodeData(type, params);
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static requestHeapFrame(params) {
    const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;
    const data = encodeData(type, params);
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static setComputeUnitLimit(params) {
    const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;
    const data = encodeData(type, params);
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static setComputeUnitPrice(params) {
    const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;
    const data = encodeData(type, {
      microLamports: BigInt(params.microLamports)
    });
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data
    });
  }
}
ComputeBudgetProgram.programId = new PublicKey('ComputeBudget111111111111111111111111111111');

const PRIVATE_KEY_BYTES$1 = 64;
const PUBLIC_KEY_BYTES$1 = 32;
const SIGNATURE_BYTES = 64;

/**
 * Params for creating an ed25519 instruction using a public key
 */

const ED25519_INSTRUCTION_LAYOUT = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__.u8('numSignatures'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__.u8('padding'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u16 */ .KB('signatureOffset'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u16 */ .KB('signatureInstructionIndex'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u16 */ .KB('publicKeyOffset'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u16 */ .KB('publicKeyInstructionIndex'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u16 */ .KB('messageDataOffset'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u16 */ .KB('messageDataSize'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u16 */ .KB('messageInstructionIndex')]);
class Ed25519Program {
  /**
   * @internal
   */
  constructor() {}

  /**
   * Public key that identifies the ed25519 program
   */

  /**
   * Create an ed25519 instruction with a public key and signature. The
   * public key must be a buffer that is 32 bytes long, and the signature
   * must be a buffer of 64 bytes.
   */
  static createInstructionWithPublicKey(params) {
    const {
      publicKey,
      message,
      signature,
      instructionIndex
    } = params;
    assert(publicKey.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${publicKey.length} bytes`);
    assert(signature.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${signature.length} bytes`);
    const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;
    const signatureOffset = publicKeyOffset + publicKey.length;
    const messageDataOffset = signatureOffset + signature.length;
    const numSignatures = 1;
    const instructionData = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(messageDataOffset + message.length);
    const index = instructionIndex == null ? 0xffff // An index of `u16::MAX` makes it default to the current instruction.
    : instructionIndex;
    ED25519_INSTRUCTION_LAYOUT.encode({
      numSignatures,
      padding: 0,
      signatureOffset,
      signatureInstructionIndex: index,
      publicKeyOffset,
      publicKeyInstructionIndex: index,
      messageDataOffset,
      messageDataSize: message.length,
      messageInstructionIndex: index
    }, instructionData);
    instructionData.fill(publicKey, publicKeyOffset);
    instructionData.fill(signature, signatureOffset);
    instructionData.fill(message, messageDataOffset);
    return new TransactionInstruction({
      keys: [],
      programId: Ed25519Program.programId,
      data: instructionData
    });
  }

  /**
   * Create an ed25519 instruction with a private key. The private key
   * must be a buffer that is 64 bytes long.
   */
  static createInstructionWithPrivateKey(params) {
    const {
      privateKey,
      message,
      instructionIndex
    } = params;
    assert(privateKey.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${privateKey.length} bytes`);
    try {
      const keypair = Keypair.fromSecretKey(privateKey);
      const publicKey = keypair.publicKey.toBytes();
      const signature = sign(message, keypair.secretKey);
      return this.createInstructionWithPublicKey({
        publicKey,
        message,
        signature,
        instructionIndex
      });
    } catch (error) {
      throw new Error(`Error creating instruction; ${error}`);
    }
  }
}
Ed25519Program.programId = new PublicKey('Ed25519SigVerify111111111111111111111111111');

// Supply a synchronous hashing algorithm to make this
// library interoperable with the synchronous APIs in web3.js.
_noble_secp256k1__WEBPACK_IMPORTED_MODULE_14__/* .utils */ .P6.hmacSha256Sync = (key, ...msgs) => {
  const h = _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_13__/* .hmac */ .b.create(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_5__/* .sha256 */ .J, key);
  msgs.forEach(msg => h.update(msg));
  return h.digest();
};
const ecdsaSign = (msgHash, privKey) => _noble_secp256k1__WEBPACK_IMPORTED_MODULE_14__/* .signSync */ .kS(msgHash, privKey, {
  der: false,
  recovered: true
});
_noble_secp256k1__WEBPACK_IMPORTED_MODULE_14__/* .utils */ .P6.isValidPrivateKey;
const publicKeyCreate = _noble_secp256k1__WEBPACK_IMPORTED_MODULE_14__/* .getPublicKey */ .$3;

const PRIVATE_KEY_BYTES = 32;
const ETHEREUM_ADDRESS_BYTES = 20;
const PUBLIC_KEY_BYTES = 64;
const SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;

/**
 * Params for creating an secp256k1 instruction using a public key
 */

const SECP256K1_INSTRUCTION_LAYOUT = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__.u8('numSignatures'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u16 */ .KB('signatureOffset'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__.u8('signatureInstructionIndex'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u16 */ .KB('ethAddressOffset'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__.u8('ethAddressInstructionIndex'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u16 */ .KB('messageDataOffset'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u16 */ .KB('messageDataSize'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__.u8('messageInstructionIndex'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .blob */ .Ik(20, 'ethAddress'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .blob */ .Ik(64, 'signature'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__.u8('recoveryId')]);
class Secp256k1Program {
  /**
   * @internal
   */
  constructor() {}

  /**
   * Public key that identifies the secp256k1 program
   */

  /**
   * Construct an Ethereum address from a secp256k1 public key buffer.
   * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer
   */
  static publicKeyToEthAddress(publicKey) {
    assert(publicKey.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${publicKey.length} bytes`);
    try {
      return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_12__/* .keccak_256 */ .fr)(toBuffer(publicKey))).slice(-ETHEREUM_ADDRESS_BYTES);
    } catch (error) {
      throw new Error(`Error constructing Ethereum address: ${error}`);
    }
  }

  /**
   * Create an secp256k1 instruction with a public key. The public key
   * must be a buffer that is 64 bytes long.
   */
  static createInstructionWithPublicKey(params) {
    const {
      publicKey,
      message,
      signature,
      recoveryId,
      instructionIndex
    } = params;
    return Secp256k1Program.createInstructionWithEthAddress({
      ethAddress: Secp256k1Program.publicKeyToEthAddress(publicKey),
      message,
      signature,
      recoveryId,
      instructionIndex
    });
  }

  /**
   * Create an secp256k1 instruction with an Ethereum address. The address
   * must be a hex string or a buffer that is 20 bytes long.
   */
  static createInstructionWithEthAddress(params) {
    const {
      ethAddress: rawAddress,
      message,
      signature,
      recoveryId,
      instructionIndex = 0
    } = params;
    let ethAddress;
    if (typeof rawAddress === 'string') {
      if (rawAddress.startsWith('0x')) {
        ethAddress = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(rawAddress.substr(2), 'hex');
      } else {
        ethAddress = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(rawAddress, 'hex');
      }
    } else {
      ethAddress = rawAddress;
    }
    assert(ethAddress.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress.length} bytes`);
    const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;
    const ethAddressOffset = dataStart;
    const signatureOffset = dataStart + ethAddress.length;
    const messageDataOffset = signatureOffset + signature.length + 1;
    const numSignatures = 1;
    const instructionData = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);
    SECP256K1_INSTRUCTION_LAYOUT.encode({
      numSignatures,
      signatureOffset,
      signatureInstructionIndex: instructionIndex,
      ethAddressOffset,
      ethAddressInstructionIndex: instructionIndex,
      messageDataOffset,
      messageDataSize: message.length,
      messageInstructionIndex: instructionIndex,
      signature: toBuffer(signature),
      ethAddress: toBuffer(ethAddress),
      recoveryId
    }, instructionData);
    instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);
    return new TransactionInstruction({
      keys: [],
      programId: Secp256k1Program.programId,
      data: instructionData
    });
  }

  /**
   * Create an secp256k1 instruction with a private key. The private key
   * must be a buffer that is 32 bytes long.
   */
  static createInstructionWithPrivateKey(params) {
    const {
      privateKey: pkey,
      message,
      instructionIndex
    } = params;
    assert(pkey.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${pkey.length} bytes`);
    try {
      const privateKey = toBuffer(pkey);
      const publicKey = publicKeyCreate(privateKey, false /* isCompressed */).slice(1); // throw away leading byte
      const messageHash = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_12__/* .keccak_256 */ .fr)(toBuffer(message)));
      const [signature, recoveryId] = ecdsaSign(messageHash, privateKey);
      return this.createInstructionWithPublicKey({
        publicKey,
        message,
        signature,
        recoveryId,
        instructionIndex
      });
    } catch (error) {
      throw new Error(`Error creating instruction; ${error}`);
    }
  }
}
Secp256k1Program.programId = new PublicKey('KeccakSecp256k11111111111111111111111111111');

/**
 * Address of the stake config account which configures the rate
 * of stake warmup and cooldown as well as the slashing penalty.
 */
const STAKE_CONFIG_ID = new PublicKey('StakeConfig11111111111111111111111111111111');

/**
 * Stake account authority info
 */
class Authorized {
  /** stake authority */

  /** withdraw authority */

  /**
   * Create a new Authorized object
   * @param staker the stake authority
   * @param withdrawer the withdraw authority
   */
  constructor(staker, withdrawer) {
    this.staker = void 0;
    this.withdrawer = void 0;
    this.staker = staker;
    this.withdrawer = withdrawer;
  }
}
/**
 * Stake account lockup info
 */
class Lockup {
  /** Unix timestamp of lockup expiration */

  /** Epoch of lockup expiration */

  /** Lockup custodian authority */

  /**
   * Create a new Lockup object
   */
  constructor(unixTimestamp, epoch, custodian) {
    this.unixTimestamp = void 0;
    this.epoch = void 0;
    this.custodian = void 0;
    this.unixTimestamp = unixTimestamp;
    this.epoch = epoch;
    this.custodian = custodian;
  }

  /**
   * Default, inactive Lockup value
   */
}
Lockup.default = new Lockup(0, 0, PublicKey.default);
/**
 * Stake Instruction class
 */
class StakeInstruction {
  /**
   * @internal
   */
  constructor() {}

  /**
   * Decode a stake instruction and retrieve the instruction type.
   */
  static decodeInstructionType(instruction) {
    this.checkProgramId(instruction.programId);
    const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction');
    const typeIndex = instructionTypeLayout.decode(instruction.data);
    let type;
    for (const [ixType, layout] of Object.entries(STAKE_INSTRUCTION_LAYOUTS)) {
      if (layout.index == typeIndex) {
        type = ixType;
        break;
      }
    }
    if (!type) {
      throw new Error('Instruction type incorrect; not a StakeInstruction');
    }
    return type;
  }

  /**
   * Decode a initialize stake instruction and retrieve the instruction params.
   */
  static decodeInitialize(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 2);
    const {
      authorized,
      lockup
    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Initialize, instruction.data);
    return {
      stakePubkey: instruction.keys[0].pubkey,
      authorized: new Authorized(new PublicKey(authorized.staker), new PublicKey(authorized.withdrawer)),
      lockup: new Lockup(lockup.unixTimestamp, lockup.epoch, new PublicKey(lockup.custodian))
    };
  }

  /**
   * Decode a delegate stake instruction and retrieve the instruction params.
   */
  static decodeDelegate(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 6);
    decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Delegate, instruction.data);
    return {
      stakePubkey: instruction.keys[0].pubkey,
      votePubkey: instruction.keys[1].pubkey,
      authorizedPubkey: instruction.keys[5].pubkey
    };
  }

  /**
   * Decode an authorize stake instruction and retrieve the instruction params.
   */
  static decodeAuthorize(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    const {
      newAuthorized,
      stakeAuthorizationType
    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);
    const o = {
      stakePubkey: instruction.keys[0].pubkey,
      authorizedPubkey: instruction.keys[2].pubkey,
      newAuthorizedPubkey: new PublicKey(newAuthorized),
      stakeAuthorizationType: {
        index: stakeAuthorizationType
      }
    };
    if (instruction.keys.length > 3) {
      o.custodianPubkey = instruction.keys[3].pubkey;
    }
    return o;
  }

  /**
   * Decode an authorize-with-seed stake instruction and retrieve the instruction params.
   */
  static decodeAuthorizeWithSeed(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 2);
    const {
      newAuthorized,
      stakeAuthorizationType,
      authoritySeed,
      authorityOwner
    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);
    const o = {
      stakePubkey: instruction.keys[0].pubkey,
      authorityBase: instruction.keys[1].pubkey,
      authoritySeed: authoritySeed,
      authorityOwner: new PublicKey(authorityOwner),
      newAuthorizedPubkey: new PublicKey(newAuthorized),
      stakeAuthorizationType: {
        index: stakeAuthorizationType
      }
    };
    if (instruction.keys.length > 3) {
      o.custodianPubkey = instruction.keys[3].pubkey;
    }
    return o;
  }

  /**
   * Decode a split stake instruction and retrieve the instruction params.
   */
  static decodeSplit(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    const {
      lamports
    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Split, instruction.data);
    return {
      stakePubkey: instruction.keys[0].pubkey,
      splitStakePubkey: instruction.keys[1].pubkey,
      authorizedPubkey: instruction.keys[2].pubkey,
      lamports
    };
  }

  /**
   * Decode a merge stake instruction and retrieve the instruction params.
   */
  static decodeMerge(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Merge, instruction.data);
    return {
      stakePubkey: instruction.keys[0].pubkey,
      sourceStakePubKey: instruction.keys[1].pubkey,
      authorizedPubkey: instruction.keys[4].pubkey
    };
  }

  /**
   * Decode a withdraw stake instruction and retrieve the instruction params.
   */
  static decodeWithdraw(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 5);
    const {
      lamports
    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);
    const o = {
      stakePubkey: instruction.keys[0].pubkey,
      toPubkey: instruction.keys[1].pubkey,
      authorizedPubkey: instruction.keys[4].pubkey,
      lamports
    };
    if (instruction.keys.length > 5) {
      o.custodianPubkey = instruction.keys[5].pubkey;
    }
    return o;
  }

  /**
   * Decode a deactivate stake instruction and retrieve the instruction params.
   */
  static decodeDeactivate(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Deactivate, instruction.data);
    return {
      stakePubkey: instruction.keys[0].pubkey,
      authorizedPubkey: instruction.keys[2].pubkey
    };
  }

  /**
   * @internal
   */
  static checkProgramId(programId) {
    if (!programId.equals(StakeProgram.programId)) {
      throw new Error('invalid instruction; programId is not StakeProgram');
    }
  }

  /**
   * @internal
   */
  static checkKeyLength(keys, expectedLength) {
    if (keys.length < expectedLength) {
      throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
    }
  }
}

/**
 * An enumeration of valid StakeInstructionType's
 */

/**
 * An enumeration of valid stake InstructionType's
 * @internal
 */
const STAKE_INSTRUCTION_LAYOUTS = Object.freeze({
  Initialize: {
    index: 0,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction'), authorized(), lockup()])
  },
  Authorize: {
    index: 1,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction'), publicKey('newAuthorized'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('stakeAuthorizationType')])
  },
  Delegate: {
    index: 2,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction')])
  },
  Split: {
    index: 3,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .ns64 */ .gM('lamports')])
  },
  Withdraw: {
    index: 4,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .ns64 */ .gM('lamports')])
  },
  Deactivate: {
    index: 5,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction')])
  },
  Merge: {
    index: 7,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction')])
  },
  AuthorizeWithSeed: {
    index: 8,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction'), publicKey('newAuthorized'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('stakeAuthorizationType'), rustString('authoritySeed'), publicKey('authorityOwner')])
  }
});

/**
 * Stake authorization type
 */

/**
 * An enumeration of valid StakeAuthorizationLayout's
 */
const StakeAuthorizationLayout = Object.freeze({
  Staker: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});

/**
 * Factory class for transactions to interact with the Stake program
 */
class StakeProgram {
  /**
   * @internal
   */
  constructor() {}

  /**
   * Public key that identifies the Stake program
   */

  /**
   * Generate an Initialize instruction to add to a Stake Create transaction
   */
  static initialize(params) {
    const {
      stakePubkey,
      authorized,
      lockup: maybeLockup
    } = params;
    const lockup = maybeLockup || Lockup.default;
    const type = STAKE_INSTRUCTION_LAYOUTS.Initialize;
    const data = encodeData(type, {
      authorized: {
        staker: toBuffer(authorized.staker.toBuffer()),
        withdrawer: toBuffer(authorized.withdrawer.toBuffer())
      },
      lockup: {
        unixTimestamp: lockup.unixTimestamp,
        epoch: lockup.epoch,
        custodian: toBuffer(lockup.custodian.toBuffer())
      }
    });
    const instructionData = {
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }

  /**
   * Generate a Transaction that creates a new Stake account at
   *   an address generated with `from`, a seed, and the Stake programId
   */
  static createAccountWithSeed(params) {
    const transaction = new Transaction();
    transaction.add(SystemProgram.createAccountWithSeed({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.stakePubkey,
      basePubkey: params.basePubkey,
      seed: params.seed,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey,
      authorized,
      lockup
    } = params;
    return transaction.add(this.initialize({
      stakePubkey,
      authorized,
      lockup
    }));
  }

  /**
   * Generate a Transaction that creates a new Stake account
   */
  static createAccount(params) {
    const transaction = new Transaction();
    transaction.add(SystemProgram.createAccount({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.stakePubkey,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey,
      authorized,
      lockup
    } = params;
    return transaction.add(this.initialize({
      stakePubkey,
      authorized,
      lockup
    }));
  }

  /**
   * Generate a Transaction that delegates Stake tokens to a validator
   * Vote PublicKey. This transaction can also be used to redelegate Stake
   * to a new validator Vote PublicKey.
   */
  static delegate(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      votePubkey
    } = params;
    const type = STAKE_INSTRUCTION_LAYOUTS.Delegate;
    const data = encodeData(type);
    return new Transaction().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: votePubkey,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: STAKE_CONFIG_ID,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }

  /**
   * Generate a Transaction that authorizes a new PublicKey as Staker
   * or Withdrawer on the Stake account.
   */
  static authorize(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      newAuthorizedPubkey,
      stakeAuthorizationType,
      custodianPubkey
    } = params;
    const type = STAKE_INSTRUCTION_LAYOUTS.Authorize;
    const data = encodeData(type, {
      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
      stakeAuthorizationType: stakeAuthorizationType.index
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: false,
        isWritable: false
      });
    }
    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }

  /**
   * Generate a Transaction that authorizes a new PublicKey as Staker
   * or Withdrawer on the Stake account.
   */
  static authorizeWithSeed(params) {
    const {
      stakePubkey,
      authorityBase,
      authoritySeed,
      authorityOwner,
      newAuthorizedPubkey,
      stakeAuthorizationType,
      custodianPubkey
    } = params;
    const type = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
    const data = encodeData(type, {
      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
      stakeAuthorizationType: stakeAuthorizationType.index,
      authoritySeed: authoritySeed,
      authorityOwner: toBuffer(authorityOwner.toBuffer())
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorityBase,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: false,
        isWritable: false
      });
    }
    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }

  /**
   * @internal
   */
  static splitInstruction(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      lamports
    } = params;
    const type = STAKE_INSTRUCTION_LAYOUTS.Split;
    const data = encodeData(type, {
      lamports
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: splitStakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }

  /**
   * Generate a Transaction that splits Stake tokens into another stake account
   */
  static split(params) {
    const transaction = new Transaction();
    transaction.add(SystemProgram.createAccount({
      fromPubkey: params.authorizedPubkey,
      newAccountPubkey: params.splitStakePubkey,
      lamports: 0,
      space: this.space,
      programId: this.programId
    }));
    return transaction.add(this.splitInstruction(params));
  }

  /**
   * Generate a Transaction that splits Stake tokens into another account
   * derived from a base public key and seed
   */
  static splitWithSeed(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      basePubkey,
      seed,
      lamports
    } = params;
    const transaction = new Transaction();
    transaction.add(SystemProgram.allocate({
      accountPubkey: splitStakePubkey,
      basePubkey,
      seed,
      space: this.space,
      programId: this.programId
    }));
    return transaction.add(this.splitInstruction({
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      lamports
    }));
  }

  /**
   * Generate a Transaction that merges Stake accounts.
   */
  static merge(params) {
    const {
      stakePubkey,
      sourceStakePubKey,
      authorizedPubkey
    } = params;
    const type = STAKE_INSTRUCTION_LAYOUTS.Merge;
    const data = encodeData(type);
    return new Transaction().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: sourceStakePubKey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }

  /**
   * Generate a Transaction that withdraws deactivated Stake tokens.
   */
  static withdraw(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      toPubkey,
      lamports,
      custodianPubkey
    } = params;
    const type = STAKE_INSTRUCTION_LAYOUTS.Withdraw;
    const data = encodeData(type, {
      lamports
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: toPubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: false,
        isWritable: false
      });
    }
    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }

  /**
   * Generate a Transaction that deactivates Stake tokens.
   */
  static deactivate(params) {
    const {
      stakePubkey,
      authorizedPubkey
    } = params;
    const type = STAKE_INSTRUCTION_LAYOUTS.Deactivate;
    const data = encodeData(type);
    return new Transaction().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
}
StakeProgram.programId = new PublicKey('Stake11111111111111111111111111111111111111');
StakeProgram.space = 200;

/**
 * Vote account info
 */
class VoteInit {
  /** [0, 100] */

  constructor(nodePubkey, authorizedVoter, authorizedWithdrawer, commission) {
    this.nodePubkey = void 0;
    this.authorizedVoter = void 0;
    this.authorizedWithdrawer = void 0;
    this.commission = void 0;
    this.nodePubkey = nodePubkey;
    this.authorizedVoter = authorizedVoter;
    this.authorizedWithdrawer = authorizedWithdrawer;
    this.commission = commission;
  }
}

/**
 * Create vote account transaction params
 */

/**
 * Vote Instruction class
 */
class VoteInstruction {
  /**
   * @internal
   */
  constructor() {}

  /**
   * Decode a vote instruction and retrieve the instruction type.
   */
  static decodeInstructionType(instruction) {
    this.checkProgramId(instruction.programId);
    const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction');
    const typeIndex = instructionTypeLayout.decode(instruction.data);
    let type;
    for (const [ixType, layout] of Object.entries(VOTE_INSTRUCTION_LAYOUTS)) {
      if (layout.index == typeIndex) {
        type = ixType;
        break;
      }
    }
    if (!type) {
      throw new Error('Instruction type incorrect; not a VoteInstruction');
    }
    return type;
  }

  /**
   * Decode an initialize vote instruction and retrieve the instruction params.
   */
  static decodeInitializeAccount(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 4);
    const {
      voteInit
    } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, instruction.data);
    return {
      votePubkey: instruction.keys[0].pubkey,
      nodePubkey: instruction.keys[3].pubkey,
      voteInit: new VoteInit(new PublicKey(voteInit.nodePubkey), new PublicKey(voteInit.authorizedVoter), new PublicKey(voteInit.authorizedWithdrawer), voteInit.commission)
    };
  }

  /**
   * Decode an authorize instruction and retrieve the instruction params.
   */
  static decodeAuthorize(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    const {
      newAuthorized,
      voteAuthorizationType
    } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);
    return {
      votePubkey: instruction.keys[0].pubkey,
      authorizedPubkey: instruction.keys[2].pubkey,
      newAuthorizedPubkey: new PublicKey(newAuthorized),
      voteAuthorizationType: {
        index: voteAuthorizationType
      }
    };
  }

  /**
   * Decode an authorize instruction and retrieve the instruction params.
   */
  static decodeAuthorizeWithSeed(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    const {
      voteAuthorizeWithSeedArgs: {
        currentAuthorityDerivedKeyOwnerPubkey,
        currentAuthorityDerivedKeySeed,
        newAuthorized,
        voteAuthorizationType
      }
    } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);
    return {
      currentAuthorityDerivedKeyBasePubkey: instruction.keys[2].pubkey,
      currentAuthorityDerivedKeyOwnerPubkey: new PublicKey(currentAuthorityDerivedKeyOwnerPubkey),
      currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,
      newAuthorizedPubkey: new PublicKey(newAuthorized),
      voteAuthorizationType: {
        index: voteAuthorizationType
      },
      votePubkey: instruction.keys[0].pubkey
    };
  }

  /**
   * Decode a withdraw instruction and retrieve the instruction params.
   */
  static decodeWithdraw(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    const {
      lamports
    } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);
    return {
      votePubkey: instruction.keys[0].pubkey,
      authorizedWithdrawerPubkey: instruction.keys[2].pubkey,
      lamports,
      toPubkey: instruction.keys[1].pubkey
    };
  }

  /**
   * @internal
   */
  static checkProgramId(programId) {
    if (!programId.equals(VoteProgram.programId)) {
      throw new Error('invalid instruction; programId is not VoteProgram');
    }
  }

  /**
   * @internal
   */
  static checkKeyLength(keys, expectedLength) {
    if (keys.length < expectedLength) {
      throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
    }
  }
}

/**
 * An enumeration of valid VoteInstructionType's
 */

const VOTE_INSTRUCTION_LAYOUTS = Object.freeze({
  InitializeAccount: {
    index: 0,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction'), voteInit()])
  },
  Authorize: {
    index: 1,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction'), publicKey('newAuthorized'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('voteAuthorizationType')])
  },
  Withdraw: {
    index: 3,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .ns64 */ .gM('lamports')])
  },
  AuthorizeWithSeed: {
    index: 10,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('instruction'), voteAuthorizeWithSeedArgs()])
  }
});

/**
 * VoteAuthorize type
 */

/**
 * An enumeration of valid VoteAuthorization layouts.
 */
const VoteAuthorizationLayout = Object.freeze({
  Voter: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});

/**
 * Factory class for transactions to interact with the Vote program
 */
class VoteProgram {
  /**
   * @internal
   */
  constructor() {}

  /**
   * Public key that identifies the Vote program
   */

  /**
   * Generate an Initialize instruction.
   */
  static initializeAccount(params) {
    const {
      votePubkey,
      nodePubkey,
      voteInit
    } = params;
    const type = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;
    const data = encodeData(type, {
      voteInit: {
        nodePubkey: toBuffer(voteInit.nodePubkey.toBuffer()),
        authorizedVoter: toBuffer(voteInit.authorizedVoter.toBuffer()),
        authorizedWithdrawer: toBuffer(voteInit.authorizedWithdrawer.toBuffer()),
        commission: voteInit.commission
      }
    });
    const instructionData = {
      keys: [{
        pubkey: votePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: nodePubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }

  /**
   * Generate a transaction that creates a new Vote account.
   */
  static createAccount(params) {
    const transaction = new Transaction();
    transaction.add(SystemProgram.createAccount({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.votePubkey,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    return transaction.add(this.initializeAccount({
      votePubkey: params.votePubkey,
      nodePubkey: params.voteInit.nodePubkey,
      voteInit: params.voteInit
    }));
  }

  /**
   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.
   */
  static authorize(params) {
    const {
      votePubkey,
      authorizedPubkey,
      newAuthorizedPubkey,
      voteAuthorizationType
    } = params;
    const type = VOTE_INSTRUCTION_LAYOUTS.Authorize;
    const data = encodeData(type, {
      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
      voteAuthorizationType: voteAuthorizationType.index
    });
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }

  /**
   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account
   * where the current Voter or Withdrawer authority is a derived key.
   */
  static authorizeWithSeed(params) {
    const {
      currentAuthorityDerivedKeyBasePubkey,
      currentAuthorityDerivedKeyOwnerPubkey,
      currentAuthorityDerivedKeySeed,
      newAuthorizedPubkey,
      voteAuthorizationType,
      votePubkey
    } = params;
    const type = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
    const data = encodeData(type, {
      voteAuthorizeWithSeedArgs: {
        currentAuthorityDerivedKeyOwnerPubkey: toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),
        currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,
        newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
        voteAuthorizationType: voteAuthorizationType.index
      }
    });
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: currentAuthorityDerivedKeyBasePubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }

  /**
   * Generate a transaction to withdraw from a Vote account.
   */
  static withdraw(params) {
    const {
      votePubkey,
      authorizedWithdrawerPubkey,
      lamports,
      toPubkey
    } = params;
    const type = VOTE_INSTRUCTION_LAYOUTS.Withdraw;
    const data = encodeData(type, {
      lamports
    });
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: toPubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorizedWithdrawerPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }

  /**
   * Generate a transaction to withdraw safely from a Vote account.
   *
   * This function was created as a safeguard for vote accounts running validators, `safeWithdraw`
   * checks that the withdraw amount will not exceed the specified balance while leaving enough left
   * to cover rent. If you wish to close the vote account by withdrawing the full amount, call the
   * `withdraw` method directly.
   */
  static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {
    if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {
      throw new Error('Withdraw will leave vote account with insuffcient funds.');
    }
    return VoteProgram.withdraw(params);
  }
}
VoteProgram.programId = new PublicKey('Vote111111111111111111111111111111111111111');
VoteProgram.space = 3731;

const VALIDATOR_INFO_KEY = new PublicKey('Va1idator1nfo111111111111111111111111111111');

/**
 * @internal
 */

const InfoString = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .type */ .dt)({
  name: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)(),
  website: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)()),
  details: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)()),
  keybaseUsername: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .string */ .Z_)())
});

/**
 * ValidatorInfo class
 */
class ValidatorInfo {
  /**
   * validator public key
   */

  /**
   * validator information
   */

  /**
   * Construct a valid ValidatorInfo
   *
   * @param key validator public key
   * @param info validator information
   */
  constructor(key, info) {
    this.key = void 0;
    this.info = void 0;
    this.key = key;
    this.info = info;
  }

  /**
   * Deserialize ValidatorInfo from the config account data. Exactly two config
   * keys are required in the data.
   *
   * @param buffer config account data
   * @return null if info was not found
   */
  static fromConfigData(buffer) {
    let byteArray = [...buffer];
    const configKeyCount = decodeLength(byteArray);
    if (configKeyCount !== 2) return null;
    const configKeys = [];
    for (let i = 0; i < 2; i++) {
      const publicKey = new PublicKey(byteArray.slice(0, PUBLIC_KEY_LENGTH));
      byteArray = byteArray.slice(PUBLIC_KEY_LENGTH);
      const isSigner = byteArray.slice(0, 1)[0] === 1;
      byteArray = byteArray.slice(1);
      configKeys.push({
        publicKey,
        isSigner
      });
    }
    if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY)) {
      if (configKeys[1].isSigner) {
        const rawInfo = rustString().decode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(byteArray));
        const info = JSON.parse(rawInfo);
        (0,superstruct__WEBPACK_IMPORTED_MODULE_15__/* .assert */ .hu)(info, InfoString);
        return new ValidatorInfo(configKeys[1].publicKey, info);
      }
    }
    return null;
  }
}

const VOTE_PROGRAM_ID = new PublicKey('Vote111111111111111111111111111111111111111');
/**
 * See https://github.com/solana-labs/solana/blob/8a12ed029cfa38d4a45400916c2463fb82bbec8c/programs/vote_api/src/vote_state.rs#L68-L88
 *
 * @internal
 */
const VoteAccountLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([publicKey('nodePubkey'), publicKey('authorizedWithdrawer'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__.u8('commission'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .nu64 */ ._O(),
// votes.length
_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .seq */ .A9(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .nu64 */ ._O('slot'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq('confirmationCount')]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .offset */ .cv(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq(), -8), 'votes'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__.u8('rootSlotValid'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .nu64 */ ._O('rootSlot'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .nu64 */ ._O(),
// authorizedVoters.length
_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .seq */ .A9(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .nu64 */ ._O('epoch'), publicKey('authorizedVoter')]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .offset */ .cv(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq(), -8), 'authorizedVoters'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .seq */ .A9(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([publicKey('authorizedPubkey'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .nu64 */ ._O('epochOfLastAuthorizedSwitch'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .nu64 */ ._O('targetEpoch')]), 32, 'buf'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .nu64 */ ._O('idx'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__.u8('isEmpty')], 'priorVoters'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .nu64 */ ._O(),
// epochCredits.length
_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .seq */ .A9(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .nu64 */ ._O('epoch'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .nu64 */ ._O('credits'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .nu64 */ ._O('prevCredits')]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .offset */ .cv(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .u32 */ .Jq(), -8), 'epochCredits'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .nu64 */ ._O('slot'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_7__/* .nu64 */ ._O('timestamp')], 'lastTimestamp')]);
/**
 * VoteAccount class
 */
class VoteAccount {
  /**
   * @internal
   */
  constructor(args) {
    this.nodePubkey = void 0;
    this.authorizedWithdrawer = void 0;
    this.commission = void 0;
    this.rootSlot = void 0;
    this.votes = void 0;
    this.authorizedVoters = void 0;
    this.priorVoters = void 0;
    this.epochCredits = void 0;
    this.lastTimestamp = void 0;
    this.nodePubkey = args.nodePubkey;
    this.authorizedWithdrawer = args.authorizedWithdrawer;
    this.commission = args.commission;
    this.rootSlot = args.rootSlot;
    this.votes = args.votes;
    this.authorizedVoters = args.authorizedVoters;
    this.priorVoters = args.priorVoters;
    this.epochCredits = args.epochCredits;
    this.lastTimestamp = args.lastTimestamp;
  }

  /**
   * Deserialize VoteAccount from the account data.
   *
   * @param buffer account data
   * @return VoteAccount
   */
  static fromAccountData(buffer) {
    const versionOffset = 4;
    const va = VoteAccountLayout.decode(toBuffer(buffer), versionOffset);
    let rootSlot = va.rootSlot;
    if (!va.rootSlotValid) {
      rootSlot = null;
    }
    return new VoteAccount({
      nodePubkey: new PublicKey(va.nodePubkey),
      authorizedWithdrawer: new PublicKey(va.authorizedWithdrawer),
      commission: va.commission,
      votes: va.votes,
      rootSlot,
      authorizedVoters: va.authorizedVoters.map(parseAuthorizedVoter),
      priorVoters: getPriorVoters(va.priorVoters),
      epochCredits: va.epochCredits,
      lastTimestamp: va.lastTimestamp
    });
  }
}
function parseAuthorizedVoter({
  authorizedVoter,
  epoch
}) {
  return {
    epoch,
    authorizedVoter: new PublicKey(authorizedVoter)
  };
}
function parsePriorVoters({
  authorizedPubkey,
  epochOfLastAuthorizedSwitch,
  targetEpoch
}) {
  return {
    authorizedPubkey: new PublicKey(authorizedPubkey),
    epochOfLastAuthorizedSwitch,
    targetEpoch
  };
}
function getPriorVoters({
  buf,
  idx,
  isEmpty
}) {
  if (isEmpty) {
    return [];
  }
  return [...buf.slice(idx + 1).map(parsePriorVoters), ...buf.slice(0, idx).map(parsePriorVoters)];
}

const endpoint = {
  http: {
    devnet: 'http://api.devnet.solana.com',
    testnet: 'http://api.testnet.solana.com',
    'mainnet-beta': 'http://api.mainnet-beta.solana.com/'
  },
  https: {
    devnet: 'https://api.devnet.solana.com',
    testnet: 'https://api.testnet.solana.com',
    'mainnet-beta': 'https://api.mainnet-beta.solana.com/'
  }
};
/**
 * Retrieves the RPC API URL for the specified cluster
 */
function clusterApiUrl(cluster, tls) {
  const key = tls === false ? 'http' : 'https';
  if (!cluster) {
    return endpoint[key]['devnet'];
  }
  const url = endpoint[key][cluster];
  if (!url) {
    throw new Error(`Unknown ${key} cluster: ${cluster}`);
  }
  return url;
}

/**
 * Send and confirm a raw transaction
 *
 * If `commitment` option is not specified, defaults to 'max' commitment.
 *
 * @param {Connection} connection
 * @param {Buffer} rawTransaction
 * @param {TransactionConfirmationStrategy} confirmationStrategy
 * @param {ConfirmOptions} [options]
 * @returns {Promise<TransactionSignature>}
 */

/**
 * @deprecated Calling `sendAndConfirmRawTransaction()` without a `confirmationStrategy`
 * is no longer supported and will be removed in a future version.
 */
// eslint-disable-next-line no-redeclare

// eslint-disable-next-line no-redeclare
async function sendAndConfirmRawTransaction(connection, rawTransaction, confirmationStrategyOrConfirmOptions, maybeConfirmOptions) {
  let confirmationStrategy;
  let options;
  if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, 'lastValidBlockHeight')) {
    confirmationStrategy = confirmationStrategyOrConfirmOptions;
    options = maybeConfirmOptions;
  } else if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, 'nonceValue')) {
    confirmationStrategy = confirmationStrategyOrConfirmOptions;
    options = maybeConfirmOptions;
  } else {
    options = confirmationStrategyOrConfirmOptions;
  }
  const sendOptions = options && {
    skipPreflight: options.skipPreflight,
    preflightCommitment: options.preflightCommitment || options.commitment,
    minContextSlot: options.minContextSlot
  };
  const signature = await connection.sendRawTransaction(rawTransaction, sendOptions);
  const commitment = options && options.commitment;
  const confirmationPromise = confirmationStrategy ? connection.confirmTransaction(confirmationStrategy, commitment) : connection.confirmTransaction(signature, commitment);
  const status = (await confirmationPromise).value;
  if (status.err) {
    throw new Error(`Raw transaction ${signature} failed (${JSON.stringify(status)})`);
  }
  return signature;
}

/**
 * There are 1-billion lamports in one SOL
 */
const LAMPORTS_PER_SOL = 1000000000;




/***/ }),

/***/ 39925:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Account: () => (/* binding */ Account),
/* harmony export */   AddressLookupTableAccount: () => (/* binding */ AddressLookupTableAccount),
/* harmony export */   AddressLookupTableInstruction: () => (/* binding */ AddressLookupTableInstruction),
/* harmony export */   AddressLookupTableProgram: () => (/* binding */ AddressLookupTableProgram),
/* harmony export */   Authorized: () => (/* binding */ Authorized),
/* harmony export */   BLOCKHASH_CACHE_TIMEOUT_MS: () => (/* binding */ BLOCKHASH_CACHE_TIMEOUT_MS),
/* harmony export */   BPF_LOADER_DEPRECATED_PROGRAM_ID: () => (/* binding */ BPF_LOADER_DEPRECATED_PROGRAM_ID),
/* harmony export */   BPF_LOADER_PROGRAM_ID: () => (/* binding */ BPF_LOADER_PROGRAM_ID),
/* harmony export */   BpfLoader: () => (/* binding */ BpfLoader),
/* harmony export */   COMPUTE_BUDGET_INSTRUCTION_LAYOUTS: () => (/* binding */ COMPUTE_BUDGET_INSTRUCTION_LAYOUTS),
/* harmony export */   ComputeBudgetInstruction: () => (/* binding */ ComputeBudgetInstruction),
/* harmony export */   ComputeBudgetProgram: () => (/* binding */ ComputeBudgetProgram),
/* harmony export */   Connection: () => (/* binding */ Connection),
/* harmony export */   Ed25519Program: () => (/* binding */ Ed25519Program),
/* harmony export */   Enum: () => (/* binding */ Enum),
/* harmony export */   EpochSchedule: () => (/* binding */ EpochSchedule),
/* harmony export */   FeeCalculatorLayout: () => (/* binding */ FeeCalculatorLayout),
/* harmony export */   Keypair: () => (/* binding */ Keypair),
/* harmony export */   LAMPORTS_PER_SOL: () => (/* binding */ LAMPORTS_PER_SOL),
/* harmony export */   LOOKUP_TABLE_INSTRUCTION_LAYOUTS: () => (/* binding */ LOOKUP_TABLE_INSTRUCTION_LAYOUTS),
/* harmony export */   Loader: () => (/* binding */ Loader),
/* harmony export */   Lockup: () => (/* binding */ Lockup),
/* harmony export */   MAX_SEED_LENGTH: () => (/* binding */ MAX_SEED_LENGTH),
/* harmony export */   Message: () => (/* binding */ Message),
/* harmony export */   MessageAccountKeys: () => (/* binding */ MessageAccountKeys),
/* harmony export */   MessageV0: () => (/* binding */ MessageV0),
/* harmony export */   NONCE_ACCOUNT_LENGTH: () => (/* binding */ NONCE_ACCOUNT_LENGTH),
/* harmony export */   NonceAccount: () => (/* binding */ NonceAccount),
/* harmony export */   PACKET_DATA_SIZE: () => (/* binding */ PACKET_DATA_SIZE),
/* harmony export */   PUBLIC_KEY_LENGTH: () => (/* binding */ PUBLIC_KEY_LENGTH),
/* harmony export */   PublicKey: () => (/* binding */ PublicKey),
/* harmony export */   SIGNATURE_LENGTH_IN_BYTES: () => (/* binding */ SIGNATURE_LENGTH_IN_BYTES),
/* harmony export */   SOLANA_SCHEMA: () => (/* binding */ SOLANA_SCHEMA),
/* harmony export */   STAKE_CONFIG_ID: () => (/* binding */ STAKE_CONFIG_ID),
/* harmony export */   STAKE_INSTRUCTION_LAYOUTS: () => (/* binding */ STAKE_INSTRUCTION_LAYOUTS),
/* harmony export */   SYSTEM_INSTRUCTION_LAYOUTS: () => (/* binding */ SYSTEM_INSTRUCTION_LAYOUTS),
/* harmony export */   SYSVAR_CLOCK_PUBKEY: () => (/* binding */ SYSVAR_CLOCK_PUBKEY),
/* harmony export */   SYSVAR_EPOCH_SCHEDULE_PUBKEY: () => (/* binding */ SYSVAR_EPOCH_SCHEDULE_PUBKEY),
/* harmony export */   SYSVAR_INSTRUCTIONS_PUBKEY: () => (/* binding */ SYSVAR_INSTRUCTIONS_PUBKEY),
/* harmony export */   SYSVAR_RECENT_BLOCKHASHES_PUBKEY: () => (/* binding */ SYSVAR_RECENT_BLOCKHASHES_PUBKEY),
/* harmony export */   SYSVAR_RENT_PUBKEY: () => (/* binding */ SYSVAR_RENT_PUBKEY),
/* harmony export */   SYSVAR_REWARDS_PUBKEY: () => (/* binding */ SYSVAR_REWARDS_PUBKEY),
/* harmony export */   SYSVAR_SLOT_HASHES_PUBKEY: () => (/* binding */ SYSVAR_SLOT_HASHES_PUBKEY),
/* harmony export */   SYSVAR_SLOT_HISTORY_PUBKEY: () => (/* binding */ SYSVAR_SLOT_HISTORY_PUBKEY),
/* harmony export */   SYSVAR_STAKE_HISTORY_PUBKEY: () => (/* binding */ SYSVAR_STAKE_HISTORY_PUBKEY),
/* harmony export */   Secp256k1Program: () => (/* binding */ Secp256k1Program),
/* harmony export */   SendTransactionError: () => (/* binding */ SendTransactionError),
/* harmony export */   SolanaJSONRPCError: () => (/* binding */ SolanaJSONRPCError),
/* harmony export */   SolanaJSONRPCErrorCode: () => (/* binding */ SolanaJSONRPCErrorCode),
/* harmony export */   StakeAuthorizationLayout: () => (/* binding */ StakeAuthorizationLayout),
/* harmony export */   StakeInstruction: () => (/* binding */ StakeInstruction),
/* harmony export */   StakeProgram: () => (/* binding */ StakeProgram),
/* harmony export */   Struct: () => (/* binding */ Struct),
/* harmony export */   SystemInstruction: () => (/* binding */ SystemInstruction),
/* harmony export */   SystemProgram: () => (/* binding */ SystemProgram),
/* harmony export */   Transaction: () => (/* binding */ Transaction),
/* harmony export */   TransactionExpiredBlockheightExceededError: () => (/* binding */ TransactionExpiredBlockheightExceededError),
/* harmony export */   TransactionExpiredNonceInvalidError: () => (/* binding */ TransactionExpiredNonceInvalidError),
/* harmony export */   TransactionExpiredTimeoutError: () => (/* binding */ TransactionExpiredTimeoutError),
/* harmony export */   TransactionInstruction: () => (/* binding */ TransactionInstruction),
/* harmony export */   TransactionMessage: () => (/* binding */ TransactionMessage),
/* harmony export */   TransactionStatus: () => (/* binding */ TransactionStatus),
/* harmony export */   VALIDATOR_INFO_KEY: () => (/* binding */ VALIDATOR_INFO_KEY),
/* harmony export */   VERSION_PREFIX_MASK: () => (/* binding */ VERSION_PREFIX_MASK),
/* harmony export */   VOTE_PROGRAM_ID: () => (/* binding */ VOTE_PROGRAM_ID),
/* harmony export */   ValidatorInfo: () => (/* binding */ ValidatorInfo),
/* harmony export */   VersionedMessage: () => (/* binding */ VersionedMessage),
/* harmony export */   VersionedTransaction: () => (/* binding */ VersionedTransaction),
/* harmony export */   VoteAccount: () => (/* binding */ VoteAccount),
/* harmony export */   VoteAuthorizationLayout: () => (/* binding */ VoteAuthorizationLayout),
/* harmony export */   VoteInit: () => (/* binding */ VoteInit),
/* harmony export */   VoteInstruction: () => (/* binding */ VoteInstruction),
/* harmony export */   VoteProgram: () => (/* binding */ VoteProgram),
/* harmony export */   clusterApiUrl: () => (/* binding */ clusterApiUrl),
/* harmony export */   sendAndConfirmRawTransaction: () => (/* binding */ sendAndConfirmRawTransaction),
/* harmony export */   sendAndConfirmTransaction: () => (/* binding */ sendAndConfirmTransaction)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(4013);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(85338);
/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7661);
/* harmony import */ var _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(52456);
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(68633);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(98564);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(30986);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(20006);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(41534);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(73182);
/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(bn_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(30721);
/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(bs58__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(97018);
/* harmony import */ var borsh__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(71433);
/* harmony import */ var borsh__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(borsh__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(2208);
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(62966);
/* harmony import */ var bigint_buffer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(76470);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(39279);
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(811);
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(98171);
/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(48078);
/* harmony import */ var superstruct__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(94700);
/* harmony import */ var jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(69362);
/* harmony import */ var jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(71897);
/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(45066);
/* harmony import */ var rpc_websockets_dist_lib_client__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(78372);
/* harmony import */ var rpc_websockets_dist_lib_client_websocket_browser__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(79179);
/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(64175);
/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(40269);






























/**
 * A 64 byte secret key, the first 32 bytes of which is the
 * private scalar and the last 32 bytes is the public key.
 * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
 */

/**
 * Ed25519 Keypair
 */

var generatePrivateKey = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_10__/* .ed25519 */ .UN.utils.randomPrivateKey;
var generateKeypair = function generateKeypair() {
  var privateScalar = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_10__/* .ed25519 */ .UN.utils.randomPrivateKey();
  var publicKey = getPublicKey(privateScalar);
  var secretKey = new Uint8Array(64);
  secretKey.set(privateScalar);
  secretKey.set(publicKey, 32);
  return {
    publicKey: publicKey,
    secretKey: secretKey
  };
};
var getPublicKey = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_10__/* .ed25519 */ .UN.getPublicKey;
function isOnCurve(publicKey) {
  try {
    _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_10__/* .ed25519 */ .UN.ExtendedPoint.fromHex(publicKey);
    return true;
  } catch (_unused) {
    return false;
  }
}
var sign = function sign(message, secretKey) {
  return _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_10__/* .ed25519 */ .UN.sign(message, secretKey.slice(0, 32));
};
var verify = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_10__/* .ed25519 */ .UN.verify;

var toBuffer = function toBuffer(arr) {
  if (buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.isBuffer(arr)) {
    return arr;
  } else if (arr instanceof Uint8Array) {
    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
  } else {
    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(arr);
  }
};

function _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .Z)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .Z)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .Z)(this, result); }; }
function _isNativeReflectConstruct$4() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

// Class wrapping a plain object
var Struct = /*#__PURE__*/function () {
  function Struct(properties) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, Struct);
    Object.assign(this, properties);
  }
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(Struct, [{
    key: "encode",
    value: function encode() {
      return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from((0,borsh__WEBPACK_IMPORTED_MODULE_4__.serialize)(SOLANA_SCHEMA, this));
    }
  }], [{
    key: "decode",
    value: function decode(data) {
      return (0,borsh__WEBPACK_IMPORTED_MODULE_4__.deserialize)(SOLANA_SCHEMA, this, data);
    }
  }, {
    key: "decodeUnchecked",
    value: function decodeUnchecked(data) {
      return (0,borsh__WEBPACK_IMPORTED_MODULE_4__.deserializeUnchecked)(SOLANA_SCHEMA, this, data);
    }
  }]);
  return Struct;
}();

// Class representing a Rust-compatible enum, since enums are only strings or
// numbers in pure JS
var Enum = /*#__PURE__*/function (_Struct) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(Enum, _Struct);
  var _super = _createSuper$4(Enum);
  function Enum(properties) {
    var _this;
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, Enum);
    _this = _super.call(this, properties);
    _this["enum"] = '';
    if (Object.keys(properties).length !== 1) {
      throw new Error('Enum can only take single value');
    }
    Object.keys(properties).map(function (key) {
      _this["enum"] = key;
    });
    return _this;
  }
  return (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(Enum);
}(Struct);
var SOLANA_SCHEMA = new Map();

var _Symbol$toStringTag;
function _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .Z)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .Z)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .Z)(this, result); }; }
function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Maximum length of derived pubkey seed
 */
var MAX_SEED_LENGTH = 32;

/**
 * Size of public key in bytes
 */
var PUBLIC_KEY_LENGTH = 32;

/**
 * Value to be converted into public key
 */

/**
 * JSON object representation of PublicKey class
 */

function isPublicKeyData(value) {
  return value._bn !== undefined;
}

// local counter used by PublicKey.unique()
var uniquePublicKeyCounter = 1;

/**
 * A public key
 */
_Symbol$toStringTag = Symbol.toStringTag;
var PublicKey = /*#__PURE__*/function (_Struct) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(PublicKey, _Struct);
  var _super = _createSuper$3(PublicKey);
  /**
   * Create a new PublicKey object
   * @param value ed25519 public key as buffer or base-58 encoded string
   */
  function PublicKey(value) {
    var _this;
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, PublicKey);
    _this = _super.call(this, {});
    /** @internal */
    _this._bn = void 0;
    if (isPublicKeyData(value)) {
      _this._bn = value._bn;
    } else {
      if (typeof value === 'string') {
        // assume base 58 encoding by default
        var decoded = bs58__WEBPACK_IMPORTED_MODULE_3___default().decode(value);
        if (decoded.length != PUBLIC_KEY_LENGTH) {
          throw new Error("Invalid public key input");
        }
        _this._bn = new (bn_js__WEBPACK_IMPORTED_MODULE_2___default())(decoded);
      } else {
        _this._bn = new (bn_js__WEBPACK_IMPORTED_MODULE_2___default())(value);
      }
      if (_this._bn.byteLength() > PUBLIC_KEY_LENGTH) {
        throw new Error("Invalid public key input");
      }
    }
    return _this;
  }

  /**
   * Returns a unique PublicKey for tests and benchmarks using a counter
   */
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(PublicKey, [{
    key: "equals",
    value:
    /**
     * Checks if two publicKeys are equal
     */
    function equals(publicKey) {
      return this._bn.eq(publicKey._bn);
    }

    /**
     * Return the base-58 representation of the public key
     */
  }, {
    key: "toBase58",
    value: function toBase58() {
      return bs58__WEBPACK_IMPORTED_MODULE_3___default().encode(this.toBytes());
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.toBase58();
    }

    /**
     * Return the byte array representation of the public key in big endian
     */
  }, {
    key: "toBytes",
    value: function toBytes() {
      var buf = this.toBuffer();
      return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
    }

    /**
     * Return the Buffer representation of the public key in big endian
     */
  }, {
    key: "toBuffer",
    value: function toBuffer() {
      var b = this._bn.toArrayLike(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer);
      if (b.length === PUBLIC_KEY_LENGTH) {
        return b;
      }
      var zeroPad = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(32);
      b.copy(zeroPad, 32 - b.length);
      return zeroPad;
    }
  }, {
    key: _Symbol$toStringTag,
    get: function get() {
      return "PublicKey(".concat(this.toString(), ")");
    }

    /**
     * Return the base-58 representation of the public key
     */
  }, {
    key: "toString",
    value: function toString() {
      return this.toBase58();
    }

    /**
     * Derive a public key from another key, a seed, and a program ID.
     * The program ID will also serve as the owner of the public key, giving
     * it permission to write data to the account.
     */
    /* eslint-disable require-await */
  }], [{
    key: "unique",
    value: function unique() {
      var key = new PublicKey(uniquePublicKeyCounter);
      uniquePublicKeyCounter += 1;
      return new PublicKey(key.toBuffer());
    }

    /**
     * Default public key value. The base58-encoded string representation is all ones (as seen below)
     * The underlying BN number is 32 bytes that are all zeros
     */
  }, {
    key: "createWithSeed",
    value: function () {
      var _createWithSeed = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee(fromPublicKey, seed, programId) {
        var buffer, publicKeyBytes;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([fromPublicKey.toBuffer(), buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(seed), programId.toBuffer()]);
              publicKeyBytes = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_17__/* .sha256 */ .J)(buffer);
              return _context.abrupt("return", new PublicKey(publicKeyBytes));
            case 3:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      function createWithSeed(_x, _x2, _x3) {
        return _createWithSeed.apply(this, arguments);
      }
      return createWithSeed;
    }()
    /**
     * Derive a program address from seeds and a program ID.
     */
    /* eslint-disable require-await */
  }, {
    key: "createProgramAddressSync",
    value: function createProgramAddressSync(seeds, programId) {
      var buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(0);
      seeds.forEach(function (seed) {
        if (seed.length > MAX_SEED_LENGTH) {
          throw new TypeError("Max seed length exceeded");
        }
        buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([buffer, toBuffer(seed)]);
      });
      buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([buffer, programId.toBuffer(), buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from('ProgramDerivedAddress')]);
      var publicKeyBytes = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_17__/* .sha256 */ .J)(buffer);
      if (isOnCurve(publicKeyBytes)) {
        throw new Error("Invalid seeds, address must fall off the curve");
      }
      return new PublicKey(publicKeyBytes);
    }

    /**
     * Async version of createProgramAddressSync
     * For backwards compatibility
     *
     * @deprecated Use {@link createProgramAddressSync} instead
     */
    /* eslint-disable require-await */
  }, {
    key: "createProgramAddress",
    value: function () {
      var _createProgramAddress = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee2(seeds, programId) {
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", this.createProgramAddressSync(seeds, programId));
            case 1:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function createProgramAddress(_x4, _x5) {
        return _createProgramAddress.apply(this, arguments);
      }
      return createProgramAddress;
    }()
    /**
     * Find a valid program address
     *
     * Valid program addresses must fall off the ed25519 curve.  This function
     * iterates a nonce until it finds one that when combined with the seeds
     * results in a valid program address.
     */
  }, {
    key: "findProgramAddressSync",
    value: function findProgramAddressSync(seeds, programId) {
      var nonce = 255;
      var address;
      while (nonce != 0) {
        try {
          var seedsWithNonce = seeds.concat(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([nonce]));
          address = this.createProgramAddressSync(seedsWithNonce, programId);
        } catch (err) {
          if (err instanceof TypeError) {
            throw err;
          }
          nonce--;
          continue;
        }
        return [address, nonce];
      }
      throw new Error("Unable to find a viable program address nonce");
    }

    /**
     * Async version of findProgramAddressSync
     * For backwards compatibility
     *
     * @deprecated Use {@link findProgramAddressSync} instead
     */
  }, {
    key: "findProgramAddress",
    value: function () {
      var _findProgramAddress = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee3(seeds, programId) {
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.abrupt("return", this.findProgramAddressSync(seeds, programId));
            case 1:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function findProgramAddress(_x6, _x7) {
        return _findProgramAddress.apply(this, arguments);
      }
      return findProgramAddress;
    }()
    /**
     * Check that a pubkey is on the ed25519 curve.
     */
  }, {
    key: "isOnCurve",
    value: function isOnCurve$1(pubkeyData) {
      var pubkey = new PublicKey(pubkeyData);
      return isOnCurve(pubkey.toBytes());
    }
  }]);
  return PublicKey;
}(Struct);
PublicKey["default"] = new PublicKey('11111111111111111111111111111111');
SOLANA_SCHEMA.set(PublicKey, {
  kind: 'struct',
  fields: [['_bn', 'u256']]
});

/**
 * An account key pair (public and secret keys).
 *
 * @deprecated since v1.10.0, please use {@link Keypair} instead.
 */
var Account = /*#__PURE__*/function () {
  /**
   * Create a new Account object
   *
   * If the secretKey parameter is not provided a new key pair is randomly
   * created for the account
   *
   * @param secretKey Secret key for the account
   */
  function Account(secretKey) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, Account);
    /** @internal */
    this._publicKey = void 0;
    /** @internal */
    this._secretKey = void 0;
    if (secretKey) {
      var secretKeyBuffer = toBuffer(secretKey);
      if (secretKey.length !== 64) {
        throw new Error('bad secret key size');
      }
      this._publicKey = secretKeyBuffer.slice(32, 64);
      this._secretKey = secretKeyBuffer.slice(0, 32);
    } else {
      this._secretKey = toBuffer(generatePrivateKey());
      this._publicKey = toBuffer(getPublicKey(this._secretKey));
    }
  }

  /**
   * The public key for this account
   */
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(Account, [{
    key: "publicKey",
    get: function get() {
      return new PublicKey(this._publicKey);
    }

    /**
     * The **unencrypted** secret key for this account. The first 32 bytes
     * is the private scalar and the last 32 bytes is the public key.
     * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
     */
  }, {
    key: "secretKey",
    get: function get() {
      return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([this._secretKey, this._publicKey], 64);
    }
  }]);
  return Account;
}();

var BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey('BPFLoader1111111111111111111111111111111111');

/**
 * Maximum over-the-wire size of a Transaction
 *
 * 1280 is IPv6 minimum MTU
 * 40 bytes is the size of the IPv6 header
 * 8 bytes is the size of the fragment header
 */
var PACKET_DATA_SIZE = 1280 - 40 - 8;
var VERSION_PREFIX_MASK = 0x7f;
var SIGNATURE_LENGTH_IN_BYTES = 64;

function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .Z)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .Z)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .Z)(this, result); }; }
function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var TransactionExpiredBlockheightExceededError = /*#__PURE__*/function (_Error) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(TransactionExpiredBlockheightExceededError, _Error);
  var _super = _createSuper$2(TransactionExpiredBlockheightExceededError);
  function TransactionExpiredBlockheightExceededError(signature) {
    var _this;
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, TransactionExpiredBlockheightExceededError);
    _this = _super.call(this, "Signature ".concat(signature, " has expired: block height exceeded."));
    _this.signature = void 0;
    _this.signature = signature;
    return _this;
  }
  return (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(TransactionExpiredBlockheightExceededError);
}( /*#__PURE__*/(0,_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .Z)(Error));
Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype, 'name', {
  value: 'TransactionExpiredBlockheightExceededError'
});
var TransactionExpiredTimeoutError = /*#__PURE__*/function (_Error2) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(TransactionExpiredTimeoutError, _Error2);
  var _super2 = _createSuper$2(TransactionExpiredTimeoutError);
  function TransactionExpiredTimeoutError(signature, timeoutSeconds) {
    var _this2;
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, TransactionExpiredTimeoutError);
    _this2 = _super2.call(this, "Transaction was not confirmed in ".concat(timeoutSeconds.toFixed(2), " seconds. It is ") + 'unknown if it succeeded or failed. Check signature ' + "".concat(signature, " using the Solana Explorer or CLI tools."));
    _this2.signature = void 0;
    _this2.signature = signature;
    return _this2;
  }
  return (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(TransactionExpiredTimeoutError);
}( /*#__PURE__*/(0,_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .Z)(Error));
Object.defineProperty(TransactionExpiredTimeoutError.prototype, 'name', {
  value: 'TransactionExpiredTimeoutError'
});
var TransactionExpiredNonceInvalidError = /*#__PURE__*/function (_Error3) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(TransactionExpiredNonceInvalidError, _Error3);
  var _super3 = _createSuper$2(TransactionExpiredNonceInvalidError);
  function TransactionExpiredNonceInvalidError(signature) {
    var _this3;
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, TransactionExpiredNonceInvalidError);
    _this3 = _super3.call(this, "Signature ".concat(signature, " has expired: the nonce is no longer valid."));
    _this3.signature = void 0;
    _this3.signature = signature;
    return _this3;
  }
  return (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(TransactionExpiredNonceInvalidError);
}( /*#__PURE__*/(0,_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .Z)(Error));
Object.defineProperty(TransactionExpiredNonceInvalidError.prototype, 'name', {
  value: 'TransactionExpiredNonceInvalidError'
});

function _createForOfIteratorHelper$5(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$5(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray$5(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$5(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen); }
function _arrayLikeToArray$5(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var MessageAccountKeys = /*#__PURE__*/function () {
  function MessageAccountKeys(staticAccountKeys, accountKeysFromLookups) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, MessageAccountKeys);
    this.staticAccountKeys = void 0;
    this.accountKeysFromLookups = void 0;
    this.staticAccountKeys = staticAccountKeys;
    this.accountKeysFromLookups = accountKeysFromLookups;
  }
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(MessageAccountKeys, [{
    key: "keySegments",
    value: function keySegments() {
      var keySegments = [this.staticAccountKeys];
      if (this.accountKeysFromLookups) {
        keySegments.push(this.accountKeysFromLookups.writable);
        keySegments.push(this.accountKeysFromLookups.readonly);
      }
      return keySegments;
    }
  }, {
    key: "get",
    value: function get(index) {
      var _iterator = _createForOfIteratorHelper$5(this.keySegments()),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var keySegment = _step.value;
          if (index < keySegment.length) {
            return keySegment[index];
          } else {
            index -= keySegment.length;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return;
    }
  }, {
    key: "length",
    get: function get() {
      return this.keySegments().flat().length;
    }
  }, {
    key: "compileInstructions",
    value: function compileInstructions(instructions) {
      // Bail early if any account indexes would overflow a u8
      var U8_MAX = 255;
      if (this.length > U8_MAX + 1) {
        throw new Error('Account index overflow encountered during compilation');
      }
      var keyIndexMap = new Map();
      this.keySegments().flat().forEach(function (key, index) {
        keyIndexMap.set(key.toBase58(), index);
      });
      var findKeyIndex = function findKeyIndex(key) {
        var keyIndex = keyIndexMap.get(key.toBase58());
        if (keyIndex === undefined) throw new Error('Encountered an unknown instruction account key during compilation');
        return keyIndex;
      };
      return instructions.map(function (instruction) {
        return {
          programIdIndex: findKeyIndex(instruction.programId),
          accountKeyIndexes: instruction.keys.map(function (meta) {
            return findKeyIndex(meta.pubkey);
          }),
          data: instruction.data
        };
      });
    }
  }]);
  return MessageAccountKeys;
}();

/**
 * Layout for a public key
 */
var publicKey = function publicKey() {
  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'publicKey';
  return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .blob */ .Ik(32, property);
};

/**
 * Layout for a signature
 */
var signature = function signature() {
  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'signature';
  return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .blob */ .Ik(64, property);
};
/**
 * Layout for a Rust String type
 */
var rustString = function rustString() {
  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'string';
  var rsl = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('length'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('lengthPadding'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .blob */ .Ik(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .offset */ .cv(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq(), -8), 'chars')], property);
  var _decode = rsl.decode.bind(rsl);
  var _encode = rsl.encode.bind(rsl);
  var rslShim = rsl;
  rslShim.decode = function (b, offset) {
    var data = _decode(b, offset);
    return data['chars'].toString();
  };
  rslShim.encode = function (str, b, offset) {
    var data = {
      chars: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(str, 'utf8')
    };
    return _encode(data, b, offset);
  };
  rslShim.alloc = function (str) {
    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq().span + _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq().span + buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(str, 'utf8').length;
  };
  return rslShim;
};

/**
 * Layout for an Authorized object
 */
var authorized = function authorized() {
  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'authorized';
  return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([publicKey('staker'), publicKey('withdrawer')], property);
};

/**
 * Layout for a Lockup object
 */
var lockup = function lockup() {
  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'lockup';
  return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .ns64 */ .gM('unixTimestamp'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .ns64 */ .gM('epoch'), publicKey('custodian')], property);
};

/**
 *  Layout for a VoteInit object
 */
var voteInit = function voteInit() {
  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'voteInit';
  return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([publicKey('nodePubkey'), publicKey('authorizedVoter'), publicKey('authorizedWithdrawer'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__.u8('commission')], property);
};

/**
 *  Layout for a VoteAuthorizeWithSeedArgs object
 */
var voteAuthorizeWithSeedArgs = function voteAuthorizeWithSeedArgs() {
  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'voteAuthorizeWithSeedArgs';
  return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('voteAuthorizationType'), publicKey('currentAuthorityDerivedKeyOwnerPubkey'), rustString('currentAuthorityDerivedKeySeed'), publicKey('newAuthorized')], property);
};
function getAlloc(type, fields) {
  var getItemAlloc = function getItemAlloc(item) {
    if (item.span >= 0) {
      return item.span;
    } else if (typeof item.alloc === 'function') {
      return item.alloc(fields[item.property]);
    } else if ('count' in item && 'elementLayout' in item) {
      var field = fields[item.property];
      if (Array.isArray(field)) {
        return field.length * getItemAlloc(item.elementLayout);
      }
    } else if ('fields' in item) {
      // This is a `Structure` whose size needs to be recursively measured.
      return getAlloc({
        layout: item
      }, fields[item.property]);
    }
    // Couldn't determine allocated size of layout
    return 0;
  };
  var alloc = 0;
  type.layout.fields.forEach(function (item) {
    alloc += getItemAlloc(item);
  });
  return alloc;
}

function decodeLength(bytes) {
  var len = 0;
  var size = 0;
  for (;;) {
    var elem = bytes.shift();
    len |= (elem & 0x7f) << size * 7;
    size += 1;
    if ((elem & 0x80) === 0) {
      break;
    }
  }
  return len;
}
function encodeLength(bytes, len) {
  var rem_len = len;
  for (;;) {
    var elem = rem_len & 0x7f;
    rem_len >>= 7;
    if (rem_len == 0) {
      bytes.push(elem);
      break;
    } else {
      elem |= 0x80;
      bytes.push(elem);
    }
  }
}

function assert (condition, message) {
  if (!condition) {
    throw new Error(message || 'Assertion failed');
  }
}

function _createForOfIteratorHelper$4(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray$4(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$4(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen); }
function _arrayLikeToArray$4(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var CompiledKeys = /*#__PURE__*/function () {
  function CompiledKeys(payer, keyMetaMap) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, CompiledKeys);
    this.payer = void 0;
    this.keyMetaMap = void 0;
    this.payer = payer;
    this.keyMetaMap = keyMetaMap;
  }
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(CompiledKeys, [{
    key: "getMessageComponents",
    value: function getMessageComponents() {
      var mapEntries = (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_19__/* ["default"] */ .Z)(this.keyMetaMap.entries());
      assert(mapEntries.length <= 256, 'Max static account keys length exceeded');
      var writableSigners = mapEntries.filter(function (_ref) {
        var _ref2 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(_ref, 2),
          meta = _ref2[1];
        return meta.isSigner && meta.isWritable;
      });
      var readonlySigners = mapEntries.filter(function (_ref3) {
        var _ref4 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(_ref3, 2),
          meta = _ref4[1];
        return meta.isSigner && !meta.isWritable;
      });
      var writableNonSigners = mapEntries.filter(function (_ref5) {
        var _ref6 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(_ref5, 2),
          meta = _ref6[1];
        return !meta.isSigner && meta.isWritable;
      });
      var readonlyNonSigners = mapEntries.filter(function (_ref7) {
        var _ref8 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(_ref7, 2),
          meta = _ref8[1];
        return !meta.isSigner && !meta.isWritable;
      });
      var header = {
        numRequiredSignatures: writableSigners.length + readonlySigners.length,
        numReadonlySignedAccounts: readonlySigners.length,
        numReadonlyUnsignedAccounts: readonlyNonSigners.length
      };

      // sanity checks
      {
        assert(writableSigners.length > 0, 'Expected at least one writable signer key');
        var _writableSigners$ = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(writableSigners[0], 1),
          payerAddress = _writableSigners$[0];
        assert(payerAddress === this.payer.toBase58(), 'Expected first writable signer key to be the fee payer');
      }
      var staticAccountKeys = [].concat((0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_19__/* ["default"] */ .Z)(writableSigners.map(function (_ref9) {
        var _ref10 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(_ref9, 1),
          address = _ref10[0];
        return new PublicKey(address);
      })), (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_19__/* ["default"] */ .Z)(readonlySigners.map(function (_ref11) {
        var _ref12 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(_ref11, 1),
          address = _ref12[0];
        return new PublicKey(address);
      })), (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_19__/* ["default"] */ .Z)(writableNonSigners.map(function (_ref13) {
        var _ref14 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(_ref13, 1),
          address = _ref14[0];
        return new PublicKey(address);
      })), (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_19__/* ["default"] */ .Z)(readonlyNonSigners.map(function (_ref15) {
        var _ref16 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(_ref15, 1),
          address = _ref16[0];
        return new PublicKey(address);
      })));
      return [header, staticAccountKeys];
    }
  }, {
    key: "extractTableLookup",
    value: function extractTableLookup(lookupTable) {
      var _this$drainKeysFoundI = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, function (keyMeta) {
          return !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable;
        }),
        _this$drainKeysFoundI2 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(_this$drainKeysFoundI, 2),
        writableIndexes = _this$drainKeysFoundI2[0],
        drainedWritableKeys = _this$drainKeysFoundI2[1];
      var _this$drainKeysFoundI3 = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, function (keyMeta) {
          return !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable;
        }),
        _this$drainKeysFoundI4 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(_this$drainKeysFoundI3, 2),
        readonlyIndexes = _this$drainKeysFoundI4[0],
        drainedReadonlyKeys = _this$drainKeysFoundI4[1];

      // Don't extract lookup if no keys were found
      if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {
        return;
      }
      return [{
        accountKey: lookupTable.key,
        writableIndexes: writableIndexes,
        readonlyIndexes: readonlyIndexes
      }, {
        writable: drainedWritableKeys,
        readonly: drainedReadonlyKeys
      }];
    }

    /** @internal */
  }, {
    key: "drainKeysFoundInLookupTable",
    value: function drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {
      var _this = this;
      var lookupTableIndexes = new Array();
      var drainedKeys = new Array();
      var _iterator = _createForOfIteratorHelper$4(this.keyMetaMap.entries()),
        _step;
      try {
        var _loop = function _loop() {
          var _step$value = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(_step.value, 2),
            address = _step$value[0],
            keyMeta = _step$value[1];
          if (keyMetaFilter(keyMeta)) {
            var key = new PublicKey(address);
            var lookupTableIndex = lookupTableEntries.findIndex(function (entry) {
              return entry.equals(key);
            });
            if (lookupTableIndex >= 0) {
              assert(lookupTableIndex < 256, 'Max lookup table index exceeded');
              lookupTableIndexes.push(lookupTableIndex);
              drainedKeys.push(key);
              _this.keyMetaMap["delete"](address);
            }
          }
        };
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          _loop();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return [lookupTableIndexes, drainedKeys];
    }
  }], [{
    key: "compile",
    value: function compile(instructions, payer) {
      var keyMetaMap = new Map();
      var getOrInsertDefault = function getOrInsertDefault(pubkey) {
        var address = pubkey.toBase58();
        var keyMeta = keyMetaMap.get(address);
        if (keyMeta === undefined) {
          keyMeta = {
            isSigner: false,
            isWritable: false,
            isInvoked: false
          };
          keyMetaMap.set(address, keyMeta);
        }
        return keyMeta;
      };
      var payerKeyMeta = getOrInsertDefault(payer);
      payerKeyMeta.isSigner = true;
      payerKeyMeta.isWritable = true;
      var _iterator2 = _createForOfIteratorHelper$4(instructions),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var ix = _step2.value;
          getOrInsertDefault(ix.programId).isInvoked = true;
          var _iterator3 = _createForOfIteratorHelper$4(ix.keys),
            _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var accountMeta = _step3.value;
              var _keyMeta = getOrInsertDefault(accountMeta.pubkey);
              _keyMeta.isSigner || (_keyMeta.isSigner = accountMeta.isSigner);
              _keyMeta.isWritable || (_keyMeta.isWritable = accountMeta.isWritable);
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return new CompiledKeys(payer, keyMetaMap);
    }
  }]);
  return CompiledKeys;
}();

/**
 * An instruction to execute by a program
 *
 * @property {number} programIdIndex
 * @property {number[]} accounts
 * @property {string} data
 */

/**
 * Message constructor arguments
 */

/**
 * List of instructions to be processed atomically
 */
var Message = /*#__PURE__*/function () {
  function Message(args) {
    var _this = this;
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, Message);
    this.header = void 0;
    this.accountKeys = void 0;
    this.recentBlockhash = void 0;
    this.instructions = void 0;
    this.indexToProgramIds = new Map();
    this.header = args.header;
    this.accountKeys = args.accountKeys.map(function (account) {
      return new PublicKey(account);
    });
    this.recentBlockhash = args.recentBlockhash;
    this.instructions = args.instructions;
    this.instructions.forEach(function (ix) {
      return _this.indexToProgramIds.set(ix.programIdIndex, _this.accountKeys[ix.programIdIndex]);
    });
  }
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(Message, [{
    key: "version",
    get: function get() {
      return 'legacy';
    }
  }, {
    key: "staticAccountKeys",
    get: function get() {
      return this.accountKeys;
    }
  }, {
    key: "compiledInstructions",
    get: function get() {
      return this.instructions.map(function (ix) {
        return {
          programIdIndex: ix.programIdIndex,
          accountKeyIndexes: ix.accounts,
          data: bs58__WEBPACK_IMPORTED_MODULE_3___default().decode(ix.data)
        };
      });
    }
  }, {
    key: "addressTableLookups",
    get: function get() {
      return [];
    }
  }, {
    key: "getAccountKeys",
    value: function getAccountKeys() {
      return new MessageAccountKeys(this.staticAccountKeys);
    }
  }, {
    key: "isAccountSigner",
    value: function isAccountSigner(index) {
      return index < this.header.numRequiredSignatures;
    }
  }, {
    key: "isAccountWritable",
    value: function isAccountWritable(index) {
      var numSignedAccounts = this.header.numRequiredSignatures;
      if (index >= this.header.numRequiredSignatures) {
        var unsignedAccountIndex = index - numSignedAccounts;
        var numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;
        var numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
        return unsignedAccountIndex < numWritableUnsignedAccounts;
      } else {
        var numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
        return index < numWritableSignedAccounts;
      }
    }
  }, {
    key: "isProgramId",
    value: function isProgramId(index) {
      return this.indexToProgramIds.has(index);
    }
  }, {
    key: "programIds",
    value: function programIds() {
      return (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_19__/* ["default"] */ .Z)(this.indexToProgramIds.values());
    }
  }, {
    key: "nonProgramIds",
    value: function nonProgramIds() {
      var _this2 = this;
      return this.accountKeys.filter(function (_, index) {
        return !_this2.isProgramId(index);
      });
    }
  }, {
    key: "serialize",
    value: function serialize() {
      var numKeys = this.accountKeys.length;
      var keyCount = [];
      encodeLength(keyCount, numKeys);
      var instructions = this.instructions.map(function (instruction) {
        var accounts = instruction.accounts,
          programIdIndex = instruction.programIdIndex;
        var data = Array.from(bs58__WEBPACK_IMPORTED_MODULE_3___default().decode(instruction.data));
        var keyIndicesCount = [];
        encodeLength(keyIndicesCount, accounts.length);
        var dataCount = [];
        encodeLength(dataCount, data.length);
        return {
          programIdIndex: programIdIndex,
          keyIndicesCount: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(keyIndicesCount),
          keyIndices: accounts,
          dataLength: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(dataCount),
          data: data
        };
      });
      var instructionCount = [];
      encodeLength(instructionCount, instructions.length);
      var instructionBuffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(PACKET_DATA_SIZE);
      buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(instructionCount).copy(instructionBuffer);
      var instructionBufferLength = instructionCount.length;
      instructions.forEach(function (instruction) {
        var instructionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__.u8('programIdIndex'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .blob */ .Ik(instruction.keyIndicesCount.length, 'keyIndicesCount'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .seq */ .A9(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__.u8('keyIndex'), instruction.keyIndices.length, 'keyIndices'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .blob */ .Ik(instruction.dataLength.length, 'dataLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .seq */ .A9(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__.u8('userdatum'), instruction.data.length, 'data')]);
        var length = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);
        instructionBufferLength += length;
      });
      instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
      var signDataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .blob */ .Ik(1, 'numRequiredSignatures'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .blob */ .Ik(1, 'numReadonlySignedAccounts'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .blob */ .Ik(1, 'numReadonlyUnsignedAccounts'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .blob */ .Ik(keyCount.length, 'keyCount'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .seq */ .A9(publicKey('key'), numKeys, 'keys'), publicKey('recentBlockhash')]);
      var transaction = {
        numRequiredSignatures: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([this.header.numRequiredSignatures]),
        numReadonlySignedAccounts: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([this.header.numReadonlySignedAccounts]),
        numReadonlyUnsignedAccounts: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
        keyCount: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(keyCount),
        keys: this.accountKeys.map(function (key) {
          return toBuffer(key.toBytes());
        }),
        recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_3___default().decode(this.recentBlockhash)
      };
      var signData = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(2048);
      var length = signDataLayout.encode(transaction, signData);
      instructionBuffer.copy(signData, length);
      return signData.slice(0, length + instructionBuffer.length);
    }

    /**
     * Decode a compiled message into a Message object.
     */
  }], [{
    key: "compile",
    value: function compile(args) {
      var compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
      var _compiledKeys$getMess = compiledKeys.getMessageComponents(),
        _compiledKeys$getMess2 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(_compiledKeys$getMess, 2),
        header = _compiledKeys$getMess2[0],
        staticAccountKeys = _compiledKeys$getMess2[1];
      var accountKeys = new MessageAccountKeys(staticAccountKeys);
      var instructions = accountKeys.compileInstructions(args.instructions).map(function (ix) {
        return {
          programIdIndex: ix.programIdIndex,
          accounts: ix.accountKeyIndexes,
          data: bs58__WEBPACK_IMPORTED_MODULE_3___default().encode(ix.data)
        };
      });
      return new Message({
        header: header,
        accountKeys: staticAccountKeys,
        recentBlockhash: args.recentBlockhash,
        instructions: instructions
      });
    }
  }, {
    key: "from",
    value: function from(buffer) {
      // Slice up wire data
      var byteArray = (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_19__/* ["default"] */ .Z)(buffer);
      var numRequiredSignatures = byteArray.shift();
      if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {
        throw new Error('Versioned messages must be deserialized with VersionedMessage.deserialize()');
      }
      var numReadonlySignedAccounts = byteArray.shift();
      var numReadonlyUnsignedAccounts = byteArray.shift();
      var accountCount = decodeLength(byteArray);
      var accountKeys = [];
      for (var i = 0; i < accountCount; i++) {
        var account = byteArray.slice(0, PUBLIC_KEY_LENGTH);
        byteArray = byteArray.slice(PUBLIC_KEY_LENGTH);
        accountKeys.push(new PublicKey(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(account)));
      }
      var recentBlockhash = byteArray.slice(0, PUBLIC_KEY_LENGTH);
      byteArray = byteArray.slice(PUBLIC_KEY_LENGTH);
      var instructionCount = decodeLength(byteArray);
      var instructions = [];
      for (var _i = 0; _i < instructionCount; _i++) {
        var programIdIndex = byteArray.shift();
        var _accountCount = decodeLength(byteArray);
        var accounts = byteArray.slice(0, _accountCount);
        byteArray = byteArray.slice(_accountCount);
        var dataLength = decodeLength(byteArray);
        var dataSlice = byteArray.slice(0, dataLength);
        var data = bs58__WEBPACK_IMPORTED_MODULE_3___default().encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(dataSlice));
        byteArray = byteArray.slice(dataLength);
        instructions.push({
          programIdIndex: programIdIndex,
          accounts: accounts,
          data: data
        });
      }
      var messageArgs = {
        header: {
          numRequiredSignatures: numRequiredSignatures,
          numReadonlySignedAccounts: numReadonlySignedAccounts,
          numReadonlyUnsignedAccounts: numReadonlyUnsignedAccounts
        },
        recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_3___default().encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(recentBlockhash)),
        accountKeys: accountKeys,
        instructions: instructions
      };
      return new Message(messageArgs);
    }
  }]);
  return Message;
}();

function _createForOfIteratorHelper$3(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray$3(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$3(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }
function _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

/**
 * Message constructor arguments
 */

var MessageV0 = /*#__PURE__*/function () {
  function MessageV0(args) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, MessageV0);
    this.header = void 0;
    this.staticAccountKeys = void 0;
    this.recentBlockhash = void 0;
    this.compiledInstructions = void 0;
    this.addressTableLookups = void 0;
    this.header = args.header;
    this.staticAccountKeys = args.staticAccountKeys;
    this.recentBlockhash = args.recentBlockhash;
    this.compiledInstructions = args.compiledInstructions;
    this.addressTableLookups = args.addressTableLookups;
  }
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(MessageV0, [{
    key: "version",
    get: function get() {
      return 0;
    }
  }, {
    key: "numAccountKeysFromLookups",
    get: function get() {
      var count = 0;
      var _iterator = _createForOfIteratorHelper$3(this.addressTableLookups),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var lookup = _step.value;
          count += lookup.readonlyIndexes.length + lookup.writableIndexes.length;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return count;
    }
  }, {
    key: "getAccountKeys",
    value: function getAccountKeys(args) {
      var accountKeysFromLookups;
      if (args && 'accountKeysFromLookups' in args && args.accountKeysFromLookups) {
        if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) {
          throw new Error('Failed to get account keys because of a mismatch in the number of account keys from lookups');
        }
        accountKeysFromLookups = args.accountKeysFromLookups;
      } else if (args && 'addressLookupTableAccounts' in args && args.addressLookupTableAccounts) {
        accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);
      } else if (this.addressTableLookups.length > 0) {
        throw new Error('Failed to get account keys because address table lookups were not resolved');
      }
      return new MessageAccountKeys(this.staticAccountKeys, accountKeysFromLookups);
    }
  }, {
    key: "isAccountSigner",
    value: function isAccountSigner(index) {
      return index < this.header.numRequiredSignatures;
    }
  }, {
    key: "isAccountWritable",
    value: function isAccountWritable(index) {
      var numSignedAccounts = this.header.numRequiredSignatures;
      var numStaticAccountKeys = this.staticAccountKeys.length;
      if (index >= numStaticAccountKeys) {
        var lookupAccountKeysIndex = index - numStaticAccountKeys;
        var numWritableLookupAccountKeys = this.addressTableLookups.reduce(function (count, lookup) {
          return count + lookup.writableIndexes.length;
        }, 0);
        return lookupAccountKeysIndex < numWritableLookupAccountKeys;
      } else if (index >= this.header.numRequiredSignatures) {
        var unsignedAccountIndex = index - numSignedAccounts;
        var numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;
        var numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
        return unsignedAccountIndex < numWritableUnsignedAccounts;
      } else {
        var numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
        return index < numWritableSignedAccounts;
      }
    }
  }, {
    key: "resolveAddressTableLookups",
    value: function resolveAddressTableLookups(addressLookupTableAccounts) {
      var accountKeysFromLookups = {
        writable: [],
        readonly: []
      };
      var _iterator2 = _createForOfIteratorHelper$3(this.addressTableLookups),
        _step2;
      try {
        var _loop = function _loop() {
          var tableLookup = _step2.value;
          var tableAccount = addressLookupTableAccounts.find(function (account) {
            return account.key.equals(tableLookup.accountKey);
          });
          if (!tableAccount) {
            throw new Error("Failed to find address lookup table account for table key ".concat(tableLookup.accountKey.toBase58()));
          }
          var _iterator3 = _createForOfIteratorHelper$3(tableLookup.writableIndexes),
            _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var index = _step3.value;
              if (index < tableAccount.state.addresses.length) {
                accountKeysFromLookups.writable.push(tableAccount.state.addresses[index]);
              } else {
                throw new Error("Failed to find address for index ".concat(index, " in address lookup table ").concat(tableLookup.accountKey.toBase58()));
              }
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
          var _iterator4 = _createForOfIteratorHelper$3(tableLookup.readonlyIndexes),
            _step4;
          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var _index = _step4.value;
              if (_index < tableAccount.state.addresses.length) {
                accountKeysFromLookups.readonly.push(tableAccount.state.addresses[_index]);
              } else {
                throw new Error("Failed to find address for index ".concat(_index, " in address lookup table ").concat(tableLookup.accountKey.toBase58()));
              }
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
        };
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          _loop();
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return accountKeysFromLookups;
    }
  }, {
    key: "serialize",
    value: function serialize() {
      var encodedStaticAccountKeysLength = Array();
      encodeLength(encodedStaticAccountKeysLength, this.staticAccountKeys.length);
      var serializedInstructions = this.serializeInstructions();
      var encodedInstructionsLength = Array();
      encodeLength(encodedInstructionsLength, this.compiledInstructions.length);
      var serializedAddressTableLookups = this.serializeAddressTableLookups();
      var encodedAddressTableLookupsLength = Array();
      encodeLength(encodedAddressTableLookupsLength, this.addressTableLookups.length);
      var messageLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__.u8('prefix'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__.u8('numRequiredSignatures'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__.u8('numReadonlySignedAccounts'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__.u8('numReadonlyUnsignedAccounts')], 'header'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .blob */ .Ik(encodedStaticAccountKeysLength.length, 'staticAccountKeysLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .seq */ .A9(publicKey(), this.staticAccountKeys.length, 'staticAccountKeys'), publicKey('recentBlockhash'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .blob */ .Ik(encodedInstructionsLength.length, 'instructionsLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .blob */ .Ik(serializedInstructions.length, 'serializedInstructions'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .blob */ .Ik(encodedAddressTableLookupsLength.length, 'addressTableLookupsLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .blob */ .Ik(serializedAddressTableLookups.length, 'serializedAddressTableLookups')]);
      var serializedMessage = new Uint8Array(PACKET_DATA_SIZE);
      var MESSAGE_VERSION_0_PREFIX = 1 << 7;
      var serializedMessageLength = messageLayout.encode({
        prefix: MESSAGE_VERSION_0_PREFIX,
        header: this.header,
        staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),
        staticAccountKeys: this.staticAccountKeys.map(function (key) {
          return key.toBytes();
        }),
        recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_3___default().decode(this.recentBlockhash),
        instructionsLength: new Uint8Array(encodedInstructionsLength),
        serializedInstructions: serializedInstructions,
        addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),
        serializedAddressTableLookups: serializedAddressTableLookups
      }, serializedMessage);
      return serializedMessage.slice(0, serializedMessageLength);
    }
  }, {
    key: "serializeInstructions",
    value: function serializeInstructions() {
      var serializedLength = 0;
      var serializedInstructions = new Uint8Array(PACKET_DATA_SIZE);
      var _iterator5 = _createForOfIteratorHelper$3(this.compiledInstructions),
        _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var instruction = _step5.value;
          var encodedAccountKeyIndexesLength = Array();
          encodeLength(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);
          var encodedDataLength = Array();
          encodeLength(encodedDataLength, instruction.data.length);
          var instructionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__.u8('programIdIndex'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .blob */ .Ik(encodedAccountKeyIndexesLength.length, 'encodedAccountKeyIndexesLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .seq */ .A9(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__.u8(), instruction.accountKeyIndexes.length, 'accountKeyIndexes'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .blob */ .Ik(encodedDataLength.length, 'encodedDataLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .blob */ .Ik(instruction.data.length, 'data')]);
          serializedLength += instructionLayout.encode({
            programIdIndex: instruction.programIdIndex,
            encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),
            accountKeyIndexes: instruction.accountKeyIndexes,
            encodedDataLength: new Uint8Array(encodedDataLength),
            data: instruction.data
          }, serializedInstructions, serializedLength);
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
      return serializedInstructions.slice(0, serializedLength);
    }
  }, {
    key: "serializeAddressTableLookups",
    value: function serializeAddressTableLookups() {
      var serializedLength = 0;
      var serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE);
      var _iterator6 = _createForOfIteratorHelper$3(this.addressTableLookups),
        _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var lookup = _step6.value;
          var encodedWritableIndexesLength = Array();
          encodeLength(encodedWritableIndexesLength, lookup.writableIndexes.length);
          var encodedReadonlyIndexesLength = Array();
          encodeLength(encodedReadonlyIndexesLength, lookup.readonlyIndexes.length);
          var addressTableLookupLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([publicKey('accountKey'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .blob */ .Ik(encodedWritableIndexesLength.length, 'encodedWritableIndexesLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .seq */ .A9(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__.u8(), lookup.writableIndexes.length, 'writableIndexes'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .blob */ .Ik(encodedReadonlyIndexesLength.length, 'encodedReadonlyIndexesLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .seq */ .A9(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__.u8(), lookup.readonlyIndexes.length, 'readonlyIndexes')]);
          serializedLength += addressTableLookupLayout.encode({
            accountKey: lookup.accountKey.toBytes(),
            encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),
            writableIndexes: lookup.writableIndexes,
            encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),
            readonlyIndexes: lookup.readonlyIndexes
          }, serializedAddressTableLookups, serializedLength);
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
      return serializedAddressTableLookups.slice(0, serializedLength);
    }
  }], [{
    key: "compile",
    value: function compile(args) {
      var compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
      var addressTableLookups = new Array();
      var accountKeysFromLookups = {
        writable: new Array(),
        readonly: new Array()
      };
      var lookupTableAccounts = args.addressLookupTableAccounts || [];
      var _iterator7 = _createForOfIteratorHelper$3(lookupTableAccounts),
        _step7;
      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var lookupTable = _step7.value;
          var extractResult = compiledKeys.extractTableLookup(lookupTable);
          if (extractResult !== undefined) {
            var _accountKeysFromLooku, _accountKeysFromLooku2;
            var _extractResult = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(extractResult, 2),
              addressTableLookup = _extractResult[0],
              _extractResult$ = _extractResult[1],
              writable = _extractResult$.writable,
              readonly = _extractResult$.readonly;
            addressTableLookups.push(addressTableLookup);
            (_accountKeysFromLooku = accountKeysFromLookups.writable).push.apply(_accountKeysFromLooku, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_19__/* ["default"] */ .Z)(writable));
            (_accountKeysFromLooku2 = accountKeysFromLookups.readonly).push.apply(_accountKeysFromLooku2, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_19__/* ["default"] */ .Z)(readonly));
          }
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }
      var _compiledKeys$getMess = compiledKeys.getMessageComponents(),
        _compiledKeys$getMess2 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(_compiledKeys$getMess, 2),
        header = _compiledKeys$getMess2[0],
        staticAccountKeys = _compiledKeys$getMess2[1];
      var accountKeys = new MessageAccountKeys(staticAccountKeys, accountKeysFromLookups);
      var compiledInstructions = accountKeys.compileInstructions(args.instructions);
      return new MessageV0({
        header: header,
        staticAccountKeys: staticAccountKeys,
        recentBlockhash: args.recentBlockhash,
        compiledInstructions: compiledInstructions,
        addressTableLookups: addressTableLookups
      });
    }
  }, {
    key: "deserialize",
    value: function deserialize(serializedMessage) {
      var byteArray = (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_19__/* ["default"] */ .Z)(serializedMessage);
      var prefix = byteArray.shift();
      var maskedPrefix = prefix & VERSION_PREFIX_MASK;
      assert(prefix !== maskedPrefix, "Expected versioned message but received legacy message");
      var version = maskedPrefix;
      assert(version === 0, "Expected versioned message with version 0 but found version ".concat(version));
      var header = {
        numRequiredSignatures: byteArray.shift(),
        numReadonlySignedAccounts: byteArray.shift(),
        numReadonlyUnsignedAccounts: byteArray.shift()
      };
      var staticAccountKeys = [];
      var staticAccountKeysLength = decodeLength(byteArray);
      for (var i = 0; i < staticAccountKeysLength; i++) {
        staticAccountKeys.push(new PublicKey(byteArray.splice(0, PUBLIC_KEY_LENGTH)));
      }
      var recentBlockhash = bs58__WEBPACK_IMPORTED_MODULE_3___default().encode(byteArray.splice(0, PUBLIC_KEY_LENGTH));
      var instructionCount = decodeLength(byteArray);
      var compiledInstructions = [];
      for (var _i = 0; _i < instructionCount; _i++) {
        var programIdIndex = byteArray.shift();
        var accountKeyIndexesLength = decodeLength(byteArray);
        var accountKeyIndexes = byteArray.splice(0, accountKeyIndexesLength);
        var dataLength = decodeLength(byteArray);
        var data = new Uint8Array(byteArray.splice(0, dataLength));
        compiledInstructions.push({
          programIdIndex: programIdIndex,
          accountKeyIndexes: accountKeyIndexes,
          data: data
        });
      }
      var addressTableLookupsCount = decodeLength(byteArray);
      var addressTableLookups = [];
      for (var _i2 = 0; _i2 < addressTableLookupsCount; _i2++) {
        var accountKey = new PublicKey(byteArray.splice(0, PUBLIC_KEY_LENGTH));
        var writableIndexesLength = decodeLength(byteArray);
        var writableIndexes = byteArray.splice(0, writableIndexesLength);
        var readonlyIndexesLength = decodeLength(byteArray);
        var readonlyIndexes = byteArray.splice(0, readonlyIndexesLength);
        addressTableLookups.push({
          accountKey: accountKey,
          writableIndexes: writableIndexes,
          readonlyIndexes: readonlyIndexes
        });
      }
      return new MessageV0({
        header: header,
        staticAccountKeys: staticAccountKeys,
        recentBlockhash: recentBlockhash,
        compiledInstructions: compiledInstructions,
        addressTableLookups: addressTableLookups
      });
    }
  }]);
  return MessageV0;
}();

// eslint-disable-next-line no-redeclare
var VersionedMessage = {
  deserializeMessageVersion: function deserializeMessageVersion(serializedMessage) {
    var prefix = serializedMessage[0];
    var maskedPrefix = prefix & VERSION_PREFIX_MASK;

    // if the highest bit of the prefix is not set, the message is not versioned
    if (maskedPrefix === prefix) {
      return 'legacy';
    }

    // the lower 7 bits of the prefix indicate the message version
    return maskedPrefix;
  },
  deserialize: function deserialize(serializedMessage) {
    var version = VersionedMessage.deserializeMessageVersion(serializedMessage);
    if (version === 'legacy') {
      return Message.from(serializedMessage);
    }
    if (version === 0) {
      return MessageV0.deserialize(serializedMessage);
    } else {
      throw new Error("Transaction message version ".concat(version, " deserialization is not supported"));
    }
  }
};

function _createForOfIteratorHelper$2(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray$2(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$2(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }
function _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_21__/* ["default"] */ .Z)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

/**
 * Transaction signature as base-58 encoded string
 */

var TransactionStatus = /*#__PURE__*/function (TransactionStatus) {
  TransactionStatus[TransactionStatus["BLOCKHEIGHT_EXCEEDED"] = 0] = "BLOCKHEIGHT_EXCEEDED";
  TransactionStatus[TransactionStatus["PROCESSED"] = 1] = "PROCESSED";
  TransactionStatus[TransactionStatus["TIMED_OUT"] = 2] = "TIMED_OUT";
  TransactionStatus[TransactionStatus["NONCE_INVALID"] = 3] = "NONCE_INVALID";
  return TransactionStatus;
}({});

/**
 * Default (empty) signature
 */
var DEFAULT_SIGNATURE = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);

/**
 * Account metadata used to define instructions
 */

/**
 * List of TransactionInstruction object fields that may be initialized at construction
 */

/**
 * Configuration object for Transaction.serialize()
 */

/**
 * @internal
 */

/**
 * Transaction Instruction class
 */
var TransactionInstruction = /*#__PURE__*/function () {
  function TransactionInstruction(opts) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, TransactionInstruction);
    /**
     * Public keys to include in this transaction
     * Boolean represents whether this pubkey needs to sign the transaction
     */
    this.keys = void 0;
    /**
     * Program Id to execute
     */
    this.programId = void 0;
    /**
     * Program input
     */
    this.data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(0);
    this.programId = opts.programId;
    this.keys = opts.keys;
    if (opts.data) {
      this.data = opts.data;
    }
  }

  /**
   * @internal
   */
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(TransactionInstruction, [{
    key: "toJSON",
    value: function toJSON() {
      return {
        keys: this.keys.map(function (_ref) {
          var pubkey = _ref.pubkey,
            isSigner = _ref.isSigner,
            isWritable = _ref.isWritable;
          return {
            pubkey: pubkey.toJSON(),
            isSigner: isSigner,
            isWritable: isWritable
          };
        }),
        programId: this.programId.toJSON(),
        data: (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_19__/* ["default"] */ .Z)(this.data)
      };
    }
  }]);
  return TransactionInstruction;
}();

/**
 * Pair of signature and corresponding public key
 */

/**
 * List of Transaction object fields that may be initialized at construction
 */

// For backward compatibility; an unfortunate consequence of being
// forced to over-export types by the documentation generator.
// See https://github.com/solana-labs/solana/pull/25820
/**
 * Blockhash-based transactions have a lifetime that are defined by
 * the blockhash they include. Any transaction whose blockhash is
 * too old will be rejected.
 */
/**
 * Use these options to construct a durable nonce transaction.
 */
/**
 * Nonce information to be used to build an offline Transaction.
 */
/**
 * @internal
 */
/**
 * Transaction class
 */
var Transaction = /*#__PURE__*/function () {
  /**
   * Construct an empty Transaction
   */
  function Transaction(opts) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, Transaction);
    /**
     * Signatures for the transaction.  Typically created by invoking the
     * `sign()` method
     */
    this.signatures = [];
    /**
     * The transaction fee payer
     */
    this.feePayer = void 0;
    /**
     * The instructions to atomically execute
     */
    this.instructions = [];
    /**
     * A recent transaction id. Must be populated by the caller
     */
    this.recentBlockhash = void 0;
    /**
     * the last block chain can advance to before tx is declared expired
     * */
    this.lastValidBlockHeight = void 0;
    /**
     * Optional Nonce information. If populated, transaction will use a durable
     * Nonce hash instead of a recentBlockhash. Must be populated by the caller
     */
    this.nonceInfo = void 0;
    /**
     * If this is a nonce transaction this represents the minimum slot from which
     * to evaluate if the nonce has advanced when attempting to confirm the
     * transaction. This protects against a case where the transaction confirmation
     * logic loads the nonce account from an old slot and assumes the mismatch in
     * nonce value implies that the nonce has been advanced.
     */
    this.minNonceContextSlot = void 0;
    /**
     * @internal
     */
    this._message = void 0;
    /**
     * @internal
     */
    this._json = void 0;
    if (!opts) {
      return;
    }
    if (opts.feePayer) {
      this.feePayer = opts.feePayer;
    }
    if (opts.signatures) {
      this.signatures = opts.signatures;
    }
    if (Object.prototype.hasOwnProperty.call(opts, 'nonceInfo')) {
      var _ref2 = opts,
        minContextSlot = _ref2.minContextSlot,
        nonceInfo = _ref2.nonceInfo;
      this.minNonceContextSlot = minContextSlot;
      this.nonceInfo = nonceInfo;
    } else if (Object.prototype.hasOwnProperty.call(opts, 'lastValidBlockHeight')) {
      var _ref3 = opts,
        blockhash = _ref3.blockhash,
        lastValidBlockHeight = _ref3.lastValidBlockHeight;
      this.recentBlockhash = blockhash;
      this.lastValidBlockHeight = lastValidBlockHeight;
    } else {
      var _ref4 = opts,
        recentBlockhash = _ref4.recentBlockhash,
        _nonceInfo = _ref4.nonceInfo;
      if (_nonceInfo) {
        this.nonceInfo = _nonceInfo;
      }
      this.recentBlockhash = recentBlockhash;
    }
  }

  /**
   * @internal
   */
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(Transaction, [{
    key: "signature",
    get:
    /**
     * The first (payer) Transaction signature
     *
     * @returns {Buffer | null} Buffer of payer's signature
     */
    function get() {
      if (this.signatures.length > 0) {
        return this.signatures[0].signature;
      }
      return null;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        recentBlockhash: this.recentBlockhash || null,
        feePayer: this.feePayer ? this.feePayer.toJSON() : null,
        nonceInfo: this.nonceInfo ? {
          nonce: this.nonceInfo.nonce,
          nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
        } : null,
        instructions: this.instructions.map(function (instruction) {
          return instruction.toJSON();
        }),
        signers: this.signatures.map(function (_ref5) {
          var publicKey = _ref5.publicKey;
          return publicKey.toJSON();
        })
      };
    }

    /**
     * Add one or more instructions to this Transaction
     *
     * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction
     */
  }, {
    key: "add",
    value: function add() {
      var _this = this;
      for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {
        items[_key] = arguments[_key];
      }
      if (items.length === 0) {
        throw new Error('No instructions');
      }
      items.forEach(function (item) {
        if ('instructions' in item) {
          _this.instructions = _this.instructions.concat(item.instructions);
        } else if ('data' in item && 'programId' in item && 'keys' in item) {
          _this.instructions.push(item);
        } else {
          _this.instructions.push(new TransactionInstruction(item));
        }
      });
      return this;
    }

    /**
     * Compile transaction data
     */
  }, {
    key: "compileMessage",
    value: function compileMessage() {
      if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {
        return this._message;
      }
      var recentBlockhash;
      var instructions;
      if (this.nonceInfo) {
        recentBlockhash = this.nonceInfo.nonce;
        if (this.instructions[0] != this.nonceInfo.nonceInstruction) {
          instructions = [this.nonceInfo.nonceInstruction].concat((0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_19__/* ["default"] */ .Z)(this.instructions));
        } else {
          instructions = this.instructions;
        }
      } else {
        recentBlockhash = this.recentBlockhash;
        instructions = this.instructions;
      }
      if (!recentBlockhash) {
        throw new Error('Transaction recentBlockhash required');
      }
      if (instructions.length < 1) {
        console.warn('No instructions provided');
      }
      var feePayer;
      if (this.feePayer) {
        feePayer = this.feePayer;
      } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {
        // Use implicit fee payer
        feePayer = this.signatures[0].publicKey;
      } else {
        throw new Error('Transaction fee payer required');
      }
      for (var i = 0; i < instructions.length; i++) {
        if (instructions[i].programId === undefined) {
          throw new Error("Transaction instruction index ".concat(i, " has undefined program id"));
        }
      }
      var programIds = [];
      var accountMetas = [];
      instructions.forEach(function (instruction) {
        instruction.keys.forEach(function (accountMeta) {
          accountMetas.push(_objectSpread$2({}, accountMeta));
        });
        var programId = instruction.programId.toString();
        if (!programIds.includes(programId)) {
          programIds.push(programId);
        }
      });

      // Append programID account metas
      programIds.forEach(function (programId) {
        accountMetas.push({
          pubkey: new PublicKey(programId),
          isSigner: false,
          isWritable: false
        });
      });

      // Cull duplicate account metas
      var uniqueMetas = [];
      accountMetas.forEach(function (accountMeta) {
        var pubkeyString = accountMeta.pubkey.toString();
        var uniqueIndex = uniqueMetas.findIndex(function (x) {
          return x.pubkey.toString() === pubkeyString;
        });
        if (uniqueIndex > -1) {
          uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;
          uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;
        } else {
          uniqueMetas.push(accountMeta);
        }
      });

      // Sort. Prioritizing first by signer, then by writable
      uniqueMetas.sort(function (x, y) {
        if (x.isSigner !== y.isSigner) {
          // Signers always come before non-signers
          return x.isSigner ? -1 : 1;
        }
        if (x.isWritable !== y.isWritable) {
          // Writable accounts always come before read-only accounts
          return x.isWritable ? -1 : 1;
        }
        // Otherwise, sort by pubkey, stringwise.
        var options = {
          localeMatcher: 'best fit',
          usage: 'sort',
          sensitivity: 'variant',
          ignorePunctuation: false,
          numeric: false,
          caseFirst: 'lower'
        };
        return x.pubkey.toBase58().localeCompare(y.pubkey.toBase58(), 'en', options);
      });

      // Move fee payer to the front
      var feePayerIndex = uniqueMetas.findIndex(function (x) {
        return x.pubkey.equals(feePayer);
      });
      if (feePayerIndex > -1) {
        var _uniqueMetas$splice = uniqueMetas.splice(feePayerIndex, 1),
          _uniqueMetas$splice2 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(_uniqueMetas$splice, 1),
          payerMeta = _uniqueMetas$splice2[0];
        payerMeta.isSigner = true;
        payerMeta.isWritable = true;
        uniqueMetas.unshift(payerMeta);
      } else {
        uniqueMetas.unshift({
          pubkey: feePayer,
          isSigner: true,
          isWritable: true
        });
      }

      // Disallow unknown signers
      var _iterator = _createForOfIteratorHelper$2(this.signatures),
        _step;
      try {
        var _loop = function _loop() {
          var signature = _step.value;
          var uniqueIndex = uniqueMetas.findIndex(function (x) {
            return x.pubkey.equals(signature.publicKey);
          });
          if (uniqueIndex > -1) {
            if (!uniqueMetas[uniqueIndex].isSigner) {
              uniqueMetas[uniqueIndex].isSigner = true;
              console.warn('Transaction references a signature that is unnecessary, ' + 'only the fee payer and instruction signer accounts should sign a transaction. ' + 'This behavior is deprecated and will throw an error in the next major version release.');
            }
          } else {
            throw new Error("unknown signer: ".concat(signature.publicKey.toString()));
          }
        };
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          _loop();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      var numRequiredSignatures = 0;
      var numReadonlySignedAccounts = 0;
      var numReadonlyUnsignedAccounts = 0;

      // Split out signing from non-signing keys and count header values
      var signedKeys = [];
      var unsignedKeys = [];
      uniqueMetas.forEach(function (_ref6) {
        var pubkey = _ref6.pubkey,
          isSigner = _ref6.isSigner,
          isWritable = _ref6.isWritable;
        if (isSigner) {
          signedKeys.push(pubkey.toString());
          numRequiredSignatures += 1;
          if (!isWritable) {
            numReadonlySignedAccounts += 1;
          }
        } else {
          unsignedKeys.push(pubkey.toString());
          if (!isWritable) {
            numReadonlyUnsignedAccounts += 1;
          }
        }
      });
      var accountKeys = signedKeys.concat(unsignedKeys);
      var compiledInstructions = instructions.map(function (instruction) {
        var data = instruction.data,
          programId = instruction.programId;
        return {
          programIdIndex: accountKeys.indexOf(programId.toString()),
          accounts: instruction.keys.map(function (meta) {
            return accountKeys.indexOf(meta.pubkey.toString());
          }),
          data: bs58__WEBPACK_IMPORTED_MODULE_3___default().encode(data)
        };
      });
      compiledInstructions.forEach(function (instruction) {
        assert(instruction.programIdIndex >= 0);
        instruction.accounts.forEach(function (keyIndex) {
          return assert(keyIndex >= 0);
        });
      });
      return new Message({
        header: {
          numRequiredSignatures: numRequiredSignatures,
          numReadonlySignedAccounts: numReadonlySignedAccounts,
          numReadonlyUnsignedAccounts: numReadonlyUnsignedAccounts
        },
        accountKeys: accountKeys,
        recentBlockhash: recentBlockhash,
        instructions: compiledInstructions
      });
    }

    /**
     * @internal
     */
  }, {
    key: "_compile",
    value: function _compile() {
      var message = this.compileMessage();
      var signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);
      if (this.signatures.length === signedKeys.length) {
        var valid = this.signatures.every(function (pair, index) {
          return signedKeys[index].equals(pair.publicKey);
        });
        if (valid) return message;
      }
      this.signatures = signedKeys.map(function (publicKey) {
        return {
          signature: null,
          publicKey: publicKey
        };
      });
      return message;
    }

    /**
     * Get a buffer of the Transaction data that need to be covered by signatures
     */
  }, {
    key: "serializeMessage",
    value: function serializeMessage() {
      return this._compile().serialize();
    }

    /**
     * Get the estimated fee associated with a transaction
     *
     * @param {Connection} connection Connection to RPC Endpoint.
     *
     * @returns {Promise<number | null>} The estimated fee for the transaction
     */
  }, {
    key: "getEstimatedFee",
    value: function () {
      var _getEstimatedFee = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee(connection) {
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return connection.getFeeForMessage(this.compileMessage());
            case 2:
              return _context.abrupt("return", _context.sent.value);
            case 3:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getEstimatedFee(_x) {
        return _getEstimatedFee.apply(this, arguments);
      }
      return getEstimatedFee;
    }()
    /**
     * Specify the public keys which will be used to sign the Transaction.
     * The first signer will be used as the transaction fee payer account.
     *
     * Signatures can be added with either `partialSign` or `addSignature`
     *
     * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be
     * specified and it can be set in the Transaction constructor or with the
     * `feePayer` property.
     */
  }, {
    key: "setSigners",
    value: function setSigners() {
      for (var _len2 = arguments.length, signers = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        signers[_key2] = arguments[_key2];
      }
      if (signers.length === 0) {
        throw new Error('No signers');
      }
      var seen = new Set();
      this.signatures = signers.filter(function (publicKey) {
        var key = publicKey.toString();
        if (seen.has(key)) {
          return false;
        } else {
          seen.add(key);
          return true;
        }
      }).map(function (publicKey) {
        return {
          signature: null,
          publicKey: publicKey
        };
      });
    }

    /**
     * Sign the Transaction with the specified signers. Multiple signatures may
     * be applied to a Transaction. The first signature is considered "primary"
     * and is used identify and confirm transactions.
     *
     * If the Transaction `feePayer` is not set, the first signer will be used
     * as the transaction fee payer account.
     *
     * Transaction fields should not be modified after the first call to `sign`,
     * as doing so may invalidate the signature and cause the Transaction to be
     * rejected.
     *
     * The Transaction must be assigned a valid `recentBlockhash` before invoking this method
     *
     * @param {Array<Signer>} signers Array of signers that will sign the transaction
     */
  }, {
    key: "sign",
    value: function sign() {
      for (var _len3 = arguments.length, signers = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        signers[_key3] = arguments[_key3];
      }
      if (signers.length === 0) {
        throw new Error('No signers');
      }

      // Dedupe signers
      var seen = new Set();
      var uniqueSigners = [];
      for (var _i = 0, _signers = signers; _i < _signers.length; _i++) {
        var signer = _signers[_i];
        var key = signer.publicKey.toString();
        if (seen.has(key)) {
          continue;
        } else {
          seen.add(key);
          uniqueSigners.push(signer);
        }
      }
      this.signatures = uniqueSigners.map(function (signer) {
        return {
          signature: null,
          publicKey: signer.publicKey
        };
      });
      var message = this._compile();
      this._partialSign.apply(this, [message].concat(uniqueSigners));
    }

    /**
     * Partially sign a transaction with the specified accounts. All accounts must
     * correspond to either the fee payer or a signer account in the transaction
     * instructions.
     *
     * All the caveats from the `sign` method apply to `partialSign`
     *
     * @param {Array<Signer>} signers Array of signers that will sign the transaction
     */
  }, {
    key: "partialSign",
    value: function partialSign() {
      for (var _len4 = arguments.length, signers = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        signers[_key4] = arguments[_key4];
      }
      if (signers.length === 0) {
        throw new Error('No signers');
      }

      // Dedupe signers
      var seen = new Set();
      var uniqueSigners = [];
      for (var _i2 = 0, _signers2 = signers; _i2 < _signers2.length; _i2++) {
        var signer = _signers2[_i2];
        var key = signer.publicKey.toString();
        if (seen.has(key)) {
          continue;
        } else {
          seen.add(key);
          uniqueSigners.push(signer);
        }
      }
      var message = this._compile();
      this._partialSign.apply(this, [message].concat(uniqueSigners));
    }

    /**
     * @internal
     */
  }, {
    key: "_partialSign",
    value: function _partialSign(message) {
      var _this2 = this;
      var signData = message.serialize();
      for (var _len5 = arguments.length, signers = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
        signers[_key5 - 1] = arguments[_key5];
      }
      signers.forEach(function (signer) {
        var signature = sign(signData, signer.secretKey);
        _this2._addSignature(signer.publicKey, toBuffer(signature));
      });
    }

    /**
     * Add an externally created signature to a transaction. The public key
     * must correspond to either the fee payer or a signer account in the transaction
     * instructions.
     *
     * @param {PublicKey} pubkey Public key that will be added to the transaction.
     * @param {Buffer} signature An externally created signature to add to the transaction.
     */
  }, {
    key: "addSignature",
    value: function addSignature(pubkey, signature) {
      this._compile(); // Ensure signatures array is populated
      this._addSignature(pubkey, signature);
    }

    /**
     * @internal
     */
  }, {
    key: "_addSignature",
    value: function _addSignature(pubkey, signature) {
      assert(signature.length === 64);
      var index = this.signatures.findIndex(function (sigpair) {
        return pubkey.equals(sigpair.publicKey);
      });
      if (index < 0) {
        throw new Error("unknown signer: ".concat(pubkey.toString()));
      }
      this.signatures[index].signature = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signature);
    }

    /**
     * Verify signatures of a Transaction
     * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.
     * If no boolean is provided, we expect a fully signed Transaction by default.
     *
     * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction
     */
  }, {
    key: "verifySignatures",
    value: function verifySignatures(requireAllSignatures) {
      return this._verifySignatures(this.serializeMessage(), requireAllSignatures === undefined ? true : requireAllSignatures);
    }

    /**
     * @internal
     */
  }, {
    key: "_verifySignatures",
    value: function _verifySignatures(signData, requireAllSignatures) {
      var _iterator2 = _createForOfIteratorHelper$2(this.signatures),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _step2$value = _step2.value,
            signature = _step2$value.signature,
            publicKey = _step2$value.publicKey;
          if (signature === null) {
            if (requireAllSignatures) {
              return false;
            }
          } else {
            if (!verify(signature, signData, publicKey.toBytes())) {
              return false;
            }
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return true;
    }

    /**
     * Serialize the Transaction in the wire format.
     *
     * @param {Buffer} [config] Config of transaction.
     *
     * @returns {Buffer} Signature of transaction in wire format.
     */
  }, {
    key: "serialize",
    value: function serialize(config) {
      var _Object$assign = Object.assign({
          requireAllSignatures: true,
          verifySignatures: true
        }, config),
        requireAllSignatures = _Object$assign.requireAllSignatures,
        verifySignatures = _Object$assign.verifySignatures;
      var signData = this.serializeMessage();
      if (verifySignatures && !this._verifySignatures(signData, requireAllSignatures)) {
        throw new Error('Signature verification failed');
      }
      return this._serialize(signData);
    }

    /**
     * @internal
     */
  }, {
    key: "_serialize",
    value: function _serialize(signData) {
      var signatures = this.signatures;
      var signatureCount = [];
      encodeLength(signatureCount, signatures.length);
      var transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
      var wireTransaction = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(transactionLength);
      assert(signatures.length < 256);
      buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signatureCount).copy(wireTransaction, 0);
      signatures.forEach(function (_ref7, index) {
        var signature = _ref7.signature;
        if (signature !== null) {
          assert(signature.length === 64, "signature has invalid length");
          buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signature).copy(wireTransaction, signatureCount.length + index * 64);
        }
      });
      signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
      assert(wireTransaction.length <= PACKET_DATA_SIZE, "Transaction too large: ".concat(wireTransaction.length, " > ").concat(PACKET_DATA_SIZE));
      return wireTransaction;
    }

    /**
     * Deprecated method
     * @internal
     */
  }, {
    key: "keys",
    get: function get() {
      assert(this.instructions.length === 1);
      return this.instructions[0].keys.map(function (keyObj) {
        return keyObj.pubkey;
      });
    }

    /**
     * Deprecated method
     * @internal
     */
  }, {
    key: "programId",
    get: function get() {
      assert(this.instructions.length === 1);
      return this.instructions[0].programId;
    }

    /**
     * Deprecated method
     * @internal
     */
  }, {
    key: "data",
    get: function get() {
      assert(this.instructions.length === 1);
      return this.instructions[0].data;
    }

    /**
     * Parse a wire transaction into a Transaction object.
     *
     * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction
     *
     * @returns {Transaction} Transaction associated with the signature
     */
  }], [{
    key: "from",
    value: function from(buffer) {
      // Slice up wire data
      var byteArray = (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_19__/* ["default"] */ .Z)(buffer);
      var signatureCount = decodeLength(byteArray);
      var signatures = [];
      for (var i = 0; i < signatureCount; i++) {
        var signature = byteArray.slice(0, SIGNATURE_LENGTH_IN_BYTES);
        byteArray = byteArray.slice(SIGNATURE_LENGTH_IN_BYTES);
        signatures.push(bs58__WEBPACK_IMPORTED_MODULE_3___default().encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signature)));
      }
      return Transaction.populate(Message.from(byteArray), signatures);
    }

    /**
     * Populate Transaction object from message and signatures
     *
     * @param {Message} message Message of transaction
     * @param {Array<string>} signatures List of signatures to assign to the transaction
     *
     * @returns {Transaction} The populated Transaction
     */
  }, {
    key: "populate",
    value: function populate(message) {
      var signatures = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var transaction = new Transaction();
      transaction.recentBlockhash = message.recentBlockhash;
      if (message.header.numRequiredSignatures > 0) {
        transaction.feePayer = message.accountKeys[0];
      }
      signatures.forEach(function (signature, index) {
        var sigPubkeyPair = {
          signature: signature == bs58__WEBPACK_IMPORTED_MODULE_3___default().encode(DEFAULT_SIGNATURE) ? null : bs58__WEBPACK_IMPORTED_MODULE_3___default().decode(signature),
          publicKey: message.accountKeys[index]
        };
        transaction.signatures.push(sigPubkeyPair);
      });
      message.instructions.forEach(function (instruction) {
        var keys = instruction.accounts.map(function (account) {
          var pubkey = message.accountKeys[account];
          return {
            pubkey: pubkey,
            isSigner: transaction.signatures.some(function (keyObj) {
              return keyObj.publicKey.toString() === pubkey.toString();
            }) || message.isAccountSigner(account),
            isWritable: message.isAccountWritable(account)
          };
        });
        transaction.instructions.push(new TransactionInstruction({
          keys: keys,
          programId: message.accountKeys[instruction.programIdIndex],
          data: bs58__WEBPACK_IMPORTED_MODULE_3___default().decode(instruction.data)
        }));
      });
      transaction._message = message;
      transaction._json = transaction.toJSON();
      return transaction;
    }
  }]);
  return Transaction;
}();

function _createForOfIteratorHelper$1(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }
function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var TransactionMessage = /*#__PURE__*/function () {
  function TransactionMessage(args) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, TransactionMessage);
    this.payerKey = void 0;
    this.instructions = void 0;
    this.recentBlockhash = void 0;
    this.payerKey = args.payerKey;
    this.instructions = args.instructions;
    this.recentBlockhash = args.recentBlockhash;
  }
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(TransactionMessage, [{
    key: "compileToLegacyMessage",
    value: function compileToLegacyMessage() {
      return Message.compile({
        payerKey: this.payerKey,
        recentBlockhash: this.recentBlockhash,
        instructions: this.instructions
      });
    }
  }, {
    key: "compileToV0Message",
    value: function compileToV0Message(addressLookupTableAccounts) {
      return MessageV0.compile({
        payerKey: this.payerKey,
        recentBlockhash: this.recentBlockhash,
        instructions: this.instructions,
        addressLookupTableAccounts: addressLookupTableAccounts
      });
    }
  }], [{
    key: "decompile",
    value: function decompile(message, args) {
      var header = message.header,
        compiledInstructions = message.compiledInstructions,
        recentBlockhash = message.recentBlockhash;
      var numRequiredSignatures = header.numRequiredSignatures,
        numReadonlySignedAccounts = header.numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts = header.numReadonlyUnsignedAccounts;
      var numWritableSignedAccounts = numRequiredSignatures - numReadonlySignedAccounts;
      assert(numWritableSignedAccounts > 0, 'Message header is invalid');
      var numWritableUnsignedAccounts = message.staticAccountKeys.length - numRequiredSignatures - numReadonlyUnsignedAccounts;
      assert(numWritableUnsignedAccounts >= 0, 'Message header is invalid');
      var accountKeys = message.getAccountKeys(args);
      var payerKey = accountKeys.get(0);
      if (payerKey === undefined) {
        throw new Error('Failed to decompile message because no account keys were found');
      }
      var instructions = [];
      var _iterator = _createForOfIteratorHelper$1(compiledInstructions),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var compiledIx = _step.value;
          var keys = [];
          var _iterator2 = _createForOfIteratorHelper$1(compiledIx.accountKeyIndexes),
            _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var keyIndex = _step2.value;
              var pubkey = accountKeys.get(keyIndex);
              if (pubkey === undefined) {
                throw new Error("Failed to find key for account key index ".concat(keyIndex));
              }
              var isSigner = keyIndex < numRequiredSignatures;
              var isWritable = void 0;
              if (isSigner) {
                isWritable = keyIndex < numWritableSignedAccounts;
              } else if (keyIndex < accountKeys.staticAccountKeys.length) {
                isWritable = keyIndex - numRequiredSignatures < numWritableUnsignedAccounts;
              } else {
                isWritable = keyIndex - accountKeys.staticAccountKeys.length <
                // accountKeysFromLookups cannot be undefined because we already found a pubkey for this index above
                accountKeys.accountKeysFromLookups.writable.length;
              }
              keys.push({
                pubkey: pubkey,
                isSigner: keyIndex < header.numRequiredSignatures,
                isWritable: isWritable
              });
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          var programId = accountKeys.get(compiledIx.programIdIndex);
          if (programId === undefined) {
            throw new Error("Failed to find program id for program id index ".concat(compiledIx.programIdIndex));
          }
          instructions.push(new TransactionInstruction({
            programId: programId,
            data: toBuffer(compiledIx.data),
            keys: keys
          }));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return new TransactionMessage({
        payerKey: payerKey,
        instructions: instructions,
        recentBlockhash: recentBlockhash
      });
    }
  }]);
  return TransactionMessage;
}();

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
/**
 * Versioned transaction class
 */
var VersionedTransaction = /*#__PURE__*/function () {
  function VersionedTransaction(message, signatures) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, VersionedTransaction);
    this.signatures = void 0;
    this.message = void 0;
    if (signatures !== undefined) {
      assert(signatures.length === message.header.numRequiredSignatures, 'Expected signatures length to be equal to the number of required signatures');
      this.signatures = signatures;
    } else {
      var defaultSignatures = [];
      for (var i = 0; i < message.header.numRequiredSignatures; i++) {
        defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));
      }
      this.signatures = defaultSignatures;
    }
    this.message = message;
  }
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(VersionedTransaction, [{
    key: "version",
    get: function get() {
      return this.message.version;
    }
  }, {
    key: "serialize",
    value: function serialize() {
      var serializedMessage = this.message.serialize();
      var encodedSignaturesLength = Array();
      encodeLength(encodedSignaturesLength, this.signatures.length);
      var transactionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .blob */ .Ik(encodedSignaturesLength.length, 'encodedSignaturesLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .seq */ .A9(signature(), this.signatures.length, 'signatures'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .blob */ .Ik(serializedMessage.length, 'serializedMessage')]);
      var serializedTransaction = new Uint8Array(2048);
      var serializedTransactionLength = transactionLayout.encode({
        encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),
        signatures: this.signatures,
        serializedMessage: serializedMessage
      }, serializedTransaction);
      return serializedTransaction.slice(0, serializedTransactionLength);
    }
  }, {
    key: "sign",
    value: function sign$1(signers) {
      var _this = this;
      var messageData = this.message.serialize();
      var signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
      var _iterator = _createForOfIteratorHelper(signers),
        _step;
      try {
        var _loop = function _loop() {
          var signer = _step.value;
          var signerIndex = signerPubkeys.findIndex(function (pubkey) {
            return pubkey.equals(signer.publicKey);
          });
          assert(signerIndex >= 0, "Cannot sign with non signer key ".concat(signer.publicKey.toBase58()));
          _this.signatures[signerIndex] = sign(messageData, signer.secretKey);
        };
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          _loop();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "addSignature",
    value: function addSignature(publicKey, signature) {
      assert(signature.byteLength === 64, 'Signature must be 64 bytes long');
      var signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
      var signerIndex = signerPubkeys.findIndex(function (pubkey) {
        return pubkey.equals(publicKey);
      });
      assert(signerIndex >= 0, "Can not add signature; `".concat(publicKey.toBase58(), "` is not required to sign this transaction"));
      this.signatures[signerIndex] = signature;
    }
  }], [{
    key: "deserialize",
    value: function deserialize(serializedTransaction) {
      var byteArray = (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_19__/* ["default"] */ .Z)(serializedTransaction);
      var signatures = [];
      var signaturesLength = decodeLength(byteArray);
      for (var i = 0; i < signaturesLength; i++) {
        signatures.push(new Uint8Array(byteArray.splice(0, SIGNATURE_LENGTH_IN_BYTES)));
      }
      var message = VersionedMessage.deserialize(new Uint8Array(byteArray));
      return new VersionedTransaction(message, signatures);
    }
  }]);
  return VersionedTransaction;
}();

// TODO: These constants should be removed in favor of reading them out of a
// Syscall account

/**
 * @internal
 */
var NUM_TICKS_PER_SECOND = 160;

/**
 * @internal
 */
var DEFAULT_TICKS_PER_SLOT = 64;

/**
 * @internal
 */
var NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;

/**
 * @internal
 */
var MS_PER_SLOT = 1000 / NUM_SLOTS_PER_SECOND;

var SYSVAR_CLOCK_PUBKEY = new PublicKey('SysvarC1ock11111111111111111111111111111111');
var SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey('SysvarEpochSchedu1e111111111111111111111111');
var SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey('Sysvar1nstructions1111111111111111111111111');
var SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey('SysvarRecentB1ockHashes11111111111111111111');
var SYSVAR_RENT_PUBKEY = new PublicKey('SysvarRent111111111111111111111111111111111');
var SYSVAR_REWARDS_PUBKEY = new PublicKey('SysvarRewards111111111111111111111111111111');
var SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey('SysvarS1otHashes111111111111111111111111111');
var SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey('SysvarS1otHistory11111111111111111111111111');
var SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey('SysvarStakeHistory1111111111111111111111111');

/**
 * Sign, send and confirm a transaction.
 *
 * If `commitment` option is not specified, defaults to 'max' commitment.
 *
 * @param {Connection} connection
 * @param {Transaction} transaction
 * @param {Array<Signer>} signers
 * @param {ConfirmOptions} [options]
 * @returns {Promise<TransactionSignature>}
 */
function sendAndConfirmTransaction(_x, _x2, _x3, _x4) {
  return _sendAndConfirmTransaction.apply(this, arguments);
}
function _sendAndConfirmTransaction() {
  _sendAndConfirmTransaction = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee(connection, transaction, signers, options) {
    var sendOptions, signature, status, nonceInstruction, nonceAccountPubkey;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          sendOptions = options && {
            skipPreflight: options.skipPreflight,
            preflightCommitment: options.preflightCommitment || options.commitment,
            maxRetries: options.maxRetries,
            minContextSlot: options.minContextSlot
          };
          _context.next = 3;
          return connection.sendTransaction(transaction, signers, sendOptions);
        case 3:
          signature = _context.sent;
          if (!(transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null)) {
            _context.next = 10;
            break;
          }
          _context.next = 7;
          return connection.confirmTransaction({
            abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,
            signature: signature,
            blockhash: transaction.recentBlockhash,
            lastValidBlockHeight: transaction.lastValidBlockHeight
          }, options && options.commitment);
        case 7:
          status = _context.sent.value;
          _context.next = 22;
          break;
        case 10:
          if (!(transaction.minNonceContextSlot != null && transaction.nonceInfo != null)) {
            _context.next = 18;
            break;
          }
          nonceInstruction = transaction.nonceInfo.nonceInstruction;
          nonceAccountPubkey = nonceInstruction.keys[0].pubkey;
          _context.next = 15;
          return connection.confirmTransaction({
            abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,
            minContextSlot: transaction.minNonceContextSlot,
            nonceAccountPubkey: nonceAccountPubkey,
            nonceValue: transaction.nonceInfo.nonce,
            signature: signature
          }, options && options.commitment);
        case 15:
          status = _context.sent.value;
          _context.next = 22;
          break;
        case 18:
          if ((options === null || options === void 0 ? void 0 : options.abortSignal) != null) {
            console.warn('sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was ' + 'supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` ' + 'or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.');
          }
          _context.next = 21;
          return connection.confirmTransaction(signature, options && options.commitment);
        case 21:
          status = _context.sent.value;
        case 22:
          if (!status.err) {
            _context.next = 24;
            break;
          }
          throw new Error("Transaction ".concat(signature, " failed (").concat(JSON.stringify(status), ")"));
        case 24:
          return _context.abrupt("return", signature);
        case 25:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _sendAndConfirmTransaction.apply(this, arguments);
}

// zzz
function sleep(ms) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, ms);
  });
}

/**
 * @internal
 */

/**
 * Populate a buffer of instruction data using an InstructionType
 * @internal
 */
function encodeData(type, fields) {
  var allocLength = type.layout.span >= 0 ? type.layout.span : getAlloc(type, fields);
  var data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(allocLength);
  var layoutFields = Object.assign({
    instruction: type.index
  }, fields);
  type.layout.encode(layoutFields, data);
  return data;
}

/**
 * Decode instruction data buffer using an InstructionType
 * @internal
 */
function decodeData$1(type, buffer) {
  var data;
  try {
    data = type.layout.decode(buffer);
  } catch (err) {
    throw new Error('invalid instruction; ' + err);
  }
  if (data.instruction !== type.index) {
    throw new Error("invalid instruction; instruction index mismatch ".concat(data.instruction, " != ").concat(type.index));
  }
  return data;
}

/**
 * https://github.com/solana-labs/solana/blob/90bedd7e067b5b8f3ddbb45da00a4e9cabb22c62/sdk/src/fee_calculator.rs#L7-L11
 *
 * @internal
 */
var FeeCalculatorLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .nu64 */ ._O('lamportsPerSignature');

/**
 * Calculator for transaction fees.
 *
 * @deprecated Deprecated since Solana v1.8.0.
 */

/**
 * See https://github.com/solana-labs/solana/blob/0ea2843ec9cdc517572b8e62c959f41b55cf4453/sdk/src/nonce_state.rs#L29-L32
 *
 * @internal
 */
var NonceAccountLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('version'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('state'), publicKey('authorizedPubkey'), publicKey('nonce'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([FeeCalculatorLayout], 'feeCalculator')]);
var NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;

/**
 * A durable nonce is a 32 byte value encoded as a base58 string.
 */

/**
 * NonceAccount class
 */
var NonceAccount = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function NonceAccount(args) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, NonceAccount);
    this.authorizedPubkey = void 0;
    this.nonce = void 0;
    this.feeCalculator = void 0;
    this.authorizedPubkey = args.authorizedPubkey;
    this.nonce = args.nonce;
    this.feeCalculator = args.feeCalculator;
  }

  /**
   * Deserialize NonceAccount from the account data.
   *
   * @param buffer account data
   * @return NonceAccount
   */
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(NonceAccount, null, [{
    key: "fromAccountData",
    value: function fromAccountData(buffer) {
      var nonceAccount = NonceAccountLayout.decode(toBuffer(buffer), 0);
      return new NonceAccount({
        authorizedPubkey: new PublicKey(nonceAccount.authorizedPubkey),
        nonce: new PublicKey(nonceAccount.nonce).toString(),
        feeCalculator: nonceAccount.feeCalculator
      });
    }
  }]);
  return NonceAccount;
}();

var encodeDecode = function encodeDecode(layout) {
  var decode = layout.decode.bind(layout);
  var encode = layout.encode.bind(layout);
  return {
    decode: decode,
    encode: encode
  };
};
var bigInt = function bigInt(length) {
  return function (property) {
    var layout = (0,_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .blob */ .Ik)(length, property);
    var _encodeDecode = encodeDecode(layout),
      encode = _encodeDecode.encode,
      decode = _encodeDecode.decode;
    var bigIntLayout = layout;
    bigIntLayout.decode = function (buffer, offset) {
      var src = decode(buffer, offset);
      return (0,bigint_buffer__WEBPACK_IMPORTED_MODULE_6__/* .toBigIntLE */ .oU)(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(src));
    };
    bigIntLayout.encode = function (bigInt, buffer, offset) {
      var src = (0,bigint_buffer__WEBPACK_IMPORTED_MODULE_6__/* .toBufferLE */ .k$)(bigInt, length);
      return encode(src, buffer, offset);
    };
    return bigIntLayout;
  };
};
var u64 = bigInt(8);

/**
 * Create account system transaction params
 */

/**
 * Transfer system transaction params
 */

/**
 * Assign system transaction params
 */

/**
 * Create account with seed system transaction params
 */

/**
 * Create nonce account system transaction params
 */

/**
 * Create nonce account with seed system transaction params
 */

/**
 * Initialize nonce account system instruction params
 */

/**
 * Advance nonce account system instruction params
 */

/**
 * Withdraw nonce account system transaction params
 */

/**
 * Authorize nonce account system transaction params
 */

/**
 * Allocate account system transaction params
 */

/**
 * Allocate account with seed system transaction params
 */

/**
 * Assign account with seed system transaction params
 */

/**
 * Transfer with seed system transaction params
 */

/** Decoded transfer system transaction instruction */

/** Decoded transferWithSeed system transaction instruction */

/**
 * System Instruction class
 */
var SystemInstruction = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function SystemInstruction() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, SystemInstruction);
  }

  /**
   * Decode a system instruction and retrieve the instruction type.
   */
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(SystemInstruction, null, [{
    key: "decodeInstructionType",
    value: function decodeInstructionType(instruction) {
      this.checkProgramId(instruction.programId);
      var instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction');
      var typeIndex = instructionTypeLayout.decode(instruction.data);
      var type;
      for (var _i = 0, _Object$entries = Object.entries(SYSTEM_INSTRUCTION_LAYOUTS); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(_Object$entries[_i], 2),
          ixType = _Object$entries$_i[0],
          layout = _Object$entries$_i[1];
        if (layout.index == typeIndex) {
          type = ixType;
          break;
        }
      }
      if (!type) {
        throw new Error('Instruction type incorrect; not a SystemInstruction');
      }
      return type;
    }

    /**
     * Decode a create account system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeCreateAccount",
    value: function decodeCreateAccount(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 2);
      var _decodeData = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Create, instruction.data),
        lamports = _decodeData.lamports,
        space = _decodeData.space,
        programId = _decodeData.programId;
      return {
        fromPubkey: instruction.keys[0].pubkey,
        newAccountPubkey: instruction.keys[1].pubkey,
        lamports: lamports,
        space: space,
        programId: new PublicKey(programId)
      };
    }

    /**
     * Decode a transfer system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeTransfer",
    value: function decodeTransfer(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 2);
      var _decodeData2 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, instruction.data),
        lamports = _decodeData2.lamports;
      return {
        fromPubkey: instruction.keys[0].pubkey,
        toPubkey: instruction.keys[1].pubkey,
        lamports: lamports
      };
    }

    /**
     * Decode a transfer with seed system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeTransferWithSeed",
    value: function decodeTransferWithSeed(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      var _decodeData3 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, instruction.data),
        lamports = _decodeData3.lamports,
        seed = _decodeData3.seed,
        programId = _decodeData3.programId;
      return {
        fromPubkey: instruction.keys[0].pubkey,
        basePubkey: instruction.keys[1].pubkey,
        toPubkey: instruction.keys[2].pubkey,
        lamports: lamports,
        seed: seed,
        programId: new PublicKey(programId)
      };
    }

    /**
     * Decode an allocate system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeAllocate",
    value: function decodeAllocate(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 1);
      var _decodeData4 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, instruction.data),
        space = _decodeData4.space;
      return {
        accountPubkey: instruction.keys[0].pubkey,
        space: space
      };
    }

    /**
     * Decode an allocate with seed system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeAllocateWithSeed",
    value: function decodeAllocateWithSeed(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 1);
      var _decodeData5 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, instruction.data),
        base = _decodeData5.base,
        seed = _decodeData5.seed,
        space = _decodeData5.space,
        programId = _decodeData5.programId;
      return {
        accountPubkey: instruction.keys[0].pubkey,
        basePubkey: new PublicKey(base),
        seed: seed,
        space: space,
        programId: new PublicKey(programId)
      };
    }

    /**
     * Decode an assign system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeAssign",
    value: function decodeAssign(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 1);
      var _decodeData6 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Assign, instruction.data),
        programId = _decodeData6.programId;
      return {
        accountPubkey: instruction.keys[0].pubkey,
        programId: new PublicKey(programId)
      };
    }

    /**
     * Decode an assign with seed system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeAssignWithSeed",
    value: function decodeAssignWithSeed(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 1);
      var _decodeData7 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, instruction.data),
        base = _decodeData7.base,
        seed = _decodeData7.seed,
        programId = _decodeData7.programId;
      return {
        accountPubkey: instruction.keys[0].pubkey,
        basePubkey: new PublicKey(base),
        seed: seed,
        programId: new PublicKey(programId)
      };
    }

    /**
     * Decode a create account with seed system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeCreateWithSeed",
    value: function decodeCreateWithSeed(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 2);
      var _decodeData8 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, instruction.data),
        base = _decodeData8.base,
        seed = _decodeData8.seed,
        lamports = _decodeData8.lamports,
        space = _decodeData8.space,
        programId = _decodeData8.programId;
      return {
        fromPubkey: instruction.keys[0].pubkey,
        newAccountPubkey: instruction.keys[1].pubkey,
        basePubkey: new PublicKey(base),
        seed: seed,
        lamports: lamports,
        space: space,
        programId: new PublicKey(programId)
      };
    }

    /**
     * Decode a nonce initialize system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeNonceInitialize",
    value: function decodeNonceInitialize(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      var _decodeData9 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, instruction.data),
        authorized = _decodeData9.authorized;
      return {
        noncePubkey: instruction.keys[0].pubkey,
        authorizedPubkey: new PublicKey(authorized)
      };
    }

    /**
     * Decode a nonce advance system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeNonceAdvance",
    value: function decodeNonceAdvance(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, instruction.data);
      return {
        noncePubkey: instruction.keys[0].pubkey,
        authorizedPubkey: instruction.keys[2].pubkey
      };
    }

    /**
     * Decode a nonce withdraw system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeNonceWithdraw",
    value: function decodeNonceWithdraw(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 5);
      var _decodeData10 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, instruction.data),
        lamports = _decodeData10.lamports;
      return {
        noncePubkey: instruction.keys[0].pubkey,
        toPubkey: instruction.keys[1].pubkey,
        authorizedPubkey: instruction.keys[4].pubkey,
        lamports: lamports
      };
    }

    /**
     * Decode a nonce authorize system instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeNonceAuthorize",
    value: function decodeNonceAuthorize(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 2);
      var _decodeData11 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, instruction.data),
        authorized = _decodeData11.authorized;
      return {
        noncePubkey: instruction.keys[0].pubkey,
        authorizedPubkey: instruction.keys[1].pubkey,
        newAuthorizedPubkey: new PublicKey(authorized)
      };
    }

    /**
     * @internal
     */
  }, {
    key: "checkProgramId",
    value: function checkProgramId(programId) {
      if (!programId.equals(SystemProgram.programId)) {
        throw new Error('invalid instruction; programId is not SystemProgram');
      }
    }

    /**
     * @internal
     */
  }, {
    key: "checkKeyLength",
    value: function checkKeyLength(keys, expectedLength) {
      if (keys.length < expectedLength) {
        throw new Error("invalid instruction; found ".concat(keys.length, " keys, expected at least ").concat(expectedLength));
      }
    }
  }]);
  return SystemInstruction;
}();

/**
 * An enumeration of valid SystemInstructionType's
 */

/**
 * An enumeration of valid system InstructionType's
 * @internal
 */
var SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({
  Create: {
    index: 0,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .ns64 */ .gM('lamports'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .ns64 */ .gM('space'), publicKey('programId')])
  },
  Assign: {
    index: 1,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction'), publicKey('programId')])
  },
  Transfer: {
    index: 2,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction'), u64('lamports')])
  },
  CreateWithSeed: {
    index: 3,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction'), publicKey('base'), rustString('seed'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .ns64 */ .gM('lamports'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .ns64 */ .gM('space'), publicKey('programId')])
  },
  AdvanceNonceAccount: {
    index: 4,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction')])
  },
  WithdrawNonceAccount: {
    index: 5,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .ns64 */ .gM('lamports')])
  },
  InitializeNonceAccount: {
    index: 6,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction'), publicKey('authorized')])
  },
  AuthorizeNonceAccount: {
    index: 7,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction'), publicKey('authorized')])
  },
  Allocate: {
    index: 8,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .ns64 */ .gM('space')])
  },
  AllocateWithSeed: {
    index: 9,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction'), publicKey('base'), rustString('seed'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .ns64 */ .gM('space'), publicKey('programId')])
  },
  AssignWithSeed: {
    index: 10,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction'), publicKey('base'), rustString('seed'), publicKey('programId')])
  },
  TransferWithSeed: {
    index: 11,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction'), u64('lamports'), rustString('seed'), publicKey('programId')])
  },
  UpgradeNonceAccount: {
    index: 12,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction')])
  }
});

/**
 * Factory class for transactions to interact with the System program
 */
var SystemProgram = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function SystemProgram() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, SystemProgram);
  }

  /**
   * Public key that identifies the System program
   */
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(SystemProgram, null, [{
    key: "createAccount",
    value:
    /**
     * Generate a transaction instruction that creates a new account
     */
    function createAccount(params) {
      var type = SYSTEM_INSTRUCTION_LAYOUTS.Create;
      var data = encodeData(type, {
        lamports: params.lamports,
        space: params.space,
        programId: toBuffer(params.programId.toBuffer())
      });
      return new TransactionInstruction({
        keys: [{
          pubkey: params.fromPubkey,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: params.newAccountPubkey,
          isSigner: true,
          isWritable: true
        }],
        programId: this.programId,
        data: data
      });
    }

    /**
     * Generate a transaction instruction that transfers lamports from one account to another
     */
  }, {
    key: "transfer",
    value: function transfer(params) {
      var data;
      var keys;
      if ('basePubkey' in params) {
        var type = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;
        data = encodeData(type, {
          lamports: BigInt(params.lamports),
          seed: params.seed,
          programId: toBuffer(params.programId.toBuffer())
        });
        keys = [{
          pubkey: params.fromPubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.basePubkey,
          isSigner: true,
          isWritable: false
        }, {
          pubkey: params.toPubkey,
          isSigner: false,
          isWritable: true
        }];
      } else {
        var _type = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;
        data = encodeData(_type, {
          lamports: BigInt(params.lamports)
        });
        keys = [{
          pubkey: params.fromPubkey,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: params.toPubkey,
          isSigner: false,
          isWritable: true
        }];
      }
      return new TransactionInstruction({
        keys: keys,
        programId: this.programId,
        data: data
      });
    }

    /**
     * Generate a transaction instruction that assigns an account to a program
     */
  }, {
    key: "assign",
    value: function assign(params) {
      var data;
      var keys;
      if ('basePubkey' in params) {
        var type = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;
        data = encodeData(type, {
          base: toBuffer(params.basePubkey.toBuffer()),
          seed: params.seed,
          programId: toBuffer(params.programId.toBuffer())
        });
        keys = [{
          pubkey: params.accountPubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.basePubkey,
          isSigner: true,
          isWritable: false
        }];
      } else {
        var _type2 = SYSTEM_INSTRUCTION_LAYOUTS.Assign;
        data = encodeData(_type2, {
          programId: toBuffer(params.programId.toBuffer())
        });
        keys = [{
          pubkey: params.accountPubkey,
          isSigner: true,
          isWritable: true
        }];
      }
      return new TransactionInstruction({
        keys: keys,
        programId: this.programId,
        data: data
      });
    }

    /**
     * Generate a transaction instruction that creates a new account at
     *   an address generated with `from`, a seed, and programId
     */
  }, {
    key: "createAccountWithSeed",
    value: function createAccountWithSeed(params) {
      var type = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;
      var data = encodeData(type, {
        base: toBuffer(params.basePubkey.toBuffer()),
        seed: params.seed,
        lamports: params.lamports,
        space: params.space,
        programId: toBuffer(params.programId.toBuffer())
      });
      var keys = [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.newAccountPubkey,
        isSigner: false,
        isWritable: true
      }];
      if (params.basePubkey != params.fromPubkey) {
        keys.push({
          pubkey: params.basePubkey,
          isSigner: true,
          isWritable: false
        });
      }
      return new TransactionInstruction({
        keys: keys,
        programId: this.programId,
        data: data
      });
    }

    /**
     * Generate a transaction that creates a new Nonce account
     */
  }, {
    key: "createNonceAccount",
    value: function createNonceAccount(params) {
      var transaction = new Transaction();
      if ('basePubkey' in params && 'seed' in params) {
        transaction.add(SystemProgram.createAccountWithSeed({
          fromPubkey: params.fromPubkey,
          newAccountPubkey: params.noncePubkey,
          basePubkey: params.basePubkey,
          seed: params.seed,
          lamports: params.lamports,
          space: NONCE_ACCOUNT_LENGTH,
          programId: this.programId
        }));
      } else {
        transaction.add(SystemProgram.createAccount({
          fromPubkey: params.fromPubkey,
          newAccountPubkey: params.noncePubkey,
          lamports: params.lamports,
          space: NONCE_ACCOUNT_LENGTH,
          programId: this.programId
        }));
      }
      var initParams = {
        noncePubkey: params.noncePubkey,
        authorizedPubkey: params.authorizedPubkey
      };
      transaction.add(this.nonceInitialize(initParams));
      return transaction;
    }

    /**
     * Generate an instruction to initialize a Nonce account
     */
  }, {
    key: "nonceInitialize",
    value: function nonceInitialize(params) {
      var type = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;
      var data = encodeData(type, {
        authorized: toBuffer(params.authorizedPubkey.toBuffer())
      });
      var instructionData = {
        keys: [{
          pubkey: params.noncePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_RENT_PUBKEY,
          isSigner: false,
          isWritable: false
        }],
        programId: this.programId,
        data: data
      };
      return new TransactionInstruction(instructionData);
    }

    /**
     * Generate an instruction to advance the nonce in a Nonce account
     */
  }, {
    key: "nonceAdvance",
    value: function nonceAdvance(params) {
      var type = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;
      var data = encodeData(type);
      var instructionData = {
        keys: [{
          pubkey: params.noncePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: params.authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data: data
      };
      return new TransactionInstruction(instructionData);
    }

    /**
     * Generate a transaction instruction that withdraws lamports from a Nonce account
     */
  }, {
    key: "nonceWithdraw",
    value: function nonceWithdraw(params) {
      var type = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;
      var data = encodeData(type, {
        lamports: params.lamports
      });
      return new TransactionInstruction({
        keys: [{
          pubkey: params.noncePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.toPubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_RENT_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: params.authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data: data
      });
    }

    /**
     * Generate a transaction instruction that authorizes a new PublicKey as the authority
     * on a Nonce account.
     */
  }, {
    key: "nonceAuthorize",
    value: function nonceAuthorize(params) {
      var type = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;
      var data = encodeData(type, {
        authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())
      });
      return new TransactionInstruction({
        keys: [{
          pubkey: params.noncePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data: data
      });
    }

    /**
     * Generate a transaction instruction that allocates space in an account without funding
     */
  }, {
    key: "allocate",
    value: function allocate(params) {
      var data;
      var keys;
      if ('basePubkey' in params) {
        var type = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;
        data = encodeData(type, {
          base: toBuffer(params.basePubkey.toBuffer()),
          seed: params.seed,
          space: params.space,
          programId: toBuffer(params.programId.toBuffer())
        });
        keys = [{
          pubkey: params.accountPubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.basePubkey,
          isSigner: true,
          isWritable: false
        }];
      } else {
        var _type3 = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;
        data = encodeData(_type3, {
          space: params.space
        });
        keys = [{
          pubkey: params.accountPubkey,
          isSigner: true,
          isWritable: true
        }];
      }
      return new TransactionInstruction({
        keys: keys,
        programId: this.programId,
        data: data
      });
    }
  }]);
  return SystemProgram;
}();
SystemProgram.programId = new PublicKey('11111111111111111111111111111111');

// Keep program chunks under PACKET_DATA_SIZE, leaving enough room for the
// rest of the Transaction fields
//
// TODO: replace 300 with a proper constant for the size of the other
// Transaction fields
var CHUNK_SIZE = PACKET_DATA_SIZE - 300;

/**
 * Program loader interface
 */
var Loader = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function Loader() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, Loader);
  }

  /**
   * Amount of program data placed in each load Transaction
   */
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(Loader, null, [{
    key: "getMinNumSignatures",
    value:
    /**
     * Minimum number of signatures required to load a program not including
     * retries
     *
     * Can be used to calculate transaction fees
     */
    function getMinNumSignatures(dataLength) {
      return 2 * (
      // Every transaction requires two signatures (payer + program)
      Math.ceil(dataLength / Loader.chunkSize) + 1 +
      // Add one for Create transaction
      1) // Add one for Finalize transaction
      ;
    }

    /**
     * Loads a generic program
     *
     * @param connection The connection to use
     * @param payer System account that pays to load the program
     * @param program Account to load the program into
     * @param programId Public key that identifies the loader
     * @param data Program octets
     * @return true if program was loaded successfully, false if program was already loaded
     */
  }, {
    key: "load",
    value: function () {
      var _load = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee(connection, payer, program, programId, data) {
        var balanceNeeded, programInfo, transaction, dataLayout, chunkSize, offset, array, transactions, bytes, _data, _transaction, REQUESTS_PER_SECOND, _dataLayout, _data2, _transaction2, deployCommitment, finalizeSignature, _yield$connection$con, context, value, currentSlot;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return connection.getMinimumBalanceForRentExemption(data.length);
            case 2:
              balanceNeeded = _context.sent;
              _context.next = 5;
              return connection.getAccountInfo(program.publicKey, 'confirmed');
            case 5:
              programInfo = _context.sent;
              transaction = null;
              if (!(programInfo !== null)) {
                _context.next = 16;
                break;
              }
              if (!programInfo.executable) {
                _context.next = 11;
                break;
              }
              console.error('Program load failed, account is already executable');
              return _context.abrupt("return", false);
            case 11:
              if (programInfo.data.length !== data.length) {
                transaction = transaction || new Transaction();
                transaction.add(SystemProgram.allocate({
                  accountPubkey: program.publicKey,
                  space: data.length
                }));
              }
              if (!programInfo.owner.equals(programId)) {
                transaction = transaction || new Transaction();
                transaction.add(SystemProgram.assign({
                  accountPubkey: program.publicKey,
                  programId: programId
                }));
              }
              if (programInfo.lamports < balanceNeeded) {
                transaction = transaction || new Transaction();
                transaction.add(SystemProgram.transfer({
                  fromPubkey: payer.publicKey,
                  toPubkey: program.publicKey,
                  lamports: balanceNeeded - programInfo.lamports
                }));
              }
              _context.next = 17;
              break;
            case 16:
              transaction = new Transaction().add(SystemProgram.createAccount({
                fromPubkey: payer.publicKey,
                newAccountPubkey: program.publicKey,
                lamports: balanceNeeded > 0 ? balanceNeeded : 1,
                space: data.length,
                programId: programId
              }));
            case 17:
              if (!(transaction !== null)) {
                _context.next = 20;
                break;
              }
              _context.next = 20;
              return sendAndConfirmTransaction(connection, transaction, [payer, program], {
                commitment: 'confirmed'
              });
            case 20:
              dataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('offset'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('bytesLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('bytesLengthPadding'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .seq */ .A9(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__.u8('byte'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .offset */ .cv(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq(), -8), 'bytes')]);
              chunkSize = Loader.chunkSize;
              offset = 0;
              array = data;
              transactions = [];
            case 25:
              if (!(array.length > 0)) {
                _context.next = 39;
                break;
              }
              bytes = array.slice(0, chunkSize);
              _data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(chunkSize + 16);
              dataLayout.encode({
                instruction: 0,
                // Load instruction
                offset: offset,
                bytes: bytes,
                bytesLength: 0,
                bytesLengthPadding: 0
              }, _data);
              _transaction = new Transaction().add({
                keys: [{
                  pubkey: program.publicKey,
                  isSigner: true,
                  isWritable: true
                }],
                programId: programId,
                data: _data
              });
              transactions.push(sendAndConfirmTransaction(connection, _transaction, [payer, program], {
                commitment: 'confirmed'
              }));

              // Delay between sends in an attempt to reduce rate limit errors
              if (!connection._rpcEndpoint.includes('solana.com')) {
                _context.next = 35;
                break;
              }
              REQUESTS_PER_SECOND = 4;
              _context.next = 35;
              return sleep(1000 / REQUESTS_PER_SECOND);
            case 35:
              offset += chunkSize;
              array = array.slice(chunkSize);
              _context.next = 25;
              break;
            case 39:
              _context.next = 41;
              return Promise.all(transactions);
            case 41:
              _dataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction')]);
              _data2 = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(_dataLayout.span);
              _dataLayout.encode({
                instruction: 1 // Finalize instruction
              }, _data2);
              _transaction2 = new Transaction().add({
                keys: [{
                  pubkey: program.publicKey,
                  isSigner: true,
                  isWritable: true
                }, {
                  pubkey: SYSVAR_RENT_PUBKEY,
                  isSigner: false,
                  isWritable: false
                }],
                programId: programId,
                data: _data2
              });
              deployCommitment = 'processed';
              _context.next = 48;
              return connection.sendTransaction(_transaction2, [payer, program], {
                preflightCommitment: deployCommitment
              });
            case 48:
              finalizeSignature = _context.sent;
              _context.next = 51;
              return connection.confirmTransaction({
                signature: finalizeSignature,
                lastValidBlockHeight: _transaction2.lastValidBlockHeight,
                blockhash: _transaction2.recentBlockhash
              }, deployCommitment);
            case 51:
              _yield$connection$con = _context.sent;
              context = _yield$connection$con.context;
              value = _yield$connection$con.value;
              if (!value.err) {
                _context.next = 56;
                break;
              }
              throw new Error("Transaction ".concat(finalizeSignature, " failed (").concat(JSON.stringify(value), ")"));
            case 56:
              _context.prev = 57;
              _context.next = 60;
              return connection.getSlot({
                commitment: deployCommitment
              });
            case 60:
              currentSlot = _context.sent;
              if (!(currentSlot > context.slot)) {
                _context.next = 63;
                break;
              }
              return _context.abrupt("break", 71);
            case 63:
              _context.next = 67;
              break;
            case 65:
              _context.prev = 65;
              _context.t0 = _context["catch"](57);
            case 67:
              _context.next = 69;
              return new Promise(function (resolve) {
                return setTimeout(resolve, Math.round(MS_PER_SLOT / 2));
              });
            case 69:
              _context.next = 56;
              break;
            case 71:
              return _context.abrupt("return", true);
            case 72:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[57, 65]]);
      }));
      function load(_x, _x2, _x3, _x4, _x5) {
        return _load.apply(this, arguments);
      }
      return load;
    }()
  }]);
  return Loader;
}();
Loader.chunkSize = CHUNK_SIZE;

var BPF_LOADER_PROGRAM_ID = new PublicKey('BPFLoader2111111111111111111111111111111111');

/**
 * Factory class for transactions to interact with a program loader
 */
var BpfLoader = /*#__PURE__*/function () {
  function BpfLoader() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, BpfLoader);
  }
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(BpfLoader, null, [{
    key: "getMinNumSignatures",
    value:
    /**
     * Minimum number of signatures required to load a program not including
     * retries
     *
     * Can be used to calculate transaction fees
     */
    function getMinNumSignatures(dataLength) {
      return Loader.getMinNumSignatures(dataLength);
    }

    /**
     * Load a SBF program
     *
     * @param connection The connection to use
     * @param payer Account that will pay program loading fees
     * @param program Account to load the program into
     * @param elf The entire ELF containing the SBF program
     * @param loaderProgramId The program id of the BPF loader to use
     * @return true if program was loaded successfully, false if program was already loaded
     */
  }, {
    key: "load",
    value: function load(connection, payer, program, elf, loaderProgramId) {
      return Loader.load(connection, payer, program, loaderProgramId, elf);
    }
  }]);
  return BpfLoader;
}();

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var objToString = Object.prototype.toString;
var objKeys = Object.keys || function(obj) {
		var keys = [];
		for (var name in obj) {
			keys.push(name);
		}
		return keys;
	};

function stringify(val, isArrayProp) {
	var i, max, str, keys, key, propVal, toStr;
	if (val === true) {
		return "true";
	}
	if (val === false) {
		return "false";
	}
	switch (typeof val) {
		case "object":
			if (val === null) {
				return null;
			} else if (val.toJSON && typeof val.toJSON === "function") {
				return stringify(val.toJSON(), isArrayProp);
			} else {
				toStr = objToString.call(val);
				if (toStr === "[object Array]") {
					str = '[';
					max = val.length - 1;
					for(i = 0; i < max; i++) {
						str += stringify(val[i], true) + ',';
					}
					if (max > -1) {
						str += stringify(val[i], true);
					}
					return str + ']';
				} else if (toStr === "[object Object]") {
					// only object is left
					keys = objKeys(val).sort();
					max = keys.length;
					str = "";
					i = 0;
					while (i < max) {
						key = keys[i];
						propVal = stringify(val[key], false);
						if (propVal !== undefined) {
							if (str) {
								str += ',';
							}
							str += JSON.stringify(key) + ':' + propVal;
						}
						i++;
					}
					return '{' + str + '}';
				} else {
					return JSON.stringify(val);
				}
			}
		case "function":
		case "undefined":
			return isArrayProp ? null : undefined;
		case "string":
			return JSON.stringify(val);
		default:
			return isFinite(val) ? val : null;
	}
}

var fastStableStringify = function(val) {
	var returnVal = stringify(val, false);
	if (returnVal !== undefined) {
		return ''+ returnVal;
	}
};

var fastStableStringify$1 = /*@__PURE__*/getDefaultExportFromCjs(fastStableStringify);

var MINIMUM_SLOT_PER_EPOCH = 32;

// Returns the number of trailing zeros in the binary representation of self.
function trailingZeros(n) {
  var trailingZeros = 0;
  while (n > 1) {
    n /= 2;
    trailingZeros++;
  }
  return trailingZeros;
}

// Returns the smallest power of two greater than or equal to n
function nextPowerOfTwo(n) {
  if (n === 0) return 1;
  n--;
  n |= n >> 1;
  n |= n >> 2;
  n |= n >> 4;
  n |= n >> 8;
  n |= n >> 16;
  n |= n >> 32;
  return n + 1;
}

/**
 * Epoch schedule
 * (see https://docs.solana.com/terminology#epoch)
 * Can be retrieved with the {@link Connection.getEpochSchedule} method
 */
var EpochSchedule = /*#__PURE__*/function () {
  function EpochSchedule(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, EpochSchedule);
    /** The maximum number of slots in each epoch */
    this.slotsPerEpoch = void 0;
    /** The number of slots before beginning of an epoch to calculate a leader schedule for that epoch */
    this.leaderScheduleSlotOffset = void 0;
    /** Indicates whether epochs start short and grow */
    this.warmup = void 0;
    /** The first epoch with `slotsPerEpoch` slots */
    this.firstNormalEpoch = void 0;
    /** The first slot of `firstNormalEpoch` */
    this.firstNormalSlot = void 0;
    this.slotsPerEpoch = slotsPerEpoch;
    this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;
    this.warmup = warmup;
    this.firstNormalEpoch = firstNormalEpoch;
    this.firstNormalSlot = firstNormalSlot;
  }
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(EpochSchedule, [{
    key: "getEpoch",
    value: function getEpoch(slot) {
      return this.getEpochAndSlotIndex(slot)[0];
    }
  }, {
    key: "getEpochAndSlotIndex",
    value: function getEpochAndSlotIndex(slot) {
      if (slot < this.firstNormalSlot) {
        var epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;
        var epochLen = this.getSlotsInEpoch(epoch);
        var slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);
        return [epoch, slotIndex];
      } else {
        var normalSlotIndex = slot - this.firstNormalSlot;
        var normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);
        var _epoch = this.firstNormalEpoch + normalEpochIndex;
        var _slotIndex = normalSlotIndex % this.slotsPerEpoch;
        return [_epoch, _slotIndex];
      }
    }
  }, {
    key: "getFirstSlotInEpoch",
    value: function getFirstSlotInEpoch(epoch) {
      if (epoch <= this.firstNormalEpoch) {
        return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;
      } else {
        return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;
      }
    }
  }, {
    key: "getLastSlotInEpoch",
    value: function getLastSlotInEpoch(epoch) {
      return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;
    }
  }, {
    key: "getSlotsInEpoch",
    value: function getSlotsInEpoch(epoch) {
      if (epoch < this.firstNormalEpoch) {
        return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));
      } else {
        return this.slotsPerEpoch;
      }
    }
  }]);
  return EpochSchedule;
}();

function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .Z)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .Z)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .Z)(this, result); }; }
function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var SendTransactionError = /*#__PURE__*/function (_Error) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(SendTransactionError, _Error);
  var _super = _createSuper$1(SendTransactionError);
  function SendTransactionError(message, logs) {
    var _this;
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, SendTransactionError);
    _this = _super.call(this, message);
    _this.logs = void 0;
    _this.logs = logs;
    return _this;
  }
  return (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(SendTransactionError);
}( /*#__PURE__*/(0,_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .Z)(Error));

// Keep in sync with client/src/rpc_custom_errors.rs
// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/
var SolanaJSONRPCErrorCode = {
  JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
  JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,
  JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
  JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
  JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,
  JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
  JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
  JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
  JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
  JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
  JSON_RPC_SCAN_ERROR: -32012,
  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
  JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
  JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
  JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016
};
var SolanaJSONRPCError = /*#__PURE__*/function (_Error2) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(SolanaJSONRPCError, _Error2);
  var _super2 = _createSuper$1(SolanaJSONRPCError);
  function SolanaJSONRPCError(_ref, customMessage) {
    var _this2;
    var code = _ref.code,
      message = _ref.message,
      data = _ref.data;
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, SolanaJSONRPCError);
    _this2 = _super2.call(this, customMessage != null ? "".concat(customMessage, ": ").concat(message) : message);
    _this2.code = void 0;
    _this2.data = void 0;
    _this2.code = code;
    _this2.data = data;
    _this2.name = 'SolanaJSONRPCError';
    return _this2;
  }
  return (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(SolanaJSONRPCError);
}( /*#__PURE__*/(0,_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .Z)(Error));

var fetchImpl = globalThis.fetch;

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_21__/* ["default"] */ .Z)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .Z)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .Z)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .Z)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var RpcWebSocketClient = /*#__PURE__*/function (_RpcWebSocketCommonCl) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(RpcWebSocketClient, _RpcWebSocketCommonCl);
  var _super = _createSuper(RpcWebSocketClient);
  function RpcWebSocketClient(address, options, generate_request_id) {
    var _this;
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, RpcWebSocketClient);
    var webSocketFactory = function webSocketFactory(url) {
      var rpc = (0,rpc_websockets_dist_lib_client_websocket_browser__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(url, _objectSpread$1({
        autoconnect: true,
        max_reconnects: 5,
        reconnect: true,
        reconnect_interval: 1000
      }, options));
      if ('socket' in rpc) {
        _this.underlyingSocket = rpc.socket;
      } else {
        _this.underlyingSocket = rpc;
      }
      return rpc;
    };
    _this = _super.call(this, webSocketFactory, address, options, generate_request_id);
    _this.underlyingSocket = void 0;
    return _this;
  }
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(RpcWebSocketClient, [{
    key: "call",
    value: function call() {
      var _this$underlyingSocke;
      var readyState = (_this$underlyingSocke = this.underlyingSocket) === null || _this$underlyingSocke === void 0 ? void 0 : _this$underlyingSocke.readyState;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (readyState === 1 /* WebSocket.OPEN */) {
        var _get2;
        return (_get2 = (0,_babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z)((0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .Z)(RpcWebSocketClient.prototype), "call", this)).call.apply(_get2, [this].concat(args));
      }
      return Promise.reject(new Error('Tried to call a JSON-RPC method `' + args[0] + '` but the socket was not `CONNECTING` or `OPEN` (`readyState` was ' + readyState + ')'));
    }
  }, {
    key: "notify",
    value: function notify() {
      var _this$underlyingSocke2;
      var readyState = (_this$underlyingSocke2 = this.underlyingSocket) === null || _this$underlyingSocke2 === void 0 ? void 0 : _this$underlyingSocke2.readyState;
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      if (readyState === 1 /* WebSocket.OPEN */) {
        var _get3;
        return (_get3 = (0,_babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z)((0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .Z)(RpcWebSocketClient.prototype), "notify", this)).call.apply(_get3, [this].concat(args));
      }
      return Promise.reject(new Error('Tried to send a JSON-RPC notification `' + args[0] + '` but the socket was not `CONNECTING` or `OPEN` (`readyState` was ' + readyState + ')'));
    }
  }]);
  return RpcWebSocketClient;
}(rpc_websockets_dist_lib_client__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z);

/**
 * @internal
 */

/**
 * Decode account data buffer using an AccountType
 * @internal
 */
function decodeData(type, data) {
  var decoded;
  try {
    decoded = type.layout.decode(data);
  } catch (err) {
    throw new Error('invalid instruction; ' + err);
  }
  if (decoded.typeIndex !== type.index) {
    throw new Error("invalid account data; account type mismatch ".concat(decoded.typeIndex, " != ").concat(type.index));
  }
  return decoded;
}

/// The serialized size of lookup table metadata
var LOOKUP_TABLE_META_SIZE = 56;
var AddressLookupTableAccount = /*#__PURE__*/function () {
  function AddressLookupTableAccount(args) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, AddressLookupTableAccount);
    this.key = void 0;
    this.state = void 0;
    this.key = args.key;
    this.state = args.state;
  }
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(AddressLookupTableAccount, [{
    key: "isActive",
    value: function isActive() {
      var U64_MAX = BigInt('0xffffffffffffffff');
      return this.state.deactivationSlot === U64_MAX;
    }
  }], [{
    key: "deserialize",
    value: function deserialize(accountData) {
      var meta = decodeData(LookupTableMetaLayout, accountData);
      var serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;
      assert(serializedAddressesLen >= 0, 'lookup table is invalid');
      assert(serializedAddressesLen % 32 === 0, 'lookup table is invalid');
      var numSerializedAddresses = serializedAddressesLen / 32;
      var _BufferLayout$struct$ = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .seq */ .A9(publicKey(), numSerializedAddresses, 'addresses')]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE)),
        addresses = _BufferLayout$struct$.addresses;
      return {
        deactivationSlot: meta.deactivationSlot,
        lastExtendedSlot: meta.lastExtendedSlot,
        lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,
        authority: meta.authority.length !== 0 ? new PublicKey(meta.authority[0]) : undefined,
        addresses: addresses.map(function (address) {
          return new PublicKey(address);
        })
      };
    }
  }]);
  return AddressLookupTableAccount;
}();
var LookupTableMetaLayout = {
  index: 1,
  layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('typeIndex'), u64('deactivationSlot'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .nu64 */ ._O('lastExtendedSlot'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__.u8('lastExtendedStartIndex'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__.u8(),
  // option
  _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .seq */ .A9(publicKey(), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .offset */ .cv(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__.u8(), -1), 'authority')])
};

var URL_RE = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
function makeWebsocketUrl(endpoint) {
  var matches = endpoint.match(URL_RE);
  if (matches == null) {
    throw TypeError("Failed to validate endpoint URL `".concat(endpoint, "`"));
  }
  var _matches = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(matches, 4);
    _matches[0];
    var // eslint-disable-line @typescript-eslint/no-unused-vars
    hostish = _matches[1],
    portWithColon = _matches[2],
    rest = _matches[3];
  var protocol = endpoint.startsWith('https:') ? 'wss:' : 'ws:';
  var startPort = portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);
  var websocketPort =
  // Only shift the port by +1 as a convention for ws(s) only if given endpoint
  // is explictly specifying the endpoint port (HTTP-based RPC), assuming
  // we're directly trying to connect to solana-validator's ws listening port.
  // When the endpoint omits the port, we're connecting to the protocol
  // default ports: http(80) or https(443) and it's assumed we're behind a reverse
  // proxy which manages WebSocket upgrade and backend port redirection.
  startPort == null ? '' : ":".concat(startPort + 1);
  return "".concat(protocol, "//").concat(hostish).concat(websocketPort).concat(rest);
}

var _process$env$npm_pack;
var _excluded = ["commitment"],
  _excluded2 = ["encoding"],
  _excluded3 = ["commitment"],
  _excluded4 = ["commitment"];
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_21__/* ["default"] */ .Z)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var PublicKeyFromString = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .coerce */ .oQ)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .instance */ .eE)(PublicKey), (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(), function (value) {
  return new PublicKey(value);
});
var RawAccountDataResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .tuple */ .bc)([(0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .literal */ .i0)('base64')]);
var BufferFromRawAccountData = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .coerce */ .oQ)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .instance */ .eE)(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer), RawAccountDataResult, function (value) {
  return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value[0], 'base64');
});

/**
 * Attempt to use a recent blockhash for up to 30 seconds
 * @internal
 */
var BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1000;

/**
 * HACK.
 * Copied from rpc-websockets/dist/lib/client.
 * Otherwise, `yarn build` fails with:
 * https://gist.github.com/steveluscher/c057eca81d479ef705cdb53162f9971d
 */

/** @internal */
/** @internal */
/** @internal */
/** @internal */

/** @internal */
/**
 * @internal
 * Every subscription contains the args used to open the subscription with
 * the server, and a list of callers interested in notifications.
 */

/**
 * @internal
 * A subscription may be in various states of connectedness. Only when it is
 * fully connected will it have a server subscription id associated with it.
 * This id can be returned to the server to unsubscribe the client entirely.
 */

/**
 * A type that encapsulates a subscription's RPC method
 * names and notification (callback) signature.
 */

/**
 * @internal
 * Utility type that keeps tagged unions intact while omitting properties.
 */

/**
 * @internal
 * This type represents a single subscribable 'topic.' It's made up of:
 *
 * - The args used to open the subscription with the server,
 * - The state of the subscription, in terms of its connectedness, and
 * - The set of callbacks to call when the server publishes notifications
 *
 * This record gets indexed by `SubscriptionConfigHash` and is used to
 * set up subscriptions, fan out notifications, and track subscription state.
 */

/**
 * @internal
 */

/**
 * Extra contextual information for RPC responses
 */

/**
 * Options for sending transactions
 */

/**
 * Options for confirming transactions
 */

/**
 * Options for getConfirmedSignaturesForAddress2
 */

/**
 * Options for getSignaturesForAddress
 */

/**
 * RPC Response with extra contextual information
 */

/**
 * A strategy for confirming transactions that uses the last valid
 * block height for a given blockhash to check for transaction expiration.
 */

/**
 * A strategy for confirming durable nonce transactions.
 */

/**
 * Properties shared by all transaction confirmation strategies
 */

/**
 * This type represents all transaction confirmation strategies
 */

/* @internal */
function assertEndpointUrl(putativeUrl) {
  if (/^https?:/.test(putativeUrl) === false) {
    throw new TypeError('Endpoint URL must start with `http:` or `https:`.');
  }
  return putativeUrl;
}

/** @internal */
function extractCommitmentFromConfig(commitmentOrConfig) {
  var commitment;
  var config;
  if (typeof commitmentOrConfig === 'string') {
    commitment = commitmentOrConfig;
  } else if (commitmentOrConfig) {
    var specifiedCommitment = commitmentOrConfig.commitment,
      specifiedConfig = (0,_babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_24__/* ["default"] */ .Z)(commitmentOrConfig, _excluded);
    commitment = specifiedCommitment;
    config = specifiedConfig;
  }
  return {
    commitment: commitment,
    config: config
  };
}

/**
 * @internal
 */
function createRpcResult(result) {
  return (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .union */ .G0)([(0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
    jsonrpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .literal */ .i0)('2.0'),
    id: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
    result: result
  }), (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
    jsonrpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .literal */ .i0)('2.0'),
    id: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
    error: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
      code: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .unknown */ ._4)(),
      message: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
      data: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .any */ .Yj)())
    })
  })]);
}
var UnknownRpcResult = createRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .unknown */ ._4)());

/**
 * @internal
 */
function jsonRpcResult(schema) {
  return (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .coerce */ .oQ)(createRpcResult(schema), UnknownRpcResult, function (value) {
    if ('error' in value) {
      return value;
    } else {
      return _objectSpread(_objectSpread({}, value), {}, {
        result: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(value.result, schema)
      });
    }
  });
}

/**
 * @internal
 */
function jsonRpcResultAndContext(value) {
  return jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
    context: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
      slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()
    }),
    value: value
  }));
}

/**
 * @internal
 */
function notificationResultAndContext(value) {
  return (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
    context: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
      slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()
    }),
    value: value
  });
}

/**
 * @internal
 */
function versionedMessageFromResponse(version, response) {
  if (version === 0) {
    return new MessageV0({
      header: response.header,
      staticAccountKeys: response.accountKeys.map(function (accountKey) {
        return new PublicKey(accountKey);
      }),
      recentBlockhash: response.recentBlockhash,
      compiledInstructions: response.instructions.map(function (ix) {
        return {
          programIdIndex: ix.programIdIndex,
          accountKeyIndexes: ix.accounts,
          data: bs58__WEBPACK_IMPORTED_MODULE_3___default().decode(ix.data)
        };
      }),
      addressTableLookups: response.addressTableLookups
    });
  } else {
    return new Message(response);
  }
}

/**
 * The level of commitment desired when querying state
 * <pre>
 *   'processed': Query the most recent block which has reached 1 confirmation by the connected node
 *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster
 *   'finalized': Query the most recent block which has been finalized by the cluster
 * </pre>
 */

// Deprecated as of v1.5.5
/**
 * A subset of Commitment levels, which are at least optimistically confirmed
 * <pre>
 *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster
 *   'finalized': Query the most recent block which has been finalized by the cluster
 * </pre>
 */
/**
 * Filter for largest accounts query
 * <pre>
 *   'circulating':    Return the largest accounts that are part of the circulating supply
 *   'nonCirculating': Return the largest accounts that are not part of the circulating supply
 * </pre>
 */
/**
 * Configuration object for changing `getAccountInfo` query behavior
 */
/**
 * Configuration object for changing `getBalance` query behavior
 */
/**
 * Configuration object for changing `getBlock` query behavior
 */
/**
 * Configuration object for changing `getBlock` query behavior
 */
/**
 * Configuration object for changing `getStakeMinimumDelegation` query behavior
 */
/**
 * Configuration object for changing `getBlockHeight` query behavior
 */
/**
 * Configuration object for changing `getEpochInfo` query behavior
 */
/**
 * Configuration object for changing `getInflationReward` query behavior
 */
/**
 * Configuration object for changing `getLatestBlockhash` query behavior
 */
/**
 * Configuration object for changing `isBlockhashValid` query behavior
 */
/**
 * Configuration object for changing `getSlot` query behavior
 */
/**
 * Configuration object for changing `getSlotLeader` query behavior
 */
/**
 * Configuration object for changing `getTransaction` query behavior
 */
/**
 * Configuration object for changing `getTransaction` query behavior
 */
/**
 * Configuration object for changing `getLargestAccounts` query behavior
 */
/**
 * Configuration object for changing `getSupply` request behavior
 */
/**
 * Configuration object for changing query behavior
 */
/**
 * Information describing a cluster node
 */
/**
 * Information describing a vote account
 */
/**
 * A collection of cluster vote accounts
 */
/**
 * Network Inflation
 * (see https://docs.solana.com/implemented-proposals/ed_overview)
 */
var GetInflationGovernorResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  foundation: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  foundationTerm: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  initial: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  taper: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  terminal: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()
});

/**
 * The inflation reward for an epoch
 */

/**
 * Expected JSON RPC response for the "getInflationReward" message
 */
var GetInflationRewardResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  effectiveSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  postBalance: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()))
}))));

/**
 * Configuration object for changing `getRecentPrioritizationFees` query behavior
 */

/**
 * Expected JSON RPC response for the "getRecentPrioritizationFees" message
 */
var GetRecentPrioritizationFeesResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  prioritizationFee: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()
}));
/**
 * Expected JSON RPC response for the "getInflationRate" message
 */
var GetInflationRateResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  total: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  validator: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  foundation: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()
});

/**
 * Information about the current epoch
 */

var GetEpochInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  slotIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  slotsInEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  absoluteSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()),
  transactionCount: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)())
});
var GetEpochScheduleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  slotsPerEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  leaderScheduleSlotOffset: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  warmup: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .boolean */ .O7)(),
  firstNormalEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  firstNormalSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()
});

/**
 * Leader schedule
 * (see https://docs.solana.com/terminology#leader-schedule)
 */

var GetLeaderScheduleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .record */ .IM)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()));

/**
 * Transaction error or null
 */
var TransactionErrorResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .union */ .G0)([(0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({}), (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)()]));

/**
 * Signature status for a transaction
 */
var SignatureStatusResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  err: TransactionErrorResult
});

/**
 * Transaction signature received notification
 */
var SignatureReceivedResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .literal */ .i0)('receivedSignature');

/**
 * Version info for a node
 */

var VersionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  'solana-core': (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
  'feature-set': (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)())
});
var SimulatedTransactionResponseStruct = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  err: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .union */ .G0)([(0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({}), (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)()])),
  logs: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)())),
  accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
    executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .boolean */ .O7)(),
    owner: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
    data: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)()),
    rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)())
  }))))),
  unitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()),
  returnData: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
    programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
    data: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .tuple */ .bc)([(0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .literal */ .i0)('base64')])
  })))
}));

/**
 * Metadata for a parsed confirmed transaction on the ledger
 *
 * @deprecated Deprecated since Solana v1.8.0. Please use {@link ParsedTransactionMeta} instead.
 */

/**
 * Collection of addresses loaded by a transaction using address table lookups
 */

/**
 * Metadata for a parsed transaction on the ledger
 */

/**
 * Metadata for a confirmed transaction on the ledger
 */

/**
 * A processed transaction from the RPC API
 */

/**
 * A processed transaction from the RPC API
 */

/**
 * A processed transaction message from the RPC API
 */

/**
 * A confirmed transaction on the ledger
 *
 * @deprecated Deprecated since Solana v1.8.0.
 */

/**
 * A partially decoded transaction instruction
 */

/**
 * A parsed transaction message account
 */

/**
 * A parsed transaction instruction
 */

/**
 * A parsed address table lookup
 */

/**
 * A parsed transaction message
 */

/**
 * A parsed transaction
 */

/**
 * A parsed and confirmed transaction on the ledger
 *
 * @deprecated Deprecated since Solana v1.8.0. Please use {@link ParsedTransactionWithMeta} instead.
 */

/**
 * A parsed transaction on the ledger with meta
 */

/**
 * A processed block fetched from the RPC API
 */

/**
 * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`
 */

/**
 * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`
 */

/**
 * A block with parsed transactions
 */

/**
 * A block with parsed transactions where the `transactionDetails` mode is `accounts`
 */

/**
 * A block with parsed transactions where the `transactionDetails` mode is `none`
 */

/**
 * A processed block fetched from the RPC API
 */

/**
 * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`
 */

/**
 * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`
 */

/**
 * A confirmed block on the ledger
 *
 * @deprecated Deprecated since Solana v1.8.0.
 */

/**
 * A Block on the ledger with signatures only
 */

/**
 * recent block production information
 */

/**
 * Expected JSON RPC response for the "getBlockProduction" message
 */
var BlockProductionResponseStruct = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  byIdentity: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .record */ .IM)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)())),
  range: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
    firstSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
    lastSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()
  })
}));

/**
 * A performance sample
 */

function createRpcClient(url, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent) {
  var fetch = customFetch ? customFetch : fetchImpl;
  var agent;
  {
    if (httpAgent != null) {
      console.warn('You have supplied an `httpAgent` when creating a `Connection` in a browser environment.' + 'It has been ignored; `httpAgent` is only used in Node environments.');
    }
  }
  var fetchWithMiddleware;
  if (fetchMiddleware) {
    fetchWithMiddleware = /*#__PURE__*/function () {
      var _ref = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee(info, init) {
        var modifiedFetchArgs;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return new Promise(function (resolve, reject) {
                try {
                  fetchMiddleware(info, init, function (modifiedInfo, modifiedInit) {
                    return resolve([modifiedInfo, modifiedInit]);
                  });
                } catch (error) {
                  reject(error);
                }
              });
            case 2:
              modifiedFetchArgs = _context.sent;
              _context.next = 5;
              return fetch.apply(void 0, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_19__/* ["default"] */ .Z)(modifiedFetchArgs));
            case 5:
              return _context.abrupt("return", _context.sent);
            case 6:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return function fetchWithMiddleware(_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }();
  }
  var clientBrowser = new (jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_7___default())( /*#__PURE__*/function () {
    var _ref2 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee2(request, callback) {
      var options, too_many_requests_retries, res, waitTime, text;
      return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            options = {
              method: 'POST',
              body: request,
              agent: agent,
              headers: Object.assign({
                'Content-Type': 'application/json'
              }, httpHeaders || {}, COMMON_HTTP_HEADERS)
            };
            _context2.prev = 1;
            too_many_requests_retries = 5;
            waitTime = 500;
          case 4:
            if (!fetchWithMiddleware) {
              _context2.next = 10;
              break;
            }
            _context2.next = 7;
            return fetchWithMiddleware(url, options);
          case 7:
            res = _context2.sent;
            _context2.next = 13;
            break;
          case 10:
            _context2.next = 12;
            return fetch(url, options);
          case 12:
            res = _context2.sent;
          case 13:
            if (!(res.status !== 429 /* Too many requests */)) {
              _context2.next = 15;
              break;
            }
            return _context2.abrupt("break", 26);
          case 15:
            if (!(disableRetryOnRateLimit === true)) {
              _context2.next = 17;
              break;
            }
            return _context2.abrupt("break", 26);
          case 17:
            too_many_requests_retries -= 1;
            if (!(too_many_requests_retries === 0)) {
              _context2.next = 20;
              break;
            }
            return _context2.abrupt("break", 26);
          case 20:
            console.log("Server responded with ".concat(res.status, " ").concat(res.statusText, ".  Retrying after ").concat(waitTime, "ms delay..."));
            _context2.next = 23;
            return sleep(waitTime);
          case 23:
            waitTime *= 2;
          case 24:
            _context2.next = 4;
            break;
          case 26:
            _context2.next = 28;
            return res.text();
          case 28:
            text = _context2.sent;
            if (res.ok) {
              callback(null, text);
            } else {
              callback(new Error("".concat(res.status, " ").concat(res.statusText, ": ").concat(text)));
            }
            _context2.next = 35;
            break;
          case 32:
            _context2.prev = 32;
            _context2.t0 = _context2["catch"](1);
            if (_context2.t0 instanceof Error) callback(_context2.t0);
          case 35:
          case "end":
            return _context2.stop();
        }
      }, _callee2, null, [[1, 32]]);
    }));
    return function (_x3, _x4) {
      return _ref2.apply(this, arguments);
    };
  }(), {});
  return clientBrowser;
}
function createRpcRequest(client) {
  return function (method, args) {
    return new Promise(function (resolve, reject) {
      client.request(method, args, function (err, response) {
        if (err) {
          reject(err);
          return;
        }
        resolve(response);
      });
    });
  };
}
function createRpcBatchRequest(client) {
  return function (requests) {
    return new Promise(function (resolve, reject) {
      // Do nothing if requests is empty
      if (requests.length === 0) resolve([]);
      var batch = requests.map(function (params) {
        return client.request(params.methodName, params.args);
      });
      client.request(batch, function (err, response) {
        if (err) {
          reject(err);
          return;
        }
        resolve(response);
      });
    });
  };
}

/**
 * Expected JSON RPC response for the "getInflationGovernor" message
 */
var GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);

/**
 * Expected JSON RPC response for the "getInflationRate" message
 */
var GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);

/**
 * Expected JSON RPC response for the "getRecentPrioritizationFees" message
 */
var GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult);

/**
 * Expected JSON RPC response for the "getEpochInfo" message
 */
var GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);

/**
 * Expected JSON RPC response for the "getEpochSchedule" message
 */
var GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);

/**
 * Expected JSON RPC response for the "getLeaderSchedule" message
 */
var GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);

/**
 * Expected JSON RPC response for the "minimumLedgerSlot" and "getFirstAvailableBlock" messages
 */
var SlotRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)());

/**
 * Supply
 */

/**
 * Expected JSON RPC response for the "getSupply" message
 */
var GetSupplyRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  total: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  circulating: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  nonCirculating: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  nonCirculatingAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)(PublicKeyFromString)
}));

/**
 * Token amount object which returns a token amount in different formats
 * for various client use cases.
 */

/**
 * Expected JSON RPC structure for token amounts
 */
var TokenAmountResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
  uiAmount: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()),
  decimals: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  uiAmountString: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)())
});

/**
 * Token address and balance.
 */

/**
 * Expected JSON RPC response for the "getTokenLargestAccounts" message
 */
var GetTokenLargestAccountsResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  address: PublicKeyFromString,
  amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
  uiAmount: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()),
  decimals: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  uiAmountString: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)())
})));

/**
 * Expected JSON RPC response for the "getTokenAccountsByOwner" message
 */
var GetTokenAccountsByOwner = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  pubkey: PublicKeyFromString,
  account: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
    executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .boolean */ .O7)(),
    owner: PublicKeyFromString,
    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
    data: BufferFromRawAccountData,
    rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()
  })
})));
var ParsedAccountDataResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  program: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
  parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .unknown */ ._4)(),
  space: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()
});

/**
 * Expected JSON RPC response for the "getTokenAccountsByOwner" message with parsed data
 */
var GetParsedTokenAccountsByOwner = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  pubkey: PublicKeyFromString,
  account: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
    executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .boolean */ .O7)(),
    owner: PublicKeyFromString,
    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
    data: ParsedAccountDataResult,
    rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()
  })
})));

/**
 * Pair of an account address and its balance
 */

/**
 * Expected JSON RPC response for the "getLargestAccounts" message
 */
var GetLargestAccountsRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  address: PublicKeyFromString
})));

/**
 * @internal
 */
var AccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .boolean */ .O7)(),
  owner: PublicKeyFromString,
  lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  data: BufferFromRawAccountData,
  rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()
});

/**
 * @internal
 */
var KeyedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
});
var ParsedOrRawAccountData = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .coerce */ .oQ)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .union */ .G0)([(0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .instance */ .eE)(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer), ParsedAccountDataResult]), (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .union */ .G0)([RawAccountDataResult, ParsedAccountDataResult]), function (value) {
  if (Array.isArray(value)) {
    return (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(value, BufferFromRawAccountData);
  } else {
    return value;
  }
});

/**
 * @internal
 */
var ParsedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .boolean */ .O7)(),
  owner: PublicKeyFromString,
  lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  data: ParsedOrRawAccountData,
  rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()
});
var KeyedParsedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  pubkey: PublicKeyFromString,
  account: ParsedAccountInfoResult
});

/**
 * @internal
 */
var StakeActivationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  state: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .union */ .G0)([(0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .literal */ .i0)('active'), (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .literal */ .i0)('inactive'), (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .literal */ .i0)('activating'), (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .literal */ .i0)('deactivating')]),
  active: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  inactive: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()
});

/**
 * Expected JSON RPC response for the "getConfirmedSignaturesForAddress2" message
 */

var GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  err: TransactionErrorResult,
  memo: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)()),
  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()))
})));

/**
 * Expected JSON RPC response for the "getSignaturesForAddress" message
 */
var GetSignaturesForAddressRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  err: TransactionErrorResult,
  memo: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)()),
  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()))
})));

/***
 * Expected JSON RPC response for the "accountNotification" message
 */
var AccountNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  result: notificationResultAndContext(AccountInfoResult)
});

/**
 * @internal
 */
var ProgramAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
});

/***
 * Expected JSON RPC response for the "programNotification" message
 */
var ProgramAccountNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  result: notificationResultAndContext(ProgramAccountInfoResult)
});

/**
 * @internal
 */
var SlotInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  parent: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  root: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()
});

/**
 * Expected JSON RPC response for the "slotNotification" message
 */
var SlotNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  result: SlotInfoResult
});

/**
 * Slot updates which can be used for tracking the live progress of a cluster.
 * - `"firstShredReceived"`: connected node received the first shred of a block.
 * Indicates that a new block that is being produced.
 * - `"completed"`: connected node has received all shreds of a block. Indicates
 * a block was recently produced.
 * - `"optimisticConfirmation"`: block was optimistically confirmed by the
 * cluster. It is not guaranteed that an optimistic confirmation notification
 * will be sent for every finalized blocks.
 * - `"root"`: the connected node rooted this block.
 * - `"createdBank"`: the connected node has started validating this block.
 * - `"frozen"`: the connected node has validated this block.
 * - `"dead"`: the connected node failed to validate this block.
 */

/**
 * @internal
 */
var SlotUpdateResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .union */ .G0)([(0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  type: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .union */ .G0)([(0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .literal */ .i0)('firstShredReceived'), (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .literal */ .i0)('completed'), (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .literal */ .i0)('optimisticConfirmation'), (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .literal */ .i0)('root')]),
  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()
}), (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  type: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .literal */ .i0)('createdBank'),
  parent: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()
}), (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  type: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .literal */ .i0)('frozen'),
  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  stats: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
    numTransactionEntries: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
    numSuccessfulTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
    numFailedTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
    maxTransactionsPerEntry: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()
  })
}), (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  type: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .literal */ .i0)('dead'),
  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  err: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)()
})]);

/**
 * Expected JSON RPC response for the "slotsUpdatesNotification" message
 */
var SlotUpdateNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  result: SlotUpdateResult
});

/**
 * Expected JSON RPC response for the "signatureNotification" message
 */
var SignatureNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  result: notificationResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .union */ .G0)([SignatureStatusResult, SignatureReceivedResult]))
});

/**
 * Expected JSON RPC response for the "rootNotification" message
 */
var RootNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  result: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()
});
var ContactInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  pubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
  gossip: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)()),
  tpu: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)()),
  rpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)()),
  version: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)())
});
var VoteAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  votePubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
  nodePubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
  activatedStake: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  epochVoteAccount: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .boolean */ .O7)(),
  epochCredits: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .tuple */ .bc)([(0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()])),
  commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  lastVote: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  rootSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)())
});

/**
 * Expected JSON RPC response for the "getVoteAccounts" message
 */
var GetVoteAccounts = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  current: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)(VoteAccountInfoResult),
  delinquent: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)(VoteAccountInfoResult)
}));
var ConfirmationStatus = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .union */ .G0)([(0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .literal */ .i0)('processed'), (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .literal */ .i0)('confirmed'), (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .literal */ .i0)('finalized')]);
var SignatureStatusResponse = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  confirmations: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()),
  err: TransactionErrorResult,
  confirmationStatus: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)(ConfirmationStatus)
});

/**
 * Expected JSON RPC response for the "getSignatureStatuses" message
 */
var GetSignatureStatusesRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)(SignatureStatusResponse)));

/**
 * Expected JSON RPC response for the "getMinimumBalanceForRentExemption" message
 */
var GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)());
var AddressTableLookupStruct = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  accountKey: PublicKeyFromString,
  writableIndexes: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()),
  readonlyIndexes: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)())
});
var ConfirmedTransactionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)()),
  message: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
    accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)()),
    header: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
      numRequiredSignatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
      numReadonlySignedAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
      numReadonlyUnsignedAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()
    }),
    instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
      accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()),
      data: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
      programIdIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()
    })),
    recentBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
    addressTableLookups: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)(AddressTableLookupStruct))
  })
});
var AnnotatedAccountKey = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  pubkey: PublicKeyFromString,
  signer: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .boolean */ .O7)(),
  writable: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .boolean */ .O7)(),
  source: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .union */ .G0)([(0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .literal */ .i0)('transaction'), (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .literal */ .i0)('lookupTable')]))
});
var ConfirmedTransactionAccountsModeResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)(AnnotatedAccountKey),
  signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)())
});
var ParsedInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .unknown */ ._4)(),
  program: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
  programId: PublicKeyFromString
});
var RawInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)(PublicKeyFromString),
  data: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
  programId: PublicKeyFromString
});
var InstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .union */ .G0)([RawInstructionResult, ParsedInstructionResult]);
var UnknownInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .union */ .G0)([(0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .unknown */ ._4)(),
  program: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
  programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)()
}), (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)()),
  data: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
  programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)()
})]);
var ParsedOrRawInstruction = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .coerce */ .oQ)(InstructionResult, UnknownInstructionResult, function (value) {
  if ('accounts' in value) {
    return (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(value, RawInstructionResult);
  } else {
    return (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(value, ParsedInstructionResult);
  }
});

/**
 * @internal
 */
var ParsedConfirmedTransactionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)()),
  message: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
    accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)(AnnotatedAccountKey),
    instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)(ParsedOrRawInstruction),
    recentBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
    addressTableLookups: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)(AddressTableLookupStruct)))
  })
});
var TokenBalanceResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  accountIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  mint: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
  owner: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)()),
  uiTokenAmount: TokenAmountResult
});
var LoadedAddressesResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  writable: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)(PublicKeyFromString),
  readonly: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)(PublicKeyFromString)
});

/**
 * @internal
 */
var ConfirmedTransactionMetaResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  err: TransactionErrorResult,
  fee: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  innerInstructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
    index: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
    instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
      accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()),
      data: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
      programIdIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()
    }))
  })))),
  preBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()),
  postBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()),
  logMessages: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)()))),
  preTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)(TokenBalanceResult))),
  postTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)(TokenBalanceResult))),
  loadedAddresses: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)(LoadedAddressesResult),
  computeUnitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)())
});

/**
 * @internal
 */
var ParsedConfirmedTransactionMetaResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  err: TransactionErrorResult,
  fee: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  innerInstructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
    index: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
    instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)(ParsedOrRawInstruction)
  })))),
  preBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()),
  postBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()),
  logMessages: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)()))),
  preTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)(TokenBalanceResult))),
  postTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)(TokenBalanceResult))),
  loadedAddresses: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)(LoadedAddressesResult),
  computeUnitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)())
});
var TransactionVersionStruct = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .union */ .G0)([(0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .literal */ .i0)(0), (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .literal */ .i0)('legacy')]);

/** @internal */
var RewardsResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  pubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
  lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  postBalance: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()),
  rewardType: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)()),
  commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()))
});

/**
 * Expected JSON RPC response for the "getBlock" message
 */
var GetBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
  previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
  parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
    transaction: ConfirmedTransactionResult,
    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)(ConfirmedTransactionMetaResult),
    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)(TransactionVersionStruct)
  })),
  rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)(RewardsResult)),
  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()),
  blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)())
})));

/**
 * Expected JSON RPC response for the "getBlock" message when `transactionDetails` is `none`
 */
var GetNoneModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
  previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
  parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)(RewardsResult)),
  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()),
  blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)())
})));

/**
 * Expected JSON RPC response for the "getBlock" message when `transactionDetails` is `accounts`
 */
var GetAccountsModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
  previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
  parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)(ConfirmedTransactionMetaResult),
    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)(TransactionVersionStruct)
  })),
  rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)(RewardsResult)),
  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()),
  blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)())
})));

/**
 * Expected parsed JSON RPC response for the "getBlock" message
 */
var GetParsedBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
  previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
  parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
    transaction: ParsedConfirmedTransactionResult,
    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)(ParsedConfirmedTransactionMetaResult),
    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)(TransactionVersionStruct)
  })),
  rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)(RewardsResult)),
  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()),
  blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)())
})));

/**
 * Expected parsed JSON RPC response for the "getBlock" message  when `transactionDetails` is `accounts`
 */
var GetParsedAccountsModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
  previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
  parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)(ParsedConfirmedTransactionMetaResult),
    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)(TransactionVersionStruct)
  })),
  rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)(RewardsResult)),
  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()),
  blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)())
})));

/**
 * Expected parsed JSON RPC response for the "getBlock" message  when `transactionDetails` is `none`
 */
var GetParsedNoneModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
  previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
  parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)(RewardsResult)),
  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()),
  blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)())
})));

/**
 * Expected JSON RPC response for the "getConfirmedBlock" message
 *
 * @deprecated Deprecated since Solana v1.8.0. Please use {@link GetBlockRpcResult} instead.
 */
var GetConfirmedBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
  previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
  parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
    transaction: ConfirmedTransactionResult,
    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)(ConfirmedTransactionMetaResult)
  })),
  rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)(RewardsResult)),
  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)())
})));

/**
 * Expected JSON RPC response for the "getBlock" message
 */
var GetBlockSignaturesRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
  previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
  parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)()),
  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)())
})));

/**
 * Expected JSON RPC response for the "getTransaction" message
 */
var GetTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  meta: ConfirmedTransactionMetaResult,
  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)())),
  transaction: ConfirmedTransactionResult,
  version: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)(TransactionVersionStruct)
})));

/**
 * Expected parsed JSON RPC response for the "getTransaction" message
 */
var GetParsedTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  transaction: ParsedConfirmedTransactionResult,
  meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)(ParsedConfirmedTransactionMetaResult),
  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)())),
  version: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)(TransactionVersionStruct)
})));

/**
 * Expected JSON RPC response for the "getRecentBlockhash" message
 *
 * @deprecated Deprecated since Solana v1.8.0. Please use {@link GetLatestBlockhashRpcResult} instead.
 */
var GetRecentBlockhashAndContextRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
  feeCalculator: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
    lamportsPerSignature: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()
  })
}));

/**
 * Expected JSON RPC response for the "getLatestBlockhash" message
 */
var GetLatestBlockhashRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
  lastValidBlockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()
}));

/**
 * Expected JSON RPC response for the "isBlockhashValid" message
 */
var IsBlockhashValidRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .boolean */ .O7)());
var PerfSampleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  numTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  numSlots: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)(),
  samplePeriodSecs: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()
});

/*
 * Expected JSON RPC response for "getRecentPerformanceSamples" message
 */
var GetRecentPerformanceSamplesRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)(PerfSampleResult));

/**
 * Expected JSON RPC response for the "getFeeCalculatorForBlockhash" message
 */
var GetFeeCalculatorRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  feeCalculator: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
    lamportsPerSignature: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()
  })
})));

/**
 * Expected JSON RPC response for the "requestAirdrop" message
 */
var RequestAirdropRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)());

/**
 * Expected JSON RPC response for the "sendTransaction" message
 */
var SendTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)());

/**
 * Information about the latest slot being processed by a node
 */

/**
 * Parsed account data
 */

/**
 * Stake Activation data
 */

/**
 * Data slice argument for getProgramAccounts
 */

/**
 * Memory comparison filter for getProgramAccounts
 */

/**
 * Data size comparison filter for getProgramAccounts
 */

/**
 * A filter object for getProgramAccounts
 */

/**
 * Configuration object for getProgramAccounts requests
 */

/**
 * Configuration object for getParsedProgramAccounts
 */

/**
 * Configuration object for getMultipleAccounts
 */

/**
 * Configuration object for `getStakeActivation`
 */

/**
 * Configuration object for `getStakeActivation`
 */

/**
 * Configuration object for `getStakeActivation`
 */

/**
 * Configuration object for `getNonce`
 */

/**
 * Configuration object for `getNonceAndContext`
 */

/**
 * Information describing an account
 */

/**
 * Account information identified by pubkey
 */

/**
 * Callback function for account change notifications
 */

/**
 * Callback function for program account change notifications
 */

/**
 * Callback function for slot change notifications
 */

/**
 * Callback function for slot update notifications
 */

/**
 * Callback function for signature status notifications
 */

/**
 * Signature status notification with transaction result
 */

/**
 * Signature received notification
 */

/**
 * Callback function for signature notifications
 */

/**
 * Signature subscription options
 */

/**
 * Callback function for root change notifications
 */

/**
 * @internal
 */
var LogsResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  err: TransactionErrorResult,
  logs: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)()),
  signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)()
});

/**
 * Logs result.
 */

/**
 * Expected JSON RPC response for the "logsNotification" message.
 */
var LogsNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  result: notificationResultAndContext(LogsResult),
  subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()
});

/**
 * Filter for log subscriptions.
 */

/**
 * Callback function for log notifications.
 */

/**
 * Signature result
 */

/**
 * Transaction error
 */

/**
 * Transaction confirmation status
 * <pre>
 *   'processed': Transaction landed in a block which has reached 1 confirmation by the connected node
 *   'confirmed': Transaction landed in a block which has reached 1 confirmation by the cluster
 *   'finalized': Transaction landed in a block which has been finalized by the cluster
 * </pre>
 */

/**
 * Signature status
 */

/**
 * A confirmed signature with its status
 */

/**
 * An object defining headers to be passed to the RPC server
 */

/**
 * The type of the JavaScript `fetch()` API
 */

/**
 * A callback used to augment the outgoing HTTP request
 */

/**
 * Configuration for instantiating a Connection
 */

/** @internal */
var COMMON_HTTP_HEADERS = {
  'solana-client': "js/".concat((_process$env$npm_pack = "0.0.0-development") !== null && _process$env$npm_pack !== void 0 ? _process$env$npm_pack : 'UNKNOWN')
};

/**
 * A connection to a fullnode JSON RPC endpoint
 */
var Connection = /*#__PURE__*/function () {
  /**
   * Establish a JSON RPC connection
   *
   * @param endpoint URL to the fullnode JSON RPC endpoint
   * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object
   */
  function Connection(endpoint, _commitmentOrConfig) {
    var _this = this;
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, Connection);
    /** @internal */
    this._commitment = void 0;
    /** @internal */
    this._confirmTransactionInitialTimeout = void 0;
    /** @internal */
    this._rpcEndpoint = void 0;
    /** @internal */
    this._rpcWsEndpoint = void 0;
    /** @internal */
    this._rpcClient = void 0;
    /** @internal */
    this._rpcRequest = void 0;
    /** @internal */
    this._rpcBatchRequest = void 0;
    /** @internal */
    this._rpcWebSocket = void 0;
    /** @internal */
    this._rpcWebSocketConnected = false;
    /** @internal */
    this._rpcWebSocketHeartbeat = null;
    /** @internal */
    this._rpcWebSocketIdleTimeout = null;
    /** @internal
     * A number that we increment every time an active connection closes.
     * Used to determine whether the same socket connection that was open
     * when an async operation started is the same one that's active when
     * its continuation fires.
     *
     */
    this._rpcWebSocketGeneration = 0;
    /** @internal */
    this._disableBlockhashCaching = false;
    /** @internal */
    this._pollingBlockhash = false;
    /** @internal */
    this._blockhashInfo = {
      latestBlockhash: null,
      lastFetch: 0,
      transactionSignatures: [],
      simulatedSignatures: []
    };
    /** @internal */
    this._nextClientSubscriptionId = 0;
    /** @internal */
    this._subscriptionDisposeFunctionsByClientSubscriptionId = {};
    /** @internal */
    this._subscriptionHashByClientSubscriptionId = {};
    /** @internal */
    this._subscriptionStateChangeCallbacksByHash = {};
    /** @internal */
    this._subscriptionCallbacksByServerSubscriptionId = {};
    /** @internal */
    this._subscriptionsByHash = {};
    /**
     * Special case.
     * After a signature is processed, RPCs automatically dispose of the
     * subscription on the server side. We need to track which of these
     * subscriptions have been disposed in such a way, so that we know
     * whether the client is dealing with a not-yet-processed signature
     * (in which case we must tear down the server subscription) or an
     * already-processed signature (in which case the client can simply
     * clear out the subscription locally without telling the server).
     *
     * NOTE: There is a proposal to eliminate this special case, here:
     * https://github.com/solana-labs/solana/issues/18892
     */
    /** @internal */
    this._subscriptionsAutoDisposedByRpc = new Set();
    /*
     * Returns the current block height of the node
     */
    this.getBlockHeight = function () {
      var requestPromises = {};
      return /*#__PURE__*/function () {
        var _ref3 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee4(commitmentOrConfig) {
          var _requestPromises$requ;
          var _extractCommitmentFro, commitment, config, args, requestHash;
          return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee4$(_context4) {
            while (1) switch (_context4.prev = _context4.next) {
              case 0:
                _extractCommitmentFro = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro.commitment, config = _extractCommitmentFro.config;
                args = _this._buildArgs([], commitment, undefined /* encoding */, config);
                requestHash = fastStableStringify$1(args);
                requestPromises[requestHash] = (_requestPromises$requ = requestPromises[requestHash]) !== null && _requestPromises$requ !== void 0 ? _requestPromises$requ : (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee3() {
                  var unsafeRes, res;
                  return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee3$(_context3) {
                    while (1) switch (_context3.prev = _context3.next) {
                      case 0:
                        _context3.prev = 0;
                        _context3.next = 3;
                        return _this._rpcRequest('getBlockHeight', args);
                      case 3:
                        unsafeRes = _context3.sent;
                        res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()));
                        if (!('error' in res)) {
                          _context3.next = 7;
                          break;
                        }
                        throw new SolanaJSONRPCError(res.error, 'failed to get block height information');
                      case 7:
                        return _context3.abrupt("return", res.result);
                      case 8:
                        _context3.prev = 8;
                        delete requestPromises[requestHash];
                        return _context3.finish(8);
                      case 11:
                      case "end":
                        return _context3.stop();
                    }
                  }, _callee3, null, [[0,, 8, 11]]);
                }))();
                _context4.next = 6;
                return requestPromises[requestHash];
              case 6:
                return _context4.abrupt("return", _context4.sent);
              case 7:
              case "end":
                return _context4.stop();
            }
          }, _callee4);
        }));
        return function (_x5) {
          return _ref3.apply(this, arguments);
        };
      }();
    }();
    var wsEndpoint;
    var httpHeaders;
    var fetch;
    var fetchMiddleware;
    var disableRetryOnRateLimit;
    var httpAgent;
    if (_commitmentOrConfig && typeof _commitmentOrConfig === 'string') {
      this._commitment = _commitmentOrConfig;
    } else if (_commitmentOrConfig) {
      this._commitment = _commitmentOrConfig.commitment;
      this._confirmTransactionInitialTimeout = _commitmentOrConfig.confirmTransactionInitialTimeout;
      wsEndpoint = _commitmentOrConfig.wsEndpoint;
      httpHeaders = _commitmentOrConfig.httpHeaders;
      fetch = _commitmentOrConfig.fetch;
      fetchMiddleware = _commitmentOrConfig.fetchMiddleware;
      disableRetryOnRateLimit = _commitmentOrConfig.disableRetryOnRateLimit;
      httpAgent = _commitmentOrConfig.httpAgent;
    }
    this._rpcEndpoint = assertEndpointUrl(endpoint);
    this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint);
    this._rpcClient = createRpcClient(endpoint, httpHeaders, fetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent);
    this._rpcRequest = createRpcRequest(this._rpcClient);
    this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);
    this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {
      autoconnect: false,
      max_reconnects: Infinity
    });
    this._rpcWebSocket.on('open', this._wsOnOpen.bind(this));
    this._rpcWebSocket.on('error', this._wsOnError.bind(this));
    this._rpcWebSocket.on('close', this._wsOnClose.bind(this));
    this._rpcWebSocket.on('accountNotification', this._wsOnAccountNotification.bind(this));
    this._rpcWebSocket.on('programNotification', this._wsOnProgramAccountNotification.bind(this));
    this._rpcWebSocket.on('slotNotification', this._wsOnSlotNotification.bind(this));
    this._rpcWebSocket.on('slotsUpdatesNotification', this._wsOnSlotUpdatesNotification.bind(this));
    this._rpcWebSocket.on('signatureNotification', this._wsOnSignatureNotification.bind(this));
    this._rpcWebSocket.on('rootNotification', this._wsOnRootNotification.bind(this));
    this._rpcWebSocket.on('logsNotification', this._wsOnLogsNotification.bind(this));
  }

  /**
   * The default commitment used for requests
   */
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(Connection, [{
    key: "commitment",
    get: function get() {
      return this._commitment;
    }

    /**
     * The RPC endpoint
     */
  }, {
    key: "rpcEndpoint",
    get: function get() {
      return this._rpcEndpoint;
    }

    /**
     * Fetch the balance for the specified public key, return with context
     */
  }, {
    key: "getBalanceAndContext",
    value: function () {
      var _getBalanceAndContext = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee5(publicKey, commitmentOrConfig) {
        var _extractCommitmentFro2, commitment, config, args, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              /** @internal */
              _extractCommitmentFro2 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro2.commitment, config = _extractCommitmentFro2.config;
              args = this._buildArgs([publicKey.toBase58()], commitment, undefined /* encoding */, config);
              _context5.next = 4;
              return this._rpcRequest('getBalance', args);
            case 4:
              unsafeRes = _context5.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()));
              if (!('error' in res)) {
                _context5.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, "failed to get balance for ".concat(publicKey.toBase58()));
            case 8:
              return _context5.abrupt("return", res.result);
            case 9:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function getBalanceAndContext(_x6, _x7) {
        return _getBalanceAndContext.apply(this, arguments);
      }
      return getBalanceAndContext;
    }()
    /**
     * Fetch the balance for the specified public key
     */
  }, {
    key: "getBalance",
    value: function () {
      var _getBalance = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee6(publicKey, commitmentOrConfig) {
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return this.getBalanceAndContext(publicKey, commitmentOrConfig).then(function (x) {
                return x.value;
              })["catch"](function (e) {
                throw new Error('failed to get balance of account ' + publicKey.toBase58() + ': ' + e);
              });
            case 2:
              return _context6.abrupt("return", _context6.sent);
            case 3:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function getBalance(_x8, _x9) {
        return _getBalance.apply(this, arguments);
      }
      return getBalance;
    }()
    /**
     * Fetch the estimated production time of a block
     */
  }, {
    key: "getBlockTime",
    value: function () {
      var _getBlockTime = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee7(slot) {
        var unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _context7.next = 2;
              return this._rpcRequest('getBlockTime', [slot]);
            case 2:
              unsafeRes = _context7.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)())));
              if (!('error' in res)) {
                _context7.next = 6;
                break;
              }
              throw new SolanaJSONRPCError(res.error, "failed to get block time for slot ".concat(slot));
            case 6:
              return _context7.abrupt("return", res.result);
            case 7:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function getBlockTime(_x10) {
        return _getBlockTime.apply(this, arguments);
      }
      return getBlockTime;
    }()
    /**
     * Fetch the lowest slot that the node has information about in its ledger.
     * This value may increase over time if the node is configured to purge older ledger data
     */
  }, {
    key: "getMinimumLedgerSlot",
    value: function () {
      var _getMinimumLedgerSlot = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee8() {
        var unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              _context8.next = 2;
              return this._rpcRequest('minimumLedgerSlot', []);
            case 2:
              unsafeRes = _context8.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()));
              if (!('error' in res)) {
                _context8.next = 6;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get minimum ledger slot');
            case 6:
              return _context8.abrupt("return", res.result);
            case 7:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function getMinimumLedgerSlot() {
        return _getMinimumLedgerSlot.apply(this, arguments);
      }
      return getMinimumLedgerSlot;
    }()
    /**
     * Fetch the slot of the lowest confirmed block that has not been purged from the ledger
     */
  }, {
    key: "getFirstAvailableBlock",
    value: function () {
      var _getFirstAvailableBlock = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee9() {
        var unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              _context9.next = 2;
              return this._rpcRequest('getFirstAvailableBlock', []);
            case 2:
              unsafeRes = _context9.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, SlotRpcResult);
              if (!('error' in res)) {
                _context9.next = 6;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get first available block');
            case 6:
              return _context9.abrupt("return", res.result);
            case 7:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));
      function getFirstAvailableBlock() {
        return _getFirstAvailableBlock.apply(this, arguments);
      }
      return getFirstAvailableBlock;
    }()
    /**
     * Fetch information about the current supply
     */
  }, {
    key: "getSupply",
    value: function () {
      var _getSupply = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee10(config) {
        var configArg, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              configArg = {};
              if (typeof config === 'string') {
                configArg = {
                  commitment: config
                };
              } else if (config) {
                configArg = _objectSpread(_objectSpread({}, config), {}, {
                  commitment: config && config.commitment || this.commitment
                });
              } else {
                configArg = {
                  commitment: this.commitment
                };
              }
              _context10.next = 4;
              return this._rpcRequest('getSupply', [configArg]);
            case 4:
              unsafeRes = _context10.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetSupplyRpcResult);
              if (!('error' in res)) {
                _context10.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get supply');
            case 8:
              return _context10.abrupt("return", res.result);
            case 9:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function getSupply(_x11) {
        return _getSupply.apply(this, arguments);
      }
      return getSupply;
    }()
    /**
     * Fetch the current supply of a token mint
     */
  }, {
    key: "getTokenSupply",
    value: function () {
      var _getTokenSupply = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee11(tokenMintAddress, commitment) {
        var args, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              args = this._buildArgs([tokenMintAddress.toBase58()], commitment);
              _context11.next = 3;
              return this._rpcRequest('getTokenSupply', args);
            case 3:
              unsafeRes = _context11.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));
              if (!('error' in res)) {
                _context11.next = 7;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get token supply');
            case 7:
              return _context11.abrupt("return", res.result);
            case 8:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));
      function getTokenSupply(_x12, _x13) {
        return _getTokenSupply.apply(this, arguments);
      }
      return getTokenSupply;
    }()
    /**
     * Fetch the current balance of a token account
     */
  }, {
    key: "getTokenAccountBalance",
    value: function () {
      var _getTokenAccountBalance = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee12(tokenAddress, commitment) {
        var args, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              args = this._buildArgs([tokenAddress.toBase58()], commitment);
              _context12.next = 3;
              return this._rpcRequest('getTokenAccountBalance', args);
            case 3:
              unsafeRes = _context12.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));
              if (!('error' in res)) {
                _context12.next = 7;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get token account balance');
            case 7:
              return _context12.abrupt("return", res.result);
            case 8:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));
      function getTokenAccountBalance(_x14, _x15) {
        return _getTokenAccountBalance.apply(this, arguments);
      }
      return getTokenAccountBalance;
    }()
    /**
     * Fetch all the token accounts owned by the specified account
     *
     * @return {Promise<RpcResponseAndContext<GetProgramAccountsResponse>}
     */
  }, {
    key: "getTokenAccountsByOwner",
    value: function () {
      var _getTokenAccountsByOwner = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee13(ownerAddress, filter, commitmentOrConfig) {
        var _extractCommitmentFro3, commitment, config, _args, args, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              _extractCommitmentFro3 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro3.commitment, config = _extractCommitmentFro3.config;
              _args = [ownerAddress.toBase58()];
              if ('mint' in filter) {
                _args.push({
                  mint: filter.mint.toBase58()
                });
              } else {
                _args.push({
                  programId: filter.programId.toBase58()
                });
              }
              args = this._buildArgs(_args, commitment, 'base64', config);
              _context13.next = 6;
              return this._rpcRequest('getTokenAccountsByOwner', args);
            case 6:
              unsafeRes = _context13.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetTokenAccountsByOwner);
              if (!('error' in res)) {
                _context13.next = 10;
                break;
              }
              throw new SolanaJSONRPCError(res.error, "failed to get token accounts owned by account ".concat(ownerAddress.toBase58()));
            case 10:
              return _context13.abrupt("return", res.result);
            case 11:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this);
      }));
      function getTokenAccountsByOwner(_x16, _x17, _x18) {
        return _getTokenAccountsByOwner.apply(this, arguments);
      }
      return getTokenAccountsByOwner;
    }()
    /**
     * Fetch parsed token accounts owned by the specified account
     *
     * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}
     */
  }, {
    key: "getParsedTokenAccountsByOwner",
    value: function () {
      var _getParsedTokenAccountsByOwner = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee14(ownerAddress, filter, commitment) {
        var _args, args, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              _args = [ownerAddress.toBase58()];
              if ('mint' in filter) {
                _args.push({
                  mint: filter.mint.toBase58()
                });
              } else {
                _args.push({
                  programId: filter.programId.toBase58()
                });
              }
              args = this._buildArgs(_args, commitment, 'jsonParsed');
              _context14.next = 5;
              return this._rpcRequest('getTokenAccountsByOwner', args);
            case 5:
              unsafeRes = _context14.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetParsedTokenAccountsByOwner);
              if (!('error' in res)) {
                _context14.next = 9;
                break;
              }
              throw new SolanaJSONRPCError(res.error, "failed to get token accounts owned by account ".concat(ownerAddress.toBase58()));
            case 9:
              return _context14.abrupt("return", res.result);
            case 10:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this);
      }));
      function getParsedTokenAccountsByOwner(_x19, _x20, _x21) {
        return _getParsedTokenAccountsByOwner.apply(this, arguments);
      }
      return getParsedTokenAccountsByOwner;
    }()
    /**
     * Fetch the 20 largest accounts with their current balances
     */
  }, {
    key: "getLargestAccounts",
    value: function () {
      var _getLargestAccounts = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee15(config) {
        var arg, args, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee15$(_context15) {
          while (1) switch (_context15.prev = _context15.next) {
            case 0:
              arg = _objectSpread(_objectSpread({}, config), {}, {
                commitment: config && config.commitment || this.commitment
              });
              args = arg.filter || arg.commitment ? [arg] : [];
              _context15.next = 4;
              return this._rpcRequest('getLargestAccounts', args);
            case 4:
              unsafeRes = _context15.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetLargestAccountsRpcResult);
              if (!('error' in res)) {
                _context15.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get largest accounts');
            case 8:
              return _context15.abrupt("return", res.result);
            case 9:
            case "end":
              return _context15.stop();
          }
        }, _callee15, this);
      }));
      function getLargestAccounts(_x22) {
        return _getLargestAccounts.apply(this, arguments);
      }
      return getLargestAccounts;
    }()
    /**
     * Fetch the 20 largest token accounts with their current balances
     * for a given mint.
     */
  }, {
    key: "getTokenLargestAccounts",
    value: function () {
      var _getTokenLargestAccounts = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee16(mintAddress, commitment) {
        var args, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee16$(_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              args = this._buildArgs([mintAddress.toBase58()], commitment);
              _context16.next = 3;
              return this._rpcRequest('getTokenLargestAccounts', args);
            case 3:
              unsafeRes = _context16.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetTokenLargestAccountsResult);
              if (!('error' in res)) {
                _context16.next = 7;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get token largest accounts');
            case 7:
              return _context16.abrupt("return", res.result);
            case 8:
            case "end":
              return _context16.stop();
          }
        }, _callee16, this);
      }));
      function getTokenLargestAccounts(_x23, _x24) {
        return _getTokenLargestAccounts.apply(this, arguments);
      }
      return getTokenLargestAccounts;
    }()
    /**
     * Fetch all the account info for the specified public key, return with context
     */
  }, {
    key: "getAccountInfoAndContext",
    value: function () {
      var _getAccountInfoAndContext = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee17(publicKey, commitmentOrConfig) {
        var _extractCommitmentFro4, commitment, config, args, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee17$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              _extractCommitmentFro4 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro4.commitment, config = _extractCommitmentFro4.config;
              args = this._buildArgs([publicKey.toBase58()], commitment, 'base64', config);
              _context17.next = 4;
              return this._rpcRequest('getAccountInfo', args);
            case 4:
              unsafeRes = _context17.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)(AccountInfoResult)));
              if (!('error' in res)) {
                _context17.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, "failed to get info about account ".concat(publicKey.toBase58()));
            case 8:
              return _context17.abrupt("return", res.result);
            case 9:
            case "end":
              return _context17.stop();
          }
        }, _callee17, this);
      }));
      function getAccountInfoAndContext(_x25, _x26) {
        return _getAccountInfoAndContext.apply(this, arguments);
      }
      return getAccountInfoAndContext;
    }()
    /**
     * Fetch parsed account info for the specified public key
     */
  }, {
    key: "getParsedAccountInfo",
    value: function () {
      var _getParsedAccountInfo = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee18(publicKey, commitmentOrConfig) {
        var _extractCommitmentFro5, commitment, config, args, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee18$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              _extractCommitmentFro5 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro5.commitment, config = _extractCommitmentFro5.config;
              args = this._buildArgs([publicKey.toBase58()], commitment, 'jsonParsed', config);
              _context18.next = 4;
              return this._rpcRequest('getAccountInfo', args);
            case 4:
              unsafeRes = _context18.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)(ParsedAccountInfoResult)));
              if (!('error' in res)) {
                _context18.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, "failed to get info about account ".concat(publicKey.toBase58()));
            case 8:
              return _context18.abrupt("return", res.result);
            case 9:
            case "end":
              return _context18.stop();
          }
        }, _callee18, this);
      }));
      function getParsedAccountInfo(_x27, _x28) {
        return _getParsedAccountInfo.apply(this, arguments);
      }
      return getParsedAccountInfo;
    }()
    /**
     * Fetch all the account info for the specified public key
     */
  }, {
    key: "getAccountInfo",
    value: function () {
      var _getAccountInfo = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee19(publicKey, commitmentOrConfig) {
        var res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee19$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              _context19.prev = 0;
              _context19.next = 3;
              return this.getAccountInfoAndContext(publicKey, commitmentOrConfig);
            case 3:
              res = _context19.sent;
              return _context19.abrupt("return", res.value);
            case 7:
              _context19.prev = 7;
              _context19.t0 = _context19["catch"](0);
              throw new Error('failed to get info about account ' + publicKey.toBase58() + ': ' + _context19.t0);
            case 10:
            case "end":
              return _context19.stop();
          }
        }, _callee19, this, [[0, 7]]);
      }));
      function getAccountInfo(_x29, _x30) {
        return _getAccountInfo.apply(this, arguments);
      }
      return getAccountInfo;
    }()
    /**
     * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
     */
  }, {
    key: "getMultipleParsedAccounts",
    value: function () {
      var _getMultipleParsedAccounts = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee20(publicKeys, rawConfig) {
        var _extractCommitmentFro6, commitment, config, keys, args, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee20$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              _extractCommitmentFro6 = extractCommitmentFromConfig(rawConfig), commitment = _extractCommitmentFro6.commitment, config = _extractCommitmentFro6.config;
              keys = publicKeys.map(function (key) {
                return key.toBase58();
              });
              args = this._buildArgs([keys], commitment, 'jsonParsed', config);
              _context20.next = 5;
              return this._rpcRequest('getMultipleAccounts', args);
            case 5:
              unsafeRes = _context20.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)(ParsedAccountInfoResult))));
              if (!('error' in res)) {
                _context20.next = 9;
                break;
              }
              throw new SolanaJSONRPCError(res.error, "failed to get info for accounts ".concat(keys));
            case 9:
              return _context20.abrupt("return", res.result);
            case 10:
            case "end":
              return _context20.stop();
          }
        }, _callee20, this);
      }));
      function getMultipleParsedAccounts(_x31, _x32) {
        return _getMultipleParsedAccounts.apply(this, arguments);
      }
      return getMultipleParsedAccounts;
    }()
    /**
     * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
     */
  }, {
    key: "getMultipleAccountsInfoAndContext",
    value: function () {
      var _getMultipleAccountsInfoAndContext = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee21(publicKeys, commitmentOrConfig) {
        var _extractCommitmentFro7, commitment, config, keys, args, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee21$(_context21) {
          while (1) switch (_context21.prev = _context21.next) {
            case 0:
              _extractCommitmentFro7 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro7.commitment, config = _extractCommitmentFro7.config;
              keys = publicKeys.map(function (key) {
                return key.toBase58();
              });
              args = this._buildArgs([keys], commitment, 'base64', config);
              _context21.next = 5;
              return this._rpcRequest('getMultipleAccounts', args);
            case 5:
              unsafeRes = _context21.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)(AccountInfoResult))));
              if (!('error' in res)) {
                _context21.next = 9;
                break;
              }
              throw new SolanaJSONRPCError(res.error, "failed to get info for accounts ".concat(keys));
            case 9:
              return _context21.abrupt("return", res.result);
            case 10:
            case "end":
              return _context21.stop();
          }
        }, _callee21, this);
      }));
      function getMultipleAccountsInfoAndContext(_x33, _x34) {
        return _getMultipleAccountsInfoAndContext.apply(this, arguments);
      }
      return getMultipleAccountsInfoAndContext;
    }()
    /**
     * Fetch all the account info for multiple accounts specified by an array of public keys
     */
  }, {
    key: "getMultipleAccountsInfo",
    value: function () {
      var _getMultipleAccountsInfo = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee22(publicKeys, commitmentOrConfig) {
        var res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee22$(_context22) {
          while (1) switch (_context22.prev = _context22.next) {
            case 0:
              _context22.next = 2;
              return this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig);
            case 2:
              res = _context22.sent;
              return _context22.abrupt("return", res.value);
            case 4:
            case "end":
              return _context22.stop();
          }
        }, _callee22, this);
      }));
      function getMultipleAccountsInfo(_x35, _x36) {
        return _getMultipleAccountsInfo.apply(this, arguments);
      }
      return getMultipleAccountsInfo;
    }()
    /**
     * Returns epoch activation information for a stake account that has been delegated
     */
  }, {
    key: "getStakeActivation",
    value: function () {
      var _getStakeActivation = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee23(publicKey, commitmentOrConfig, epoch) {
        var _extractCommitmentFro8, commitment, config, args, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee23$(_context23) {
          while (1) switch (_context23.prev = _context23.next) {
            case 0:
              _extractCommitmentFro8 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro8.commitment, config = _extractCommitmentFro8.config;
              args = this._buildArgs([publicKey.toBase58()], commitment, undefined /* encoding */, _objectSpread(_objectSpread({}, config), {}, {
                epoch: epoch != null ? epoch : config === null || config === void 0 ? void 0 : config.epoch
              }));
              _context23.next = 4;
              return this._rpcRequest('getStakeActivation', args);
            case 4:
              unsafeRes = _context23.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, jsonRpcResult(StakeActivationResult));
              if (!('error' in res)) {
                _context23.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, "failed to get Stake Activation ".concat(publicKey.toBase58()));
            case 8:
              return _context23.abrupt("return", res.result);
            case 9:
            case "end":
              return _context23.stop();
          }
        }, _callee23, this);
      }));
      function getStakeActivation(_x37, _x38, _x39) {
        return _getStakeActivation.apply(this, arguments);
      }
      return getStakeActivation;
    }()
    /**
     * Fetch all the accounts owned by the specified program id
     *
     * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}
     */
  }, {
    key: "getProgramAccounts",
    value: // eslint-disable-next-line no-dupe-class-members
    function () {
      var _getProgramAccounts = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee24(programId, configOrCommitment) {
        var _extractCommitmentFro9, commitment, config, _ref5, encoding, configWithoutEncoding, args, unsafeRes, baseSchema, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee24$(_context24) {
          while (1) switch (_context24.prev = _context24.next) {
            case 0:
              _extractCommitmentFro9 = extractCommitmentFromConfig(configOrCommitment), commitment = _extractCommitmentFro9.commitment, config = _extractCommitmentFro9.config;
              _ref5 = config || {}, encoding = _ref5.encoding, configWithoutEncoding = (0,_babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_24__/* ["default"] */ .Z)(_ref5, _excluded2);
              args = this._buildArgs([programId.toBase58()], commitment, encoding || 'base64', configWithoutEncoding);
              _context24.next = 5;
              return this._rpcRequest('getProgramAccounts', args);
            case 5:
              unsafeRes = _context24.sent;
              baseSchema = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)(KeyedAccountInfoResult);
              res = configWithoutEncoding.withContext === true ? (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, jsonRpcResultAndContext(baseSchema)) : (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, jsonRpcResult(baseSchema));
              if (!('error' in res)) {
                _context24.next = 10;
                break;
              }
              throw new SolanaJSONRPCError(res.error, "failed to get accounts owned by program ".concat(programId.toBase58()));
            case 10:
              return _context24.abrupt("return", res.result);
            case 11:
            case "end":
              return _context24.stop();
          }
        }, _callee24, this);
      }));
      function getProgramAccounts(_x40, _x41) {
        return _getProgramAccounts.apply(this, arguments);
      }
      return getProgramAccounts;
    }()
    /**
     * Fetch and parse all the accounts owned by the specified program id
     *
     * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}
     */
  }, {
    key: "getParsedProgramAccounts",
    value: function () {
      var _getParsedProgramAccounts = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee25(programId, configOrCommitment) {
        var _extractCommitmentFro10, commitment, config, args, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee25$(_context25) {
          while (1) switch (_context25.prev = _context25.next) {
            case 0:
              _extractCommitmentFro10 = extractCommitmentFromConfig(configOrCommitment), commitment = _extractCommitmentFro10.commitment, config = _extractCommitmentFro10.config;
              args = this._buildArgs([programId.toBase58()], commitment, 'jsonParsed', config);
              _context25.next = 4;
              return this._rpcRequest('getProgramAccounts', args);
            case 4:
              unsafeRes = _context25.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)(KeyedParsedAccountInfoResult)));
              if (!('error' in res)) {
                _context25.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, "failed to get accounts owned by program ".concat(programId.toBase58()));
            case 8:
              return _context25.abrupt("return", res.result);
            case 9:
            case "end":
              return _context25.stop();
          }
        }, _callee25, this);
      }));
      function getParsedProgramAccounts(_x42, _x43) {
        return _getParsedProgramAccounts.apply(this, arguments);
      }
      return getParsedProgramAccounts;
    }()
  }, {
    key: "confirmTransaction",
    value: // eslint-disable-next-line no-dupe-class-members
    function () {
      var _confirmTransaction = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee26(strategy, commitment) {
        var rawSignature, _config$abortSignal, _config, decodedSignature;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee26$(_context26) {
          while (1) switch (_context26.prev = _context26.next) {
            case 0:
              if (!(typeof strategy == 'string')) {
                _context26.next = 4;
                break;
              }
              rawSignature = strategy;
              _context26.next = 8;
              break;
            case 4:
              _config = strategy;
              if (!((_config$abortSignal = _config.abortSignal) !== null && _config$abortSignal !== void 0 && _config$abortSignal.aborted)) {
                _context26.next = 7;
                break;
              }
              return _context26.abrupt("return", Promise.reject(_config.abortSignal.reason));
            case 7:
              rawSignature = _config.signature;
            case 8:
              _context26.prev = 8;
              decodedSignature = bs58__WEBPACK_IMPORTED_MODULE_3___default().decode(rawSignature);
              _context26.next = 15;
              break;
            case 12:
              _context26.prev = 12;
              _context26.t0 = _context26["catch"](8);
              throw new Error('signature must be base58 encoded: ' + rawSignature);
            case 15:
              assert(decodedSignature.length === 64, 'signature has invalid length');
              if (!(typeof strategy === 'string')) {
                _context26.next = 22;
                break;
              }
              _context26.next = 19;
              return this.confirmTransactionUsingLegacyTimeoutStrategy({
                commitment: commitment || this.commitment,
                signature: rawSignature
              });
            case 19:
              return _context26.abrupt("return", _context26.sent);
            case 22:
              if (!('lastValidBlockHeight' in strategy)) {
                _context26.next = 28;
                break;
              }
              _context26.next = 25;
              return this.confirmTransactionUsingBlockHeightExceedanceStrategy({
                commitment: commitment || this.commitment,
                strategy: strategy
              });
            case 25:
              return _context26.abrupt("return", _context26.sent);
            case 28:
              _context26.next = 30;
              return this.confirmTransactionUsingDurableNonceStrategy({
                commitment: commitment || this.commitment,
                strategy: strategy
              });
            case 30:
              return _context26.abrupt("return", _context26.sent);
            case 31:
            case "end":
              return _context26.stop();
          }
        }, _callee26, this, [[8, 12]]);
      }));
      function confirmTransaction(_x44, _x45) {
        return _confirmTransaction.apply(this, arguments);
      }
      return confirmTransaction;
    }()
  }, {
    key: "getCancellationPromise",
    value: function getCancellationPromise(signal) {
      return new Promise(function (_, reject) {
        if (signal == null) {
          return;
        }
        if (signal.aborted) {
          reject(signal.reason);
        } else {
          signal.addEventListener('abort', function () {
            reject(signal.reason);
          });
        }
      });
    }
  }, {
    key: "getTransactionConfirmationPromise",
    value: function getTransactionConfirmationPromise(_ref6) {
      var _this2 = this;
      var commitment = _ref6.commitment,
        signature = _ref6.signature;
      var signatureSubscriptionId;
      var disposeSignatureSubscriptionStateChangeObserver;
      var done = false;
      var confirmationPromise = new Promise(function (resolve, reject) {
        try {
          signatureSubscriptionId = _this2.onSignature(signature, function (result, context) {
            signatureSubscriptionId = undefined;
            var response = {
              context: context,
              value: result
            };
            resolve({
              __type: TransactionStatus.PROCESSED,
              response: response
            });
          }, commitment);
          var subscriptionSetupPromise = new Promise(function (resolveSubscriptionSetup) {
            if (signatureSubscriptionId == null) {
              resolveSubscriptionSetup();
            } else {
              disposeSignatureSubscriptionStateChangeObserver = _this2._onSubscriptionStateChange(signatureSubscriptionId, function (nextState) {
                if (nextState === 'subscribed') {
                  resolveSubscriptionSetup();
                }
              });
            }
          });
          (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee27() {
            var response, context, value;
            return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee27$(_context27) {
              while (1) switch (_context27.prev = _context27.next) {
                case 0:
                  _context27.next = 2;
                  return subscriptionSetupPromise;
                case 2:
                  if (!done) {
                    _context27.next = 4;
                    break;
                  }
                  return _context27.abrupt("return");
                case 4:
                  _context27.next = 6;
                  return _this2.getSignatureStatus(signature);
                case 6:
                  response = _context27.sent;
                  if (!done) {
                    _context27.next = 9;
                    break;
                  }
                  return _context27.abrupt("return");
                case 9:
                  if (!(response == null)) {
                    _context27.next = 11;
                    break;
                  }
                  return _context27.abrupt("return");
                case 11:
                  context = response.context, value = response.value;
                  if (!(value == null)) {
                    _context27.next = 14;
                    break;
                  }
                  return _context27.abrupt("return");
                case 14:
                  if (!(value !== null && value !== void 0 && value.err)) {
                    _context27.next = 18;
                    break;
                  }
                  reject(value.err);
                  _context27.next = 29;
                  break;
                case 18:
                  _context27.t0 = commitment;
                  _context27.next = _context27.t0 === 'confirmed' ? 21 : _context27.t0 === 'single' ? 21 : _context27.t0 === 'singleGossip' ? 21 : _context27.t0 === 'finalized' ? 24 : _context27.t0 === 'max' ? 24 : _context27.t0 === 'root' ? 24 : _context27.t0 === 'processed' ? 27 : _context27.t0 === 'recent' ? 27 : 27;
                  break;
                case 21:
                  if (!(value.confirmationStatus === 'processed')) {
                    _context27.next = 23;
                    break;
                  }
                  return _context27.abrupt("return");
                case 23:
                  return _context27.abrupt("break", 27);
                case 24:
                  if (!(value.confirmationStatus === 'processed' || value.confirmationStatus === 'confirmed')) {
                    _context27.next = 26;
                    break;
                  }
                  return _context27.abrupt("return");
                case 26:
                  return _context27.abrupt("break", 27);
                case 27:
                  done = true;
                  resolve({
                    __type: TransactionStatus.PROCESSED,
                    response: {
                      context: context,
                      value: value
                    }
                  });
                case 29:
                case "end":
                  return _context27.stop();
              }
            }, _callee27);
          }))();
        } catch (err) {
          reject(err);
        }
      });
      var abortConfirmation = function abortConfirmation() {
        if (disposeSignatureSubscriptionStateChangeObserver) {
          disposeSignatureSubscriptionStateChangeObserver();
          disposeSignatureSubscriptionStateChangeObserver = undefined;
        }
        if (signatureSubscriptionId != null) {
          _this2.removeSignatureListener(signatureSubscriptionId);
          signatureSubscriptionId = undefined;
        }
      };
      return {
        abortConfirmation: abortConfirmation,
        confirmationPromise: confirmationPromise
      };
    }
  }, {
    key: "confirmTransactionUsingBlockHeightExceedanceStrategy",
    value: function () {
      var _confirmTransactionUsingBlockHeightExceedanceStrategy = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee30(_ref8) {
        var _this3 = this;
        var commitment, _ref8$strategy, abortSignal, lastValidBlockHeight, signature, done, expiryPromise, _this$getTransactionC, abortConfirmation, confirmationPromise, cancellationPromise, result, outcome;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee30$(_context30) {
          while (1) switch (_context30.prev = _context30.next) {
            case 0:
              commitment = _ref8.commitment, _ref8$strategy = _ref8.strategy, abortSignal = _ref8$strategy.abortSignal, lastValidBlockHeight = _ref8$strategy.lastValidBlockHeight, signature = _ref8$strategy.signature;
              done = false;
              expiryPromise = new Promise(function (resolve) {
                var checkBlockHeight = /*#__PURE__*/function () {
                  var _ref9 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee28() {
                    var blockHeight;
                    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee28$(_context28) {
                      while (1) switch (_context28.prev = _context28.next) {
                        case 0:
                          _context28.prev = 0;
                          _context28.next = 3;
                          return _this3.getBlockHeight(commitment);
                        case 3:
                          blockHeight = _context28.sent;
                          return _context28.abrupt("return", blockHeight);
                        case 7:
                          _context28.prev = 7;
                          _context28.t0 = _context28["catch"](0);
                          return _context28.abrupt("return", -1);
                        case 10:
                        case "end":
                          return _context28.stop();
                      }
                    }, _callee28, null, [[0, 7]]);
                  }));
                  return function checkBlockHeight() {
                    return _ref9.apply(this, arguments);
                  };
                }();
                (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee29() {
                  var currentBlockHeight;
                  return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee29$(_context29) {
                    while (1) switch (_context29.prev = _context29.next) {
                      case 0:
                        _context29.next = 2;
                        return checkBlockHeight();
                      case 2:
                        currentBlockHeight = _context29.sent;
                        if (!done) {
                          _context29.next = 5;
                          break;
                        }
                        return _context29.abrupt("return");
                      case 5:
                        if (!(currentBlockHeight <= lastValidBlockHeight)) {
                          _context29.next = 17;
                          break;
                        }
                        _context29.next = 8;
                        return sleep(1000);
                      case 8:
                        if (!done) {
                          _context29.next = 10;
                          break;
                        }
                        return _context29.abrupt("return");
                      case 10:
                        _context29.next = 12;
                        return checkBlockHeight();
                      case 12:
                        currentBlockHeight = _context29.sent;
                        if (!done) {
                          _context29.next = 15;
                          break;
                        }
                        return _context29.abrupt("return");
                      case 15:
                        _context29.next = 5;
                        break;
                      case 17:
                        resolve({
                          __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED
                        });
                      case 18:
                      case "end":
                        return _context29.stop();
                    }
                  }, _callee29);
                }))();
              });
              _this$getTransactionC = this.getTransactionConfirmationPromise({
                commitment: commitment,
                signature: signature
              }), abortConfirmation = _this$getTransactionC.abortConfirmation, confirmationPromise = _this$getTransactionC.confirmationPromise;
              cancellationPromise = this.getCancellationPromise(abortSignal);
              _context30.prev = 5;
              _context30.next = 8;
              return Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);
            case 8:
              outcome = _context30.sent;
              if (!(outcome.__type === TransactionStatus.PROCESSED)) {
                _context30.next = 13;
                break;
              }
              result = outcome.response;
              _context30.next = 14;
              break;
            case 13:
              throw new TransactionExpiredBlockheightExceededError(signature);
            case 14:
              _context30.prev = 14;
              done = true;
              abortConfirmation();
              return _context30.finish(14);
            case 18:
              return _context30.abrupt("return", result);
            case 19:
            case "end":
              return _context30.stop();
          }
        }, _callee30, this, [[5,, 14, 18]]);
      }));
      function confirmTransactionUsingBlockHeightExceedanceStrategy(_x46) {
        return _confirmTransactionUsingBlockHeightExceedanceStrategy.apply(this, arguments);
      }
      return confirmTransactionUsingBlockHeightExceedanceStrategy;
    }()
  }, {
    key: "confirmTransactionUsingDurableNonceStrategy",
    value: function () {
      var _confirmTransactionUsingDurableNonceStrategy = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee33(_ref11) {
        var _this4 = this;
        var commitment, _ref11$strategy, abortSignal, minContextSlot, nonceAccountPubkey, nonceValue, signature, done, expiryPromise, _this$getTransactionC2, abortConfirmation, confirmationPromise, cancellationPromise, result, outcome, _signatureStatus, signatureStatus, _outcome$slotInWhichN, status, commitmentForStatus, confirmationStatus;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee33$(_context34) {
          while (1) switch (_context34.prev = _context34.next) {
            case 0:
              commitment = _ref11.commitment, _ref11$strategy = _ref11.strategy, abortSignal = _ref11$strategy.abortSignal, minContextSlot = _ref11$strategy.minContextSlot, nonceAccountPubkey = _ref11$strategy.nonceAccountPubkey, nonceValue = _ref11$strategy.nonceValue, signature = _ref11$strategy.signature;
              done = false;
              expiryPromise = new Promise(function (resolve) {
                var currentNonceValue = nonceValue;
                var lastCheckedSlot = null;
                var getCurrentNonceValue = /*#__PURE__*/function () {
                  var _ref12 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee31() {
                    var _yield$_this4$getNonc, _context31, nonceAccount;
                    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee31$(_context32) {
                      while (1) switch (_context32.prev = _context32.next) {
                        case 0:
                          _context32.prev = 0;
                          _context32.next = 3;
                          return _this4.getNonceAndContext(nonceAccountPubkey, {
                            commitment: commitment,
                            minContextSlot: minContextSlot
                          });
                        case 3:
                          _yield$_this4$getNonc = _context32.sent;
                          _context31 = _yield$_this4$getNonc.context;
                          nonceAccount = _yield$_this4$getNonc.value;
                          lastCheckedSlot = _context31.slot;
                          return _context32.abrupt("return", nonceAccount === null || nonceAccount === void 0 ? void 0 : nonceAccount.nonce);
                        case 10:
                          _context32.prev = 10;
                          _context32.t0 = _context32["catch"](0);
                          return _context32.abrupt("return", currentNonceValue);
                        case 13:
                        case "end":
                          return _context32.stop();
                      }
                    }, _callee31, null, [[0, 10]]);
                  }));
                  return function getCurrentNonceValue() {
                    return _ref12.apply(this, arguments);
                  };
                }();
                (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee32() {
                  return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee32$(_context33) {
                    while (1) switch (_context33.prev = _context33.next) {
                      case 0:
                        _context33.next = 2;
                        return getCurrentNonceValue();
                      case 2:
                        currentNonceValue = _context33.sent;
                        if (!done) {
                          _context33.next = 5;
                          break;
                        }
                        return _context33.abrupt("return");
                      case 5:
                        if (!(nonceValue !== currentNonceValue)) {
                          _context33.next = 9;
                          break;
                        }
                        resolve({
                          __type: TransactionStatus.NONCE_INVALID,
                          slotInWhichNonceDidAdvance: lastCheckedSlot
                        });
                        return _context33.abrupt("return");
                      case 9:
                        _context33.next = 11;
                        return sleep(2000);
                      case 11:
                        if (!done) {
                          _context33.next = 13;
                          break;
                        }
                        return _context33.abrupt("return");
                      case 13:
                        _context33.next = 15;
                        return getCurrentNonceValue();
                      case 15:
                        currentNonceValue = _context33.sent;
                        if (!done) {
                          _context33.next = 18;
                          break;
                        }
                        return _context33.abrupt("return");
                      case 18:
                        _context33.next = 5;
                        break;
                      case 20:
                      case "end":
                        return _context33.stop();
                    }
                  }, _callee32);
                }))();
              });
              _this$getTransactionC2 = this.getTransactionConfirmationPromise({
                commitment: commitment,
                signature: signature
              }), abortConfirmation = _this$getTransactionC2.abortConfirmation, confirmationPromise = _this$getTransactionC2.confirmationPromise;
              cancellationPromise = this.getCancellationPromise(abortSignal);
              _context34.prev = 5;
              _context34.next = 8;
              return Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);
            case 8:
              outcome = _context34.sent;
              if (!(outcome.__type === TransactionStatus.PROCESSED)) {
                _context34.next = 13;
                break;
              }
              result = outcome.response;
              _context34.next = 47;
              break;
            case 13:
              _context34.next = 16;
              return this.getSignatureStatus(signature);
            case 16:
              status = _context34.sent;
              if (!(status == null)) {
                _context34.next = 19;
                break;
              }
              return _context34.abrupt("break", 27);
            case 19:
              if (!(status.context.slot < ((_outcome$slotInWhichN = outcome.slotInWhichNonceDidAdvance) !== null && _outcome$slotInWhichN !== void 0 ? _outcome$slotInWhichN : minContextSlot))) {
                _context34.next = 23;
                break;
              }
              _context34.next = 22;
              return sleep(400);
            case 22:
              return _context34.abrupt("continue", 13);
            case 23:
              signatureStatus = status;
              return _context34.abrupt("break", 27);
            case 27:
              if (!((_signatureStatus = signatureStatus) !== null && _signatureStatus !== void 0 && _signatureStatus.value)) {
                _context34.next = 46;
                break;
              }
              commitmentForStatus = commitment || 'finalized';
              confirmationStatus = signatureStatus.value.confirmationStatus;
              _context34.t0 = commitmentForStatus;
              _context34.next = _context34.t0 === 'processed' ? 33 : _context34.t0 === 'recent' ? 33 : _context34.t0 === 'confirmed' ? 36 : _context34.t0 === 'single' ? 36 : _context34.t0 === 'singleGossip' ? 36 : _context34.t0 === 'finalized' ? 39 : _context34.t0 === 'max' ? 39 : _context34.t0 === 'root' ? 39 : 42;
              break;
            case 33:
              if (!(confirmationStatus !== 'processed' && confirmationStatus !== 'confirmed' && confirmationStatus !== 'finalized')) {
                _context34.next = 35;
                break;
              }
              throw new TransactionExpiredNonceInvalidError(signature);
            case 35:
              return _context34.abrupt("break", 43);
            case 36:
              if (!(confirmationStatus !== 'confirmed' && confirmationStatus !== 'finalized')) {
                _context34.next = 38;
                break;
              }
              throw new TransactionExpiredNonceInvalidError(signature);
            case 38:
              return _context34.abrupt("break", 43);
            case 39:
              if (!(confirmationStatus !== 'finalized')) {
                _context34.next = 41;
                break;
              }
              throw new TransactionExpiredNonceInvalidError(signature);
            case 41:
              return _context34.abrupt("break", 43);
            case 42:
            case 43:
              result = {
                context: signatureStatus.context,
                value: {
                  err: signatureStatus.value.err
                }
              };
              _context34.next = 47;
              break;
            case 46:
              throw new TransactionExpiredNonceInvalidError(signature);
            case 47:
              _context34.prev = 47;
              done = true;
              abortConfirmation();
              return _context34.finish(47);
            case 51:
              return _context34.abrupt("return", result);
            case 52:
            case "end":
              return _context34.stop();
          }
        }, _callee33, this, [[5,, 47, 51]]);
      }));
      function confirmTransactionUsingDurableNonceStrategy(_x47) {
        return _confirmTransactionUsingDurableNonceStrategy.apply(this, arguments);
      }
      return confirmTransactionUsingDurableNonceStrategy;
    }()
  }, {
    key: "confirmTransactionUsingLegacyTimeoutStrategy",
    value: function () {
      var _confirmTransactionUsingLegacyTimeoutStrategy = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee34(_ref14) {
        var _this5 = this;
        var commitment, signature, timeoutId, expiryPromise, _this$getTransactionC3, abortConfirmation, confirmationPromise, result, outcome;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee34$(_context35) {
          while (1) switch (_context35.prev = _context35.next) {
            case 0:
              commitment = _ref14.commitment, signature = _ref14.signature;
              expiryPromise = new Promise(function (resolve) {
                var timeoutMs = _this5._confirmTransactionInitialTimeout || 60 * 1000;
                switch (commitment) {
                  case 'processed':
                  case 'recent':
                  case 'single':
                  case 'confirmed':
                  case 'singleGossip':
                    {
                      timeoutMs = _this5._confirmTransactionInitialTimeout || 30 * 1000;
                      break;
                    }
                }
                timeoutId = setTimeout(function () {
                  return resolve({
                    __type: TransactionStatus.TIMED_OUT,
                    timeoutMs: timeoutMs
                  });
                }, timeoutMs);
              });
              _this$getTransactionC3 = this.getTransactionConfirmationPromise({
                commitment: commitment,
                signature: signature
              }), abortConfirmation = _this$getTransactionC3.abortConfirmation, confirmationPromise = _this$getTransactionC3.confirmationPromise;
              _context35.prev = 3;
              _context35.next = 6;
              return Promise.race([confirmationPromise, expiryPromise]);
            case 6:
              outcome = _context35.sent;
              if (!(outcome.__type === TransactionStatus.PROCESSED)) {
                _context35.next = 11;
                break;
              }
              result = outcome.response;
              _context35.next = 12;
              break;
            case 11:
              throw new TransactionExpiredTimeoutError(signature, outcome.timeoutMs / 1000);
            case 12:
              _context35.prev = 12;
              clearTimeout(timeoutId);
              abortConfirmation();
              return _context35.finish(12);
            case 16:
              return _context35.abrupt("return", result);
            case 17:
            case "end":
              return _context35.stop();
          }
        }, _callee34, this, [[3,, 12, 16]]);
      }));
      function confirmTransactionUsingLegacyTimeoutStrategy(_x48) {
        return _confirmTransactionUsingLegacyTimeoutStrategy.apply(this, arguments);
      }
      return confirmTransactionUsingLegacyTimeoutStrategy;
    }()
    /**
     * Return the list of nodes that are currently participating in the cluster
     */
  }, {
    key: "getClusterNodes",
    value: function () {
      var _getClusterNodes = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee35() {
        var unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee35$(_context36) {
          while (1) switch (_context36.prev = _context36.next) {
            case 0:
              _context36.next = 2;
              return this._rpcRequest('getClusterNodes', []);
            case 2:
              unsafeRes = _context36.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)(ContactInfoResult)));
              if (!('error' in res)) {
                _context36.next = 6;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get cluster nodes');
            case 6:
              return _context36.abrupt("return", res.result);
            case 7:
            case "end":
              return _context36.stop();
          }
        }, _callee35, this);
      }));
      function getClusterNodes() {
        return _getClusterNodes.apply(this, arguments);
      }
      return getClusterNodes;
    }()
    /**
     * Return the list of nodes that are currently participating in the cluster
     */
  }, {
    key: "getVoteAccounts",
    value: function () {
      var _getVoteAccounts = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee36(commitment) {
        var args, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee36$(_context37) {
          while (1) switch (_context37.prev = _context37.next) {
            case 0:
              args = this._buildArgs([], commitment);
              _context37.next = 3;
              return this._rpcRequest('getVoteAccounts', args);
            case 3:
              unsafeRes = _context37.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetVoteAccounts);
              if (!('error' in res)) {
                _context37.next = 7;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get vote accounts');
            case 7:
              return _context37.abrupt("return", res.result);
            case 8:
            case "end":
              return _context37.stop();
          }
        }, _callee36, this);
      }));
      function getVoteAccounts(_x49) {
        return _getVoteAccounts.apply(this, arguments);
      }
      return getVoteAccounts;
    }()
    /**
     * Fetch the current slot that the node is processing
     */
  }, {
    key: "getSlot",
    value: function () {
      var _getSlot = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee37(commitmentOrConfig) {
        var _extractCommitmentFro11, commitment, config, args, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee37$(_context38) {
          while (1) switch (_context38.prev = _context38.next) {
            case 0:
              _extractCommitmentFro11 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro11.commitment, config = _extractCommitmentFro11.config;
              args = this._buildArgs([], commitment, undefined /* encoding */, config);
              _context38.next = 4;
              return this._rpcRequest('getSlot', args);
            case 4:
              unsafeRes = _context38.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()));
              if (!('error' in res)) {
                _context38.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get slot');
            case 8:
              return _context38.abrupt("return", res.result);
            case 9:
            case "end":
              return _context38.stop();
          }
        }, _callee37, this);
      }));
      function getSlot(_x50) {
        return _getSlot.apply(this, arguments);
      }
      return getSlot;
    }()
    /**
     * Fetch the current slot leader of the cluster
     */
  }, {
    key: "getSlotLeader",
    value: function () {
      var _getSlotLeader = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee38(commitmentOrConfig) {
        var _extractCommitmentFro12, commitment, config, args, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee38$(_context39) {
          while (1) switch (_context39.prev = _context39.next) {
            case 0:
              _extractCommitmentFro12 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro12.commitment, config = _extractCommitmentFro12.config;
              args = this._buildArgs([], commitment, undefined /* encoding */, config);
              _context39.next = 4;
              return this._rpcRequest('getSlotLeader', args);
            case 4:
              unsafeRes = _context39.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)()));
              if (!('error' in res)) {
                _context39.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get slot leader');
            case 8:
              return _context39.abrupt("return", res.result);
            case 9:
            case "end":
              return _context39.stop();
          }
        }, _callee38, this);
      }));
      function getSlotLeader(_x51) {
        return _getSlotLeader.apply(this, arguments);
      }
      return getSlotLeader;
    }()
    /**
     * Fetch `limit` number of slot leaders starting from `startSlot`
     *
     * @param startSlot fetch slot leaders starting from this slot
     * @param limit number of slot leaders to return
     */
  }, {
    key: "getSlotLeaders",
    value: function () {
      var _getSlotLeaders = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee39(startSlot, limit) {
        var args, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee39$(_context40) {
          while (1) switch (_context40.prev = _context40.next) {
            case 0:
              args = [startSlot, limit];
              _context40.next = 3;
              return this._rpcRequest('getSlotLeaders', args);
            case 3:
              unsafeRes = _context40.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)(PublicKeyFromString)));
              if (!('error' in res)) {
                _context40.next = 7;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get slot leaders');
            case 7:
              return _context40.abrupt("return", res.result);
            case 8:
            case "end":
              return _context40.stop();
          }
        }, _callee39, this);
      }));
      function getSlotLeaders(_x52, _x53) {
        return _getSlotLeaders.apply(this, arguments);
      }
      return getSlotLeaders;
    }()
    /**
     * Fetch the current status of a signature
     */
  }, {
    key: "getSignatureStatus",
    value: function () {
      var _getSignatureStatus = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee40(signature, config) {
        var _yield$this$getSignat, context, values, value;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee40$(_context41) {
          while (1) switch (_context41.prev = _context41.next) {
            case 0:
              _context41.next = 2;
              return this.getSignatureStatuses([signature], config);
            case 2:
              _yield$this$getSignat = _context41.sent;
              context = _yield$this$getSignat.context;
              values = _yield$this$getSignat.value;
              assert(values.length === 1);
              value = values[0];
              return _context41.abrupt("return", {
                context: context,
                value: value
              });
            case 8:
            case "end":
              return _context41.stop();
          }
        }, _callee40, this);
      }));
      function getSignatureStatus(_x54, _x55) {
        return _getSignatureStatus.apply(this, arguments);
      }
      return getSignatureStatus;
    }()
    /**
     * Fetch the current statuses of a batch of signatures
     */
  }, {
    key: "getSignatureStatuses",
    value: function () {
      var _getSignatureStatuses = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee41(signatures, config) {
        var params, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee41$(_context42) {
          while (1) switch (_context42.prev = _context42.next) {
            case 0:
              params = [signatures];
              if (config) {
                params.push(config);
              }
              _context42.next = 4;
              return this._rpcRequest('getSignatureStatuses', params);
            case 4:
              unsafeRes = _context42.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetSignatureStatusesRpcResult);
              if (!('error' in res)) {
                _context42.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get signature status');
            case 8:
              return _context42.abrupt("return", res.result);
            case 9:
            case "end":
              return _context42.stop();
          }
        }, _callee41, this);
      }));
      function getSignatureStatuses(_x56, _x57) {
        return _getSignatureStatuses.apply(this, arguments);
      }
      return getSignatureStatuses;
    }()
    /**
     * Fetch the current transaction count of the cluster
     */
  }, {
    key: "getTransactionCount",
    value: function () {
      var _getTransactionCount = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee42(commitmentOrConfig) {
        var _extractCommitmentFro13, commitment, config, args, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee42$(_context43) {
          while (1) switch (_context43.prev = _context43.next) {
            case 0:
              _extractCommitmentFro13 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro13.commitment, config = _extractCommitmentFro13.config;
              args = this._buildArgs([], commitment, undefined /* encoding */, config);
              _context43.next = 4;
              return this._rpcRequest('getTransactionCount', args);
            case 4:
              unsafeRes = _context43.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()));
              if (!('error' in res)) {
                _context43.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get transaction count');
            case 8:
              return _context43.abrupt("return", res.result);
            case 9:
            case "end":
              return _context43.stop();
          }
        }, _callee42, this);
      }));
      function getTransactionCount(_x58) {
        return _getTransactionCount.apply(this, arguments);
      }
      return getTransactionCount;
    }()
    /**
     * Fetch the current total currency supply of the cluster in lamports
     *
     * @deprecated Deprecated since v1.2.8. Please use {@link getSupply} instead.
     */
  }, {
    key: "getTotalSupply",
    value: function () {
      var _getTotalSupply = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee43(commitment) {
        var result;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee43$(_context44) {
          while (1) switch (_context44.prev = _context44.next) {
            case 0:
              _context44.next = 2;
              return this.getSupply({
                commitment: commitment,
                excludeNonCirculatingAccountsList: true
              });
            case 2:
              result = _context44.sent;
              return _context44.abrupt("return", result.value.total);
            case 4:
            case "end":
              return _context44.stop();
          }
        }, _callee43, this);
      }));
      function getTotalSupply(_x59) {
        return _getTotalSupply.apply(this, arguments);
      }
      return getTotalSupply;
    }()
    /**
     * Fetch the cluster InflationGovernor parameters
     */
  }, {
    key: "getInflationGovernor",
    value: function () {
      var _getInflationGovernor = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee44(commitment) {
        var args, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee44$(_context45) {
          while (1) switch (_context45.prev = _context45.next) {
            case 0:
              args = this._buildArgs([], commitment);
              _context45.next = 3;
              return this._rpcRequest('getInflationGovernor', args);
            case 3:
              unsafeRes = _context45.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetInflationGovernorRpcResult);
              if (!('error' in res)) {
                _context45.next = 7;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get inflation');
            case 7:
              return _context45.abrupt("return", res.result);
            case 8:
            case "end":
              return _context45.stop();
          }
        }, _callee44, this);
      }));
      function getInflationGovernor(_x60) {
        return _getInflationGovernor.apply(this, arguments);
      }
      return getInflationGovernor;
    }()
    /**
     * Fetch the inflation reward for a list of addresses for an epoch
     */
  }, {
    key: "getInflationReward",
    value: function () {
      var _getInflationReward = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee45(addresses, epoch, commitmentOrConfig) {
        var _extractCommitmentFro14, commitment, config, args, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee45$(_context46) {
          while (1) switch (_context46.prev = _context46.next) {
            case 0:
              _extractCommitmentFro14 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro14.commitment, config = _extractCommitmentFro14.config;
              args = this._buildArgs([addresses.map(function (pubkey) {
                return pubkey.toBase58();
              })], commitment, undefined /* encoding */, _objectSpread(_objectSpread({}, config), {}, {
                epoch: epoch != null ? epoch : config === null || config === void 0 ? void 0 : config.epoch
              }));
              _context46.next = 4;
              return this._rpcRequest('getInflationReward', args);
            case 4:
              unsafeRes = _context46.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetInflationRewardResult);
              if (!('error' in res)) {
                _context46.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get inflation reward');
            case 8:
              return _context46.abrupt("return", res.result);
            case 9:
            case "end":
              return _context46.stop();
          }
        }, _callee45, this);
      }));
      function getInflationReward(_x61, _x62, _x63) {
        return _getInflationReward.apply(this, arguments);
      }
      return getInflationReward;
    }()
    /**
     * Fetch the specific inflation values for the current epoch
     */
  }, {
    key: "getInflationRate",
    value: function () {
      var _getInflationRate = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee46() {
        var unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee46$(_context47) {
          while (1) switch (_context47.prev = _context47.next) {
            case 0:
              _context47.next = 2;
              return this._rpcRequest('getInflationRate', []);
            case 2:
              unsafeRes = _context47.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetInflationRateRpcResult);
              if (!('error' in res)) {
                _context47.next = 6;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get inflation rate');
            case 6:
              return _context47.abrupt("return", res.result);
            case 7:
            case "end":
              return _context47.stop();
          }
        }, _callee46, this);
      }));
      function getInflationRate() {
        return _getInflationRate.apply(this, arguments);
      }
      return getInflationRate;
    }()
    /**
     * Fetch the Epoch Info parameters
     */
  }, {
    key: "getEpochInfo",
    value: function () {
      var _getEpochInfo = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee47(commitmentOrConfig) {
        var _extractCommitmentFro15, commitment, config, args, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee47$(_context48) {
          while (1) switch (_context48.prev = _context48.next) {
            case 0:
              _extractCommitmentFro15 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro15.commitment, config = _extractCommitmentFro15.config;
              args = this._buildArgs([], commitment, undefined /* encoding */, config);
              _context48.next = 4;
              return this._rpcRequest('getEpochInfo', args);
            case 4:
              unsafeRes = _context48.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetEpochInfoRpcResult);
              if (!('error' in res)) {
                _context48.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get epoch info');
            case 8:
              return _context48.abrupt("return", res.result);
            case 9:
            case "end":
              return _context48.stop();
          }
        }, _callee47, this);
      }));
      function getEpochInfo(_x64) {
        return _getEpochInfo.apply(this, arguments);
      }
      return getEpochInfo;
    }()
    /**
     * Fetch the Epoch Schedule parameters
     */
  }, {
    key: "getEpochSchedule",
    value: function () {
      var _getEpochSchedule = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee48() {
        var unsafeRes, res, epochSchedule;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee48$(_context49) {
          while (1) switch (_context49.prev = _context49.next) {
            case 0:
              _context49.next = 2;
              return this._rpcRequest('getEpochSchedule', []);
            case 2:
              unsafeRes = _context49.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetEpochScheduleRpcResult);
              if (!('error' in res)) {
                _context49.next = 6;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get epoch schedule');
            case 6:
              epochSchedule = res.result;
              return _context49.abrupt("return", new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot));
            case 8:
            case "end":
              return _context49.stop();
          }
        }, _callee48, this);
      }));
      function getEpochSchedule() {
        return _getEpochSchedule.apply(this, arguments);
      }
      return getEpochSchedule;
    }()
    /**
     * Fetch the leader schedule for the current epoch
     * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}
     */
  }, {
    key: "getLeaderSchedule",
    value: function () {
      var _getLeaderSchedule = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee49() {
        var unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee49$(_context50) {
          while (1) switch (_context50.prev = _context50.next) {
            case 0:
              _context50.next = 2;
              return this._rpcRequest('getLeaderSchedule', []);
            case 2:
              unsafeRes = _context50.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetLeaderScheduleRpcResult);
              if (!('error' in res)) {
                _context50.next = 6;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get leader schedule');
            case 6:
              return _context50.abrupt("return", res.result);
            case 7:
            case "end":
              return _context50.stop();
          }
        }, _callee49, this);
      }));
      function getLeaderSchedule() {
        return _getLeaderSchedule.apply(this, arguments);
      }
      return getLeaderSchedule;
    }()
    /**
     * Fetch the minimum balance needed to exempt an account of `dataLength`
     * size from rent
     */
  }, {
    key: "getMinimumBalanceForRentExemption",
    value: function () {
      var _getMinimumBalanceForRentExemption = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee50(dataLength, commitment) {
        var args, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee50$(_context51) {
          while (1) switch (_context51.prev = _context51.next) {
            case 0:
              args = this._buildArgs([dataLength], commitment);
              _context51.next = 3;
              return this._rpcRequest('getMinimumBalanceForRentExemption', args);
            case 3:
              unsafeRes = _context51.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult);
              if (!('error' in res)) {
                _context51.next = 8;
                break;
              }
              console.warn('Unable to fetch minimum balance for rent exemption');
              return _context51.abrupt("return", 0);
            case 8:
              return _context51.abrupt("return", res.result);
            case 9:
            case "end":
              return _context51.stop();
          }
        }, _callee50, this);
      }));
      function getMinimumBalanceForRentExemption(_x65, _x66) {
        return _getMinimumBalanceForRentExemption.apply(this, arguments);
      }
      return getMinimumBalanceForRentExemption;
    }()
    /**
     * Fetch a recent blockhash from the cluster, return with context
     * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}
     *
     * @deprecated Deprecated since Solana v1.8.0. Please use {@link getLatestBlockhash} instead.
     */
  }, {
    key: "getRecentBlockhashAndContext",
    value: function () {
      var _getRecentBlockhashAndContext = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee51(commitment) {
        var args, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee51$(_context52) {
          while (1) switch (_context52.prev = _context52.next) {
            case 0:
              args = this._buildArgs([], commitment);
              _context52.next = 3;
              return this._rpcRequest('getRecentBlockhash', args);
            case 3:
              unsafeRes = _context52.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetRecentBlockhashAndContextRpcResult);
              if (!('error' in res)) {
                _context52.next = 7;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get recent blockhash');
            case 7:
              return _context52.abrupt("return", res.result);
            case 8:
            case "end":
              return _context52.stop();
          }
        }, _callee51, this);
      }));
      function getRecentBlockhashAndContext(_x67) {
        return _getRecentBlockhashAndContext.apply(this, arguments);
      }
      return getRecentBlockhashAndContext;
    }()
    /**
     * Fetch recent performance samples
     * @return {Promise<Array<PerfSample>>}
     */
  }, {
    key: "getRecentPerformanceSamples",
    value: function () {
      var _getRecentPerformanceSamples = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee52(limit) {
        var unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee52$(_context53) {
          while (1) switch (_context53.prev = _context53.next) {
            case 0:
              _context53.next = 2;
              return this._rpcRequest('getRecentPerformanceSamples', limit ? [limit] : []);
            case 2:
              unsafeRes = _context53.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetRecentPerformanceSamplesRpcResult);
              if (!('error' in res)) {
                _context53.next = 6;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get recent performance samples');
            case 6:
              return _context53.abrupt("return", res.result);
            case 7:
            case "end":
              return _context53.stop();
          }
        }, _callee52, this);
      }));
      function getRecentPerformanceSamples(_x68) {
        return _getRecentPerformanceSamples.apply(this, arguments);
      }
      return getRecentPerformanceSamples;
    }()
    /**
     * Fetch the fee calculator for a recent blockhash from the cluster, return with context
     *
     * @deprecated Deprecated since Solana v1.8.0. Please use {@link getFeeForMessage} instead.
     */
  }, {
    key: "getFeeCalculatorForBlockhash",
    value: function () {
      var _getFeeCalculatorForBlockhash = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee53(blockhash, commitment) {
        var args, unsafeRes, res, _res$result, context, value;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee53$(_context54) {
          while (1) switch (_context54.prev = _context54.next) {
            case 0:
              args = this._buildArgs([blockhash], commitment);
              _context54.next = 3;
              return this._rpcRequest('getFeeCalculatorForBlockhash', args);
            case 3:
              unsafeRes = _context54.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetFeeCalculatorRpcResult);
              if (!('error' in res)) {
                _context54.next = 7;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get fee calculator');
            case 7:
              _res$result = res.result, context = _res$result.context, value = _res$result.value;
              return _context54.abrupt("return", {
                context: context,
                value: value !== null ? value.feeCalculator : null
              });
            case 9:
            case "end":
              return _context54.stop();
          }
        }, _callee53, this);
      }));
      function getFeeCalculatorForBlockhash(_x69, _x70) {
        return _getFeeCalculatorForBlockhash.apply(this, arguments);
      }
      return getFeeCalculatorForBlockhash;
    }()
    /**
     * Fetch the fee for a message from the cluster, return with context
     */
  }, {
    key: "getFeeForMessage",
    value: function () {
      var _getFeeForMessage = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee54(message, commitment) {
        var wireMessage, args, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee54$(_context55) {
          while (1) switch (_context55.prev = _context55.next) {
            case 0:
              wireMessage = toBuffer(message.serialize()).toString('base64');
              args = this._buildArgs([wireMessage], commitment);
              _context55.next = 4;
              return this._rpcRequest('getFeeForMessage', args);
            case 4:
              unsafeRes = _context55.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .nullable */ .AG)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)())));
              if (!('error' in res)) {
                _context55.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get fee for message');
            case 8:
              if (!(res.result === null)) {
                _context55.next = 10;
                break;
              }
              throw new Error('invalid blockhash');
            case 10:
              return _context55.abrupt("return", res.result);
            case 11:
            case "end":
              return _context55.stop();
          }
        }, _callee54, this);
      }));
      function getFeeForMessage(_x71, _x72) {
        return _getFeeForMessage.apply(this, arguments);
      }
      return getFeeForMessage;
    }()
    /**
     * Fetch a list of prioritization fees from recent blocks.
     */
  }, {
    key: "getRecentPrioritizationFees",
    value: function () {
      var _getRecentPrioritizationFees = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee55(config) {
        var _config$lockedWritabl;
        var accounts, args, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee55$(_context56) {
          while (1) switch (_context56.prev = _context56.next) {
            case 0:
              accounts = config === null || config === void 0 ? void 0 : (_config$lockedWritabl = config.lockedWritableAccounts) === null || _config$lockedWritabl === void 0 ? void 0 : _config$lockedWritabl.map(function (key) {
                return key.toBase58();
              });
              args = accounts !== null && accounts !== void 0 && accounts.length ? [accounts] : [];
              _context56.next = 4;
              return this._rpcRequest('getRecentPrioritizationFees', args);
            case 4:
              unsafeRes = _context56.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetRecentPrioritizationFeesRpcResult);
              if (!('error' in res)) {
                _context56.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get recent prioritization fees');
            case 8:
              return _context56.abrupt("return", res.result);
            case 9:
            case "end":
              return _context56.stop();
          }
        }, _callee55, this);
      }));
      function getRecentPrioritizationFees(_x73) {
        return _getRecentPrioritizationFees.apply(this, arguments);
      }
      return getRecentPrioritizationFees;
    }()
    /**
     * Fetch a recent blockhash from the cluster
     * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}
     *
     * @deprecated Deprecated since Solana v1.8.0. Please use {@link getLatestBlockhash} instead.
     */
  }, {
    key: "getRecentBlockhash",
    value: function () {
      var _getRecentBlockhash = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee56(commitment) {
        var res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee56$(_context57) {
          while (1) switch (_context57.prev = _context57.next) {
            case 0:
              _context57.prev = 0;
              _context57.next = 3;
              return this.getRecentBlockhashAndContext(commitment);
            case 3:
              res = _context57.sent;
              return _context57.abrupt("return", res.value);
            case 7:
              _context57.prev = 7;
              _context57.t0 = _context57["catch"](0);
              throw new Error('failed to get recent blockhash: ' + _context57.t0);
            case 10:
            case "end":
              return _context57.stop();
          }
        }, _callee56, this, [[0, 7]]);
      }));
      function getRecentBlockhash(_x74) {
        return _getRecentBlockhash.apply(this, arguments);
      }
      return getRecentBlockhash;
    }()
    /**
     * Fetch the latest blockhash from the cluster
     * @return {Promise<BlockhashWithExpiryBlockHeight>}
     */
  }, {
    key: "getLatestBlockhash",
    value: function () {
      var _getLatestBlockhash = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee57(commitmentOrConfig) {
        var res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee57$(_context58) {
          while (1) switch (_context58.prev = _context58.next) {
            case 0:
              _context58.prev = 0;
              _context58.next = 3;
              return this.getLatestBlockhashAndContext(commitmentOrConfig);
            case 3:
              res = _context58.sent;
              return _context58.abrupt("return", res.value);
            case 7:
              _context58.prev = 7;
              _context58.t0 = _context58["catch"](0);
              throw new Error('failed to get recent blockhash: ' + _context58.t0);
            case 10:
            case "end":
              return _context58.stop();
          }
        }, _callee57, this, [[0, 7]]);
      }));
      function getLatestBlockhash(_x75) {
        return _getLatestBlockhash.apply(this, arguments);
      }
      return getLatestBlockhash;
    }()
    /**
     * Fetch the latest blockhash from the cluster
     * @return {Promise<BlockhashWithExpiryBlockHeight>}
     */
  }, {
    key: "getLatestBlockhashAndContext",
    value: function () {
      var _getLatestBlockhashAndContext = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee58(commitmentOrConfig) {
        var _extractCommitmentFro16, commitment, config, args, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee58$(_context59) {
          while (1) switch (_context59.prev = _context59.next) {
            case 0:
              _extractCommitmentFro16 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro16.commitment, config = _extractCommitmentFro16.config;
              args = this._buildArgs([], commitment, undefined /* encoding */, config);
              _context59.next = 4;
              return this._rpcRequest('getLatestBlockhash', args);
            case 4:
              unsafeRes = _context59.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetLatestBlockhashRpcResult);
              if (!('error' in res)) {
                _context59.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get latest blockhash');
            case 8:
              return _context59.abrupt("return", res.result);
            case 9:
            case "end":
              return _context59.stop();
          }
        }, _callee58, this);
      }));
      function getLatestBlockhashAndContext(_x76) {
        return _getLatestBlockhashAndContext.apply(this, arguments);
      }
      return getLatestBlockhashAndContext;
    }()
    /**
     * Returns whether a blockhash is still valid or not
     */
  }, {
    key: "isBlockhashValid",
    value: function () {
      var _isBlockhashValid = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee59(blockhash, rawConfig) {
        var _extractCommitmentFro17, commitment, config, args, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee59$(_context60) {
          while (1) switch (_context60.prev = _context60.next) {
            case 0:
              _extractCommitmentFro17 = extractCommitmentFromConfig(rawConfig), commitment = _extractCommitmentFro17.commitment, config = _extractCommitmentFro17.config;
              args = this._buildArgs([blockhash], commitment, undefined /* encoding */, config);
              _context60.next = 4;
              return this._rpcRequest('isBlockhashValid', args);
            case 4:
              unsafeRes = _context60.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, IsBlockhashValidRpcResult);
              if (!('error' in res)) {
                _context60.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to determine if the blockhash `' + blockhash + '`is valid');
            case 8:
              return _context60.abrupt("return", res.result);
            case 9:
            case "end":
              return _context60.stop();
          }
        }, _callee59, this);
      }));
      function isBlockhashValid(_x77, _x78) {
        return _isBlockhashValid.apply(this, arguments);
      }
      return isBlockhashValid;
    }()
    /**
     * Fetch the node version
     */
  }, {
    key: "getVersion",
    value: function () {
      var _getVersion = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee60() {
        var unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee60$(_context61) {
          while (1) switch (_context61.prev = _context61.next) {
            case 0:
              _context61.next = 2;
              return this._rpcRequest('getVersion', []);
            case 2:
              unsafeRes = _context61.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, jsonRpcResult(VersionResult));
              if (!('error' in res)) {
                _context61.next = 6;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get version');
            case 6:
              return _context61.abrupt("return", res.result);
            case 7:
            case "end":
              return _context61.stop();
          }
        }, _callee60, this);
      }));
      function getVersion() {
        return _getVersion.apply(this, arguments);
      }
      return getVersion;
    }()
    /**
     * Fetch the genesis hash
     */
  }, {
    key: "getGenesisHash",
    value: function () {
      var _getGenesisHash = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee61() {
        var unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee61$(_context62) {
          while (1) switch (_context62.prev = _context62.next) {
            case 0:
              _context62.next = 2;
              return this._rpcRequest('getGenesisHash', []);
            case 2:
              unsafeRes = _context62.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)()));
              if (!('error' in res)) {
                _context62.next = 6;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get genesis hash');
            case 6:
              return _context62.abrupt("return", res.result);
            case 7:
            case "end":
              return _context62.stop();
          }
        }, _callee61, this);
      }));
      function getGenesisHash() {
        return _getGenesisHash.apply(this, arguments);
      }
      return getGenesisHash;
    }()
    /**
     * Fetch a processed block from the cluster.
     *
     * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
     * setting the `maxSupportedTransactionVersion` property.
     */
  }, {
    key: "getBlock",
    value:
    /**
     * Fetch a processed block from the cluster.
     */
    // eslint-disable-next-line no-dupe-class-members
    function () {
      var _getBlock = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee62(slot, rawConfig) {
        var _extractCommitmentFro18, commitment, config, args, unsafeRes, res, _res, _res2, result;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee62$(_context63) {
          while (1) switch (_context63.prev = _context63.next) {
            case 0:
              _extractCommitmentFro18 = extractCommitmentFromConfig(rawConfig), commitment = _extractCommitmentFro18.commitment, config = _extractCommitmentFro18.config;
              args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined /* encoding */, config);
              _context63.next = 4;
              return this._rpcRequest('getBlock', args);
            case 4:
              unsafeRes = _context63.sent;
              _context63.prev = 5;
              _context63.t0 = config === null || config === void 0 ? void 0 : config.transactionDetails;
              _context63.next = _context63.t0 === 'accounts' ? 9 : _context63.t0 === 'none' ? 13 : 17;
              break;
            case 9:
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetAccountsModeBlockRpcResult);
              if (!('error' in res)) {
                _context63.next = 12;
                break;
              }
              throw res.error;
            case 12:
              return _context63.abrupt("return", res.result);
            case 13:
              _res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetNoneModeBlockRpcResult);
              if (!('error' in _res)) {
                _context63.next = 16;
                break;
              }
              throw _res.error;
            case 16:
              return _context63.abrupt("return", _res.result);
            case 17:
              _res2 = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetBlockRpcResult);
              if (!('error' in _res2)) {
                _context63.next = 20;
                break;
              }
              throw _res2.error;
            case 20:
              result = _res2.result;
              return _context63.abrupt("return", result ? _objectSpread(_objectSpread({}, result), {}, {
                transactions: result.transactions.map(function (_ref15) {
                  var transaction = _ref15.transaction,
                    meta = _ref15.meta,
                    version = _ref15.version;
                  return {
                    meta: meta,
                    transaction: _objectSpread(_objectSpread({}, transaction), {}, {
                      message: versionedMessageFromResponse(version, transaction.message)
                    }),
                    version: version
                  };
                })
              }) : null);
            case 22:
              _context63.next = 27;
              break;
            case 24:
              _context63.prev = 24;
              _context63.t1 = _context63["catch"](5);
              throw new SolanaJSONRPCError(_context63.t1, 'failed to get confirmed block');
            case 27:
            case "end":
              return _context63.stop();
          }
        }, _callee62, this, [[5, 24]]);
      }));
      function getBlock(_x79, _x80) {
        return _getBlock.apply(this, arguments);
      }
      return getBlock;
    }()
    /**
     * Fetch parsed transaction details for a confirmed or finalized block
     */
  }, {
    key: "getParsedBlock",
    value: // eslint-disable-next-line no-dupe-class-members
    function () {
      var _getParsedBlock = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee63(slot, rawConfig) {
        var _extractCommitmentFro19, commitment, config, args, unsafeRes, res, _res3, _res4;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee63$(_context64) {
          while (1) switch (_context64.prev = _context64.next) {
            case 0:
              _extractCommitmentFro19 = extractCommitmentFromConfig(rawConfig), commitment = _extractCommitmentFro19.commitment, config = _extractCommitmentFro19.config;
              args = this._buildArgsAtLeastConfirmed([slot], commitment, 'jsonParsed', config);
              _context64.next = 4;
              return this._rpcRequest('getBlock', args);
            case 4:
              unsafeRes = _context64.sent;
              _context64.prev = 5;
              _context64.t0 = config === null || config === void 0 ? void 0 : config.transactionDetails;
              _context64.next = _context64.t0 === 'accounts' ? 9 : _context64.t0 === 'none' ? 13 : 17;
              break;
            case 9:
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetParsedAccountsModeBlockRpcResult);
              if (!('error' in res)) {
                _context64.next = 12;
                break;
              }
              throw res.error;
            case 12:
              return _context64.abrupt("return", res.result);
            case 13:
              _res3 = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetParsedNoneModeBlockRpcResult);
              if (!('error' in _res3)) {
                _context64.next = 16;
                break;
              }
              throw _res3.error;
            case 16:
              return _context64.abrupt("return", _res3.result);
            case 17:
              _res4 = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetParsedBlockRpcResult);
              if (!('error' in _res4)) {
                _context64.next = 20;
                break;
              }
              throw _res4.error;
            case 20:
              return _context64.abrupt("return", _res4.result);
            case 21:
              _context64.next = 26;
              break;
            case 23:
              _context64.prev = 23;
              _context64.t1 = _context64["catch"](5);
              throw new SolanaJSONRPCError(_context64.t1, 'failed to get block');
            case 26:
            case "end":
              return _context64.stop();
          }
        }, _callee63, this, [[5, 23]]);
      }));
      function getParsedBlock(_x81, _x82) {
        return _getParsedBlock.apply(this, arguments);
      }
      return getParsedBlock;
    }()
  }, {
    key: "getBlockProduction",
    value:
    /*
     * Returns recent block production information from the current or previous epoch
     */
    function () {
      var _getBlockProduction = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee64(configOrCommitment) {
        var extra, commitment, c, rest, args, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee64$(_context65) {
          while (1) switch (_context65.prev = _context65.next) {
            case 0:
              if (typeof configOrCommitment === 'string') {
                commitment = configOrCommitment;
              } else if (configOrCommitment) {
                c = configOrCommitment.commitment, rest = (0,_babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_24__/* ["default"] */ .Z)(configOrCommitment, _excluded3);
                commitment = c;
                extra = rest;
              }
              args = this._buildArgs([], commitment, 'base64', extra);
              _context65.next = 4;
              return this._rpcRequest('getBlockProduction', args);
            case 4:
              unsafeRes = _context65.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, BlockProductionResponseStruct);
              if (!('error' in res)) {
                _context65.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get block production information');
            case 8:
              return _context65.abrupt("return", res.result);
            case 9:
            case "end":
              return _context65.stop();
          }
        }, _callee64, this);
      }));
      function getBlockProduction(_x83) {
        return _getBlockProduction.apply(this, arguments);
      }
      return getBlockProduction;
    }()
    /**
     * Fetch a confirmed or finalized transaction from the cluster.
     *
     * @deprecated Instead, call `getTransaction` using a
     * `GetVersionedTransactionConfig` by setting the
     * `maxSupportedTransactionVersion` property.
     */
  }, {
    key: "getTransaction",
    value:
    /**
     * Fetch a confirmed or finalized transaction from the cluster.
     */
    // eslint-disable-next-line no-dupe-class-members
    function () {
      var _getTransaction = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee65(signature, rawConfig) {
        var _extractCommitmentFro20, commitment, config, args, unsafeRes, res, result;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee65$(_context66) {
          while (1) switch (_context66.prev = _context66.next) {
            case 0:
              _extractCommitmentFro20 = extractCommitmentFromConfig(rawConfig), commitment = _extractCommitmentFro20.commitment, config = _extractCommitmentFro20.config;
              args = this._buildArgsAtLeastConfirmed([signature], commitment, undefined /* encoding */, config);
              _context66.next = 4;
              return this._rpcRequest('getTransaction', args);
            case 4:
              unsafeRes = _context66.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetTransactionRpcResult);
              if (!('error' in res)) {
                _context66.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get transaction');
            case 8:
              result = res.result;
              if (result) {
                _context66.next = 11;
                break;
              }
              return _context66.abrupt("return", result);
            case 11:
              return _context66.abrupt("return", _objectSpread(_objectSpread({}, result), {}, {
                transaction: _objectSpread(_objectSpread({}, result.transaction), {}, {
                  message: versionedMessageFromResponse(result.version, result.transaction.message)
                })
              }));
            case 12:
            case "end":
              return _context66.stop();
          }
        }, _callee65, this);
      }));
      function getTransaction(_x84, _x85) {
        return _getTransaction.apply(this, arguments);
      }
      return getTransaction;
    }()
    /**
     * Fetch parsed transaction details for a confirmed or finalized transaction
     */
  }, {
    key: "getParsedTransaction",
    value: function () {
      var _getParsedTransaction = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee66(signature, commitmentOrConfig) {
        var _extractCommitmentFro21, commitment, config, args, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee66$(_context67) {
          while (1) switch (_context67.prev = _context67.next) {
            case 0:
              _extractCommitmentFro21 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro21.commitment, config = _extractCommitmentFro21.config;
              args = this._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed', config);
              _context67.next = 4;
              return this._rpcRequest('getTransaction', args);
            case 4:
              unsafeRes = _context67.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetParsedTransactionRpcResult);
              if (!('error' in res)) {
                _context67.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get transaction');
            case 8:
              return _context67.abrupt("return", res.result);
            case 9:
            case "end":
              return _context67.stop();
          }
        }, _callee66, this);
      }));
      function getParsedTransaction(_x86, _x87) {
        return _getParsedTransaction.apply(this, arguments);
      }
      return getParsedTransaction;
    }()
    /**
     * Fetch parsed transaction details for a batch of confirmed transactions
     */
  }, {
    key: "getParsedTransactions",
    value: function () {
      var _getParsedTransactions = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee67(signatures, commitmentOrConfig) {
        var _this6 = this;
        var _extractCommitmentFro22, commitment, config, batch, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee67$(_context68) {
          while (1) switch (_context68.prev = _context68.next) {
            case 0:
              _extractCommitmentFro22 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro22.commitment, config = _extractCommitmentFro22.config;
              batch = signatures.map(function (signature) {
                var args = _this6._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed', config);
                return {
                  methodName: 'getTransaction',
                  args: args
                };
              });
              _context68.next = 4;
              return this._rpcBatchRequest(batch);
            case 4:
              unsafeRes = _context68.sent;
              res = unsafeRes.map(function (unsafeRes) {
                var res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetParsedTransactionRpcResult);
                if ('error' in res) {
                  throw new SolanaJSONRPCError(res.error, 'failed to get transactions');
                }
                return res.result;
              });
              return _context68.abrupt("return", res);
            case 7:
            case "end":
              return _context68.stop();
          }
        }, _callee67, this);
      }));
      function getParsedTransactions(_x88, _x89) {
        return _getParsedTransactions.apply(this, arguments);
      }
      return getParsedTransactions;
    }()
    /**
     * Fetch transaction details for a batch of confirmed transactions.
     * Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.
     *
     * @deprecated Instead, call `getTransactions` using a
     * `GetVersionedTransactionConfig` by setting the
     * `maxSupportedTransactionVersion` property.
     */
  }, {
    key: "getTransactions",
    value:
    /**
     * Fetch transaction details for a batch of confirmed transactions.
     * Similar to {@link getParsedTransactions} but returns a {@link
     * VersionedTransactionResponse}.
     */
    // eslint-disable-next-line no-dupe-class-members
    function () {
      var _getTransactions = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee68(signatures, commitmentOrConfig) {
        var _this7 = this;
        var _extractCommitmentFro23, commitment, config, batch, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee68$(_context69) {
          while (1) switch (_context69.prev = _context69.next) {
            case 0:
              _extractCommitmentFro23 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro23.commitment, config = _extractCommitmentFro23.config;
              batch = signatures.map(function (signature) {
                var args = _this7._buildArgsAtLeastConfirmed([signature], commitment, undefined /* encoding */, config);
                return {
                  methodName: 'getTransaction',
                  args: args
                };
              });
              _context69.next = 4;
              return this._rpcBatchRequest(batch);
            case 4:
              unsafeRes = _context69.sent;
              res = unsafeRes.map(function (unsafeRes) {
                var res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetTransactionRpcResult);
                if ('error' in res) {
                  throw new SolanaJSONRPCError(res.error, 'failed to get transactions');
                }
                var result = res.result;
                if (!result) return result;
                return _objectSpread(_objectSpread({}, result), {}, {
                  transaction: _objectSpread(_objectSpread({}, result.transaction), {}, {
                    message: versionedMessageFromResponse(result.version, result.transaction.message)
                  })
                });
              });
              return _context69.abrupt("return", res);
            case 7:
            case "end":
              return _context69.stop();
          }
        }, _callee68, this);
      }));
      function getTransactions(_x90, _x91) {
        return _getTransactions.apply(this, arguments);
      }
      return getTransactions;
    }()
    /**
     * Fetch a list of Transactions and transaction statuses from the cluster
     * for a confirmed block.
     *
     * @deprecated Deprecated since v1.13.0. Please use {@link getBlock} instead.
     */
  }, {
    key: "getConfirmedBlock",
    value: function () {
      var _getConfirmedBlock = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee69(slot, commitment) {
        var args, unsafeRes, res, result, block;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee69$(_context70) {
          while (1) switch (_context70.prev = _context70.next) {
            case 0:
              args = this._buildArgsAtLeastConfirmed([slot], commitment);
              _context70.next = 3;
              return this._rpcRequest('getConfirmedBlock', args);
            case 3:
              unsafeRes = _context70.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetConfirmedBlockRpcResult);
              if (!('error' in res)) {
                _context70.next = 7;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get confirmed block');
            case 7:
              result = res.result;
              if (result) {
                _context70.next = 10;
                break;
              }
              throw new Error('Confirmed block ' + slot + ' not found');
            case 10:
              block = _objectSpread(_objectSpread({}, result), {}, {
                transactions: result.transactions.map(function (_ref16) {
                  var transaction = _ref16.transaction,
                    meta = _ref16.meta;
                  var message = new Message(transaction.message);
                  return {
                    meta: meta,
                    transaction: _objectSpread(_objectSpread({}, transaction), {}, {
                      message: message
                    })
                  };
                })
              });
              return _context70.abrupt("return", _objectSpread(_objectSpread({}, block), {}, {
                transactions: block.transactions.map(function (_ref17) {
                  var transaction = _ref17.transaction,
                    meta = _ref17.meta;
                  return {
                    meta: meta,
                    transaction: Transaction.populate(transaction.message, transaction.signatures)
                  };
                })
              }));
            case 12:
            case "end":
              return _context70.stop();
          }
        }, _callee69, this);
      }));
      function getConfirmedBlock(_x92, _x93) {
        return _getConfirmedBlock.apply(this, arguments);
      }
      return getConfirmedBlock;
    }()
    /**
     * Fetch confirmed blocks between two slots
     */
  }, {
    key: "getBlocks",
    value: function () {
      var _getBlocks = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee70(startSlot, endSlot, commitment) {
        var args, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee70$(_context71) {
          while (1) switch (_context71.prev = _context71.next) {
            case 0:
              args = this._buildArgsAtLeastConfirmed(endSlot !== undefined ? [startSlot, endSlot] : [startSlot], commitment);
              _context71.next = 3;
              return this._rpcRequest('getBlocks', args);
            case 3:
              unsafeRes = _context71.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .array */ .IX)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)())));
              if (!('error' in res)) {
                _context71.next = 7;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get blocks');
            case 7:
              return _context71.abrupt("return", res.result);
            case 8:
            case "end":
              return _context71.stop();
          }
        }, _callee70, this);
      }));
      function getBlocks(_x94, _x95, _x96) {
        return _getBlocks.apply(this, arguments);
      }
      return getBlocks;
    }()
    /**
     * Fetch a list of Signatures from the cluster for a block, excluding rewards
     */
  }, {
    key: "getBlockSignatures",
    value: function () {
      var _getBlockSignatures = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee71(slot, commitment) {
        var args, unsafeRes, res, result;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee71$(_context72) {
          while (1) switch (_context72.prev = _context72.next) {
            case 0:
              args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined, {
                transactionDetails: 'signatures',
                rewards: false
              });
              _context72.next = 3;
              return this._rpcRequest('getBlock', args);
            case 3:
              unsafeRes = _context72.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetBlockSignaturesRpcResult);
              if (!('error' in res)) {
                _context72.next = 7;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get block');
            case 7:
              result = res.result;
              if (result) {
                _context72.next = 10;
                break;
              }
              throw new Error('Block ' + slot + ' not found');
            case 10:
              return _context72.abrupt("return", result);
            case 11:
            case "end":
              return _context72.stop();
          }
        }, _callee71, this);
      }));
      function getBlockSignatures(_x97, _x98) {
        return _getBlockSignatures.apply(this, arguments);
      }
      return getBlockSignatures;
    }()
    /**
     * Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards
     *
     * @deprecated Deprecated since Solana v1.8.0. Please use {@link getBlockSignatures} instead.
     */
  }, {
    key: "getConfirmedBlockSignatures",
    value: function () {
      var _getConfirmedBlockSignatures = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee72(slot, commitment) {
        var args, unsafeRes, res, result;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee72$(_context73) {
          while (1) switch (_context73.prev = _context73.next) {
            case 0:
              args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined, {
                transactionDetails: 'signatures',
                rewards: false
              });
              _context73.next = 3;
              return this._rpcRequest('getConfirmedBlock', args);
            case 3:
              unsafeRes = _context73.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetBlockSignaturesRpcResult);
              if (!('error' in res)) {
                _context73.next = 7;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get confirmed block');
            case 7:
              result = res.result;
              if (result) {
                _context73.next = 10;
                break;
              }
              throw new Error('Confirmed block ' + slot + ' not found');
            case 10:
              return _context73.abrupt("return", result);
            case 11:
            case "end":
              return _context73.stop();
          }
        }, _callee72, this);
      }));
      function getConfirmedBlockSignatures(_x99, _x100) {
        return _getConfirmedBlockSignatures.apply(this, arguments);
      }
      return getConfirmedBlockSignatures;
    }()
    /**
     * Fetch a transaction details for a confirmed transaction
     *
     * @deprecated Deprecated since Solana v1.8.0. Please use {@link getTransaction} instead.
     */
  }, {
    key: "getConfirmedTransaction",
    value: function () {
      var _getConfirmedTransaction = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee73(signature, commitment) {
        var args, unsafeRes, res, result, message, signatures;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee73$(_context74) {
          while (1) switch (_context74.prev = _context74.next) {
            case 0:
              args = this._buildArgsAtLeastConfirmed([signature], commitment);
              _context74.next = 3;
              return this._rpcRequest('getConfirmedTransaction', args);
            case 3:
              unsafeRes = _context74.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetTransactionRpcResult);
              if (!('error' in res)) {
                _context74.next = 7;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get transaction');
            case 7:
              result = res.result;
              if (result) {
                _context74.next = 10;
                break;
              }
              return _context74.abrupt("return", result);
            case 10:
              message = new Message(result.transaction.message);
              signatures = result.transaction.signatures;
              return _context74.abrupt("return", _objectSpread(_objectSpread({}, result), {}, {
                transaction: Transaction.populate(message, signatures)
              }));
            case 13:
            case "end":
              return _context74.stop();
          }
        }, _callee73, this);
      }));
      function getConfirmedTransaction(_x101, _x102) {
        return _getConfirmedTransaction.apply(this, arguments);
      }
      return getConfirmedTransaction;
    }()
    /**
     * Fetch parsed transaction details for a confirmed transaction
     *
     * @deprecated Deprecated since Solana v1.8.0. Please use {@link getParsedTransaction} instead.
     */
  }, {
    key: "getParsedConfirmedTransaction",
    value: function () {
      var _getParsedConfirmedTransaction = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee74(signature, commitment) {
        var args, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee74$(_context75) {
          while (1) switch (_context75.prev = _context75.next) {
            case 0:
              args = this._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed');
              _context75.next = 3;
              return this._rpcRequest('getConfirmedTransaction', args);
            case 3:
              unsafeRes = _context75.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetParsedTransactionRpcResult);
              if (!('error' in res)) {
                _context75.next = 7;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get confirmed transaction');
            case 7:
              return _context75.abrupt("return", res.result);
            case 8:
            case "end":
              return _context75.stop();
          }
        }, _callee74, this);
      }));
      function getParsedConfirmedTransaction(_x103, _x104) {
        return _getParsedConfirmedTransaction.apply(this, arguments);
      }
      return getParsedConfirmedTransaction;
    }()
    /**
     * Fetch parsed transaction details for a batch of confirmed transactions
     *
     * @deprecated Deprecated since Solana v1.8.0. Please use {@link getParsedTransactions} instead.
     */
  }, {
    key: "getParsedConfirmedTransactions",
    value: function () {
      var _getParsedConfirmedTransactions = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee75(signatures, commitment) {
        var _this8 = this;
        var batch, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee75$(_context76) {
          while (1) switch (_context76.prev = _context76.next) {
            case 0:
              batch = signatures.map(function (signature) {
                var args = _this8._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed');
                return {
                  methodName: 'getConfirmedTransaction',
                  args: args
                };
              });
              _context76.next = 3;
              return this._rpcBatchRequest(batch);
            case 3:
              unsafeRes = _context76.sent;
              res = unsafeRes.map(function (unsafeRes) {
                var res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetParsedTransactionRpcResult);
                if ('error' in res) {
                  throw new SolanaJSONRPCError(res.error, 'failed to get confirmed transactions');
                }
                return res.result;
              });
              return _context76.abrupt("return", res);
            case 6:
            case "end":
              return _context76.stop();
          }
        }, _callee75, this);
      }));
      function getParsedConfirmedTransactions(_x105, _x106) {
        return _getParsedConfirmedTransactions.apply(this, arguments);
      }
      return getParsedConfirmedTransactions;
    }()
    /**
     * Fetch a list of all the confirmed signatures for transactions involving an address
     * within a specified slot range. Max range allowed is 10,000 slots.
     *
     * @deprecated Deprecated since v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.
     *
     * @param address queried address
     * @param startSlot start slot, inclusive
     * @param endSlot end slot, inclusive
     */
  }, {
    key: "getConfirmedSignaturesForAddress",
    value: function () {
      var _getConfirmedSignaturesForAddress = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee76(address, startSlot, endSlot) {
        var options, firstAvailableBlock, block, highestConfirmedRoot, _block, confirmedSignatureInfo;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee76$(_context77) {
          while (1) switch (_context77.prev = _context77.next) {
            case 0:
              options = {};
              _context77.next = 3;
              return this.getFirstAvailableBlock();
            case 3:
              firstAvailableBlock = _context77.sent;
            case 4:
              if ('until' in options) {
                _context77.next = 24;
                break;
              }
              startSlot--;
              if (!(startSlot <= 0 || startSlot < firstAvailableBlock)) {
                _context77.next = 8;
                break;
              }
              return _context77.abrupt("break", 24);
            case 8:
              _context77.prev = 8;
              _context77.next = 11;
              return this.getConfirmedBlockSignatures(startSlot, 'finalized');
            case 11:
              block = _context77.sent;
              if (block.signatures.length > 0) {
                options.until = block.signatures[block.signatures.length - 1].toString();
              }
              _context77.next = 22;
              break;
            case 15:
              _context77.prev = 15;
              _context77.t0 = _context77["catch"](8);
              if (!(_context77.t0 instanceof Error && _context77.t0.message.includes('skipped'))) {
                _context77.next = 21;
                break;
              }
              return _context77.abrupt("continue", 4);
            case 21:
              throw _context77.t0;
            case 22:
              _context77.next = 4;
              break;
            case 24:
              _context77.next = 26;
              return this.getSlot('finalized');
            case 26:
              highestConfirmedRoot = _context77.sent;
            case 27:
              if ('before' in options) {
                _context77.next = 47;
                break;
              }
              endSlot++;
              if (!(endSlot > highestConfirmedRoot)) {
                _context77.next = 31;
                break;
              }
              return _context77.abrupt("break", 47);
            case 31:
              _context77.prev = 31;
              _context77.next = 34;
              return this.getConfirmedBlockSignatures(endSlot);
            case 34:
              _block = _context77.sent;
              if (_block.signatures.length > 0) {
                options.before = _block.signatures[_block.signatures.length - 1].toString();
              }
              _context77.next = 45;
              break;
            case 38:
              _context77.prev = 38;
              _context77.t1 = _context77["catch"](31);
              if (!(_context77.t1 instanceof Error && _context77.t1.message.includes('skipped'))) {
                _context77.next = 44;
                break;
              }
              return _context77.abrupt("continue", 27);
            case 44:
              throw _context77.t1;
            case 45:
              _context77.next = 27;
              break;
            case 47:
              _context77.next = 49;
              return this.getConfirmedSignaturesForAddress2(address, options);
            case 49:
              confirmedSignatureInfo = _context77.sent;
              return _context77.abrupt("return", confirmedSignatureInfo.map(function (info) {
                return info.signature;
              }));
            case 51:
            case "end":
              return _context77.stop();
          }
        }, _callee76, this, [[8, 15], [31, 38]]);
      }));
      function getConfirmedSignaturesForAddress(_x107, _x108, _x109) {
        return _getConfirmedSignaturesForAddress.apply(this, arguments);
      }
      return getConfirmedSignaturesForAddress;
    }()
    /**
     * Returns confirmed signatures for transactions involving an
     * address backwards in time from the provided signature or most recent confirmed block
     *
     *
     * @param address queried address
     * @param options
     */
  }, {
    key: "getConfirmedSignaturesForAddress2",
    value: function () {
      var _getConfirmedSignaturesForAddress2 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee77(address, options, commitment) {
        var args, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee77$(_context78) {
          while (1) switch (_context78.prev = _context78.next) {
            case 0:
              args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, undefined, options);
              _context78.next = 3;
              return this._rpcRequest('getConfirmedSignaturesForAddress2', args);
            case 3:
              unsafeRes = _context78.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult);
              if (!('error' in res)) {
                _context78.next = 7;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get confirmed signatures for address');
            case 7:
              return _context78.abrupt("return", res.result);
            case 8:
            case "end":
              return _context78.stop();
          }
        }, _callee77, this);
      }));
      function getConfirmedSignaturesForAddress2(_x110, _x111, _x112) {
        return _getConfirmedSignaturesForAddress2.apply(this, arguments);
      }
      return getConfirmedSignaturesForAddress2;
    }()
    /**
     * Returns confirmed signatures for transactions involving an
     * address backwards in time from the provided signature or most recent confirmed block
     *
     *
     * @param address queried address
     * @param options
     */
  }, {
    key: "getSignaturesForAddress",
    value: function () {
      var _getSignaturesForAddress = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee78(address, options, commitment) {
        var args, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee78$(_context79) {
          while (1) switch (_context79.prev = _context79.next) {
            case 0:
              args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, undefined, options);
              _context79.next = 3;
              return this._rpcRequest('getSignaturesForAddress', args);
            case 3:
              unsafeRes = _context79.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, GetSignaturesForAddressRpcResult);
              if (!('error' in res)) {
                _context79.next = 7;
                break;
              }
              throw new SolanaJSONRPCError(res.error, 'failed to get signatures for address');
            case 7:
              return _context79.abrupt("return", res.result);
            case 8:
            case "end":
              return _context79.stop();
          }
        }, _callee78, this);
      }));
      function getSignaturesForAddress(_x113, _x114, _x115) {
        return _getSignaturesForAddress.apply(this, arguments);
      }
      return getSignaturesForAddress;
    }()
  }, {
    key: "getAddressLookupTable",
    value: function () {
      var _getAddressLookupTable = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee79(accountKey, config) {
        var _yield$this$getAccoun, context, accountInfo, value;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee79$(_context80) {
          while (1) switch (_context80.prev = _context80.next) {
            case 0:
              _context80.next = 2;
              return this.getAccountInfoAndContext(accountKey, config);
            case 2:
              _yield$this$getAccoun = _context80.sent;
              context = _yield$this$getAccoun.context;
              accountInfo = _yield$this$getAccoun.value;
              value = null;
              if (accountInfo !== null) {
                value = new AddressLookupTableAccount({
                  key: accountKey,
                  state: AddressLookupTableAccount.deserialize(accountInfo.data)
                });
              }
              return _context80.abrupt("return", {
                context: context,
                value: value
              });
            case 8:
            case "end":
              return _context80.stop();
          }
        }, _callee79, this);
      }));
      function getAddressLookupTable(_x116, _x117) {
        return _getAddressLookupTable.apply(this, arguments);
      }
      return getAddressLookupTable;
    }()
    /**
     * Fetch the contents of a Nonce account from the cluster, return with context
     */
  }, {
    key: "getNonceAndContext",
    value: function () {
      var _getNonceAndContext = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee80(nonceAccount, commitmentOrConfig) {
        var _yield$this$getAccoun2, context, accountInfo, value;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee80$(_context81) {
          while (1) switch (_context81.prev = _context81.next) {
            case 0:
              _context81.next = 2;
              return this.getAccountInfoAndContext(nonceAccount, commitmentOrConfig);
            case 2:
              _yield$this$getAccoun2 = _context81.sent;
              context = _yield$this$getAccoun2.context;
              accountInfo = _yield$this$getAccoun2.value;
              value = null;
              if (accountInfo !== null) {
                value = NonceAccount.fromAccountData(accountInfo.data);
              }
              return _context81.abrupt("return", {
                context: context,
                value: value
              });
            case 8:
            case "end":
              return _context81.stop();
          }
        }, _callee80, this);
      }));
      function getNonceAndContext(_x118, _x119) {
        return _getNonceAndContext.apply(this, arguments);
      }
      return getNonceAndContext;
    }()
    /**
     * Fetch the contents of a Nonce account from the cluster
     */
  }, {
    key: "getNonce",
    value: function () {
      var _getNonce = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee81(nonceAccount, commitmentOrConfig) {
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee81$(_context82) {
          while (1) switch (_context82.prev = _context82.next) {
            case 0:
              _context82.next = 2;
              return this.getNonceAndContext(nonceAccount, commitmentOrConfig).then(function (x) {
                return x.value;
              })["catch"](function (e) {
                throw new Error('failed to get nonce for account ' + nonceAccount.toBase58() + ': ' + e);
              });
            case 2:
              return _context82.abrupt("return", _context82.sent);
            case 3:
            case "end":
              return _context82.stop();
          }
        }, _callee81, this);
      }));
      function getNonce(_x120, _x121) {
        return _getNonce.apply(this, arguments);
      }
      return getNonce;
    }()
    /**
     * Request an allocation of lamports to the specified address
     *
     * ```typescript
     * import { Connection, PublicKey, LAMPORTS_PER_SOL } from "@solana/web3.js";
     *
     * (async () => {
     *   const connection = new Connection("https://api.testnet.solana.com", "confirmed");
     *   const myAddress = new PublicKey("2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM");
     *   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);
     *   await connection.confirmTransaction(signature);
     * })();
     * ```
     */
  }, {
    key: "requestAirdrop",
    value: function () {
      var _requestAirdrop = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee82(to, lamports) {
        var unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee82$(_context83) {
          while (1) switch (_context83.prev = _context83.next) {
            case 0:
              _context83.next = 2;
              return this._rpcRequest('requestAirdrop', [to.toBase58(), lamports]);
            case 2:
              unsafeRes = _context83.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, RequestAirdropRpcResult);
              if (!('error' in res)) {
                _context83.next = 6;
                break;
              }
              throw new SolanaJSONRPCError(res.error, "airdrop to ".concat(to.toBase58(), " failed"));
            case 6:
              return _context83.abrupt("return", res.result);
            case 7:
            case "end":
              return _context83.stop();
          }
        }, _callee82, this);
      }));
      function requestAirdrop(_x122, _x123) {
        return _requestAirdrop.apply(this, arguments);
      }
      return requestAirdrop;
    }()
    /**
     * @internal
     */
  }, {
    key: "_blockhashWithExpiryBlockHeight",
    value: function () {
      var _blockhashWithExpiryBlockHeight2 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee83(disableCache) {
        var timeSinceFetch, expired;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee83$(_context84) {
          while (1) switch (_context84.prev = _context84.next) {
            case 0:
              if (disableCache) {
                _context84.next = 10;
                break;
              }
            case 1:
              if (!this._pollingBlockhash) {
                _context84.next = 6;
                break;
              }
              _context84.next = 4;
              return sleep(100);
            case 4:
              _context84.next = 1;
              break;
            case 6:
              timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;
              expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;
              if (!(this._blockhashInfo.latestBlockhash !== null && !expired)) {
                _context84.next = 10;
                break;
              }
              return _context84.abrupt("return", this._blockhashInfo.latestBlockhash);
            case 10:
              _context84.next = 12;
              return this._pollNewBlockhash();
            case 12:
              return _context84.abrupt("return", _context84.sent);
            case 13:
            case "end":
              return _context84.stop();
          }
        }, _callee83, this);
      }));
      function _blockhashWithExpiryBlockHeight(_x124) {
        return _blockhashWithExpiryBlockHeight2.apply(this, arguments);
      }
      return _blockhashWithExpiryBlockHeight;
    }()
    /**
     * @internal
     */
  }, {
    key: "_pollNewBlockhash",
    value: function () {
      var _pollNewBlockhash2 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee84() {
        var startTime, cachedLatestBlockhash, cachedBlockhash, i, latestBlockhash;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee84$(_context85) {
          while (1) switch (_context85.prev = _context85.next) {
            case 0:
              this._pollingBlockhash = true;
              _context85.prev = 1;
              startTime = Date.now();
              cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;
              cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;
              i = 0;
            case 6:
              if (!(i < 50)) {
                _context85.next = 18;
                break;
              }
              _context85.next = 9;
              return this.getLatestBlockhash('finalized');
            case 9:
              latestBlockhash = _context85.sent;
              if (!(cachedBlockhash !== latestBlockhash.blockhash)) {
                _context85.next = 13;
                break;
              }
              this._blockhashInfo = {
                latestBlockhash: latestBlockhash,
                lastFetch: Date.now(),
                transactionSignatures: [],
                simulatedSignatures: []
              };
              return _context85.abrupt("return", latestBlockhash);
            case 13:
              _context85.next = 15;
              return sleep(MS_PER_SLOT / 2);
            case 15:
              i++;
              _context85.next = 6;
              break;
            case 18:
              throw new Error("Unable to obtain a new blockhash after ".concat(Date.now() - startTime, "ms"));
            case 19:
              _context85.prev = 19;
              this._pollingBlockhash = false;
              return _context85.finish(19);
            case 22:
            case "end":
              return _context85.stop();
          }
        }, _callee84, this, [[1,, 19, 22]]);
      }));
      function _pollNewBlockhash() {
        return _pollNewBlockhash2.apply(this, arguments);
      }
      return _pollNewBlockhash;
    }()
    /**
     * get the stake minimum delegation
     */
  }, {
    key: "getStakeMinimumDelegation",
    value: function () {
      var _getStakeMinimumDelegation = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee85(config) {
        var _extractCommitmentFro24, commitment, configArg, args, unsafeRes, res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee85$(_context86) {
          while (1) switch (_context86.prev = _context86.next) {
            case 0:
              _extractCommitmentFro24 = extractCommitmentFromConfig(config), commitment = _extractCommitmentFro24.commitment, configArg = _extractCommitmentFro24.config;
              args = this._buildArgs([], commitment, 'base64', configArg);
              _context86.next = 4;
              return this._rpcRequest('getStakeMinimumDelegation', args);
            case 4:
              unsafeRes = _context86.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .number */ .Rx)()));
              if (!('error' in res)) {
                _context86.next = 8;
                break;
              }
              throw new SolanaJSONRPCError(res.error, "failed to get stake minimum delegation");
            case 8:
              return _context86.abrupt("return", res.result);
            case 9:
            case "end":
              return _context86.stop();
          }
        }, _callee85, this);
      }));
      function getStakeMinimumDelegation(_x125) {
        return _getStakeMinimumDelegation.apply(this, arguments);
      }
      return getStakeMinimumDelegation;
    }()
    /**
     * Simulate a transaction
     *
     * @deprecated Instead, call {@link simulateTransaction} with {@link
     * VersionedTransaction} and {@link SimulateTransactionConfig} parameters
     */
  }, {
    key: "simulateTransaction",
    value:
    /**
     * Simulate a transaction
     */
    // eslint-disable-next-line no-dupe-class-members
    function () {
      var _simulateTransaction = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee86(transactionOrMessage, configOrSigners, includeAccounts) {
        var versionedTx, _wireTransaction, _encodedTransaction, _config2, _args87, _unsafeRes, _res5, transaction, originalTx, signers, _transaction, disableCache, _transaction2, latestBlockhash, _signature, message, signData, wireTransaction, encodedTransaction, config, addresses, args, unsafeRes, res, _logs, traceIndent, logTrace;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee86$(_context87) {
          while (1) switch (_context87.prev = _context87.next) {
            case 0:
              if (!('message' in transactionOrMessage)) {
                _context87.next = 17;
                break;
              }
              versionedTx = transactionOrMessage;
              _wireTransaction = versionedTx.serialize();
              _encodedTransaction = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(_wireTransaction).toString('base64');
              if (!(Array.isArray(configOrSigners) || includeAccounts !== undefined)) {
                _context87.next = 6;
                break;
              }
              throw new Error('Invalid arguments');
            case 6:
              _config2 = configOrSigners || {};
              _config2.encoding = 'base64';
              if (!('commitment' in _config2)) {
                _config2.commitment = this.commitment;
              }
              _args87 = [_encodedTransaction, _config2];
              _context87.next = 12;
              return this._rpcRequest('simulateTransaction', _args87);
            case 12:
              _unsafeRes = _context87.sent;
              _res5 = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(_unsafeRes, SimulatedTransactionResponseStruct);
              if (!('error' in _res5)) {
                _context87.next = 16;
                break;
              }
              throw new Error('failed to simulate transaction: ' + _res5.error.message);
            case 16:
              return _context87.abrupt("return", _res5.result);
            case 17:
              if (transactionOrMessage instanceof Transaction) {
                originalTx = transactionOrMessage;
                transaction = new Transaction();
                transaction.feePayer = originalTx.feePayer;
                transaction.instructions = transactionOrMessage.instructions;
                transaction.nonceInfo = originalTx.nonceInfo;
                transaction.signatures = originalTx.signatures;
              } else {
                transaction = Transaction.populate(transactionOrMessage);
                // HACK: this function relies on mutating the populated transaction
                transaction._message = transaction._json = undefined;
              }
              if (!(configOrSigners !== undefined && !Array.isArray(configOrSigners))) {
                _context87.next = 20;
                break;
              }
              throw new Error('Invalid arguments');
            case 20:
              signers = configOrSigners;
              if (!(transaction.nonceInfo && signers)) {
                _context87.next = 25;
                break;
              }
              (_transaction = transaction).sign.apply(_transaction, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_19__/* ["default"] */ .Z)(signers));
              _context87.next = 45;
              break;
            case 25:
              disableCache = this._disableBlockhashCaching;
            case 26:
              _context87.next = 28;
              return this._blockhashWithExpiryBlockHeight(disableCache);
            case 28:
              latestBlockhash = _context87.sent;
              transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
              transaction.recentBlockhash = latestBlockhash.blockhash;
              if (signers) {
                _context87.next = 33;
                break;
              }
              return _context87.abrupt("break", 45);
            case 33:
              (_transaction2 = transaction).sign.apply(_transaction2, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_19__/* ["default"] */ .Z)(signers));
              if (transaction.signature) {
                _context87.next = 36;
                break;
              }
              throw new Error('!signature');
            case 36:
              _signature = transaction.signature.toString('base64');
              if (!(!this._blockhashInfo.simulatedSignatures.includes(_signature) && !this._blockhashInfo.transactionSignatures.includes(_signature))) {
                _context87.next = 42;
                break;
              }
              // The signature of this transaction has not been seen before with the
              // current recentBlockhash, all done. Let's break
              this._blockhashInfo.simulatedSignatures.push(_signature);
              return _context87.abrupt("break", 45);
            case 42:
              // This transaction would be treated as duplicate (its derived signature
              // matched to one of already recorded signatures).
              // So, we must fetch a new blockhash for a different signature by disabling
              // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).
              disableCache = true;
            case 43:
              _context87.next = 26;
              break;
            case 45:
              message = transaction._compile();
              signData = message.serialize();
              wireTransaction = transaction._serialize(signData);
              encodedTransaction = wireTransaction.toString('base64');
              config = {
                encoding: 'base64',
                commitment: this.commitment
              };
              if (includeAccounts) {
                addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map(function (key) {
                  return key.toBase58();
                });
                config['accounts'] = {
                  encoding: 'base64',
                  addresses: addresses
                };
              }
              if (signers) {
                config.sigVerify = true;
              }
              args = [encodedTransaction, config];
              _context87.next = 55;
              return this._rpcRequest('simulateTransaction', args);
            case 55:
              unsafeRes = _context87.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, SimulatedTransactionResponseStruct);
              if (!('error' in res)) {
                _context87.next = 60;
                break;
              }
              if ('data' in res.error) {
                _logs = res.error.data.logs;
                if (_logs && Array.isArray(_logs)) {
                  traceIndent = '\n    ';
                  logTrace = traceIndent + _logs.join(traceIndent);
                  console.error(res.error.message, logTrace);
                }
              }
              throw new SendTransactionError('failed to simulate transaction: ' + res.error.message, _logs);
            case 60:
              return _context87.abrupt("return", res.result);
            case 61:
            case "end":
              return _context87.stop();
          }
        }, _callee86, this);
      }));
      function simulateTransaction(_x126, _x127, _x128) {
        return _simulateTransaction.apply(this, arguments);
      }
      return simulateTransaction;
    }()
    /**
     * Sign and send a transaction
     *
     * @deprecated Instead, call {@link sendTransaction} with a {@link
     * VersionedTransaction}
     */
  }, {
    key: "sendTransaction",
    value:
    /**
     * Sign and send a transaction
     */
    // eslint-disable-next-line no-dupe-class-members
    function () {
      var _sendTransaction = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee87(transaction, signersOrOptions, options) {
        var _wireTransaction2, signers, disableCache, latestBlockhash, _signature2, wireTransaction;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee87$(_context88) {
          while (1) switch (_context88.prev = _context88.next) {
            case 0:
              if (!('version' in transaction)) {
                _context88.next = 7;
                break;
              }
              if (!(signersOrOptions && Array.isArray(signersOrOptions))) {
                _context88.next = 3;
                break;
              }
              throw new Error('Invalid arguments');
            case 3:
              _wireTransaction2 = transaction.serialize();
              _context88.next = 6;
              return this.sendRawTransaction(_wireTransaction2, signersOrOptions);
            case 6:
              return _context88.abrupt("return", _context88.sent);
            case 7:
              if (!(signersOrOptions === undefined || !Array.isArray(signersOrOptions))) {
                _context88.next = 9;
                break;
              }
              throw new Error('Invalid arguments');
            case 9:
              signers = signersOrOptions;
              if (!transaction.nonceInfo) {
                _context88.next = 14;
                break;
              }
              transaction.sign.apply(transaction, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_19__/* ["default"] */ .Z)(signers));
              _context88.next = 32;
              break;
            case 14:
              disableCache = this._disableBlockhashCaching;
            case 15:
              _context88.next = 17;
              return this._blockhashWithExpiryBlockHeight(disableCache);
            case 17:
              latestBlockhash = _context88.sent;
              transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
              transaction.recentBlockhash = latestBlockhash.blockhash;
              transaction.sign.apply(transaction, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_19__/* ["default"] */ .Z)(signers));
              if (transaction.signature) {
                _context88.next = 23;
                break;
              }
              throw new Error('!signature');
            case 23:
              _signature2 = transaction.signature.toString('base64');
              if (this._blockhashInfo.transactionSignatures.includes(_signature2)) {
                _context88.next = 29;
                break;
              }
              // The signature of this transaction has not been seen before with the
              // current recentBlockhash, all done. Let's break
              this._blockhashInfo.transactionSignatures.push(_signature2);
              return _context88.abrupt("break", 32);
            case 29:
              // This transaction would be treated as duplicate (its derived signature
              // matched to one of already recorded signatures).
              // So, we must fetch a new blockhash for a different signature by disabling
              // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).
              disableCache = true;
            case 30:
              _context88.next = 15;
              break;
            case 32:
              wireTransaction = transaction.serialize();
              _context88.next = 35;
              return this.sendRawTransaction(wireTransaction, options);
            case 35:
              return _context88.abrupt("return", _context88.sent);
            case 36:
            case "end":
              return _context88.stop();
          }
        }, _callee87, this);
      }));
      function sendTransaction(_x129, _x130, _x131) {
        return _sendTransaction.apply(this, arguments);
      }
      return sendTransaction;
    }()
    /**
     * Send a transaction that has already been signed and serialized into the
     * wire format
     */
  }, {
    key: "sendRawTransaction",
    value: function () {
      var _sendRawTransaction = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee88(rawTransaction, options) {
        var encodedTransaction, result;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee88$(_context89) {
          while (1) switch (_context89.prev = _context89.next) {
            case 0:
              encodedTransaction = toBuffer(rawTransaction).toString('base64');
              _context89.next = 3;
              return this.sendEncodedTransaction(encodedTransaction, options);
            case 3:
              result = _context89.sent;
              return _context89.abrupt("return", result);
            case 5:
            case "end":
              return _context89.stop();
          }
        }, _callee88, this);
      }));
      function sendRawTransaction(_x132, _x133) {
        return _sendRawTransaction.apply(this, arguments);
      }
      return sendRawTransaction;
    }()
    /**
     * Send a transaction that has already been signed, serialized into the
     * wire format, and encoded as a base64 string
     */
  }, {
    key: "sendEncodedTransaction",
    value: function () {
      var _sendEncodedTransaction = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee89(encodedTransaction, options) {
        var config, skipPreflight, preflightCommitment, args, unsafeRes, res, _logs2;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee89$(_context90) {
          while (1) switch (_context90.prev = _context90.next) {
            case 0:
              config = {
                encoding: 'base64'
              };
              skipPreflight = options && options.skipPreflight;
              preflightCommitment = options && options.preflightCommitment || this.commitment;
              if (options && options.maxRetries != null) {
                config.maxRetries = options.maxRetries;
              }
              if (options && options.minContextSlot != null) {
                config.minContextSlot = options.minContextSlot;
              }
              if (skipPreflight) {
                config.skipPreflight = skipPreflight;
              }
              if (preflightCommitment) {
                config.preflightCommitment = preflightCommitment;
              }
              args = [encodedTransaction, config];
              _context90.next = 10;
              return this._rpcRequest('sendTransaction', args);
            case 10:
              unsafeRes = _context90.sent;
              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(unsafeRes, SendTransactionRpcResult);
              if (!('error' in res)) {
                _context90.next = 15;
                break;
              }
              if ('data' in res.error) {
                _logs2 = res.error.data.logs;
              }
              throw new SendTransactionError('failed to send transaction: ' + res.error.message, _logs2);
            case 15:
              return _context90.abrupt("return", res.result);
            case 16:
            case "end":
              return _context90.stop();
          }
        }, _callee89, this);
      }));
      function sendEncodedTransaction(_x134, _x135) {
        return _sendEncodedTransaction.apply(this, arguments);
      }
      return sendEncodedTransaction;
    }()
    /**
     * @internal
     */
  }, {
    key: "_wsOnOpen",
    value: function _wsOnOpen() {
      var _this9 = this;
      this._rpcWebSocketConnected = true;
      this._rpcWebSocketHeartbeat = setInterval(function () {
        // Ping server every 5s to prevent idle timeouts
        (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee90() {
          return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee90$(_context91) {
            while (1) switch (_context91.prev = _context91.next) {
              case 0:
                _context91.prev = 0;
                _context91.next = 3;
                return _this9._rpcWebSocket.notify('ping');
              case 3:
                _context91.next = 7;
                break;
              case 5:
                _context91.prev = 5;
                _context91.t0 = _context91["catch"](0);
              case 7:
              case "end":
                return _context91.stop();
            }
          }, _callee90, null, [[0, 5]]);
        }))();
      }, 5000);
      this._updateSubscriptions();
    }

    /**
     * @internal
     */
  }, {
    key: "_wsOnError",
    value: function _wsOnError(err) {
      this._rpcWebSocketConnected = false;
      console.error('ws error:', err.message);
    }

    /**
     * @internal
     */
  }, {
    key: "_wsOnClose",
    value: function _wsOnClose(code) {
      var _this10 = this;
      this._rpcWebSocketConnected = false;
      this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER;
      if (this._rpcWebSocketIdleTimeout) {
        clearTimeout(this._rpcWebSocketIdleTimeout);
        this._rpcWebSocketIdleTimeout = null;
      }
      if (this._rpcWebSocketHeartbeat) {
        clearInterval(this._rpcWebSocketHeartbeat);
        this._rpcWebSocketHeartbeat = null;
      }
      if (code === 1000) {
        // explicit close, check if any subscriptions have been made since close
        this._updateSubscriptions();
        return;
      }

      // implicit close, prepare subscriptions for auto-reconnect
      this._subscriptionCallbacksByServerSubscriptionId = {};
      Object.entries(this._subscriptionsByHash).forEach(function (_ref19) {
        var _ref20 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(_ref19, 2),
          hash = _ref20[0],
          subscription = _ref20[1];
        _this10._setSubscription(hash, _objectSpread(_objectSpread({}, subscription), {}, {
          state: 'pending'
        }));
      });
    }

    /**
     * @internal
     */
  }, {
    key: "_setSubscription",
    value: function _setSubscription(hash, nextSubscription) {
      var _this$_subscriptionsB;
      var prevState = (_this$_subscriptionsB = this._subscriptionsByHash[hash]) === null || _this$_subscriptionsB === void 0 ? void 0 : _this$_subscriptionsB.state;
      this._subscriptionsByHash[hash] = nextSubscription;
      if (prevState !== nextSubscription.state) {
        var stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash];
        if (stateChangeCallbacks) {
          stateChangeCallbacks.forEach(function (cb) {
            try {
              cb(nextSubscription.state);
              // eslint-disable-next-line no-empty
            } catch (_unused2) {}
          });
        }
      }
    }

    /**
     * @internal
     */
  }, {
    key: "_onSubscriptionStateChange",
    value: function _onSubscriptionStateChange(clientSubscriptionId, callback) {
      var _this$_subscriptionSt,
        _this11 = this;
      var hash = this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
      if (hash == null) {
        return function () {};
      }
      var stateChangeCallbacks = (_this$_subscriptionSt = this._subscriptionStateChangeCallbacksByHash)[hash] || (_this$_subscriptionSt[hash] = new Set());
      stateChangeCallbacks.add(callback);
      return function () {
        stateChangeCallbacks["delete"](callback);
        if (stateChangeCallbacks.size === 0) {
          delete _this11._subscriptionStateChangeCallbacksByHash[hash];
        }
      };
    }

    /**
     * @internal
     */
  }, {
    key: "_updateSubscriptions",
    value: function () {
      var _updateSubscriptions2 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee94() {
        var _this12 = this;
        var activeWebSocketGeneration, isCurrentConnectionStillActive;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee94$(_context95) {
          while (1) switch (_context95.prev = _context95.next) {
            case 0:
              if (!(Object.keys(this._subscriptionsByHash).length === 0)) {
                _context95.next = 3;
                break;
              }
              if (this._rpcWebSocketConnected) {
                this._rpcWebSocketConnected = false;
                this._rpcWebSocketIdleTimeout = setTimeout(function () {
                  _this12._rpcWebSocketIdleTimeout = null;
                  try {
                    _this12._rpcWebSocket.close();
                  } catch (err) {
                    // swallow error if socket has already been closed.
                    if (err instanceof Error) {
                      console.log("Error when closing socket connection: ".concat(err.message));
                    }
                  }
                }, 500);
              }
              return _context95.abrupt("return");
            case 3:
              if (this._rpcWebSocketIdleTimeout !== null) {
                clearTimeout(this._rpcWebSocketIdleTimeout);
                this._rpcWebSocketIdleTimeout = null;
                this._rpcWebSocketConnected = true;
              }
              if (this._rpcWebSocketConnected) {
                _context95.next = 7;
                break;
              }
              this._rpcWebSocket.connect();
              return _context95.abrupt("return");
            case 7:
              activeWebSocketGeneration = this._rpcWebSocketGeneration;
              isCurrentConnectionStillActive = function isCurrentConnectionStillActive() {
                return activeWebSocketGeneration === _this12._rpcWebSocketGeneration;
              };
              _context95.next = 11;
              return Promise.all(
              // Don't be tempted to change this to `Object.entries`. We call
              // `_updateSubscriptions` recursively when processing the state,
              // so it's important that we look up the *current* version of
              // each subscription, every time we process a hash.
              Object.keys(this._subscriptionsByHash).map( /*#__PURE__*/function () {
                var _ref21 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee93(hash) {
                  var subscription;
                  return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee93$(_context94) {
                    while (1) switch (_context94.prev = _context94.next) {
                      case 0:
                        subscription = _this12._subscriptionsByHash[hash];
                        if (!(subscription === undefined)) {
                          _context94.next = 3;
                          break;
                        }
                        return _context94.abrupt("return");
                      case 3:
                        _context94.t0 = subscription.state;
                        _context94.next = _context94.t0 === 'pending' ? 6 : _context94.t0 === 'unsubscribed' ? 6 : _context94.t0 === 'subscribed' ? 15 : _context94.t0 === 'subscribing' ? 19 : _context94.t0 === 'unsubscribing' ? 19 : 20;
                        break;
                      case 6:
                        if (!(subscription.callbacks.size === 0)) {
                          _context94.next = 12;
                          break;
                        }
                        /**
                         * You can end up here when:
                         *
                         * - a subscription has recently unsubscribed
                         *   without having new callbacks added to it
                         *   while the unsubscribe was in flight, or
                         * - when a pending subscription has its
                         *   listeners removed before a request was
                         *   sent to the server.
                         *
                         * Being that nobody is interested in this
                         * subscription any longer, delete it.
                         */
                        delete _this12._subscriptionsByHash[hash];
                        if (subscription.state === 'unsubscribed') {
                          delete _this12._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];
                        }
                        _context94.next = 11;
                        return _this12._updateSubscriptions();
                      case 11:
                        return _context94.abrupt("return");
                      case 12:
                        _context94.next = 14;
                        return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee91() {
                          var args, method, _serverSubscriptionId;
                          return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee91$(_context92) {
                            while (1) switch (_context92.prev = _context92.next) {
                              case 0:
                                args = subscription.args, method = subscription.method;
                                _context92.prev = 1;
                                _this12._setSubscription(hash, _objectSpread(_objectSpread({}, subscription), {}, {
                                  state: 'subscribing'
                                }));
                                _context92.next = 5;
                                return _this12._rpcWebSocket.call(method, args);
                              case 5:
                                _serverSubscriptionId = _context92.sent;
                                _this12._setSubscription(hash, _objectSpread(_objectSpread({}, subscription), {}, {
                                  serverSubscriptionId: _serverSubscriptionId,
                                  state: 'subscribed'
                                }));
                                _this12._subscriptionCallbacksByServerSubscriptionId[_serverSubscriptionId] = subscription.callbacks;
                                _context92.next = 10;
                                return _this12._updateSubscriptions();
                              case 10:
                                _context92.next = 20;
                                break;
                              case 12:
                                _context92.prev = 12;
                                _context92.t0 = _context92["catch"](1);
                                if (_context92.t0 instanceof Error) {
                                  console.error("".concat(method, " error for argument"), args, _context92.t0.message);
                                }
                                if (isCurrentConnectionStillActive()) {
                                  _context92.next = 17;
                                  break;
                                }
                                return _context92.abrupt("return");
                              case 17:
                                // TODO: Maybe add an 'errored' state or a retry limit?
                                _this12._setSubscription(hash, _objectSpread(_objectSpread({}, subscription), {}, {
                                  state: 'pending'
                                }));
                                _context92.next = 20;
                                return _this12._updateSubscriptions();
                              case 20:
                              case "end":
                                return _context92.stop();
                            }
                          }, _callee91, null, [[1, 12]]);
                        }))();
                      case 14:
                        return _context94.abrupt("break", 20);
                      case 15:
                        if (!(subscription.callbacks.size === 0)) {
                          _context94.next = 18;
                          break;
                        }
                        _context94.next = 18;
                        return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee92() {
                          var serverSubscriptionId, unsubscribeMethod;
                          return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee92$(_context93) {
                            while (1) switch (_context93.prev = _context93.next) {
                              case 0:
                                serverSubscriptionId = subscription.serverSubscriptionId, unsubscribeMethod = subscription.unsubscribeMethod;
                                if (!_this12._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)) {
                                  _context93.next = 5;
                                  break;
                                }
                                /**
                                 * Special case.
                                 * If we're dealing with a subscription that has been auto-
                                 * disposed by the RPC, then we can skip the RPC call to
                                 * tear down the subscription here.
                                 *
                                 * NOTE: There is a proposal to eliminate this special case, here:
                                 * https://github.com/solana-labs/solana/issues/18892
                                 */
                                _this12._subscriptionsAutoDisposedByRpc["delete"](serverSubscriptionId);
                                _context93.next = 21;
                                break;
                              case 5:
                                _this12._setSubscription(hash, _objectSpread(_objectSpread({}, subscription), {}, {
                                  state: 'unsubscribing'
                                }));
                                _this12._setSubscription(hash, _objectSpread(_objectSpread({}, subscription), {}, {
                                  state: 'unsubscribing'
                                }));
                                _context93.prev = 7;
                                _context93.next = 10;
                                return _this12._rpcWebSocket.call(unsubscribeMethod, [serverSubscriptionId]);
                              case 10:
                                _context93.next = 21;
                                break;
                              case 12:
                                _context93.prev = 12;
                                _context93.t0 = _context93["catch"](7);
                                if (_context93.t0 instanceof Error) {
                                  console.error("".concat(unsubscribeMethod, " error:"), _context93.t0.message);
                                }
                                if (isCurrentConnectionStillActive()) {
                                  _context93.next = 17;
                                  break;
                                }
                                return _context93.abrupt("return");
                              case 17:
                                // TODO: Maybe add an 'errored' state or a retry limit?
                                _this12._setSubscription(hash, _objectSpread(_objectSpread({}, subscription), {}, {
                                  state: 'subscribed'
                                }));
                                _context93.next = 20;
                                return _this12._updateSubscriptions();
                              case 20:
                                return _context93.abrupt("return");
                              case 21:
                                _this12._setSubscription(hash, _objectSpread(_objectSpread({}, subscription), {}, {
                                  state: 'unsubscribed'
                                }));
                                _context93.next = 24;
                                return _this12._updateSubscriptions();
                              case 24:
                              case "end":
                                return _context93.stop();
                            }
                          }, _callee92, null, [[7, 12]]);
                        }))();
                      case 18:
                        return _context94.abrupt("break", 20);
                      case 19:
                        return _context94.abrupt("break", 20);
                      case 20:
                      case "end":
                        return _context94.stop();
                    }
                  }, _callee93);
                }));
                return function (_x136) {
                  return _ref21.apply(this, arguments);
                };
              }()));
            case 11:
            case "end":
              return _context95.stop();
          }
        }, _callee94, this);
      }));
      function _updateSubscriptions() {
        return _updateSubscriptions2.apply(this, arguments);
      }
      return _updateSubscriptions;
    }()
    /**
     * @internal
     */
  }, {
    key: "_handleServerNotification",
    value: function _handleServerNotification(serverSubscriptionId, callbackArgs) {
      var callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];
      if (callbacks === undefined) {
        return;
      }
      callbacks.forEach(function (cb) {
        try {
          cb.apply(void 0, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_19__/* ["default"] */ .Z)(callbackArgs));
        } catch (e) {
          console.error(e);
        }
      });
    }

    /**
     * @internal
     */
  }, {
    key: "_wsOnAccountNotification",
    value: function _wsOnAccountNotification(notification) {
      var _create = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(notification, AccountNotificationResult),
        result = _create.result,
        subscription = _create.subscription;
      this._handleServerNotification(subscription, [result.value, result.context]);
    }

    /**
     * @internal
     */
  }, {
    key: "_makeSubscription",
    value: function _makeSubscription(subscriptionConfig,
    /**
     * When preparing `args` for a call to `_makeSubscription`, be sure
     * to carefully apply a default `commitment` property, if necessary.
     *
     * - If the user supplied a `commitment` use that.
     * - Otherwise, if the `Connection::commitment` is set, use that.
     * - Otherwise, set it to the RPC server default: `finalized`.
     *
     * This is extremely important to ensure that these two fundamentally
     * identical subscriptions produce the same identifying hash:
     *
     * - A subscription made without specifying a commitment.
     * - A subscription made where the commitment specified is the same
     *   as the default applied to the subscription above.
     *
     * Example; these two subscriptions must produce the same hash:
     *
     * - An `accountSubscribe` subscription for `'PUBKEY'`
     * - An `accountSubscribe` subscription for `'PUBKEY'` with commitment
     *   `'finalized'`.
     *
     * See the 'making a subscription with defaulted params omitted' test
     * in `connection-subscriptions.ts` for more.
     */
    args) {
      var _this13 = this;
      var clientSubscriptionId = this._nextClientSubscriptionId++;
      var hash = fastStableStringify$1([subscriptionConfig.method, args], true /* isArrayProp */);

      var existingSubscription = this._subscriptionsByHash[hash];
      if (existingSubscription === undefined) {
        this._subscriptionsByHash[hash] = _objectSpread(_objectSpread({}, subscriptionConfig), {}, {
          args: args,
          callbacks: new Set([subscriptionConfig.callback]),
          state: 'pending'
        });
      } else {
        existingSubscription.callbacks.add(subscriptionConfig.callback);
      }
      this._subscriptionHashByClientSubscriptionId[clientSubscriptionId] = hash;
      this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = /*#__PURE__*/(0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee95() {
        var subscription;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee95$(_context96) {
          while (1) switch (_context96.prev = _context96.next) {
            case 0:
              delete _this13._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
              delete _this13._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
              subscription = _this13._subscriptionsByHash[hash];
              assert(subscription !== undefined, "Could not find a `Subscription` when tearing down client subscription #".concat(clientSubscriptionId));
              subscription.callbacks["delete"](subscriptionConfig.callback);
              _context96.next = 7;
              return _this13._updateSubscriptions();
            case 7:
            case "end":
              return _context96.stop();
          }
        }, _callee95);
      }));
      this._updateSubscriptions();
      return clientSubscriptionId;
    }

    /**
     * Register a callback to be invoked whenever the specified account changes
     *
     * @param publicKey Public key of the account to monitor
     * @param callback Function to invoke whenever the account is changed
     * @param commitment Specify the commitment level account changes must reach before notification
     * @return subscription id
     */
  }, {
    key: "onAccountChange",
    value: function onAccountChange(publicKey, callback, commitment) {
      var args = this._buildArgs([publicKey.toBase58()], commitment || this._commitment || 'finalized',
      // Apply connection/server default.
      'base64');
      return this._makeSubscription({
        callback: callback,
        method: 'accountSubscribe',
        unsubscribeMethod: 'accountUnsubscribe'
      }, args);
    }

    /**
     * Deregister an account notification callback
     *
     * @param id client subscription id to deregister
     */
  }, {
    key: "removeAccountChangeListener",
    value: function () {
      var _removeAccountChangeListener = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee96(clientSubscriptionId) {
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee96$(_context97) {
          while (1) switch (_context97.prev = _context97.next) {
            case 0:
              _context97.next = 2;
              return this._unsubscribeClientSubscription(clientSubscriptionId, 'account change');
            case 2:
            case "end":
              return _context97.stop();
          }
        }, _callee96, this);
      }));
      function removeAccountChangeListener(_x137) {
        return _removeAccountChangeListener.apply(this, arguments);
      }
      return removeAccountChangeListener;
    }()
    /**
     * @internal
     */
  }, {
    key: "_wsOnProgramAccountNotification",
    value: function _wsOnProgramAccountNotification(notification) {
      var _create2 = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(notification, ProgramAccountNotificationResult),
        result = _create2.result,
        subscription = _create2.subscription;
      this._handleServerNotification(subscription, [{
        accountId: result.value.pubkey,
        accountInfo: result.value.account
      }, result.context]);
    }

    /**
     * Register a callback to be invoked whenever accounts owned by the
     * specified program change
     *
     * @param programId Public key of the program to monitor
     * @param callback Function to invoke whenever the account is changed
     * @param commitment Specify the commitment level account changes must reach before notification
     * @param filters The program account filters to pass into the RPC method
     * @return subscription id
     */
  }, {
    key: "onProgramAccountChange",
    value: function onProgramAccountChange(programId, callback, commitment, filters) {
      var args = this._buildArgs([programId.toBase58()], commitment || this._commitment || 'finalized',
      // Apply connection/server default.
      'base64' /* encoding */, filters ? {
        filters: filters
      } : undefined /* extra */);

      return this._makeSubscription({
        callback: callback,
        method: 'programSubscribe',
        unsubscribeMethod: 'programUnsubscribe'
      }, args);
    }

    /**
     * Deregister an account notification callback
     *
     * @param id client subscription id to deregister
     */
  }, {
    key: "removeProgramAccountChangeListener",
    value: function () {
      var _removeProgramAccountChangeListener = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee97(clientSubscriptionId) {
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee97$(_context98) {
          while (1) switch (_context98.prev = _context98.next) {
            case 0:
              _context98.next = 2;
              return this._unsubscribeClientSubscription(clientSubscriptionId, 'program account change');
            case 2:
            case "end":
              return _context98.stop();
          }
        }, _callee97, this);
      }));
      function removeProgramAccountChangeListener(_x138) {
        return _removeProgramAccountChangeListener.apply(this, arguments);
      }
      return removeProgramAccountChangeListener;
    }()
    /**
     * Registers a callback to be invoked whenever logs are emitted.
     */
  }, {
    key: "onLogs",
    value: function onLogs(filter, callback, commitment) {
      var args = this._buildArgs([(0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_25__/* ["default"] */ .Z)(filter) === 'object' ? {
        mentions: [filter.toString()]
      } : filter], commitment || this._commitment || 'finalized' // Apply connection/server default.
      );

      return this._makeSubscription({
        callback: callback,
        method: 'logsSubscribe',
        unsubscribeMethod: 'logsUnsubscribe'
      }, args);
    }

    /**
     * Deregister a logs callback.
     *
     * @param id client subscription id to deregister.
     */
  }, {
    key: "removeOnLogsListener",
    value: function () {
      var _removeOnLogsListener = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee98(clientSubscriptionId) {
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee98$(_context99) {
          while (1) switch (_context99.prev = _context99.next) {
            case 0:
              _context99.next = 2;
              return this._unsubscribeClientSubscription(clientSubscriptionId, 'logs');
            case 2:
            case "end":
              return _context99.stop();
          }
        }, _callee98, this);
      }));
      function removeOnLogsListener(_x139) {
        return _removeOnLogsListener.apply(this, arguments);
      }
      return removeOnLogsListener;
    }()
    /**
     * @internal
     */
  }, {
    key: "_wsOnLogsNotification",
    value: function _wsOnLogsNotification(notification) {
      var _create3 = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(notification, LogsNotificationResult),
        result = _create3.result,
        subscription = _create3.subscription;
      this._handleServerNotification(subscription, [result.value, result.context]);
    }

    /**
     * @internal
     */
  }, {
    key: "_wsOnSlotNotification",
    value: function _wsOnSlotNotification(notification) {
      var _create4 = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(notification, SlotNotificationResult),
        result = _create4.result,
        subscription = _create4.subscription;
      this._handleServerNotification(subscription, [result]);
    }

    /**
     * Register a callback to be invoked upon slot changes
     *
     * @param callback Function to invoke whenever the slot changes
     * @return subscription id
     */
  }, {
    key: "onSlotChange",
    value: function onSlotChange(callback) {
      return this._makeSubscription({
        callback: callback,
        method: 'slotSubscribe',
        unsubscribeMethod: 'slotUnsubscribe'
      }, [] /* args */);
    }

    /**
     * Deregister a slot notification callback
     *
     * @param id client subscription id to deregister
     */
  }, {
    key: "removeSlotChangeListener",
    value: function () {
      var _removeSlotChangeListener = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee99(clientSubscriptionId) {
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee99$(_context100) {
          while (1) switch (_context100.prev = _context100.next) {
            case 0:
              _context100.next = 2;
              return this._unsubscribeClientSubscription(clientSubscriptionId, 'slot change');
            case 2:
            case "end":
              return _context100.stop();
          }
        }, _callee99, this);
      }));
      function removeSlotChangeListener(_x140) {
        return _removeSlotChangeListener.apply(this, arguments);
      }
      return removeSlotChangeListener;
    }()
    /**
     * @internal
     */
  }, {
    key: "_wsOnSlotUpdatesNotification",
    value: function _wsOnSlotUpdatesNotification(notification) {
      var _create5 = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(notification, SlotUpdateNotificationResult),
        result = _create5.result,
        subscription = _create5.subscription;
      this._handleServerNotification(subscription, [result]);
    }

    /**
     * Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s
     * may be useful to track live progress of a cluster.
     *
     * @param callback Function to invoke whenever the slot updates
     * @return subscription id
     */
  }, {
    key: "onSlotUpdate",
    value: function onSlotUpdate(callback) {
      return this._makeSubscription({
        callback: callback,
        method: 'slotsUpdatesSubscribe',
        unsubscribeMethod: 'slotsUpdatesUnsubscribe'
      }, [] /* args */);
    }

    /**
     * Deregister a slot update notification callback
     *
     * @param id client subscription id to deregister
     */
  }, {
    key: "removeSlotUpdateListener",
    value: function () {
      var _removeSlotUpdateListener = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee100(clientSubscriptionId) {
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee100$(_context101) {
          while (1) switch (_context101.prev = _context101.next) {
            case 0:
              _context101.next = 2;
              return this._unsubscribeClientSubscription(clientSubscriptionId, 'slot update');
            case 2:
            case "end":
              return _context101.stop();
          }
        }, _callee100, this);
      }));
      function removeSlotUpdateListener(_x141) {
        return _removeSlotUpdateListener.apply(this, arguments);
      }
      return removeSlotUpdateListener;
    }()
    /**
     * @internal
     */
  }, {
    key: "_unsubscribeClientSubscription",
    value: function () {
      var _unsubscribeClientSubscription2 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee101(clientSubscriptionId, subscriptionName) {
        var dispose;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee101$(_context102) {
          while (1) switch (_context102.prev = _context102.next) {
            case 0:
              dispose = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
              if (!dispose) {
                _context102.next = 6;
                break;
              }
              _context102.next = 4;
              return dispose();
            case 4:
              _context102.next = 7;
              break;
            case 6:
              console.warn('Ignored unsubscribe request because an active subscription with id ' + "`".concat(clientSubscriptionId, "` for '").concat(subscriptionName, "' events ") + 'could not be found.');
            case 7:
            case "end":
              return _context102.stop();
          }
        }, _callee101, this);
      }));
      function _unsubscribeClientSubscription(_x142, _x143) {
        return _unsubscribeClientSubscription2.apply(this, arguments);
      }
      return _unsubscribeClientSubscription;
    }()
  }, {
    key: "_buildArgs",
    value: function _buildArgs(args, override, encoding, extra) {
      var commitment = override || this._commitment;
      if (commitment || encoding || extra) {
        var _options = {};
        if (encoding) {
          _options.encoding = encoding;
        }
        if (commitment) {
          _options.commitment = commitment;
        }
        if (extra) {
          _options = Object.assign(_options, extra);
        }
        args.push(_options);
      }
      return args;
    }

    /**
     * @internal
     */
  }, {
    key: "_buildArgsAtLeastConfirmed",
    value: function _buildArgsAtLeastConfirmed(args, override, encoding, extra) {
      var commitment = override || this._commitment;
      if (commitment && !['confirmed', 'finalized'].includes(commitment)) {
        throw new Error('Using Connection with default commitment: `' + this._commitment + '`, but method requires at least `confirmed`');
      }
      return this._buildArgs(args, override, encoding, extra);
    }

    /**
     * @internal
     */
  }, {
    key: "_wsOnSignatureNotification",
    value: function _wsOnSignatureNotification(notification) {
      var _create6 = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(notification, SignatureNotificationResult),
        result = _create6.result,
        subscription = _create6.subscription;
      if (result.value !== 'receivedSignature') {
        /**
         * Special case.
         * After a signature is processed, RPCs automatically dispose of the
         * subscription on the server side. We need to track which of these
         * subscriptions have been disposed in such a way, so that we know
         * whether the client is dealing with a not-yet-processed signature
         * (in which case we must tear down the server subscription) or an
         * already-processed signature (in which case the client can simply
         * clear out the subscription locally without telling the server).
         *
         * NOTE: There is a proposal to eliminate this special case, here:
         * https://github.com/solana-labs/solana/issues/18892
         */
        this._subscriptionsAutoDisposedByRpc.add(subscription);
      }
      this._handleServerNotification(subscription, result.value === 'receivedSignature' ? [{
        type: 'received'
      }, result.context] : [{
        type: 'status',
        result: result.value
      }, result.context]);
    }

    /**
     * Register a callback to be invoked upon signature updates
     *
     * @param signature Transaction signature string in base 58
     * @param callback Function to invoke on signature notifications
     * @param commitment Specify the commitment level signature must reach before notification
     * @return subscription id
     */
  }, {
    key: "onSignature",
    value: function onSignature(signature, _callback, commitment) {
      var _this14 = this;
      var args = this._buildArgs([signature], commitment || this._commitment || 'finalized' // Apply connection/server default.
      );

      var clientSubscriptionId = this._makeSubscription({
        callback: function callback(notification, context) {
          if (notification.type === 'status') {
            _callback(notification.result, context);
            // Signatures subscriptions are auto-removed by the RPC service
            // so no need to explicitly send an unsubscribe message.
            try {
              _this14.removeSignatureListener(clientSubscriptionId);
              // eslint-disable-next-line no-empty
            } catch (_err) {
              // Already removed.
            }
          }
        },
        method: 'signatureSubscribe',
        unsubscribeMethod: 'signatureUnsubscribe'
      }, args);
      return clientSubscriptionId;
    }

    /**
     * Register a callback to be invoked when a transaction is
     * received and/or processed.
     *
     * @param signature Transaction signature string in base 58
     * @param callback Function to invoke on signature notifications
     * @param options Enable received notifications and set the commitment
     *   level that signature must reach before notification
     * @return subscription id
     */
  }, {
    key: "onSignatureWithOptions",
    value: function onSignatureWithOptions(signature, _callback2, options) {
      var _this15 = this;
      var _options$commitment = _objectSpread(_objectSpread({}, options), {}, {
          commitment: options && options.commitment || this._commitment || 'finalized' // Apply connection/server default.
        }),
        commitment = _options$commitment.commitment,
        extra = (0,_babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_24__/* ["default"] */ .Z)(_options$commitment, _excluded4);
      var args = this._buildArgs([signature], commitment, undefined /* encoding */, extra);
      var clientSubscriptionId = this._makeSubscription({
        callback: function callback(notification, context) {
          _callback2(notification, context);
          // Signatures subscriptions are auto-removed by the RPC service
          // so no need to explicitly send an unsubscribe message.
          try {
            _this15.removeSignatureListener(clientSubscriptionId);
            // eslint-disable-next-line no-empty
          } catch (_err) {
            // Already removed.
          }
        },
        method: 'signatureSubscribe',
        unsubscribeMethod: 'signatureUnsubscribe'
      }, args);
      return clientSubscriptionId;
    }

    /**
     * Deregister a signature notification callback
     *
     * @param id client subscription id to deregister
     */
  }, {
    key: "removeSignatureListener",
    value: function () {
      var _removeSignatureListener = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee102(clientSubscriptionId) {
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee102$(_context103) {
          while (1) switch (_context103.prev = _context103.next) {
            case 0:
              _context103.next = 2;
              return this._unsubscribeClientSubscription(clientSubscriptionId, 'signature result');
            case 2:
            case "end":
              return _context103.stop();
          }
        }, _callee102, this);
      }));
      function removeSignatureListener(_x144) {
        return _removeSignatureListener.apply(this, arguments);
      }
      return removeSignatureListener;
    }()
    /**
     * @internal
     */
  }, {
    key: "_wsOnRootNotification",
    value: function _wsOnRootNotification(notification) {
      var _create7 = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .create */ .Ue)(notification, RootNotificationResult),
        result = _create7.result,
        subscription = _create7.subscription;
      this._handleServerNotification(subscription, [result]);
    }

    /**
     * Register a callback to be invoked upon root changes
     *
     * @param callback Function to invoke whenever the root changes
     * @return subscription id
     */
  }, {
    key: "onRootChange",
    value: function onRootChange(callback) {
      return this._makeSubscription({
        callback: callback,
        method: 'rootSubscribe',
        unsubscribeMethod: 'rootUnsubscribe'
      }, [] /* args */);
    }

    /**
     * Deregister a root notification callback
     *
     * @param id client subscription id to deregister
     */
  }, {
    key: "removeRootChangeListener",
    value: function () {
      var _removeRootChangeListener = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee103(clientSubscriptionId) {
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee103$(_context104) {
          while (1) switch (_context104.prev = _context104.next) {
            case 0:
              _context104.next = 2;
              return this._unsubscribeClientSubscription(clientSubscriptionId, 'root change');
            case 2:
            case "end":
              return _context104.stop();
          }
        }, _callee103, this);
      }));
      function removeRootChangeListener(_x145) {
        return _removeRootChangeListener.apply(this, arguments);
      }
      return removeRootChangeListener;
    }()
  }]);
  return Connection;
}();

/**
 * Keypair signer interface
 */

/**
 * An account keypair used for signing transactions.
 */
var Keypair = /*#__PURE__*/function () {
  /**
   * Create a new keypair instance.
   * Generate random keypair if no {@link Ed25519Keypair} is provided.
   *
   * @param {Ed25519Keypair} keypair ed25519 keypair
   */
  function Keypair(keypair) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, Keypair);
    this._keypair = void 0;
    this._keypair = keypair !== null && keypair !== void 0 ? keypair : generateKeypair();
  }

  /**
   * Generate a new random keypair
   *
   * @returns {Keypair} Keypair
   */
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(Keypair, [{
    key: "publicKey",
    get:
    /**
     * The public key for this keypair
     *
     * @returns {PublicKey} PublicKey
     */
    function get() {
      return new PublicKey(this._keypair.publicKey);
    }

    /**
     * The raw secret key for this keypair
     * @returns {Uint8Array} Secret key in an array of Uint8 bytes
     */
  }, {
    key: "secretKey",
    get: function get() {
      return new Uint8Array(this._keypair.secretKey);
    }
  }], [{
    key: "generate",
    value: function generate() {
      return new Keypair(generateKeypair());
    }

    /**
     * Create a keypair from a raw secret key byte array.
     *
     * This method should only be used to recreate a keypair from a previously
     * generated secret key. Generating keypairs from a random seed should be done
     * with the {@link Keypair.fromSeed} method.
     *
     * @throws error if the provided secret key is invalid and validation is not skipped.
     *
     * @param secretKey secret key byte array
     * @param options skip secret key validation
     *
     * @returns {Keypair} Keypair
     */
  }, {
    key: "fromSecretKey",
    value: function fromSecretKey(secretKey, options) {
      if (secretKey.byteLength !== 64) {
        throw new Error('bad secret key size');
      }
      var publicKey = secretKey.slice(32, 64);
      if (!options || !options.skipValidation) {
        var privateScalar = secretKey.slice(0, 32);
        var computedPublicKey = getPublicKey(privateScalar);
        for (var ii = 0; ii < 32; ii++) {
          if (publicKey[ii] !== computedPublicKey[ii]) {
            throw new Error('provided secretKey is invalid');
          }
        }
      }
      return new Keypair({
        publicKey: publicKey,
        secretKey: secretKey
      });
    }

    /**
     * Generate a keypair from a 32 byte seed.
     *
     * @param seed seed byte array
     *
     * @returns {Keypair} Keypair
     */
  }, {
    key: "fromSeed",
    value: function fromSeed(seed) {
      var publicKey = getPublicKey(seed);
      var secretKey = new Uint8Array(64);
      secretKey.set(seed);
      secretKey.set(publicKey, 32);
      return new Keypair({
        publicKey: publicKey,
        secretKey: secretKey
      });
    }
  }]);
  return Keypair;
}();

/**
 * An enumeration of valid LookupTableInstructionType's
 */

/**
 * An enumeration of valid address lookup table InstructionType's
 * @internal
 */
var LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({
  CreateLookupTable: {
    index: 0,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction'), u64('recentSlot'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__.u8('bumpSeed')])
  },
  FreezeLookupTable: {
    index: 1,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction')])
  },
  ExtendLookupTable: {
    index: 2,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction'), u64(), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .seq */ .A9(publicKey(), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .offset */ .cv(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq(), -8), 'addresses')])
  },
  DeactivateLookupTable: {
    index: 3,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction')])
  },
  CloseLookupTable: {
    index: 4,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction')])
  }
});
var AddressLookupTableInstruction = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function AddressLookupTableInstruction() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, AddressLookupTableInstruction);
  }
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(AddressLookupTableInstruction, null, [{
    key: "decodeInstructionType",
    value: function decodeInstructionType(instruction) {
      this.checkProgramId(instruction.programId);
      var instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction');
      var index = instructionTypeLayout.decode(instruction.data);
      var type;
      for (var _i = 0, _Object$entries = Object.entries(LOOKUP_TABLE_INSTRUCTION_LAYOUTS); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(_Object$entries[_i], 2),
          layoutType = _Object$entries$_i[0],
          layout = _Object$entries$_i[1];
        if (layout.index == index) {
          type = layoutType;
          break;
        }
      }
      if (!type) {
        throw new Error('Invalid Instruction. Should be a LookupTable Instruction');
      }
      return type;
    }
  }, {
    key: "decodeCreateLookupTable",
    value: function decodeCreateLookupTable(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeysLength(instruction.keys, 4);
      var _decodeData = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, instruction.data),
        recentSlot = _decodeData.recentSlot;
      return {
        authority: instruction.keys[1].pubkey,
        payer: instruction.keys[2].pubkey,
        recentSlot: Number(recentSlot)
      };
    }
  }, {
    key: "decodeExtendLookupTable",
    value: function decodeExtendLookupTable(instruction) {
      this.checkProgramId(instruction.programId);
      if (instruction.keys.length < 2) {
        throw new Error("invalid instruction; found ".concat(instruction.keys.length, " keys, expected at least 2"));
      }
      var _decodeData2 = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable, instruction.data),
        addresses = _decodeData2.addresses;
      return {
        lookupTable: instruction.keys[0].pubkey,
        authority: instruction.keys[1].pubkey,
        payer: instruction.keys.length > 2 ? instruction.keys[2].pubkey : undefined,
        addresses: addresses.map(function (buffer) {
          return new PublicKey(buffer);
        })
      };
    }
  }, {
    key: "decodeCloseLookupTable",
    value: function decodeCloseLookupTable(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeysLength(instruction.keys, 3);
      return {
        lookupTable: instruction.keys[0].pubkey,
        authority: instruction.keys[1].pubkey,
        recipient: instruction.keys[2].pubkey
      };
    }
  }, {
    key: "decodeFreezeLookupTable",
    value: function decodeFreezeLookupTable(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeysLength(instruction.keys, 2);
      return {
        lookupTable: instruction.keys[0].pubkey,
        authority: instruction.keys[1].pubkey
      };
    }
  }, {
    key: "decodeDeactivateLookupTable",
    value: function decodeDeactivateLookupTable(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeysLength(instruction.keys, 2);
      return {
        lookupTable: instruction.keys[0].pubkey,
        authority: instruction.keys[1].pubkey
      };
    }

    /**
     * @internal
     */
  }, {
    key: "checkProgramId",
    value: function checkProgramId(programId) {
      if (!programId.equals(AddressLookupTableProgram.programId)) {
        throw new Error('invalid instruction; programId is not AddressLookupTable Program');
      }
    }
    /**
     * @internal
     */
  }, {
    key: "checkKeysLength",
    value: function checkKeysLength(keys, expectedLength) {
      if (keys.length < expectedLength) {
        throw new Error("invalid instruction; found ".concat(keys.length, " keys, expected at least ").concat(expectedLength));
      }
    }
  }]);
  return AddressLookupTableInstruction;
}();
var AddressLookupTableProgram = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function AddressLookupTableProgram() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, AddressLookupTableProgram);
  }
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(AddressLookupTableProgram, null, [{
    key: "createLookupTable",
    value: function createLookupTable(params) {
      var _PublicKey$findProgra = PublicKey.findProgramAddressSync([params.authority.toBuffer(), (0,bigint_buffer__WEBPACK_IMPORTED_MODULE_6__/* .toBufferLE */ .k$)(BigInt(params.recentSlot), 8)], this.programId),
        _PublicKey$findProgra2 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(_PublicKey$findProgra, 2),
        lookupTableAddress = _PublicKey$findProgra2[0],
        bumpSeed = _PublicKey$findProgra2[1];
      var type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;
      var data = encodeData(type, {
        recentSlot: BigInt(params.recentSlot),
        bumpSeed: bumpSeed
      });
      var keys = [{
        pubkey: lookupTableAddress,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authority,
        isSigner: true,
        isWritable: false
      }, {
        pubkey: params.payer,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: SystemProgram.programId,
        isSigner: false,
        isWritable: false
      }];
      return [new TransactionInstruction({
        programId: this.programId,
        keys: keys,
        data: data
      }), lookupTableAddress];
    }
  }, {
    key: "freezeLookupTable",
    value: function freezeLookupTable(params) {
      var type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;
      var data = encodeData(type);
      var keys = [{
        pubkey: params.lookupTable,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authority,
        isSigner: true,
        isWritable: false
      }];
      return new TransactionInstruction({
        programId: this.programId,
        keys: keys,
        data: data
      });
    }
  }, {
    key: "extendLookupTable",
    value: function extendLookupTable(params) {
      var type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;
      var data = encodeData(type, {
        addresses: params.addresses.map(function (addr) {
          return addr.toBytes();
        })
      });
      var keys = [{
        pubkey: params.lookupTable,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authority,
        isSigner: true,
        isWritable: false
      }];
      if (params.payer) {
        keys.push({
          pubkey: params.payer,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: SystemProgram.programId,
          isSigner: false,
          isWritable: false
        });
      }
      return new TransactionInstruction({
        programId: this.programId,
        keys: keys,
        data: data
      });
    }
  }, {
    key: "deactivateLookupTable",
    value: function deactivateLookupTable(params) {
      var type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;
      var data = encodeData(type);
      var keys = [{
        pubkey: params.lookupTable,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authority,
        isSigner: true,
        isWritable: false
      }];
      return new TransactionInstruction({
        programId: this.programId,
        keys: keys,
        data: data
      });
    }
  }, {
    key: "closeLookupTable",
    value: function closeLookupTable(params) {
      var type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;
      var data = encodeData(type);
      var keys = [{
        pubkey: params.lookupTable,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authority,
        isSigner: true,
        isWritable: false
      }, {
        pubkey: params.recipient,
        isSigner: false,
        isWritable: true
      }];
      return new TransactionInstruction({
        programId: this.programId,
        keys: keys,
        data: data
      });
    }
  }]);
  return AddressLookupTableProgram;
}();
AddressLookupTableProgram.programId = new PublicKey('AddressLookupTab1e1111111111111111111111111');

/**
 * Compute Budget Instruction class
 */
var ComputeBudgetInstruction = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function ComputeBudgetInstruction() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, ComputeBudgetInstruction);
  }

  /**
   * Decode a compute budget instruction and retrieve the instruction type.
   */
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(ComputeBudgetInstruction, null, [{
    key: "decodeInstructionType",
    value: function decodeInstructionType(instruction) {
      this.checkProgramId(instruction.programId);
      var instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__.u8('instruction');
      var typeIndex = instructionTypeLayout.decode(instruction.data);
      var type;
      for (var _i = 0, _Object$entries = Object.entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(_Object$entries[_i], 2),
          ixType = _Object$entries$_i[0],
          layout = _Object$entries$_i[1];
        if (layout.index == typeIndex) {
          type = ixType;
          break;
        }
      }
      if (!type) {
        throw new Error('Instruction type incorrect; not a ComputeBudgetInstruction');
      }
      return type;
    }

    /**
     * Decode request units compute budget instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeRequestUnits",
    value: function decodeRequestUnits(instruction) {
      this.checkProgramId(instruction.programId);
      var _decodeData = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, instruction.data),
        units = _decodeData.units,
        additionalFee = _decodeData.additionalFee;
      return {
        units: units,
        additionalFee: additionalFee
      };
    }

    /**
     * Decode request heap frame compute budget instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeRequestHeapFrame",
    value: function decodeRequestHeapFrame(instruction) {
      this.checkProgramId(instruction.programId);
      var _decodeData2 = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, instruction.data),
        bytes = _decodeData2.bytes;
      return {
        bytes: bytes
      };
    }

    /**
     * Decode set compute unit limit compute budget instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeSetComputeUnitLimit",
    value: function decodeSetComputeUnitLimit(instruction) {
      this.checkProgramId(instruction.programId);
      var _decodeData3 = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, instruction.data),
        units = _decodeData3.units;
      return {
        units: units
      };
    }

    /**
     * Decode set compute unit price compute budget instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeSetComputeUnitPrice",
    value: function decodeSetComputeUnitPrice(instruction) {
      this.checkProgramId(instruction.programId);
      var _decodeData4 = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, instruction.data),
        microLamports = _decodeData4.microLamports;
      return {
        microLamports: microLamports
      };
    }

    /**
     * @internal
     */
  }, {
    key: "checkProgramId",
    value: function checkProgramId(programId) {
      if (!programId.equals(ComputeBudgetProgram.programId)) {
        throw new Error('invalid instruction; programId is not ComputeBudgetProgram');
      }
    }
  }]);
  return ComputeBudgetInstruction;
}();

/**
 * An enumeration of valid ComputeBudgetInstructionType's
 */

/**
 * Request units instruction params
 */

/**
 * Request heap frame instruction params
 */

/**
 * Set compute unit limit instruction params
 */

/**
 * Set compute unit price instruction params
 */

/**
 * An enumeration of valid ComputeBudget InstructionType's
 * @internal
 */
var COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({
  RequestUnits: {
    index: 0,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__.u8('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('units'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('additionalFee')])
  },
  RequestHeapFrame: {
    index: 1,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__.u8('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('bytes')])
  },
  SetComputeUnitLimit: {
    index: 2,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__.u8('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('units')])
  },
  SetComputeUnitPrice: {
    index: 3,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__.u8('instruction'), u64('microLamports')])
  }
});

/**
 * Factory class for transaction instructions to interact with the Compute Budget program
 */
var ComputeBudgetProgram = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function ComputeBudgetProgram() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, ComputeBudgetProgram);
  }

  /**
   * Public key that identifies the Compute Budget program
   */
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(ComputeBudgetProgram, null, [{
    key: "requestUnits",
    value:
    /**
     * @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}
     */
    function requestUnits(params) {
      var type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;
      var data = encodeData(type, params);
      return new TransactionInstruction({
        keys: [],
        programId: this.programId,
        data: data
      });
    }
  }, {
    key: "requestHeapFrame",
    value: function requestHeapFrame(params) {
      var type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;
      var data = encodeData(type, params);
      return new TransactionInstruction({
        keys: [],
        programId: this.programId,
        data: data
      });
    }
  }, {
    key: "setComputeUnitLimit",
    value: function setComputeUnitLimit(params) {
      var type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;
      var data = encodeData(type, params);
      return new TransactionInstruction({
        keys: [],
        programId: this.programId,
        data: data
      });
    }
  }, {
    key: "setComputeUnitPrice",
    value: function setComputeUnitPrice(params) {
      var type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;
      var data = encodeData(type, {
        microLamports: BigInt(params.microLamports)
      });
      return new TransactionInstruction({
        keys: [],
        programId: this.programId,
        data: data
      });
    }
  }]);
  return ComputeBudgetProgram;
}();
ComputeBudgetProgram.programId = new PublicKey('ComputeBudget111111111111111111111111111111');

var PRIVATE_KEY_BYTES$1 = 64;
var PUBLIC_KEY_BYTES$1 = 32;
var SIGNATURE_BYTES = 64;

/**
 * Params for creating an ed25519 instruction using a public key
 */

/**
 * Params for creating an ed25519 instruction using a private key
 */

var ED25519_INSTRUCTION_LAYOUT = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__.u8('numSignatures'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__.u8('padding'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u16 */ .KB('signatureOffset'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u16 */ .KB('signatureInstructionIndex'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u16 */ .KB('publicKeyOffset'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u16 */ .KB('publicKeyInstructionIndex'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u16 */ .KB('messageDataOffset'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u16 */ .KB('messageDataSize'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u16 */ .KB('messageInstructionIndex')]);
var Ed25519Program = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function Ed25519Program() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, Ed25519Program);
  }

  /**
   * Public key that identifies the ed25519 program
   */
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(Ed25519Program, null, [{
    key: "createInstructionWithPublicKey",
    value:
    /**
     * Create an ed25519 instruction with a public key and signature. The
     * public key must be a buffer that is 32 bytes long, and the signature
     * must be a buffer of 64 bytes.
     */
    function createInstructionWithPublicKey(params) {
      var publicKey = params.publicKey,
        message = params.message,
        signature = params.signature,
        instructionIndex = params.instructionIndex;
      assert(publicKey.length === PUBLIC_KEY_BYTES$1, "Public Key must be ".concat(PUBLIC_KEY_BYTES$1, " bytes but received ").concat(publicKey.length, " bytes"));
      assert(signature.length === SIGNATURE_BYTES, "Signature must be ".concat(SIGNATURE_BYTES, " bytes but received ").concat(signature.length, " bytes"));
      var publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;
      var signatureOffset = publicKeyOffset + publicKey.length;
      var messageDataOffset = signatureOffset + signature.length;
      var numSignatures = 1;
      var instructionData = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(messageDataOffset + message.length);
      var index = instructionIndex == null ? 0xffff // An index of `u16::MAX` makes it default to the current instruction.
      : instructionIndex;
      ED25519_INSTRUCTION_LAYOUT.encode({
        numSignatures: numSignatures,
        padding: 0,
        signatureOffset: signatureOffset,
        signatureInstructionIndex: index,
        publicKeyOffset: publicKeyOffset,
        publicKeyInstructionIndex: index,
        messageDataOffset: messageDataOffset,
        messageDataSize: message.length,
        messageInstructionIndex: index
      }, instructionData);
      instructionData.fill(publicKey, publicKeyOffset);
      instructionData.fill(signature, signatureOffset);
      instructionData.fill(message, messageDataOffset);
      return new TransactionInstruction({
        keys: [],
        programId: Ed25519Program.programId,
        data: instructionData
      });
    }

    /**
     * Create an ed25519 instruction with a private key. The private key
     * must be a buffer that is 64 bytes long.
     */
  }, {
    key: "createInstructionWithPrivateKey",
    value: function createInstructionWithPrivateKey(params) {
      var privateKey = params.privateKey,
        message = params.message,
        instructionIndex = params.instructionIndex;
      assert(privateKey.length === PRIVATE_KEY_BYTES$1, "Private key must be ".concat(PRIVATE_KEY_BYTES$1, " bytes but received ").concat(privateKey.length, " bytes"));
      try {
        var keypair = Keypair.fromSecretKey(privateKey);
        var publicKey = keypair.publicKey.toBytes();
        var signature = sign(message, keypair.secretKey);
        return this.createInstructionWithPublicKey({
          publicKey: publicKey,
          message: message,
          signature: signature,
          instructionIndex: instructionIndex
        });
      } catch (error) {
        throw new Error("Error creating instruction; ".concat(error));
      }
    }
  }]);
  return Ed25519Program;
}();
Ed25519Program.programId = new PublicKey('Ed25519SigVerify111111111111111111111111111');

var ecdsaSign = function ecdsaSign(msgHash, privKey) {
  var signature = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_26__/* .secp256k1 */ .kA.sign(msgHash, privKey);
  return [signature.toCompactRawBytes(), signature.recovery];
};
_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_26__/* .secp256k1 */ .kA.utils.isValidPrivateKey;
var publicKeyCreate = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_26__/* .secp256k1 */ .kA.getPublicKey;

var PRIVATE_KEY_BYTES = 32;
var ETHEREUM_ADDRESS_BYTES = 20;
var PUBLIC_KEY_BYTES = 64;
var SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;

/**
 * Params for creating an secp256k1 instruction using a public key
 */

/**
 * Params for creating an secp256k1 instruction using an Ethereum address
 */

/**
 * Params for creating an secp256k1 instruction using a private key
 */

var SECP256K1_INSTRUCTION_LAYOUT = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__.u8('numSignatures'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u16 */ .KB('signatureOffset'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__.u8('signatureInstructionIndex'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u16 */ .KB('ethAddressOffset'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__.u8('ethAddressInstructionIndex'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u16 */ .KB('messageDataOffset'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u16 */ .KB('messageDataSize'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__.u8('messageInstructionIndex'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .blob */ .Ik(20, 'ethAddress'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .blob */ .Ik(64, 'signature'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__.u8('recoveryId')]);
var Secp256k1Program = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function Secp256k1Program() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, Secp256k1Program);
  }

  /**
   * Public key that identifies the secp256k1 program
   */
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(Secp256k1Program, null, [{
    key: "publicKeyToEthAddress",
    value:
    /**
     * Construct an Ethereum address from a secp256k1 public key buffer.
     * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer
     */
    function publicKeyToEthAddress(publicKey) {
      assert(publicKey.length === PUBLIC_KEY_BYTES, "Public key must be ".concat(PUBLIC_KEY_BYTES, " bytes but received ").concat(publicKey.length, " bytes"));
      try {
        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_27__/* .keccak_256 */ .fr)(toBuffer(publicKey))).slice(-ETHEREUM_ADDRESS_BYTES);
      } catch (error) {
        throw new Error("Error constructing Ethereum address: ".concat(error));
      }
    }

    /**
     * Create an secp256k1 instruction with a public key. The public key
     * must be a buffer that is 64 bytes long.
     */
  }, {
    key: "createInstructionWithPublicKey",
    value: function createInstructionWithPublicKey(params) {
      var publicKey = params.publicKey,
        message = params.message,
        signature = params.signature,
        recoveryId = params.recoveryId,
        instructionIndex = params.instructionIndex;
      return Secp256k1Program.createInstructionWithEthAddress({
        ethAddress: Secp256k1Program.publicKeyToEthAddress(publicKey),
        message: message,
        signature: signature,
        recoveryId: recoveryId,
        instructionIndex: instructionIndex
      });
    }

    /**
     * Create an secp256k1 instruction with an Ethereum address. The address
     * must be a hex string or a buffer that is 20 bytes long.
     */
  }, {
    key: "createInstructionWithEthAddress",
    value: function createInstructionWithEthAddress(params) {
      var rawAddress = params.ethAddress,
        message = params.message,
        signature = params.signature,
        recoveryId = params.recoveryId,
        _params$instructionIn = params.instructionIndex,
        instructionIndex = _params$instructionIn === void 0 ? 0 : _params$instructionIn;
      var ethAddress;
      if (typeof rawAddress === 'string') {
        if (rawAddress.startsWith('0x')) {
          ethAddress = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(rawAddress.substr(2), 'hex');
        } else {
          ethAddress = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(rawAddress, 'hex');
        }
      } else {
        ethAddress = rawAddress;
      }
      assert(ethAddress.length === ETHEREUM_ADDRESS_BYTES, "Address must be ".concat(ETHEREUM_ADDRESS_BYTES, " bytes but received ").concat(ethAddress.length, " bytes"));
      var dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;
      var ethAddressOffset = dataStart;
      var signatureOffset = dataStart + ethAddress.length;
      var messageDataOffset = signatureOffset + signature.length + 1;
      var numSignatures = 1;
      var instructionData = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);
      SECP256K1_INSTRUCTION_LAYOUT.encode({
        numSignatures: numSignatures,
        signatureOffset: signatureOffset,
        signatureInstructionIndex: instructionIndex,
        ethAddressOffset: ethAddressOffset,
        ethAddressInstructionIndex: instructionIndex,
        messageDataOffset: messageDataOffset,
        messageDataSize: message.length,
        messageInstructionIndex: instructionIndex,
        signature: toBuffer(signature),
        ethAddress: toBuffer(ethAddress),
        recoveryId: recoveryId
      }, instructionData);
      instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);
      return new TransactionInstruction({
        keys: [],
        programId: Secp256k1Program.programId,
        data: instructionData
      });
    }

    /**
     * Create an secp256k1 instruction with a private key. The private key
     * must be a buffer that is 32 bytes long.
     */
  }, {
    key: "createInstructionWithPrivateKey",
    value: function createInstructionWithPrivateKey(params) {
      var pkey = params.privateKey,
        message = params.message,
        instructionIndex = params.instructionIndex;
      assert(pkey.length === PRIVATE_KEY_BYTES, "Private key must be ".concat(PRIVATE_KEY_BYTES, " bytes but received ").concat(pkey.length, " bytes"));
      try {
        var privateKey = toBuffer(pkey);
        var publicKey = publicKeyCreate(privateKey, false /* isCompressed */).slice(1); // throw away leading byte
        var messageHash = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_27__/* .keccak_256 */ .fr)(toBuffer(message)));
        var _ecdsaSign = ecdsaSign(messageHash, privateKey),
          _ecdsaSign2 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(_ecdsaSign, 2),
          signature = _ecdsaSign2[0],
          recoveryId = _ecdsaSign2[1];
        return this.createInstructionWithPublicKey({
          publicKey: publicKey,
          message: message,
          signature: signature,
          recoveryId: recoveryId,
          instructionIndex: instructionIndex
        });
      } catch (error) {
        throw new Error("Error creating instruction; ".concat(error));
      }
    }
  }]);
  return Secp256k1Program;
}();
Secp256k1Program.programId = new PublicKey('KeccakSecp256k11111111111111111111111111111');

/**
 * Address of the stake config account which configures the rate
 * of stake warmup and cooldown as well as the slashing penalty.
 */
var STAKE_CONFIG_ID = new PublicKey('StakeConfig11111111111111111111111111111111');

/**
 * Stake account authority info
 */
var Authorized = /*#__PURE__*/(0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(
/**
 * Create a new Authorized object
 * @param staker the stake authority
 * @param withdrawer the withdraw authority
 */
function Authorized(staker, withdrawer) {
  (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, Authorized);
  /** stake authority */
  this.staker = void 0;
  /** withdraw authority */
  this.withdrawer = void 0;
  this.staker = staker;
  this.withdrawer = withdrawer;
});
/**
 * Stake account lockup info
 */
var Lockup = /*#__PURE__*/(0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(
/**
 * Create a new Lockup object
 */
function Lockup(unixTimestamp, epoch, custodian) {
  (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, Lockup);
  /** Unix timestamp of lockup expiration */
  this.unixTimestamp = void 0;
  /** Epoch of lockup expiration */
  this.epoch = void 0;
  /** Lockup custodian authority */
  this.custodian = void 0;
  this.unixTimestamp = unixTimestamp;
  this.epoch = epoch;
  this.custodian = custodian;
}

/**
 * Default, inactive Lockup value
 */);
Lockup["default"] = new Lockup(0, 0, PublicKey["default"]);
/**
 * Create stake account transaction params
 */
/**
 * Create stake account with seed transaction params
 */
/**
 * Initialize stake instruction params
 */
/**
 * Delegate stake instruction params
 */
/**
 * Authorize stake instruction params
 */
/**
 * Authorize stake instruction params using a derived key
 */
/**
 * Split stake instruction params
 */
/**
 * Split with seed transaction params
 */
/**
 * Withdraw stake instruction params
 */
/**
 * Deactivate stake instruction params
 */
/**
 * Merge stake instruction params
 */
/**
 * Stake Instruction class
 */
var StakeInstruction = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function StakeInstruction() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, StakeInstruction);
  }

  /**
   * Decode a stake instruction and retrieve the instruction type.
   */
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(StakeInstruction, null, [{
    key: "decodeInstructionType",
    value: function decodeInstructionType(instruction) {
      this.checkProgramId(instruction.programId);
      var instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction');
      var typeIndex = instructionTypeLayout.decode(instruction.data);
      var type;
      for (var _i = 0, _Object$entries = Object.entries(STAKE_INSTRUCTION_LAYOUTS); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(_Object$entries[_i], 2),
          ixType = _Object$entries$_i[0],
          layout = _Object$entries$_i[1];
        if (layout.index == typeIndex) {
          type = ixType;
          break;
        }
      }
      if (!type) {
        throw new Error('Instruction type incorrect; not a StakeInstruction');
      }
      return type;
    }

    /**
     * Decode a initialize stake instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeInitialize",
    value: function decodeInitialize(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 2);
      var _decodeData = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Initialize, instruction.data),
        authorized = _decodeData.authorized,
        lockup = _decodeData.lockup;
      return {
        stakePubkey: instruction.keys[0].pubkey,
        authorized: new Authorized(new PublicKey(authorized.staker), new PublicKey(authorized.withdrawer)),
        lockup: new Lockup(lockup.unixTimestamp, lockup.epoch, new PublicKey(lockup.custodian))
      };
    }

    /**
     * Decode a delegate stake instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeDelegate",
    value: function decodeDelegate(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 6);
      decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Delegate, instruction.data);
      return {
        stakePubkey: instruction.keys[0].pubkey,
        votePubkey: instruction.keys[1].pubkey,
        authorizedPubkey: instruction.keys[5].pubkey
      };
    }

    /**
     * Decode an authorize stake instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeAuthorize",
    value: function decodeAuthorize(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      var _decodeData2 = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Authorize, instruction.data),
        newAuthorized = _decodeData2.newAuthorized,
        stakeAuthorizationType = _decodeData2.stakeAuthorizationType;
      var o = {
        stakePubkey: instruction.keys[0].pubkey,
        authorizedPubkey: instruction.keys[2].pubkey,
        newAuthorizedPubkey: new PublicKey(newAuthorized),
        stakeAuthorizationType: {
          index: stakeAuthorizationType
        }
      };
      if (instruction.keys.length > 3) {
        o.custodianPubkey = instruction.keys[3].pubkey;
      }
      return o;
    }

    /**
     * Decode an authorize-with-seed stake instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeAuthorizeWithSeed",
    value: function decodeAuthorizeWithSeed(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 2);
      var _decodeData3 = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data),
        newAuthorized = _decodeData3.newAuthorized,
        stakeAuthorizationType = _decodeData3.stakeAuthorizationType,
        authoritySeed = _decodeData3.authoritySeed,
        authorityOwner = _decodeData3.authorityOwner;
      var o = {
        stakePubkey: instruction.keys[0].pubkey,
        authorityBase: instruction.keys[1].pubkey,
        authoritySeed: authoritySeed,
        authorityOwner: new PublicKey(authorityOwner),
        newAuthorizedPubkey: new PublicKey(newAuthorized),
        stakeAuthorizationType: {
          index: stakeAuthorizationType
        }
      };
      if (instruction.keys.length > 3) {
        o.custodianPubkey = instruction.keys[3].pubkey;
      }
      return o;
    }

    /**
     * Decode a split stake instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeSplit",
    value: function decodeSplit(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      var _decodeData4 = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Split, instruction.data),
        lamports = _decodeData4.lamports;
      return {
        stakePubkey: instruction.keys[0].pubkey,
        splitStakePubkey: instruction.keys[1].pubkey,
        authorizedPubkey: instruction.keys[2].pubkey,
        lamports: lamports
      };
    }

    /**
     * Decode a merge stake instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeMerge",
    value: function decodeMerge(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Merge, instruction.data);
      return {
        stakePubkey: instruction.keys[0].pubkey,
        sourceStakePubKey: instruction.keys[1].pubkey,
        authorizedPubkey: instruction.keys[4].pubkey
      };
    }

    /**
     * Decode a withdraw stake instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeWithdraw",
    value: function decodeWithdraw(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 5);
      var _decodeData5 = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data),
        lamports = _decodeData5.lamports;
      var o = {
        stakePubkey: instruction.keys[0].pubkey,
        toPubkey: instruction.keys[1].pubkey,
        authorizedPubkey: instruction.keys[4].pubkey,
        lamports: lamports
      };
      if (instruction.keys.length > 5) {
        o.custodianPubkey = instruction.keys[5].pubkey;
      }
      return o;
    }

    /**
     * Decode a deactivate stake instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeDeactivate",
    value: function decodeDeactivate(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Deactivate, instruction.data);
      return {
        stakePubkey: instruction.keys[0].pubkey,
        authorizedPubkey: instruction.keys[2].pubkey
      };
    }

    /**
     * @internal
     */
  }, {
    key: "checkProgramId",
    value: function checkProgramId(programId) {
      if (!programId.equals(StakeProgram.programId)) {
        throw new Error('invalid instruction; programId is not StakeProgram');
      }
    }

    /**
     * @internal
     */
  }, {
    key: "checkKeyLength",
    value: function checkKeyLength(keys, expectedLength) {
      if (keys.length < expectedLength) {
        throw new Error("invalid instruction; found ".concat(keys.length, " keys, expected at least ").concat(expectedLength));
      }
    }
  }]);
  return StakeInstruction;
}();

/**
 * An enumeration of valid StakeInstructionType's
 */

/**
 * An enumeration of valid stake InstructionType's
 * @internal
 */
var STAKE_INSTRUCTION_LAYOUTS = Object.freeze({
  Initialize: {
    index: 0,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction'), authorized(), lockup()])
  },
  Authorize: {
    index: 1,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction'), publicKey('newAuthorized'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('stakeAuthorizationType')])
  },
  Delegate: {
    index: 2,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction')])
  },
  Split: {
    index: 3,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .ns64 */ .gM('lamports')])
  },
  Withdraw: {
    index: 4,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .ns64 */ .gM('lamports')])
  },
  Deactivate: {
    index: 5,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction')])
  },
  Merge: {
    index: 7,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction')])
  },
  AuthorizeWithSeed: {
    index: 8,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction'), publicKey('newAuthorized'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('stakeAuthorizationType'), rustString('authoritySeed'), publicKey('authorityOwner')])
  }
});

/**
 * Stake authorization type
 */

/**
 * An enumeration of valid StakeAuthorizationLayout's
 */
var StakeAuthorizationLayout = Object.freeze({
  Staker: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});

/**
 * Factory class for transactions to interact with the Stake program
 */
var StakeProgram = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function StakeProgram() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, StakeProgram);
  }

  /**
   * Public key that identifies the Stake program
   */
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(StakeProgram, null, [{
    key: "initialize",
    value:
    /**
     * Generate an Initialize instruction to add to a Stake Create transaction
     */
    function initialize(params) {
      var stakePubkey = params.stakePubkey,
        authorized = params.authorized,
        maybeLockup = params.lockup;
      var lockup = maybeLockup || Lockup["default"];
      var type = STAKE_INSTRUCTION_LAYOUTS.Initialize;
      var data = encodeData(type, {
        authorized: {
          staker: toBuffer(authorized.staker.toBuffer()),
          withdrawer: toBuffer(authorized.withdrawer.toBuffer())
        },
        lockup: {
          unixTimestamp: lockup.unixTimestamp,
          epoch: lockup.epoch,
          custodian: toBuffer(lockup.custodian.toBuffer())
        }
      });
      var instructionData = {
        keys: [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_RENT_PUBKEY,
          isSigner: false,
          isWritable: false
        }],
        programId: this.programId,
        data: data
      };
      return new TransactionInstruction(instructionData);
    }

    /**
     * Generate a Transaction that creates a new Stake account at
     *   an address generated with `from`, a seed, and the Stake programId
     */
  }, {
    key: "createAccountWithSeed",
    value: function createAccountWithSeed(params) {
      var transaction = new Transaction();
      transaction.add(SystemProgram.createAccountWithSeed({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.stakePubkey,
        basePubkey: params.basePubkey,
        seed: params.seed,
        lamports: params.lamports,
        space: this.space,
        programId: this.programId
      }));
      var stakePubkey = params.stakePubkey,
        authorized = params.authorized,
        lockup = params.lockup;
      return transaction.add(this.initialize({
        stakePubkey: stakePubkey,
        authorized: authorized,
        lockup: lockup
      }));
    }

    /**
     * Generate a Transaction that creates a new Stake account
     */
  }, {
    key: "createAccount",
    value: function createAccount(params) {
      var transaction = new Transaction();
      transaction.add(SystemProgram.createAccount({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.stakePubkey,
        lamports: params.lamports,
        space: this.space,
        programId: this.programId
      }));
      var stakePubkey = params.stakePubkey,
        authorized = params.authorized,
        lockup = params.lockup;
      return transaction.add(this.initialize({
        stakePubkey: stakePubkey,
        authorized: authorized,
        lockup: lockup
      }));
    }

    /**
     * Generate a Transaction that delegates Stake tokens to a validator
     * Vote PublicKey. This transaction can also be used to redelegate Stake
     * to a new validator Vote PublicKey.
     */
  }, {
    key: "delegate",
    value: function delegate(params) {
      var stakePubkey = params.stakePubkey,
        authorizedPubkey = params.authorizedPubkey,
        votePubkey = params.votePubkey;
      var type = STAKE_INSTRUCTION_LAYOUTS.Delegate;
      var data = encodeData(type);
      return new Transaction().add({
        keys: [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: votePubkey,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: STAKE_CONFIG_ID,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data: data
      });
    }

    /**
     * Generate a Transaction that authorizes a new PublicKey as Staker
     * or Withdrawer on the Stake account.
     */
  }, {
    key: "authorize",
    value: function authorize(params) {
      var stakePubkey = params.stakePubkey,
        authorizedPubkey = params.authorizedPubkey,
        newAuthorizedPubkey = params.newAuthorizedPubkey,
        stakeAuthorizationType = params.stakeAuthorizationType,
        custodianPubkey = params.custodianPubkey;
      var type = STAKE_INSTRUCTION_LAYOUTS.Authorize;
      var data = encodeData(type, {
        newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
        stakeAuthorizationType: stakeAuthorizationType.index
      });
      var keys = [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }];
      if (custodianPubkey) {
        keys.push({
          pubkey: custodianPubkey,
          isSigner: false,
          isWritable: false
        });
      }
      return new Transaction().add({
        keys: keys,
        programId: this.programId,
        data: data
      });
    }

    /**
     * Generate a Transaction that authorizes a new PublicKey as Staker
     * or Withdrawer on the Stake account.
     */
  }, {
    key: "authorizeWithSeed",
    value: function authorizeWithSeed(params) {
      var stakePubkey = params.stakePubkey,
        authorityBase = params.authorityBase,
        authoritySeed = params.authoritySeed,
        authorityOwner = params.authorityOwner,
        newAuthorizedPubkey = params.newAuthorizedPubkey,
        stakeAuthorizationType = params.stakeAuthorizationType,
        custodianPubkey = params.custodianPubkey;
      var type = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
      var data = encodeData(type, {
        newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
        stakeAuthorizationType: stakeAuthorizationType.index,
        authoritySeed: authoritySeed,
        authorityOwner: toBuffer(authorityOwner.toBuffer())
      });
      var keys = [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: authorityBase,
        isSigner: true,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }];
      if (custodianPubkey) {
        keys.push({
          pubkey: custodianPubkey,
          isSigner: false,
          isWritable: false
        });
      }
      return new Transaction().add({
        keys: keys,
        programId: this.programId,
        data: data
      });
    }

    /**
     * @internal
     */
  }, {
    key: "splitInstruction",
    value: function splitInstruction(params) {
      var stakePubkey = params.stakePubkey,
        authorizedPubkey = params.authorizedPubkey,
        splitStakePubkey = params.splitStakePubkey,
        lamports = params.lamports;
      var type = STAKE_INSTRUCTION_LAYOUTS.Split;
      var data = encodeData(type, {
        lamports: lamports
      });
      return new TransactionInstruction({
        keys: [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: splitStakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data: data
      });
    }

    /**
     * Generate a Transaction that splits Stake tokens into another stake account
     */
  }, {
    key: "split",
    value: function split(params) {
      var transaction = new Transaction();
      transaction.add(SystemProgram.createAccount({
        fromPubkey: params.authorizedPubkey,
        newAccountPubkey: params.splitStakePubkey,
        lamports: 0,
        space: this.space,
        programId: this.programId
      }));
      return transaction.add(this.splitInstruction(params));
    }

    /**
     * Generate a Transaction that splits Stake tokens into another account
     * derived from a base public key and seed
     */
  }, {
    key: "splitWithSeed",
    value: function splitWithSeed(params) {
      var stakePubkey = params.stakePubkey,
        authorizedPubkey = params.authorizedPubkey,
        splitStakePubkey = params.splitStakePubkey,
        basePubkey = params.basePubkey,
        seed = params.seed,
        lamports = params.lamports;
      var transaction = new Transaction();
      transaction.add(SystemProgram.allocate({
        accountPubkey: splitStakePubkey,
        basePubkey: basePubkey,
        seed: seed,
        space: this.space,
        programId: this.programId
      }));
      return transaction.add(this.splitInstruction({
        stakePubkey: stakePubkey,
        authorizedPubkey: authorizedPubkey,
        splitStakePubkey: splitStakePubkey,
        lamports: lamports
      }));
    }

    /**
     * Generate a Transaction that merges Stake accounts.
     */
  }, {
    key: "merge",
    value: function merge(params) {
      var stakePubkey = params.stakePubkey,
        sourceStakePubKey = params.sourceStakePubKey,
        authorizedPubkey = params.authorizedPubkey;
      var type = STAKE_INSTRUCTION_LAYOUTS.Merge;
      var data = encodeData(type);
      return new Transaction().add({
        keys: [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: sourceStakePubKey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data: data
      });
    }

    /**
     * Generate a Transaction that withdraws deactivated Stake tokens.
     */
  }, {
    key: "withdraw",
    value: function withdraw(params) {
      var stakePubkey = params.stakePubkey,
        authorizedPubkey = params.authorizedPubkey,
        toPubkey = params.toPubkey,
        lamports = params.lamports,
        custodianPubkey = params.custodianPubkey;
      var type = STAKE_INSTRUCTION_LAYOUTS.Withdraw;
      var data = encodeData(type, {
        lamports: lamports
      });
      var keys = [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: toPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }];
      if (custodianPubkey) {
        keys.push({
          pubkey: custodianPubkey,
          isSigner: false,
          isWritable: false
        });
      }
      return new Transaction().add({
        keys: keys,
        programId: this.programId,
        data: data
      });
    }

    /**
     * Generate a Transaction that deactivates Stake tokens.
     */
  }, {
    key: "deactivate",
    value: function deactivate(params) {
      var stakePubkey = params.stakePubkey,
        authorizedPubkey = params.authorizedPubkey;
      var type = STAKE_INSTRUCTION_LAYOUTS.Deactivate;
      var data = encodeData(type);
      return new Transaction().add({
        keys: [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data: data
      });
    }
  }]);
  return StakeProgram;
}();
StakeProgram.programId = new PublicKey('Stake11111111111111111111111111111111111111');
/**
 * Max space of a Stake account
 *
 * This is generated from the solana-stake-program StakeState struct as
 * `StakeState::size_of()`:
 * https://docs.rs/solana-stake-program/latest/solana_stake_program/stake_state/enum.StakeState.html
 */
StakeProgram.space = 200;

/**
 * Vote account info
 */
var VoteInit = /*#__PURE__*/(0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)( /** [0, 100] */

function VoteInit(nodePubkey, authorizedVoter, authorizedWithdrawer, commission) {
  (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, VoteInit);
  this.nodePubkey = void 0;
  this.authorizedVoter = void 0;
  this.authorizedWithdrawer = void 0;
  this.commission = void 0;
  this.nodePubkey = nodePubkey;
  this.authorizedVoter = authorizedVoter;
  this.authorizedWithdrawer = authorizedWithdrawer;
  this.commission = commission;
});

/**
 * Create vote account transaction params
 */

/**
 * InitializeAccount instruction params
 */

/**
 * Authorize instruction params
 */

/**
 * AuthorizeWithSeed instruction params
 */

/**
 * Withdraw from vote account transaction params
 */

/**
 * Vote Instruction class
 */
var VoteInstruction = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function VoteInstruction() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, VoteInstruction);
  }

  /**
   * Decode a vote instruction and retrieve the instruction type.
   */
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(VoteInstruction, null, [{
    key: "decodeInstructionType",
    value: function decodeInstructionType(instruction) {
      this.checkProgramId(instruction.programId);
      var instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction');
      var typeIndex = instructionTypeLayout.decode(instruction.data);
      var type;
      for (var _i = 0, _Object$entries = Object.entries(VOTE_INSTRUCTION_LAYOUTS); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(_Object$entries[_i], 2),
          ixType = _Object$entries$_i[0],
          layout = _Object$entries$_i[1];
        if (layout.index == typeIndex) {
          type = ixType;
          break;
        }
      }
      if (!type) {
        throw new Error('Instruction type incorrect; not a VoteInstruction');
      }
      return type;
    }

    /**
     * Decode an initialize vote instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeInitializeAccount",
    value: function decodeInitializeAccount(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 4);
      var _decodeData = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, instruction.data),
        voteInit = _decodeData.voteInit;
      return {
        votePubkey: instruction.keys[0].pubkey,
        nodePubkey: instruction.keys[3].pubkey,
        voteInit: new VoteInit(new PublicKey(voteInit.nodePubkey), new PublicKey(voteInit.authorizedVoter), new PublicKey(voteInit.authorizedWithdrawer), voteInit.commission)
      };
    }

    /**
     * Decode an authorize instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeAuthorize",
    value: function decodeAuthorize(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      var _decodeData2 = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Authorize, instruction.data),
        newAuthorized = _decodeData2.newAuthorized,
        voteAuthorizationType = _decodeData2.voteAuthorizationType;
      return {
        votePubkey: instruction.keys[0].pubkey,
        authorizedPubkey: instruction.keys[2].pubkey,
        newAuthorizedPubkey: new PublicKey(newAuthorized),
        voteAuthorizationType: {
          index: voteAuthorizationType
        }
      };
    }

    /**
     * Decode an authorize instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeAuthorizeWithSeed",
    value: function decodeAuthorizeWithSeed(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      var _decodeData3 = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data),
        _decodeData3$voteAuth = _decodeData3.voteAuthorizeWithSeedArgs,
        currentAuthorityDerivedKeyOwnerPubkey = _decodeData3$voteAuth.currentAuthorityDerivedKeyOwnerPubkey,
        currentAuthorityDerivedKeySeed = _decodeData3$voteAuth.currentAuthorityDerivedKeySeed,
        newAuthorized = _decodeData3$voteAuth.newAuthorized,
        voteAuthorizationType = _decodeData3$voteAuth.voteAuthorizationType;
      return {
        currentAuthorityDerivedKeyBasePubkey: instruction.keys[2].pubkey,
        currentAuthorityDerivedKeyOwnerPubkey: new PublicKey(currentAuthorityDerivedKeyOwnerPubkey),
        currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,
        newAuthorizedPubkey: new PublicKey(newAuthorized),
        voteAuthorizationType: {
          index: voteAuthorizationType
        },
        votePubkey: instruction.keys[0].pubkey
      };
    }

    /**
     * Decode a withdraw instruction and retrieve the instruction params.
     */
  }, {
    key: "decodeWithdraw",
    value: function decodeWithdraw(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      var _decodeData4 = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data),
        lamports = _decodeData4.lamports;
      return {
        votePubkey: instruction.keys[0].pubkey,
        authorizedWithdrawerPubkey: instruction.keys[2].pubkey,
        lamports: lamports,
        toPubkey: instruction.keys[1].pubkey
      };
    }

    /**
     * @internal
     */
  }, {
    key: "checkProgramId",
    value: function checkProgramId(programId) {
      if (!programId.equals(VoteProgram.programId)) {
        throw new Error('invalid instruction; programId is not VoteProgram');
      }
    }

    /**
     * @internal
     */
  }, {
    key: "checkKeyLength",
    value: function checkKeyLength(keys, expectedLength) {
      if (keys.length < expectedLength) {
        throw new Error("invalid instruction; found ".concat(keys.length, " keys, expected at least ").concat(expectedLength));
      }
    }
  }]);
  return VoteInstruction;
}();

/**
 * An enumeration of valid VoteInstructionType's
 */

/** @internal */

var VOTE_INSTRUCTION_LAYOUTS = Object.freeze({
  InitializeAccount: {
    index: 0,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction'), voteInit()])
  },
  Authorize: {
    index: 1,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction'), publicKey('newAuthorized'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('voteAuthorizationType')])
  },
  Withdraw: {
    index: 3,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .ns64 */ .gM('lamports')])
  },
  AuthorizeWithSeed: {
    index: 10,
    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('instruction'), voteAuthorizeWithSeedArgs()])
  }
});

/**
 * VoteAuthorize type
 */

/**
 * An enumeration of valid VoteAuthorization layouts.
 */
var VoteAuthorizationLayout = Object.freeze({
  Voter: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});

/**
 * Factory class for transactions to interact with the Vote program
 */
var VoteProgram = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function VoteProgram() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, VoteProgram);
  }

  /**
   * Public key that identifies the Vote program
   */
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(VoteProgram, null, [{
    key: "initializeAccount",
    value:
    /**
     * Generate an Initialize instruction.
     */
    function initializeAccount(params) {
      var votePubkey = params.votePubkey,
        nodePubkey = params.nodePubkey,
        voteInit = params.voteInit;
      var type = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;
      var data = encodeData(type, {
        voteInit: {
          nodePubkey: toBuffer(voteInit.nodePubkey.toBuffer()),
          authorizedVoter: toBuffer(voteInit.authorizedVoter.toBuffer()),
          authorizedWithdrawer: toBuffer(voteInit.authorizedWithdrawer.toBuffer()),
          commission: voteInit.commission
        }
      });
      var instructionData = {
        keys: [{
          pubkey: votePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_RENT_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: nodePubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data: data
      };
      return new TransactionInstruction(instructionData);
    }

    /**
     * Generate a transaction that creates a new Vote account.
     */
  }, {
    key: "createAccount",
    value: function createAccount(params) {
      var transaction = new Transaction();
      transaction.add(SystemProgram.createAccount({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.votePubkey,
        lamports: params.lamports,
        space: this.space,
        programId: this.programId
      }));
      return transaction.add(this.initializeAccount({
        votePubkey: params.votePubkey,
        nodePubkey: params.voteInit.nodePubkey,
        voteInit: params.voteInit
      }));
    }

    /**
     * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.
     */
  }, {
    key: "authorize",
    value: function authorize(params) {
      var votePubkey = params.votePubkey,
        authorizedPubkey = params.authorizedPubkey,
        newAuthorizedPubkey = params.newAuthorizedPubkey,
        voteAuthorizationType = params.voteAuthorizationType;
      var type = VOTE_INSTRUCTION_LAYOUTS.Authorize;
      var data = encodeData(type, {
        newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
        voteAuthorizationType: voteAuthorizationType.index
      });
      var keys = [{
        pubkey: votePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }];
      return new Transaction().add({
        keys: keys,
        programId: this.programId,
        data: data
      });
    }

    /**
     * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account
     * where the current Voter or Withdrawer authority is a derived key.
     */
  }, {
    key: "authorizeWithSeed",
    value: function authorizeWithSeed(params) {
      var currentAuthorityDerivedKeyBasePubkey = params.currentAuthorityDerivedKeyBasePubkey,
        currentAuthorityDerivedKeyOwnerPubkey = params.currentAuthorityDerivedKeyOwnerPubkey,
        currentAuthorityDerivedKeySeed = params.currentAuthorityDerivedKeySeed,
        newAuthorizedPubkey = params.newAuthorizedPubkey,
        voteAuthorizationType = params.voteAuthorizationType,
        votePubkey = params.votePubkey;
      var type = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
      var data = encodeData(type, {
        voteAuthorizeWithSeedArgs: {
          currentAuthorityDerivedKeyOwnerPubkey: toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),
          currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,
          newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
          voteAuthorizationType: voteAuthorizationType.index
        }
      });
      var keys = [{
        pubkey: votePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: currentAuthorityDerivedKeyBasePubkey,
        isSigner: true,
        isWritable: false
      }];
      return new Transaction().add({
        keys: keys,
        programId: this.programId,
        data: data
      });
    }

    /**
     * Generate a transaction to withdraw from a Vote account.
     */
  }, {
    key: "withdraw",
    value: function withdraw(params) {
      var votePubkey = params.votePubkey,
        authorizedWithdrawerPubkey = params.authorizedWithdrawerPubkey,
        lamports = params.lamports,
        toPubkey = params.toPubkey;
      var type = VOTE_INSTRUCTION_LAYOUTS.Withdraw;
      var data = encodeData(type, {
        lamports: lamports
      });
      var keys = [{
        pubkey: votePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: toPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: authorizedWithdrawerPubkey,
        isSigner: true,
        isWritable: false
      }];
      return new Transaction().add({
        keys: keys,
        programId: this.programId,
        data: data
      });
    }

    /**
     * Generate a transaction to withdraw safely from a Vote account.
     *
     * This function was created as a safeguard for vote accounts running validators, `safeWithdraw`
     * checks that the withdraw amount will not exceed the specified balance while leaving enough left
     * to cover rent. If you wish to close the vote account by withdrawing the full amount, call the
     * `withdraw` method directly.
     */
  }, {
    key: "safeWithdraw",
    value: function safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {
      if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {
        throw new Error('Withdraw will leave vote account with insuffcient funds.');
      }
      return VoteProgram.withdraw(params);
    }
  }]);
  return VoteProgram;
}();
VoteProgram.programId = new PublicKey('Vote111111111111111111111111111111111111111');
/**
 * Max space of a Vote account
 *
 * This is generated from the solana-vote-program VoteState struct as
 * `VoteState::size_of()`:
 * https://docs.rs/solana-vote-program/1.9.5/solana_vote_program/vote_state/struct.VoteState.html#method.size_of
 *
 * KEEP IN SYNC WITH `VoteState::size_of()` in https://github.com/solana-labs/solana/blob/a474cb24b9238f5edcc982f65c0b37d4a1046f7e/sdk/program/src/vote/state/mod.rs#L340-L342
 */
VoteProgram.space = 3731;

var VALIDATOR_INFO_KEY = new PublicKey('Va1idator1nfo111111111111111111111111111111');

/**
 * @internal
 */

/**
 * Info used to identity validators.
 */

var InfoString = (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .type */ .dt)({
  name: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)(),
  website: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)()),
  details: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)()),
  keybaseUsername: (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .optional */ .jt)((0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .string */ .Z_)())
});

/**
 * ValidatorInfo class
 */
var ValidatorInfo = /*#__PURE__*/function () {
  /**
   * Construct a valid ValidatorInfo
   *
   * @param key validator public key
   * @param info validator information
   */
  function ValidatorInfo(key, info) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, ValidatorInfo);
    /**
     * validator public key
     */
    this.key = void 0;
    /**
     * validator information
     */
    this.info = void 0;
    this.key = key;
    this.info = info;
  }

  /**
   * Deserialize ValidatorInfo from the config account data. Exactly two config
   * keys are required in the data.
   *
   * @param buffer config account data
   * @return null if info was not found
   */
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(ValidatorInfo, null, [{
    key: "fromConfigData",
    value: function fromConfigData(buffer) {
      var byteArray = (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_19__/* ["default"] */ .Z)(buffer);
      var configKeyCount = decodeLength(byteArray);
      if (configKeyCount !== 2) return null;
      var configKeys = [];
      for (var i = 0; i < 2; i++) {
        var publicKey = new PublicKey(byteArray.slice(0, PUBLIC_KEY_LENGTH));
        byteArray = byteArray.slice(PUBLIC_KEY_LENGTH);
        var isSigner = byteArray.slice(0, 1)[0] === 1;
        byteArray = byteArray.slice(1);
        configKeys.push({
          publicKey: publicKey,
          isSigner: isSigner
        });
      }
      if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY)) {
        if (configKeys[1].isSigner) {
          var rawInfo = rustString().decode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(byteArray));
          var info = JSON.parse(rawInfo);
          (0,superstruct__WEBPACK_IMPORTED_MODULE_23__/* .assert */ .hu)(info, InfoString);
          return new ValidatorInfo(configKeys[1].publicKey, info);
        }
      }
      return null;
    }
  }]);
  return ValidatorInfo;
}();

var VOTE_PROGRAM_ID = new PublicKey('Vote111111111111111111111111111111111111111');

/**
 * History of how many credits earned by the end of each epoch
 */

/**
 * See https://github.com/solana-labs/solana/blob/8a12ed029cfa38d4a45400916c2463fb82bbec8c/programs/vote_api/src/vote_state.rs#L68-L88
 *
 * @internal
 */
var VoteAccountLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([publicKey('nodePubkey'), publicKey('authorizedWithdrawer'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__.u8('commission'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .nu64 */ ._O(),
// votes.length
_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .seq */ .A9(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .nu64 */ ._O('slot'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq('confirmationCount')]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .offset */ .cv(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq(), -8), 'votes'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__.u8('rootSlotValid'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .nu64 */ ._O('rootSlot'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .nu64 */ ._O(),
// authorizedVoters.length
_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .seq */ .A9(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .nu64 */ ._O('epoch'), publicKey('authorizedVoter')]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .offset */ .cv(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq(), -8), 'authorizedVoters'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .seq */ .A9(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([publicKey('authorizedPubkey'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .nu64 */ ._O('epochOfLastAuthorizedSwitch'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .nu64 */ ._O('targetEpoch')]), 32, 'buf'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .nu64 */ ._O('idx'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__.u8('isEmpty')], 'priorVoters'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .nu64 */ ._O(),
// epochCredits.length
_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .seq */ .A9(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .nu64 */ ._O('epoch'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .nu64 */ ._O('credits'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .nu64 */ ._O('prevCredits')]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .offset */ .cv(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .u32 */ .Jq(), -8), 'epochCredits'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .struct */ .n_([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .nu64 */ ._O('slot'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_5__/* .nu64 */ ._O('timestamp')], 'lastTimestamp')]);
/**
 * VoteAccount class
 */
var VoteAccount = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function VoteAccount(args) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(this, VoteAccount);
    this.nodePubkey = void 0;
    this.authorizedWithdrawer = void 0;
    this.commission = void 0;
    this.rootSlot = void 0;
    this.votes = void 0;
    this.authorizedVoters = void 0;
    this.priorVoters = void 0;
    this.epochCredits = void 0;
    this.lastTimestamp = void 0;
    this.nodePubkey = args.nodePubkey;
    this.authorizedWithdrawer = args.authorizedWithdrawer;
    this.commission = args.commission;
    this.rootSlot = args.rootSlot;
    this.votes = args.votes;
    this.authorizedVoters = args.authorizedVoters;
    this.priorVoters = args.priorVoters;
    this.epochCredits = args.epochCredits;
    this.lastTimestamp = args.lastTimestamp;
  }

  /**
   * Deserialize VoteAccount from the account data.
   *
   * @param buffer account data
   * @return VoteAccount
   */
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(VoteAccount, null, [{
    key: "fromAccountData",
    value: function fromAccountData(buffer) {
      var versionOffset = 4;
      var va = VoteAccountLayout.decode(toBuffer(buffer), versionOffset);
      var rootSlot = va.rootSlot;
      if (!va.rootSlotValid) {
        rootSlot = null;
      }
      return new VoteAccount({
        nodePubkey: new PublicKey(va.nodePubkey),
        authorizedWithdrawer: new PublicKey(va.authorizedWithdrawer),
        commission: va.commission,
        votes: va.votes,
        rootSlot: rootSlot,
        authorizedVoters: va.authorizedVoters.map(parseAuthorizedVoter),
        priorVoters: getPriorVoters(va.priorVoters),
        epochCredits: va.epochCredits,
        lastTimestamp: va.lastTimestamp
      });
    }
  }]);
  return VoteAccount;
}();
function parseAuthorizedVoter(_ref) {
  var authorizedVoter = _ref.authorizedVoter,
    epoch = _ref.epoch;
  return {
    epoch: epoch,
    authorizedVoter: new PublicKey(authorizedVoter)
  };
}
function parsePriorVoters(_ref2) {
  var authorizedPubkey = _ref2.authorizedPubkey,
    epochOfLastAuthorizedSwitch = _ref2.epochOfLastAuthorizedSwitch,
    targetEpoch = _ref2.targetEpoch;
  return {
    authorizedPubkey: new PublicKey(authorizedPubkey),
    epochOfLastAuthorizedSwitch: epochOfLastAuthorizedSwitch,
    targetEpoch: targetEpoch
  };
}
function getPriorVoters(_ref3) {
  var buf = _ref3.buf,
    idx = _ref3.idx,
    isEmpty = _ref3.isEmpty;
  if (isEmpty) {
    return [];
  }
  return [].concat((0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_19__/* ["default"] */ .Z)(buf.slice(idx + 1).map(parsePriorVoters)), (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_19__/* ["default"] */ .Z)(buf.slice(0, idx).map(parsePriorVoters)));
}

var endpoint = {
  http: {
    devnet: 'http://api.devnet.solana.com',
    testnet: 'http://api.testnet.solana.com',
    'mainnet-beta': 'http://api.mainnet-beta.solana.com/'
  },
  https: {
    devnet: 'https://api.devnet.solana.com',
    testnet: 'https://api.testnet.solana.com',
    'mainnet-beta': 'https://api.mainnet-beta.solana.com/'
  }
};
/**
 * Retrieves the RPC API URL for the specified cluster
 * @param {Cluster} [cluster="devnet"] - The cluster name of the RPC API URL to use. Possible options: 'devnet' | 'testnet' | 'mainnet-beta'
 * @param {boolean} [tls="http"] - Use TLS when connecting to cluster.
 *
 * @returns {string} URL string of the RPC endpoint
 */
function clusterApiUrl(cluster, tls) {
  var key = tls === false ? 'http' : 'https';
  if (!cluster) {
    return endpoint[key]['devnet'];
  }
  var url = endpoint[key][cluster];
  if (!url) {
    throw new Error("Unknown ".concat(key, " cluster: ").concat(cluster));
  }
  return url;
}

/**
 * Send and confirm a raw transaction
 *
 * If `commitment` option is not specified, defaults to 'max' commitment.
 *
 * @param {Connection} connection
 * @param {Buffer} rawTransaction
 * @param {TransactionConfirmationStrategy} confirmationStrategy
 * @param {ConfirmOptions} [options]
 * @returns {Promise<TransactionSignature>}
 */

/**
 * @deprecated Calling `sendAndConfirmRawTransaction()` without a `confirmationStrategy`
 * is no longer supported and will be removed in a future version.
 */ // eslint-disable-next-line no-redeclare
// eslint-disable-next-line no-redeclare
function sendAndConfirmRawTransaction(_x, _x2, _x3, _x4) {
  return _sendAndConfirmRawTransaction.apply(this, arguments);
}
function _sendAndConfirmRawTransaction() {
  _sendAndConfirmRawTransaction = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee(connection, rawTransaction, confirmationStrategyOrConfirmOptions, maybeConfirmOptions) {
    var confirmationStrategy, options, sendOptions, signature, commitment, confirmationPromise, status;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, 'lastValidBlockHeight')) {
            confirmationStrategy = confirmationStrategyOrConfirmOptions;
            options = maybeConfirmOptions;
          } else if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, 'nonceValue')) {
            confirmationStrategy = confirmationStrategyOrConfirmOptions;
            options = maybeConfirmOptions;
          } else {
            options = confirmationStrategyOrConfirmOptions;
          }
          sendOptions = options && {
            skipPreflight: options.skipPreflight,
            preflightCommitment: options.preflightCommitment || options.commitment,
            minContextSlot: options.minContextSlot
          };
          _context.next = 4;
          return connection.sendRawTransaction(rawTransaction, sendOptions);
        case 4:
          signature = _context.sent;
          commitment = options && options.commitment;
          confirmationPromise = confirmationStrategy ? connection.confirmTransaction(confirmationStrategy, commitment) : connection.confirmTransaction(signature, commitment);
          _context.next = 9;
          return confirmationPromise;
        case 9:
          status = _context.sent.value;
          if (!status.err) {
            _context.next = 12;
            break;
          }
          throw new Error("Raw transaction ".concat(signature, " failed (").concat(JSON.stringify(status), ")"));
        case 12:
          return _context.abrupt("return", signature);
        case 13:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _sendAndConfirmRawTransaction.apply(this, arguments);
}

/**
 * There are 1-billion lamports in one SOL
 */
var LAMPORTS_PER_SOL = 1000000000;




/***/ })

}]);
//# sourceMappingURL=npm-ns.solana.web3.js.js.map