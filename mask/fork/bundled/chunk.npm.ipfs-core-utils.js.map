{"version":3,"file":"bundled/chunk.npm.ipfs-core-utils.js","mappings":"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a;AACb;AACA;AACA;AACA;;AAEA;AACA,WAAW,KAAK;AAChB,aAAa;AACb;AACA;AACA,SAAS,2DAAG;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,KAAK;AACL;AACA;AACA,cAAc,8BAA8B;AAC5C,cAAc,kCAAkC;AAChD;AACA;AACA,mBAAmB,8BAA8B;AACjD,mBAAmB,kCAAkC;AACrD;AACA;AACA;AACA;AACA,mBAAmB,+CAA+C;AAClE;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACO;AACP;AACA;AACA,UAAU,qCAAO,gCAAgC,MAAM;AACvD;;AAEA;AACA,cAAc,2DAAG;;AAEjB;AACA,kBAAkB,KAAK;AACvB;AACA;;AAEA;AACA,kBAAkB,aAAa;AAC/B;AACA;;AAEA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA,sBAAsB,KAAK;AAC3B;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA,sBAAsB,MAAM;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU,qCAAO;AACjB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA,sBAAsB,KAAK;AAC3B;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA,sBAAsB,MAAM;AAC5B;AACA;AACA;;AAEA,uBAAuB,qCAAqC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU,qCAAO;AACjB;;AAEA,QAAQ,qCAAO;AACf;;AAEA;AACA,WAAW,UAAU;AACrB;AACA;AACA,+BAA+B,WAAW;;AAE1C;AACA,UAAU,qCAAO;AACjB;;AAEA,aAAa,KAAK;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACnMmD;AACY;;AAE/D;AACA,aAAa,6CAA6C;AAC1D;;AAEA;AACA,WAAW,sBAAsB;AACjC,aAAa;AACb;AACO;AACP;AACA;AACA,UAAU,uFAAc,CAAC,4EAAS;AAClC,IAAI,kBAAkB,KAAK;;AAE3B;;AAEA;AACA","sources":["webpack://mask-network/./node_modules/.pnpm/ipfs-core-utils@0.18.1_undici@5.23.0/node_modules/ipfs-core-utils/src/agent.browser.js","webpack://mask-network/./node_modules/.pnpm/ipfs-core-utils@0.18.1_undici@5.23.0/node_modules/ipfs-core-utils/src/files/normalise-content.js","webpack://mask-network/./node_modules/.pnpm/ipfs-core-utils@0.18.1_undici@5.23.0/node_modules/ipfs-core-utils/src/files/normalise-candidate-single.js","webpack://mask-network/./node_modules/.pnpm/ipfs-core-utils@0.18.1_undici@5.23.0/node_modules/ipfs-core-utils/src/files/normalise-input-single.js","webpack://mask-network/./node_modules/.pnpm/ipfs-core-utils@0.18.1_undici@5.23.0/node_modules/ipfs-core-utils/src/files/utils.js","webpack://mask-network/./node_modules/.pnpm/ipfs-core-utils@0.18.1_undici@5.23.0/node_modules/ipfs-core-utils/src/multibases.js","webpack://mask-network/./node_modules/.pnpm/ipfs-core-utils@0.18.1_undici@5.23.0/node_modules/ipfs-core-utils/src/multicodecs.js","webpack://mask-network/./node_modules/.pnpm/ipfs-core-utils@0.18.1_undici@5.23.0/node_modules/ipfs-core-utils/src/multihashes.js","webpack://mask-network/./node_modules/.pnpm/ipfs-core-utils@0.18.1_undici@5.23.0/node_modules/ipfs-core-utils/src/files/normalise-content.browser.js","webpack://mask-network/./node_modules/.pnpm/ipfs-core-utils@0.18.1_undici@5.23.0/node_modules/ipfs-core-utils/src/files/normalise-candidate-multiple.js","webpack://mask-network/./node_modules/.pnpm/ipfs-core-utils@0.18.1_undici@5.23.0/node_modules/ipfs-core-utils/src/files/normalise-input-multiple.browser.js","webpack://mask-network/./node_modules/.pnpm/ipfs-core-utils@0.18.1_undici@5.23.0/node_modules/ipfs-core-utils/src/mode-to-string.js","webpack://mask-network/./node_modules/.pnpm/ipfs-core-utils@0.18.1_undici@5.23.0/node_modules/ipfs-core-utils/src/multipart-request.browser.js","webpack://mask-network/./node_modules/.pnpm/ipfs-core-utils@0.18.1_undici@5.23.0/node_modules/ipfs-core-utils/src/pins/normalise-input.js","webpack://mask-network/./node_modules/.pnpm/ipfs-core-utils@0.18.1_undici@5.23.0/node_modules/ipfs-core-utils/src/to-url-string.js"],"sourcesContent":["\nexport default () => {}\n","import errCode from 'err-code'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport browserStreamToIt from 'browser-readablestream-to-it'\nimport blobToIt from 'blob-to-it'\nimport itPeekable from 'it-peekable'\nimport all from 'it-all'\nimport map from 'it-map'\nimport {\n  isBytes,\n  isReadableStream,\n  isBlob\n} from './utils.js'\n\n/**\n * @template T\n * @param {T} thing\n */\nasync function * toAsyncIterable (thing) {\n  yield thing\n}\n\n/**\n * @param {import('ipfs-core-types/src/utils').ToContent} input\n */\nexport async function normaliseContent (input) {\n  // Bytes | String\n  if (isBytes(input)) {\n    return toAsyncIterable(toBytes(input))\n  }\n\n  if (typeof input === 'string' || input instanceof String) {\n    return toAsyncIterable(toBytes(input.toString()))\n  }\n\n  // Blob\n  if (isBlob(input)) {\n    return blobToIt(input)\n  }\n\n  // Browser stream\n  if (isReadableStream(input)) {\n    input = browserStreamToIt(input)\n  }\n\n  // (Async)Iterator<?>\n  if (Symbol.iterator in input || Symbol.asyncIterator in input) {\n    /** @type {any} peekable */\n    const peekable = itPeekable(input)\n\n    /** @type {any} value */\n    const { value, done } = await peekable.peek()\n\n    if (done) {\n      // make sure empty iterators result in empty files\n      return toAsyncIterable(new Uint8Array(0))\n    }\n\n    peekable.push(value)\n\n    // (Async)Iterable<Number>\n    if (Number.isInteger(value)) {\n      return toAsyncIterable(Uint8Array.from(await all(peekable)))\n    }\n\n    // (Async)Iterable<Bytes|String>\n    if (isBytes(value) || typeof value === 'string' || value instanceof String) {\n      return map(peekable, toBytes)\n    }\n  }\n\n  throw errCode(new Error(`Unexpected input: ${input}`), 'ERR_UNEXPECTED_INPUT')\n}\n\n/**\n * @param {ArrayBuffer | ArrayBufferView | string | InstanceType<typeof window.String> | number[]} chunk\n */\nfunction toBytes (chunk) {\n  if (chunk instanceof Uint8Array) {\n    return chunk\n  }\n\n  if (ArrayBuffer.isView(chunk)) {\n    return new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength)\n  }\n\n  if (chunk instanceof ArrayBuffer) {\n    return new Uint8Array(chunk)\n  }\n\n  if (Array.isArray(chunk)) {\n    return Uint8Array.from(chunk)\n  }\n\n  return uint8ArrayFromString(chunk.toString())\n}\n","import errCode from 'err-code'\nimport browserStreamToIt from 'browser-readablestream-to-it'\nimport itPeekable from 'it-peekable'\nimport {\n  isBytes,\n  isBlob,\n  isReadableStream,\n  isFileObject\n} from './utils.js'\nimport {\n  parseMtime,\n  parseMode\n} from 'ipfs-unixfs'\n\n/**\n * @typedef {import('ipfs-core-types/src/utils').ToContent} ToContent\n * @typedef {import('ipfs-unixfs-importer').ImportCandidate} ImporterImportCandidate\n * @typedef {import('ipfs-core-types/src/utils').ImportCandidate} ImportCandidate\n * @typedef {import('ipfs-core-types/src/utils').ImportCandidateStream} ImportCandidateStream\n */\n\n/**\n * @param {ImportCandidate} input\n * @param {(content:ToContent) => Promise<AsyncIterable<Uint8Array>>} normaliseContent\n */\n// eslint-disable-next-line complexity\nexport async function * normaliseCandidateSingle (input, normaliseContent) {\n  if (input === null || input === undefined) {\n    throw errCode(new Error(`Unexpected input: ${input}`), 'ERR_UNEXPECTED_INPUT')\n  }\n\n  // String\n  if (typeof input === 'string' || input instanceof String) {\n    yield toFileObject(input.toString(), normaliseContent)\n    return\n  }\n\n  // Uint8Array|ArrayBuffer|TypedArray\n  // Blob|File\n  if (isBytes(input) || isBlob(input)) {\n    yield toFileObject(input, normaliseContent)\n    return\n  }\n\n  // Browser ReadableStream\n  if (isReadableStream(input)) {\n    input = browserStreamToIt(input)\n  }\n\n  // Iterable<?>\n  if (Symbol.iterator in input || Symbol.asyncIterator in input) {\n    const peekable = itPeekable(input)\n\n    /** @type {any} value **/\n    const { value, done } = await peekable.peek()\n\n    if (done) {\n      // make sure empty iterators result in empty files\n      yield { content: [] }\n      return\n    }\n\n    peekable.push(value)\n\n    // (Async)Iterable<Number>\n    // (Async)Iterable<Bytes>\n    // (Async)Iterable<String>\n    if (Number.isInteger(value) || isBytes(value) || typeof value === 'string' || value instanceof String) {\n      yield toFileObject(peekable, normaliseContent)\n      return\n    }\n\n    throw errCode(new Error('Unexpected input: multiple items passed - if you are using ipfs.add, please use ipfs.addAll instead'), 'ERR_UNEXPECTED_INPUT')\n  }\n\n  // { path, content: ? }\n  // Note: Detected _after_ (Async)Iterable<?> because Node.js fs.ReadStreams have a\n  // `path` property that passes this check.\n  if (isFileObject(input)) {\n    yield toFileObject(input, normaliseContent)\n    return\n  }\n\n  throw errCode(new Error('Unexpected input: cannot convert \"' + typeof input + '\" into ImportCandidate'), 'ERR_UNEXPECTED_INPUT')\n}\n\n/**\n * @param {ImportCandidate} input\n * @param {(content:ToContent) => Promise<AsyncIterable<Uint8Array>>} normaliseContent\n */\nasync function toFileObject (input, normaliseContent) {\n  // @ts-expect-error - Those properties don't exist on most input types\n  const { path, mode, mtime, content } = input\n\n  /** @type {ImporterImportCandidate} */\n  const file = {\n    path: path || '',\n    mode: parseMode(mode),\n    mtime: parseMtime(mtime)\n  }\n\n  if (content) {\n    file.content = await normaliseContent(content)\n  } else if (!path) { // Not already a file object with path or content prop\n    // @ts-expect-error - input still can be different ToContent\n    file.content = await normaliseContent(input)\n  }\n\n  return file\n}\n","import { normaliseContent } from './normalise-content.js'\nimport { normaliseCandidateSingle } from './normalise-candidate-single.js'\n\n/**\n * @typedef {import('ipfs-core-types/src/utils').ImportCandidate} ImportCandidate\n */\n\n/**\n * Transforms any of the `ipfs.add` input types into\n *\n * ```\n * AsyncIterable<{ path, mode, mtime, content: AsyncIterable<Uint8Array> }>\n * ```\n *\n * See https://github.com/ipfs/js-ipfs/blob/master/docs/core-api/FILES.md#ipfsadddata-options\n *\n * @param {ImportCandidate} input\n */\nexport function normaliseInput (input) {\n  return normaliseCandidateSingle(input, normaliseContent)\n}\n","/**\n * @param {any} obj\n * @returns {obj is ArrayBufferView|ArrayBuffer}\n */\nexport function isBytes (obj) {\n  return ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer\n}\n\n/**\n * @param {any} obj\n * @returns {obj is globalThis.Blob}\n */\nexport function isBlob (obj) {\n  return obj.constructor &&\n    (obj.constructor.name === 'Blob' || obj.constructor.name === 'File') &&\n    typeof obj.stream === 'function'\n}\n\n/**\n * An object with a path or content property\n *\n * @param {any} obj\n * @returns {obj is import('ipfs-core-types/src/utils').ImportCandidate}\n */\nexport function isFileObject (obj) {\n  return typeof obj === 'object' && (obj.path || obj.content)\n}\n\n/**\n * @param {any} value\n * @returns {value is ReadableStream}\n */\nexport const isReadableStream = (value) =>\n  value && typeof value.getReader === 'function'\n","/**\n * @typedef {import('multiformats/bases/interface').MultibaseCodec<any>} MultibaseCodec\n * @typedef {import('./types').LoadBaseFn} LoadBaseFn\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @type {LoadBaseFn}\n */\nconst LOAD_BASE = (name) => Promise.reject(new Error(`No base found for \"${name}\"`))\n\nexport class Multibases {\n  /**\n   * @param {object} options\n   * @param {LoadBaseFn} [options.loadBase]\n   * @param {MultibaseCodec[]} options.bases\n   */\n  constructor (options) {\n    // Object with current list of active resolvers\n    /** @type {Record<string, MultibaseCodec>}} */\n    this._basesByName = {}\n\n    // Object with current list of active resolvers\n    /** @type {Record<string, MultibaseCodec>}} */\n    this._basesByPrefix = {}\n\n    this._loadBase = options.loadBase || LOAD_BASE\n\n    // Enable all supplied codecs\n    for (const base of options.bases) {\n      this.addBase(base)\n    }\n  }\n\n  /**\n   * Add support for a multibase codec\n   *\n   * @param {MultibaseCodec} base\n   */\n  addBase (base) {\n    if (this._basesByName[base.name] || this._basesByPrefix[base.prefix]) {\n      throw new Error(`Codec already exists for codec \"${base.name}\"`)\n    }\n\n    this._basesByName[base.name] = base\n    this._basesByPrefix[base.prefix] = base\n  }\n\n  /**\n   * Remove support for a multibase codec\n   *\n   * @param {MultibaseCodec} base\n   */\n  removeBase (base) {\n    delete this._basesByName[base.name]\n    delete this._basesByPrefix[base.prefix]\n  }\n\n  /**\n   * @param {string} nameOrPrefix\n   */\n  async getBase (nameOrPrefix) {\n    if (this._basesByName[nameOrPrefix]) {\n      return this._basesByName[nameOrPrefix]\n    }\n\n    if (this._basesByPrefix[nameOrPrefix]) {\n      return this._basesByPrefix[nameOrPrefix]\n    }\n\n    // If not supported, attempt to dynamically load this codec\n    const base = await this._loadBase(nameOrPrefix)\n\n    if (this._basesByName[base.name] == null && this._basesByPrefix[base.prefix] == null) {\n      this.addBase(base)\n    }\n\n    return base\n  }\n\n  listBases () {\n    return Object.values(this._basesByName)\n  }\n}\n","/**\n * @typedef {import('multiformats/codecs/interface').BlockCodec<any, any>} BlockCodec\n * @typedef {import('./types').LoadCodecFn} LoadCodecFn\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @type {LoadCodecFn}\n */\nconst LOAD_CODEC = (codeOrName) => Promise.reject(new Error(`No codec found for \"${codeOrName}\"`))\n\nexport class Multicodecs {\n  /**\n   * @param {object} options\n   * @param {LoadCodecFn} [options.loadCodec]\n   * @param {BlockCodec[]} options.codecs\n   */\n  constructor (options) {\n    // Object with current list of active resolvers\n    /** @type {Record<string, BlockCodec>}} */\n    this._codecsByName = {}\n\n    // Object with current list of active resolvers\n    /** @type {Record<number, BlockCodec>}} */\n    this._codecsByCode = {}\n\n    this._loadCodec = options.loadCodec || LOAD_CODEC\n\n    // Enable all supplied codecs\n    for (const codec of options.codecs) {\n      this.addCodec(codec)\n    }\n  }\n\n  /**\n   * Add support for a block codec\n   *\n   * @param {BlockCodec} codec\n   */\n  addCodec (codec) {\n    if (this._codecsByName[codec.name] || this._codecsByCode[codec.code]) {\n      throw new Error(`Resolver already exists for codec \"${codec.name}\"`)\n    }\n\n    this._codecsByName[codec.name] = codec\n    this._codecsByCode[codec.code] = codec\n  }\n\n  /**\n   * Remove support for a block codec\n   *\n   * @param {BlockCodec} codec\n   */\n  removeCodec (codec) {\n    delete this._codecsByName[codec.name]\n    delete this._codecsByCode[codec.code]\n  }\n\n  /**\n   * @param {number | string} code\n   */\n  async getCodec (code) {\n    const table = typeof code === 'string' ? this._codecsByName : this._codecsByCode\n\n    if (table[code]) {\n      return table[code]\n    }\n\n    // If not supported, attempt to dynamically load this codec\n    const codec = await this._loadCodec(code)\n\n    if (table[code] == null) {\n      this.addCodec(codec)\n    }\n\n    return codec\n  }\n\n  listCodecs () {\n    return Object.values(this._codecsByName)\n  }\n}\n","/**\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n * @typedef {import('./types').LoadHasherFn} LoadHasherFn\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @type {LoadHasherFn}\n */\nconst LOAD_HASHER = (codeOrName) => Promise.reject(new Error(`No hasher found for \"${codeOrName}\"`))\n\nexport class Multihashes {\n  /**\n   * @param {object} options\n   * @param {LoadHasherFn} [options.loadHasher]\n   * @param {MultihashHasher[]} options.hashers\n   */\n  constructor (options) {\n    // Object with current list of active hashers\n    /** @type {Record<string, MultihashHasher>}} */\n    this._hashersByName = {}\n\n    // Object with current list of active hashers\n    /** @type {Record<number, MultihashHasher>}} */\n    this._hashersByCode = {}\n\n    this._loadHasher = options.loadHasher || LOAD_HASHER\n\n    // Enable all supplied hashers\n    for (const hasher of options.hashers) {\n      this.addHasher(hasher)\n    }\n  }\n\n  /**\n   * Add support for a multibase hasher\n   *\n   * @param {MultihashHasher} hasher\n   */\n  addHasher (hasher) {\n    if (this._hashersByName[hasher.name] || this._hashersByCode[hasher.code]) {\n      throw new Error(`Resolver already exists for codec \"${hasher.name}\"`)\n    }\n\n    this._hashersByName[hasher.name] = hasher\n    this._hashersByCode[hasher.code] = hasher\n  }\n\n  /**\n   * Remove support for a multibase hasher\n   *\n   * @param {MultihashHasher} hasher\n   */\n  removeHasher (hasher) {\n    delete this._hashersByName[hasher.name]\n    delete this._hashersByCode[hasher.code]\n  }\n\n  /**\n   * @param {number | string} code\n   */\n  async getHasher (code) {\n    const table = typeof code === 'string' ? this._hashersByName : this._hashersByCode\n\n    if (table[code]) {\n      return table[code]\n    }\n\n    // If not supported, attempt to dynamically load this hasher\n    const hasher = await this._loadHasher(code)\n\n    if (table[code] == null) {\n      this.addHasher(hasher)\n    }\n\n    return hasher\n  }\n\n  listHashers () {\n    return Object.values(this._hashersByName)\n  }\n}\n","import errCode from 'err-code'\nimport itPeekable from 'it-peekable'\nimport browserStreamToIt from 'browser-readablestream-to-it'\nimport all from 'it-all'\nimport {\n  isBytes,\n  isBlob,\n  isReadableStream\n} from './utils.js'\n\n/**\n * @param {import('ipfs-core-types/src/utils').ToContent} input\n */\nexport async function normaliseContent (input) {\n  // Bytes\n  if (isBytes(input)) {\n    return new Blob([input])\n  }\n\n  // String\n  if (typeof input === 'string' || input instanceof String) {\n    return new Blob([input.toString()])\n  }\n\n  // Blob | File\n  if (isBlob(input)) {\n    return input\n  }\n\n  // Browser stream\n  if (isReadableStream(input)) {\n    input = browserStreamToIt(input)\n  }\n\n  // (Async)Iterator<?>\n  if (Symbol.iterator in input || Symbol.asyncIterator in input) {\n    /** @type {any} peekable */\n    const peekable = itPeekable(input)\n\n    /** @type {any} value **/\n    const { value, done } = await peekable.peek()\n\n    if (done) {\n      // make sure empty iterators result in empty files\n      return itToBlob(peekable)\n    }\n\n    peekable.push(value)\n\n    // (Async)Iterable<Number>\n    if (Number.isInteger(value)) {\n      return new Blob([Uint8Array.from(await all(peekable))])\n    }\n\n    // (Async)Iterable<Bytes|String>\n    if (isBytes(value) || typeof value === 'string' || value instanceof String) {\n      return itToBlob(peekable)\n    }\n  }\n\n  throw errCode(new Error(`Unexpected input: ${input}`), 'ERR_UNEXPECTED_INPUT')\n}\n\n/**\n * @param {AsyncIterable<BlobPart>|Iterable<BlobPart>} stream\n */\nasync function itToBlob (stream) {\n  const parts = []\n\n  for await (const chunk of stream) {\n    parts.push(chunk)\n  }\n\n  return new Blob(parts)\n}\n","import errCode from 'err-code'\nimport browserStreamToIt from 'browser-readablestream-to-it'\nimport itPeekable from 'it-peekable'\nimport map from 'it-map'\nimport {\n  isBytes,\n  isBlob,\n  isReadableStream,\n  isFileObject\n} from './utils.js'\nimport {\n  parseMtime,\n  parseMode\n} from 'ipfs-unixfs'\n\n/**\n * @typedef {import('ipfs-core-types/src/utils').ImportCandidate} ImportCandidate\n * @typedef {import('ipfs-core-types/src/utils').ToContent} ToContent\n * @typedef {import('ipfs-unixfs-importer').ImportCandidate} ImporterImportCandidate\n * @typedef {import('ipfs-core-types/src/utils').ImportCandidateStream} ImportCandidateStream\n */\n\n/**\n * @param {ImportCandidateStream} input\n * @param {(content:ToContent) => Promise<AsyncIterable<Uint8Array>>} normaliseContent\n */\n// eslint-disable-next-line complexity\nexport async function * normaliseCandidateMultiple (input, normaliseContent) {\n  // String\n  // Uint8Array|ArrayBuffer|TypedArray\n  // Blob|File\n  // fs.ReadStream\n  // @ts-expect-error _readableState is a property of a node fs.ReadStream\n  if (typeof input === 'string' || input instanceof String || isBytes(input) || isBlob(input) || input._readableState) {\n    throw errCode(new Error('Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead'), 'ERR_UNEXPECTED_INPUT')\n  }\n\n  // Browser ReadableStream\n  if (isReadableStream(input)) {\n    input = browserStreamToIt(input)\n  }\n\n  // Iterable<?>\n  if (Symbol.iterator in input || Symbol.asyncIterator in input) {\n    const peekable = itPeekable(input)\n    const { value, done } = await peekable.peek()\n\n    if (done) {\n      // make sure empty iterators result in empty files\n      yield * []\n      return\n    }\n\n    peekable.push(value)\n\n    // (Async)Iterable<Number>\n    // (Async)Iterable<Bytes>\n    if (Number.isInteger(value)) {\n      throw errCode(new Error('Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead'), 'ERR_UNEXPECTED_INPUT')\n    }\n\n    // (Async)Iterable<fs.ReadStream>\n    // @ts-expect-error private field\n    if (value._readableState) {\n      // @ts-expect-error Node fs.ReadStreams have a `.path` property so we need to pass it as the content\n      yield * map(peekable, (/** @type {ImportCandidate} */ value) => toFileObject({ content: value }, normaliseContent))\n      return\n    }\n\n    if (isBytes(value)) {\n      // @ts-expect-error peekable is still an iterable of ImportCandidates\n      yield toFileObject({ content: peekable }, normaliseContent)\n      return\n    }\n\n    // (Async)Iterable<(Async)Iterable<?>>\n    // (Async)Iterable<ReadableStream<?>>\n    // ReadableStream<(Async)Iterable<?>>\n    // ReadableStream<ReadableStream<?>>\n    if (isFileObject(value) || value[Symbol.iterator] || value[Symbol.asyncIterator] || isReadableStream(value) || isBlob(value)) {\n      yield * map(peekable, (/** @type {ImportCandidate} */ value) => toFileObject(value, normaliseContent))\n      return\n    }\n  }\n\n  // { path, content: ? }\n  // Note: Detected _after_ (Async)Iterable<?> because Node.js fs.ReadStreams have a\n  // `path` property that passes this check.\n  if (isFileObject(input)) {\n    throw errCode(new Error('Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead'), 'ERR_UNEXPECTED_INPUT')\n  }\n\n  throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT')\n}\n\n/**\n * @param {ImportCandidate} input\n * @param {(content:ToContent) => Promise<AsyncIterable<Uint8Array>>} normaliseContent\n */\nasync function toFileObject (input, normaliseContent) {\n  // @ts-expect-error - Those properties don't exist on most input types\n  const { path, mode, mtime, content } = input\n\n  /** @type {ImporterImportCandidate} */\n  const file = {\n    path: path || '',\n    mode: parseMode(mode),\n    mtime: parseMtime(mtime)\n  }\n\n  if (content) {\n    file.content = await normaliseContent(content)\n  } else if (!path) { // Not already a file object with path or content prop\n    // @ts-expect-error - input still can be different ToContent\n    file.content = await normaliseContent(input)\n  }\n\n  return file\n}\n","import { normaliseContent } from './normalise-content.browser.js'\nimport { normaliseCandidateMultiple } from './normalise-candidate-multiple.js'\n\n/**\n * @typedef {import('ipfs-core-types/src/utils').ImportCandidateStream} ImportCandidateStream\n * @typedef {import('ipfs-core-types/src/utils').BrowserImportCandidate} BrowserImportCandidate\n */\n\n/**\n * Transforms any of the `ipfs.addAll` input types into\n *\n * ```\n * AsyncIterable<{ path, mode, mtime, content: Blob }>\n * ```\n *\n * See https://github.com/ipfs/js-ipfs/blob/master/docs/core-api/FILES.md#ipfsadddata-options\n *\n * @param {ImportCandidateStream} input\n * @returns {AsyncGenerator<BrowserImportCandidate, void, undefined>}\n */\nexport function normaliseInput (input) {\n  // @ts-expect-error browser normaliseContent returns a Blob not an AsyncIterable<Uint8Array>\n  return normaliseCandidateMultiple(input, normaliseContent, true)\n}\n","\n/**\n * @param {number | string | undefined} mode\n */\nexport function modeToString (mode) {\n  if (mode == null) {\n    return undefined\n  }\n\n  if (typeof mode === 'string') {\n    return mode\n  }\n\n  return mode.toString(8).padStart(4, '0')\n}\n","\n// Import browser version otherwise electron-renderer will end up with node\n// version and fail.\nimport { normaliseInput } from './files/normalise-input-multiple.browser.js'\nimport { modeToString } from './mode-to-string.js'\n\n/**\n * @typedef {import('ipfs-core-types/src/utils').ImportCandidateStream} ImportCandidateStream\n */\n\n/**\n * @param {ImportCandidateStream} source\n * @param {AbortController} abortController\n * @param {Headers|Record<string, string>} [headers]\n */\nexport async function multipartRequest (source, abortController, headers = {}) {\n  const parts = []\n  const formData = new FormData()\n  let index = 0\n  let total = 0\n\n  for await (const { content, path, mode, mtime } of normaliseInput(source)) {\n    let fileSuffix = ''\n    const type = content ? 'file' : 'dir'\n\n    if (index > 0) {\n      fileSuffix = `-${index}`\n    }\n\n    let fieldName = type + fileSuffix\n    const qs = []\n\n    if (mode !== null && mode !== undefined) {\n      qs.push(`mode=${modeToString(mode)}`)\n    }\n\n    if ((mtime) != null) {\n      const { secs, nsecs } = (mtime)\n\n      qs.push(`mtime=${secs}`)\n\n      if (nsecs != null) {\n        qs.push(`mtime-nsecs=${nsecs}`)\n      }\n    }\n\n    if (qs.length) {\n      fieldName = `${fieldName}?${qs.join('&')}`\n    }\n\n    if (content) {\n      formData.set(fieldName, content, path != null ? encodeURIComponent(path) : undefined)\n      const end = total + content.size\n      parts.push({ name: path, start: total, end })\n      total = end\n    } else if (path != null) {\n      formData.set(fieldName, new File([''], encodeURIComponent(path), { type: 'application/x-directory' }))\n    } else {\n      throw new Error('path or content or both must be set')\n    }\n\n    index++\n  }\n\n  return {\n    total,\n    parts,\n    headers,\n    body: formData\n  }\n}\n","import errCode from 'err-code'\nimport { CID } from 'multiformats/cid'\n\n/**\n * @typedef {object} Pinnable\n * @property {string | InstanceType<typeof window.String> | CID} [path]\n * @property {CID} [cid]\n * @property {boolean} [recursive]\n * @property {any} [metadata]\n *\n * @typedef {CID|string|InstanceType<typeof window.String>|Pinnable} ToPin\n * @typedef {ToPin|Iterable<ToPin>|AsyncIterable<ToPin>} Source\n *\n * @typedef {object} Pin\n * @property {string|CID} path\n * @property {boolean} recursive\n * @property {any} [metadata]\n */\n\n/**\n * @param {any} thing\n * @returns {thing is IterableIterator<any> & Iterator<any>}\n */\nfunction isIterable (thing) {\n  return Symbol.iterator in thing\n}\n\n/**\n * @param {any} thing\n * @returns {thing is AsyncIterableIterator<any> & AsyncIterator<any>}\n */\nfunction isAsyncIterable (thing) {\n  return Symbol.asyncIterator in thing\n}\n\n/**\n * @param {any} thing\n * @returns {thing is CID}\n */\nfunction isCID (thing) {\n  return CID.asCID(thing) != null\n}\n\n/**\n * Transform one of:\n *\n * ```ts\n * CID\n * String\n * { cid: CID recursive, metadata }\n * { path: String recursive, metadata }\n * Iterable<CID>\n * Iterable<String>\n * Iterable<{ cid: CID recursive, metadata }>\n * Iterable<{ path: String recursive, metadata }>\n * AsyncIterable<CID>\n * AsyncIterable<String>\n * AsyncIterable<{ cid: CID recursive, metadata }>\n * AsyncIterable<{ path: String recursive, metadata }>\n * ```\n * Into:\n *\n * ```ts\n * AsyncIterable<{ path: CID|String, recursive:boolean, metadata }>\n * ```\n *\n * @param {Source} input\n * @returns {AsyncIterable<Pin>}\n */\n// eslint-disable-next-line complexity\nexport async function * normaliseInput (input) {\n  // must give us something\n  if (input === null || input === undefined) {\n    throw errCode(new Error(`Unexpected input: ${input}`), 'ERR_UNEXPECTED_INPUT')\n  }\n\n  // CID\n  const cid = CID.asCID(input)\n\n  if (cid) {\n    yield toPin({ cid })\n    return\n  }\n\n  if (input instanceof String || typeof input === 'string') {\n    yield toPin({ path: input })\n    return\n  }\n\n  // { cid: CID recursive, metadata }\n  // @ts-expect-error - it still could be iterable or async iterable\n  if (input.cid != null || input.path != null) {\n    // @ts-expect-error\n    return yield toPin(input)\n  }\n\n  // Iterable<?>\n  if (isIterable(input)) {\n    const iterator = input[Symbol.iterator]()\n    const first = iterator.next()\n\n    if (first.done) {\n      return iterator\n    }\n\n    // Iterable<CID>\n    if (isCID(first.value)) {\n      yield toPin({ cid: first.value })\n      for (const cid of iterator) {\n        yield toPin({ cid })\n      }\n      return\n    }\n\n    // Iterable<String>\n    if (first.value instanceof String || typeof first.value === 'string') {\n      yield toPin({ path: first.value })\n      for (const path of iterator) {\n        yield toPin({ path })\n      }\n      return\n    }\n\n    // Iterable<Pinnable>\n    if (first.value.cid != null || first.value.path != null) {\n      yield toPin(first.value)\n      for (const obj of iterator) {\n        yield toPin(obj)\n      }\n      return\n    }\n\n    throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT')\n  }\n\n  // AsyncIterable<?>\n  if (isAsyncIterable(input)) {\n    const iterator = input[Symbol.asyncIterator]()\n    const first = await iterator.next()\n    if (first.done) return iterator\n\n    // AsyncIterable<CID>\n    if (isCID(first.value)) {\n      yield toPin({ cid: first.value })\n      for await (const cid of iterator) {\n        yield toPin({ cid })\n      }\n      return\n    }\n\n    // AsyncIterable<String>\n    if (first.value instanceof String || typeof first.value === 'string') {\n      yield toPin({ path: first.value })\n      for await (const path of iterator) {\n        yield toPin({ path })\n      }\n      return\n    }\n\n    // AsyncIterable<{ cid: CID|String recursive, metadata }>\n    if (first.value.cid != null || first.value.path != null) {\n      yield toPin(first.value)\n      for await (const obj of iterator) {\n        yield toPin(obj)\n      }\n      return\n    }\n\n    throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT')\n  }\n\n  throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT')\n}\n\n/**\n * @param {Pinnable} input\n */\nfunction toPin (input) {\n  const path = input.cid || `${input.path}`\n\n  if (!path) {\n    throw errCode(new Error('Unexpected input: Please path either a CID or an IPFS path'), 'ERR_UNEXPECTED_INPUT')\n  }\n\n  /** @type {Pin} */\n  const pin = {\n    path,\n    recursive: input.recursive !== false\n  }\n\n  if (input.metadata != null) {\n    pin.metadata = input.metadata\n  }\n\n  return pin\n}\n","import { multiaddr } from '@multiformats/multiaddr'\nimport { multiaddrToUri } from '@multiformats/multiaddr-to-uri'\n\n/**\n * @typedef {import('@multiformats/multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @param {string|Multiaddr|URL} url - A string, multiaddr or URL to convert to a url string\n * @returns {string}\n */\nexport function toUrlString (url) {\n  try {\n    // @ts-expect-error\n    url = multiaddrToUri(multiaddr(url))\n  } catch (/** @type {any} */ err) { }\n\n  url = url.toString()\n\n  return url\n}\n"],"names":[],"sourceRoot":"","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14]}