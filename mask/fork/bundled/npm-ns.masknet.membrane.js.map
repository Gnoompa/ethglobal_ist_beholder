{"version":3,"file":"bundled/npm-ns.masknet.membrane.js","mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA,6DAAe;AACf;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA,oBAAoB,iDAAiD;AACrE;AACA;AACA;AACA,qDAAqD;AACrD,oBAAoB,8TAA8T;AAClV,oBAAoB,mIAAmI;AACvJ,oBAAoB,+BAA+B;AACnD,oBAAoB,8KAA8K;AAClM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iHAAiH;AACjH;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mBAAmB,iBAAiB;AAClF,0FAA0F;AAC1F;AACA,2EAA2E;AAC3E;AACA,kEAAkE;AAClE;AACA;AACA;AACA,oBAAoB,oCAAoC;AACxD,oBAAoB,oFAAoF;AACxG,oBAAoB,4BAA4B;AAChD;AACA,oBAAoB,+BAA+B;AACnD,oBAAoB,+BAA+B;AACnD,oBAAoB,2DAA2D;AAC/E,oBAAoB,2BAA2B;AAC/C,oBAAoB,6BAA6B;AACjD,oBAAoB,8BAA8B;AAClD,oBAAoB,4BAA4B;AAChD,oBAAoB,yBAAyB;AAC7C,oBAAoB,6EAA6E,eAAe;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qFAAqF;AACzG,oBAAoB,6DAA6D;AACjF;AACA;AACA;AACA;AACA,oBAAoB,+BAA+B;AACnD,oBAAoB,+BAA+B;AACnD,oBAAoB,4BAA4B;AAChD,oBAAoB,6BAA6B;AACjD,oBAAoB,6BAA6B;AACjD,oBAAoB,6BAA6B;AACjD,oBAAoB,8BAA8B;AAClD,oBAAoB,8BAA8B,iBAAiB;AACnE;AACA;AACA,oBAAoB,0BAA0B;AAC9C,oBAAoB,8HAA8H;AAClJ,oBAAoB,0BAA0B;AAC9C,oBAAoB,8HAA8H;AAClJ;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,4BAA4B,6HAA6H,sBAAsB;AAC/K,6EAA6E;AAC7E,yCAAyC;AACzC;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS,aAAa,YAAY;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,kDAAkD,GAAG;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS,oBAAoB,YAAY;AACvF;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,oDAAoD,oCAAoC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,gCAAgC,8CAA8C;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,oDAAoD,oCAAoC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,gCAAgC,8CAA8C;AAC9E;AACA;AACA;AACA,oCAAoC,UAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,oDAAoD,oCAAoC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,gCAAgC,8CAA8C;AAC9E;AACA;AACA;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,oDAAoD,oCAAoC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,gCAAgC,8CAA8C;AAC9E;AACA;AACA;AACA,oCAAoC,4BAA4B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,oDAAoD,oCAAoC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,gCAAgC,8CAA8C;AAC9E;AACA;AACA;AACA,oCAAoC,qCAAqC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,oDAAoD,oCAAoC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,gCAAgC,8CAA8C;AAC9E;AACA;AACA;AACA,oCAAoC,8CAA8C;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D,gCAAgC,8CAA8C;AAC9E;AACA,gCAAgC,SAAS;AACzC;AACA;AACA,gEAAgE,iBAAiB,GAAG,OAAO;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,YAAY;AACxD,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E;AACA,0EAA0E,0CAA0C;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA,wCAAwC,6BAA6B;AACrE;AACA;AACA;AACA;AACA,iDAAiD,MAAK;AACtD,kCAAkC,CAAuD;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA,0KAA0K;AAC1K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qHAAqH;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,6BAA6B,gBAAgB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA;AACA;AACA,4CAA4C,oBAAoB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS,WAAW,YAAY;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA,2GAA2G;AAC3G;AACA;AACA;AACA,iIAAiI;AACjI;AACA;AACA;AACA;AACA,8FAA8F;AAC9F;AACA;AACA;AACA,mIAAmI;AACnI;AACA;AACA;AACA;AACA,gHAAgH;AAChH;AACA;AACA;AACA;AACA,gHAAgH;AAChH;AACA;AACA;AACA;AACA,2HAA2H;AAC3H;AACA;AACA;AACA;AACA,2HAA2H;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,8CAA8C;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uGAAuG;AACvG;AACA;AACA;AACA;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E;AAC9E,iFAAiF;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA,4FAA4F;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kBAAkB;AAC1D;AACA;AACA;AACA;AACA,uCAAuC,sDAAsD;AAC7F;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uHAAuH;AACvJ;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4GAA4G;AAC5G;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA,gCAAgC,iFAAiF;AACjH;AACA;AACA,gCAAgC,0CAA0C;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA,gCAAgC,8BAA8B;AAC9D,4CAA4C;AAC5C;AACA,oCAAoC,8CAA8C;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA,gCAAgC,2EAA2E;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA,gCAAgC,2EAA2E;AAC3G;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA,gCAAgC,8CAA8C;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD,gCAAgC,kFAAkF,QAAQ;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8HAA8H;AAC9J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iCAAiC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kJAAkJ;AAClL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iCAAiC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iGAAiG;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA,gCAAgC,0FAA0F,QAAQ;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0FAA0F,QAAQ;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0FAA0F,QAAQ;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+DAA+D;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oGAAoG;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS,QAAQ,YAAY;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS,QAAQ,YAAY;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,0CAA0C;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0CAA0C;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,wCAAwC;AACxC;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,8CAA8C,SAAS,QAAQ,YAAY;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS,oBAAoB,YAAY;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA,kDAAkD;AAClD;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS,WAAW,YAAY;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA,2CAA2C,YAAY;AACvD;AACA;AACA;AACA,gCAAgC,0CAA0C;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0CAA0C;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uCAAuC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC,EAAC;;;ACp+G4C;AAC9C;AACA;AACO;AACP;AACA;AACA;AACA,IAAI,sBAAG;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK,IAAI,YAAY;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrCqK;AACrH;AAChD;AACA,QAAQ,uBAAuB;AAC/B;AACA;AACe;AACf;AACA;AACA;AACA,YAAY,sGAAsG,iBAAiB,iBAAiB;AACpJ,0BAA0B,eAAe;AACzC,oBAAoB,+BAAkB;AACtC;AACA;AACA;AACA,sBAAsB,eAAe;AACrC,KAAK;AACL,IAAI,+BAAc;AAClB;AACA;AACA,+BAA+B,yCAAwB;AACvD;AACA,iGAAiG,yCAAwB;AACzH;AACA;AACA,QAAQ,yEAAwD;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;ACpCyC;AACG","sources":["webpack://mask-network/./node_modules/.pnpm/@masknet+membrane@0.1.5/node_modules/@masknet/membrane/dist/createMembraneMarshall.js","webpack://mask-network/./node_modules/.pnpm/@masknet+membrane@0.1.5/node_modules/@masknet/membrane/dist/membrane.js","webpack://mask-network/./node_modules/.pnpm/@masknet+membrane@0.1.5/node_modules/@masknet/membrane/dist/evaluator.js","webpack://mask-network/./node_modules/.pnpm/@masknet+membrane@0.1.5/node_modules/@masknet/membrane/dist/index.js"],"sourcesContent":["// @ts-nocheck\n// This file is built from '@locker/near-membrane-base'.createMembraneMarshall.\n// DO NOT edit it manually.\nexport default {\n    bindings: [\n        {\n            import: 'debugTargetBookkeeping',\n            from: '',\n        },\n        {\n            import: 'attachDebuggerTarget',\n            from: '',\n        },\n        {\n            import: 'proxyTargetToLazyPropertyDescriptorStateMap',\n            from: '',\n        },\n        {\n            export: 'default',\n        },\n    ],\n    execute: function (__, context) {\n        var _ = context.globalThis;\n        function createMembraneMarshall(globalObject) {\n            var _ref, _ref2, _ReflectApply, _globalThisRef$BigInt, _globalThisRef$BigUin;\n            /* eslint-disable prefer-object-spread */ const ArrayCtor = _.Array;\n            const ArrayBufferCtor = _.ArrayBuffer;\n            const ErrorCtor = _.Error;\n            const NumberCtor = _.Number;\n            const ObjectCtor = _.Object;\n            const ProxyCtor = _.Proxy;\n            const ReflectRef = _.Reflect;\n            const RegExpCtor = _.RegExp;\n            const StringCtor = _.String;\n            const SymbolCtor = _.Symbol;\n            const TypeErrorCtor = _.TypeError; // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow\n            const WeakMapCtor = _.WeakMap;\n            const WeakSetCtor = _.WeakSet;\n            const { for: SymbolFor, toStringTag: SymbolToStringTag } = SymbolCtor;\n            const { \n            // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow\n            apply: ReflectApply, construct: ReflectConstruct, defineProperty: ReflectDefineProperty, deleteProperty: ReflectDeleteProperty, get: ReflectGet, getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor, getPrototypeOf: ReflectGetPrototypeOf, has: ReflectHas, isExtensible: ReflectIsExtensible, ownKeys: ReflectOwnKeys, preventExtensions: ReflectPreventExtensions, set: ReflectSet, // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow\n            setPrototypeOf: ReflectSetPrototypeOf, } = ReflectRef;\n            const { assign: ObjectAssign, defineProperties: ObjectDefineProperties, freeze: ObjectFreeze, getOwnPropertyDescriptor: ObjectGetOwnPropertyDescriptor, getOwnPropertyDescriptors: ObjectGetOwnPropertyDescriptors, isFrozen: ObjectIsFrozen, isSealed: ObjectIsSealed, keys: ObjectKeys, prototype: ObjectProto, seal: ObjectSeal, } = ObjectCtor;\n            const { hasOwnProperty: ObjectProtoHasOwnProperty, propertyIsEnumerable: ObjectProtoPropertyIsEnumerable, toString: ObjectProtoToString, } = ObjectProto;\n            const { hasOwn: OriginalObjectHasOwn } = ObjectCtor;\n            const { __defineGetter__: ObjectProtoDefineGetter, __defineSetter__: ObjectProtoDefineSetter, __lookupGetter__: ObjectProtoLookupGetter, __lookupSetter__: ObjectProtoLookupSetter, } = ObjectProto;\n            const ObjectHasOwn = typeof OriginalObjectHasOwn === 'function'\n                ? OriginalObjectHasOwn\n                : (object, key) => ReflectApply(ObjectProtoHasOwnProperty, object, [key]);\n            const globalThisRef = (_ref =\n                (_ref2 =\n                    globalObject != null\n                        ? globalObject // https://caniuse.com/mdn-javascript_builtins_globalthisfor\n                        : typeof _.globalThis !== 'undefined'\n                            ? _.globalThis\n                            : undefined) != null\n                    ? _ref2 // eslint-disable-next-line no-restricted-globals\n                    : typeof _.self !== 'undefined'\n                        ? _.self\n                        : undefined) != null\n                ? _ref\n                : (ReflectDefineProperty(ObjectProto, 'globalThis', {\n                    __proto__: null,\n                    configurable: true,\n                    get() {\n                        ReflectDeleteProperty(ObjectProto, 'globalThis'); // Safari 12 on iOS 12.1 has a `this` of `undefined` so we\n                        // fallback to `self`.\n                        // eslint-disable-next-line no-restricted-globals\n                        return this != null ? this : _.self;\n                    },\n                }),\n                    _.globalThis);\n            const IS_IN_SHADOW_REALM = typeof globalObject !== 'object' || globalObject === null;\n            const LOCKER_DEBUG_MODE_SYMBOL = !IS_IN_SHADOW_REALM ? SymbolFor('@@lockerDebugMode') : undefined;\n            const LOCKER_IDENTIFIER_MARKER = '$LWS';\n            const LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL = !IS_IN_SHADOW_REALM\n                ? SymbolFor('@@lockerNearMembraneSerializedValue')\n                : undefined;\n            const LOCKER_NEAR_MEMBRANE_SYMBOL = !IS_IN_SHADOW_REALM ? SymbolFor('@@lockerNearMembrane') : undefined;\n            const LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL = SymbolFor('@@lockerNearMembraneUndefinedValue'); // The default stack trace limit in Chrome is 10.\n            // Set to 20 to account for stack trace filtering.\n            const LOCKER_STACK_TRACE_LIMIT = 20; // This package is bundled by third-parties that have their own build time\n            // replacement logic. Instead of customizing each build system to be aware\n            // of this package we implement a two phase debug mode by performing small\n            // runtime checks to determine phase one, our code is unminified, and\n            // phase two, the user opted-in to custom devtools formatters. Phase one\n            // is used for light weight initialization time debug while phase two is\n            // reserved for post initialization runtime.\n            const LOCKER_UNMINIFIED_FLAG = `${() => /* $LWS */ 1}`.includes('*'); // Indicate whether debug support is available.\n            const LOCKER_DEBUGGABLE_FLAG = LOCKER_UNMINIFIED_FLAG && !IS_IN_SHADOW_REALM; // BigInt is not supported in Safari 13.1.\n            // https://caniuse.com/bigint\n            const FLAGS_REG_EXP = IS_IN_SHADOW_REALM ? /\\w*$/ : undefined; // Minification safe reference to the private `BoundaryProxyHandler`\n            // 'serializedValue' property name.\n            let MINIFICATION_SAFE_SERIALIZED_VALUE_PROPERTY_NAME; // Minification safe references to the private `BoundaryProxyHandler`\n            // 'apply' and 'construct' trap variant's property names.\n            let MINIFICATION_SAFE_TRAP_PROPERTY_NAMES;\n            const SUPPORTS_BIG_INT = typeof _.BigInt === 'function';\n            const { isArray: isArrayOrThrowForRevoked } = ArrayCtor;\n            const { includes: ArrayProtoIncludes, indexOf: ArrayProtoIndexOf, slice: ArrayProtoSlice, } = ArrayCtor.prototype;\n            const { isView: ArrayBufferIsView } = ArrayBufferCtor;\n            const BigIntProtoValueOf = SUPPORTS_BIG_INT ? _.BigInt.prototype.valueOf : undefined;\n            const { valueOf: BooleanProtoValueOf } = _.Boolean.prototype;\n            const { toString: ErrorProtoToString } = ErrorCtor.prototype;\n            const { bind: FunctionProtoBind, toString: FunctionProtoToString } = _.Function.prototype;\n            const { stringify: JSONStringify } = _.JSON;\n            const { isInteger: NumberIsInteger } = NumberCtor;\n            const { valueOf: NumberProtoValueOf } = NumberCtor.prototype;\n            const { revocable: ProxyRevocable } = ProxyCtor;\n            const { prototype: RegExpProto } = RegExpCtor;\n            const { exec: RegExpProtoExec, test: RegExpProtoTest, toString: RegExProtoToString } = RegExpProto; // Edge 15 does not support RegExp.prototype.flags.\n            // https://caniuse.com/mdn-javascript_builtins_regexp_flags\n            const RegExpProtoFlagsGetter = IS_IN_SHADOW_REALM\n                ? (_ReflectApply = ReflectApply(ObjectProtoLookupGetter, RegExpProto, ['flags'])) != null\n                    ? _ReflectApply\n                    : function flags() {\n                        const string = ReflectApply(RegExProtoToString, this, []);\n                        return ReflectApply(RegExpProtoExec, FLAGS_REG_EXP, [string])[0];\n                    }\n                : undefined;\n            const RegExpProtoSourceGetter = ReflectApply(ObjectProtoLookupGetter, RegExpProto, ['source']);\n            const { replace: StringProtoReplace, slice: StringProtoSlice, valueOf: StringProtoValueOf, } = StringCtor.prototype;\n            const { toString: SymbolProtoToString, valueOf: SymbolProtoValueOf } = SymbolCtor.prototype;\n            const BigInt64ArrayProto = (_globalThisRef$BigInt = globalThisRef.BigInt64Array) == null ? void 0 : _globalThisRef$BigInt.prototype;\n            const BigUint64ArrayProto = (_globalThisRef$BigUin = globalThisRef.BigUint64Array) == null\n                ? void 0\n                : _globalThisRef$BigUin.prototype;\n            const { prototype: Float32ArrayProto } = _.Float32Array;\n            const { prototype: Float64ArrayProto } = _.Float64Array;\n            const { prototype: Int8ArrayProto } = _.Int8Array;\n            const { prototype: Int16ArrayProto } = _.Int16Array;\n            const { prototype: Int32ArrayProto } = _.Int32Array;\n            const { prototype: Uint8ArrayProto } = _.Uint8Array;\n            const { prototype: Uint16ArrayProto } = _.Uint16Array;\n            const { prototype: Uint32ArrayProto } = _.Uint32Array; // eslint-disable-next-line no-proto\n            const TypedArrayProto = Uint8ArrayProto.__proto__;\n            const TypedArrayProtoLengthGetter = ReflectApply(ObjectProtoLookupGetter, TypedArrayProto, ['length']);\n            const { prototype: WeakMapProto } = WeakMapCtor;\n            const { delete: WeakMapProtoDelete, has: WeakMapProtoHas, set: WeakMapProtoSet, [SymbolToStringTag]: WeakMapProtoSymbolToStringTag, } = WeakMapProto;\n            const { prototype: WeakSetProto } = WeakSetCtor;\n            const { add: WeakSetProtoAdd, has: WeakSetProtoHas, delete: WeakSetProtoDelete, [SymbolToStringTag]: WeakSetProtoSymbolToStringTag, } = WeakSetProto;\n            const consoleObject = !IS_IN_SHADOW_REALM && typeof _.console === 'object' && _.console !== null ? _.console : undefined;\n            const consoleInfo = consoleObject == null ? void 0 : consoleObject.info;\n            const localEval = IS_IN_SHADOW_REALM ? _.eval : undefined; // Install flags to ensure things are installed once per realm.\n            let installedErrorPrepareStackTraceFlag = false;\n            let installedPropertyDescriptorMethodWrappersFlag = false;\n            function alwaysFalse() {\n                return false;\n            }\n            const installErrorPrepareStackTrace = LOCKER_UNMINIFIED_FLAG\n                ? () => {\n                    if (installedErrorPrepareStackTraceFlag) {\n                        return;\n                    }\n                    installedErrorPrepareStackTraceFlag = true; // Feature detect the V8 stack trace API.\n                    // https://v8.dev/docs/stack-trace-api\n                    const CallSite = (() => {\n                        try {\n                            var _callSites$;\n                            ErrorCtor.prepareStackTrace = (_error, callSites) => callSites;\n                            const callSites = new ErrorCtor().stack;\n                            ReflectDeleteProperty(ErrorCtor, 'prepareStackTrace');\n                            return isArrayOrThrowForRevoked(callSites) && callSites.length > 0\n                                ? (_callSites$ = callSites[0]) == null\n                                    ? void 0\n                                    : _callSites$.constructor\n                                : undefined; // eslint-disable-next-line no-empty\n                        }\n                        catch (_unused) { }\n                        return undefined;\n                    })();\n                    if (typeof CallSite !== 'function') {\n                        return;\n                    }\n                    const { getEvalOrigin: CallSiteProtoGetEvalOrigin, getFunctionName: CallSiteProtoGetFunctionName, toString: CallSiteProtoToString, } = CallSite.prototype; // A regexp to detect call sites containing LOCKER_IDENTIFIER_MARKER.\n                    const lockerFunctionNameMarkerRegExp = new RegExpCtor(`${ReflectApply(StringProtoReplace, LOCKER_IDENTIFIER_MARKER, [\n                        /[\\\\^$.*+?()[\\]{}|]/g,\n                        '\\\\$&',\n                    ]) // Function name references in call sites also contain\n                    }(?=\\\\.|$)`);\n                    const formatStackTrace = function formatStackTrace1(error, callSites) {\n                        // Based on V8's default stack trace formatting:\n                        // https://chromium.googlesource.com/v8/v8.git/+/refs/heads/main/src/execution/messages.cc#371\n                        let stackTrace = '';\n                        try {\n                            stackTrace = ReflectApply(ErrorProtoToString, error, []);\n                        }\n                        catch (_unused2) {\n                            stackTrace = '<error>';\n                        }\n                        let consecutive = false;\n                        for (let i = 0, { length } = callSites; i < length; i += 1) {\n                            const callSite = callSites[i];\n                            const funcName = ReflectApply(CallSiteProtoGetFunctionName, callSite, []);\n                            let isMarked = false;\n                            if (typeof funcName === 'string' &&\n                                funcName !== 'eval' &&\n                                ReflectApply(RegExpProtoTest, lockerFunctionNameMarkerRegExp, [funcName])) {\n                                isMarked = true;\n                            }\n                            if (!isMarked) {\n                                const evalOrigin = ReflectApply(CallSiteProtoGetEvalOrigin, callSite, []);\n                                if (typeof evalOrigin === 'string' &&\n                                    ReflectApply(RegExpProtoTest, lockerFunctionNameMarkerRegExp, [evalOrigin])) {\n                                    isMarked = true;\n                                }\n                            } // Only write a single LWS entry per consecutive LWS stacks.\n                            if (isMarked) {\n                                if (!consecutive) {\n                                    consecutive = true;\n                                    stackTrace += '\\n    at LWS';\n                                }\n                                continue;\n                            }\n                            else {\n                                consecutive = false;\n                            }\n                            try {\n                                stackTrace += `\\n    at ${ReflectApply(CallSiteProtoToString, callSite, [])}`; // eslint-disable-next-line no-empty\n                            }\n                            catch (_unused3) { }\n                        }\n                        return stackTrace;\n                    };\n                    try {\n                        // Error.prepareStackTrace cannot be a bound or proxy wrapped\n                        // function, so to obscure its source we wrap the call to\n                        // formatStackTrace().\n                        ErrorCtor.prepareStackTrace = function prepareStackTrace(error, callSites) {\n                            return formatStackTrace(error, callSites);\n                        }; // eslint-disable-next-line no-empty\n                    }\n                    catch (_unused4) { }\n                    try {\n                        const { stackTraceLimit } = ErrorCtor;\n                        if (typeof stackTraceLimit !== 'number' || stackTraceLimit < LOCKER_STACK_TRACE_LIMIT) {\n                            ErrorCtor.stackTraceLimit = LOCKER_STACK_TRACE_LIMIT;\n                        } // eslint-disable-next-line no-empty\n                    }\n                    catch (_unused5) { }\n                }\n                : noop;\n            function noop() { }\n            const serializeBigIntObject = IS_IN_SHADOW_REALM\n                ? (bigIntObject) => \n                // Step 2: If Type(value) is Object and value has a [[BigIntData]] internal slot, then\n                //     a. Assert: Type(value.[[BigIntData]]) is BigInt.\n                ReflectApply(BigIntProtoValueOf, bigIntObject, [])\n                : noop;\n            const serializeBooleanObject = IS_IN_SHADOW_REALM\n                ? (booleanObject) => \n                // Step 2: If Type(value) is Object and value has a [[BooleanData]] internal slot, then\n                //     a. Let b be value.[[BooleanData]].\n                //     b. Assert: Type(b) is Boolean.\n                ReflectApply(BooleanProtoValueOf, booleanObject, [])\n                : noop;\n            const serializeNumberObject = IS_IN_SHADOW_REALM\n                ? (numberObject) => \n                // Step 2: If Type(value) is Object and value has a [[NumberData]] internal slot, then\n                //     a. Let n be value.[[NumberData]].\n                //     b. Assert: Type(n) is Number.\n                ReflectApply(NumberProtoValueOf, numberObject, [])\n                : noop;\n            const serializeRegExp = IS_IN_SHADOW_REALM\n                ? (value) => {\n                    // 22.2.5.12 get RegExp.prototype.source\n                    // https://tc39.es/ecma262/#sec-get-regexp.prototype.source\n                    // Step 3: If R does not have an [[OriginalSource]] internal slot, then\n                    //     a. If SameValue(R, %RegExp.prototype%) is true, return \"(?:)\".\n                    //     b. Otherwise, throw a TypeError exception.\n                    if (value !== RegExpProto) {\n                        const source = ReflectApply(RegExpProtoSourceGetter, value, []);\n                        return JSONStringify({\n                            __proto__: null,\n                            flags: ReflectApply(RegExpProtoFlagsGetter, value, []),\n                            source,\n                        });\n                    }\n                    return undefined;\n                }\n                : noop;\n            const serializeStringObject = IS_IN_SHADOW_REALM\n                ? (stringObject) => \n                // Step 2: If Type(value) is Object and value has a [[StringData]] internal slot, then\n                //     a. Let s be value.[[StringData]].\n                //     b. Assert: Type(s) is String.\n                ReflectApply(StringProtoValueOf, stringObject, [])\n                : noop;\n            const serializeSymbolObject = IS_IN_SHADOW_REALM\n                ? (symbolObject) => \n                // Step 2: If Type(value) is Object and value has a [[SymbolData]] internal slot, then\n                //     a. Let s be value.[[SymbolData]].\n                //     b. Assert: Type(s) is Symbol.\n                ReflectApply(SymbolProtoValueOf, symbolObject, [])\n                : noop;\n            const serializeTargetByBrand = IS_IN_SHADOW_REALM\n                ? (target) => {\n                    const brand = ReflectApply(ObjectProtoToString, target, []);\n                    switch (brand) {\n                        // The brand checks below represent boxed primitives of\n                        // `ESGlobalKeys` in packages/near-membrane-base/src/intrinsics.ts\n                        // which are not remapped or reflective.\n                        case '[object Boolean]':\n                            return serializeBooleanObject(target);\n                        case '[object Number]':\n                            return serializeNumberObject(target);\n                        case '[object RegExp]':\n                            return serializeRegExp(target);\n                        case '[object String]':\n                            return serializeStringObject(target);\n                        case '[object Object]':\n                            try {\n                                // Symbol.prototype[@@toStringTag] is defined by default so\n                                // must have been removed.\n                                // https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag\n                                return serializeSymbolObject(target); // eslint-disable-next-line no-empty\n                            }\n                            catch (_unused6) { }\n                            if (SUPPORTS_BIG_INT) {\n                                // BigInt.prototype[@@toStringTag] is defined by default so\n                                // must have been removed.\n                                // https://tc39.es/ecma262/#sec-bigint.prototype-@@tostringtag\n                                try {\n                                    return serializeBigIntObject(target); // eslint-disable-next-line no-empty\n                                }\n                                catch (_unused7) { }\n                            }\n                        // eslint-disable-next-line no-fallthrough\n                        default:\n                            return undefined;\n                    }\n                }\n                : noop;\n            const serializeTargetByTrialAndError = IS_IN_SHADOW_REALM\n                ? (target) => {\n                    // The serialization attempts below represent boxed primitives of\n                    // `ESGlobalKeys` in packages/near-membrane-base/src/intrinsics.ts\n                    // which are not remapped or reflective.\n                    try {\n                        // Symbol.prototype[@@toStringTag] is defined by default so\n                        // attempted before others.\n                        // https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag\n                        return serializeSymbolObject(target); // eslint-disable-next-line no-empty\n                    }\n                    catch (_unused8) { }\n                    if (SUPPORTS_BIG_INT) {\n                        // BigInt.prototype[@@toStringTag] is defined by default so\n                        // attempted before others.\n                        // https://tc39.es/ecma262/#sec-bigint.prototype-@@tostringtag\n                        try {\n                            return serializeBigIntObject(target); // eslint-disable-next-line no-empty\n                        }\n                        catch (_unused9) { }\n                    }\n                    try {\n                        return serializeBooleanObject(target); // eslint-disable-next-line no-empty\n                    }\n                    catch (_unused10) { }\n                    try {\n                        return serializeNumberObject(target); // eslint-disable-next-line no-empty\n                    }\n                    catch (_unused11) { }\n                    try {\n                        return serializeRegExp(target); // eslint-disable-next-line no-empty\n                    }\n                    catch (_unused12) { }\n                    try {\n                        return serializeStringObject(target); // eslint-disable-next-line no-empty\n                    }\n                    catch (_unused13) { }\n                    return undefined;\n                }\n                : noop;\n            function toSafeTemplateStringValue(value) {\n                if (typeof value === 'string') {\n                    return value;\n                }\n                try {\n                    if (typeof value === 'object' && value !== null) {\n                        const result = ReflectApply(ObjectProtoToString, value, []);\n                        return result === '[object Symbol]' ? ReflectApply(SymbolProtoToString, value, []) : result;\n                    }\n                    if (typeof value === 'function') {\n                        return ReflectApply(FunctionProtoToString, value, []);\n                    } // Attempt to coerce `value` to a string with the String() constructor.\n                    // Section 22.1.1.1 String ( value )\n                    // https://tc39.es/ecma262/#sec-string-constructor-string-value\n                    return StringCtor(value); // eslint-disable-next-line no-empty\n                }\n                catch (_unused14) { }\n                return '[Object Unknown]';\n            } // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow\n            function toSafeWeakMap(weakMap) {\n                ReflectSetPrototypeOf(weakMap, null);\n                weakMap.delete = WeakMapProtoDelete;\n                weakMap.has = WeakMapProtoHas;\n                weakMap.set = WeakMapProtoSet;\n                weakMap[SymbolToStringTag] = WeakMapProtoSymbolToStringTag;\n                ReflectSetPrototypeOf(weakMap, WeakMapProto);\n                return weakMap;\n            }\n            function toSafeWeakSet(weakSet) {\n                ReflectSetPrototypeOf(weakSet, null);\n                weakSet.add = WeakSetProtoAdd;\n                weakSet.delete = WeakSetProtoDelete;\n                weakSet.has = WeakSetProtoHas;\n                weakSet[SymbolToStringTag] = WeakSetProtoSymbolToStringTag;\n                ReflectSetPrototypeOf(weakSet, WeakSetProto);\n                return weakSet;\n            }\n            return function createHooksCallback(color, foreignCallableHooksCallback, options) {\n                if (IS_IN_SHADOW_REALM) {\n                    options = undefined;\n                }\n                const { distortionCallback, instrumentation, liveTargetCallback, // eslint-disable-next-line prefer-object-spread\n                 } = ObjectAssign({\n                    __proto__: null,\n                }, options);\n                const LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG = // definition with a LOCKER_UNMINIFIED_FLAG check to have instrumentation\n                 \n                // removed in minified production builds.\n                !IS_IN_SHADOW_REALM && typeof instrumentation === 'object' && instrumentation !== null;\n                const arityToApplyTrapNameRegistry = {\n                    // Populated in the returned connector function below.\n                    __proto__: null,\n                    0: undefined,\n                    1: undefined,\n                    2: undefined,\n                    3: undefined,\n                    4: undefined,\n                    n: undefined,\n                };\n                const arityToConstructTrapNameRegistry = {\n                    // Populated in the returned connector function below.\n                    __proto__: null,\n                    0: undefined,\n                    1: undefined,\n                    2: undefined,\n                    3: undefined,\n                    4: undefined,\n                    n: undefined,\n                };\n                const localProxyTargetToLazyPropertyDescriptorStateMap = toSafeWeakMap(new WeakMapCtor());\n                const proxyTargetToPointerMap = toSafeWeakMap(new WeakMapCtor());\n                const startActivity = LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG ? instrumentation.startActivity : undefined;\n                let foreignCallablePushErrorTarget;\n                let foreignCallablePushTarget;\n                let foreignCallableApply;\n                let foreignCallableConstruct;\n                let foreignCallableDefineProperty;\n                let foreignCallableDeleteProperty;\n                let foreignCallableGet;\n                let foreignCallableGetOwnPropertyDescriptor;\n                let foreignCallableGetPrototypeOf;\n                let foreignCallableHas;\n                let foreignCallableIsExtensible;\n                let foreignCallableOwnKeys;\n                let foreignCallablePreventExtensions;\n                let foreignCallableSet;\n                let foreignCallableSetPrototypeOf;\n                let foreignCallableDebugInfo;\n                let foreignCallableGetPropertyValue;\n                let foreignCallableGetLazyPropertyDescriptorStateByTarget;\n                let foreignCallableGetTargetIntegrityTraits;\n                let foreignCallableGetToStringTagOfTarget;\n                let foreignCallableInstallErrorPrepareStackTrace;\n                let foreignCallableIsTargetLive;\n                let foreignCallableIsTargetRevoked;\n                let foreignCallableSerializeTarget;\n                let foreignCallableSetLazyPropertyDescriptorStateByTarget;\n                let foreignCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors;\n                let foreignCallableBatchGetPrototypeOfWhenHasNoOwnProperty;\n                let foreignCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor;\n                let fastForeignTargetPointers;\n                let foreignPointerBigInt64ArrayProto;\n                let foreignPointerBigUint64ArrayProto;\n                let foreignPointerFloat32ArrayProto;\n                let foreignPointerFloat64ArrayProto;\n                let foreignPointerInt8ArrayProto;\n                let foreignPointerInt16ArrayProto;\n                let foreignPointerInt32ArrayProto;\n                let foreignPointerObjectProto;\n                let foreignPointerTypedArrayProto;\n                let foreignPointerUint8ArrayProto;\n                let foreignPointerUint16ArrayProto;\n                let foreignPointerUint32ArrayProto;\n                let selectedTarget;\n                let useFastForeignTargetPath = IS_IN_SHADOW_REALM;\n                let useFastForeignTargetPathForTypedArrays = IS_IN_SHADOW_REALM;\n                let nearMembraneSymbolFlag = false;\n                let lastProxyTrapCalled = 0;\n                const activateLazyOwnPropertyDefinition = IS_IN_SHADOW_REALM\n                    ? (target, key, state) => {\n                        state[key] = false;\n                        const foreignTargetPointer = getTransferablePointer(target);\n                        let safeDesc;\n                        try {\n                            foreignCallableGetOwnPropertyDescriptor(foreignTargetPointer, key, (_key, configurable, enumerable, writable, valuePointer, getterPointer, setterPointer) => {\n                                safeDesc = createDescriptorFromMeta(configurable, enumerable, writable, valuePointer, getterPointer, setterPointer);\n                            });\n                        }\n                        catch (error) {\n                            var _selectedTarget;\n                            const errorToThrow = (_selectedTarget = selectedTarget) != null ? _selectedTarget : error;\n                            selectedTarget = undefined;\n                            throw errorToThrow;\n                        }\n                        if (safeDesc) {\n                            ReflectDefineProperty(target, key, safeDesc);\n                        }\n                        else {\n                            ReflectDeleteProperty(target, key);\n                        }\n                    }\n                    : noop;\n                let checkDebugMode = LOCKER_DEBUGGABLE_FLAG\n                    ? () => {\n                        try {\n                            if (ObjectHasOwn(globalThisRef, LOCKER_DEBUG_MODE_SYMBOL)) {\n                                checkDebugMode = () => true;\n                                installErrorPrepareStackTrace();\n                                foreignCallableInstallErrorPrepareStackTrace();\n                            }\n                        }\n                        catch (_unused15) {\n                            checkDebugMode = alwaysFalse;\n                        }\n                        return false;\n                    }\n                    : alwaysFalse;\n                const clearFastForeignTargetPointers = IS_IN_SHADOW_REALM\n                    ? () => {\n                        fastForeignTargetPointers = toSafeWeakSet(new WeakSetCtor());\n                    }\n                    : noop;\n                function copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget(foreignTargetPointer, shadowTarget) {\n                    let activity;\n                    if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                        activity = startActivity('copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget');\n                    }\n                    let protoPointerOrNull;\n                    try {\n                        protoPointerOrNull = foreignCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors(foreignTargetPointer, (...descriptorTuples) => {\n                            const descriptors = {};\n                            for (let i = 0, { length } = descriptorTuples; i < length; i += 7) {\n                                const key = descriptorTuples[i];\n                                descriptors[key] = createDescriptorFromMeta(descriptorTuples[i + 1], descriptorTuples[i + 2], descriptorTuples[i + 3], descriptorTuples[i + 4], descriptorTuples[i + 5], descriptorTuples[i + 6]);\n                            } // Use `ObjectDefineProperties()` instead of individual\n                            // `ReflectDefineProperty()` calls for better performance.\n                            ObjectDefineProperties(shadowTarget, descriptors);\n                        });\n                    }\n                    catch (error) {\n                        var _selectedTarget2;\n                        const errorToThrow = (_selectedTarget2 = selectedTarget) != null ? _selectedTarget2 : error;\n                        selectedTarget = undefined;\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity.error(errorToThrow);\n                        }\n                        throw errorToThrow;\n                    }\n                    let proto;\n                    if (typeof protoPointerOrNull === 'function') {\n                        protoPointerOrNull();\n                        proto = selectedTarget;\n                        selectedTarget = undefined;\n                    }\n                    else {\n                        proto = null;\n                    }\n                    ReflectSetPrototypeOf(shadowTarget, proto);\n                    if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                        activity.stop();\n                    }\n                }\n                function createApplyOrConstructTrapForZeroOrMoreArgs(proxyTrapEnum) {\n                    const isApplyTrap = proxyTrapEnum & 1; /* ProxyHandlerTraps.Apply */\n                    const activityName = `Reflect.${isApplyTrap ? 'apply' : 'construct'}()`;\n                    const arityToApplyOrConstructTrapNameRegistry = isApplyTrap\n                        ? arityToApplyTrapNameRegistry\n                        : arityToConstructTrapNameRegistry;\n                    const foreignCallableApplyOrConstruct = isApplyTrap\n                        ? foreignCallableApply\n                        : foreignCallableConstruct;\n                    return function applyOrConstructTrap(shadowTarget, thisArgOrArgs, argsOrNewTarget) {\n                        lastProxyTrapCalled = proxyTrapEnum;\n                        const args = isApplyTrap ? argsOrNewTarget : thisArgOrArgs;\n                        const { length } = args;\n                        if (length !== 0) {\n                            var _arityToApplyOrConstr;\n                            return this[(_arityToApplyOrConstr = arityToApplyOrConstructTrapNameRegistry[length]) != null\n                                ? _arityToApplyOrConstr\n                                : arityToApplyOrConstructTrapNameRegistry.n](shadowTarget, thisArgOrArgs, argsOrNewTarget);\n                        }\n                        let activity;\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity = startActivity(activityName);\n                        } // @ts-ignore: Prevent private property access error.\n                        const { foreignTargetPointer: foreignTargetPointer1 } = this;\n                        const thisArgOrNewTarget = isApplyTrap ? thisArgOrArgs : argsOrNewTarget;\n                        let pointerOrPrimitive;\n                        try {\n                            pointerOrPrimitive = foreignCallableApplyOrConstruct(foreignTargetPointer1, (typeof thisArgOrNewTarget === 'object' && thisArgOrNewTarget !== null) ||\n                                typeof thisArgOrNewTarget === 'function'\n                                ? getTransferablePointer(thisArgOrNewTarget) // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                                : // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                                    typeof thisArgOrNewTarget === 'undefined'\n                                        ? undefined\n                                        : thisArgOrNewTarget);\n                        }\n                        catch (error) {\n                            var _selectedTarget3;\n                            const errorToThrow = (_selectedTarget3 = selectedTarget) != null ? _selectedTarget3 : error;\n                            selectedTarget = undefined;\n                            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                                activity.error(errorToThrow);\n                            }\n                            throw errorToThrow;\n                        }\n                        let result;\n                        if (typeof pointerOrPrimitive === 'function') {\n                            pointerOrPrimitive();\n                            result = selectedTarget;\n                            selectedTarget = undefined;\n                        }\n                        else {\n                            result = pointerOrPrimitive;\n                        }\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity.stop();\n                        }\n                        return result;\n                    };\n                }\n                function createApplyOrConstructTrapForOneOrMoreArgs(proxyTrapEnum) {\n                    const isApplyTrap = proxyTrapEnum & 1; /* ProxyHandlerTraps.Apply */\n                    const activityName = `Reflect.${isApplyTrap ? 'apply' : 'construct'}(1)`;\n                    const arityToApplyOrConstructTrapNameRegistry = isApplyTrap\n                        ? arityToApplyTrapNameRegistry\n                        : arityToConstructTrapNameRegistry;\n                    const foreignCallableApplyOrConstruct = isApplyTrap\n                        ? foreignCallableApply\n                        : foreignCallableConstruct;\n                    return function applyOrConstructTrapForOneOrMoreArgs(shadowTarget, thisArgOrArgs, argsOrNewTarget) {\n                        lastProxyTrapCalled = proxyTrapEnum;\n                        const args = isApplyTrap ? argsOrNewTarget : thisArgOrArgs;\n                        const { length } = args;\n                        if (length !== 1) {\n                            var _arityToApplyOrConstr2;\n                            return this[(_arityToApplyOrConstr2 = arityToApplyOrConstructTrapNameRegistry[length]) != null\n                                ? _arityToApplyOrConstr2\n                                : arityToApplyOrConstructTrapNameRegistry.n](shadowTarget, thisArgOrArgs, argsOrNewTarget);\n                        }\n                        let activity;\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity = startActivity(activityName);\n                        } // @ts-ignore: Prevent private property access error.\n                        const { foreignTargetPointer: foreignTargetPointer1 } = this;\n                        const thisArgOrNewTarget = isApplyTrap ? thisArgOrArgs : argsOrNewTarget;\n                        let pointerOrPrimitive;\n                        try {\n                            const { 0: arg0 } = args;\n                            pointerOrPrimitive = foreignCallableApplyOrConstruct(foreignTargetPointer1, (typeof thisArgOrNewTarget === 'object' && thisArgOrNewTarget !== null) ||\n                                typeof thisArgOrNewTarget === 'function'\n                                ? getTransferablePointer(thisArgOrNewTarget) // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                                : // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                                    typeof thisArgOrNewTarget === 'undefined'\n                                        ? undefined\n                                        : thisArgOrNewTarget, (typeof arg0 === 'object' && arg0 !== null) || typeof arg0 === 'function'\n                                ? getTransferablePointer(arg0) // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                                : // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                                    typeof arg0 === 'undefined'\n                                        ? undefined\n                                        : arg0);\n                        }\n                        catch (error) {\n                            var _selectedTarget4;\n                            const errorToThrow = (_selectedTarget4 = selectedTarget) != null ? _selectedTarget4 : error;\n                            selectedTarget = undefined;\n                            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                                activity.error(errorToThrow);\n                            }\n                            throw errorToThrow;\n                        }\n                        let result;\n                        if (typeof pointerOrPrimitive === 'function') {\n                            pointerOrPrimitive();\n                            result = selectedTarget;\n                            selectedTarget = undefined;\n                        }\n                        else {\n                            result = pointerOrPrimitive;\n                        }\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity.stop();\n                        }\n                        return result;\n                    };\n                }\n                function createApplyOrConstructTrapForTwoOrMoreArgs(proxyTrapEnum) {\n                    const isApplyTrap = proxyTrapEnum & 1; /* ProxyHandlerTraps.Apply */\n                    const activityName = `Reflect.${isApplyTrap ? 'apply' : 'construct'}(2)`;\n                    const arityToApplyOrConstructTrapNameRegistry = isApplyTrap\n                        ? arityToApplyTrapNameRegistry\n                        : arityToConstructTrapNameRegistry;\n                    const foreignCallableApplyOrConstruct = isApplyTrap\n                        ? foreignCallableApply\n                        : foreignCallableConstruct;\n                    return function applyOrConstructTrapForTwoOrMoreArgs(shadowTarget, thisArgOrArgs, argsOrNewTarget) {\n                        lastProxyTrapCalled = proxyTrapEnum;\n                        const args = isApplyTrap ? argsOrNewTarget : thisArgOrArgs;\n                        const { length } = args;\n                        if (length !== 2) {\n                            var _arityToApplyOrConstr3;\n                            return this[(_arityToApplyOrConstr3 = arityToApplyOrConstructTrapNameRegistry[length]) != null\n                                ? _arityToApplyOrConstr3\n                                : arityToApplyOrConstructTrapNameRegistry.n](shadowTarget, thisArgOrArgs, argsOrNewTarget);\n                        }\n                        let activity;\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity = startActivity(activityName);\n                        } // @ts-ignore: Prevent private property access error.\n                        const { foreignTargetPointer: foreignTargetPointer1 } = this;\n                        const thisArgOrNewTarget = isApplyTrap ? thisArgOrArgs : argsOrNewTarget;\n                        let pointerOrPrimitive;\n                        try {\n                            const { 0: arg0, 1: arg1 } = args;\n                            pointerOrPrimitive = foreignCallableApplyOrConstruct(foreignTargetPointer1, (typeof thisArgOrNewTarget === 'object' && thisArgOrNewTarget !== null) ||\n                                typeof thisArgOrNewTarget === 'function'\n                                ? getTransferablePointer(thisArgOrNewTarget) // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                                : // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                                    typeof thisArgOrNewTarget === 'undefined'\n                                        ? undefined\n                                        : thisArgOrNewTarget, (typeof arg0 === 'object' && arg0 !== null) || typeof arg0 === 'function'\n                                ? getTransferablePointer(arg0) // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                                : // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                                    typeof arg0 === 'undefined'\n                                        ? undefined\n                                        : arg0, (typeof arg1 === 'object' && arg1 !== null) || typeof arg1 === 'function'\n                                ? getTransferablePointer(arg1) // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                                : // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                                    typeof arg1 === 'undefined'\n                                        ? undefined\n                                        : arg1);\n                        }\n                        catch (error) {\n                            var _selectedTarget5;\n                            const errorToThrow = (_selectedTarget5 = selectedTarget) != null ? _selectedTarget5 : error;\n                            selectedTarget = undefined;\n                            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                                activity.error(errorToThrow);\n                            }\n                            throw errorToThrow;\n                        }\n                        let result;\n                        if (typeof pointerOrPrimitive === 'function') {\n                            pointerOrPrimitive();\n                            result = selectedTarget;\n                            selectedTarget = undefined;\n                        }\n                        else {\n                            result = pointerOrPrimitive;\n                        }\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity.stop();\n                        }\n                        return result;\n                    };\n                }\n                function createApplyOrConstructTrapForThreeOrMoreArgs(proxyTrapEnum) {\n                    const isApplyTrap = proxyTrapEnum & 1; /* ProxyHandlerTraps.Apply */\n                    const activityName = `Reflect.${isApplyTrap ? 'apply' : 'construct'}(3)`;\n                    const arityToApplyOrConstructTrapNameRegistry = isApplyTrap\n                        ? arityToApplyTrapNameRegistry\n                        : arityToConstructTrapNameRegistry;\n                    const foreignCallableApplyOrConstruct = isApplyTrap\n                        ? foreignCallableApply\n                        : foreignCallableConstruct;\n                    return function applyOrConstructTrapForTwoOrMoreArgs(shadowTarget, thisArgOrArgs, argsOrNewTarget) {\n                        lastProxyTrapCalled = proxyTrapEnum;\n                        const args = isApplyTrap ? argsOrNewTarget : thisArgOrArgs;\n                        const { length } = args;\n                        if (length !== 3) {\n                            var _arityToApplyOrConstr4;\n                            return this[(_arityToApplyOrConstr4 = arityToApplyOrConstructTrapNameRegistry[length]) != null\n                                ? _arityToApplyOrConstr4\n                                : arityToApplyOrConstructTrapNameRegistry.n](shadowTarget, thisArgOrArgs, argsOrNewTarget);\n                        }\n                        let activity;\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity = startActivity(activityName);\n                        } // @ts-ignore: Prevent private property access error.\n                        const { foreignTargetPointer: foreignTargetPointer1 } = this;\n                        const thisArgOrNewTarget = isApplyTrap ? thisArgOrArgs : argsOrNewTarget;\n                        let pointerOrPrimitive;\n                        try {\n                            const { 0: arg0, 1: arg1, 2: arg2 } = args;\n                            pointerOrPrimitive = foreignCallableApplyOrConstruct(foreignTargetPointer1, (typeof thisArgOrNewTarget === 'object' && thisArgOrNewTarget !== null) ||\n                                typeof thisArgOrNewTarget === 'function'\n                                ? getTransferablePointer(thisArgOrNewTarget) // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                                : // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                                    typeof thisArgOrNewTarget === 'undefined'\n                                        ? undefined\n                                        : thisArgOrNewTarget, (typeof arg0 === 'object' && arg0 !== null) || typeof arg0 === 'function'\n                                ? getTransferablePointer(arg0) // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                                : // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                                    typeof arg0 === 'undefined'\n                                        ? undefined\n                                        : arg0, (typeof arg1 === 'object' && arg1 !== null) || typeof arg1 === 'function'\n                                ? getTransferablePointer(arg1) // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                                : // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                                    typeof arg1 === 'undefined'\n                                        ? undefined\n                                        : arg1, (typeof arg2 === 'object' && arg2 !== null) || typeof arg2 === 'function'\n                                ? getTransferablePointer(arg2) // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                                : // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                                    typeof arg2 === 'undefined'\n                                        ? undefined\n                                        : arg2);\n                        }\n                        catch (error) {\n                            var _selectedTarget6;\n                            const errorToThrow = (_selectedTarget6 = selectedTarget) != null ? _selectedTarget6 : error;\n                            selectedTarget = undefined;\n                            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                                activity.error(errorToThrow);\n                            }\n                            throw errorToThrow;\n                        }\n                        let result;\n                        if (typeof pointerOrPrimitive === 'function') {\n                            pointerOrPrimitive();\n                            result = selectedTarget;\n                            selectedTarget = undefined;\n                        }\n                        else {\n                            result = pointerOrPrimitive;\n                        }\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity.stop();\n                        }\n                        return result;\n                    };\n                }\n                function createApplyOrConstructTrapForFourOrMoreArgs(proxyTrapEnum) {\n                    const isApplyTrap = proxyTrapEnum & 1; /* ProxyHandlerTraps.Apply */\n                    const activityName = `Reflect.${isApplyTrap ? 'apply' : 'construct'}(4)`;\n                    const arityToApplyOrConstructTrapNameRegistry = isApplyTrap\n                        ? arityToApplyTrapNameRegistry\n                        : arityToConstructTrapNameRegistry;\n                    const foreignCallableApplyOrConstruct = isApplyTrap\n                        ? foreignCallableApply\n                        : foreignCallableConstruct;\n                    return function applyOrConstructTrapForTwoOrMoreArgs(shadowTarget, thisArgOrArgs, argsOrNewTarget) {\n                        lastProxyTrapCalled = proxyTrapEnum;\n                        const args = isApplyTrap ? argsOrNewTarget : thisArgOrArgs;\n                        const { length } = args;\n                        if (length !== 4) {\n                            var _arityToApplyOrConstr5;\n                            return this[(_arityToApplyOrConstr5 = arityToApplyOrConstructTrapNameRegistry[length]) != null\n                                ? _arityToApplyOrConstr5\n                                : arityToApplyOrConstructTrapNameRegistry.n](shadowTarget, thisArgOrArgs, argsOrNewTarget);\n                        }\n                        let activity;\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity = startActivity(activityName);\n                        } // @ts-ignore: Prevent private property access error.\n                        const { foreignTargetPointer: foreignTargetPointer1 } = this;\n                        const thisArgOrNewTarget = isApplyTrap ? thisArgOrArgs : argsOrNewTarget;\n                        let pointerOrPrimitive;\n                        try {\n                            const { 0: arg0, 1: arg1, 2: arg2, 3: arg3 } = args;\n                            pointerOrPrimitive = foreignCallableApplyOrConstruct(foreignTargetPointer1, (typeof thisArgOrNewTarget === 'object' && thisArgOrNewTarget !== null) ||\n                                typeof thisArgOrNewTarget === 'function'\n                                ? getTransferablePointer(thisArgOrNewTarget) // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                                : // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                                    typeof thisArgOrNewTarget === 'undefined'\n                                        ? undefined\n                                        : thisArgOrNewTarget, (typeof arg0 === 'object' && arg0 !== null) || typeof arg0 === 'function'\n                                ? getTransferablePointer(arg0) // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                                : // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                                    typeof arg0 === 'undefined'\n                                        ? undefined\n                                        : arg0, (typeof arg1 === 'object' && arg1 !== null) || typeof arg1 === 'function'\n                                ? getTransferablePointer(arg1) // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                                : // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                                    typeof arg1 === 'undefined'\n                                        ? undefined\n                                        : arg1, (typeof arg2 === 'object' && arg2 !== null) || typeof arg2 === 'function'\n                                ? getTransferablePointer(arg2) // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                                : // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                                    typeof arg2 === 'undefined'\n                                        ? undefined\n                                        : arg2, (typeof arg3 === 'object' && arg3 !== null) || typeof arg3 === 'function'\n                                ? getTransferablePointer(arg3) // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                                : // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                                    typeof arg3 === 'undefined'\n                                        ? undefined\n                                        : arg3);\n                        }\n                        catch (error) {\n                            var _selectedTarget7;\n                            const errorToThrow = (_selectedTarget7 = selectedTarget) != null ? _selectedTarget7 : error;\n                            selectedTarget = undefined;\n                            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                                activity.error(errorToThrow);\n                            }\n                            throw errorToThrow;\n                        }\n                        let result;\n                        if (typeof pointerOrPrimitive === 'function') {\n                            pointerOrPrimitive();\n                            result = selectedTarget;\n                            selectedTarget = undefined;\n                        }\n                        else {\n                            result = pointerOrPrimitive;\n                        }\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity.stop();\n                        }\n                        return result;\n                    };\n                }\n                function createApplyOrConstructTrapForFiveOrMoreArgs(proxyTrapEnum) {\n                    const isApplyTrap = proxyTrapEnum & 1; /* ProxyHandlerTraps.Apply */\n                    const activityName = `Reflect.${isApplyTrap ? 'apply' : 'construct'}(5)`;\n                    const arityToApplyOrConstructTrapNameRegistry = isApplyTrap\n                        ? arityToApplyTrapNameRegistry\n                        : arityToConstructTrapNameRegistry;\n                    const foreignCallableApplyOrConstruct = isApplyTrap\n                        ? foreignCallableApply\n                        : foreignCallableConstruct;\n                    return function applyOrConstructTrapForTwoOrMoreArgs(shadowTarget, thisArgOrArgs, argsOrNewTarget) {\n                        lastProxyTrapCalled = proxyTrapEnum;\n                        const args = isApplyTrap ? argsOrNewTarget : thisArgOrArgs;\n                        const { length } = args;\n                        if (length !== 5) {\n                            var _arityToApplyOrConstr6;\n                            return this[(_arityToApplyOrConstr6 = arityToApplyOrConstructTrapNameRegistry[length]) != null\n                                ? _arityToApplyOrConstr6\n                                : arityToApplyOrConstructTrapNameRegistry.n](shadowTarget, thisArgOrArgs, argsOrNewTarget);\n                        }\n                        let activity;\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity = startActivity(activityName);\n                        } // @ts-ignore: Prevent private property access error.\n                        const { foreignTargetPointer: foreignTargetPointer1 } = this;\n                        const thisArgOrNewTarget = isApplyTrap ? thisArgOrArgs : argsOrNewTarget;\n                        let pointerOrPrimitive;\n                        try {\n                            const { 0: arg0, 1: arg1, 2: arg2, 3: arg3, 4: arg4 } = args;\n                            pointerOrPrimitive = foreignCallableApplyOrConstruct(foreignTargetPointer1, (typeof thisArgOrNewTarget === 'object' && thisArgOrNewTarget !== null) ||\n                                typeof thisArgOrNewTarget === 'function'\n                                ? getTransferablePointer(thisArgOrNewTarget) // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                                : // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                                    typeof thisArgOrNewTarget === 'undefined'\n                                        ? undefined\n                                        : thisArgOrNewTarget, (typeof arg0 === 'object' && arg0 !== null) || typeof arg0 === 'function'\n                                ? getTransferablePointer(arg0) // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                                : // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                                    typeof arg0 === 'undefined'\n                                        ? undefined\n                                        : arg0, (typeof arg1 === 'object' && arg1 !== null) || typeof arg1 === 'function'\n                                ? getTransferablePointer(arg1) // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                                : // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                                    typeof arg1 === 'undefined'\n                                        ? undefined\n                                        : arg1, (typeof arg2 === 'object' && arg2 !== null) || typeof arg2 === 'function'\n                                ? getTransferablePointer(arg2) // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                                : // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                                    typeof arg2 === 'undefined'\n                                        ? undefined\n                                        : arg2, (typeof arg3 === 'object' && arg3 !== null) || typeof arg3 === 'function'\n                                ? getTransferablePointer(arg3) // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                                : // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                                    typeof arg3 === 'undefined'\n                                        ? undefined\n                                        : arg3, (typeof arg4 === 'object' && arg4 !== null) || typeof arg4 === 'function'\n                                ? getTransferablePointer(arg4) // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                                : // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                                    typeof arg4 === 'undefined'\n                                        ? undefined\n                                        : arg4);\n                        }\n                        catch (error) {\n                            var _selectedTarget8;\n                            const errorToThrow = (_selectedTarget8 = selectedTarget) != null ? _selectedTarget8 : error;\n                            selectedTarget = undefined;\n                            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                                activity.error(errorToThrow);\n                            }\n                            throw errorToThrow;\n                        }\n                        let result;\n                        if (typeof pointerOrPrimitive === 'function') {\n                            pointerOrPrimitive();\n                            result = selectedTarget;\n                            selectedTarget = undefined;\n                        }\n                        else {\n                            result = pointerOrPrimitive;\n                        }\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity.stop();\n                        }\n                        return result;\n                    };\n                }\n                function createApplyOrConstructTrapForAnyNumberOfArgs(proxyTrapEnum) {\n                    const isApplyTrap = proxyTrapEnum & 1; /* ProxyHandlerTraps.Apply */\n                    const nativeMethodName = isApplyTrap ? 'apply' : 'construct';\n                    const foreignCallableApplyOrConstruct = isApplyTrap\n                        ? foreignCallableApply\n                        : foreignCallableConstruct;\n                    return function applyOrConstructTrapForAnyNumberOfArgs(_shadowTarget, thisArgOrArgs, argsOrNewTarget) {\n                        lastProxyTrapCalled = proxyTrapEnum; // @ts-ignore: Prevent private property access error.\n                        const { foreignTargetPointer: foreignTargetPointer1 } = this;\n                        const args = isApplyTrap ? argsOrNewTarget : thisArgOrArgs;\n                        const { length } = args;\n                        let activity;\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity = startActivity(`Reflect.${nativeMethodName}(${length})`);\n                        }\n                        const thisArgOrNewTarget = isApplyTrap ? thisArgOrArgs : argsOrNewTarget;\n                        let combinedOffset = 2;\n                        const combinedArgs = new ArrayCtor(length + combinedOffset);\n                        combinedArgs[0] = foreignTargetPointer1;\n                        let pointerOrPrimitive;\n                        try {\n                            combinedArgs[1] =\n                                (typeof thisArgOrNewTarget === 'object' && thisArgOrNewTarget !== null) ||\n                                    typeof thisArgOrNewTarget === 'function'\n                                    ? getTransferablePointer(thisArgOrNewTarget) // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                                    : // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                                        typeof thisArgOrNewTarget === 'undefined'\n                                            ? undefined\n                                            : thisArgOrNewTarget;\n                            for (let i = 0; i < length; i += 1) {\n                                const arg = args[i]; // Inlining `getTransferableValue()`.\n                                combinedArgs[combinedOffset++] =\n                                    (typeof arg === 'object' && arg !== null) || typeof arg === 'function'\n                                        ? getTransferablePointer(arg) // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                                        : // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                                            typeof arg === 'undefined'\n                                                ? undefined\n                                                : arg;\n                            }\n                            pointerOrPrimitive = ReflectApply(foreignCallableApplyOrConstruct, undefined, combinedArgs);\n                        }\n                        catch (error) {\n                            var _selectedTarget9;\n                            const errorToThrow = (_selectedTarget9 = selectedTarget) != null ? _selectedTarget9 : error;\n                            selectedTarget = undefined;\n                            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                                activity.error(errorToThrow);\n                            }\n                            throw errorToThrow;\n                        }\n                        let result;\n                        if (typeof pointerOrPrimitive === 'function') {\n                            pointerOrPrimitive();\n                            result = selectedTarget;\n                            selectedTarget = undefined;\n                        }\n                        else {\n                            result = pointerOrPrimitive;\n                        }\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity.stop();\n                        }\n                        return result;\n                    };\n                }\n                function createDescriptorFromMeta(configurable, enumerable, writable, valuePointerOrPrimitive, getterPointerOrPrimitive, setterPointerOrPrimitive) {\n                    const safeDesc = {\n                        __proto__: null,\n                    };\n                    if (configurable !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL) {\n                        safeDesc.configurable = configurable;\n                    }\n                    if (enumerable !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL) {\n                        safeDesc.enumerable = enumerable;\n                    }\n                    if (writable !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL) {\n                        safeDesc.writable = writable;\n                    }\n                    if (getterPointerOrPrimitive !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL) {\n                        if (typeof getterPointerOrPrimitive === 'function') {\n                            getterPointerOrPrimitive();\n                            safeDesc.get = selectedTarget;\n                            selectedTarget = undefined;\n                        }\n                        else {\n                            safeDesc.get = undefined;\n                        }\n                    }\n                    if (setterPointerOrPrimitive !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL) {\n                        if (typeof setterPointerOrPrimitive === 'function') {\n                            setterPointerOrPrimitive();\n                            safeDesc.set = selectedTarget;\n                            selectedTarget = undefined;\n                        }\n                        else {\n                            safeDesc.set = undefined;\n                        }\n                    }\n                    if (valuePointerOrPrimitive !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL) {\n                        if (typeof valuePointerOrPrimitive === 'function') {\n                            valuePointerOrPrimitive();\n                            safeDesc.value = selectedTarget;\n                            selectedTarget = undefined;\n                        }\n                        else {\n                            safeDesc.value = valuePointerOrPrimitive;\n                        }\n                    }\n                    return safeDesc;\n                }\n                function createPointer(originalTarget) {\n                    const pointer = () => {\n                        // assert: selectedTarget is undefined\n                        selectedTarget = originalTarget;\n                    };\n                    __.debugTargetBookkeeping?.(pointer, originalTarget);\n                    return pointer;\n                }\n                const disableFastForeignTargetPointers = IS_IN_SHADOW_REALM\n                    ? () => {\n                        useFastForeignTargetPath = false;\n                        useFastForeignTargetPathForTypedArrays = false;\n                        clearFastForeignTargetPointers();\n                    }\n                    : noop;\n                const getLazyPropertyDescriptorStateByTarget = IS_IN_SHADOW_REALM\n                    ? (target) => {\n                        let state = localProxyTargetToLazyPropertyDescriptorStateMap.get(target);\n                        if (state === undefined) {\n                            const statePointerOrUndefined = foreignCallableGetLazyPropertyDescriptorStateByTarget(getTransferablePointer(target));\n                            if (typeof statePointerOrUndefined === 'function') {\n                                statePointerOrUndefined();\n                                state = selectedTarget;\n                                selectedTarget = undefined;\n                                if (state) {\n                                    localProxyTargetToLazyPropertyDescriptorStateMap.set(target, state);\n                                }\n                            }\n                        }\n                        return state;\n                    }\n                    : noop;\n                const isForeignPointerOfObjectProto = IS_IN_SHADOW_REALM\n                    ? (foreignTargetPointer) => foreignTargetPointer ===\n                        (foreignPointerObjectProto === undefined\n                            ? (foreignPointerObjectProto = getTransferablePointer(ObjectProto))\n                            : foreignPointerObjectProto)\n                    : alwaysFalse;\n                const isForeignPointerOfTypedArrayProto = IS_IN_SHADOW_REALM\n                    ? (foreignTargetPointer) => foreignTargetPointer ===\n                        (foreignPointerFloat32ArrayProto === undefined\n                            ? (foreignPointerFloat32ArrayProto = getTransferablePointer(Float32ArrayProto))\n                            : foreignPointerFloat32ArrayProto) ||\n                        foreignTargetPointer ===\n                            (foreignPointerFloat64ArrayProto === undefined\n                                ? (foreignPointerFloat64ArrayProto = getTransferablePointer(Float64ArrayProto))\n                                : foreignPointerFloat64ArrayProto) ||\n                        foreignTargetPointer ===\n                            (foreignPointerInt8ArrayProto === undefined\n                                ? (foreignPointerInt8ArrayProto = getTransferablePointer(Int8ArrayProto))\n                                : foreignPointerInt8ArrayProto) ||\n                        foreignTargetPointer ===\n                            (foreignPointerInt16ArrayProto === undefined\n                                ? (foreignPointerInt16ArrayProto = getTransferablePointer(Int16ArrayProto))\n                                : foreignPointerInt16ArrayProto) ||\n                        foreignTargetPointer ===\n                            (foreignPointerInt32ArrayProto === undefined\n                                ? (foreignPointerInt32ArrayProto = getTransferablePointer(Int32ArrayProto))\n                                : foreignPointerInt32ArrayProto) ||\n                        foreignTargetPointer ===\n                            (foreignPointerUint8ArrayProto === undefined\n                                ? (foreignPointerUint8ArrayProto = getTransferablePointer(Uint8ArrayProto))\n                                : foreignPointerUint8ArrayProto) ||\n                        foreignTargetPointer ===\n                            (foreignPointerUint16ArrayProto === undefined\n                                ? (foreignPointerUint16ArrayProto = getTransferablePointer(Uint16ArrayProto))\n                                : foreignPointerUint16ArrayProto) ||\n                        foreignTargetPointer ===\n                            (foreignPointerUint32ArrayProto === undefined\n                                ? (foreignPointerUint32ArrayProto = getTransferablePointer(Uint32ArrayProto))\n                                : foreignPointerUint32ArrayProto) ||\n                        foreignTargetPointer ===\n                            (foreignPointerTypedArrayProto === undefined\n                                ? (foreignPointerTypedArrayProto = getTransferablePointer(TypedArrayProto))\n                                : foreignPointerTypedArrayProto) ||\n                        foreignTargetPointer ===\n                            (foreignPointerBigInt64ArrayProto === undefined\n                                ? (foreignPointerBigInt64ArrayProto = BigInt64ArrayProto\n                                    ? getTransferablePointer(BigInt64ArrayProto)\n                                    : noop)\n                                : foreignPointerBigInt64ArrayProto) ||\n                        foreignTargetPointer ===\n                            (foreignPointerBigUint64ArrayProto === undefined\n                                ? (foreignPointerBigUint64ArrayProto = BigUint64ArrayProto\n                                    ? getTransferablePointer(BigUint64ArrayProto)\n                                    : noop)\n                                : foreignPointerBigUint64ArrayProto)\n                    : alwaysFalse;\n                function getTransferablePointer(originalTarget, foreignCallablePusher = foreignCallablePushTarget) {\n                    let proxyPointer = proxyTargetToPointerMap.get(originalTarget);\n                    if (proxyPointer) {\n                        return proxyPointer;\n                    }\n                    let distortionTarget;\n                    if (distortionCallback) {\n                        distortionTarget = distortionCallback(originalTarget); // If a distortion entry is found, it must be a valid proxy target.\n                        if (distortionTarget !== originalTarget && typeof distortionTarget !== typeof originalTarget) {\n                            throw new TypeErrorCtor(`Invalid distortion ${toSafeTemplateStringValue(originalTarget)}.`);\n                        }\n                    }\n                    else {\n                        distortionTarget = originalTarget;\n                    }\n                    let isPossiblyRevoked = true;\n                    let targetFunctionArity = 0;\n                    let targetFunctionName = '';\n                    let targetTypedArrayLength = 0;\n                    let targetTraits = 16; /* TargetTraits.IsObject */\n                    if (typeof distortionTarget === 'function') {\n                        isPossiblyRevoked = false;\n                        targetFunctionArity = 0;\n                        targetTraits = 4; /* TargetTraits.IsFunction */\n                        try {\n                            // Detect arrow functions.\n                            if (!('prototype' in distortionTarget)) {\n                                targetTraits |= 8; /* TargetTraits.IsArrowFunction */\n                            }\n                            const safeLengthDesc = ReflectGetOwnPropertyDescriptor(originalTarget, 'length');\n                            if (safeLengthDesc) {\n                                ReflectSetPrototypeOf(safeLengthDesc, null);\n                                const { value: safeLengthDescValue } = safeLengthDesc;\n                                if (typeof safeLengthDescValue === 'number') {\n                                    targetFunctionArity = safeLengthDescValue;\n                                }\n                            }\n                            const safeNameDesc = false\n                                ? ReflectGetOwnPropertyDescriptor(originalTarget, 'name')\n                                : undefined;\n                            if (safeNameDesc)\n                                ;\n                        }\n                        catch (_unused16) {\n                            isPossiblyRevoked = true;\n                        }\n                    }\n                    else if (ArrayBufferIsView(distortionTarget)) {\n                        isPossiblyRevoked = false;\n                        targetTraits = 2; /* TargetTraits.IsArrayBufferView */\n                        try {\n                            targetTypedArrayLength = ReflectApply(TypedArrayProtoLengthGetter, distortionTarget, []);\n                            targetTraits |= 32; /* TargetTraits.IsTypedArray */ // eslint-disable-next-line no-empty\n                        }\n                        catch (_unused17) {\n                            // Could be a DataView object or a revoked proxy.\n                            isPossiblyRevoked = true;\n                        }\n                    }\n                    if (isPossiblyRevoked) {\n                        try {\n                            if (isArrayOrThrowForRevoked(distortionTarget)) {\n                                targetTraits = 1; /* TargetTraits.IsArray */\n                            }\n                        }\n                        catch (_unused18) {\n                            targetTraits = 64; /* TargetTraits.Revoked */\n                        }\n                    }\n                    proxyPointer = foreignCallablePusher(createPointer(distortionTarget), targetTraits, targetFunctionArity, targetFunctionName, targetTypedArrayLength); // The WeakMap is populated with the original target rather then the\n                    // distorted one while the pointer always uses the distorted one.\n                    // TODO: This mechanism poses another issue, which is that the return\n                    // value of selectedTarget! can never be used to call across the\n                    // membrane because that will cause a wrapping around the potential\n                    // distorted value instead of the original value. This is not fatal,\n                    // but implies that for every distorted value where are two proxies\n                    // that are not ===, which is weird. Guaranteeing this is not easy\n                    // because it means auditing the code.\n                    proxyTargetToPointerMap.set(originalTarget, proxyPointer);\n                    return proxyPointer;\n                }\n                const installPropertyDescriptorMethodWrappers = IS_IN_SHADOW_REALM\n                    ? (unforgeableGlobalThisKeys) => {\n                        if (installedPropertyDescriptorMethodWrappersFlag) {\n                            return;\n                        }\n                        installedPropertyDescriptorMethodWrappersFlag = true; // We wrap property descriptor methods to activate lazy\n                        // descriptors and/or workaround browser bugs. The following\n                        // methods are wrapped:\n                        //   Object.getOwnPropertyDescriptors()\n                        //   Object.getOwnPropertyDescriptor()\n                        //   Reflect.defineProperty()\n                        //   Reflect.getOwnPropertyDescriptor()\n                        //   Object.prototype.__defineGetter__()\n                        //   Object.prototype.__defineSetter__()\n                        //   Object.prototype.__lookupGetter__()\n                        //   Object.prototype.__lookupSetter__()\n                        //\n                        // Chromium based browsers have a bug that nulls the result\n                        // of `window` getters in detached iframes when the property\n                        // descriptor of `window.window` is retrieved.\n                        // https://bugs.chromium.org/p/chromium/issues/detail?id=1305302\n                        //\n                        // Methods may be poisoned when they interact with the `window`\n                        // object and retrieve property descriptors, like 'window',\n                        // that contain the `window` object itself. The following\n                        // built-in methods are susceptible to this issue:\n                        //     console.log(window);\n                        //     Object.getOwnPropertyDescriptors(window);\n                        //     Object.getOwnPropertyDescriptor(window, 'window');\n                        //     Reflect.getOwnPropertyDescriptor(window, 'window');\n                        //     window.__lookupGetter__('window');\n                        //     window.__lookupSetter__('window');\n                        //\n                        // We side step issues with `console` by mapping it to the\n                        // primary realm's `console`. Since we're already wrapping\n                        // property descriptor methods to activate lazy descriptors\n                        // we use the wrapper to workaround the `window` getter\n                        // nulling bug.\n                        const shouldFixChromeBug = isArrayOrThrowForRevoked(unforgeableGlobalThisKeys) &&\n                            unforgeableGlobalThisKeys.length > 0; // Lazily populated by `getUnforgeableGlobalThisGetter()`;\n                        const keyToGlobalThisGetterRegistry = shouldFixChromeBug\n                            ? {\n                                __proto__: null,\n                            }\n                            : undefined;\n                        const getFixedDescriptor = shouldFixChromeBug\n                            ? (target, key) => ReflectApply(ArrayProtoIncludes, unforgeableGlobalThisKeys, [key])\n                                ? {\n                                    configurable: false,\n                                    enumerable: ReflectApply(ObjectProtoPropertyIsEnumerable, target, [key]),\n                                    get: getUnforgeableGlobalThisGetter(key),\n                                    set: undefined,\n                                }\n                                : ReflectGetOwnPropertyDescriptor(target, key)\n                            : undefined;\n                        const getUnforgeableGlobalThisGetter = shouldFixChromeBug\n                            ? (key) => {\n                                let globalThisGetter = keyToGlobalThisGetterRegistry[key];\n                                if (globalThisGetter === undefined) {\n                                    // Wrap `unboundGlobalThisGetter` in bound function\n                                    // to obscure the getter source as \"[native code]\".\n                                    globalThisGetter = ReflectApply(FunctionProtoBind, unboundGlobalThisGetter, []); // Preserve identity continuity of getters.\n                                    keyToGlobalThisGetterRegistry[key] = globalThisGetter;\n                                }\n                                return globalThisGetter;\n                            }\n                            : undefined;\n                        const lookupFixedGetter = shouldFixChromeBug\n                            ? (target, key) => ReflectApply(ArrayProtoIncludes, unforgeableGlobalThisKeys, [key])\n                                ? getUnforgeableGlobalThisGetter(key)\n                                : ReflectApply(ObjectProtoLookupGetter, target, [key])\n                            : undefined;\n                        const lookupFixedSetter = shouldFixChromeBug\n                            ? (target, key) => ReflectApply(ArrayProtoIncludes, unforgeableGlobalThisKeys, [key])\n                                ? undefined\n                                : ReflectApply(ObjectProtoLookupSetter, target, [key])\n                            : undefined;\n                        const unboundGlobalThisGetter = shouldFixChromeBug ? () => globalThisRef : undefined;\n                        const wrapDefineAccessOrProperty = (originalFunc) => {\n                            const { length: originalFuncLength } = originalFunc; // `__defineGetter__()` and `__defineSetter__()` have\n                            // function lengths of 2 while `Reflect.defineProperty()`\n                            // has a function length of 3.\n                            const useThisArgAsTarget = originalFuncLength === 2;\n                            return new ProxyCtor(originalFunc, {\n                                apply(_originalFunc, thisArg, args) {\n                                    if (args.length >= originalFuncLength) {\n                                        const target = useThisArgAsTarget ? thisArg : args[0];\n                                        if ((typeof target === 'object' && target !== null) ||\n                                            typeof target === 'function') {\n                                            const key = useThisArgAsTarget ? args[0] : args[1];\n                                            const state = getLazyPropertyDescriptorStateByTarget(target);\n                                            if (state != null && state[key]) {\n                                                // Activate the descriptor by triggering\n                                                // its getter.\n                                                // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n                                                target[key];\n                                            }\n                                        }\n                                    }\n                                    return ReflectApply(originalFunc, thisArg, args);\n                                },\n                            });\n                        };\n                        const wrapLookupAccessor = (originalFunc, lookupFixedAccessor) => new ProxyCtor(originalFunc, {\n                            apply(_originalFunc, thisArg, args) {\n                                if (args.length &&\n                                    ((typeof thisArg === 'object' && thisArg !== null) ||\n                                        typeof thisArg === 'function')) {\n                                    const { 0: key } = args;\n                                    const state = getLazyPropertyDescriptorStateByTarget(thisArg);\n                                    if (state != null && state[key]) {\n                                        // Activate the descriptor by triggering\n                                        // its getter.\n                                        // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n                                        thisArg[key];\n                                    }\n                                    if (shouldFixChromeBug && thisArg === globalThisRef) {\n                                        return lookupFixedAccessor(thisArg, key);\n                                    }\n                                }\n                                return ReflectApply(originalFunc, thisArg, args);\n                            },\n                        });\n                        const wrapGetOwnPropertyDescriptor = (originalFunc) => new ProxyCtor(originalFunc, {\n                            apply(_originalFunc, thisArg, args) {\n                                if (args.length > 1) {\n                                    const { 0: target, 1: key } = args;\n                                    if ((typeof target === 'object' && target !== null) ||\n                                        typeof target === 'function') {\n                                        const state = getLazyPropertyDescriptorStateByTarget(target);\n                                        if (state != null && state[key]) {\n                                            // Activate the descriptor by triggering\n                                            // its getter.\n                                            // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n                                            target[key];\n                                        }\n                                        if (shouldFixChromeBug && target === globalThisRef) {\n                                            return getFixedDescriptor(target, key);\n                                        }\n                                    }\n                                }\n                                return ReflectApply(originalFunc, thisArg, args);\n                            },\n                        });\n                        const wrapGetOwnPropertyDescriptors = (originalFunc) => new ProxyCtor(originalFunc, {\n                            apply(_originalFunc, thisArg, args) {\n                                const target = args.length ? args[0] : undefined;\n                                if (!((typeof target === 'object' && target !== null) ||\n                                    typeof target === 'function')) {\n                                    // Defer to native method to throw exception.\n                                    return ReflectApply(originalFunc, thisArg, args);\n                                }\n                                const state = getLazyPropertyDescriptorStateByTarget(target);\n                                const isFixingChromeBug = target === globalThisRef && shouldFixChromeBug;\n                                const unsafeDescMap = isFixingChromeBug // to populate with curated descriptors.\n                                    ? {} // safe to use the native method.\n                                    : ReflectApply(originalFunc, thisArg, args);\n                                if (!isFixingChromeBug && state === undefined) {\n                                    // Exit early if the target is not a global\n                                    // object and there are no lazy descriptors.\n                                    return unsafeDescMap;\n                                }\n                                const ownKeys = ReflectOwnKeys(isFixingChromeBug ? target : unsafeDescMap);\n                                for (let i = 0, { length } = ownKeys; i < length; i += 1) {\n                                    const ownKey = ownKeys[i];\n                                    const isLazyProp = !!(state != null && state[ownKey]);\n                                    if (isLazyProp) {\n                                        // Activate the descriptor by triggering\n                                        // its getter.\n                                        // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n                                        target[ownKey];\n                                    }\n                                    if (isLazyProp || isFixingChromeBug) {\n                                        const unsafeDesc = isFixingChromeBug\n                                            ? getFixedDescriptor(target, ownKey)\n                                            : ReflectGetOwnPropertyDescriptor(target, ownKey); // Update the descriptor map entry.\n                                        if (unsafeDesc) {\n                                            unsafeDescMap[ownKey] = unsafeDesc;\n                                        }\n                                        else if (!isFixingChromeBug) {\n                                            ReflectDeleteProperty(unsafeDescMap, ownKey);\n                                        }\n                                    }\n                                }\n                                return unsafeDescMap;\n                            },\n                        });\n                        try {\n                            ReflectRef.defineProperty = wrapDefineAccessOrProperty(ReflectDefineProperty); // eslint-disable-next-line no-empty\n                        }\n                        catch (_unused19) { }\n                        try {\n                            ReflectRef.getOwnPropertyDescriptor = wrapGetOwnPropertyDescriptor(ReflectGetOwnPropertyDescriptor); // eslint-disable-next-line no-empty\n                        }\n                        catch (_unused20) { }\n                        try {\n                            ObjectCtor.getOwnPropertyDescriptor =\n                                wrapGetOwnPropertyDescriptor(ObjectGetOwnPropertyDescriptor); // eslint-disable-next-line no-empty\n                        }\n                        catch (_unused21) { }\n                        try {\n                            ObjectCtor.getOwnPropertyDescriptors = wrapGetOwnPropertyDescriptors(ObjectGetOwnPropertyDescriptors); // eslint-disable-next-line no-empty\n                        }\n                        catch (_unused22) { }\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/naming-convention, no-restricted-properties, no-underscore-dangle\n                            ObjectProto.__defineGetter__ = wrapDefineAccessOrProperty(ObjectProtoDefineGetter); // eslint-disable-next-line no-empty\n                        }\n                        catch (_unused23) { }\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/naming-convention, no-restricted-properties, no-underscore-dangle\n                            ObjectProto.__defineSetter__ = wrapDefineAccessOrProperty(ObjectProtoDefineSetter); // eslint-disable-next-line no-empty\n                        }\n                        catch (_unused24) { }\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/naming-convention, no-underscore-dangle\n                            ObjectProto.__lookupGetter__ = wrapLookupAccessor(ObjectProtoLookupGetter, lookupFixedGetter); // eslint-disable-next-line no-empty\n                        }\n                        catch (_unused25) { }\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/naming-convention, no-underscore-dangle\n                            ObjectProto.__lookupSetter__ = wrapLookupAccessor(ObjectProtoLookupSetter, lookupFixedSetter); // eslint-disable-next-line no-empty\n                        }\n                        catch (_unused26) { }\n                    }\n                    : noop;\n                function lookupForeignDescriptor(foreignTargetPointer, shadowTarget, key) {\n                    let activity;\n                    if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                        activity = startActivity('lookupForeignDescriptor');\n                    }\n                    let protoPointerOrNull;\n                    let safeDesc;\n                    try {\n                        protoPointerOrNull = foreignCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor(foreignTargetPointer, key, (_key, configurable, enumerable, writable, valuePointerOrPrimitive, getterPointerOrPrimitive, setterPointerOrPrimitive) => {\n                            safeDesc = {\n                                __proto__: null,\n                                foreign: true,\n                            };\n                            if (configurable !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL) {\n                                safeDesc.configurable = configurable;\n                            }\n                            if (enumerable !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL) {\n                                safeDesc.enumerable = enumerable;\n                            }\n                            if (writable !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL) {\n                                safeDesc.writable = writable;\n                            }\n                            if (getterPointerOrPrimitive !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL) {\n                                if (typeof getterPointerOrPrimitive === 'function') {\n                                    getterPointerOrPrimitive();\n                                    safeDesc.get = selectedTarget;\n                                    selectedTarget = undefined;\n                                }\n                                else {\n                                    safeDesc.get = undefined;\n                                }\n                            }\n                            if (setterPointerOrPrimitive !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL) {\n                                if (typeof setterPointerOrPrimitive === 'function') {\n                                    setterPointerOrPrimitive();\n                                    safeDesc.set = selectedTarget;\n                                    selectedTarget = undefined;\n                                }\n                                else {\n                                    safeDesc.set = undefined;\n                                }\n                            }\n                            if (valuePointerOrPrimitive !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL) {\n                                if (typeof valuePointerOrPrimitive === 'function') {\n                                    valuePointerOrPrimitive();\n                                    safeDesc.value = selectedTarget;\n                                    selectedTarget = undefined;\n                                }\n                                else {\n                                    safeDesc.value = valuePointerOrPrimitive;\n                                }\n                            }\n                            if (configurable === false) {\n                                // Update the descriptor to non-configurable on\n                                // the shadow target.\n                                ReflectDefineProperty(shadowTarget, key, safeDesc);\n                            }\n                        });\n                    }\n                    catch (error) {\n                        var _selectedTarget10;\n                        const errorToThrow = (_selectedTarget10 = selectedTarget) != null ? _selectedTarget10 : error;\n                        selectedTarget = undefined;\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity.error(errorToThrow);\n                        }\n                        throw errorToThrow;\n                    }\n                    if (safeDesc === undefined) {\n                        // Avoiding calling the has trap for any proto chain operation,\n                        // instead we implement the regular logic here in this trap.\n                        let currentObject;\n                        if (typeof protoPointerOrNull === 'function') {\n                            protoPointerOrNull();\n                            currentObject = selectedTarget;\n                            selectedTarget = undefined;\n                        }\n                        else {\n                            currentObject = null;\n                        }\n                        while (currentObject) {\n                            safeDesc = ReflectGetOwnPropertyDescriptor(currentObject, key);\n                            if (safeDesc) {\n                                ReflectSetPrototypeOf(safeDesc, null);\n                                break;\n                            }\n                            currentObject = ReflectGetPrototypeOf(currentObject);\n                        }\n                        if (safeDesc) {\n                            var _ref3;\n                            const { get: getter, set: setter, value: localValue } = safeDesc;\n                            const possibleProxy = (_ref3 = getter != null ? getter : setter) != null ? _ref3 : localValue;\n                            safeDesc.foreign =\n                                ((typeof possibleProxy === 'object' && possibleProxy !== null) ||\n                                    typeof possibleProxy === 'function') &&\n                                    proxyTargetToPointerMap.get(possibleProxy) !== undefined;\n                        }\n                    }\n                    if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                        activity.stop();\n                    }\n                    return safeDesc;\n                }\n                function passthruForeignTraversedSet(foreignTargetPointer, shadowTarget, key, value, receiver) {\n                    const safeDesc = lookupForeignDescriptor(foreignTargetPointer, shadowTarget, key); // Following the specification steps for\n                    // OrdinarySetWithOwnDescriptor ( O, P, V, Receiver, ownDesc ).\n                    // https://tc39.es/ecma262/#sec-ordinarysetwithowndescriptor\n                    if (safeDesc) {\n                        if ('get' in safeDesc || 'set' in safeDesc) {\n                            const { set: setter } = safeDesc;\n                            if (setter) {\n                                if (safeDesc.foreign) {\n                                    foreignCallableApply(getTransferablePointer(setter), (typeof receiver === 'object' && receiver !== null) ||\n                                        typeof receiver === 'function'\n                                        ? getTransferablePointer(receiver) // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                                        : // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                                            typeof receiver === 'undefined'\n                                                ? undefined\n                                                : receiver, (typeof value === 'object' && value !== null) || typeof value === 'function'\n                                        ? getTransferablePointer(value) // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                                        : // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                                            typeof value === 'undefined'\n                                                ? undefined\n                                                : value);\n                                }\n                                else {\n                                    // Even though the setter function exists, we can't\n                                    // use `ReflectSet()` because there might be a\n                                    // distortion for that setter function, in which\n                                    // case we must resolve the local setter and call\n                                    // it instead.\n                                    ReflectApply(setter, receiver, [value]);\n                                } // If there is a setter, it either throw or we can assume\n                                // the value was set.\n                                return true;\n                            }\n                            return false;\n                        }\n                        if (safeDesc.writable === false) {\n                            return false;\n                        }\n                    } // Exit early if receiver is not object like.\n                    if (!((typeof receiver === 'object' && receiver !== null) || typeof receiver === 'function')) {\n                        return false;\n                    }\n                    const safeReceiverDesc = ReflectGetOwnPropertyDescriptor(receiver, key);\n                    if (safeReceiverDesc) {\n                        ReflectSetPrototypeOf(safeReceiverDesc, null); // Exit early for accessor descriptors or non-writable data\n                        // descriptors.\n                        if ('get' in safeReceiverDesc ||\n                            'set' in safeReceiverDesc ||\n                            safeReceiverDesc.writable === false) {\n                            return false;\n                        } // Setting the descriptor with only a value entry should not\n                        // affect existing descriptor traits.\n                        ReflectDefineProperty(receiver, key, {\n                            __proto__: null,\n                            value,\n                        });\n                        return true;\n                    } // `ReflectDefineProperty()` and `ReflectSet()` both are expected\n                    // to return `false` when attempting to add a new property if the\n                    // receiver is not extensible.\n                    return ReflectDefineProperty(receiver, key, {\n                        __proto__: null,\n                        configurable: true,\n                        enumerable: true,\n                        value,\n                        writable: true,\n                    });\n                }\n                function pushErrorAcrossBoundary(error) {\n                    if (LOCKER_DEBUGGABLE_FLAG) {\n                        checkDebugMode();\n                    } // Inline getTransferableValue().\n                    if ((typeof error === 'object' && error !== null) || typeof error === 'function') {\n                        const foreignErrorPointer = getTransferablePointer(error, foreignCallablePushErrorTarget);\n                        foreignErrorPointer();\n                    }\n                    return error;\n                }\n                function pushTarget(foreignTargetPointer, foreignTargetTraits, foreignTargetFunctionArity, foreignTargetFunctionName, foreignTargetTypedArrayLength) {\n                    const { proxy } = new BoundaryProxyHandler(foreignTargetPointer, foreignTargetTraits, foreignTargetFunctionArity, foreignTargetFunctionName, foreignTargetTypedArrayLength);\n                    proxyTargetToPointerMap.set(proxy, foreignTargetPointer);\n                    return createPointer(proxy);\n                }\n                const setLazyPropertyDescriptorStateByTarget = IS_IN_SHADOW_REALM\n                    ? (target, state) => {\n                        localProxyTargetToLazyPropertyDescriptorStateMap.set(target, state);\n                        foreignCallableSetLazyPropertyDescriptorStateByTarget(getTransferablePointer(target), getTransferablePointer(state));\n                    }\n                    : noop;\n                class BoundaryProxyHandler {\n                    constructor(foreignTargetPointer, foreignTargetTraits, foreignTargetFunctionArity, foreignTargetFunctionName, foreignTargetTypedArrayLength) {\n                        let shadowTarget;\n                        const isForeignTargetArray = foreignTargetTraits & 1; /* TargetTraits.IsArray */\n                        const isForeignTargetFunction = foreignTargetTraits & 4; /* TargetTraits.IsFunction */\n                        if (isForeignTargetFunction) {\n                            // This shadow target is never invoked. It's needed to avoid\n                            // proxy trap invariants. Because it's not invoked the code\n                            // does not need to be instrumented for code coverage.\n                            //\n                            // istanbul ignore next\n                            shadowTarget = foreignTargetTraits & 8 ? () => { } : function () { };\n                        }\n                        else if (isForeignTargetArray) {\n                            shadowTarget = [];\n                        }\n                        else {\n                            shadowTarget = {};\n                        }\n                        const { proxy, revoke } = ProxyRevocable(shadowTarget, this);\n                        __.attachDebuggerTarget?.(proxy, foreignTargetPointer);\n                        this.foreignTargetPointer = foreignTargetPointer;\n                        this.foreignTargetTraits = foreignTargetTraits;\n                        this.foreignTargetTypedArrayLength = foreignTargetTypedArrayLength; // Define in the BoundaryProxyHandler constructor so it is bound\n                        // to the BoundaryProxyHandler instance.\n                        this.nonConfigurableDescriptorCallback = (key, configurable, enumerable, writable, valuePointer, getterPointer, setterPointer) => {\n                            // Update the descriptor to non-configurable on the shadow\n                            // target.\n                            ReflectDefineProperty(this.shadowTarget, key, createDescriptorFromMeta(configurable, enumerable, writable, valuePointer, getterPointer, setterPointer));\n                        };\n                        this.proxy = proxy;\n                        this.revoke = revoke;\n                        this.serializedValue = undefined;\n                        this.shadowTarget = shadowTarget;\n                        this.staticToStringTag = 'Object'; // Define traps.\n                        if (isForeignTargetFunction) {\n                            var _arityToApplyTrapName, _arityToConstructTrap;\n                            this.apply =\n                                this[(_arityToApplyTrapName =\n                                    arityToApplyTrapNameRegistry[foreignTargetFunctionArity]) != null\n                                    ? _arityToApplyTrapName\n                                    : arityToApplyTrapNameRegistry.n];\n                            this.construct =\n                                this[(_arityToConstructTrap =\n                                    arityToConstructTrapNameRegistry[foreignTargetFunctionArity]) != null\n                                    ? _arityToConstructTrap\n                                    : arityToConstructTrapNameRegistry.n];\n                        }\n                        this.defineProperty = BoundaryProxyHandler.defaultDefinePropertyTrap;\n                        this.deleteProperty = BoundaryProxyHandler.defaultDeletePropertyTrap;\n                        this.isExtensible = BoundaryProxyHandler.defaultIsExtensibleTrap;\n                        this.getOwnPropertyDescriptor = BoundaryProxyHandler.defaultGetOwnPropertyDescriptorTrap;\n                        this.getPrototypeOf = BoundaryProxyHandler.defaultGetPrototypeOfTrap;\n                        this.get =\n                            foreignTargetTraits & 32\n                                ? BoundaryProxyHandler.hybridGetTrapForTypedArray\n                                : BoundaryProxyHandler.defaultGetTrap;\n                        this.has = BoundaryProxyHandler.defaultHasTrap;\n                        this.ownKeys = BoundaryProxyHandler.defaultOwnKeysTrap;\n                        this.preventExtensions = BoundaryProxyHandler.defaultPreventExtensionsTrap;\n                        this.setPrototypeOf = BoundaryProxyHandler.defaultSetPrototypeOfTrap;\n                        this.set = BoundaryProxyHandler.defaultSetTrap;\n                        if (foreignTargetTraits & 64) {\n                            // Future optimization: Hoping proxies with frozen handlers\n                            // can be faster.\n                            ObjectFreeze(this);\n                            this.revoke();\n                        }\n                        else if (IS_IN_SHADOW_REALM) {\n                            if (isForeignTargetArray || foreignTargetTraits & 2) {\n                                this.makeProxyLive();\n                            }\n                        }\n                        else {\n                            if (foreignTargetTraits & 16) {\n                                // Lazily define serializedValue.\n                                let cachedSerializedValue = LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL;\n                                const { serializedValue } = this;\n                                if (MINIFICATION_SAFE_SERIALIZED_VALUE_PROPERTY_NAME === undefined) {\n                                    // A minification safe way to get the 'serializedValue'\n                                    // property name.\n                                    ;\n                                    ({ 0: MINIFICATION_SAFE_SERIALIZED_VALUE_PROPERTY_NAME } = ObjectKeys({\n                                        serializedValue,\n                                    }));\n                                }\n                                ReflectApply(ObjectProtoDefineGetter, this, [\n                                    MINIFICATION_SAFE_SERIALIZED_VALUE_PROPERTY_NAME,\n                                    () => {\n                                        if (cachedSerializedValue === LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL) {\n                                            cachedSerializedValue = foreignCallableSerializeTarget(this.foreignTargetPointer);\n                                        }\n                                        return cachedSerializedValue;\n                                    },\n                                ]);\n                            } // Future optimization: Hoping proxies with frozen handlers\n                            // can be faster. If local mutations are not trapped, then\n                            // freezing the handler is ok because it is not expecting to\n                            // change in the future.\n                            ObjectFreeze(this);\n                        }\n                    }\n                    makeProxyLive() {\n                        // Replace pending traps with live traps that can work with the\n                        // target without taking snapshots.\n                        this.deleteProperty = BoundaryProxyHandler.passthruDeletePropertyTrap;\n                        this.defineProperty = BoundaryProxyHandler.passthruDefinePropertyTrap;\n                        this.preventExtensions = BoundaryProxyHandler.passthruPreventExtensionsTrap;\n                        this.set = BoundaryProxyHandler.passthruSetTrap;\n                        this.setPrototypeOf = BoundaryProxyHandler.passthruSetPrototypeOfTrap; // Future optimization: Hoping proxies with frozen handlers can\n                        // be faster.\n                        ObjectFreeze(this);\n                    }\n                    makeProxyStatic() {\n                        // Reset all traps except apply and construct for static proxies\n                        // since the proxy target is the shadow target and all operations\n                        // are going to be applied to it rather than the real target.\n                        this.defineProperty = BoundaryProxyHandler.staticDefinePropertyTrap;\n                        this.deleteProperty = BoundaryProxyHandler.staticDeletePropertyTrap;\n                        this.get = BoundaryProxyHandler.staticGetTrap;\n                        this.getOwnPropertyDescriptor = BoundaryProxyHandler.staticGetOwnPropertyDescriptorTrap;\n                        this.getPrototypeOf = BoundaryProxyHandler.staticGetPrototypeOfTrap;\n                        this.has = BoundaryProxyHandler.staticHasTrap;\n                        this.isExtensible = BoundaryProxyHandler.staticIsExtensibleTrap;\n                        this.ownKeys = BoundaryProxyHandler.staticOwnKeysTrap;\n                        this.preventExtensions = BoundaryProxyHandler.staticPreventExtensionsTrap;\n                        this.set = BoundaryProxyHandler.staticSetTrap;\n                        this.setPrototypeOf = BoundaryProxyHandler.staticSetPrototypeOfTrap;\n                        const { foreignTargetPointer: foreignTargetPointer1, foreignTargetTraits: foreignTargetTraits1, shadowTarget: shadowTarget1, } = this;\n                        if (useFastForeignTargetPath) {\n                            fastForeignTargetPointers.delete(foreignTargetPointer1);\n                        } // We don't wrap `foreignCallableGetTargetIntegrityTraits()`\n                        // in a try-catch because it cannot throw.\n                        const targetIntegrityTraits = foreignCallableGetTargetIntegrityTraits(foreignTargetPointer1);\n                        if (targetIntegrityTraits & 8) {\n                            // Future optimization: Hoping proxies with frozen\n                            // handlers can be faster.\n                            ObjectFreeze(this); // the target is a revoked proxy, in which case we revoke\n                            // this proxy as well.\n                            this.revoke();\n                            return;\n                        } // A proxy can revoke itself when traps are triggered and break\n                        // the membrane, therefore we need protection.\n                        try {\n                            copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget(foreignTargetPointer1, shadowTarget1);\n                        }\n                        catch (_unused27) {\n                            // We don't wrap `foreignCallableIsTargetRevoked()` in a\n                            // try-catch because it cannot throw.\n                            if (foreignCallableIsTargetRevoked(foreignTargetPointer1)) {\n                                // Future optimization: Hoping proxies with frozen\n                                // handlers can be faster.\n                                ObjectFreeze(this);\n                                this.revoke();\n                                return;\n                            }\n                        }\n                        if (foreignTargetTraits1 & 16 && !(SymbolToStringTag in shadowTarget1)) {\n                            let toStringTag = 'Object';\n                            try {\n                                toStringTag = foreignCallableGetToStringTagOfTarget(foreignTargetPointer1); // eslint-disable-next-line no-empty\n                            }\n                            catch (_unused28) { }\n                            this.staticToStringTag = toStringTag;\n                        } // Preserve the semantics of the target.\n                        if (targetIntegrityTraits & 4) {\n                            ObjectFreeze(shadowTarget1);\n                        }\n                        else {\n                            if (targetIntegrityTraits & 2) {\n                                ObjectSeal(shadowTarget1);\n                            }\n                            else if (targetIntegrityTraits & 1) {\n                                ReflectPreventExtensions(shadowTarget1);\n                            }\n                            if (LOCKER_UNMINIFIED_FLAG) {\n                                // We don't wrap `foreignCallableDebugInfo()` in a try-catch\n                                // because it cannot throw.\n                                foreignCallableDebugInfo('Mutations on the membrane of an object originating ' +\n                                    'outside of the sandbox will not be reflected on ' +\n                                    'the object itself:', foreignTargetPointer1);\n                            }\n                        } // Future optimization: Hoping proxies with frozen handlers can\n                        // be faster.\n                        ObjectFreeze(this);\n                    }\n                    static passthruDefinePropertyTrap(_shadowTarget, key, unsafePartialDesc) {\n                        lastProxyTrapCalled = 4; /* ProxyHandlerTraps.DefineProperty */\n                        let activity;\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity = startActivity('Reflect.defineProperty');\n                        }\n                        const { foreignTargetPointer: foreignTargetPointer1, nonConfigurableDescriptorCallback } = this;\n                        const safePartialDesc = unsafePartialDesc;\n                        ReflectSetPrototypeOf(safePartialDesc, null);\n                        const { get: getter, set: setter, value: value1 } = safePartialDesc;\n                        const valuePointerOrPrimitive = 'value' in safePartialDesc\n                            ? (typeof value1 === 'object' && value1 !== null) || typeof value1 === 'function'\n                                ? getTransferablePointer(value1) // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                                : // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                                    typeof value1 === 'undefined'\n                                        ? undefined\n                                        : value1\n                            : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL;\n                        const getterPointerOrUndefinedSymbol = 'get' in safePartialDesc\n                            ? typeof getter === 'function'\n                                ? getTransferablePointer(getter)\n                                : getter\n                            : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL;\n                        const setterPointerOrUndefinedSymbol = 'set' in safePartialDesc\n                            ? typeof setter === 'function'\n                                ? getTransferablePointer(setter)\n                                : setter\n                            : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL;\n                        let result = false;\n                        try {\n                            result = foreignCallableDefineProperty(foreignTargetPointer1, key, 'configurable' in safePartialDesc\n                                ? !!safePartialDesc.configurable\n                                : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL, 'enumerable' in safePartialDesc\n                                ? !!safePartialDesc.enumerable\n                                : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL, 'writable' in safePartialDesc\n                                ? !!safePartialDesc.writable\n                                : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL, valuePointerOrPrimitive, getterPointerOrUndefinedSymbol, setterPointerOrUndefinedSymbol, nonConfigurableDescriptorCallback);\n                        }\n                        catch (error) {\n                            var _selectedTarget11;\n                            const errorToThrow = (_selectedTarget11 = selectedTarget) != null ? _selectedTarget11 : error;\n                            selectedTarget = undefined;\n                            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                                activity.error(errorToThrow);\n                            }\n                            throw errorToThrow;\n                        }\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity.stop();\n                        }\n                        if (useFastForeignTargetPath &&\n                            result &&\n                            (typeof getterPointerOrUndefinedSymbol === 'function' ||\n                                typeof setterPointerOrUndefinedSymbol === 'function')) {\n                            fastForeignTargetPointers.delete(foreignTargetPointer1);\n                        }\n                        return result;\n                    }\n                    static passthruDeletePropertyTrap(_shadowTarget, key) {\n                        lastProxyTrapCalled = 8; /* ProxyHandlerTraps.DeleteProperty */\n                        let activity;\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity = startActivity('Reflect.deleteProperty');\n                        }\n                        let result = false;\n                        try {\n                            result = foreignCallableDeleteProperty(this.foreignTargetPointer, key);\n                        }\n                        catch (error) {\n                            var _selectedTarget12;\n                            const errorToThrow = (_selectedTarget12 = selectedTarget) != null ? _selectedTarget12 : error;\n                            selectedTarget = undefined;\n                            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                                activity.error(errorToThrow);\n                            }\n                            throw errorToThrow;\n                        }\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity.stop();\n                        }\n                        return result;\n                    }\n                    static passthruGetPrototypeOfTrap(_shadowTarget) {\n                        lastProxyTrapCalled = 64; /* ProxyHandlerTraps.GetPrototypeOf */\n                        let activity;\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity = startActivity('Reflect.getPrototypeOf');\n                        }\n                        let protoPointerOrNull;\n                        try {\n                            protoPointerOrNull = foreignCallableGetPrototypeOf(this.foreignTargetPointer);\n                        }\n                        catch (error) {\n                            var _selectedTarget13;\n                            const errorToThrow = (_selectedTarget13 = selectedTarget) != null ? _selectedTarget13 : error;\n                            selectedTarget = undefined;\n                            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                                activity.error(errorToThrow);\n                            }\n                            throw errorToThrow;\n                        }\n                        let proto;\n                        if (typeof protoPointerOrNull === 'function') {\n                            protoPointerOrNull();\n                            proto = selectedTarget;\n                            selectedTarget = undefined;\n                        }\n                        else {\n                            proto = null;\n                        }\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity.stop();\n                        }\n                        return proto;\n                    }\n                    static passthruIsExtensibleTrap(_shadowTarget) {\n                        lastProxyTrapCalled = 256; /* ProxyHandlerTraps.IsExtensible */\n                        let activity;\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity = startActivity('Reflect.isExtensible');\n                        }\n                        const { shadowTarget: shadowTarget1 } = this;\n                        let result = false; // Check if already locked.\n                        if (ReflectIsExtensible(shadowTarget1)) {\n                            const { foreignTargetPointer: foreignTargetPointer1 } = this;\n                            try {\n                                result = foreignCallableIsExtensible(foreignTargetPointer1);\n                            }\n                            catch (error) {\n                                var _selectedTarget14;\n                                const errorToThrow = (_selectedTarget14 = selectedTarget) != null ? _selectedTarget14 : error;\n                                selectedTarget = undefined;\n                                if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                                    activity.error(errorToThrow);\n                                }\n                                throw errorToThrow;\n                            }\n                            if (!result) {\n                                copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget(foreignTargetPointer1, shadowTarget1);\n                                ReflectPreventExtensions(shadowTarget1);\n                            }\n                        }\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity.stop();\n                        }\n                        return result;\n                    }\n                    static passthruOwnKeysTrap(_shadowTarget) {\n                        lastProxyTrapCalled = 512; /* ProxyHandlerTraps.OwnKeys */\n                        let activity;\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity = startActivity('Reflect.ownKeys');\n                        }\n                        let ownKeys;\n                        try {\n                            foreignCallableOwnKeys(this.foreignTargetPointer, (...args) => {\n                                ownKeys = args;\n                            });\n                        }\n                        catch (error) {\n                            var _selectedTarget15;\n                            const errorToThrow = (_selectedTarget15 = selectedTarget) != null ? _selectedTarget15 : error;\n                            selectedTarget = undefined;\n                            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                                activity.error(errorToThrow);\n                            }\n                            throw errorToThrow;\n                        }\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity.stop();\n                        }\n                        return ownKeys || [];\n                    }\n                    static passthruGetOwnPropertyDescriptorTrap(_shadowTarget, key) {\n                        lastProxyTrapCalled = 32; /* ProxyHandlerTraps.GetOwnPropertyDescriptor */\n                        let activity;\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity = startActivity('Reflect.getOwnPropertyDescriptor');\n                        }\n                        const { foreignTargetPointer: foreignTargetPointer1, shadowTarget: shadowTarget1 } = this;\n                        let safeDesc;\n                        try {\n                            foreignCallableGetOwnPropertyDescriptor(foreignTargetPointer1, key, (_key, configurable, enumerable, writable, valuePointer, getterPointer, setterPointer) => {\n                                safeDesc = createDescriptorFromMeta(configurable, enumerable, writable, valuePointer, getterPointer, setterPointer);\n                                if (safeDesc.configurable === false) {\n                                    // Update the descriptor to non-configurable on\n                                    // the shadow target.\n                                    ReflectDefineProperty(shadowTarget1, key, safeDesc);\n                                }\n                            });\n                        }\n                        catch (error) {\n                            var _selectedTarget16;\n                            const errorToThrow = (_selectedTarget16 = selectedTarget) != null ? _selectedTarget16 : error;\n                            selectedTarget = undefined;\n                            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                                activity.error(errorToThrow);\n                            }\n                            throw errorToThrow;\n                        }\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity.stop();\n                        }\n                        return safeDesc;\n                    }\n                    static passthruPreventExtensionsTrap(_shadowTarget) {\n                        lastProxyTrapCalled = 1024; /* ProxyHandlerTraps.PreventExtensions */\n                        let activity;\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity = startActivity('Reflect.preventExtensions');\n                        }\n                        const { foreignTargetPointer: foreignTargetPointer1, shadowTarget: shadowTarget1 } = this;\n                        let result = true;\n                        if (ReflectIsExtensible(shadowTarget1)) {\n                            let resultEnum = 0; /* PreventExtensionsResult.None */\n                            try {\n                                resultEnum = foreignCallablePreventExtensions(foreignTargetPointer1);\n                            }\n                            catch (error) {\n                                var _selectedTarget17;\n                                const errorToThrow = (_selectedTarget17 = selectedTarget) != null ? _selectedTarget17 : error;\n                                selectedTarget = undefined;\n                                if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                                    activity.error(errorToThrow);\n                                }\n                                throw errorToThrow;\n                            } // If the target is a proxy it might reject the\n                            // preventExtension call, in which case we should not\n                            // attempt to lock down the shadow target.\n                            if (!(resultEnum & 1)) {\n                                copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget(foreignTargetPointer1, shadowTarget1);\n                                ReflectPreventExtensions(shadowTarget1);\n                            }\n                            result = !(resultEnum & 2);\n                        }\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity.stop();\n                        }\n                        return result;\n                    }\n                    static passthruSetPrototypeOfTrap(_shadowTarget, proto) {\n                        lastProxyTrapCalled = 4096; /* ProxyHandlerTraps.SetPrototypeOf */\n                        let activity;\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity = startActivity('Reflect.setPrototypeOf');\n                        }\n                        const { foreignTargetPointer: foreignTargetPointer1 } = this;\n                        const transferableProto = proto ? getTransferablePointer(proto) : proto;\n                        let result = false;\n                        try {\n                            result = foreignCallableSetPrototypeOf(foreignTargetPointer1, transferableProto);\n                        }\n                        catch (error) {\n                            var _selectedTarget18;\n                            const errorToThrow = (_selectedTarget18 = selectedTarget) != null ? _selectedTarget18 : error;\n                            selectedTarget = undefined;\n                            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                                activity.error(errorToThrow);\n                            }\n                            throw errorToThrow;\n                        }\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity.stop();\n                        }\n                        if (useFastForeignTargetPath && result) {\n                            fastForeignTargetPointers.delete(foreignTargetPointer1);\n                        }\n                        return result;\n                    }\n                    static passthruSetTrap(_shadowTarget, key, value, receiver) {\n                        lastProxyTrapCalled = 2048; /* ProxyHandlerTraps.Set */\n                        const { foreignTargetPointer: foreignTargetPointer1, proxy, shadowTarget: shadowTarget1 } = this; // Intentionally ignoring `document.all`.\n                        // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                        if (typeof value === 'undefined') {\n                            value = undefined;\n                        }\n                        if (typeof receiver === 'undefined') {\n                            receiver = proxy;\n                        }\n                        const isFastPath = proxy === receiver;\n                        let activity;\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity = startActivity(isFastPath ? 'Reflect.set' : 'passthruForeignTraversedSet');\n                        }\n                        let result = false;\n                        try {\n                            result = isFastPath\n                                ? foreignCallableSet(foreignTargetPointer1, key, (typeof value === 'object' && value !== null) || typeof value === 'function'\n                                    ? getTransferablePointer(value)\n                                    : value, LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL)\n                                : passthruForeignTraversedSet(foreignTargetPointer1, shadowTarget1, key, value, receiver);\n                        }\n                        catch (error) {\n                            var _selectedTarget19;\n                            const errorToThrow = (_selectedTarget19 = selectedTarget) != null ? _selectedTarget19 : error;\n                            selectedTarget = undefined;\n                            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                                activity.error(errorToThrow);\n                            }\n                            throw errorToThrow;\n                        }\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity.stop();\n                        }\n                        return result;\n                    }\n                } // Logic implementation of all traps.\n                // Hybrid traps:\n                // (traps that operate on their shadowTarget, proxy, and foreignTargetPointer):\n                BoundaryProxyHandler.hybridGetTrap = IS_IN_SHADOW_REALM\n                    ? function (_shadowTarget, key, receiver) {\n                        let activity;\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity = startActivity('hybridGetTrap');\n                        }\n                        const { foreignTargetPointer: foreignTargetPointer1, foreignTargetTraits: foreignTargetTraits1, proxy, shadowTarget: shadowTarget1, } = this;\n                        let safeDesc;\n                        let result;\n                        if (useFastForeignTargetPath && fastForeignTargetPointers.has(foreignTargetPointer1)) {\n                            let pointerOrPrimitive;\n                            try {\n                                pointerOrPrimitive = foreignCallableGetPropertyValue(foreignTargetPointer1, key);\n                            }\n                            catch (error) {\n                                var _selectedTarget20;\n                                const errorToThrow = (_selectedTarget20 = selectedTarget) != null ? _selectedTarget20 : error;\n                                selectedTarget = undefined;\n                                if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                                    activity.error(errorToThrow);\n                                }\n                                throw errorToThrow;\n                            }\n                            if (typeof pointerOrPrimitive === 'function') {\n                                pointerOrPrimitive();\n                                result = selectedTarget;\n                                selectedTarget = undefined;\n                            }\n                            else {\n                                result = pointerOrPrimitive;\n                            }\n                        }\n                        else {\n                            safeDesc = lookupForeignDescriptor(foreignTargetPointer1, shadowTarget1, key);\n                            if (safeDesc) {\n                                const { get: getter, value: localValue } = safeDesc;\n                                if (getter) {\n                                    if (safeDesc.foreign) {\n                                        const foreignGetterPointer = getTransferablePointer(getter);\n                                        const transferableReceiver = proxy === receiver\n                                            ? foreignTargetPointer1\n                                            : (typeof receiver === 'object' && receiver !== null) ||\n                                                typeof receiver === 'function'\n                                                ? getTransferablePointer(receiver)\n                                                : receiver;\n                                        let pointerOrPrimitive;\n                                        try {\n                                            pointerOrPrimitive = foreignCallableApply(foreignGetterPointer, transferableReceiver);\n                                        }\n                                        catch (error) {\n                                            var _selectedTarget21;\n                                            const errorToThrow = (_selectedTarget21 = selectedTarget) != null\n                                                ? _selectedTarget21\n                                                : error;\n                                            selectedTarget = undefined;\n                                            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                                                activity.error(errorToThrow);\n                                            }\n                                            throw errorToThrow;\n                                        }\n                                        if (typeof pointerOrPrimitive === 'function') {\n                                            pointerOrPrimitive();\n                                            result = selectedTarget;\n                                            selectedTarget = undefined;\n                                        }\n                                        else {\n                                            result = pointerOrPrimitive;\n                                        }\n                                    }\n                                    else {\n                                        // Even though the getter function exists,\n                                        // we can't use `ReflectGet()` because there\n                                        // might be a distortion for that getter function,\n                                        // in which case we must resolve the local getter\n                                        // and call it instead.\n                                        result = ReflectApply(getter, receiver, []);\n                                    }\n                                }\n                                else {\n                                    result = localValue;\n                                }\n                            }\n                            else {\n                                const transferableReceiver = proxy === receiver\n                                    ? foreignTargetPointer1\n                                    : (typeof receiver === 'object' && receiver !== null) ||\n                                        typeof receiver === 'function'\n                                        ? getTransferablePointer(receiver)\n                                        : receiver;\n                                let pointerOrPrimitive;\n                                try {\n                                    pointerOrPrimitive = foreignCallableGet(foreignTargetPointer1, foreignTargetTraits1, key, transferableReceiver);\n                                }\n                                catch (error) {\n                                    var _selectedTarget22;\n                                    const errorToThrow = (_selectedTarget22 = selectedTarget) != null ? _selectedTarget22 : error;\n                                    selectedTarget = undefined;\n                                    if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                                        activity.error(errorToThrow);\n                                    }\n                                    throw errorToThrow;\n                                }\n                                if (typeof pointerOrPrimitive === 'function') {\n                                    pointerOrPrimitive();\n                                    result = selectedTarget;\n                                    selectedTarget = undefined;\n                                }\n                                else {\n                                    result = pointerOrPrimitive;\n                                }\n                            }\n                        }\n                        if (safeDesc === undefined &&\n                            result === undefined &&\n                            key === SymbolToStringTag &&\n                            foreignTargetTraits1 & 16) {\n                            let toStringTag;\n                            try {\n                                toStringTag = foreignCallableGetToStringTagOfTarget(foreignTargetPointer1);\n                            }\n                            catch (error) {\n                                var _selectedTarget23;\n                                const errorToThrow = (_selectedTarget23 = selectedTarget) != null ? _selectedTarget23 : error;\n                                selectedTarget = undefined;\n                                if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                                    activity.error(errorToThrow);\n                                }\n                                throw errorToThrow;\n                            } // The default language toStringTag is \"Object\". If we\n                            // receive \"Object\" we return `undefined` to let the\n                            // language resolve it naturally without projecting a\n                            // value.\n                            if (toStringTag !== 'Object') {\n                                result = toStringTag;\n                            }\n                        }\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity.stop();\n                        }\n                        return result;\n                    }\n                    : noop;\n                BoundaryProxyHandler.hybridGetTrapForTypedArray = IS_IN_SHADOW_REALM\n                    ? function (_shadowTarget, key, receiver) {\n                        let activity;\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity = startActivity('hybridGetTrapForTypedArray');\n                        }\n                        const { foreignTargetPointer: foreignTargetPointer1, foreignTargetTypedArrayLength: foreignTargetTypedArrayLength1, proxy, shadowTarget: shadowTarget1, } = this;\n                        let useFastPath = useFastForeignTargetPathForTypedArrays;\n                        if (!useFastPath && typeof key === 'string') {\n                            const possibleIndex = +key;\n                            useFastPath =\n                                possibleIndex > -1 &&\n                                    possibleIndex < foreignTargetTypedArrayLength1 &&\n                                    NumberIsInteger(possibleIndex);\n                        }\n                        let result;\n                        if (useFastPath) {\n                            try {\n                                result = foreignCallableGetPropertyValue(foreignTargetPointer1, key);\n                            }\n                            catch (error) {\n                                var _selectedTarget24;\n                                const errorToThrow = (_selectedTarget24 = selectedTarget) != null ? _selectedTarget24 : error;\n                                selectedTarget = undefined;\n                                if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                                    activity.error(errorToThrow);\n                                }\n                                throw errorToThrow;\n                            }\n                        }\n                        else {\n                            const safeDesc = lookupForeignDescriptor(foreignTargetPointer1, shadowTarget1, key);\n                            if (safeDesc) {\n                                const { get: getter, value: localValue } = safeDesc;\n                                if (getter) {\n                                    if (safeDesc.foreign) {\n                                        const foreignGetterPointer = getTransferablePointer(getter);\n                                        const transferableReceiver = proxy === receiver\n                                            ? foreignTargetPointer1\n                                            : (typeof receiver === 'object' && receiver !== null) ||\n                                                typeof receiver === 'function'\n                                                ? getTransferablePointer(receiver)\n                                                : receiver;\n                                        let pointerOrPrimitive;\n                                        try {\n                                            pointerOrPrimitive = foreignCallableApply(foreignGetterPointer, transferableReceiver);\n                                        }\n                                        catch (error) {\n                                            var _selectedTarget25;\n                                            const errorToThrow = (_selectedTarget25 = selectedTarget) != null\n                                                ? _selectedTarget25\n                                                : error;\n                                            selectedTarget = undefined;\n                                            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                                                activity.error(errorToThrow);\n                                            }\n                                            throw errorToThrow;\n                                        }\n                                        if (typeof pointerOrPrimitive === 'function') {\n                                            pointerOrPrimitive();\n                                            result = selectedTarget;\n                                            selectedTarget = undefined;\n                                        }\n                                        else {\n                                            result = pointerOrPrimitive;\n                                        }\n                                    }\n                                    else {\n                                        // Even though the getter function exists,\n                                        // we can't use `ReflectGet()` because there\n                                        // might be a distortion for that getter function,\n                                        // in which case we must resolve the local getter\n                                        // and call it instead.\n                                        result = ReflectApply(getter, receiver, []);\n                                    }\n                                }\n                                else {\n                                    result = localValue;\n                                }\n                            }\n                        }\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity.stop();\n                        }\n                        return result;\n                    }\n                    : noop;\n                BoundaryProxyHandler.hybridHasTrap = IS_IN_SHADOW_REALM\n                    ? function (_shadowTarget, key) {\n                        let activity;\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity = startActivity('hybridHasTrap');\n                        }\n                        let trueOrProtoPointerOrNull;\n                        try {\n                            trueOrProtoPointerOrNull = foreignCallableBatchGetPrototypeOfWhenHasNoOwnProperty(this.foreignTargetPointer, key);\n                        }\n                        catch (error) {\n                            var _selectedTarget26;\n                            const errorToThrow = (_selectedTarget26 = selectedTarget) != null ? _selectedTarget26 : error;\n                            selectedTarget = undefined;\n                            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                                activity.error(errorToThrow);\n                            }\n                            throw errorToThrow;\n                        }\n                        let result = false;\n                        if (trueOrProtoPointerOrNull === true) {\n                            result = true;\n                        }\n                        else {\n                            // Avoiding calling the has trap for any proto chain operation,\n                            // instead we implement the regular logic here in this trap.\n                            let currentObject;\n                            if (typeof trueOrProtoPointerOrNull === 'function') {\n                                trueOrProtoPointerOrNull();\n                                currentObject = selectedTarget;\n                                selectedTarget = undefined;\n                            }\n                            else {\n                                currentObject = null;\n                            }\n                            while (currentObject) {\n                                if (ObjectHasOwn(currentObject, key)) {\n                                    result = true;\n                                    break;\n                                }\n                                currentObject = ReflectGetPrototypeOf(currentObject);\n                            }\n                        }\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity.stop();\n                        }\n                        return result;\n                    }\n                    : alwaysFalse;\n                BoundaryProxyHandler.passthruGetTrap = !IS_IN_SHADOW_REALM\n                    ? function (_shadowTarget, key, receiver) {\n                        // Only allow accessing near-membrane symbol values if the\n                        // BoundaryProxyHandler.has trap has been called immediately\n                        // before and the symbol does not exist.\n                        nearMembraneSymbolFlag && (nearMembraneSymbolFlag = lastProxyTrapCalled === 128);\n                        lastProxyTrapCalled = 16; /* ProxyHandlerTraps.Get */\n                        if (nearMembraneSymbolFlag) {\n                            // Exit without performing a [[Get]] for near-membrane\n                            // symbols because we know when the nearMembraneSymbolFlag\n                            // is on that there is no shadowed symbol value.\n                            if (key === LOCKER_NEAR_MEMBRANE_SYMBOL) {\n                                return true;\n                            }\n                            if (key === LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL) {\n                                return this.serializedValue;\n                            }\n                        }\n                        let activity;\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity = startActivity('Reflect.get');\n                        }\n                        const { foreignTargetPointer: foreignTargetPointer1, foreignTargetTraits: foreignTargetTraits1, proxy, } = this;\n                        if (typeof receiver === 'undefined') {\n                            receiver = proxy;\n                        }\n                        const transferableReceiver = proxy === receiver\n                            ? LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL\n                            : (typeof receiver === 'object' && receiver !== null) ||\n                                typeof receiver === 'function'\n                                ? getTransferablePointer(receiver)\n                                : receiver;\n                        let pointerOrPrimitive;\n                        try {\n                            pointerOrPrimitive = foreignCallableGet(foreignTargetPointer1, foreignTargetTraits1, key, transferableReceiver);\n                        }\n                        catch (error) {\n                            var _selectedTarget27;\n                            const errorToThrow = (_selectedTarget27 = selectedTarget) != null ? _selectedTarget27 : error;\n                            selectedTarget = undefined;\n                            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                                activity.error(errorToThrow);\n                            }\n                            throw errorToThrow;\n                        }\n                        let result;\n                        if (typeof pointerOrPrimitive === 'function') {\n                            pointerOrPrimitive();\n                            result = selectedTarget;\n                            selectedTarget = undefined;\n                        }\n                        else {\n                            result = pointerOrPrimitive;\n                        }\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity.stop();\n                        }\n                        return result;\n                    }\n                    : noop;\n                BoundaryProxyHandler.passthruHasTrap = !IS_IN_SHADOW_REALM\n                    ? function (_shadowTarget, key) {\n                        lastProxyTrapCalled = 128; /* ProxyHandlerTraps.Has */\n                        let activity;\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity = startActivity('Reflect.has');\n                        }\n                        let result;\n                        try {\n                            result = foreignCallableHas(this.foreignTargetPointer, key);\n                        }\n                        catch (error) {\n                            var _selectedTarget28;\n                            const errorToThrow = (_selectedTarget28 = selectedTarget) != null ? _selectedTarget28 : error;\n                            selectedTarget = undefined;\n                            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                                activity.error(errorToThrow);\n                            }\n                            throw errorToThrow;\n                        } // The near-membrane symbol flag is on if the symbol does not\n                        // exist on the object or its [[Prototype]].\n                        nearMembraneSymbolFlag =\n                            !result &&\n                                (key === LOCKER_NEAR_MEMBRANE_SYMBOL ||\n                                    key === LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL);\n                        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                            activity.stop();\n                        }\n                        return result;\n                    }\n                    : alwaysFalse; // Pending traps:\n                BoundaryProxyHandler.pendingDefinePropertyTrap = IS_IN_SHADOW_REALM\n                    ? function (shadowTarget, key, unsafePartialDesc) {\n                        const { foreignTargetPointer: foreignTargetPointer1, foreignTargetTraits: foreignTargetTraits1, } = this; // We don't wrap `foreignCallableIsTargetLive()` in a\n                        // try-catch because it cannot throw.\n                        if (foreignCallableIsTargetLive(foreignTargetPointer1, foreignTargetTraits1)) {\n                            this.makeProxyLive();\n                        }\n                        else {\n                            if (useFastForeignTargetPath) {\n                                if (isForeignPointerOfObjectProto(foreignTargetPointer1)) {\n                                    disableFastForeignTargetPointers();\n                                }\n                                else if (isForeignPointerOfTypedArrayProto(foreignTargetPointer1)) {\n                                    useFastForeignTargetPathForTypedArrays = false;\n                                }\n                            }\n                            this.makeProxyStatic();\n                        }\n                        return this.defineProperty(shadowTarget, key, unsafePartialDesc);\n                    }\n                    : alwaysFalse;\n                BoundaryProxyHandler.pendingDeletePropertyTrap = IS_IN_SHADOW_REALM\n                    ? function (shadowTarget, key) {\n                        // We don't wrap `foreignCallableIsTargetLive()` in a\n                        // try-catch because it cannot throw.\n                        if (foreignCallableIsTargetLive(this.foreignTargetPointer, this.foreignTargetTraits)) {\n                            this.makeProxyLive();\n                        }\n                        else {\n                            this.makeProxyStatic();\n                        }\n                        return this.deleteProperty(shadowTarget, key);\n                    }\n                    : alwaysFalse;\n                BoundaryProxyHandler.pendingPreventExtensionsTrap = IS_IN_SHADOW_REALM\n                    ? function (shadowTarget) {\n                        // We don't wrap `foreignCallableIsTargetLive()` in a\n                        // try-catch because it cannot throw.\n                        if (foreignCallableIsTargetLive(this.foreignTargetPointer, this.foreignTargetTraits)) {\n                            this.makeProxyLive();\n                        }\n                        else {\n                            this.makeProxyStatic();\n                        }\n                        return this.preventExtensions(shadowTarget);\n                    }\n                    : alwaysFalse;\n                BoundaryProxyHandler.pendingSetPrototypeOfTrap = IS_IN_SHADOW_REALM\n                    ? function (shadowTarget, proto) {\n                        const { foreignTargetPointer: foreignTargetPointer1, foreignTargetTraits: foreignTargetTraits1, } = this; // We don't wrap `foreignCallableIsTargetLive()` in a\n                        // try-catch because it cannot throw.\n                        if (foreignCallableIsTargetLive(foreignTargetPointer1, foreignTargetTraits1)) {\n                            this.makeProxyLive();\n                        }\n                        else {\n                            if (useFastForeignTargetPath) {\n                                if (isForeignPointerOfObjectProto(foreignTargetPointer1)) {\n                                    disableFastForeignTargetPointers();\n                                }\n                                else if (isForeignPointerOfTypedArrayProto(foreignTargetPointer1)) {\n                                    useFastForeignTargetPathForTypedArrays = false;\n                                }\n                            }\n                            this.makeProxyStatic();\n                        }\n                        return this.setPrototypeOf(shadowTarget, proto);\n                    }\n                    : alwaysFalse;\n                BoundaryProxyHandler.pendingSetTrap = IS_IN_SHADOW_REALM\n                    ? function (shadowTarget, key, value, receiver) {\n                        const { foreignTargetPointer: foreignTargetPointer1, foreignTargetTraits: foreignTargetTraits1, } = this; // We don't wrap `foreignCallableIsTargetLive()` in a\n                        // try-catch because it cannot throw.\n                        if (foreignCallableIsTargetLive(foreignTargetPointer1, foreignTargetTraits1)) {\n                            this.makeProxyLive();\n                        }\n                        else {\n                            if (useFastForeignTargetPath) {\n                                if (isForeignPointerOfObjectProto(foreignTargetPointer1)) {\n                                    disableFastForeignTargetPointers();\n                                }\n                                else if (isForeignPointerOfTypedArrayProto(foreignTargetPointer1)) {\n                                    useFastForeignTargetPathForTypedArrays = false;\n                                }\n                            }\n                            this.makeProxyStatic();\n                        }\n                        return this.set(shadowTarget, key, value, receiver);\n                    }\n                    : alwaysFalse; //  Static traps:\n                BoundaryProxyHandler.staticDefinePropertyTrap = IS_IN_SHADOW_REALM ? ReflectDefineProperty : alwaysFalse;\n                BoundaryProxyHandler.staticDeletePropertyTrap = IS_IN_SHADOW_REALM ? ReflectDeleteProperty : alwaysFalse;\n                BoundaryProxyHandler.staticGetOwnPropertyDescriptorTrap = IS_IN_SHADOW_REALM\n                    ? ReflectGetOwnPropertyDescriptor\n                    : noop;\n                BoundaryProxyHandler.staticGetPrototypeOfTrap = IS_IN_SHADOW_REALM ? ReflectGetPrototypeOf : () => null;\n                BoundaryProxyHandler.staticGetTrap = IS_IN_SHADOW_REALM\n                    ? function (shadowTarget, key, receiver) {\n                        const { foreignTargetTraits: foreignTargetTraits1, staticToStringTag } = this;\n                        const result = ReflectGet(shadowTarget, key, receiver);\n                        if (result === undefined &&\n                            key === SymbolToStringTag &&\n                            foreignTargetTraits1 & 16 && // The default language toStringTag is \"Object\". If we\n                            // receive \"Object\" we return `undefined` to let the\n                            // language resolve it naturally without projecting a\n                            // value.\n                            staticToStringTag !== 'Object' &&\n                            !(key in shadowTarget)) {\n                            return staticToStringTag;\n                        }\n                        return result;\n                    }\n                    : noop;\n                BoundaryProxyHandler.staticHasTrap = IS_IN_SHADOW_REALM ? ReflectHas : alwaysFalse;\n                BoundaryProxyHandler.staticIsExtensibleTrap = IS_IN_SHADOW_REALM ? ReflectIsExtensible : alwaysFalse;\n                BoundaryProxyHandler.staticOwnKeysTrap = IS_IN_SHADOW_REALM ? ReflectOwnKeys : () => [];\n                BoundaryProxyHandler.staticPreventExtensionsTrap = IS_IN_SHADOW_REALM\n                    ? ReflectPreventExtensions\n                    : alwaysFalse;\n                BoundaryProxyHandler.staticSetPrototypeOfTrap = IS_IN_SHADOW_REALM ? ReflectSetPrototypeOf : alwaysFalse;\n                BoundaryProxyHandler.staticSetTrap = IS_IN_SHADOW_REALM ? ReflectSet : alwaysFalse; // Default traps:\n                // Pending traps are needed for the shadow realm side of the membrane\n                // to avoid leaking mutation operations on the primary realm side.\n                BoundaryProxyHandler.defaultDefinePropertyTrap = IS_IN_SHADOW_REALM\n                    ? BoundaryProxyHandler.pendingDefinePropertyTrap\n                    : BoundaryProxyHandler.passthruDefinePropertyTrap;\n                BoundaryProxyHandler.defaultDeletePropertyTrap = IS_IN_SHADOW_REALM\n                    ? BoundaryProxyHandler.pendingDeletePropertyTrap\n                    : BoundaryProxyHandler.passthruDeletePropertyTrap;\n                BoundaryProxyHandler.defaultGetOwnPropertyDescriptorTrap =\n                    BoundaryProxyHandler.passthruGetOwnPropertyDescriptorTrap;\n                BoundaryProxyHandler.defaultGetPrototypeOfTrap = BoundaryProxyHandler.passthruGetPrototypeOfTrap;\n                BoundaryProxyHandler.defaultGetTrap = IS_IN_SHADOW_REALM\n                    ? BoundaryProxyHandler.hybridGetTrap\n                    : BoundaryProxyHandler.passthruGetTrap;\n                BoundaryProxyHandler.defaultHasTrap = IS_IN_SHADOW_REALM\n                    ? BoundaryProxyHandler.hybridHasTrap\n                    : BoundaryProxyHandler.passthruHasTrap;\n                BoundaryProxyHandler.defaultIsExtensibleTrap = BoundaryProxyHandler.passthruIsExtensibleTrap;\n                BoundaryProxyHandler.defaultOwnKeysTrap = BoundaryProxyHandler.passthruOwnKeysTrap;\n                BoundaryProxyHandler.defaultPreventExtensionsTrap = IS_IN_SHADOW_REALM\n                    ? BoundaryProxyHandler.pendingPreventExtensionsTrap\n                    : BoundaryProxyHandler.passthruPreventExtensionsTrap;\n                BoundaryProxyHandler.defaultSetTrap = IS_IN_SHADOW_REALM\n                    ? BoundaryProxyHandler.pendingSetTrap\n                    : BoundaryProxyHandler.passthruSetTrap;\n                BoundaryProxyHandler.defaultSetPrototypeOfTrap = IS_IN_SHADOW_REALM\n                    ? BoundaryProxyHandler.pendingSetPrototypeOfTrap\n                    : BoundaryProxyHandler.passthruSetPrototypeOfTrap;\n                if (IS_IN_SHADOW_REALM) {\n                    clearFastForeignTargetPointers();\n                } // Export callable hooks to a foreign realm.\n                foreignCallableHooksCallback(\n                // When crossing, should be mapped to the foreign globalThis\n                createPointer(globalThisRef), !IS_IN_SHADOW_REALM\n                    ? () => {\n                        const result = selectedTarget;\n                        selectedTarget = undefined;\n                        return result;\n                    }\n                    : noop, (value) => {\n                    if ((typeof value === 'object' && value !== null) || typeof value === 'function') {\n                        return getTransferablePointer(value);\n                    } // Intentionally ignoring `document.all`.\n                    // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                    // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                    return typeof value === 'undefined' ? undefined : value;\n                }, // the foreign realm to access a linkable pointer for a property value.\n                // In order to do that, the foreign side must provide a pointer and\n                // a key access the value in order to produce a pointer\n                (targetPointer, key) => {\n                    targetPointer();\n                    const target = selectedTarget;\n                    selectedTarget = undefined;\n                    const value = target == null ? void 0 : target[key]; // Intentionally ignoring `document.all`.\n                    // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                    // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                    return createPointer(typeof value === 'undefined' ? undefined : value);\n                }, IS_IN_SHADOW_REALM\n                    ? (sourceText) => {\n                        let result;\n                        try {\n                            result = sourceText();\n                        }\n                        catch (error) {\n                            throw pushErrorAcrossBoundary(error);\n                        } // Inline getTransferableValue().\n                        return (typeof result === 'object' && result !== null) || typeof result === 'function'\n                            ? getTransferablePointer(result)\n                            : result;\n                    }\n                    : noop, // realm to define a linkage between two values across the membrane.\n                (targetPointer, newPointer) => {\n                    targetPointer();\n                    const target = selectedTarget;\n                    selectedTarget = undefined;\n                    if ((typeof target === 'object' && target !== null) || typeof target === 'function') {\n                        proxyTargetToPointerMap.set(target, newPointer);\n                    }\n                }, LOCKER_DEBUGGABLE_FLAG\n                    ? (foreignTargetPointer, foreignTargetTraits, foreignTargetFunctionArity, foreignTargetFunctionName, foreignTargetTypedArrayLength) => {\n                        const pointer = pushTarget(foreignTargetPointer, foreignTargetTraits, foreignTargetFunctionArity, foreignTargetFunctionName, foreignTargetTypedArrayLength);\n                        const pointerWrapper = () => {\n                            checkDebugMode();\n                            return pointer();\n                        };\n                        return pointerWrapper;\n                    }\n                    : pushTarget, // to install a proxy into this realm that correspond to an object\n                // from the foreign realm. It returns a Pointer that can be used by\n                // the foreign realm to pass back a reference to this realm when\n                // passing arguments or returning from a foreign callable invocation.\n                // This function is extremely important to understand the mechanics\n                // of this membrane.\n                pushTarget, (targetPointer, thisArgPointerOrUndefined, ...args) => {\n                    targetPointer();\n                    const func = selectedTarget;\n                    selectedTarget = undefined;\n                    let thisArg;\n                    if (typeof thisArgPointerOrUndefined === 'function') {\n                        thisArgPointerOrUndefined();\n                        thisArg = selectedTarget;\n                        selectedTarget = undefined;\n                    }\n                    for (let i = 0, { length } = args; i < length; i += 1) {\n                        const pointerOrPrimitive = args[i];\n                        if (typeof pointerOrPrimitive === 'function') {\n                            pointerOrPrimitive();\n                            args[i] = selectedTarget;\n                            selectedTarget = undefined;\n                        }\n                    }\n                    let result;\n                    try {\n                        result = ReflectApply(func, thisArg, args);\n                    }\n                    catch (error) {\n                        throw pushErrorAcrossBoundary(error);\n                    } // Inline getTransferableValue().\n                    return (typeof result === 'object' && result !== null) || typeof result === 'function'\n                        ? getTransferablePointer(result) // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                        : // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                            typeof result === 'undefined'\n                                ? undefined\n                                : result;\n                }, (targetPointer, newTargetPointerOrUndefined, ...args) => {\n                    targetPointer();\n                    const constructor = selectedTarget;\n                    selectedTarget = undefined;\n                    let newTarget;\n                    if (typeof newTargetPointerOrUndefined === 'function') {\n                        newTargetPointerOrUndefined();\n                        newTarget = selectedTarget;\n                        selectedTarget = undefined;\n                    }\n                    for (let i = 0, { length } = args; i < length; i += 1) {\n                        const pointerOrPrimitive = args[i];\n                        if (typeof pointerOrPrimitive === 'function') {\n                            pointerOrPrimitive();\n                            args[i] = selectedTarget;\n                            selectedTarget = undefined;\n                        }\n                    }\n                    let result;\n                    try {\n                        result = ReflectConstruct(constructor, args, newTarget);\n                    }\n                    catch (error) {\n                        throw pushErrorAcrossBoundary(error);\n                    } // Inline getTransferableValue().\n                    return (typeof result === 'object' && result !== null) || typeof result === 'function'\n                        ? getTransferablePointer(result) // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                        : // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                            typeof result === 'undefined'\n                                ? undefined\n                                : result;\n                }, (targetPointer, key, configurable, enumerable, writable, valuePointer, getterPointer, setterPointer, foreignCallableNonConfigurableDescriptorCallback) => {\n                    targetPointer();\n                    const target = selectedTarget;\n                    selectedTarget = undefined;\n                    const safePartialDesc = createDescriptorFromMeta(configurable, enumerable, writable, valuePointer, getterPointer, setterPointer);\n                    let result = false;\n                    try {\n                        result = ReflectDefineProperty(target, key, safePartialDesc);\n                    }\n                    catch (error) {\n                        throw pushErrorAcrossBoundary(error);\n                    }\n                    if (result && configurable === false) {\n                        let safeDesc;\n                        try {\n                            safeDesc = ReflectGetOwnPropertyDescriptor(target, key);\n                        }\n                        catch (error) {\n                            throw pushErrorAcrossBoundary(error);\n                        }\n                        if (safeDesc) {\n                            ReflectSetPrototypeOf(safeDesc, null);\n                            if (safeDesc.configurable === false) {\n                                const { get: getter, set: setter, value: value1 } = safeDesc;\n                                foreignCallableNonConfigurableDescriptorCallback(key, false, 'enumerable' in safeDesc\n                                    ? safeDesc.enumerable\n                                    : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL, 'writable' in safeDesc\n                                    ? safeDesc.writable\n                                    : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL, 'value' in safeDesc\n                                    ? (typeof value1 === 'object' && value1 !== null) ||\n                                        typeof value1 === 'function'\n                                        ? getTransferablePointer(value1)\n                                        : value1\n                                    : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL, 'get' in safeDesc\n                                    ? typeof getter === 'function'\n                                        ? getTransferablePointer(getter)\n                                        : getter\n                                    : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL, 'set' in safeDesc\n                                    ? typeof setter === 'function'\n                                        ? getTransferablePointer(setter)\n                                        : setter\n                                    : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL);\n                            }\n                        }\n                    }\n                    return result;\n                }, (targetPointer, key) => {\n                    targetPointer();\n                    const target = selectedTarget;\n                    selectedTarget = undefined;\n                    try {\n                        return ReflectDeleteProperty(target, key);\n                    }\n                    catch (error) {\n                        throw pushErrorAcrossBoundary(error);\n                    }\n                }, (targetPointer, targetTraits, key, receiverPointerOrPrimitive) => {\n                    targetPointer();\n                    const target = selectedTarget;\n                    selectedTarget = undefined;\n                    let receiver;\n                    if (typeof receiverPointerOrPrimitive === 'function') {\n                        receiverPointerOrPrimitive();\n                        receiver = selectedTarget;\n                        selectedTarget = undefined;\n                    }\n                    else {\n                        receiver =\n                            receiverPointerOrPrimitive === LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL\n                                ? target\n                                : receiverPointerOrPrimitive;\n                    }\n                    let result;\n                    try {\n                        result = ReflectGet(target, key, receiver);\n                    }\n                    catch (error) {\n                        throw pushErrorAcrossBoundary(error);\n                    } // Inline getTransferableValue().\n                    if ((typeof result === 'object' && result !== null) || typeof result === 'function') {\n                        return getTransferablePointer(result);\n                    }\n                    if (result === undefined && key === SymbolToStringTag && targetTraits & 16) {\n                        try {\n                            if (!(key in target)) {\n                                // Section 19.1.3.6 Object.prototype.toString()\n                                // https://tc39.github.io/ecma262/#sec-object.prototype.tostring\n                                const brand = ReflectApply(ObjectProtoToString, target, []); // The default language toStringTag is \"Object\". If\n                                // we receive \"[object Object]\" we return `undefined`\n                                // to let the language resolve it naturally without\n                                // projecting a value.\n                                if (brand !== '[object Object]') {\n                                    result = ReflectApply(StringProtoSlice, brand, [8, -1]);\n                                }\n                            }\n                        }\n                        catch (error) {\n                            throw pushErrorAcrossBoundary(error);\n                        }\n                    } // Intentionally ignoring `document.all`.\n                    // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                    // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                    return typeof result === 'undefined' ? undefined : result;\n                }, (targetPointer, key, foreignCallableDescriptorCallback) => {\n                    targetPointer();\n                    const target = selectedTarget;\n                    selectedTarget = undefined;\n                    let safeDesc;\n                    try {\n                        safeDesc = ReflectGetOwnPropertyDescriptor(target, key);\n                    }\n                    catch (error) {\n                        throw pushErrorAcrossBoundary(error);\n                    }\n                    if (safeDesc) {\n                        ReflectSetPrototypeOf(safeDesc, null);\n                        const { get: getter, set: setter, value: value1 } = safeDesc;\n                        foreignCallableDescriptorCallback(key, 'configurable' in safeDesc\n                            ? safeDesc.configurable\n                            : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL, 'enumerable' in safeDesc\n                            ? safeDesc.enumerable\n                            : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL, 'writable' in safeDesc\n                            ? safeDesc.writable\n                            : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL, 'value' in safeDesc\n                            ? (typeof value1 === 'object' && value1 !== null) || typeof value1 === 'function'\n                                ? getTransferablePointer(value1) // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                                : // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                                    typeof value1 === 'undefined'\n                                        ? undefined\n                                        : value1\n                            : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL, 'get' in safeDesc\n                            ? typeof getter === 'function'\n                                ? getTransferablePointer(getter)\n                                : getter\n                            : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL, 'set' in safeDesc\n                            ? typeof setter === 'function'\n                                ? getTransferablePointer(setter)\n                                : setter\n                            : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL);\n                    }\n                }, (targetPointer) => {\n                    targetPointer();\n                    const target = selectedTarget;\n                    selectedTarget = undefined;\n                    let proto;\n                    try {\n                        proto = ReflectGetPrototypeOf(target);\n                    }\n                    catch (error) {\n                        throw pushErrorAcrossBoundary(error);\n                    } // Intentionally ignoring `document.all`.\n                    // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                    // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                    if (typeof proto === 'undefined') {\n                        return null;\n                    }\n                    return proto ? getTransferablePointer(proto) : proto;\n                }, (targetPointer, key) => {\n                    targetPointer();\n                    const target = selectedTarget;\n                    selectedTarget = undefined;\n                    try {\n                        return key in target;\n                    }\n                    catch (error) {\n                        throw pushErrorAcrossBoundary(error);\n                    }\n                }, (targetPointer) => {\n                    targetPointer();\n                    const target = selectedTarget;\n                    selectedTarget = undefined;\n                    try {\n                        return ReflectIsExtensible(target);\n                    }\n                    catch (error) {\n                        throw pushErrorAcrossBoundary(error);\n                    }\n                }, (targetPointer, foreignCallableKeysCallback) => {\n                    targetPointer();\n                    const target = selectedTarget;\n                    selectedTarget = undefined;\n                    let ownKeys;\n                    try {\n                        ownKeys = ReflectOwnKeys(target);\n                    }\n                    catch (error) {\n                        throw pushErrorAcrossBoundary(error);\n                    }\n                    ReflectApply(foreignCallableKeysCallback, undefined, ownKeys);\n                }, (targetPointer) => {\n                    targetPointer();\n                    const target = selectedTarget;\n                    selectedTarget = undefined;\n                    let result = 2; /* PreventExtensionsResult.False */\n                    try {\n                        if (ReflectPreventExtensions(target)) {\n                            result = 4; /* PreventExtensionsResult.True */\n                        }\n                        else if (ReflectIsExtensible(target)) {\n                            result |= 1; /* PreventExtensionsResult.Extensible */\n                        }\n                    }\n                    catch (error) {\n                        throw pushErrorAcrossBoundary(error);\n                    }\n                    return result;\n                }, (targetPointer, key, valuePointerOrPrimitive, receiverPointerOrPrimitive) => {\n                    targetPointer();\n                    const target = selectedTarget;\n                    selectedTarget = undefined;\n                    let value;\n                    if (typeof valuePointerOrPrimitive === 'function') {\n                        valuePointerOrPrimitive();\n                        value = selectedTarget;\n                        selectedTarget = undefined;\n                    }\n                    else {\n                        value = valuePointerOrPrimitive;\n                    }\n                    let receiver;\n                    if (typeof receiverPointerOrPrimitive === 'function') {\n                        receiverPointerOrPrimitive();\n                        receiver = selectedTarget;\n                        selectedTarget = undefined;\n                    }\n                    else {\n                        receiver =\n                            receiverPointerOrPrimitive === LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL\n                                ? target\n                                : receiverPointerOrPrimitive;\n                    }\n                    try {\n                        return ReflectSet(target, key, value, receiver);\n                    }\n                    catch (error) {\n                        throw pushErrorAcrossBoundary(error);\n                    }\n                }, (targetPointer, protoPointerOrNull = null) => {\n                    targetPointer();\n                    const target = selectedTarget;\n                    selectedTarget = undefined;\n                    let proto;\n                    if (typeof protoPointerOrNull === 'function') {\n                        protoPointerOrNull();\n                        proto = selectedTarget;\n                        selectedTarget = undefined;\n                    }\n                    else {\n                        proto = null;\n                    }\n                    try {\n                        return ReflectSetPrototypeOf(target, proto);\n                    }\n                    catch (error) {\n                        throw pushErrorAcrossBoundary(error);\n                    }\n                }, LOCKER_DEBUGGABLE_FLAG\n                    ? (...args) => {\n                        if (checkDebugMode()) {\n                            for (let i = 0, { length } = args; i < length; i += 1) {\n                                const pointerOrPrimitive = args[i];\n                                if (typeof pointerOrPrimitive === 'function') {\n                                    pointerOrPrimitive();\n                                    args[i] = selectedTarget;\n                                    selectedTarget = undefined;\n                                }\n                            }\n                            try {\n                                ReflectApply(consoleInfo, consoleObject, args); // eslint-disable-next-line no-empty\n                            }\n                            catch (_unused29) { }\n                        }\n                    }\n                    : noop, IS_IN_SHADOW_REALM\n                    ? (targetPointer, ...descriptorTuples) => {\n                        targetPointer();\n                        const target = selectedTarget;\n                        selectedTarget = undefined;\n                        for (let i = 0, { length } = descriptorTuples; i < length; i += 7) {\n                            // We don't use `ObjectDefineProperties()` here because it\n                            // will throw an exception if it fails to define one of its\n                            // properties.\n                            ReflectDefineProperty(target, descriptorTuples[i], createDescriptorFromMeta(descriptorTuples[i + 1], descriptorTuples[i + 2], descriptorTuples[i + 3], descriptorTuples[i + 4], descriptorTuples[i + 5], descriptorTuples[i + 6]));\n                        }\n                    }\n                    : noop, !IS_IN_SHADOW_REALM\n                    ? (targetPointer) => {\n                        targetPointer();\n                        const target = selectedTarget;\n                        selectedTarget = undefined; // We don't wrap the weak map `get()` call in a try-catch\n                        // because we know `target` is an object.\n                        const state = __.proxyTargetToLazyPropertyDescriptorStateMap.get(target);\n                        return state ? getTransferablePointer(state) : state;\n                    }\n                    : noop, !IS_IN_SHADOW_REALM\n                    ? (targetPointer, index) => {\n                        targetPointer();\n                        const target = selectedTarget;\n                        selectedTarget = undefined;\n                        try {\n                            return target[index];\n                        }\n                        catch (error) {\n                            throw pushErrorAcrossBoundary(error);\n                        }\n                    }\n                    : noop, !IS_IN_SHADOW_REALM\n                    ? (targetPointer) => {\n                        targetPointer();\n                        const target = selectedTarget;\n                        selectedTarget = undefined; // A target may be a proxy that is revoked or throws in its\n                        // \"isExtensible\" trap.\n                        try {\n                            if (!ReflectIsExtensible(target)) {\n                                if (ObjectIsFrozen(target)) {\n                                    return 4 & 2 & 1; /* TargetIntegrityTraits.IsNotExtensible */\n                                }\n                                if (ObjectIsSealed(target)) {\n                                    return 2 & 1; /* TargetIntegrityTraits.IsNotExtensible */\n                                }\n                                return 1; /* TargetIntegrityTraits.IsNotExtensible */\n                            }\n                        }\n                        catch (_unused30) {\n                            try {\n                                isArrayOrThrowForRevoked(target);\n                            }\n                            catch (_unused31) {\n                                return 8; /* TargetIntegrityTraits.Revoked */\n                            }\n                        }\n                        return 0; /* TargetIntegrityTraits.None */\n                    }\n                    : () => 0, (targetPointer) => {\n                    targetPointer();\n                    const target = selectedTarget;\n                    selectedTarget = undefined;\n                    try {\n                        // Section 19.1.3.6 Object.prototype.toString()\n                        // https://tc39.github.io/ecma262/#sec-object.prototype.tostring\n                        const brand = ReflectApply(ObjectProtoToString, target, []);\n                        return brand === '[object Object]'\n                            ? 'Object'\n                            : ReflectApply(StringProtoSlice, brand, [8, -1]);\n                    }\n                    catch (error) {\n                        throw pushErrorAcrossBoundary(error);\n                    }\n                }, installErrorPrepareStackTrace, IS_IN_SHADOW_REALM\n                    ? (targetPointer, ...ownKeysAndUnforgeableGlobalThisKeys) => {\n                        const sliceIndex = ReflectApply(ArrayProtoIndexOf, ownKeysAndUnforgeableGlobalThisKeys, [\n                            LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL,\n                        ]);\n                        let ownKeys;\n                        let unforgeableGlobalThisKeys;\n                        if (sliceIndex === -1) {\n                            ownKeys = ownKeysAndUnforgeableGlobalThisKeys;\n                        }\n                        else {\n                            ownKeys = ReflectApply(ArrayProtoSlice, ownKeysAndUnforgeableGlobalThisKeys, [\n                                0,\n                                sliceIndex,\n                            ]);\n                            unforgeableGlobalThisKeys = ReflectApply(ArrayProtoSlice, ownKeysAndUnforgeableGlobalThisKeys, [sliceIndex + 1]);\n                        }\n                        targetPointer();\n                        const target = selectedTarget;\n                        selectedTarget = undefined;\n                        let state = getLazyPropertyDescriptorStateByTarget(target);\n                        if (state === undefined) {\n                            state = {\n                                __proto__: null,\n                            };\n                            setLazyPropertyDescriptorStateByTarget(target, state);\n                        }\n                        for (let i = 0, { length } = ownKeys; i < length; i += 1) {\n                            const ownKey = ownKeys[i];\n                            state[ownKey] = true;\n                            ReflectDefineProperty(target, ownKey, // bouncer. When either a getter or a setter is\n                            // invoked the descriptor will be replaced with\n                            // the descriptor from the foreign side and the\n                            // get/set operation will carry on from there.\n                            {\n                                __proto__: null,\n                                // We DO explicitly set configurability in the\n                                // off chance that the property doesn't exist.\n                                configurable: true,\n                                // We DON'T explicitly set enumerability to\n                                // defer to the enumerability of the existing\n                                // property. In the off chance the property\n                                // doesn't exist the property will be defined\n                                // as non-enumerable.\n                                get() {\n                                    activateLazyOwnPropertyDefinition(target, ownKey, state);\n                                    return target[ownKey];\n                                },\n                                set(value) {\n                                    activateLazyOwnPropertyDefinition(target, ownKey, state);\n                                    ReflectSet(target, ownKey, value);\n                                },\n                            });\n                        }\n                        installPropertyDescriptorMethodWrappers(unforgeableGlobalThisKeys);\n                    }\n                    : noop, !IS_IN_SHADOW_REALM && liveTargetCallback\n                    ? (targetPointer, targetTraits) => {\n                        targetPointer();\n                        const target = selectedTarget;\n                        selectedTarget = undefined;\n                        if (target !== ObjectProto && target !== RegExpProto) {\n                            try {\n                                return liveTargetCallback(target, targetTraits); // eslint-disable-next-line no-empty\n                            }\n                            catch (_unused32) { }\n                        }\n                        return false;\n                    }\n                    : alwaysFalse, !IS_IN_SHADOW_REALM\n                    ? (targetPointer) => {\n                        targetPointer();\n                        const target = selectedTarget;\n                        selectedTarget = undefined;\n                        try {\n                            isArrayOrThrowForRevoked(target);\n                            return false; //  eslint-disable-next-line no-empty\n                        }\n                        catch (_unused33) { }\n                        return true;\n                    }\n                    : alwaysFalse, IS_IN_SHADOW_REALM\n                    ? (targetPointer) => {\n                        targetPointer();\n                        const target = selectedTarget;\n                        selectedTarget = undefined;\n                        try {\n                            return SymbolToStringTag in target\n                                ? serializeTargetByTrialAndError(target)\n                                : serializeTargetByBrand(target); // eslint-disable-next-line no-empty\n                        }\n                        catch (_unused34) { }\n                        return undefined;\n                    }\n                    : noop, !IS_IN_SHADOW_REALM\n                    ? (targetPointer, statePointer) => {\n                        targetPointer();\n                        const target = selectedTarget;\n                        selectedTarget = undefined;\n                        statePointer();\n                        const state = selectedTarget;\n                        selectedTarget = undefined; // We don't wrap the weak map `set()` call in a try-catch\n                        // because we know `target` is an object.\n                        __.proxyTargetToLazyPropertyDescriptorStateMap.set(target, state);\n                    }\n                    : noop, !IS_IN_SHADOW_REALM\n                    ? (targetPointer) => {\n                        targetPointer();\n                        const target = selectedTarget;\n                        selectedTarget = undefined;\n                        if (useFastForeignTargetPath) {\n                            fastForeignTargetPointers.add(getTransferablePointer(target));\n                        }\n                    }\n                    : noop, (targetPointer, foreignCallableDescriptorsCallback) => {\n                    targetPointer();\n                    const target = selectedTarget;\n                    selectedTarget = undefined;\n                    let unsafeDescMap;\n                    try {\n                        unsafeDescMap = ObjectGetOwnPropertyDescriptors(target);\n                    }\n                    catch (error) {\n                        throw pushErrorAcrossBoundary(error);\n                    }\n                    const ownKeys = ReflectOwnKeys(unsafeDescMap);\n                    const { length } = ownKeys;\n                    const descriptorTuples = new ArrayCtor(length * 7);\n                    for (let i = 0, j = 0; i < length; i += 1, j += 7) {\n                        const ownKey = ownKeys[i];\n                        const safeDesc = unsafeDescMap[ownKey];\n                        ReflectSetPrototypeOf(safeDesc, null);\n                        const { get: getter, set: setter, value: value1 } = safeDesc;\n                        descriptorTuples[j] = ownKey;\n                        descriptorTuples[j + 1] =\n                            'configurable' in safeDesc\n                                ? safeDesc.configurable\n                                : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL;\n                        descriptorTuples[j + 2] =\n                            'enumerable' in safeDesc\n                                ? safeDesc.enumerable\n                                : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL;\n                        descriptorTuples[j + 3] =\n                            'writable' in safeDesc ? safeDesc.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL;\n                        descriptorTuples[j + 4] =\n                            'value' in safeDesc\n                                ? (typeof value1 === 'object' && value1 !== null) || typeof value1 === 'function'\n                                    ? getTransferablePointer(value1)\n                                    : value1\n                                : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL;\n                        descriptorTuples[j + 5] =\n                            'get' in safeDesc\n                                ? typeof getter === 'function'\n                                    ? getTransferablePointer(getter)\n                                    : getter\n                                : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL;\n                        descriptorTuples[j + 6] =\n                            'set' in safeDesc\n                                ? typeof setter === 'function'\n                                    ? getTransferablePointer(setter)\n                                    : setter\n                                : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL;\n                    }\n                    ReflectApply(foreignCallableDescriptorsCallback, undefined, descriptorTuples);\n                    let proto;\n                    try {\n                        proto = ReflectGetPrototypeOf(target);\n                    }\n                    catch (error) {\n                        throw pushErrorAcrossBoundary(error);\n                    } // Intentionally ignoring `document.all`.\n                    // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                    // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                    if (typeof proto === 'undefined') {\n                        return null;\n                    }\n                    return proto ? getTransferablePointer(proto) : proto;\n                }, (targetPointer, key) => {\n                    targetPointer();\n                    const target = selectedTarget;\n                    selectedTarget = undefined;\n                    let proto;\n                    try {\n                        if (ObjectHasOwn(target, key)) {\n                            return true;\n                        }\n                        proto = ReflectGetPrototypeOf(target);\n                    }\n                    catch (error) {\n                        throw pushErrorAcrossBoundary(error);\n                    } // Intentionally ignoring `document.all`.\n                    // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                    // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                    if (typeof proto === 'undefined') {\n                        return null;\n                    }\n                    return proto ? getTransferablePointer(proto) : proto;\n                }, (targetPointer, key, foreignCallableDescriptorCallback) => {\n                    targetPointer();\n                    const target = selectedTarget;\n                    selectedTarget = undefined;\n                    let safeDesc;\n                    try {\n                        safeDesc = ReflectGetOwnPropertyDescriptor(target, key);\n                    }\n                    catch (error) {\n                        throw pushErrorAcrossBoundary(error);\n                    }\n                    if (safeDesc) {\n                        ReflectSetPrototypeOf(safeDesc, null);\n                        const { get: getter, set: setter, value: value1 } = safeDesc;\n                        foreignCallableDescriptorCallback(key, 'configurable' in safeDesc\n                            ? safeDesc.configurable\n                            : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL, 'enumerable' in safeDesc\n                            ? safeDesc.enumerable\n                            : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL, 'writable' in safeDesc\n                            ? safeDesc.writable\n                            : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL, 'value' in safeDesc\n                            ? (typeof value1 === 'object' && value1 !== null) || typeof value1 === 'function'\n                                ? getTransferablePointer(value1) // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                                : // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                                    typeof value1 === 'undefined'\n                                        ? undefined\n                                        : value1\n                            : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL, 'get' in safeDesc\n                            ? typeof getter === 'function'\n                                ? getTransferablePointer(getter)\n                                : getter\n                            : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL, 'set' in safeDesc\n                            ? typeof setter === 'function'\n                                ? getTransferablePointer(setter)\n                                : setter\n                            : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL);\n                        return undefined;\n                    }\n                    let proto;\n                    try {\n                        proto = ReflectGetPrototypeOf(target);\n                    }\n                    catch (error) {\n                        throw pushErrorAcrossBoundary(error);\n                    } // Intentionally ignoring `document.all`.\n                    // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n                    // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n                    if (typeof proto === 'undefined') {\n                        return null;\n                    }\n                    return proto ? getTransferablePointer(proto) : proto;\n                });\n                let foreignCallablesHooked = false;\n                return (...hooks) => {\n                    if (foreignCallablesHooked) {\n                        return;\n                    }\n                    foreignCallablesHooked = true;\n                    ({\n                        // 0: globalThisPointer,\n                        // 1: getSelectedTarget,\n                        // 2: getTransferableValue,\n                        // 3: callableGetPropertyValuePointer,\n                        // 4: callableEvaluate,\n                        // 5: callableLinkPointers,\n                        6: foreignCallablePushErrorTarget,\n                        7: foreignCallablePushTarget,\n                        8: foreignCallableApply,\n                        9: foreignCallableConstruct,\n                        10: foreignCallableDefineProperty,\n                        11: foreignCallableDeleteProperty,\n                        12: foreignCallableGet,\n                        13: foreignCallableGetOwnPropertyDescriptor,\n                        14: foreignCallableGetPrototypeOf,\n                        15: foreignCallableHas,\n                        16: foreignCallableIsExtensible,\n                        17: foreignCallableOwnKeys,\n                        18: foreignCallablePreventExtensions,\n                        19: foreignCallableSet,\n                        20: foreignCallableSetPrototypeOf,\n                        21: foreignCallableDebugInfo,\n                        23: foreignCallableGetLazyPropertyDescriptorStateByTarget,\n                        24: foreignCallableGetPropertyValue,\n                        25: foreignCallableGetTargetIntegrityTraits,\n                        26: foreignCallableGetToStringTagOfTarget,\n                        27: foreignCallableInstallErrorPrepareStackTrace,\n                        29: foreignCallableIsTargetLive,\n                        30: foreignCallableIsTargetRevoked,\n                        31: foreignCallableSerializeTarget,\n                        32: foreignCallableSetLazyPropertyDescriptorStateByTarget,\n                        34: foreignCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors,\n                        35: foreignCallableBatchGetPrototypeOfWhenHasNoOwnProperty,\n                        36: foreignCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor,\n                    } = hooks);\n                    const applyTrapForZeroOrMoreArgs = createApplyOrConstructTrapForZeroOrMoreArgs(1);\n                    const applyTrapForOneOrMoreArgs = createApplyOrConstructTrapForOneOrMoreArgs(1);\n                    const applyTrapForTwoOrMoreArgs = createApplyOrConstructTrapForTwoOrMoreArgs(1);\n                    const applyTrapForThreeOrMoreArgs = createApplyOrConstructTrapForThreeOrMoreArgs(1);\n                    const applyTrapForFourOrMoreArgs = createApplyOrConstructTrapForFourOrMoreArgs(1);\n                    const applyTrapForFiveOrMoreArgs = createApplyOrConstructTrapForFiveOrMoreArgs(1);\n                    const applyTrapForAnyNumberOfArgs = createApplyOrConstructTrapForAnyNumberOfArgs(1);\n                    const constructTrapForZeroOrMoreArgs = createApplyOrConstructTrapForZeroOrMoreArgs(2);\n                    const constructTrapForOneOrMoreArgs = createApplyOrConstructTrapForOneOrMoreArgs(2);\n                    const constructTrapForTwoOrMoreArgs = createApplyOrConstructTrapForTwoOrMoreArgs(2);\n                    const constructTrapForThreeOrMoreArgs = createApplyOrConstructTrapForThreeOrMoreArgs(2);\n                    const constructTrapForFourOrMoreArgs = createApplyOrConstructTrapForFourOrMoreArgs(2);\n                    const constructTrapForFiveOrMoreArgs = createApplyOrConstructTrapForFiveOrMoreArgs(2);\n                    const constructTrapForAnyNumberOfArgs = createApplyOrConstructTrapForAnyNumberOfArgs(2);\n                    if (MINIFICATION_SAFE_TRAP_PROPERTY_NAMES === undefined) {\n                        // A minification safe way to get the 'apply' and 'construct'\n                        // trap property names.\n                        MINIFICATION_SAFE_TRAP_PROPERTY_NAMES = ObjectKeys({\n                            applyTrapForZeroOrMoreArgs,\n                            applyTrapForOneOrMoreArgs,\n                            applyTrapForTwoOrMoreArgs,\n                            applyTrapForThreeOrMoreArgs,\n                            applyTrapForFourOrMoreArgs,\n                            applyTrapForFiveOrMoreArgs,\n                            applyTrapForAnyNumberOfArgs,\n                            constructTrapForZeroOrMoreArgs,\n                            constructTrapForOneOrMoreArgs,\n                            constructTrapForTwoOrMoreArgs,\n                            constructTrapForThreeOrMoreArgs,\n                            constructTrapForFourOrMoreArgs,\n                            constructTrapForFiveOrMoreArgs,\n                            constructTrapForAnyNumberOfArgs,\n                        });\n                    }\n                    arityToApplyTrapNameRegistry[0] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES[0];\n                    arityToApplyTrapNameRegistry[1] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES[1];\n                    arityToApplyTrapNameRegistry[2] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES[2];\n                    arityToApplyTrapNameRegistry[3] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES[3];\n                    arityToApplyTrapNameRegistry[4] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES[4];\n                    arityToApplyTrapNameRegistry[5] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES[5];\n                    arityToApplyTrapNameRegistry.n = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES[6];\n                    arityToConstructTrapNameRegistry[0] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES[7];\n                    arityToConstructTrapNameRegistry[1] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES[8];\n                    arityToConstructTrapNameRegistry[2] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES[9];\n                    arityToConstructTrapNameRegistry[3] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES[10];\n                    arityToConstructTrapNameRegistry[4] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES[11];\n                    arityToConstructTrapNameRegistry[5] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES[12];\n                    arityToConstructTrapNameRegistry.n = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES[13];\n                    const { prototype: BoundaryProxyHandlerProto } = BoundaryProxyHandler;\n                    BoundaryProxyHandlerProto[arityToApplyTrapNameRegistry[0]] = applyTrapForZeroOrMoreArgs;\n                    BoundaryProxyHandlerProto[arityToApplyTrapNameRegistry[1]] = applyTrapForOneOrMoreArgs;\n                    BoundaryProxyHandlerProto[arityToApplyTrapNameRegistry[2]] = applyTrapForTwoOrMoreArgs;\n                    BoundaryProxyHandlerProto[arityToApplyTrapNameRegistry[3]] = applyTrapForThreeOrMoreArgs;\n                    BoundaryProxyHandlerProto[arityToApplyTrapNameRegistry[4]] = applyTrapForFourOrMoreArgs;\n                    BoundaryProxyHandlerProto[arityToApplyTrapNameRegistry[5]] = applyTrapForFiveOrMoreArgs;\n                    BoundaryProxyHandlerProto[arityToApplyTrapNameRegistry.n] = applyTrapForAnyNumberOfArgs;\n                    BoundaryProxyHandlerProto[arityToConstructTrapNameRegistry[0]] = constructTrapForZeroOrMoreArgs;\n                    BoundaryProxyHandlerProto[arityToConstructTrapNameRegistry[1]] = constructTrapForOneOrMoreArgs;\n                    BoundaryProxyHandlerProto[arityToConstructTrapNameRegistry[2]] = constructTrapForTwoOrMoreArgs;\n                    BoundaryProxyHandlerProto[arityToConstructTrapNameRegistry[3]] = constructTrapForThreeOrMoreArgs;\n                    BoundaryProxyHandlerProto[arityToConstructTrapNameRegistry[4]] = constructTrapForFourOrMoreArgs;\n                    BoundaryProxyHandlerProto[arityToConstructTrapNameRegistry[5]] = constructTrapForFiveOrMoreArgs;\n                    BoundaryProxyHandlerProto[arityToConstructTrapNameRegistry.n] = constructTrapForAnyNumberOfArgs;\n                    ReflectSetPrototypeOf(BoundaryProxyHandlerProto, null); // Future optimization: Hoping proxies with frozen handlers can be faster.\n                    ObjectFreeze(BoundaryProxyHandlerProto);\n                };\n            };\n            /* eslint-enable prefer-object-spread */\n        }\n        __.default = createMembraneMarshall;\n    },\n};\n","import lib from './createMembraneMarshall.js';\nconst connectorMap = /*#__PURE__*/ new WeakMap();\nconst debuggerMap = /*#__PURE__*/ new WeakMap();\nexport function createConnector(globalThis, isMainIsolate, allowDebug = false) {\n    if (connectorMap.has(globalThis))\n        return connectorMap.get(globalThis);\n    let f;\n    lib.execute({\n        set default(value) {\n            f = value;\n        },\n        debugTargetBookkeeping: allowDebug ? debuggerMap.set.bind(debuggerMap) : undefined,\n        attachDebuggerTarget: allowDebug ? TransferablePointerTarget.attachDebuggerTarget : undefined,\n        proxyTargetToLazyPropertyDescriptorStateMap: isMainIsolate ? new WeakMap() : undefined,\n    }, { globalThis });\n    const connector = f(isMainIsolate ? globalThis : undefined);\n    connectorMap.set(globalThis, connector);\n    return connector;\n}\n// @ts-ignore\nclass TransferablePointerTarget extends function (f) {\n    return f;\n} {\n    constructor(obj) {\n        super(obj);\n    }\n    // Note: This field MUST NOT be read. otherwise it might break the isolation.\n    #Target;\n    static attachDebuggerTarget(key, target) {\n        if (!debuggerMap.has(target))\n            return;\n        // Note: although attach a private field might fail (https://github.com/tc39/ecma262/pull/2807)\n        // but key should always be a proxy, therefore 2807 does not apply.\n        // It's also impossible to call on the same target twice because we only call it for newly created Proxy.\n        new TransferablePointerTarget(key);\n        key.#Target = debuggerMap.get(target);\n    }\n}\n","import { assignFilteredGlobalDescriptorsFromPropertyDescriptorMap, getFilteredGlobalOwnKeys, linkIntrinsics, VirtualEnvironment, } from '@locker/near-membrane-base';\nimport { createConnector } from './membrane.js';\nconst ObjectCtor = Object;\nconst { assign: ObjectAssign } = ObjectCtor;\nconst TypeErrorCtor = TypeError;\nlet defaultGlobalOwnKeys = null;\nexport default function createVirtualEnvironment(globalObject, redGlobalObject, options) {\n    if (typeof globalObject !== 'object' || globalObject === null) {\n        throw new TypeErrorCtor('Missing global object virtualization target.');\n    }\n    const { distortionCallback, endowments, globalObjectShape, instrumentation, debugPrivateFieldAttach = true, } = ObjectAssign({ __proto__: null }, options);\n    const blueConnector = createConnector(globalObject, true, debugPrivateFieldAttach);\n    const env = new VirtualEnvironment({\n        blueConnector,\n        distortionCallback: distortionCallback,\n        instrumentation: instrumentation,\n        redConnector: createConnector(redGlobalObject, false, debugPrivateFieldAttach),\n    });\n    linkIntrinsics(env, globalObject);\n    const shouldUseDefaultGlobalOwnKeys = typeof globalObjectShape !== 'object' || globalObjectShape === null;\n    if (shouldUseDefaultGlobalOwnKeys && defaultGlobalOwnKeys === null) {\n        defaultGlobalOwnKeys = getFilteredGlobalOwnKeys(redGlobalObject);\n    }\n    env.lazyRemapProperties(globalObject, shouldUseDefaultGlobalOwnKeys ? defaultGlobalOwnKeys : getFilteredGlobalOwnKeys(globalObjectShape));\n    if (endowments) {\n        const filteredEndowments = {};\n        assignFilteredGlobalDescriptorsFromPropertyDescriptorMap(filteredEndowments, endowments);\n        env.remapProperties(globalObject, filteredEndowments);\n    }\n    // we patched it's evaluate method to receive a method instead of a string.\n    return {\n        execute(f) {\n            return env.evaluate(f);\n        },\n        virtualEnvironment: env,\n    };\n}\n","export { default } from './evaluator.js';\nexport {} from '@locker/near-membrane-base';\n"],"names":[],"sourceRoot":"","x_google_ignoreList":[]}