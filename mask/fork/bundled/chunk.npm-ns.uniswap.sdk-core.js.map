{"version":3,"file":"bundled/chunk.npm-ns.uniswap.sdk-core.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAwB;AACe;AACC;AACd;AACM;AACoB;;AAEpD;;AAEA;AACA;AACA;AACA,CAAC,8BAA8B;;AAE/B;;AAEA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;;AAE7B,8BAA8B,kDAAW;;AAEzC;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,+CAAQ,CAAC,yDAAQ;AAC5C,uBAAuB,+CAAQ,CAAC,+CAAI;AACpC,uDAAuD;AACvD,4CAA4C;AAC5C;AACA;AACA;AACA,oBAAoB,kDAAW;AAC/B;;AAEA,qBAAqB,kDAAW;AAChC,uBAAuB,kDAAW;AAClC;;AAEA;AACA,+BAA+B,6CAAI;AACnC;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,QAAQ,iDAAU;AAClB,0BAA0B,+CAAQ;AAClC;;AAEA,wBAAwB,+CAAQ,CAAC,oDAAa,2CAA2C,oDAAa,4CAA4C,oDAAa;AAC/J;;AAEA;AACA;;AAEA,QAAQ,iDAAU;AAClB,0BAA0B,oDAAa;AACvC;;AAEA,wBAAwB,oDAAa,CAAC,oDAAa,2CAA2C,oDAAa,4CAA4C,oDAAa;AACpK;;AAEA;AACA;AACA,WAAW,oDAAa,CAAC,oDAAa,2CAA2C,oDAAa;AAC9F;;AAEA;AACA;AACA,WAAW,iDAAU,CAAC,oDAAa,2CAA2C,oDAAa;AAC3F;;AAEA;AACA;AACA,WAAW,uDAAgB,CAAC,oDAAa,2CAA2C,oDAAa;AACjG;;AAEA;AACA;AACA,wBAAwB,oDAAa,yCAAyC,oDAAa;AAC3F;;AAEA;AACA;AACA,wBAAwB,oDAAa,2CAA2C,oDAAa;AAC7F;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2CAA2C,MAAqC,GAAG,CAA2D,GAAG,mEAAS;AAC1J,+BAA+B,MAAqC,GAAG,CAAyD,GAAG,mEAAS;AAC5I;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uCAAuC,MAAqC,GAAG,CAAuD,GAAG,mEAAS;AAClJ,4BAA4B,MAAqC,GAAG,CAAiD,GAAG,mEAAS;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,kDAAW;AACxB,MAAM;;AAEN,GAAG;AACH;AACA;AACA,0BAA0B,qDAAc;AACxC;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED,yBAAyB,+CAAQ,CAAC,+CAAI;AACtC;AACA;;AAEA;AACA;;AAEA;AACA,KAAK,2DAAoB,+BAA+B,MAAqC,GAAG,CAA0B,GAAG,mEAAS;AACtI;AACA,yBAAyB,wDAAiB,CAAC,kDAAW,MAAM,kDAAW;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,4CAA4C,MAAqC,GAAG,CAA4B,GAAG,mEAAS;;AAE5H;;AAEA;AACA;;AAEA;AACA,4CAA4C,MAAqC,GAAG,CAA4B,GAAG,mEAAS;;AAE5H;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iDAAiD,MAAqC,GAAG,CAA4B,GAAG,mEAAS;AACjI;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED,0DAA0D,kDAAW;AACrE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,wEAAwE,aAAa;AACrF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC,wDAAiB,CAAC,kDAAW,MAAM,kDAAW,0BAA0B,wDAAiB,CAAC,kDAAW,MAAM,kDAAW;AACtJ;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qDAAqD,MAAqC,GAAG,CAAyB,GAAG,mEAAS;;AAElI;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yDAAyD,MAAqC,GAAG,CAAyB,GAAG,mEAAS;;AAEtI;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,MAAqC,GAAG,CAA4B,GAAG,mEAAS;AACnH,qEAAqE,MAAqC,GAAG,CAA4B,GAAG,mEAAS;AACrJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,4EAAU;AACrB,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,MAAqC,GAAG,CAA6B,GAAG,mEAAS;AACzH,wCAAwC,MAAqC,GAAG,CAA6B,GAAG,mEAAS;AACzH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA,uBAAuB;;AAEvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,MAAqC,GAAG,CAA2B,GAAG,mEAAS;AAChG;AACA;AACA,GAAG;;AAEH;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wDAAwD;;AAExD;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,MAAqC,GAAG,CAAiC,GAAG,mEAAS,kBAAkB;;AAE1H,+BAA+B,MAAqC,GAAG,CAA8B,GAAG,mEAAS,kBAAkB;;AAEnI;AACA;AACA;AACA,IAAI;AACJ,2CAA2C;;AAE3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oCAAoC,kDAAW;AAC/C,wBAAwB,kDAAW;AACnC,uBAAuB,kDAAW;AAClC,uBAAuB,kDAAW;AAClC;AACA;AACA;AACA;;AAEA;AACA,GAAG,8DAAuB,gBAAgB,MAAqC,GAAG,CAA4B,GAAG,mEAAS,kBAAkB;;AAE5I,MAAM,oDAAa;AACnB,WAAW,kDAAW,sBAAsB,oDAAa;AACzD;;AAEA;AACA;AACA;AACA,MAAM,+CAAQ,CAAC,kDAAW;;AAE1B,SAAS,oDAAa;AACtB;AACA,QAAQ,kDAAW,CAAC,+CAAQ,CAAC,kDAAW;AACxC;;AAEA;AACA;;AAE2L","sources":["webpack://mask-network/./node_modules/.pnpm/@uniswap+sdk-core@3.0.1/node_modules/@uniswap/sdk-core/dist/sdk-core.esm.js"],"sourcesContent":["import JSBI from 'jsbi';\nimport invariant from 'tiny-invariant';\nimport _Decimal from 'decimal.js-light';\nimport _Big from 'big.js';\nimport toFormat from 'toformat';\nimport { getAddress } from '@ethersproject/address';\n\nvar TradeType;\n\n(function (TradeType) {\n  TradeType[TradeType[\"EXACT_INPUT\"] = 0] = \"EXACT_INPUT\";\n  TradeType[TradeType[\"EXACT_OUTPUT\"] = 1] = \"EXACT_OUTPUT\";\n})(TradeType || (TradeType = {}));\n\nvar Rounding;\n\n(function (Rounding) {\n  Rounding[Rounding[\"ROUND_DOWN\"] = 0] = \"ROUND_DOWN\";\n  Rounding[Rounding[\"ROUND_HALF_UP\"] = 1] = \"ROUND_HALF_UP\";\n  Rounding[Rounding[\"ROUND_UP\"] = 2] = \"ROUND_UP\";\n})(Rounding || (Rounding = {}));\n\nvar MaxUint256 = /*#__PURE__*/JSBI.BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar _toSignificantRoundin, _toFixedRounding;\nvar Decimal = /*#__PURE__*/toFormat(_Decimal);\nvar Big = /*#__PURE__*/toFormat(_Big);\nvar toSignificantRounding = (_toSignificantRoundin = {}, _toSignificantRoundin[Rounding.ROUND_DOWN] = Decimal.ROUND_DOWN, _toSignificantRoundin[Rounding.ROUND_HALF_UP] = Decimal.ROUND_HALF_UP, _toSignificantRoundin[Rounding.ROUND_UP] = Decimal.ROUND_UP, _toSignificantRoundin);\nvar toFixedRounding = (_toFixedRounding = {}, _toFixedRounding[Rounding.ROUND_DOWN] = 0, _toFixedRounding[Rounding.ROUND_HALF_UP] = 1, _toFixedRounding[Rounding.ROUND_UP] = 3, _toFixedRounding);\nvar Fraction = /*#__PURE__*/function () {\n  function Fraction(numerator, denominator) {\n    if (denominator === void 0) {\n      denominator = JSBI.BigInt(1);\n    }\n\n    this.numerator = JSBI.BigInt(numerator);\n    this.denominator = JSBI.BigInt(denominator);\n  }\n\n  Fraction.tryParseFraction = function tryParseFraction(fractionish) {\n    if (fractionish instanceof JSBI || typeof fractionish === 'number' || typeof fractionish === 'string') return new Fraction(fractionish);\n    if ('numerator' in fractionish && 'denominator' in fractionish) return fractionish;\n    throw new Error('Could not parse fraction');\n  } // performs floor division\n  ;\n\n  var _proto = Fraction.prototype;\n\n  _proto.invert = function invert() {\n    return new Fraction(this.denominator, this.numerator);\n  };\n\n  _proto.add = function add(other) {\n    var otherParsed = Fraction.tryParseFraction(other);\n\n    if (JSBI.equal(this.denominator, otherParsed.denominator)) {\n      return new Fraction(JSBI.add(this.numerator, otherParsed.numerator), this.denominator);\n    }\n\n    return new Fraction(JSBI.add(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator)), JSBI.multiply(this.denominator, otherParsed.denominator));\n  };\n\n  _proto.subtract = function subtract(other) {\n    var otherParsed = Fraction.tryParseFraction(other);\n\n    if (JSBI.equal(this.denominator, otherParsed.denominator)) {\n      return new Fraction(JSBI.subtract(this.numerator, otherParsed.numerator), this.denominator);\n    }\n\n    return new Fraction(JSBI.subtract(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator)), JSBI.multiply(this.denominator, otherParsed.denominator));\n  };\n\n  _proto.lessThan = function lessThan(other) {\n    var otherParsed = Fraction.tryParseFraction(other);\n    return JSBI.lessThan(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));\n  };\n\n  _proto.equalTo = function equalTo(other) {\n    var otherParsed = Fraction.tryParseFraction(other);\n    return JSBI.equal(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));\n  };\n\n  _proto.greaterThan = function greaterThan(other) {\n    var otherParsed = Fraction.tryParseFraction(other);\n    return JSBI.greaterThan(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));\n  };\n\n  _proto.multiply = function multiply(other) {\n    var otherParsed = Fraction.tryParseFraction(other);\n    return new Fraction(JSBI.multiply(this.numerator, otherParsed.numerator), JSBI.multiply(this.denominator, otherParsed.denominator));\n  };\n\n  _proto.divide = function divide(other) {\n    var otherParsed = Fraction.tryParseFraction(other);\n    return new Fraction(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(this.denominator, otherParsed.numerator));\n  };\n\n  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {\n    if (format === void 0) {\n      format = {\n        groupSeparator: ''\n      };\n    }\n\n    if (rounding === void 0) {\n      rounding = Rounding.ROUND_HALF_UP;\n    }\n\n    !Number.isInteger(significantDigits) ? process.env.NODE_ENV !== \"production\" ? invariant(false, significantDigits + \" is not an integer.\") : invariant(false) : void 0;\n    !(significantDigits > 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, significantDigits + \" is not positive.\") : invariant(false) : void 0;\n    Decimal.set({\n      precision: significantDigits + 1,\n      rounding: toSignificantRounding[rounding]\n    });\n    var quotient = new Decimal(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(significantDigits);\n    return quotient.toFormat(quotient.decimalPlaces(), format);\n  };\n\n  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {\n    if (format === void 0) {\n      format = {\n        groupSeparator: ''\n      };\n    }\n\n    if (rounding === void 0) {\n      rounding = Rounding.ROUND_HALF_UP;\n    }\n\n    !Number.isInteger(decimalPlaces) ? process.env.NODE_ENV !== \"production\" ? invariant(false, decimalPlaces + \" is not an integer.\") : invariant(false) : void 0;\n    !(decimalPlaces >= 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, decimalPlaces + \" is negative.\") : invariant(false) : void 0;\n    Big.DP = decimalPlaces;\n    Big.RM = toFixedRounding[rounding];\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format);\n  }\n  /**\r\n   * Helper method for converting any super class back to a fraction\r\n   */\n  ;\n\n  _createClass(Fraction, [{\n    key: \"quotient\",\n    get: function get() {\n      return JSBI.divide(this.numerator, this.denominator);\n    } // remainder after floor division\n\n  }, {\n    key: \"remainder\",\n    get: function get() {\n      return new Fraction(JSBI.remainder(this.numerator, this.denominator), this.denominator);\n    }\n  }, {\n    key: \"asFraction\",\n    get: function get() {\n      return new Fraction(this.numerator, this.denominator);\n    }\n  }]);\n\n  return Fraction;\n}();\n\nvar Big$1 = /*#__PURE__*/toFormat(_Big);\nvar CurrencyAmount = /*#__PURE__*/function (_Fraction) {\n  _inheritsLoose(CurrencyAmount, _Fraction);\n\n  function CurrencyAmount(currency, numerator, denominator) {\n    var _this;\n\n    _this = _Fraction.call(this, numerator, denominator) || this;\n    !JSBI.lessThanOrEqual(_this.quotient, MaxUint256) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'AMOUNT') : invariant(false) : void 0;\n    _this.currency = currency;\n    _this.decimalScale = JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(currency.decimals));\n    return _this;\n  }\n  /**\r\n   * Returns a new currency amount instance from the unitless amount of token, i.e. the raw amount\r\n   * @param currency the currency in the amount\r\n   * @param rawAmount the raw token or ether amount\r\n   */\n\n\n  CurrencyAmount.fromRawAmount = function fromRawAmount(currency, rawAmount) {\n    return new CurrencyAmount(currency, rawAmount);\n  }\n  /**\r\n   * Construct a currency amount with a denominator that is not equal to 1\r\n   * @param currency the currency\r\n   * @param numerator the numerator of the fractional token amount\r\n   * @param denominator the denominator of the fractional token amount\r\n   */\n  ;\n\n  CurrencyAmount.fromFractionalAmount = function fromFractionalAmount(currency, numerator, denominator) {\n    return new CurrencyAmount(currency, numerator, denominator);\n  };\n\n  var _proto = CurrencyAmount.prototype;\n\n  _proto.add = function add(other) {\n    !this.currency.equals(other.currency) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'CURRENCY') : invariant(false) : void 0;\n\n    var added = _Fraction.prototype.add.call(this, other);\n\n    return CurrencyAmount.fromFractionalAmount(this.currency, added.numerator, added.denominator);\n  };\n\n  _proto.subtract = function subtract(other) {\n    !this.currency.equals(other.currency) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'CURRENCY') : invariant(false) : void 0;\n\n    var subtracted = _Fraction.prototype.subtract.call(this, other);\n\n    return CurrencyAmount.fromFractionalAmount(this.currency, subtracted.numerator, subtracted.denominator);\n  };\n\n  _proto.multiply = function multiply(other) {\n    var multiplied = _Fraction.prototype.multiply.call(this, other);\n\n    return CurrencyAmount.fromFractionalAmount(this.currency, multiplied.numerator, multiplied.denominator);\n  };\n\n  _proto.divide = function divide(other) {\n    var divided = _Fraction.prototype.divide.call(this, other);\n\n    return CurrencyAmount.fromFractionalAmount(this.currency, divided.numerator, divided.denominator);\n  };\n\n  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {\n    if (significantDigits === void 0) {\n      significantDigits = 6;\n    }\n\n    if (rounding === void 0) {\n      rounding = Rounding.ROUND_DOWN;\n    }\n\n    return _Fraction.prototype.divide.call(this, this.decimalScale).toSignificant(significantDigits, format, rounding);\n  };\n\n  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {\n    if (decimalPlaces === void 0) {\n      decimalPlaces = this.currency.decimals;\n    }\n\n    if (rounding === void 0) {\n      rounding = Rounding.ROUND_DOWN;\n    }\n\n    !(decimalPlaces <= this.currency.decimals) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DECIMALS') : invariant(false) : void 0;\n    return _Fraction.prototype.divide.call(this, this.decimalScale).toFixed(decimalPlaces, format, rounding);\n  };\n\n  _proto.toExact = function toExact(format) {\n    if (format === void 0) {\n      format = {\n        groupSeparator: ''\n      };\n    }\n\n    Big$1.DP = this.currency.decimals;\n    return new Big$1(this.quotient.toString()).div(this.decimalScale.toString()).toFormat(format);\n  };\n\n  _createClass(CurrencyAmount, [{\n    key: \"wrapped\",\n    get: function get() {\n      if (this.currency.isToken) return this;\n      return CurrencyAmount.fromFractionalAmount(this.currency.wrapped, this.numerator, this.denominator);\n    }\n  }]);\n\n  return CurrencyAmount;\n}(Fraction);\n\nvar ONE_HUNDRED = /*#__PURE__*/new Fraction( /*#__PURE__*/JSBI.BigInt(100));\n/**\r\n * Converts a fraction to a percent\r\n * @param fraction the fraction to convert\r\n */\n\nfunction toPercent(fraction) {\n  return new Percent(fraction.numerator, fraction.denominator);\n}\n\nvar Percent = /*#__PURE__*/function (_Fraction) {\n  _inheritsLoose(Percent, _Fraction);\n\n  function Percent() {\n    var _this;\n\n    _this = _Fraction.apply(this, arguments) || this;\n    /**\r\n     * This boolean prevents a fraction from being interpreted as a Percent\r\n     */\n\n    _this.isPercent = true;\n    return _this;\n  }\n\n  var _proto = Percent.prototype;\n\n  _proto.add = function add(other) {\n    return toPercent(_Fraction.prototype.add.call(this, other));\n  };\n\n  _proto.subtract = function subtract(other) {\n    return toPercent(_Fraction.prototype.subtract.call(this, other));\n  };\n\n  _proto.multiply = function multiply(other) {\n    return toPercent(_Fraction.prototype.multiply.call(this, other));\n  };\n\n  _proto.divide = function divide(other) {\n    return toPercent(_Fraction.prototype.divide.call(this, other));\n  };\n\n  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {\n    if (significantDigits === void 0) {\n      significantDigits = 5;\n    }\n\n    return _Fraction.prototype.multiply.call(this, ONE_HUNDRED).toSignificant(significantDigits, format, rounding);\n  };\n\n  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {\n    if (decimalPlaces === void 0) {\n      decimalPlaces = 2;\n    }\n\n    return _Fraction.prototype.multiply.call(this, ONE_HUNDRED).toFixed(decimalPlaces, format, rounding);\n  };\n\n  return Percent;\n}(Fraction);\n\nvar Price = /*#__PURE__*/function (_Fraction) {\n  _inheritsLoose(Price, _Fraction);\n\n  /**\r\n   * Construct a price, either with the base and quote currency amount, or the\r\n   * @param args\r\n   */\n  function Price() {\n    var _this;\n\n    var baseCurrency, quoteCurrency, denominator, numerator;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (args.length === 4) {\n      baseCurrency = args[0];\n      quoteCurrency = args[1];\n      denominator = args[2];\n      numerator = args[3];\n    } else {\n      var result = args[0].quoteAmount.divide(args[0].baseAmount);\n      var _ref = [args[0].baseAmount.currency, args[0].quoteAmount.currency, result.denominator, result.numerator];\n      baseCurrency = _ref[0];\n      quoteCurrency = _ref[1];\n      denominator = _ref[2];\n      numerator = _ref[3];\n    }\n\n    _this = _Fraction.call(this, numerator, denominator) || this;\n    _this.baseCurrency = baseCurrency;\n    _this.quoteCurrency = quoteCurrency;\n    _this.scalar = new Fraction(JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(baseCurrency.decimals)), JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(quoteCurrency.decimals)));\n    return _this;\n  }\n  /**\r\n   * Flip the price, switching the base and quote currency\r\n   */\n\n\n  var _proto = Price.prototype;\n\n  _proto.invert = function invert() {\n    return new Price(this.quoteCurrency, this.baseCurrency, this.numerator, this.denominator);\n  }\n  /**\r\n   * Multiply the price by another price, returning a new price. The other price must have the same base currency as this price's quote currency\r\n   * @param other the other price\r\n   */\n  ;\n\n  _proto.multiply = function multiply(other) {\n    !this.quoteCurrency.equals(other.baseCurrency) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'TOKEN') : invariant(false) : void 0;\n\n    var fraction = _Fraction.prototype.multiply.call(this, other);\n\n    return new Price(this.baseCurrency, other.quoteCurrency, fraction.denominator, fraction.numerator);\n  }\n  /**\r\n   * Return the amount of quote currency corresponding to a given amount of the base currency\r\n   * @param currencyAmount the amount of base currency to quote against the price\r\n   */\n  ;\n\n  _proto.quote = function quote(currencyAmount) {\n    !currencyAmount.currency.equals(this.baseCurrency) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'TOKEN') : invariant(false) : void 0;\n\n    var result = _Fraction.prototype.multiply.call(this, currencyAmount);\n\n    return CurrencyAmount.fromFractionalAmount(this.quoteCurrency, result.numerator, result.denominator);\n  }\n  /**\r\n   * Get the value scaled by decimals for formatting\r\n   * @private\r\n   */\n  ;\n\n  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {\n    if (significantDigits === void 0) {\n      significantDigits = 6;\n    }\n\n    return this.adjustedForDecimals.toSignificant(significantDigits, format, rounding);\n  };\n\n  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {\n    if (decimalPlaces === void 0) {\n      decimalPlaces = 4;\n    }\n\n    return this.adjustedForDecimals.toFixed(decimalPlaces, format, rounding);\n  };\n\n  _createClass(Price, [{\n    key: \"adjustedForDecimals\",\n    get: function get() {\n      return _Fraction.prototype.multiply.call(this, this.scalar);\n    }\n  }]);\n\n  return Price;\n}(Fraction);\n\n/**\r\n * A currency is any fungible financial instrument, including Ether, all ERC20 tokens, and other chain-native currencies\r\n */\n\nvar BaseCurrency =\n/**\r\n * Constructs an instance of the base class `BaseCurrency`.\r\n * @param chainId the chain ID on which this currency resides\r\n * @param decimals decimals of the currency\r\n * @param symbol symbol of the currency\r\n * @param name of the currency\r\n */\nfunction BaseCurrency(chainId, decimals, symbol, name) {\n  !Number.isSafeInteger(chainId) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'CHAIN_ID') : invariant(false) : void 0;\n  !(decimals >= 0 && decimals < 255 && Number.isInteger(decimals)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DECIMALS') : invariant(false) : void 0;\n  this.chainId = chainId;\n  this.decimals = decimals;\n  this.symbol = symbol;\n  this.name = name;\n};\n\n/**\r\n * Represents the native currency of the chain on which it resides, e.g.\r\n */\n\nvar NativeCurrency = /*#__PURE__*/function (_BaseCurrency) {\n  _inheritsLoose(NativeCurrency, _BaseCurrency);\n\n  function NativeCurrency() {\n    var _this;\n\n    _this = _BaseCurrency.apply(this, arguments) || this;\n    _this.isNative = true;\n    _this.isToken = false;\n    return _this;\n  }\n\n  return NativeCurrency;\n}(BaseCurrency);\n\n/**\r\n * Validates an address and returns the parsed (checksummed) version of that address\r\n * @param address the unchecksummed hex address\r\n */\n\nfunction validateAndParseAddress(address) {\n  try {\n    return getAddress(address);\n  } catch (error) {\n    throw new Error(address + \" is not a valid address.\");\n  }\n}\n\n/**\r\n * Represents an ERC20 token with a unique address and some metadata.\r\n */\n\nvar Token = /*#__PURE__*/function (_BaseCurrency) {\n  _inheritsLoose(Token, _BaseCurrency);\n\n  function Token(chainId, address, decimals, symbol, name) {\n    var _this;\n\n    _this = _BaseCurrency.call(this, chainId, decimals, symbol, name) || this;\n    _this.isNative = false;\n    _this.isToken = true;\n    _this.address = validateAndParseAddress(address);\n    return _this;\n  }\n  /**\r\n   * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.\r\n   * @param other other token to compare\r\n   */\n\n\n  var _proto = Token.prototype;\n\n  _proto.equals = function equals(other) {\n    return other.isToken && this.chainId === other.chainId && this.address === other.address;\n  }\n  /**\r\n   * Returns true if the address of this token sorts before the address of the other token\r\n   * @param other other token to compare\r\n   * @throws if the tokens have the same address\r\n   * @throws if the tokens are on different chains\r\n   */\n  ;\n\n  _proto.sortsBefore = function sortsBefore(other) {\n    !(this.chainId === other.chainId) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'CHAIN_IDS') : invariant(false) : void 0;\n    !(this.address !== other.address) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ADDRESSES') : invariant(false) : void 0;\n    return this.address.toLowerCase() < other.address.toLowerCase();\n  }\n  /**\r\n   * Return this token, which does not need to be wrapped\r\n   */\n  ;\n\n  _createClass(Token, [{\n    key: \"wrapped\",\n    get: function get() {\n      return this;\n    }\n  }]);\n\n  return Token;\n}(BaseCurrency);\n\nvar _WETH;\n/**\r\n * Known WETH9 implementation addresses, used in our implementation of Ether#wrapped\r\n */\n\nvar WETH9 = (_WETH = {}, _WETH[1] = /*#__PURE__*/new Token(1, '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2', 18, 'WETH', 'Wrapped Ether'), _WETH[3] = /*#__PURE__*/new Token(3, '0xc778417E063141139Fce010982780140Aa0cD5Ab', 18, 'WETH', 'Wrapped Ether'), _WETH[4] = /*#__PURE__*/new Token(4, '0xc778417E063141139Fce010982780140Aa0cD5Ab', 18, 'WETH', 'Wrapped Ether'), _WETH[5] = /*#__PURE__*/new Token(5, '0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6', 18, 'WETH', 'Wrapped Ether'), _WETH[42] = /*#__PURE__*/new Token(42, '0xd0A1E359811322d97991E03f863a0C30C2cF029C', 18, 'WETH', 'Wrapped Ether'), _WETH[10] = /*#__PURE__*/new Token(10, '0x4200000000000000000000000000000000000006', 18, 'WETH', 'Wrapped Ether'), _WETH[69] = /*#__PURE__*/new Token(69, '0x4200000000000000000000000000000000000006', 18, 'WETH', 'Wrapped Ether'), _WETH[42161] = /*#__PURE__*/new Token(42161, '0x82aF49447D8a07e3bd95BD0d56f35241523fBab1', 18, 'WETH', 'Wrapped Ether'), _WETH[421611] = /*#__PURE__*/new Token(421611, '0xB47e6A5f8b33b3F17603C83a0535A9dcD7E32681', 18, 'WETH', 'Wrapped Ether'), _WETH);\n\n/**\r\n * Ether is the main usage of a 'native' currency, i.e. for Ethereum mainnet and all testnets\r\n */\n\nvar Ether = /*#__PURE__*/function (_NativeCurrency) {\n  _inheritsLoose(Ether, _NativeCurrency);\n\n  function Ether(chainId) {\n    return _NativeCurrency.call(this, chainId, 18, 'ETH', 'Ether') || this;\n  }\n\n  Ether.onChain = function onChain(chainId) {\n    var _this$_etherCache$cha;\n\n    return (_this$_etherCache$cha = this._etherCache[chainId]) != null ? _this$_etherCache$cha : this._etherCache[chainId] = new Ether(chainId);\n  };\n\n  var _proto = Ether.prototype;\n\n  _proto.equals = function equals(other) {\n    return other.isNative && other.chainId === this.chainId;\n  };\n\n  _createClass(Ether, [{\n    key: \"wrapped\",\n    get: function get() {\n      var weth9 = WETH9[this.chainId];\n      !!!weth9 ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'WRAPPED') : invariant(false) : void 0;\n      return weth9;\n    }\n  }]);\n\n  return Ether;\n}(NativeCurrency);\nEther._etherCache = {};\n\n/**\r\n * Returns the percent difference between the mid price and the execution price, i.e. price impact.\r\n * @param midPrice mid price before the trade\r\n * @param inputAmount the input amount of the trade\r\n * @param outputAmount the output amount of the trade\r\n */\n\nfunction computePriceImpact(midPrice, inputAmount, outputAmount) {\n  var quotedOutputAmount = midPrice.quote(inputAmount); // calculate price impact := (exactQuote - outputAmount) / exactQuote\n\n  var priceImpact = quotedOutputAmount.subtract(outputAmount).divide(quotedOutputAmount);\n  return new Percent(priceImpact.numerator, priceImpact.denominator);\n}\n\n// `maxSize` by removing the last item\n\nfunction sortedInsert(items, add, maxSize, comparator) {\n  !(maxSize > 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'MAX_SIZE_ZERO') : invariant(false) : void 0; // this is an invariant because the interface cannot return multiple removed items if items.length exceeds maxSize\n\n  !(items.length <= maxSize) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ITEMS_SIZE') : invariant(false) : void 0; // short circuit first item add\n\n  if (items.length === 0) {\n    items.push(add);\n    return null;\n  } else {\n    var isFull = items.length === maxSize; // short circuit if full and the additional item does not come before the last item\n\n    if (isFull && comparator(items[items.length - 1], add) <= 0) {\n      return add;\n    }\n\n    var lo = 0,\n        hi = items.length;\n\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n\n      if (comparator(items[mid], add) <= 0) {\n        lo = mid + 1;\n      } else {\n        hi = mid;\n      }\n    }\n\n    items.splice(lo, 0, add);\n    return isFull ? items.pop() : null;\n  }\n}\n\nvar MAX_SAFE_INTEGER = /*#__PURE__*/JSBI.BigInt(Number.MAX_SAFE_INTEGER);\nvar ZERO = /*#__PURE__*/JSBI.BigInt(0);\nvar ONE = /*#__PURE__*/JSBI.BigInt(1);\nvar TWO = /*#__PURE__*/JSBI.BigInt(2);\n/**\r\n * Computes floor(sqrt(value))\r\n * @param value the value for which to compute the square root, rounded down\r\n */\n\nfunction sqrt(value) {\n  !JSBI.greaterThanOrEqual(value, ZERO) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'NEGATIVE') : invariant(false) : void 0; // rely on built in sqrt if possible\n\n  if (JSBI.lessThan(value, MAX_SAFE_INTEGER)) {\n    return JSBI.BigInt(Math.floor(Math.sqrt(JSBI.toNumber(value))));\n  }\n\n  var z;\n  var x;\n  z = value;\n  x = JSBI.add(JSBI.divide(value, TWO), ONE);\n\n  while (JSBI.lessThan(x, z)) {\n    z = x;\n    x = JSBI.divide(JSBI.add(JSBI.divide(value, x), x), TWO);\n  }\n\n  return z;\n}\n\nexport { CurrencyAmount, Ether, Fraction, MaxUint256, NativeCurrency, Percent, Price, Rounding, Token, TradeType, WETH9, computePriceImpact, sortedInsert, sqrt, validateAndParseAddress };\n"],"names":[],"sourceRoot":"","x_google_ignoreList":[0]}