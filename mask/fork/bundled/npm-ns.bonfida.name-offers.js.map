{"version":3,"file":"bundled/npm-ns.bonfida.name-offers.js","mappings":";;;;;;AAAa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,6BAA6B,GAAG,2BAA2B,GAAG,yBAAyB,GAAG,mBAAmB,GAAG,mBAAmB,GAAG,iBAAiB,GAAG,mBAAmB,GAAG,iBAAiB,GAAG,6BAA6B,GAAG,sBAAsB;AAClR,kBAAkB,mBAAO,CAAC,KAAiB;AAC3C,2BAA2B,mBAAO,CAAC,KAAoB;AACvD,gCAAgC,mBAAO,CAAC,KAAO;AAC/C,gBAAgB,mBAAO,CAAC,KAAS;AACjC,oBAAoB,mBAAO,CAAC,KAAmB;AAC/C,2BAA2B,mBAAO,CAAC,KAA2B;AAC9D;AACA,sBAAsB;AACtB;AACA,6BAA6B;AAC7B;AACA,iBAAiB;AACjB;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;;;;;;;AC3JR;AACb;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,KAAY;AACjC,aAAa,mBAAO,CAAC,KAAoB;AACzC,aAAa,mBAAO,CAAC,KAAS;AAC9B,aAAa,mBAAO,CAAC,KAAS;;;;;;;;;ACfjB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oCAAoC,GAAG,4BAA4B,GAAG,iCAAiC,GAAG,8BAA8B,GAAG,mCAAmC,GAAG,gCAAgC,GAAG,8BAA8B;AAClP,gBAAgB,mBAAO,CAAC,KAAO;AAC/B,kBAAkB,mBAAO,CAAC,KAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;ACzaa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB,GAAG,uBAAuB,GAAG,aAAa,GAAG,WAAW;AAC/E,gBAAgB,mBAAO,CAAC,KAAO;AAC/B,kBAAkB,mBAAO,CAAC,KAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wBAAwB,WAAW,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,MAAM;AACnE;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;ACvMa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0CAA0C,GAAG,aAAa,GAAG,wBAAwB,GAAG,mCAAmC,GAAG,kCAAkC,GAAG,yBAAyB,GAAG,wBAAwB;AACvN,kBAAkB,mBAAO,CAAC,KAAiB;AAC3C,mBAAmB,mBAAO,CAAC,KAAY;AACvC,gBAAgB,mBAAO,CAAC,KAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA,iBAAiB;AACjB,KAAK;AACL;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA,iBAAiB;AACjB,KAAK;AACL;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,0CAA0C","sources":["webpack://mask-network/./node_modules/.pnpm/@bonfida+name-offers@0.0.1_@solana+buffer-layout@4.0.1/node_modules/@bonfida/name-offers/dist/bindings.js","webpack://mask-network/./node_modules/.pnpm/@bonfida+name-offers@0.0.1_@solana+buffer-layout@4.0.1/node_modules/@bonfida/name-offers/dist/index.js","webpack://mask-network/./node_modules/.pnpm/@bonfida+name-offers@0.0.1_@solana+buffer-layout@4.0.1/node_modules/@bonfida/name-offers/dist/raw_instructions.js","webpack://mask-network/./node_modules/.pnpm/@bonfida+name-offers@0.0.1_@solana+buffer-layout@4.0.1/node_modules/@bonfida/name-offers/dist/state.js","webpack://mask-network/./node_modules/.pnpm/@bonfida+name-offers@0.0.1_@solana+buffer-layout@4.0.1/node_modules/@bonfida/name-offers/dist/utils.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.buyFixedPrice = exports.cancelFixedPriceOffer = exports.makeFixedPriceOffer = exports.registerFavourite = exports.acceptOffer = exports.cancelOffer = exports.makeOffer = exports.ROOT_DOMAIN = exports.FEE_OWNER = exports.NAME_OFFERS_ID_DEVNET = exports.NAME_OFFERS_ID = void 0;\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst raw_instructions_1 = require(\"./raw_instructions\");\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst state_1 = require(\"./state\");\nconst spl_token_1 = require(\"@solana/spl-token\");\nconst spl_name_service_1 = require(\"@bonfida/spl-name-service\");\n/** Mainnet program ID */\nexports.NAME_OFFERS_ID = new web3_js_1.PublicKey(\"85iDfUvr3HJyLM2zcq5BXSiDvUWfw6cSE1FfNBo8Ap29\");\n/** Devnet program ID */\nexports.NAME_OFFERS_ID_DEVNET = new web3_js_1.PublicKey(\"zugu92jR3kqgFiNEJywq7gbbc9NbaLmHLiQhsZRwd6J\");\n/** Fee collecting address */\nexports.FEE_OWNER = new web3_js_1.PublicKey(\"GcWEQ9K78FV7LEHteFVciYApERk5YvQuFDQPk1yYJVXi\");\n/** Root TLD */\nexports.ROOT_DOMAIN = new web3_js_1.PublicKey(\"58PwtjSDuFHuUkYjH9BYnnQKHfwo9reZhC2zMJv9JPkx\");\n/**\n * This function can be used to create an usolicited offer\n * @param amount Raw amount of the offer\n * @param nameAccount The domain name on which the unsolicited offer is made\n * @param owner The owner of the usolicited offer\n * @param quoteMint The quote token mint of the usolicited offer\n * @param tokenSource The token account from which the tokens originate from\n * @param programId The name offer program ID\n * @returns\n */\nconst makeOffer = async (amount, nameAccount, owner, quoteMint, tokenSource, programId) => {\n    const [offerKey] = await state_1.Offer.getKey(programId, owner, quoteMint, nameAccount);\n    const [escrow] = await web3_js_1.PublicKey.findProgramAddress([offerKey.toBuffer()], programId);\n    const ix = new raw_instructions_1.makeOfferInstruction({\n        amount: new bn_js_1.default(amount),\n        nameAccount: nameAccount.toBuffer(),\n    }).getInstruction(programId, owner, quoteMint, tokenSource, escrow, offerKey, web3_js_1.SystemProgram.programId, web3_js_1.SYSVAR_RENT_PUBKEY, spl_token_1.TOKEN_PROGRAM_ID);\n    return [ix];\n};\nexports.makeOffer = makeOffer;\n/**\n * This function can be used to cancel an unsolicited offer\n * @param owner The owner of the unsolicited offer\n * @param tokenDestination The token destination account\n * @param offer The offer account\n * @param programId The name offer program ID\n * @returns\n */\nconst cancelOffer = async (owner, tokenDestination, offer, programId) => {\n    const [escrow] = await web3_js_1.PublicKey.findProgramAddress([offer.toBuffer()], programId);\n    const ix = new raw_instructions_1.cancelOfferInstruction().getInstruction(programId, owner, tokenDestination, escrow, offer, spl_token_1.TOKEN_PROGRAM_ID);\n    return [ix];\n};\nexports.cancelOffer = cancelOffer;\n/**\n * This function can be used to accept an unsolicited offer\n * @param connection The Solana RPC connection object\n * @param programId The name offer program ID\n * @param offerAccount The offer account\n * @param offerOwner The offer owner account\n * @param offerBeneficiary The offer owner beneficialiciary i.e the person accepting the offer\n * @param nameAccount The domain name on which the unsolicited offer is made\n * @param escrowTokenAccount The escrow token account\n * @param destinationTokenAccount The destination token account\n * @returns\n */\nconst acceptOffer = async (connection, programId, offerAccount, offerOwner, offerBeneficiary, nameAccount, escrowTokenAccount, destinationTokenAccount) => {\n    var _a;\n    const ix = [];\n    const offer = await state_1.Offer.retrieve(connection, offerAccount);\n    const feeAta = await spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, offer.quoteMint, exports.FEE_OWNER);\n    if (!((_a = (await connection.getAccountInfo(feeAta))) === null || _a === void 0 ? void 0 : _a.data)) {\n        const ix_create_ata = spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, offer.quoteMint, feeAta, exports.FEE_OWNER, offerOwner);\n        ix.push(ix_create_ata);\n    }\n    const ix_accept = new raw_instructions_1.acceptOfferInstruction().getInstruction(programId, offerAccount, offerBeneficiary, nameAccount, escrowTokenAccount, destinationTokenAccount, feeAta, spl_token_1.TOKEN_PROGRAM_ID, spl_name_service_1.NAME_PROGRAM_ID);\n    ix.push(ix_accept);\n    return ix;\n};\nexports.acceptOffer = acceptOffer;\n/**\n * This function can be used to register a domain name as favorite\n * @param nameAccount The name account being registered as favorite\n * @param owner The owner of the name account\n * @param programId The name offer program ID\n * @returns\n */\nconst registerFavourite = async (nameAccount, owner, programId) => {\n    const [favKey] = await state_1.FavouriteDomain.getKey(programId, owner);\n    const ix = new raw_instructions_1.registerFavouriteInstruction().getInstruction(programId, nameAccount, favKey, owner, web3_js_1.SystemProgram.programId);\n    return [ix];\n};\nexports.registerFavourite = registerFavourite;\n/**\n * This function can be used to create a fixed price offer\n * @param connection The Solana RPC connection object\n * @param amount The amount of the fixed price offer\n * @param quoteMint The quote token mint of the fixed price offer\n * @param seller The seller i.e creator of the fixed price offer\n * @param nameAccount The name account being sold\n * @param programId The name offer program ID\n * @returns\n */\nconst makeFixedPriceOffer = async (connection, amount, quoteMint, seller, nameAccount, programId) => {\n    var _a;\n    const ix = [];\n    const tokenDestination = await spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, quoteMint, seller);\n    if (!((_a = (await connection.getAccountInfo(tokenDestination))) === null || _a === void 0 ? void 0 : _a.data)) {\n        const ix_create_ata = spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, quoteMint, tokenDestination, seller, seller);\n        ix.push(ix_create_ata);\n    }\n    const [fixedKey] = await state_1.FixedPriceOffer.getKey(programId, seller, quoteMint, nameAccount);\n    const ix_offer = new raw_instructions_1.makeFixedPriceInstruction({\n        amount: new bn_js_1.default(amount),\n        quoteMint: quoteMint.toBuffer(),\n    }).getInstruction(programId, fixedKey, seller, nameAccount, tokenDestination, spl_name_service_1.NAME_PROGRAM_ID, web3_js_1.SystemProgram.programId);\n    ix.push(ix_offer);\n    return ix;\n};\nexports.makeFixedPriceOffer = makeFixedPriceOffer;\n/**\n * This function can be used to cancel a fixed price offer\n * @param connection The Solana RPC connection object\n * @param fixedPriceOffer The fixed price offer key\n * @param programId The name offer program ID\n * @returns\n */\nconst cancelFixedPriceOffer = async (connection, fixedPriceOffer, programId) => {\n    const offer = await state_1.FixedPriceOffer.retrieve(connection, fixedPriceOffer);\n    const ix = new raw_instructions_1.cancelFixedPriceInstruction().getInstruction(programId, fixedPriceOffer, offer.owner, offer.nameAccount, spl_name_service_1.NAME_PROGRAM_ID, web3_js_1.SystemProgram.programId);\n    return [ix];\n};\nexports.cancelFixedPriceOffer = cancelFixedPriceOffer;\n/**\n * This function can be used to buy a fixed a price offer\n * @param connection The Solana RPC connection object\n * @param fixedPriceOffer The fixed price offer being bought\n * @param buyer The buyer of the fixed price offer\n * @param tokenSource The token account used to buy the fixed price offer\n * @param programId The name offer program ID\n * @returns\n */\nconst buyFixedPrice = async (connection, fixedPriceOffer, buyer, tokenSource, programId) => {\n    var _a;\n    const ix = [];\n    const offer = await state_1.FixedPriceOffer.retrieve(connection, fixedPriceOffer);\n    const feeAta = await spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, offer.quoteMint, exports.FEE_OWNER);\n    if (!((_a = (await connection.getAccountInfo(feeAta))) === null || _a === void 0 ? void 0 : _a.data)) {\n        const ix_create_ata = spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, offer.quoteMint, feeAta, exports.FEE_OWNER, buyer);\n        ix.push(ix_create_ata);\n    }\n    const ix_buy = new raw_instructions_1.buyFixedPriceInstruction().getInstruction(programId, fixedPriceOffer, buyer, offer.nameAccount, offer.tokenDestination, tokenSource, feeAta, spl_token_1.TOKEN_PROGRAM_ID, spl_name_service_1.NAME_PROGRAM_ID);\n    ix.push(ix_buy);\n    return ix;\n};\nexports.buyFixedPrice = buyFixedPrice;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./bindings\"), exports);\n__exportStar(require(\"./raw_instructions\"), exports);\n__exportStar(require(\"./state\"), exports);\n__exportStar(require(\"./utils\"), exports);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.registerFavouriteInstruction = exports.makeOfferInstruction = exports.makeFixedPriceInstruction = exports.cancelOfferInstruction = exports.cancelFixedPriceInstruction = exports.buyFixedPriceInstruction = exports.acceptOfferInstruction = void 0;\nconst borsh_1 = require(\"borsh\");\nconst web3_js_1 = require(\"@solana/web3.js\");\nclass acceptOfferInstruction {\n    constructor() {\n        this.tag = 2;\n    }\n    serialize() {\n        return (0, borsh_1.serialize)(acceptOfferInstruction.schema, this);\n    }\n    getInstruction(programId, offerAccount, offerBeneficiary, nameAccount, escrowTokenAccount, destinationTokenAccount, feeAccount, splTokenProgram, nameServiceProgram) {\n        const data = Buffer.from(this.serialize());\n        let keys = [];\n        keys.push({\n            pubkey: offerAccount,\n            isSigner: false,\n            isWritable: true,\n        });\n        keys.push({\n            pubkey: offerBeneficiary,\n            isSigner: true,\n            isWritable: false,\n        });\n        keys.push({\n            pubkey: nameAccount,\n            isSigner: false,\n            isWritable: true,\n        });\n        keys.push({\n            pubkey: escrowTokenAccount,\n            isSigner: false,\n            isWritable: true,\n        });\n        keys.push({\n            pubkey: destinationTokenAccount,\n            isSigner: false,\n            isWritable: true,\n        });\n        keys.push({\n            pubkey: feeAccount,\n            isSigner: false,\n            isWritable: true,\n        });\n        keys.push({\n            pubkey: splTokenProgram,\n            isSigner: false,\n            isWritable: false,\n        });\n        keys.push({\n            pubkey: nameServiceProgram,\n            isSigner: false,\n            isWritable: false,\n        });\n        return new web3_js_1.TransactionInstruction({\n            keys,\n            programId,\n            data,\n        });\n    }\n}\nexports.acceptOfferInstruction = acceptOfferInstruction;\nacceptOfferInstruction.schema = new Map([\n    [\n        acceptOfferInstruction,\n        {\n            kind: \"struct\",\n            fields: [[\"tag\", \"u8\"]],\n        },\n    ],\n]);\nclass buyFixedPriceInstruction {\n    constructor() {\n        this.tag = 5;\n    }\n    serialize() {\n        return (0, borsh_1.serialize)(buyFixedPriceInstruction.schema, this);\n    }\n    getInstruction(programId, fixedPriceOffer, buyer, nameAccount, tokenDestination, tokenSource, feeAccount, splTokenProgram, nameServiceProgram) {\n        const data = Buffer.from(this.serialize());\n        let keys = [];\n        keys.push({\n            pubkey: fixedPriceOffer,\n            isSigner: false,\n            isWritable: true,\n        });\n        keys.push({\n            pubkey: buyer,\n            isSigner: true,\n            isWritable: false,\n        });\n        keys.push({\n            pubkey: nameAccount,\n            isSigner: false,\n            isWritable: true,\n        });\n        keys.push({\n            pubkey: tokenDestination,\n            isSigner: false,\n            isWritable: true,\n        });\n        keys.push({\n            pubkey: tokenSource,\n            isSigner: false,\n            isWritable: true,\n        });\n        keys.push({\n            pubkey: feeAccount,\n            isSigner: false,\n            isWritable: true,\n        });\n        keys.push({\n            pubkey: splTokenProgram,\n            isSigner: false,\n            isWritable: false,\n        });\n        keys.push({\n            pubkey: nameServiceProgram,\n            isSigner: false,\n            isWritable: false,\n        });\n        return new web3_js_1.TransactionInstruction({\n            keys,\n            programId,\n            data,\n        });\n    }\n}\nexports.buyFixedPriceInstruction = buyFixedPriceInstruction;\nbuyFixedPriceInstruction.schema = new Map([\n    [\n        buyFixedPriceInstruction,\n        {\n            kind: \"struct\",\n            fields: [[\"tag\", \"u8\"]],\n        },\n    ],\n]);\nclass cancelFixedPriceInstruction {\n    constructor() {\n        this.tag = 4;\n    }\n    serialize() {\n        return (0, borsh_1.serialize)(cancelFixedPriceInstruction.schema, this);\n    }\n    getInstruction(programId, fixedPriceOffer, fixedPriceOfferOwner, nameAccount, nameServiceProgram, systemProgram) {\n        const data = Buffer.from(this.serialize());\n        let keys = [];\n        keys.push({\n            pubkey: fixedPriceOffer,\n            isSigner: false,\n            isWritable: true,\n        });\n        keys.push({\n            pubkey: fixedPriceOfferOwner,\n            isSigner: true,\n            isWritable: false,\n        });\n        keys.push({\n            pubkey: nameAccount,\n            isSigner: false,\n            isWritable: true,\n        });\n        keys.push({\n            pubkey: nameServiceProgram,\n            isSigner: false,\n            isWritable: false,\n        });\n        keys.push({\n            pubkey: systemProgram,\n            isSigner: false,\n            isWritable: false,\n        });\n        return new web3_js_1.TransactionInstruction({\n            keys,\n            programId,\n            data,\n        });\n    }\n}\nexports.cancelFixedPriceInstruction = cancelFixedPriceInstruction;\ncancelFixedPriceInstruction.schema = new Map([\n    [\n        cancelFixedPriceInstruction,\n        {\n            kind: \"struct\",\n            fields: [[\"tag\", \"u8\"]],\n        },\n    ],\n]);\nclass cancelOfferInstruction {\n    constructor() {\n        this.tag = 1;\n    }\n    serialize() {\n        return (0, borsh_1.serialize)(cancelOfferInstruction.schema, this);\n    }\n    getInstruction(programId, owner, tokenDestination, escrowAccount, offerAccount, splTokenProgram) {\n        const data = Buffer.from(this.serialize());\n        let keys = [];\n        keys.push({\n            pubkey: owner,\n            isSigner: true,\n            isWritable: false,\n        });\n        keys.push({\n            pubkey: tokenDestination,\n            isSigner: false,\n            isWritable: true,\n        });\n        keys.push({\n            pubkey: escrowAccount,\n            isSigner: false,\n            isWritable: true,\n        });\n        keys.push({\n            pubkey: offerAccount,\n            isSigner: false,\n            isWritable: true,\n        });\n        keys.push({\n            pubkey: splTokenProgram,\n            isSigner: false,\n            isWritable: false,\n        });\n        return new web3_js_1.TransactionInstruction({\n            keys,\n            programId,\n            data,\n        });\n    }\n}\nexports.cancelOfferInstruction = cancelOfferInstruction;\ncancelOfferInstruction.schema = new Map([\n    [\n        cancelOfferInstruction,\n        {\n            kind: \"struct\",\n            fields: [[\"tag\", \"u8\"]],\n        },\n    ],\n]);\nclass makeFixedPriceInstruction {\n    constructor(obj) {\n        this.tag = 3;\n        this.amount = obj.amount;\n        this.quoteMint = obj.quoteMint;\n    }\n    serialize() {\n        return (0, borsh_1.serialize)(makeFixedPriceInstruction.schema, this);\n    }\n    getInstruction(programId, fixedPriceOffer, fixedPriceOfferOwner, nameAccount, tokenDestination, nameServiceProgram, systemProgram) {\n        const data = Buffer.from(this.serialize());\n        let keys = [];\n        keys.push({\n            pubkey: fixedPriceOffer,\n            isSigner: false,\n            isWritable: true,\n        });\n        keys.push({\n            pubkey: fixedPriceOfferOwner,\n            isSigner: true,\n            isWritable: true,\n        });\n        keys.push({\n            pubkey: nameAccount,\n            isSigner: false,\n            isWritable: true,\n        });\n        keys.push({\n            pubkey: tokenDestination,\n            isSigner: false,\n            isWritable: false,\n        });\n        keys.push({\n            pubkey: nameServiceProgram,\n            isSigner: false,\n            isWritable: false,\n        });\n        keys.push({\n            pubkey: systemProgram,\n            isSigner: false,\n            isWritable: false,\n        });\n        return new web3_js_1.TransactionInstruction({\n            keys,\n            programId,\n            data,\n        });\n    }\n}\nexports.makeFixedPriceInstruction = makeFixedPriceInstruction;\nmakeFixedPriceInstruction.schema = new Map([\n    [\n        makeFixedPriceInstruction,\n        {\n            kind: \"struct\",\n            fields: [\n                [\"tag\", \"u8\"],\n                [\"amount\", \"u64\"],\n                [\"quoteMint\", [32]],\n            ],\n        },\n    ],\n]);\nclass makeOfferInstruction {\n    constructor(obj) {\n        this.tag = 0;\n        this.amount = obj.amount;\n        this.nameAccount = obj.nameAccount;\n    }\n    serialize() {\n        return (0, borsh_1.serialize)(makeOfferInstruction.schema, this);\n    }\n    getInstruction(programId, owner, quoteMint, tokenSource, escrowTokenAccount, offerAccount, systemProgram, rentAccount, splTokenProgram) {\n        const data = Buffer.from(this.serialize());\n        let keys = [];\n        keys.push({\n            pubkey: owner,\n            isSigner: true,\n            isWritable: true,\n        });\n        keys.push({\n            pubkey: quoteMint,\n            isSigner: false,\n            isWritable: false,\n        });\n        keys.push({\n            pubkey: tokenSource,\n            isSigner: false,\n            isWritable: true,\n        });\n        keys.push({\n            pubkey: escrowTokenAccount,\n            isSigner: false,\n            isWritable: true,\n        });\n        keys.push({\n            pubkey: offerAccount,\n            isSigner: false,\n            isWritable: true,\n        });\n        keys.push({\n            pubkey: systemProgram,\n            isSigner: false,\n            isWritable: false,\n        });\n        keys.push({\n            pubkey: rentAccount,\n            isSigner: false,\n            isWritable: false,\n        });\n        keys.push({\n            pubkey: splTokenProgram,\n            isSigner: false,\n            isWritable: false,\n        });\n        return new web3_js_1.TransactionInstruction({\n            keys,\n            programId,\n            data,\n        });\n    }\n}\nexports.makeOfferInstruction = makeOfferInstruction;\nmakeOfferInstruction.schema = new Map([\n    [\n        makeOfferInstruction,\n        {\n            kind: \"struct\",\n            fields: [\n                [\"tag\", \"u8\"],\n                [\"amount\", \"u64\"],\n                [\"nameAccount\", [32]],\n            ],\n        },\n    ],\n]);\nclass registerFavouriteInstruction {\n    constructor() {\n        this.tag = 6;\n    }\n    serialize() {\n        return (0, borsh_1.serialize)(registerFavouriteInstruction.schema, this);\n    }\n    getInstruction(programId, nameAccount, favouriteAccount, owner, systemProgram) {\n        const data = Buffer.from(this.serialize());\n        let keys = [];\n        keys.push({\n            pubkey: nameAccount,\n            isSigner: false,\n            isWritable: false,\n        });\n        keys.push({\n            pubkey: favouriteAccount,\n            isSigner: false,\n            isWritable: true,\n        });\n        keys.push({\n            pubkey: owner,\n            isSigner: true,\n            isWritable: true,\n        });\n        keys.push({\n            pubkey: systemProgram,\n            isSigner: false,\n            isWritable: false,\n        });\n        return new web3_js_1.TransactionInstruction({\n            keys,\n            programId,\n            data,\n        });\n    }\n}\nexports.registerFavouriteInstruction = registerFavouriteInstruction;\nregisterFavouriteInstruction.schema = new Map([\n    [\n        registerFavouriteInstruction,\n        {\n            kind: \"struct\",\n            fields: [[\"tag\", \"u8\"]],\n        },\n    ],\n]);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FixedPriceOffer = exports.FavouriteDomain = exports.Offer = exports.Tag = void 0;\nconst borsh_1 = require(\"borsh\");\nconst web3_js_1 = require(\"@solana/web3.js\");\n/**\n * Account tags (used for deserialization on-chain)\n */\nvar Tag;\n(function (Tag) {\n    Tag[Tag[\"Uninitialized\"] = 0] = \"Uninitialized\";\n    Tag[Tag[\"ActiveOffer\"] = 1] = \"ActiveOffer\";\n    Tag[Tag[\"CancelledOffer\"] = 2] = \"CancelledOffer\";\n    Tag[Tag[\"AcceptedOffer\"] = 3] = \"AcceptedOffer\";\n    Tag[Tag[\"FavouriteDomain\"] = 4] = \"FavouriteDomain\";\n    Tag[Tag[\"FixedPriceOffer\"] = 5] = \"FixedPriceOffer\";\n    Tag[Tag[\"AcceptedFixedPriceOffer\"] = 6] = \"AcceptedFixedPriceOffer\";\n    Tag[Tag[\"CancelledFixedPriceOffer\"] = 7] = \"CancelledFixedPriceOffer\";\n})(Tag = exports.Tag || (exports.Tag = {}));\nclass Offer {\n    constructor(obj) {\n        this.tag = obj.tag;\n        this.nonce = obj.nonce;\n        this.nameAccount = new web3_js_1.PublicKey(obj.nameAccount);\n        this.owner = new web3_js_1.PublicKey(obj.owner);\n        this.quoteMint = new web3_js_1.PublicKey(obj.quoteMint);\n        this.offerAmount = obj.offerAmount;\n        this.escrow = new web3_js_1.PublicKey(obj.escrow);\n    }\n    /**\n     * This function can be used to deserialize a Buffer into an Offer object\n     * @param data The buffer to deserialize\n     * @returns\n     */\n    static deserialize(data) {\n        return (0, borsh_1.deserialize)(this.schema, Offer, data);\n    }\n    /**\n     * This function can be used to retrieve and deserialize an offer\n     * @param connection The Solana RPC connection object\n     * @param key The offer key\n     * @returns\n     */\n    static async retrieve(connection, key) {\n        const accountInfo = await connection.getAccountInfo(key);\n        if (!accountInfo || !accountInfo.data) {\n            throw new Error(\"Offer not found\");\n        }\n        return this.deserialize(accountInfo.data);\n    }\n    /**\n     * This function can be used to derive the PDA of an offer\n     * @param programId The name offer program ID\n     * @param owner The owner of the offer\n     * @param quoteMint The quote mint of the offer\n     * @param nameAccount The name account key\n     * @returns\n     */\n    static async getKey(programId, owner, quoteMint, nameAccount) {\n        return await web3_js_1.PublicKey.findProgramAddress([\n            Buffer.from(\"offer_account\"),\n            owner.toBuffer(),\n            quoteMint.toBuffer(),\n            nameAccount.toBuffer(),\n        ], programId);\n    }\n}\nexports.Offer = Offer;\nOffer.schema = new Map([\n    [\n        Offer,\n        {\n            kind: \"struct\",\n            fields: [\n                [\"tag\", \"u8\"],\n                [\"nonce\", \"u8\"],\n                [\"nameAccount\", [32]],\n                [\"owner\", [32]],\n                [\"quoteMint\", [32]],\n                [\"offerAmount\", \"u64\"],\n                [\"escrow\", [32]],\n            ],\n        },\n    ],\n]);\nclass FavouriteDomain {\n    constructor(obj) {\n        this.tag = obj.tag;\n        this.nameAccount = new web3_js_1.PublicKey(obj.nameAccount);\n    }\n    /**\n     * This function can be used to deserialize a Buffer into a FavouriteDomain object\n     * @param data The buffer to deserialize\n     * @returns\n     */\n    static deserialize(data) {\n        return (0, borsh_1.deserialize)(this.schema, FavouriteDomain, data);\n    }\n    /**\n     * This function can be used to retrieve and deserialize a favorite domain\n     * @param connection The Solana RPC connection object\n     * @param key The favorite account key\n     * @returns\n     */\n    static async retrieve(connection, key) {\n        const accountInfo = await connection.getAccountInfo(key);\n        if (!accountInfo || !accountInfo.data) {\n            throw new Error(\"Favourite domain not found\");\n        }\n        return this.deserialize(accountInfo.data);\n    }\n    /**\n     * This function can be used to derive the key of a favorite domain\n     * @param programId The name offer program ID\n     * @param owner The owner to retrieve the favorite domain for\n     * @returns\n     */\n    static async getKey(programId, owner) {\n        return await web3_js_1.PublicKey.findProgramAddress([Buffer.from(\"favourite_domain\"), owner.toBuffer()], programId);\n    }\n}\nexports.FavouriteDomain = FavouriteDomain;\nFavouriteDomain.schema = new Map([\n    [\n        FavouriteDomain,\n        {\n            kind: \"struct\",\n            fields: [\n                [\"tag\", \"u8\"],\n                [\"nameAccount\", [32]],\n            ],\n        },\n    ],\n]);\nclass FixedPriceOffer {\n    constructor(obj) {\n        this.tag = obj.tag;\n        this.nonce = obj.nonce;\n        this.nameAccount = new web3_js_1.PublicKey(obj.nameAccount);\n        this.owner = new web3_js_1.PublicKey(obj.owner);\n        this.quoteMint = new web3_js_1.PublicKey(obj.quoteMint);\n        this.offerAmount = obj.offerAmount;\n        this.tokenDestination = new web3_js_1.PublicKey(obj.tokenDestination);\n    }\n    /**\n     * This function can be used to deserialize a Buffer into a FixedPriceOffer object\n     * @param data The buffer to deserialize\n     * @returns\n     */\n    static deserialize(data) {\n        return (0, borsh_1.deserialize)(this.schema, FixedPriceOffer, data);\n    }\n    /**\n     * This function can be used to retrieve and deserialize a fixed price offer\n     * @param connection The Solana RPC connection object\n     * @param key The key of the fixed price offer\n     * @returns\n     */\n    static async retrieve(connection, key) {\n        const accountInfo = await connection.getAccountInfo(key);\n        if (!accountInfo || !accountInfo.data) {\n            throw new Error(\"Fixed price offer not found\");\n        }\n        return this.deserialize(accountInfo.data);\n    }\n    /**\n     * This function can be used to derive the key of a fixed price offer\n     * @param programId The name offer program ID\n     * @param owner The owner of the fixed price\n     * @param quoteMint The quote mint of the fixed price offer\n     * @param nameAccount The name account of the fixed price offer\n     * @returns\n     */\n    static async getKey(programId, owner, quoteMint, nameAccount) {\n        return await web3_js_1.PublicKey.findProgramAddress([\n            Buffer.from(\"fixed_price_offer\"),\n            owner.toBuffer(),\n            quoteMint.toBuffer(),\n            nameAccount.toBuffer(),\n        ], programId);\n    }\n}\nexports.FixedPriceOffer = FixedPriceOffer;\nFixedPriceOffer.schema = new Map([\n    [\n        FixedPriceOffer,\n        {\n            kind: \"struct\",\n            fields: [\n                [\"tag\", \"u8\"],\n                [\"nonce\", \"u8\"],\n                [\"nameAccount\", [32]],\n                [\"owner\", [32]],\n                [\"quoteMint\", [32]],\n                [\"offerAmount\", \"u64\"],\n                [\"tokenDestination\", [32]],\n            ],\n        },\n    ],\n]);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.signAndSendTransactionInstructions = exports.sleep = exports.getAllFixedPrice = exports.getFixedPriceOffersForOwner = exports.getFixedPriceOffersForName = exports.getOffersForOwner = exports.getOffersForName = void 0;\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst bindings_1 = require(\"./bindings\");\nconst state_1 = require(\"./state\");\nconst getOffersForName = async (connection, name) => {\n    const filters = [\n        {\n            memcmp: {\n                offset: 1 + 1,\n                bytes: name.toBase58(),\n            },\n        },\n        {\n            memcmp: {\n                offset: 0,\n                bytes: \"2\",\n            },\n        },\n    ];\n    const result = await connection.getProgramAccounts(bindings_1.NAME_OFFERS_ID, {\n        filters,\n    });\n    return result.map((r) => {\n        return { pubkey: r.pubkey, offer: state_1.Offer.deserialize(r.account.data) };\n    });\n};\nexports.getOffersForName = getOffersForName;\nconst getOffersForOwner = async (connection, owner) => {\n    const filters = [\n        {\n            memcmp: {\n                offset: 1 + 1 + 32,\n                bytes: owner.toBase58(),\n            },\n        },\n        {\n            memcmp: {\n                offset: 0,\n                bytes: \"2\",\n            },\n        },\n    ];\n    const result = await connection.getProgramAccounts(bindings_1.NAME_OFFERS_ID, {\n        filters,\n    });\n    return result.map((r) => {\n        return { pubkey: r.pubkey, offer: state_1.Offer.deserialize(r.account.data) };\n    });\n};\nexports.getOffersForOwner = getOffersForOwner;\nconst getFixedPriceOffersForName = async (connection, name) => {\n    const filters = [\n        {\n            memcmp: {\n                offset: 1 + 1,\n                bytes: name.toBase58(),\n            },\n        },\n        {\n            memcmp: {\n                offset: 0,\n                bytes: \"6\",\n            },\n        },\n    ];\n    const result = await connection.getProgramAccounts(bindings_1.NAME_OFFERS_ID, {\n        filters,\n    });\n    return result.map((r) => {\n        return {\n            pubkey: r.pubkey,\n            offer: state_1.FixedPriceOffer.deserialize(r.account.data),\n        };\n    });\n};\nexports.getFixedPriceOffersForName = getFixedPriceOffersForName;\nconst getFixedPriceOffersForOwner = async (connection, owner) => {\n    const filters = [\n        {\n            memcmp: {\n                offset: 1 + 1 + 32,\n                bytes: owner.toBase58(),\n            },\n        },\n        {\n            memcmp: {\n                offset: 0,\n                bytes: \"6\",\n            },\n        },\n    ];\n    const result = await connection.getProgramAccounts(bindings_1.NAME_OFFERS_ID, {\n        filters,\n    });\n    return result.map((r) => {\n        return {\n            pubkey: r.pubkey,\n            offer: state_1.FixedPriceOffer.deserialize(r.account.data),\n        };\n    });\n};\nexports.getFixedPriceOffersForOwner = getFixedPriceOffersForOwner;\nconst getAllFixedPrice = async (connection) => {\n    const filters = [\n        {\n            memcmp: {\n                offset: 0,\n                bytes: \"6\",\n            },\n        },\n    ];\n    const result = await connection.getProgramAccounts(bindings_1.NAME_OFFERS_ID, {\n        filters,\n    });\n    return result.map((r) => {\n        return {\n            pubkey: r.pubkey,\n            offer: state_1.FixedPriceOffer.deserialize(r.account.data),\n        };\n    });\n};\nexports.getAllFixedPrice = getAllFixedPrice;\nasync function sleep(ms) {\n    console.log(\"Sleeping for \", ms, \" ms\");\n    return await new Promise((resolve) => setTimeout(resolve, ms));\n}\nexports.sleep = sleep;\nconst signAndSendTransactionInstructions = async (\n// sign and send transaction\nconnection, signers, feePayer, txInstructions) => {\n    const tx = new web3_js_1.Transaction();\n    tx.feePayer = feePayer.publicKey;\n    signers.push(feePayer);\n    tx.add(...txInstructions);\n    return await connection.sendTransaction(tx, signers, {\n        skipPreflight: false,\n    });\n};\nexports.signAndSendTransactionInstructions = signAndSendTransactionInstructions;\n"],"names":[],"sourceRoot":"","x_google_ignoreList":[0,1,2,3,4]}