{"version":3,"file":"bundled/npm-ns.metaplex.js.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAA0B;AAC+J;AACpJ;AACO;AACqF;AAC3D;AAC8I;AAC3J;AACoB;AACtD;AAC0C;AACyP;AAC9O;AACwM;AACrN;AAC+F;;AAE9J;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,QAAQ,iBAAiB,MAAM;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb,SAAS;AACT;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,YAAY;AAChF,sEAAsE,YAAY,SAAS,sBAAsB;AACjH;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mCAAmC,8BAA8B;AACjE;AACA,aAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA,kBAAkB,8DAAa;AAC/B;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,kBAAkB,8DAAa;AAC/B;AACA,KAAK;AACL;AACA,yBAAyB,uDAAY;AACrC;AACA;AACA;AAC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9D,wBAAwB;AACxB;AACA,iCAAiC,uEAAK;AACtC,2EAA2E,4DAAa;AACxF;AACA,qDAAqD,kBAAkB;AACvE,uCAAuC,kFAAgB;AACvD,kCAAkC,oDAAO;AACzC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB,gDAAgD;AAChE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,+BAA+B,yFAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,aAAa;AACb,CAAC;;AAED,qBAAqB,sCAAsC;AAC3D,0BAA0B,oEAAK;AAC/B,mBAAmB,uEAAQ,GAAG,4BAA4B;AAC1D,mBAAmB,sDAAS;AAC5B;AACA;AACA,KAAK;AACL,yCAAyC,+BAA+B;AACxE,aAAa;AACb,CAAC;;AAED,uBAAuB,0DAA0D;AACjF,0BAA0B,oEAAK;AAC/B,2BAA2B,0EAAW;AACtC,mBAAmB,yEAAU,GAAG,4BAA4B;AAC5D,mBAAmB,sDAAS;AAC5B;AACA;AACA;AACA;AACA,KAAK;AACL,yCAAyC,+BAA+B;AACxE,aAAa;AACb,CAAC;;AAED,mBAAmB,qCAAqC;AACxD,YAAY,+DAA+D;AAC3E,8BAA8B,6EAAQ;AACtC,6BAA6B,kFAAa;AAC1C,YAAY,qDAAqD,UAAU,IAAI;AAC/E,kDAAkD,gBAAgB;AAClE;AACA,4BAA4B,4EAAO;AACnC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL,6BAA6B,qFAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,iCAAiC,mFAAc;AAC/C;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,gCAAgC,wFAAmB,GAAG,4BAA4B;AAClF;AACA;AACA;AACA;AACA;AACA,sDAAsD,8CAAE;AACxD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,iCAAiC,yDAAyD,IAAI;AAC9F,4BAA4B,kFAAa;AACzC,gCAAgC,6EAAQ;AACxC,6BAA6B,kEAAO;AACpC,2BAA2B,kFAAa;AACxC,mDAAmD,8CAAE;AACrD,YAAY,+DAA+D;AAC3E,+BAA+B,oDAAK,2BAA2B,0EAA2B,EAAE,+DAAgB;AAC5G,8BAA8B,6EAAQ;AACtC,gCAAgC,kFAAa;AAC7C,6BAA6B,4EAAO;AACpC,uCAAuC,4GAAuC,GAAG,4BAA4B;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,0BAA0B,iEAAiE,IAAI;AAC/F,2BAA2B,6EAAQ;AACnC,iCAAiC,mFAAc,GAAG,4BAA4B;AAC9E;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED,+BAA+B,8DAA8D,IAAI;AACjG,2BAA2B,6EAAQ;AACnC,0BAA0B,kFAAa;AACvC,iCAAiC,wFAAmB,GAAG,4BAA4B;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED,wBAAwB,0CAA0C,IAAI;AACtE,2BAA2B,6EAAQ;AACnC,uBAAuB,iFAAY,GAAG,4BAA4B;AAClE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED,0BAA0B,6FAA6F,IAAI;AAC3H,2BAA2B,6EAAQ;AACnC,yBAAyB,mFAAc,GAAG,4BAA4B;AACtE;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED,qBAAqB,2DAA2D;AAChF;AACA,iCAAiC,6EAAc;AAC/C,0BAA0B,6EAAc;AACxC,YAAY,QAAQ,WAAW,IAAI;AACnC,iCAAiC,sDAAS;AAC1C,sBAAsB,sDAAS;AAC/B,kCAAkC,8EAAe;AACjD,4BAA4B,wEAAS;AACrC,6BAA6B,6EAAc;AAC3C,iFAAiF,4DAAa;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,aAAa;AACb,CAAC;AACD,oCAAoC,mIAAmI;AACvK,4CAA4C,kBAAkB;AAC9D;AACA,wBAAwB,oDAAO;AAC/B,uEAAuE,kBAAkB;AACzF;AACA;AACA,kBAAkB,0DAAW;AAC7B,SAAS;AACT,iDAAiD,sEAAW,OAAO,oDAAK,+BAA+B,+DAAgB;AACvH;AACA;AACA;AACA;AACA;AACA,qCAAqC,wEAAS,GAAG,kBAAkB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;;AAED,oBAAoB,sDAAsD;AAC1E;AACA,iFAAiF,4DAAa;AAC9F,iCAAiC,6EAAc;AAC/C,0BAA0B,6EAAc;AACxC,YAAY,QAAQ,WAAW,IAAI;AACnC,iCAAiC,sDAAS;AAC1C,sBAAsB,sDAAS;AAC/B,kCAAkC,8EAAe;AACjD,4BAA4B,wEAAS;AACrC,6BAA6B,6EAAc;AAC3C,0CAA0C,kBAAkB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,wBAAwB,oDAAO;AAC/B,oEAAoE,kBAAkB;AACtF;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,YAAY,qEAAqE;AACjF;AACA;AACA;AACA,YAAY,iEAAiE;AAC7E;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oCAAoC,uEAAQ,GAAG,kBAAkB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,aAAa;AACb,CAAC;;AAED,uCAAuC,qCAAqC;AAC5E;AACA,iFAAiF,4DAAa;AAC9F,iCAAiC,6EAAc;AAC/C,0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;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,uBAAuB,6CAA6C;AACpE,wBAAwB;AACxB;AACA,QAAQ,sEAAO;AACf,QAAQ,8EAAe;AACvB;AACA,6BAA6B,gFAAiB,+BAA+B,sBAAsB,oEAAoE;AACvK,0BAA0B,4EAAa;AACvC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,aAAa;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,WAAW,8DAAU;AACrB,QAAQ,0DAAO;AACf,YAAY,8DAAW;AACvB,YAAY,oEAAgB;AAC5B,SAAS,iEAAa;AACtB,CAAC;;AAE4L","sources":["webpack://mask-network/./node_modules/.pnpm/@metaplex+js@4.11.7_@metaplex-foundation+mpl-auction@0.0.2_@metaplex-foundation+mpl-core@0.0._7uazmvunxxghvixol5yhx34wd4/node_modules/@metaplex/js/lib/index.browser.esm.js"],"sourcesContent":["import axios from 'axios';\nimport { clusterApiUrl, Connection as Connection$1, SystemProgram, PublicKey, TransactionInstruction, SYSVAR_RENT_PUBKEY, Keypair, Transaction as Transaction$1 } from '@solana/web3.js';\nimport { sha256 } from 'crypto-hash';\nimport { Buffer as Buffer$1 } from 'buffer';\nimport { MintLayout, TOKEN_PROGRAM_ID, Token, AccountLayout, ASSOCIATED_TOKEN_PROGRAM_ID, NATIVE_MINT } from '@solana/spl-token';\nimport * as mplTokenVault from '@metaplex-foundation/mpl-token-vault';\nimport { Vault, SafetyDepositBox, AddTokenToInactiveVault, ActivateVault, CombineVault, ExternalPriceAccountData, VaultProgram, UpdateExternalPriceAccount, InitVault } from '@metaplex-foundation/mpl-token-vault';\nimport * as mplCore from '@metaplex-foundation/mpl-core';\nimport { Transaction, config, Account } from '@metaplex-foundation/mpl-core';\nimport BN from 'bn.js';\nimport * as mplMetaplex from '@metaplex-foundation/mpl-metaplex';\nimport { Store, SetStore, StoreConfig, SetStoreV2, AuctionManager, MetaplexProgram, SafetyDepositConfig, RedeemFullRightsTransferBid, PrizeTrackingTicket, RedeemPrintingV2Bid, RedeemParticipationBidV3, WinningConstraint, NonWinningConstraint, ClaimBid, WinningConfigType } from '@metaplex-foundation/mpl-metaplex';\nimport * as mplTokenMetadata from '@metaplex-foundation/mpl-token-metadata';\nimport { Metadata, MasterEdition, Creator, MetadataDataData, CreateMetadata, CreateMasterEdition, EditionMarker, Edition, MintNewEditionFromMasterEditionViaToken, SignMetadata, UpdateMetadata, UpdatePrimarySaleHappenedViaToken } from '@metaplex-foundation/mpl-token-metadata';\nimport * as mplAuction from '@metaplex-foundation/mpl-auction';\nimport { AuctionExtended, BidderPot, BidderMetadata, CancelBid, PlaceBid, Auction, CreateAuctionArgs, CreateAuction } from '@metaplex-foundation/mpl-auction';\n\nvar Currency;\r\n(function (Currency) {\r\n    Currency[\"USD\"] = \"usd\";\r\n    Currency[\"EUR\"] = \"eur\";\r\n    Currency[\"AR\"] = \"ar\";\r\n    Currency[\"SOL\"] = \"sol\";\r\n})(Currency || (Currency = {}));\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\nclass Coingecko {\r\n    static translateCurrency(currency) {\r\n        switch (currency) {\r\n            case Currency.AR:\r\n                return 'arweave';\r\n            case Currency.SOL:\r\n                return 'solana';\r\n            case Currency.USD:\r\n                return 'usd';\r\n            case Currency.EUR:\r\n                return 'eur';\r\n            default:\r\n                throw new Error('Invalid currency supplied to Coingecko conversion rate provider');\r\n        }\r\n    }\r\n    getRate(from, to) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const fromArray = typeof from === 'string' ? [from] : from;\r\n            const toArray = typeof to === 'string' ? [to] : to;\r\n            const fromIds = fromArray.map((currency) => Coingecko.translateCurrency(currency)).join(',');\r\n            const toIds = toArray.map((currency) => Coingecko.translateCurrency(currency)).join(',');\r\n            const url = `https://api.coingecko.com/api/v3/simple/price?ids=${fromIds}&vs_currencies=${toIds}`;\r\n            const response = yield axios(url);\r\n            const data = yield response.data;\r\n            return fromArray.reduce((previousPairs, fromCurrency) => {\r\n                return [\r\n                    ...previousPairs,\r\n                    ...toArray.map((toCurrency) => ({\r\n                        from: fromCurrency,\r\n                        to: toCurrency,\r\n                        rate: data[Coingecko.translateCurrency(fromCurrency)][Coingecko.translateCurrency(toCurrency)],\r\n                    })),\r\n                ];\r\n            }, []);\r\n        });\r\n    }\r\n}\n\n/* eslint-env browser */\n\nvar browser = typeof self == 'object' ? self.FormData : window.FormData;\n\nconst ARWEAVE_URL = 'https://arweave.net';\r\nconst LAMPORT_MULTIPLIER = Math.pow(10, 9);\r\nconst WINSTON_MULTIPLIER = Math.pow(10, 12);\r\nclass ArweaveStorage {\r\n    constructor({ endpoint, env }) {\r\n        this.endpoint = endpoint;\r\n        this.env = env;\r\n    }\r\n    getAssetCostToStore(files, arweaveRate, solanaRate) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const buffers = Array.from(files.values());\r\n            const totalBytes = buffers.reduce((sum, f) => (sum += f.byteLength), 0);\r\n            const txnFeeInWinstons = parseInt(yield (yield axios(`${ARWEAVE_URL}/price/0`)).data);\r\n            const byteCostInWinstons = parseInt(yield (yield axios(`${ARWEAVE_URL}/price/${totalBytes.toString()}`)).data);\r\n            const totalArCost = (txnFeeInWinstons * buffers.length + byteCostInWinstons) / WINSTON_MULTIPLIER;\r\n            const arMultiplier = arweaveRate / solanaRate;\r\n            return LAMPORT_MULTIPLIER * totalArCost * arMultiplier * 1.1;\r\n        });\r\n    }\r\n    upload(files, mintKey, txid) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const fileEntries = Array.from(files.entries());\r\n            const tags = fileEntries.reduce((acc, [fileName]) => {\r\n                acc[fileName] = [{ name: 'mint', value: mintKey }];\r\n                return acc;\r\n            }, {});\r\n            const body = new browser();\r\n            body.append('tags', JSON.stringify(tags));\r\n            body.append('transaction', txid);\r\n            body.append('env', this.env);\r\n            fileEntries.map(([, file]) => {\r\n                body.append('file[]', file);\r\n            });\r\n            const response = yield axios.post(this.endpoint, body);\r\n            if (response.data.error) {\r\n                return Promise.reject(new Error(response.data.error));\r\n            }\r\n            return response.data;\r\n        });\r\n    }\r\n}\n\nclass Storage {\r\n}\n\nvar Storage$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  Storage: Storage\n});\n\nvar ChainId;\r\n(function (ChainId) {\r\n    ChainId[ChainId[\"MainnetBeta\"] = 101] = \"MainnetBeta\";\r\n    ChainId[ChainId[\"Testnet\"] = 102] = \"Testnet\";\r\n    ChainId[ChainId[\"Devnet\"] = 103] = \"Devnet\";\r\n})(ChainId || (ChainId = {}));\r\nconst ENV = {\r\n    devnet: {\r\n        endpoint: clusterApiUrl('devnet'),\r\n        ChainId: ChainId.Devnet,\r\n    },\r\n    'mainnet-beta': {\r\n        endpoint: 'https://api.metaplex.solana.com/',\r\n        ChainId: ChainId.MainnetBeta,\r\n    },\r\n    'mainnet-beta (Solana)': {\r\n        endpoint: 'https://api.mainnet-beta.solana.com',\r\n        ChainId: ChainId.MainnetBeta,\r\n    },\r\n    'mainnet-beta (Serum)': {\r\n        endpoint: 'https://solana-api.projectserum.com/',\r\n        ChainId: ChainId.MainnetBeta,\r\n    },\r\n    testnet: {\r\n        endpoint: clusterApiUrl('testnet'),\r\n        ChainId: ChainId.Testnet,\r\n    },\r\n};\r\nclass Connection extends Connection$1 {\r\n    constructor(endpoint = 'mainnet-beta', commitment) {\r\n        if (endpoint in ENV)\r\n            endpoint = ENV[endpoint].endpoint;\r\n        super(endpoint, commitment);\r\n    }\r\n}\n\nclass NodeWallet {\r\n    constructor(payer) {\r\n        this.payer = payer;\r\n    }\r\n    signTransaction(tx) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            tx.partialSign(this.payer);\r\n            return tx;\r\n        });\r\n    }\r\n    signAllTransactions(txs) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return txs.map((tx) => {\r\n                tx.partialSign(this.payer);\r\n                return tx;\r\n            });\r\n        });\r\n    }\r\n    get publicKey() {\r\n        return this.payer.publicKey;\r\n    }\r\n}\n\nconst getFileHash = (file) => __awaiter(void 0, void 0, void 0, function* () { return Buffer$1.from(yield sha256(file.toString())); });\n\nvar crypto = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  getFileHash: getFileHash\n});\n\nconst lookup = (url) => __awaiter(void 0, void 0, void 0, function* () {\r\n    try {\r\n        const { data } = yield axios.get(url);\r\n        return data;\r\n    }\r\n    catch (_a) {\r\n        throw new Error(`unable to get metadata json from url ${url}`);\r\n    }\r\n});\n\nvar metadata = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  lookup: lookup\n});\n\nvar index$3 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  Crypto: crypto,\n  metadata: metadata\n});\n\nclass PayForFiles extends Transaction {\r\n    constructor(options, params) {\r\n        const { feePayer } = options;\r\n        const { lamports, fileHashes, arweaveWallet } = params;\r\n        super(options);\r\n        this.add(SystemProgram.transfer({\r\n            fromPubkey: feePayer,\r\n            toPubkey: arweaveWallet !== null && arweaveWallet !== void 0 ? arweaveWallet : new PublicKey(config.arweaveWallet),\r\n            lamports,\r\n        }));\r\n        fileHashes.forEach((data) => {\r\n            this.add(new TransactionInstruction({\r\n                keys: [],\r\n                programId: new PublicKey(config.programs.memo),\r\n                data,\r\n            }));\r\n        });\r\n    }\r\n}\n\nclass CreateMint extends Transaction {\r\n    constructor(options, params) {\r\n        const { feePayer } = options;\r\n        const { newAccountPubkey, lamports, decimals, owner, freezeAuthority } = params;\r\n        super(options);\r\n        this.add(SystemProgram.createAccount({\r\n            fromPubkey: feePayer,\r\n            newAccountPubkey,\r\n            lamports,\r\n            space: MintLayout.span,\r\n            programId: TOKEN_PROGRAM_ID,\r\n        }));\r\n        this.add(Token.createInitMintInstruction(TOKEN_PROGRAM_ID, newAccountPubkey, decimals !== null && decimals !== void 0 ? decimals : 0, owner !== null && owner !== void 0 ? owner : feePayer, freezeAuthority !== null && freezeAuthority !== void 0 ? freezeAuthority : feePayer));\r\n    }\r\n}\n\nclass CreateTokenAccount extends Transaction {\r\n    constructor(options, params) {\r\n        const { feePayer } = options;\r\n        const { newAccountPubkey, lamports, mint, owner } = params;\r\n        super(options);\r\n        this.add(SystemProgram.createAccount({\r\n            fromPubkey: feePayer,\r\n            newAccountPubkey,\r\n            lamports,\r\n            space: AccountLayout.span,\r\n            programId: TOKEN_PROGRAM_ID,\r\n        }));\r\n        this.add(Token.createInitAccountInstruction(TOKEN_PROGRAM_ID, mint, newAccountPubkey, owner !== null && owner !== void 0 ? owner : feePayer));\r\n    }\r\n}\n\nclass CreateAssociatedTokenAccount extends Transaction {\r\n    constructor(options, params) {\r\n        const { feePayer } = options;\r\n        const { associatedTokenAddress, walletAddress, splTokenMintAddress } = params;\r\n        super(options);\r\n        this.add(new TransactionInstruction({\r\n            keys: [\r\n                {\r\n                    pubkey: feePayer,\r\n                    isSigner: true,\r\n                    isWritable: true,\r\n                },\r\n                {\r\n                    pubkey: associatedTokenAddress,\r\n                    isSigner: false,\r\n                    isWritable: true,\r\n                },\r\n                {\r\n                    pubkey: walletAddress !== null && walletAddress !== void 0 ? walletAddress : feePayer,\r\n                    isSigner: false,\r\n                    isWritable: false,\r\n                },\r\n                {\r\n                    pubkey: splTokenMintAddress,\r\n                    isSigner: false,\r\n                    isWritable: false,\r\n                },\r\n                {\r\n                    pubkey: SystemProgram.programId,\r\n                    isSigner: false,\r\n                    isWritable: false,\r\n                },\r\n                {\r\n                    pubkey: TOKEN_PROGRAM_ID,\r\n                    isSigner: false,\r\n                    isWritable: false,\r\n                },\r\n                {\r\n                    pubkey: SYSVAR_RENT_PUBKEY,\r\n                    isSigner: false,\r\n                    isWritable: false,\r\n                },\r\n            ],\r\n            programId: ASSOCIATED_TOKEN_PROGRAM_ID,\r\n            data: Buffer$1.from([]),\r\n        }));\r\n    }\r\n}\n\nclass MintTo extends Transaction {\r\n    constructor(options, params) {\r\n        const { feePayer } = options;\r\n        const { mint, dest, authority, amount } = params;\r\n        super(options);\r\n        this.add(Token.createMintToInstruction(TOKEN_PROGRAM_ID, mint, dest, authority !== null && authority !== void 0 ? authority : feePayer, [], new BN(amount).toNumber()));\r\n    }\r\n}\n\nvar index$2 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  PayForFiles: PayForFiles,\n  CreateMint: CreateMint,\n  CreateTokenAccount: CreateTokenAccount,\n  CreateAssociatedTokenAccount: CreateAssociatedTokenAccount,\n  MintTo: MintTo\n});\n\nfunction prepareTokenAccountAndMintTxs(connection, owner) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        const mint = Keypair.generate();\r\n        const mintRent = yield connection.getMinimumBalanceForRentExemption(MintLayout.span);\r\n        const createMintTx = new CreateMint({ feePayer: owner }, {\r\n            newAccountPubkey: mint.publicKey,\r\n            lamports: mintRent,\r\n        });\r\n        const recipient = yield Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, mint.publicKey, owner);\r\n        const createAssociatedTokenAccountTx = new CreateAssociatedTokenAccount({ feePayer: owner }, {\r\n            associatedTokenAddress: recipient,\r\n            splTokenMintAddress: mint.publicKey,\r\n        });\r\n        const mintToTx = new MintTo({ feePayer: owner }, {\r\n            mint: mint.publicKey,\r\n            dest: recipient,\r\n            amount: 1,\r\n        });\r\n        return { mint, createMintTx, createAssociatedTokenAccountTx, mintToTx, recipient };\r\n    });\r\n}\n\nfunction createWrappedAccountTxs(connection, owner, amount = 0) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        const account = Keypair.generate();\r\n        const accountRentExempt = yield connection.getMinimumBalanceForRentExemption(AccountLayout.span);\r\n        const createTokenAccountTx = new CreateTokenAccount({ feePayer: owner }, {\r\n            newAccountPubkey: account.publicKey,\r\n            lamports: amount + accountRentExempt,\r\n            mint: NATIVE_MINT,\r\n        });\r\n        const closeTokenAccountTx = new Transaction().add(Token.createCloseAccountInstruction(TOKEN_PROGRAM_ID, account.publicKey, owner, owner, []));\r\n        return { account, createTokenAccountTx, closeTokenAccountTx };\r\n    });\r\n}\n\nfunction createApproveTxs(args) {\r\n    const { authority = Keypair.generate(), account, owner, amount } = args;\r\n    const createApproveTx = new Transaction$1().add(Token.createApproveInstruction(TOKEN_PROGRAM_ID, account, authority.publicKey, owner, [], amount));\r\n    const createRevokeTx = new Transaction$1().add(Token.createRevokeInstruction(TOKEN_PROGRAM_ID, account, owner, []));\r\n    return { authority, createApproveTx, createRevokeTx };\r\n}\n\nconst sendTransaction = ({ connection, wallet, txs, signers = [], options, }) => __awaiter(void 0, void 0, void 0, function* () {\r\n    let tx = Transaction.fromCombined(txs, { feePayer: wallet.publicKey });\r\n    tx.recentBlockhash = (yield connection.getRecentBlockhash()).blockhash;\r\n    if (signers.length) {\r\n        tx.partialSign(...signers);\r\n    }\r\n    tx = yield wallet.signTransaction(tx);\r\n    return connection.sendRawTransaction(tx.serialize(), options);\r\n});\n\nclass TransactionsBatch {\r\n    constructor({ beforeTransactions = [], transactions, afterTransactions = [], }) {\r\n        this.signers = [];\r\n        this.beforeTransactions = beforeTransactions;\r\n        this.transactions = transactions;\r\n        this.afterTransactions = afterTransactions;\r\n    }\r\n    addSigner(signer) {\r\n        this.signers.push(signer);\r\n    }\r\n    addBeforeTransaction(transaction) {\r\n        this.beforeTransactions.push(transaction);\r\n    }\r\n    addTransaction(transaction) {\r\n        this.transactions.push(transaction);\r\n    }\r\n    addAfterTransaction(transaction) {\r\n        this.afterTransactions.push(transaction);\r\n    }\r\n    toTransactions() {\r\n        return [...this.beforeTransactions, ...this.transactions, ...this.afterTransactions];\r\n    }\r\n    toInstructions() {\r\n        return this.toTransactions().flatMap((t) => t.instructions);\r\n    }\r\n}\n\nconst addTokensToVault = ({ connection, wallet, vault, nfts, }) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const txOptions = { feePayer: wallet.publicKey };\r\n    const safetyDepositTokenStores = [];\r\n    const vaultAuthority = yield Vault.getPDA(vault);\r\n    const accountRent = yield connection.getMinimumBalanceForRentExemption(AccountLayout.span);\r\n    for (const nft of nfts) {\r\n        const tokenTxBatch = new TransactionsBatch({ transactions: [] });\r\n        const safetyDepositBox = yield SafetyDepositBox.getPDA(vault, nft.tokenMint);\r\n        const tokenStoreAccount = Keypair.generate();\r\n        const tokenStoreAccountTx = new CreateTokenAccount(txOptions, {\r\n            newAccountPubkey: tokenStoreAccount.publicKey,\r\n            lamports: accountRent,\r\n            mint: nft.tokenMint,\r\n            owner: vaultAuthority,\r\n        });\r\n        tokenTxBatch.addTransaction(tokenStoreAccountTx);\r\n        tokenTxBatch.addSigner(tokenStoreAccount);\r\n        const { authority: transferAuthority, createApproveTx } = createApproveTxs({\r\n            account: nft.tokenAccount,\r\n            owner: wallet.publicKey,\r\n            amount: nft.amount.toNumber(),\r\n        });\r\n        tokenTxBatch.addTransaction(createApproveTx);\r\n        tokenTxBatch.addSigner(transferAuthority);\r\n        const addTokenTx = new AddTokenToInactiveVault(txOptions, {\r\n            vault,\r\n            vaultAuthority: wallet.publicKey,\r\n            tokenAccount: nft.tokenAccount,\r\n            tokenStoreAccount: tokenStoreAccount.publicKey,\r\n            transferAuthority: transferAuthority.publicKey,\r\n            safetyDepositBox: safetyDepositBox,\r\n            amount: nft.amount,\r\n        });\r\n        tokenTxBatch.addTransaction(addTokenTx);\r\n        const txId = yield sendTransaction({\r\n            connection,\r\n            wallet,\r\n            txs: tokenTxBatch.transactions,\r\n            signers: tokenTxBatch.signers,\r\n        });\r\n        safetyDepositTokenStores.push({\r\n            txId,\r\n            tokenStoreAccount: tokenStoreAccount.publicKey,\r\n            tokenMint: nft.tokenMint,\r\n            tokenAccount: nft.tokenAccount,\r\n        });\r\n    }\r\n    return { safetyDepositTokenStores };\r\n});\n\nconst initStore = ({ connection, wallet, isPublic = true, }) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const storeId = yield Store.getPDA(wallet.publicKey);\r\n    const tx = new SetStore({ feePayer: wallet.publicKey }, {\r\n        admin: new PublicKey(wallet.publicKey),\r\n        store: storeId,\r\n        isPublic,\r\n    });\r\n    const txId = yield sendTransaction({ connection, wallet, txs: [tx] });\r\n    return { storeId, txId };\r\n});\n\nconst initStoreV2 = ({ connection, wallet, settingsUri = null, isPublic = true, }) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const storeId = yield Store.getPDA(wallet.publicKey);\r\n    const configId = yield StoreConfig.getPDA(storeId);\r\n    const tx = new SetStoreV2({ feePayer: wallet.publicKey }, {\r\n        admin: new PublicKey(wallet.publicKey),\r\n        store: storeId,\r\n        config: configId,\r\n        isPublic,\r\n        settingsUri,\r\n    });\r\n    const txId = yield sendTransaction({ connection, wallet, txs: [tx] });\r\n    return { storeId, configId, txId };\r\n});\n\nconst mintNFT = ({ connection, wallet, uri, maxSupply, }) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const { mint, createMintTx, createAssociatedTokenAccountTx, mintToTx } = yield prepareTokenAccountAndMintTxs(connection, wallet.publicKey);\r\n    const metadataPDA = yield Metadata.getPDA(mint.publicKey);\r\n    const editionPDA = yield MasterEdition.getPDA(mint.publicKey);\r\n    const { name, symbol, seller_fee_basis_points, properties: { creators }, } = yield lookup(uri);\r\n    const creatorsData = creators.reduce((memo, { address, share }) => {\r\n        const verified = address === wallet.publicKey.toString();\r\n        const creator = new Creator({\r\n            address,\r\n            share,\r\n            verified,\r\n        });\r\n        memo = [...memo, creator];\r\n        return memo;\r\n    }, []);\r\n    const metadataData = new MetadataDataData({\r\n        name,\r\n        symbol,\r\n        uri,\r\n        sellerFeeBasisPoints: seller_fee_basis_points,\r\n        creators: creatorsData,\r\n    });\r\n    const createMetadataTx = new CreateMetadata({\r\n        feePayer: wallet.publicKey,\r\n    }, {\r\n        metadata: metadataPDA,\r\n        metadataData,\r\n        updateAuthority: wallet.publicKey,\r\n        mint: mint.publicKey,\r\n        mintAuthority: wallet.publicKey,\r\n    });\r\n    const masterEditionTx = new CreateMasterEdition({ feePayer: wallet.publicKey }, {\r\n        edition: editionPDA,\r\n        metadata: metadataPDA,\r\n        updateAuthority: wallet.publicKey,\r\n        mint: mint.publicKey,\r\n        mintAuthority: wallet.publicKey,\r\n        maxSupply: maxSupply || maxSupply === 0 ? new BN(maxSupply) : null,\r\n    });\r\n    const txId = yield sendTransaction({\r\n        connection,\r\n        signers: [mint],\r\n        txs: [\r\n            createMintTx,\r\n            createMetadataTx,\r\n            createAssociatedTokenAccountTx,\r\n            mintToTx,\r\n            masterEditionTx,\r\n        ],\r\n        wallet,\r\n    });\r\n    return {\r\n        txId,\r\n        mint: mint.publicKey,\r\n        metadata: metadataPDA,\r\n        edition: editionPDA,\r\n    };\r\n});\n\nconst mintEditionFromMaster = ({ connection, wallet, masterEditionMint, updateAuthority } = {}) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const masterPDA = yield MasterEdition.getPDA(masterEditionMint);\r\n    const masterMetaPDA = yield Metadata.getPDA(masterEditionMint);\r\n    const masterInfo = yield Account.getInfo(connection, masterPDA);\r\n    const masterData = new MasterEdition(masterPDA, masterInfo).data;\r\n    const editionValue = masterData.supply.add(new BN(1));\r\n    const { mint, createMintTx, createAssociatedTokenAccountTx, mintToTx } = yield prepareTokenAccountAndMintTxs(connection, wallet.publicKey);\r\n    const tokenAccount = yield Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, masterEditionMint, wallet.publicKey);\r\n    const metadataPDA = yield Metadata.getPDA(mint.publicKey);\r\n    const editionMarker = yield EditionMarker.getPDA(masterEditionMint, editionValue);\r\n    const editionPDA = yield Edition.getPDA(mint.publicKey);\r\n    const newEditionFromMasterTx = new MintNewEditionFromMasterEditionViaToken({ feePayer: wallet.publicKey }, {\r\n        edition: editionPDA,\r\n        metadata: metadataPDA,\r\n        updateAuthority: updateAuthority !== null && updateAuthority !== void 0 ? updateAuthority : wallet.publicKey,\r\n        mint: mint.publicKey,\r\n        mintAuthority: wallet.publicKey,\r\n        masterEdition: masterPDA,\r\n        masterMetadata: masterMetaPDA,\r\n        editionMarker,\r\n        tokenOwner: wallet.publicKey,\r\n        tokenAccount,\r\n        editionValue,\r\n    });\r\n    const txId = yield sendTransaction({\r\n        connection,\r\n        signers: [mint],\r\n        txs: [createMintTx, createAssociatedTokenAccountTx, mintToTx, newEditionFromMasterTx],\r\n        wallet,\r\n    });\r\n    return {\r\n        txId,\r\n        mint: mint.publicKey,\r\n        metadata: metadataPDA,\r\n        edition: editionPDA,\r\n    };\r\n});\n\nconst createMetadata = ({ connection, wallet, editionMint, metadataData, updateAuthority } = {}) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const metadata = yield Metadata.getPDA(editionMint);\r\n    const createMetadataTx = new CreateMetadata({ feePayer: wallet.publicKey }, {\r\n        metadata,\r\n        metadataData,\r\n        updateAuthority: updateAuthority !== null && updateAuthority !== void 0 ? updateAuthority : wallet.publicKey,\r\n        mint: editionMint,\r\n        mintAuthority: wallet.publicKey,\r\n    });\r\n    return sendTransaction({\r\n        connection,\r\n        signers: [],\r\n        txs: [createMetadataTx],\r\n        wallet,\r\n    });\r\n});\n\nconst createMasterEdition = ({ connection, wallet, editionMint, updateAuthority, maxSupply } = {}) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const metadata = yield Metadata.getPDA(editionMint);\r\n    const edition = yield MasterEdition.getPDA(editionMint);\r\n    const createMetadataTx = new CreateMasterEdition({ feePayer: wallet.publicKey }, {\r\n        edition,\r\n        metadata,\r\n        updateAuthority: updateAuthority !== null && updateAuthority !== void 0 ? updateAuthority : wallet.publicKey,\r\n        mint: editionMint,\r\n        mintAuthority: wallet.publicKey,\r\n        maxSupply,\r\n    });\r\n    return sendTransaction({\r\n        connection,\r\n        signers: [],\r\n        txs: [createMetadataTx],\r\n        wallet,\r\n    });\r\n});\n\nconst signMetadata = ({ connection, wallet, editionMint, signer } = {}) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const metadata = yield Metadata.getPDA(editionMint);\r\n    const signTx = new SignMetadata({ feePayer: wallet.publicKey }, {\r\n        metadata,\r\n        creator: signer ? signer.publicKey : wallet.publicKey,\r\n    });\r\n    return yield sendTransaction({\r\n        connection,\r\n        signers: signer ? [signer] : [],\r\n        txs: [signTx],\r\n        wallet,\r\n    });\r\n});\n\nconst updateMetadata = ({ connection, wallet, editionMint, newMetadataData, newUpdateAuthority, primarySaleHappened, } = {}) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const metadata = yield Metadata.getPDA(editionMint);\r\n    const updateTx = new UpdateMetadata({ feePayer: wallet.publicKey }, {\r\n        metadata,\r\n        updateAuthority: wallet.publicKey,\r\n        metadataData: newMetadataData,\r\n        newUpdateAuthority,\r\n        primarySaleHappened,\r\n    });\r\n    return sendTransaction({\r\n        connection,\r\n        signers: [],\r\n        txs: [updateTx],\r\n        wallet,\r\n    });\r\n});\n\nconst cancelBid = ({ connection, wallet, auction, bidderPotToken, destAccount, }) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const bidder = wallet.publicKey;\r\n    const auctionManager = yield AuctionManager.getPDA(auction);\r\n    const manager = yield AuctionManager.load(connection, auctionManager);\r\n    const { data: { tokenMint }, } = yield manager.getAuction(connection);\r\n    const auctionTokenMint = new PublicKey(tokenMint);\r\n    const vault = new PublicKey(manager.data.vault);\r\n    const auctionExtended = yield AuctionExtended.getPDA(vault);\r\n    const bidderPot = yield BidderPot.getPDA(auction, bidder);\r\n    const bidderMeta = yield BidderMetadata.getPDA(auction, bidder);\r\n    const accountRentExempt = yield connection.getMinimumBalanceForRentExemption(AccountLayout.span);\r\n    const txBatch = yield getCancelBidTransactions({\r\n        destAccount,\r\n        bidder,\r\n        accountRentExempt,\r\n        bidderPot,\r\n        bidderPotToken,\r\n        bidderMeta,\r\n        auction,\r\n        auctionExtended,\r\n        auctionTokenMint,\r\n        vault,\r\n    });\r\n    const txId = yield sendTransaction({\r\n        connection,\r\n        wallet,\r\n        txs: txBatch.toTransactions(),\r\n        signers: txBatch.signers,\r\n    });\r\n    return { txId };\r\n});\r\nconst getCancelBidTransactions = ({ destAccount, bidder, accountRentExempt, bidderPot, bidderPotToken, bidderMeta, auction, auctionExtended, auctionTokenMint, vault, }) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const txBatch = new TransactionsBatch({ transactions: [] });\r\n    if (!destAccount) {\r\n        const account = Keypair.generate();\r\n        const createTokenAccountTransaction = new CreateTokenAccount({ feePayer: bidder }, {\r\n            newAccountPubkey: account.publicKey,\r\n            lamports: accountRentExempt,\r\n            mint: NATIVE_MINT,\r\n        });\r\n        const closeTokenAccountInstruction = new Transaction().add(Token.createCloseAccountInstruction(TOKEN_PROGRAM_ID, account.publicKey, bidder, bidder, []));\r\n        txBatch.addTransaction(createTokenAccountTransaction);\r\n        txBatch.addAfterTransaction(closeTokenAccountInstruction);\r\n        txBatch.addSigner(account);\r\n        destAccount = account.publicKey;\r\n    }\r\n    const cancelBidTransaction = new CancelBid({ feePayer: bidder }, {\r\n        bidder,\r\n        bidderToken: destAccount,\r\n        bidderPot,\r\n        bidderPotToken,\r\n        bidderMeta,\r\n        auction,\r\n        auctionExtended,\r\n        tokenMint: auctionTokenMint,\r\n        resource: vault,\r\n    });\r\n    txBatch.addTransaction(cancelBidTransaction);\r\n    return txBatch;\r\n});\n\nconst placeBid = ({ connection, wallet, amount, auction, bidderPotToken, }) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const bidder = wallet.publicKey;\r\n    const accountRentExempt = yield connection.getMinimumBalanceForRentExemption(AccountLayout.span);\r\n    const auctionManager = yield AuctionManager.getPDA(auction);\r\n    const manager = yield AuctionManager.load(connection, auctionManager);\r\n    const { data: { tokenMint }, } = yield manager.getAuction(connection);\r\n    const auctionTokenMint = new PublicKey(tokenMint);\r\n    const vault = new PublicKey(manager.data.vault);\r\n    const auctionExtended = yield AuctionExtended.getPDA(vault);\r\n    const bidderPot = yield BidderPot.getPDA(auction, bidder);\r\n    const bidderMeta = yield BidderMetadata.getPDA(auction, bidder);\r\n    let txBatch = new TransactionsBatch({ transactions: [] });\r\n    if (bidderPotToken) {\r\n        txBatch = yield getCancelBidTransactions({\r\n            destAccount: null,\r\n            bidder,\r\n            accountRentExempt,\r\n            bidderPot,\r\n            bidderPotToken,\r\n            bidderMeta,\r\n            auction,\r\n            auctionExtended,\r\n            auctionTokenMint,\r\n            vault,\r\n        });\r\n    }\r\n    else {\r\n        const account = Keypair.generate();\r\n        const createBidderPotTransaction = new CreateTokenAccount({ feePayer: bidder }, {\r\n            newAccountPubkey: account.publicKey,\r\n            lamports: accountRentExempt,\r\n            mint: auctionTokenMint,\r\n            owner: auction,\r\n        });\r\n        txBatch.addSigner(account);\r\n        txBatch.addTransaction(createBidderPotTransaction);\r\n        bidderPotToken = account.publicKey;\r\n    }\r\n    const { account: payingAccount, createTokenAccountTx, closeTokenAccountTx, } = yield createWrappedAccountTxs(connection, bidder, amount.toNumber() + accountRentExempt * 2);\r\n    txBatch.addTransaction(createTokenAccountTx);\r\n    txBatch.addAfterTransaction(closeTokenAccountTx);\r\n    txBatch.addSigner(payingAccount);\r\n    const { authority: transferAuthority, createApproveTx, createRevokeTx, } = createApproveTxs({\r\n        account: payingAccount.publicKey,\r\n        owner: bidder,\r\n        amount: amount.toNumber(),\r\n    });\r\n    txBatch.addTransaction(createApproveTx);\r\n    txBatch.addAfterTransaction(createRevokeTx);\r\n    txBatch.addSigner(transferAuthority);\r\n    const placeBidTransaction = new PlaceBid({ feePayer: bidder }, {\r\n        bidder,\r\n        bidderToken: payingAccount.publicKey,\r\n        bidderPot,\r\n        bidderPotToken,\r\n        bidderMeta,\r\n        auction,\r\n        auctionExtended,\r\n        tokenMint: auctionTokenMint,\r\n        transferAuthority: transferAuthority.publicKey,\r\n        amount,\r\n        resource: vault,\r\n    });\r\n    txBatch.addTransaction(placeBidTransaction);\r\n    const txId = yield sendTransaction({\r\n        connection,\r\n        wallet,\r\n        txs: txBatch.toTransactions(),\r\n        signers: txBatch.signers,\r\n    });\r\n    return { txId, bidderPotToken, bidderMeta };\r\n});\n\nconst redeemFullRightsTransferBid = ({ connection, wallet, store, auction, }) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const bidder = wallet.publicKey;\r\n    const accountRentExempt = yield connection.getMinimumBalanceForRentExemption(AccountLayout.span);\r\n    const auctionManager = yield AuctionManager.getPDA(auction);\r\n    const manager = yield AuctionManager.load(connection, auctionManager);\r\n    const vault = yield Vault.load(connection, manager.data.vault);\r\n    const fractionMint = new PublicKey(vault.data.fractionMint);\r\n    const auctionExtended = yield AuctionExtended.getPDA(vault.pubkey);\r\n    const [safetyDepositBox] = yield vault.getSafetyDepositBoxes(connection);\r\n    const tokenMint = new PublicKey(safetyDepositBox.data.tokenMint);\r\n    const safetyDepositTokenStore = new PublicKey(safetyDepositBox.data.store);\r\n    const bidderMeta = yield BidderMetadata.getPDA(auction, bidder);\r\n    const bidRedemption = yield getBidRedemptionPDA(auction, bidderMeta);\r\n    const safetyDepositConfig = yield SafetyDepositConfig.getPDA(auctionManager, safetyDepositBox.pubkey);\r\n    const transferAuthority = yield Vault.getPDA(vault.pubkey);\r\n    const metadata = yield Metadata.getPDA(tokenMint);\r\n    const txBatch = yield getRedeemFRTBidTransactions({\r\n        accountRentExempt,\r\n        tokenMint,\r\n        bidder,\r\n        bidderMeta,\r\n        store,\r\n        vault: vault.pubkey,\r\n        auction,\r\n        auctionExtended,\r\n        auctionManager,\r\n        fractionMint,\r\n        safetyDepositTokenStore,\r\n        safetyDeposit: safetyDepositBox.pubkey,\r\n        bidRedemption,\r\n        safetyDepositConfig,\r\n        transferAuthority,\r\n        metadata,\r\n    });\r\n    const txId = yield sendTransaction({\r\n        connection,\r\n        wallet,\r\n        txs: txBatch.toTransactions(),\r\n        signers: txBatch.signers,\r\n    });\r\n    return { txId };\r\n});\r\nconst getRedeemFRTBidTransactions = ({ accountRentExempt, bidder, tokenMint, store, vault, auction, auctionManager, auctionExtended, bidRedemption, bidderMeta: bidMetadata, safetyDepositTokenStore, safetyDeposit, fractionMint, safetyDepositConfig, transferAuthority, metadata, }) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const txBatch = new TransactionsBatch({ transactions: [] });\r\n    const account = Keypair.generate();\r\n    const createDestinationTransaction = new CreateTokenAccount({ feePayer: bidder }, {\r\n        newAccountPubkey: account.publicKey,\r\n        lamports: accountRentExempt,\r\n        mint: tokenMint,\r\n    });\r\n    txBatch.addSigner(account);\r\n    txBatch.addTransaction(createDestinationTransaction);\r\n    const redeemBidTransaction = new RedeemFullRightsTransferBid({ feePayer: bidder }, {\r\n        store,\r\n        vault,\r\n        auction,\r\n        auctionManager,\r\n        bidRedemption,\r\n        bidMetadata,\r\n        safetyDepositTokenStore,\r\n        destination: account.publicKey,\r\n        safetyDeposit,\r\n        fractionMint,\r\n        bidder,\r\n        safetyDepositConfig,\r\n        auctionExtended,\r\n        transferAuthority,\r\n        newAuthority: bidder,\r\n        masterMetadata: metadata,\r\n    });\r\n    txBatch.addTransaction(redeemBidTransaction);\r\n    const updatePrimarySaleHappenedViaTokenTransaction = new UpdatePrimarySaleHappenedViaToken({ feePayer: bidder }, {\r\n        metadata,\r\n        owner: bidder,\r\n        tokenAccount: account.publicKey,\r\n    });\r\n    txBatch.addTransaction(updatePrimarySaleHappenedViaTokenTransaction);\r\n    return txBatch;\r\n});\r\nconst getBidRedemptionPDA = (auction, bidderMeta) => __awaiter(void 0, void 0, void 0, function* () {\r\n    return (yield PublicKey.findProgramAddress([Buffer.from(MetaplexProgram.PREFIX), auction.toBuffer(), bidderMeta.toBuffer()], MetaplexProgram.PUBKEY))[0];\r\n});\n\nconst redeemPrintingV2Bid = ({ connection, wallet, store, auction, }) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const bidder = wallet.publicKey;\r\n    const { data: { bidState }, } = yield Auction.load(connection, auction);\r\n    const auctionManagerPDA = yield AuctionManager.getPDA(auction);\r\n    const manager = yield AuctionManager.load(connection, auctionManagerPDA);\r\n    const vault = yield Vault.load(connection, manager.data.vault);\r\n    const auctionExtendedPDA = yield AuctionExtended.getPDA(vault.pubkey);\r\n    const [safetyDepositBox] = yield vault.getSafetyDepositBoxes(connection);\r\n    const originalMint = new PublicKey(safetyDepositBox.data.tokenMint);\r\n    const safetyDepositTokenStore = new PublicKey(safetyDepositBox.data.store);\r\n    const bidderMetaPDA = yield BidderMetadata.getPDA(auction, bidder);\r\n    const bidRedemptionPDA = yield getBidRedemptionPDA(auction, bidderMetaPDA);\r\n    const safetyDepositConfigPDA = yield SafetyDepositConfig.getPDA(auctionManagerPDA, safetyDepositBox.pubkey);\r\n    const { mint, createMintTx, createAssociatedTokenAccountTx, mintToTx, recipient } = yield prepareTokenAccountAndMintTxs(connection, wallet.publicKey);\r\n    const newMint = mint.publicKey;\r\n    const newMetadataPDA = yield Metadata.getPDA(newMint);\r\n    const newEditionPDA = yield Edition.getPDA(newMint);\r\n    const metadataPDA = yield Metadata.getPDA(originalMint);\r\n    const masterEditionPDA = yield MasterEdition.getPDA(originalMint);\r\n    const masterEdition = yield MasterEdition.load(connection, masterEditionPDA);\r\n    const prizeTrackingTicketPDA = yield PrizeTrackingTicket.getPDA(auctionManagerPDA, originalMint);\r\n    let prizeTrackingTicket;\r\n    try {\r\n        prizeTrackingTicket = yield PrizeTrackingTicket.load(connection, prizeTrackingTicketPDA);\r\n    }\r\n    catch (e) {\r\n        prizeTrackingTicket = null;\r\n    }\r\n    const winIndex = bidState.getWinnerIndex(bidder.toBase58()) || 0;\r\n    const editionOffset = getEditionOffset(winIndex);\r\n    const editionBase = (prizeTrackingTicket === null || prizeTrackingTicket === void 0 ? void 0 : prizeTrackingTicket.data.supplySnapshot) || masterEdition.data.supply;\r\n    const desiredEdition = editionBase.add(editionOffset);\r\n    const editionMarkerPDA = yield EditionMarker.getPDA(originalMint, desiredEdition);\r\n    try {\r\n        const editionMarker = yield EditionMarker.load(connection, editionMarkerPDA);\r\n        const isEditionTaken = editionMarker.data.editionTaken(desiredEdition.toNumber());\r\n        if (isEditionTaken) {\r\n            throw new Error('The edition is already taken');\r\n        }\r\n    }\r\n    catch (e) {\r\n    }\r\n    const txBatch = yield getRedeemPrintingV2BidTransactions({\r\n        bidder,\r\n        bidderMeta: bidderMetaPDA,\r\n        store,\r\n        vault: vault.pubkey,\r\n        destination: recipient,\r\n        auction,\r\n        auctionExtended: auctionExtendedPDA,\r\n        auctionManager: auctionManagerPDA,\r\n        safetyDepositTokenStore,\r\n        safetyDeposit: safetyDepositBox.pubkey,\r\n        bidRedemption: bidRedemptionPDA,\r\n        safetyDepositConfig: safetyDepositConfigPDA,\r\n        metadata: metadataPDA,\r\n        newMint,\r\n        newMetadata: newMetadataPDA,\r\n        newEdition: newEditionPDA,\r\n        masterEdition: masterEditionPDA,\r\n        editionMarker: editionMarkerPDA,\r\n        prizeTrackingTicket: prizeTrackingTicketPDA,\r\n        editionOffset,\r\n        winIndex: new BN(winIndex),\r\n    });\r\n    txBatch.addSigner(mint);\r\n    txBatch.addBeforeTransaction(createMintTx);\r\n    txBatch.addBeforeTransaction(createAssociatedTokenAccountTx);\r\n    txBatch.addBeforeTransaction(mintToTx);\r\n    const txId = yield sendTransaction({\r\n        connection,\r\n        wallet,\r\n        txs: txBatch.toTransactions(),\r\n        signers: txBatch.signers,\r\n    });\r\n    return { txId };\r\n});\r\nconst getRedeemPrintingV2BidTransactions = ({ bidder, destination, store, vault, auction, auctionManager, auctionExtended, bidRedemption, bidderMeta: bidMetadata, safetyDepositTokenStore, safetyDeposit, safetyDepositConfig, metadata, newMint, newMetadata, newEdition, masterEdition, editionMarker: editionMark, prizeTrackingTicket, winIndex, editionOffset, }) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const txBatch = new TransactionsBatch({ transactions: [] });\r\n    const redeemPrintingV2BidTx = new RedeemPrintingV2Bid({ feePayer: bidder }, {\r\n        store,\r\n        vault,\r\n        auction,\r\n        auctionManager,\r\n        bidRedemption,\r\n        bidMetadata,\r\n        safetyDepositTokenStore,\r\n        destination,\r\n        safetyDeposit,\r\n        bidder,\r\n        safetyDepositConfig,\r\n        auctionExtended,\r\n        newMint,\r\n        newEdition,\r\n        newMetadata,\r\n        metadata,\r\n        masterEdition,\r\n        editionMark,\r\n        prizeTrackingTicket,\r\n        winIndex,\r\n        editionOffset,\r\n    });\r\n    txBatch.addTransaction(redeemPrintingV2BidTx);\r\n    const updatePrimarySaleHappenedViaTokenTx = new UpdatePrimarySaleHappenedViaToken({ feePayer: bidder }, {\r\n        metadata: newMetadata,\r\n        owner: bidder,\r\n        tokenAccount: destination,\r\n    });\r\n    txBatch.addTransaction(updatePrimarySaleHappenedViaTokenTx);\r\n    return txBatch;\r\n});\r\nfunction getEditionOffset(winIndex) {\r\n    const offset = new BN(1);\r\n    return offset.add(new BN(winIndex));\r\n}\n\nconst redeemParticipationBidV3 = ({ connection, wallet, store, auction, }) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const txInitBatch = new TransactionsBatch({ transactions: [] });\r\n    const txMainBatch = new TransactionsBatch({ transactions: [] });\r\n    const bidder = wallet.publicKey;\r\n    const { data: { bidState, tokenMint: auctionTokenMint }, } = yield Auction.load(connection, auction);\r\n    const auctionManagerPDA = yield AuctionManager.getPDA(auction);\r\n    const manager = yield AuctionManager.load(connection, auctionManagerPDA);\r\n    const vault = yield Vault.load(connection, manager.data.vault);\r\n    const auctionExtendedPDA = yield AuctionExtended.getPDA(vault.pubkey);\r\n    const [safetyDepositBox] = yield vault.getSafetyDepositBoxes(connection);\r\n    const originalMint = new PublicKey(safetyDepositBox.data.tokenMint);\r\n    const safetyDepositTokenStore = new PublicKey(safetyDepositBox.data.store);\r\n    const bidderMetaPDA = yield BidderMetadata.getPDA(auction, bidder);\r\n    const bidRedemptionPDA = yield getBidRedemptionPDA(auction, bidderMetaPDA);\r\n    const safetyDepositConfigPDA = yield SafetyDepositConfig.getPDA(auctionManagerPDA, safetyDepositBox.pubkey);\r\n    const { data: { participationConfig: { fixedPrice }, }, } = yield SafetyDepositConfig.load(connection, safetyDepositConfigPDA);\r\n    const acceptPaymentAccount = new PublicKey(manager.data.acceptPayment);\r\n    const { mint, createMintTx, createAssociatedTokenAccountTx, mintToTx, recipient } = yield prepareTokenAccountAndMintTxs(connection, wallet.publicKey);\r\n    txInitBatch.addSigner(mint);\r\n    txInitBatch.addTransaction(createMintTx);\r\n    txInitBatch.addTransaction(createAssociatedTokenAccountTx);\r\n    txInitBatch.addTransaction(mintToTx);\r\n    const newMint = mint.publicKey;\r\n    const newMetadataPDA = yield Metadata.getPDA(newMint);\r\n    const newEditionPDA = yield Edition.getPDA(newMint);\r\n    const metadataPDA = yield Metadata.getPDA(originalMint);\r\n    const masterEditionPDA = yield MasterEdition.getPDA(originalMint);\r\n    const masterEdition = yield MasterEdition.load(connection, masterEditionPDA);\r\n    const prizeTrackingTicketPDA = yield PrizeTrackingTicket.getPDA(auctionManagerPDA, originalMint);\r\n    const winIndex = bidState.getWinnerIndex(bidder.toBase58());\r\n    const desiredEdition = masterEdition.data.supply.add(new BN(1));\r\n    const editionMarkerPDA = yield EditionMarker.getPDA(originalMint, desiredEdition);\r\n    let tokenPaymentAccount;\r\n    if (auctionTokenMint === NATIVE_MINT.toBase58()) {\r\n        const { account, createTokenAccountTx, closeTokenAccountTx } = yield createWrappedAccountTxs(connection, bidder, fixedPrice.toNumber());\r\n        tokenPaymentAccount = account.publicKey;\r\n        txInitBatch.addTransaction(createTokenAccountTx);\r\n        txInitBatch.addSigner(account);\r\n        txMainBatch.addAfterTransaction(closeTokenAccountTx);\r\n    }\r\n    else {\r\n        tokenPaymentAccount = yield Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, new PublicKey(auctionTokenMint), bidder);\r\n    }\r\n    const { authority, createApproveTx, createRevokeTx } = createApproveTxs({\r\n        account: tokenPaymentAccount,\r\n        owner: bidder,\r\n        amount: fixedPrice.toNumber(),\r\n    });\r\n    txMainBatch.addTransaction(createApproveTx);\r\n    txMainBatch.addAfterTransaction(createRevokeTx);\r\n    txMainBatch.addSigner(authority);\r\n    const redeemParticipationBidV3Tx = new RedeemParticipationBidV3({ feePayer: bidder }, {\r\n        store,\r\n        vault: vault.pubkey,\r\n        auction,\r\n        auctionManager: auctionManagerPDA,\r\n        bidRedemption: bidRedemptionPDA,\r\n        bidMetadata: bidderMetaPDA,\r\n        safetyDepositTokenStore,\r\n        destination: recipient,\r\n        safetyDeposit: safetyDepositBox.pubkey,\r\n        bidder,\r\n        safetyDepositConfig: safetyDepositConfigPDA,\r\n        auctionExtended: auctionExtendedPDA,\r\n        newMint,\r\n        newEdition: newEditionPDA,\r\n        newMetadata: newMetadataPDA,\r\n        metadata: metadataPDA,\r\n        masterEdition: masterEditionPDA,\r\n        editionMark: editionMarkerPDA,\r\n        prizeTrackingTicket: prizeTrackingTicketPDA,\r\n        winIndex: winIndex !== null ? new BN(winIndex) : null,\r\n        transferAuthority: authority.publicKey,\r\n        tokenPaymentAccount,\r\n        acceptPaymentAccount,\r\n    });\r\n    txMainBatch.addTransaction(redeemParticipationBidV3Tx);\r\n    const updatePrimarySaleHappenedViaTokenTx = new UpdatePrimarySaleHappenedViaToken({ feePayer: bidder }, {\r\n        metadata: newMetadataPDA,\r\n        owner: bidder,\r\n        tokenAccount: recipient,\r\n    });\r\n    txMainBatch.addTransaction(updatePrimarySaleHappenedViaTokenTx);\r\n    const initTxId = yield sendTransaction({\r\n        connection,\r\n        wallet,\r\n        txs: txInitBatch.toTransactions(),\r\n        signers: txInitBatch.signers,\r\n    });\r\n    yield connection.confirmTransaction(initTxId, 'finalized');\r\n    const mainTxId = yield sendTransaction({\r\n        connection,\r\n        wallet,\r\n        txs: txMainBatch.toTransactions(),\r\n        signers: txMainBatch.signers,\r\n    });\r\n    return { txIds: [initTxId, mainTxId] };\r\n});\r\nfunction isEligibleForParticipationPrize(winIndex, { nonWinningConstraint, winnerConstraint } = {}) {\r\n    const noWinnerConstraints = winnerConstraint !== WinningConstraint.NoParticipationPrize;\r\n    const noNonWinnerConstraints = nonWinningConstraint !== NonWinningConstraint.NoParticipationPrize;\r\n    return ((winIndex === null && noNonWinnerConstraints) || (winIndex !== null && noWinnerConstraints));\r\n}\n\nconst claimBid = ({ connection, wallet, store, auction, bidderPotToken, }) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const bidder = wallet.publicKey;\r\n    const auctionManager = yield AuctionManager.getPDA(auction);\r\n    const manager = yield AuctionManager.load(connection, auctionManager);\r\n    const vault = new PublicKey(manager.data.vault);\r\n    const { data: { tokenMint }, } = yield Auction.load(connection, auction);\r\n    const acceptPayment = new PublicKey(manager.data.acceptPayment);\r\n    const auctionExtended = yield AuctionExtended.getPDA(vault);\r\n    const auctionTokenMint = new PublicKey(tokenMint);\r\n    const bidderPot = yield BidderPot.getPDA(auction, bidder);\r\n    const txBatch = yield getClaimBidTransactions({\r\n        auctionTokenMint,\r\n        bidder,\r\n        store,\r\n        vault,\r\n        auction,\r\n        auctionExtended,\r\n        auctionManager,\r\n        acceptPayment,\r\n        bidderPot,\r\n        bidderPotToken,\r\n    });\r\n    const txId = yield sendTransaction({\r\n        connection,\r\n        wallet,\r\n        txs: txBatch.toTransactions(),\r\n        signers: txBatch.signers,\r\n    });\r\n    return { txId };\r\n});\r\nconst getClaimBidTransactions = ({ bidder, auctionTokenMint, store, vault, auction, auctionManager, auctionExtended, acceptPayment, bidderPot, bidderPotToken, }) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const txBatch = new TransactionsBatch({ transactions: [] });\r\n    const claimBidTransaction = new ClaimBid({ feePayer: bidder }, {\r\n        store,\r\n        vault,\r\n        auction,\r\n        auctionExtended,\r\n        auctionManager,\r\n        bidder,\r\n        tokenMint: auctionTokenMint,\r\n        acceptPayment,\r\n        bidderPot,\r\n        bidderPotToken,\r\n    });\r\n    txBatch.addTransaction(claimBidTransaction);\r\n    return txBatch;\r\n});\n\nconst instantSale = ({ connection, wallet, store, auction, }) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const txIds = [];\r\n    const auctionManagerPDA = yield AuctionManager.getPDA(auction);\r\n    const manager = yield AuctionManager.load(connection, auctionManagerPDA);\r\n    const vault = yield Vault.load(connection, manager.data.vault);\r\n    const auctionExtendedPDA = yield AuctionExtended.getPDA(vault.pubkey);\r\n    const { data: { instantSalePrice }, } = yield AuctionExtended.load(connection, auctionExtendedPDA);\r\n    const [safetyDepositBox] = yield vault.getSafetyDepositBoxes(connection);\r\n    const safetyDepositConfigPDA = yield SafetyDepositConfig.getPDA(auctionManagerPDA, safetyDepositBox.pubkey);\r\n    const { data: { winningConfigType, participationConfig }, } = yield SafetyDepositConfig.load(connection, safetyDepositConfigPDA);\r\n    const { txId: placeBidTxId, bidderPotToken } = yield placeBid({\r\n        connection,\r\n        wallet,\r\n        amount: instantSalePrice,\r\n        auction,\r\n    });\r\n    txIds.push(placeBidTxId);\r\n    yield connection.confirmTransaction(placeBidTxId, 'finalized');\r\n    const { data: { bidState }, } = yield Auction.load(connection, auction);\r\n    const winIndex = bidState.getWinnerIndex(wallet.publicKey.toBase58());\r\n    const hasWinner = winIndex !== null;\r\n    if (hasWinner) {\r\n        switch (winningConfigType) {\r\n            case WinningConfigType.FullRightsTransfer: {\r\n                const { txId } = yield redeemFullRightsTransferBid({ connection, wallet, store, auction });\r\n                txIds.push(txId);\r\n                break;\r\n            }\r\n            case WinningConfigType.PrintingV2: {\r\n                const { txId } = yield redeemPrintingV2Bid({ connection, wallet, store, auction });\r\n                txIds.push(txId);\r\n                break;\r\n            }\r\n            default:\r\n                throw new Error(`${winningConfigType} winning type isn't supported yet`);\r\n        }\r\n        const { txId: claimBidTxId } = yield claimBid({\r\n            connection,\r\n            wallet,\r\n            store,\r\n            auction,\r\n            bidderPotToken,\r\n        });\r\n        txIds.push(claimBidTxId);\r\n    }\r\n    else {\r\n        const { txId } = yield cancelBid({ connection, wallet, auction, bidderPotToken });\r\n        txIds.push(txId);\r\n    }\r\n    const hasWonParticipationPrize = isEligibleForParticipationPrize(winIndex, participationConfig);\r\n    if (hasWonParticipationPrize) {\r\n        const { txIds } = yield redeemParticipationBidV3({ connection, wallet, store, auction });\r\n        txIds.push(...txIds);\r\n    }\r\n    return { txIds: txIds };\r\n});\n\nconst burnToken = ({ connection, wallet, token, mint, amount, owner, close = true, }) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const tx = new Transaction({ feePayer: wallet.publicKey }).add(Token.createBurnInstruction(TOKEN_PROGRAM_ID, mint, token, owner !== null && owner !== void 0 ? owner : wallet.publicKey, [], amount));\r\n    if (close) {\r\n        tx.add(Token.createCloseAccountInstruction(TOKEN_PROGRAM_ID, token, wallet.publicKey, owner !== null && owner !== void 0 ? owner : wallet.publicKey, []));\r\n    }\r\n    const txId = yield sendTransaction({ connection, wallet, txs: [tx] });\r\n    return { txId };\r\n});\n\nconst sendToken = ({ connection, wallet, source, destination, mint, amount, }) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const txs = [];\r\n    const destAta = yield Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, mint, destination);\r\n    const transactionCtorFields = {\r\n        feePayer: wallet.publicKey,\r\n    };\r\n    try {\r\n        yield Account.load(connection, destAta);\r\n    }\r\n    catch (_a) {\r\n        txs.push(new CreateAssociatedTokenAccount(transactionCtorFields, {\r\n            associatedTokenAddress: destAta,\r\n            splTokenMintAddress: mint,\r\n            walletAddress: destination,\r\n        }));\r\n    }\r\n    txs.push(new Transaction(transactionCtorFields).add(Token.createTransferInstruction(TOKEN_PROGRAM_ID, source, destAta, wallet.publicKey, [], amount)));\r\n    const txId = yield sendTransaction({ connection, wallet, txs });\r\n    return { txId };\r\n});\n\nconst closeVault = ({ connection, wallet, vault, priceMint, }) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const accountRent = yield connection.getMinimumBalanceForRentExemption(AccountLayout.span);\r\n    const fractionMintAuthority = yield Vault.getPDA(vault);\r\n    const txBatch = new TransactionsBatch({ transactions: [] });\r\n    const txOptions = { feePayer: wallet.publicKey };\r\n    const { data: { fractionMint, fractionTreasury, redeemTreasury, pricingLookupAddress }, } = yield Vault.load(connection, vault);\r\n    const fractionMintKey = new PublicKey(fractionMint);\r\n    const fractionTreasuryKey = new PublicKey(fractionTreasury);\r\n    const redeemTreasuryKey = new PublicKey(redeemTreasury);\r\n    const pricingLookupAddressKey = new PublicKey(pricingLookupAddress);\r\n    const activateVaultTx = new ActivateVault(txOptions, {\r\n        vault,\r\n        numberOfShares: new BN(0),\r\n        fractionMint: fractionMintKey,\r\n        fractionTreasury: fractionTreasuryKey,\r\n        fractionMintAuthority,\r\n        vaultAuthority: wallet.publicKey,\r\n    });\r\n    txBatch.addTransaction(activateVaultTx);\r\n    const outstandingShareAccount = Keypair.generate();\r\n    const outstandingShareAccountTx = new CreateTokenAccount(txOptions, {\r\n        newAccountPubkey: outstandingShareAccount.publicKey,\r\n        lamports: accountRent,\r\n        mint: fractionMintKey,\r\n        owner: wallet.publicKey,\r\n    });\r\n    txBatch.addTransaction(outstandingShareAccountTx);\r\n    txBatch.addSigner(outstandingShareAccount);\r\n    const payingTokenAccount = Keypair.generate();\r\n    const payingTokenAccountTx = new CreateTokenAccount(txOptions, {\r\n        newAccountPubkey: payingTokenAccount.publicKey,\r\n        lamports: accountRent,\r\n        mint: priceMint,\r\n        owner: wallet.publicKey,\r\n    });\r\n    txBatch.addTransaction(payingTokenAccountTx);\r\n    txBatch.addSigner(payingTokenAccount);\r\n    const transferAuthority = Keypair.generate();\r\n    const createApproveTx = (account) => new Transaction().add(Token.createApproveInstruction(TOKEN_PROGRAM_ID, account.publicKey, transferAuthority.publicKey, wallet.publicKey, [], 0));\r\n    txBatch.addTransaction(createApproveTx(payingTokenAccount));\r\n    txBatch.addTransaction(createApproveTx(outstandingShareAccount));\r\n    txBatch.addSigner(transferAuthority);\r\n    const combineVaultTx = new CombineVault(txOptions, {\r\n        vault,\r\n        outstandingShareTokenAccount: outstandingShareAccount.publicKey,\r\n        payingTokenAccount: payingTokenAccount.publicKey,\r\n        fractionMint: fractionMintKey,\r\n        fractionTreasury: fractionTreasuryKey,\r\n        redeemTreasury: redeemTreasuryKey,\r\n        burnAuthority: fractionMintAuthority,\r\n        externalPriceAccount: pricingLookupAddressKey,\r\n        transferAuthority: transferAuthority.publicKey,\r\n        vaultAuthority: wallet.publicKey,\r\n        newVaultAuthority: wallet.publicKey,\r\n    });\r\n    txBatch.addTransaction(combineVaultTx);\r\n    const txId = yield sendTransaction({\r\n        connection,\r\n        signers: txBatch.signers,\r\n        txs: txBatch.transactions,\r\n        wallet,\r\n    });\r\n    return { txId };\r\n});\n\nconst createExternalPriceAccount = ({ connection, wallet, }) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const txBatch = new TransactionsBatch({ transactions: [] });\r\n    const txOptions = { feePayer: wallet.publicKey };\r\n    const epaRentExempt = yield connection.getMinimumBalanceForRentExemption(Vault.MAX_EXTERNAL_ACCOUNT_SIZE);\r\n    const externalPriceAccount = Keypair.generate();\r\n    const externalPriceAccountData = new ExternalPriceAccountData({\r\n        pricePerShare: new BN(0),\r\n        priceMint: NATIVE_MINT.toBase58(),\r\n        allowedToCombine: true,\r\n    });\r\n    const uninitializedEPA = new Transaction().add(SystemProgram.createAccount({\r\n        fromPubkey: wallet.publicKey,\r\n        newAccountPubkey: externalPriceAccount.publicKey,\r\n        lamports: epaRentExempt,\r\n        space: Vault.MAX_EXTERNAL_ACCOUNT_SIZE,\r\n        programId: VaultProgram.PUBKEY,\r\n    }));\r\n    txBatch.addTransaction(uninitializedEPA);\r\n    txBatch.addSigner(externalPriceAccount);\r\n    const updateEPA = new UpdateExternalPriceAccount(txOptions, {\r\n        externalPriceAccount: externalPriceAccount.publicKey,\r\n        externalPriceAccountData,\r\n    });\r\n    txBatch.addTransaction(updateEPA);\r\n    const txId = yield sendTransaction({\r\n        connection,\r\n        signers: txBatch.signers,\r\n        txs: txBatch.transactions,\r\n        wallet,\r\n    });\r\n    return {\r\n        txId,\r\n        externalPriceAccount: externalPriceAccount.publicKey,\r\n        priceMint: NATIVE_MINT,\r\n    };\r\n});\n\nconst createVault = ({ connection, wallet, priceMint = NATIVE_MINT, externalPriceAccount, }) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const accountRent = yield connection.getMinimumBalanceForRentExemption(AccountLayout.span);\r\n    const mintRent = yield connection.getMinimumBalanceForRentExemption(MintLayout.span);\r\n    const vaultRent = yield connection.getMinimumBalanceForRentExemption(Vault.MAX_VAULT_SIZE);\r\n    const vault = Keypair.generate();\r\n    const vaultAuthority = yield Vault.getPDA(vault.publicKey);\r\n    const txBatch = new TransactionsBatch({ transactions: [] });\r\n    const fractionMint = Keypair.generate();\r\n    const fractionMintTx = new CreateMint({ feePayer: wallet.publicKey }, {\r\n        newAccountPubkey: fractionMint.publicKey,\r\n        lamports: mintRent,\r\n        owner: vaultAuthority,\r\n        freezeAuthority: vaultAuthority,\r\n    });\r\n    txBatch.addTransaction(fractionMintTx);\r\n    txBatch.addSigner(fractionMint);\r\n    const redeemTreasury = Keypair.generate();\r\n    const redeemTreasuryTx = new CreateTokenAccount({ feePayer: wallet.publicKey }, {\r\n        newAccountPubkey: redeemTreasury.publicKey,\r\n        lamports: accountRent,\r\n        mint: priceMint,\r\n        owner: vaultAuthority,\r\n    });\r\n    txBatch.addTransaction(redeemTreasuryTx);\r\n    txBatch.addSigner(redeemTreasury);\r\n    const fractionTreasury = Keypair.generate();\r\n    const fractionTreasuryTx = new CreateTokenAccount({ feePayer: wallet.publicKey }, {\r\n        newAccountPubkey: fractionTreasury.publicKey,\r\n        lamports: accountRent,\r\n        mint: fractionMint.publicKey,\r\n        owner: vaultAuthority,\r\n    });\r\n    txBatch.addTransaction(fractionTreasuryTx);\r\n    txBatch.addSigner(fractionTreasury);\r\n    const uninitializedVaultTx = new Transaction().add(SystemProgram.createAccount({\r\n        fromPubkey: wallet.publicKey,\r\n        newAccountPubkey: vault.publicKey,\r\n        lamports: vaultRent,\r\n        space: Vault.MAX_VAULT_SIZE,\r\n        programId: VaultProgram.PUBKEY,\r\n    }));\r\n    txBatch.addTransaction(uninitializedVaultTx);\r\n    txBatch.addSigner(vault);\r\n    const initVaultTx = new InitVault({ feePayer: wallet.publicKey }, {\r\n        vault: vault.publicKey,\r\n        vaultAuthority: wallet.publicKey,\r\n        fractionalTreasury: fractionTreasury.publicKey,\r\n        pricingLookupAddress: externalPriceAccount,\r\n        redeemTreasury: redeemTreasury.publicKey,\r\n        fractionalMint: fractionMint.publicKey,\r\n        allowFurtherShareCreation: true,\r\n    });\r\n    txBatch.addTransaction(initVaultTx);\r\n    const txId = yield sendTransaction({\r\n        connection,\r\n        signers: txBatch.signers,\r\n        txs: txBatch.transactions,\r\n        wallet,\r\n    });\r\n    return {\r\n        txId,\r\n        vault: vault.publicKey,\r\n        fractionMint: fractionMint.publicKey,\r\n        redeemTreasury: redeemTreasury.publicKey,\r\n        fractionTreasury: fractionTreasury.publicKey,\r\n    };\r\n});\n\nconst initAuction = ({ connection, wallet, vault, auctionSettings, }) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const txOptions = { feePayer: wallet.publicKey };\r\n    const [auctionKey, auctionExtended] = yield Promise.all([\r\n        Auction.getPDA(vault),\r\n        AuctionExtended.getPDA(vault),\r\n    ]);\r\n    const fullSettings = new CreateAuctionArgs(Object.assign(Object.assign({}, auctionSettings), { authority: wallet.publicKey.toBase58(), resource: vault.toBase58() }));\r\n    const auctionTx = new CreateAuction(txOptions, {\r\n        args: fullSettings,\r\n        auction: auctionKey,\r\n        creator: wallet.publicKey,\r\n        auctionExtended,\r\n    });\r\n    const txId = yield sendTransaction({\r\n        connection,\r\n        signers: [],\r\n        txs: [auctionTx],\r\n        wallet,\r\n    });\r\n    return { txId, auction: auctionKey };\r\n});\n\nvar index$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  addTokensToVault: addTokensToVault,\n  sendTransaction: sendTransaction,\n  initStore: initStore,\n  initStoreV2: initStoreV2,\n  mintNFT: mintNFT,\n  mintEditionFromMaster: mintEditionFromMaster,\n  createMetadata: createMetadata,\n  createMasterEdition: createMasterEdition,\n  signMetadata: signMetadata,\n  updateMetadata: updateMetadata,\n  cancelBid: cancelBid,\n  getCancelBidTransactions: getCancelBidTransactions,\n  placeBid: placeBid,\n  redeemFullRightsTransferBid: redeemFullRightsTransferBid,\n  getRedeemFRTBidTransactions: getRedeemFRTBidTransactions,\n  getBidRedemptionPDA: getBidRedemptionPDA,\n  redeemPrintingV2Bid: redeemPrintingV2Bid,\n  getRedeemPrintingV2BidTransactions: getRedeemPrintingV2BidTransactions,\n  getEditionOffset: getEditionOffset,\n  redeemParticipationBidV3: redeemParticipationBidV3,\n  isEligibleForParticipationPrize: isEligibleForParticipationPrize,\n  claimBid: claimBid,\n  getClaimBidTransactions: getClaimBidTransactions,\n  instantSale: instantSale,\n  burnToken: burnToken,\n  sendToken: sendToken,\n  prepareTokenAccountAndMintTxs: prepareTokenAccountAndMintTxs,\n  createWrappedAccountTxs: createWrappedAccountTxs,\n  createApproveTxs: createApproveTxs,\n  closeVault: closeVault,\n  createExternalPriceAccount: createExternalPriceAccount,\n  createVault: createVault,\n  initAuction: initAuction\n});\n\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  transactions: index$2,\n  auction: mplAuction,\n  core: mplCore,\n  metaplex: mplMetaplex,\n  metadata: mplTokenMetadata,\n  vault: mplTokenVault\n});\n\nexport { ArweaveStorage, ChainId, Coingecko, Connection, Currency, ENV, NodeWallet, index$1 as actions, index as programs, Storage$1 as storage, index$2 as transactions, index$3 as utils };\n"],"names":[],"sourceRoot":"","x_google_ignoreList":[0]}