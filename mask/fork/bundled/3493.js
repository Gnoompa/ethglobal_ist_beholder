(globalThis["webpackChunkmask_network"] = globalThis["webpackChunkmask_network"] || []).push([[3493],{

/***/ 12247:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   x: () => (/* binding */ Identifier)
/* harmony export */ });
/* harmony import */ var ts_results_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(76089);

class Identifier {
    /** @internal */ toString() {
        return this.toText();
    }
    static from(input) {
        // this method will be override in ./utils
        return ts_results_es__WEBPACK_IMPORTED_MODULE_0__.None;
    }
    static [Symbol.hasInstance](x) {
        // this method will be override in ./utils
        return false;
    }
}


/***/ }),

/***/ 19477:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   o: () => (/* binding */ ECKeyIdentifier)
/* harmony export */ });
/* unused harmony export PersonaIdentifier */
/* harmony import */ var _masknet_kit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30898);
/* harmony import */ var pvtsutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85907);
/* harmony import */ var ts_results_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(76089);
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(12247);
/* harmony import */ var _WebCrypto_JsonWebKey_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(94724);
/* harmony import */ var _WebCrypto_k256_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(17688);







const instance = new WeakSet();
const k256Cache = Object.create(null);
const keyAsHex = Object.create(null);
/**
 * This class identify the point on an EC curve.
 * ec_key:secp256k1/CompressedPoint
 */ class ECKeyIdentifier extends _base_js__WEBPACK_IMPORTED_MODULE_3__/* .Identifier */ .x {
    static from(input) {
        if (!input) return ts_results_es__WEBPACK_IMPORTED_MODULE_2__.None;
        input = String(input);
        if (input.startsWith('ec_key:')) return _base_js__WEBPACK_IMPORTED_MODULE_3__/* .Identifier */ .x.from(input);
        return ts_results_es__WEBPACK_IMPORTED_MODULE_2__.None;
    }
    static fromHexPublicKeyK256(hex) {
        if (!hex) return ts_results_es__WEBPACK_IMPORTED_MODULE_2__.None;
        hex = String(hex);
        if (hex.startsWith('0x')) hex = hex.slice(2);
        const publicKey = (0,_masknet_kit__WEBPACK_IMPORTED_MODULE_0__/* .encodeArrayBuffer */ .ll)(new Uint8Array(pvtsutils__WEBPACK_IMPORTED_MODULE_1__/* .Convert */ .ep.FromHex(hex)));
        return (0,ts_results_es__WEBPACK_IMPORTED_MODULE_2__.Some)(new ECKeyIdentifier('secp256k1', publicKey));
    }
    static async fromJsonWebKey(key) {
        if (!(0,_WebCrypto_JsonWebKey_js__WEBPACK_IMPORTED_MODULE_4__/* .isEC_JsonWebKey */ .$G)(key)) return (0,ts_results_es__WEBPACK_IMPORTED_MODULE_2__.Err)(new Error('key is not a EC_JsonWebKey'));
        if (key.crv !== 'K-256') return (0,ts_results_es__WEBPACK_IMPORTED_MODULE_2__.Err)(new Error('curve is not K-256'));
        const result = await ts_results_es__WEBPACK_IMPORTED_MODULE_2__.Result.wrapAsync(()=>(0,_WebCrypto_k256_js__WEBPACK_IMPORTED_MODULE_5__/* .compressK256Key */ .b2)(key));
        return result.map((key)=>new ECKeyIdentifier('secp256k1', key));
    }
    static async fromCryptoKey(key) {
        if (!key.extractable) return (0,ts_results_es__WEBPACK_IMPORTED_MODULE_2__.Err)('key is not extractable');
        if (key.algorithm.namedCurve !== 'K-256') return (0,ts_results_es__WEBPACK_IMPORTED_MODULE_2__.Err)('curve is not K-256');
        const jwk = await ts_results_es__WEBPACK_IMPORTED_MODULE_2__.Result.wrapAsync(()=>crypto.subtle.exportKey('jwk', key));
        if (jwk.isErr()) return jwk;
        return ECKeyIdentifier.fromJsonWebKey(jwk.value);
    }
    async toJsonWebKey(usage) {
        const key = await (0,_WebCrypto_k256_js__WEBPACK_IMPORTED_MODULE_5__/* .decompressK256Key */ .J$)(this.rawPublicKey);
        if (usage === 'sign_and_verify') key.key_ops = [
            'sign',
            'verify'
        ];
        return key;
    }
    async toCryptoKey(usage) {
        const key = await this.toJsonWebKey(usage);
        return crypto.subtle.importKey('jwk', key, {
            name: usage === 'sign_and_verify' ? 'ECDSA' : 'ECDH',
            namedCurve: 'K-256'
        }, true, key.key_ops);
    }
    constructor(curve, publicKey){
        publicKey = String(publicKey).replaceAll('|', '/');
        if (curve !== 'secp256k1') throw new Error('Only secp256k1 is supported');
        // return the cache to keep the object identity
        // eslint-disable-next-line no-constructor-return
        if (k256Cache[publicKey]) return k256Cache[publicKey];
        super();
        this.curve = 'secp256k1';
        this.rawPublicKey = publicKey;
        Object.freeze(this);
        k256Cache[publicKey] = this;
        instance.add(this);
    }
    toText() {
        const normalized = this.rawPublicKey.replaceAll('/', '|');
        return `ec_key:${this.curve}/${normalized}`;
    }
    get publicKeyAsHex() {
        return '0x' + (keyAsHex[this.rawPublicKey] ??= pvtsutils__WEBPACK_IMPORTED_MODULE_1__/* .Convert */ .ep.ToHex((0,_masknet_kit__WEBPACK_IMPORTED_MODULE_0__/* .decodeArrayBuffer */ .xe)(this.rawPublicKey)));
    }
    static [Symbol.hasInstance](x) {
        return instance.has(x);
    }
}
ECKeyIdentifier.prototype[Symbol.toStringTag] = 'ECKeyIdentifier';
Object.freeze(ECKeyIdentifier.prototype);
Object.freeze(ECKeyIdentifier);
const PersonaIdentifier = [
    ECKeyIdentifier
];


/***/ }),

/***/ 97039:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   b: () => (/* binding */ PostIVIdentifier)
/* harmony export */ });
/* harmony import */ var _masknet_kit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30898);
/* harmony import */ var ts_results_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(76089);
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12247);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(89458);




const instance = new WeakSet();
const id = Object.create(null);
class PostIVIdentifier extends _base_js__WEBPACK_IMPORTED_MODULE_2__/* .Identifier */ .x {
    static from(input) {
        if (!input) return ts_results_es__WEBPACK_IMPORTED_MODULE_1__.None;
        input = String(input);
        if (input.startsWith('post_iv:')) return _base_js__WEBPACK_IMPORTED_MODULE_2__/* .Identifier */ .x.from(input);
        return ts_results_es__WEBPACK_IMPORTED_MODULE_1__.None;
    }
    constructor(network, postIV){
        network = String(network);
        postIV = String(postIV);
        const networkCache = id[network] ??= {};
        // return the cache to keep the object identity
        // eslint-disable-next-line no-constructor-return
        if (networkCache[postIV]) return networkCache[postIV];
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__/* .banSlash */ .a)(network, 'PostIVIdentifier.network');
        super();
        this.network = network;
        this.postIV = postIV;
        Object.freeze(this);
        networkCache[postIV] = this;
        instance.add(this);
    }
    toText() {
        return `post_iv:${this.network}/${this.postIV.replaceAll('/', '|')}`;
    }
    toIV() {
        const x = this.postIV.replaceAll('|', '/');
        return new Uint8Array((0,_masknet_kit__WEBPACK_IMPORTED_MODULE_0__/* .decodeArrayBuffer */ .xe)(x));
    }
    static [Symbol.hasInstance](x) {
        return instance.has(x);
    }
}
PostIVIdentifier.prototype[Symbol.toStringTag] = 'PostIVIdentifier';
Object.freeze(PostIVIdentifier.prototype);
Object.freeze(PostIVIdentifier);


/***/ }),

/***/ 82654:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _: () => (/* binding */ PostIdentifier)
/* harmony export */ });
/* harmony import */ var ts_results_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(76089);
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12247);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(89458);
/* harmony import */ var _profile_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(50508);




const instance = new WeakSet();
const id = new WeakMap();
/**
 * If identifier is a PostIdentifier, that means this post is bound with other post in some kind
 * e.g. a comment.
 */ class PostIdentifier extends _base_js__WEBPACK_IMPORTED_MODULE_1__/* .Identifier */ .x {
    static from(input) {
        if (!input) return ts_results_es__WEBPACK_IMPORTED_MODULE_0__.None;
        input = String(input);
        if (input.startsWith('post:')) return _base_js__WEBPACK_IMPORTED_MODULE_1__/* .Identifier */ .x.from(input);
        return ts_results_es__WEBPACK_IMPORTED_MODULE_0__.None;
    }
    constructor(identifier, postID){
        if (!(identifier instanceof _profile_js__WEBPACK_IMPORTED_MODULE_2__/* .ProfileIdentifier */ .W)) throw new TypeError('[@masknet/shared-base] PostIdentifier.identifier is not a ProfileIdentifier');
        if (!id.has(identifier)) id.set(identifier, Object.create(null));
        const idCache = id.get(identifier);
        // return the cache to keep the object identity
        // eslint-disable-next-line no-constructor-return
        if (idCache[postID]) return idCache[postID];
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__/* .banSlash */ .a)(postID, 'PostIdentifier.postID');
        super();
        this.identifier = identifier;
        this.postID = postID;
        Object.freeze(this);
        idCache[postID] = this;
        instance.add(this);
    }
    toText() {
        return `post:${this.postID}/${this.identifier.toText()}`;
    }
    /** @deprecated */ get postId() {
        return this.postID;
    }
    static [Symbol.hasInstance](x) {
        return instance.has(x);
    }
}
PostIdentifier.prototype[Symbol.toStringTag] = 'PostIdentifier';
Object.freeze(PostIdentifier.prototype);
Object.freeze(PostIdentifier);


/***/ }),

/***/ 50508:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   W: () => (/* binding */ ProfileIdentifier)
/* harmony export */ });
/* harmony import */ var ts_results_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(76089);
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12247);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(89458);



const instance = new WeakSet();
const id = Object.create(null);
const unknownText = 'person:localhost/$unknown';
/**
 * Refers to a profile on a network.
 */ class ProfileIdentifier extends _base_js__WEBPACK_IMPORTED_MODULE_1__/* .Identifier */ .x {
    static from(input) {
        input = String(input);
        if (input === unknownText) return ts_results_es__WEBPACK_IMPORTED_MODULE_0__.None;
        if (input.startsWith('person:')) return _base_js__WEBPACK_IMPORTED_MODULE_1__/* .Identifier */ .x.from(input);
        return ts_results_es__WEBPACK_IMPORTED_MODULE_0__.None;
    }
    static of(network, userID) {
        if (!userID || !network) return ts_results_es__WEBPACK_IMPORTED_MODULE_0__.None;
        if (network === 'localhost' && userID === '$unknown') return ts_results_es__WEBPACK_IMPORTED_MODULE_0__.None;
        if (network.includes('/') || userID.includes('/')) return ts_results_es__WEBPACK_IMPORTED_MODULE_0__.None;
        if (network.includes('\n') || userID.includes('\n')) return ts_results_es__WEBPACK_IMPORTED_MODULE_0__.None;
        return (0,ts_results_es__WEBPACK_IMPORTED_MODULE_0__.Some)(new ProfileIdentifier(network, userID));
    }
    // ! "network" and "userId" cannot be renamed because they're stored in the database in it's object form.
    constructor(network, userID){
        network = String(network).toLowerCase();
        userID = String(userID);
        if (network === 'localhost' && userID === '$unknown') {
            throw new TypeError('[@masknet/base] Use null instead.');
        }
        if (!userID) throw new TypeError('[@masknet/base] userID cannot be empty.');
        const networkCache = id[network] ??= {};
        // return the cache to keep the object identity
        // eslint-disable-next-line no-constructor-return
        if (networkCache[userID]) return networkCache[userID];
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__/* .banSlash */ .a)(network, 'ProfileIdentifier.network');
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__/* .banSlash */ .a)(userID, 'ProfileIdentifier.userID');
        super();
        this.network = network;
        this.userId = userID;
        Object.freeze(this);
        networkCache[userID] = this;
        instance.add(this);
    }
    toText() {
        return `person:${this.network}/${this.userId}`;
    }
    static [Symbol.hasInstance](x) {
        return instance.has(x);
    }
}
ProfileIdentifier.prototype[Symbol.toStringTag] = 'ProfileIdentifier';
Object.freeze(ProfileIdentifier.prototype);
Object.freeze(ProfileIdentifier);


/***/ }),

/***/ 89458:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ banSlash)
/* harmony export */ });
/* harmony import */ var ts_results_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(76089);
/* harmony import */ var _profile_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(50508);
/* harmony import */ var _post_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(82654);
/* harmony import */ var _ec_key_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(19477);
/* harmony import */ var _post_iv_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(97039);
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(12247);






/**
 * This type only refers to the stringified Identifier. ANY suffix CANNOT be renamed.
 * person:...
 * post:...
 * post_iv:...
 * ec_key:...
 *
 * Note:
 * group: has removed, if you want to add a new identifier for grouping, please choose another prefix.
 * @internal
 */ function parse(input) {
    if (!input) return ts_results_es__WEBPACK_IMPORTED_MODULE_0__.None;
    input = String(input);
    if (input.startsWith('person:')) {
        const [network, userID] = input.slice('person:'.length).split('/');
        if (!network || !userID) return ts_results_es__WEBPACK_IMPORTED_MODULE_0__.None;
        return _profile_js__WEBPACK_IMPORTED_MODULE_1__/* .ProfileIdentifier */ .W.of(network, userID);
    } else if (input.startsWith('post:')) {
        const [postID, ...rest] = input.slice('post:'.length).split('/');
        const inner = parse(rest.join('/'));
        if (inner.isNone()) return ts_results_es__WEBPACK_IMPORTED_MODULE_0__.None;
        if (inner.value instanceof _profile_js__WEBPACK_IMPORTED_MODULE_1__/* .ProfileIdentifier */ .W) return (0,ts_results_es__WEBPACK_IMPORTED_MODULE_0__.Some)(new _post_js__WEBPACK_IMPORTED_MODULE_2__/* .PostIdentifier */ ._(inner.value, postID));
        return ts_results_es__WEBPACK_IMPORTED_MODULE_0__.None;
    } else if (input.startsWith('post_iv:')) {
        const [network, postIV] = input.slice('post_iv:'.length).split('/');
        if (!network || !postIV) return ts_results_es__WEBPACK_IMPORTED_MODULE_0__.None;
        return (0,ts_results_es__WEBPACK_IMPORTED_MODULE_0__.Some)(new _post_iv_js__WEBPACK_IMPORTED_MODULE_3__/* .PostIVIdentifier */ .b(network, postIV.replaceAll('|', '/')));
    } else if (input.startsWith('ec_key:')) {
        const [curve, compressedPoint] = input.slice('ec_key:'.length).split('/');
        if (curve !== 'secp256k1') return ts_results_es__WEBPACK_IMPORTED_MODULE_0__.None;
        if (!compressedPoint) return ts_results_es__WEBPACK_IMPORTED_MODULE_0__.None;
        return (0,ts_results_es__WEBPACK_IMPORTED_MODULE_0__.Some)(new _ec_key_js__WEBPACK_IMPORTED_MODULE_4__/* .ECKeyIdentifier */ .o(curve, compressedPoint));
    }
    return ts_results_es__WEBPACK_IMPORTED_MODULE_0__.None;
}
function hasInstance(x) {
    if (x instanceof _profile_js__WEBPACK_IMPORTED_MODULE_1__/* .ProfileIdentifier */ .W || x instanceof _ec_key_js__WEBPACK_IMPORTED_MODULE_4__/* .ECKeyIdentifier */ .o || x instanceof _post_iv_js__WEBPACK_IMPORTED_MODULE_3__/* .PostIVIdentifier */ .b || x instanceof _post_js__WEBPACK_IMPORTED_MODULE_2__/* .PostIdentifier */ ._) return true;
    return false;
}
// Due to circular reference, I have to move part of this class to this file.
_base_js__WEBPACK_IMPORTED_MODULE_5__/* .Identifier */ .x[Symbol.hasInstance] = hasInstance;
_base_js__WEBPACK_IMPORTED_MODULE_5__/* .Identifier */ .x.from = parse;
Object.freeze(_base_js__WEBPACK_IMPORTED_MODULE_5__/* .Identifier */ .x.prototype);
Object.freeze(_base_js__WEBPACK_IMPORTED_MODULE_5__/* .Identifier */ .x);
/**
 * Because "/" is used to split parts in identifier
 * we should reject the "/"
 *
 * If you want to use it, you must first convert to something else
 * @internal
 */ function banSlash(input, source) {
    if (!input) return;
    if (input.includes('/')) throw new TypeError(`Cannot contain / in a part of identifier (${source}): ${input}`);
}


/***/ }),

/***/ 15393:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OB: () => (/* binding */ env),
/* harmony export */   tH: () => (/* binding */ setupBuildInfo)
/* harmony export */ });
/* unused harmony exports getBuildInfo, buildInfoReadyPromise, setupBuildInfoManually */
/* harmony import */ var _dimensiondev_holoflows_kit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(88228);
/* harmony import */ var _masknet_kit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30898);


async function getBuildInfo() {
    try {
        // eslint-disable-next-line no-bitwise
        const hasBrowserAPI = (0,_dimensiondev_holoflows_kit__WEBPACK_IMPORTED_MODULE_1__/* .getEnvironment */ .zj)() & _dimensiondev_holoflows_kit__WEBPACK_IMPORTED_MODULE_1__/* .Environment */ .qA.HasBrowserAPI;
        const b = globalThis.browser;
        const manifestVersion = hasBrowserAPI ? b.runtime.getManifest().version : undefined;
        const response = await fetch(hasBrowserAPI ? b.runtime.getURL('/build-info.json') : '/build-info.json');
        const env = await response.json();
        if (manifestVersion) Object.assign(env, {
            VERSION: manifestVersion
        });
        Object.freeze(env);
        return env;
    } catch  {
        return {
            channel: 'stable'
        };
    }
}
let env;
const [_promise, resolve] = (0,_masknet_kit__WEBPACK_IMPORTED_MODULE_0__/* .defer */ .PQ)();
const buildInfoReadyPromise = (/* unused pure expression or super */ null && (_promise));
async function setupBuildInfo() {
    if (env) return;
    return setupBuildInfoManually(await getBuildInfo());
}
function setupBuildInfoManually(_env) {
    if (env) return;
    resolve();
    env = _env;
}


/***/ }),

/***/ 76102:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   i: () => (/* binding */ flags)
/* harmony export */ });
/* harmony import */ var _buildInfo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15393);
/* harmony import */ var _dimensiondev_holoflows_kit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(88228);


const isTest = "production" === 'test';
const isDev = "production" === 'development';
const isProd = "production" === 'production';
const isInsider = _buildInfo_js__WEBPACK_IMPORTED_MODULE_0__/* .env */ .OB.channel === 'insider' || isDev;
const isBeta = isInsider || _buildInfo_js__WEBPACK_IMPORTED_MODULE_0__/* .env */ .OB.channel === 'beta';
const flags = {
    mask_sdk_enabled: isBeta,
    support_testnet_switch: isBeta,
    shadowRootInit: {
        mode: '__REACT_DEVTOOLS_GLOBAL_HOOK__' in globalThis || isBeta || isTest || !(0,_dimensiondev_holoflows_kit__WEBPACK_IMPORTED_MODULE_1__/* .isEnvironment */ .hE)(_dimensiondev_holoflows_kit__WEBPACK_IMPORTED_MODULE_1__/* .Environment */ .qA.HasBrowserAPI) ? 'open' : 'closed',
        delegatesFocus: true
    },
    using_emoji_flag: true,
    post_actions_enabled: true,
    sandboxedPluginRuntime: false,
    // twitter
    twitter_token: 'AAAAAAAAAAAAAAAAAAAAANRILgAAAAAAnNwIzUejRCOuH5E6I8xnZz4puTs%3D1Zv7ttfk8LF81IUq16cHjhLTvJu4FA33AGWWjCpTnA',
    // sentry
    sentry_earliest_version: _buildInfo_js__WEBPACK_IMPORTED_MODULE_0__/* .env */ .OB.VERSION,
    sentry_sample_rate: 0.05,
    sentry_enabled: isProd,
    sentry_event_enabled: isProd,
    sentry_exception_enabled: isProd,
    sentry_fetch_transaction_enabled: isProd,
    sentry_async_transaction_enabled: isDev,
    // mixpanel
    mixpanel_earliest_version: _buildInfo_js__WEBPACK_IMPORTED_MODULE_0__/* .env */ .OB.VERSION,
    mixpanel_sample_rate: 1,
    mixpanel_enabled: isProd,
    mixpanel_event_enabled: isProd,
    mixpanel_exception_enabled: isProd,
    mixpanel_project_token: 'b815b822fd131650e92ff8539eb5e793',
    // wallet connect
    wc_relay_url: 'wss://relay.walletconnect.com',
    wc_project_id: '8f1769933420afe8873860925fcca14f',
    wc_mode: isProd ? 'error' : 'debug',
    wc_enabled: "production" !== 'test'
};
Object.freeze(flags.shadowRootInit);
if (false) {}


/***/ }),

/***/ 24935:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  C: () => (/* binding */ RemoteFlags)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/urlcat@3.1.0_patch_hash=5r5xyq4zgcnqugwsrx4lxq2i4e/node_modules/urlcat/dist/index.mjs
var dist = __webpack_require__(78757);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/has.js + 1 modules
var has = __webpack_require__(73766);
;// CONCATENATED MODULE: ./packages/flags/src/libs/Flags.ts
class Flags {
    defaults;
    constructor(defaults){
        this.defaults = defaults;
    }
    get accessor() {
        return new Proxy(this.defaults, {
            get (target, key, receiver) {
                return Reflect.get(target, key, receiver);
            },
            set (target, key, value, receiver) {
                throw new Error('Not allowed');
            }
        });
    }
}

// EXTERNAL MODULE: ./packages/flags/src/flags/buildInfo.ts
var buildInfo = __webpack_require__(15393);
;// CONCATENATED MODULE: ./packages/flags/src/libs/RemoteFlags.ts




class RemoteFlags extends Flags {
    remoteFlagsURL;
    initials;
    KEY;
    lastFetchResult;
    get lastStorageResult() {
        if (typeof localStorage === 'undefined') return null;
        try {
            const json = localStorage.getItem(this.KEY);
            const result = json ? JSON.parse(json) : null;
            return result;
        } catch (error) {
            return null;
        }
    }
    constructor(remoteFlagsURL, defaults, initials)// the valid duration for remote fetched flags
    // the valid duration for local storage flags
    {
        super(defaults);
        this.remoteFlagsURL = remoteFlagsURL;
        this.initials = initials;
        this.KEY = 'mask-last-fetch-result';
        this.lastFetchResult = null;
        this.sync();
    }
    get options() {
        return {
            fetchTTL: 60 * 60 * 1000,
            // 1hr
            storageTTL: 2 * 60 * 60 * 1000,
            // 2hr
            ...this.initials
        };
    }
    get isLastFetchResultFresh() {
        return Date.now() - this.lastFetchTimestamp < this.options.fetchTTL;
    }
    get isLastStorageResultFresh() {
        return Date.now() - this.lastStorageTimestamp < this.options.storageTTL;
    }
    get lastFetchTimestamp() {
        return this.lastFetchResult?.timestamp ?? 0;
    }
    get lastStorageTimestamp() {
        return this.lastStorageResult?.timestamp ?? 0;
    }
    get accessor() {
        return new Proxy(this.defaults, {
            get: (target, key, receiver)=>{
                if ((0,has/* default */.Z)(this.lastFetchResult?.flags, key)) return this.lastFetchResult?.flags?.[key];
                return Reflect.get(target, key, receiver);
            },
            set: (target, key, value, receiver)=>{
                throw new Error('Not allowed');
            }
        });
    }
    /**
     * Sync with the local storage.
     */ sync() {
        if (!this.isLastStorageResultFresh) {
            try {
                localStorage.removeItem(this.KEY);
            } catch  {}
        }
        const lastFetchResult = this.lastFetchResult;
        const lastStorageResult = this.lastStorageResult;
        if (lastFetchResult?.timestamp && !lastStorageResult?.timestamp || lastFetchResult?.timestamp && lastStorageResult?.timestamp && lastStorageResult.timestamp < lastFetchResult.timestamp) {
            console.log('[RemoteFlags] sync from remote');
            try {
                localStorage.setItem(this.KEY, JSON.stringify(lastFetchResult));
            } catch  {}
        } else if (lastStorageResult?.timestamp) {
            this.lastFetchResult = lastStorageResult;
        }
    }
    /**
     * Fetch flags from the remote server.
     */ async fetch() {
        const response = await fetch((0,dist/* default */.ZP)(this.remoteFlagsURL, {
            channel: buildInfo/* env */.OB.channel,
            NODE_ENV: "production"
        }));
        const flags = await response.json();
        return flags;
    }
    /**
     * Fetch flags from the remote server and patch updates right after fetched.
     */ async fetchAndActive() {
        // Prevent fetching too frequently
        if (this.isLastFetchResultFresh) return;
        this.lastFetchResult = {
            flags: await this.fetch(),
            timestamp: Date.now()
        };
        this.sync();
    }
}


/***/ }),

/***/ 97328:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  j: () => (/* binding */ BaseInjectedProvider)
});

;// CONCATENATED MODULE: ./packages/injected-script/sdk/Base.ts
class BaseProvider {
    pathname;
    events;
    isReadyInternal;
    isConnectedInternal;
    constructor(pathname){
        this.pathname = pathname;
        this.events = new Map();
        this.isReadyInternal = false;
        this.isConnectedInternal = false;
        this.startup();
    }
    async startup() {
        await this.untilAvailable();
        // if a provider is not ready, it will not be able to connect
        if (!this.isReady) return;
        this.on('connected', ()=>{
            this.isConnectedInternal = true;
        });
        this.on('disconnect', ()=>{
            this.isConnectedInternal = false;
        });
        this.isConnectedInternal = await this.getProperty('isConnected') ?? false;
    }
    get isReady() {
        return this.isReadyInternal;
    }
    get isConnected() {
        return this.isConnectedInternal;
    }
} /**
     * Build the connection.
     */  /**
     * Break the connections.
     */  /**
     * Wait until the sdk object injected into the page.
     */  /**
     * Send RPC request to the sdk object.
     */  /**
     * Add event listener on the sdk object.
     */  /**
     * Remove event listener from the sdk object.
     */  /**
     * Emit event and invoke registered listeners
     */  /**
     * Access primitive property on the sdk object.
     */ 

// EXTERNAL MODULE: ./packages/injected-script/sdk/utils.ts
var utils = __webpack_require__(35936);
;// CONCATENATED MODULE: ./packages/injected-script/sdk/BaseInjected.ts


class BaseInjectedProvider extends BaseProvider {
    /**
     * Build the connection.
     */ connect(options) {
        return (0,utils/* createPromise */.wv)((id)=>(0,utils/* sendEvent */.qP)('web3BridgeExecute', [
                this.pathname,
                'connect'
            ].join('.'), id, options));
    }
    /**
     * Break the connections.
     */ async disconnect() {
        try {
            // some providers do not support disconnect
            return await (0,utils/* createPromise */.wv)((id)=>(0,utils/* sendEvent */.qP)('web3BridgeExecute', [
                    this.pathname,
                    'disconnect'
                ].join('.'), id));
        } catch  {
            return;
        }
    }
    /**
     * Wait until the sdk object injected into the page.
     */ async untilAvailable(validator = ()=>Promise.resolve(true)) {
        await (0,utils/* createPromise */.wv)((id)=>(0,utils/* sendEvent */.qP)('web3UntilBridgeOnline', this.pathname.split('.')[0], id));
        if (await validator()) {
            this.isReadyInternal = true;
        }
    }
    /**
     * Send RPC request to the sdk object.
     */ request(data) {
        return (0,utils/* createPromise */.wv)((id)=>(0,utils/* sendEvent */.qP)('web3BridgeExecute', [
                this.pathname,
                'request'
            ].join('.'), id, data));
    }
    /**
     * Add event listener on the sdk object.
     */ on(event, callback) {
        if (!this.events.has(event)) {
            this.events.set(event, new Set());
            (0,utils/* sendEvent */.qP)('web3BridgeBindEvent', this.pathname, 'web3BridgeEmitEvent', event);
        }
        const set = this.events.get(event);
        set.add(callback);
        return ()=>void set.delete(callback);
    }
    /**
     * Remove event listener from the sdk object.
     */ off(event, callback) {
        this.events.get(event)?.delete(callback);
    }
    /**
     * Emit event and invoke registered listeners
     */ emit(event, data) {
        for (const f of this.events.get(event) || []){
            try {
                Reflect.apply(f, null, data);
            } catch  {}
        }
    }
    /**
     * Access primitive property on the sdk object.
     */ getProperty(key) {
        return (0,utils/* createPromise */.wv)((id)=>(0,utils/* sendEvent */.qP)('web3BridgePrimitiveAccess', this.pathname, id, key));
    }
}


/***/ }),

/***/ 53230:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Q: () => (/* binding */ BrowserProvider)
/* harmony export */ });
/* harmony import */ var _BaseInjected_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97328);

class BrowserProvider extends _BaseInjected_js__WEBPACK_IMPORTED_MODULE_0__/* .BaseInjectedProvider */ .j {
    constructor(){
        super('ethereum');
    }
}


/***/ }),

/***/ 51092:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   u: () => (/* binding */ CloverProvider)
/* harmony export */ });
/* harmony import */ var _BaseInjected_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97328);

class CloverProvider extends _BaseInjected_js__WEBPACK_IMPORTED_MODULE_0__/* .BaseInjectedProvider */ .j {
    constructor(){
        super('clover');
    }
    async untilAvailable() {
        await super.untilAvailable(async ()=>{
            const isClover = await super.getProperty('isClover');
            return !!isClover;
        });
    }
}


/***/ }),

/***/ 38488:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E: () => (/* binding */ Coin98ProviderType),
/* harmony export */   v: () => (/* binding */ Coin98Provider)
/* harmony export */ });
/* harmony import */ var _BaseInjected_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97328);

var Coin98ProviderType;
(function(Coin98ProviderType) {
    Coin98ProviderType[Coin98ProviderType["EVM"] = 1] = "EVM";
    Coin98ProviderType[Coin98ProviderType["Solana"] = 2] = "Solana";
    Coin98ProviderType[Coin98ProviderType["Near"] = 3] = "Near";
})(Coin98ProviderType || (Coin98ProviderType = {}));
class Coin98Provider extends _BaseInjected_js__WEBPACK_IMPORTED_MODULE_0__/* .BaseInjectedProvider */ .j {
    type;
    constructor(type){
        const pathnameMap = {
            [Coin98ProviderType.EVM]: 'coin98.provider',
            [Coin98ProviderType.Near]: 'coin98.near',
            [Coin98ProviderType.Solana]: 'coin98.sol'
        };
        super(pathnameMap[type]);
        this.type = type;
    }
    async request(data) {
        // coin98 cannot handle it correctly (test with coin98 v6.0.3)
        if (data.method === 'eth_chainId') return await this.getProperty('chainId');
        return super.request(data);
    }
}


/***/ }),

/***/ 92607:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   X: () => (/* binding */ CoinbaseProvider)
/* harmony export */ });
/* harmony import */ var _BaseInjected_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97328);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(35936);


class CoinbaseProvider extends _BaseInjected_js__WEBPACK_IMPORTED_MODULE_0__/* .BaseInjectedProvider */ .j {
    constructor(){
        super('coinbaseWalletExtension');
    }
    async untilAvailable() {
        await super.untilAvailable(async ()=>!!await super.getProperty('isCoinbaseWallet'));
    }
    connect(options) {
        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__/* .createPromise */ .wv)((id)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__/* .sendEvent */ .qP)('web3BridgeExecute', [
                this.pathname,
                'enable'
            ].join('.'), id, options));
    }
    emit(event, data) {
        for (const f of this.events.get(event) || []){
            try {
                Reflect.apply(f, null, event === 'chainChanged' ? [
                    `0x${Number(data[0]).toString(16)}`
                ] : data);
            } catch  {}
        }
    }
}


/***/ }),

/***/ 13389:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Y: () => (/* binding */ MetaMaskProvider)
/* harmony export */ });
/* harmony import */ var _BaseInjected_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97328);

class MetaMaskProvider extends _BaseInjected_js__WEBPACK_IMPORTED_MODULE_0__/* .BaseInjectedProvider */ .j {
    constructor(){
        super('ethereum.__metamask__');
    }
    async untilAvailable() {
        await super.untilAvailable(async ()=>{
            const isMetaMask = await super.getProperty('isMetaMask');
            return !!isMetaMask;
        });
    }
}


/***/ }),

/***/ 37464:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   k: () => (/* binding */ OKXProvider)
/* harmony export */ });
/* harmony import */ var _BaseInjected_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97328);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(35936);


class OKXProvider extends _BaseInjected_js__WEBPACK_IMPORTED_MODULE_0__/* .BaseInjectedProvider */ .j {
    constructor(){
        super('okxwallet');
    }
    async untilAvailable() {
        await super.untilAvailable(async ()=>!!await super.getProperty('isOKExWallet'));
    }
    connect(options) {
        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__/* .createPromise */ .wv)((id)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__/* .sendEvent */ .qP)('web3BridgeExecute', [
                this.pathname,
                'enable'
            ].join('.'), id, options));
    }
    emit(event, data) {
        for (const f of this.events.get(event) || []){
            try {
                Reflect.apply(f, null, event === 'chainChanged' ? [
                    `0x${Number(data[0]).toString(16)}`
                ] : data);
            } catch  {}
        }
    }
}


/***/ }),

/***/ 77122:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   J: () => (/* binding */ OperaProvider)
/* harmony export */ });
/* harmony import */ var _BaseInjected_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97328);

class OperaProvider extends _BaseInjected_js__WEBPACK_IMPORTED_MODULE_0__/* .BaseInjectedProvider */ .j {
    constructor(){
        super('ethereum');
    }
    async untilAvailable() {
        await super.untilAvailable(async ()=>{
            const isOpera = await super.getProperty('isOpera');
            return !!isOpera;
        });
    }
}


/***/ }),

/***/ 72297:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   p: () => (/* binding */ PhantomProvider)
/* harmony export */ });
/* harmony import */ var _BaseInjected_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97328);

class PhantomProvider extends _BaseInjected_js__WEBPACK_IMPORTED_MODULE_0__/* .BaseInjectedProvider */ .j {
    constructor(){
        super('phantom.solana');
    }
    async connect(options) {
        await super.connect(options);
        return {
            publicKey: await super.getProperty('publicKey')
        };
    }
}


/***/ }),

/***/ 5993:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   B: () => (/* binding */ SolflareProvider)
/* harmony export */ });
/* harmony import */ var _BaseInjected_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97328);

class SolflareProvider extends _BaseInjected_js__WEBPACK_IMPORTED_MODULE_0__/* .BaseInjectedProvider */ .j {
    constructor(){
        super('solflare');
    }
    async connect(options) {
        await super.connect(options);
        return {
            publicKey: await super.getProperty('publicKey')
        };
    }
}


/***/ }),

/***/ 35936:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Eu: () => (/* binding */ rejectPromise),
/* harmony export */   LD: () => (/* binding */ resolvePromise),
/* harmony export */   qP: () => (/* binding */ sendEvent),
/* harmony export */   wv: () => (/* binding */ createPromise)
/* harmony export */ });
/* harmony import */ var _shared_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70733);

let warned = false;
function sendEvent(name, ...params) {
    if (!warned && typeof location === 'object' && location.protocol.includes('extension')) {
        console.warn('This code is not expected to be run in the extension pages. Please check your code.');
        warned = true;
    }
    if (typeof document === 'undefined') return;
    document.dispatchEvent(new CustomEvent(_shared_index_js__WEBPACK_IMPORTED_MODULE_0__/* .CustomEventId */ .OV, {
        cancelable: true,
        bubbles: true,
        detail: (0,_shared_index_js__WEBPACK_IMPORTED_MODULE_0__/* .encodeEvent */ .Nu)(name, params)
    }));
}
const promisePool = new Map();
let id = 1;
function createPromise(callback) {
    return new Promise((resolve, reject)=>{
        id += 1;
        promisePool.set(id, [
            resolve,
            reject
        ]);
        callback(id);
    });
}
function resolvePromise(id, data) {
    const pair = promisePool.get(id);
    if (pair) {
        pair[0](data);
        promisePool.delete(id);
    }
}
function rejectPromise(id, data) {
    const pair = promisePool.get(id);
    if (pair) {
        pair[1](data);
        promisePool.delete(id);
    }
}


/***/ }),

/***/ 70733:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Nu: () => (/* binding */ encodeEvent),
/* harmony export */   OV: () => (/* binding */ CustomEventId),
/* harmony export */   Vu: () => (/* binding */ decodeEvent)
/* harmony export */ });
const CustomEventId = '413f832d-db5c-4779-8d7e-1f7127bd167b';
/** Simulate a paste event on the activeElement */ /** Simulate an image paste event on the activeElement */ /** Simulate a input event on the activeElement */ /** Simulate a image upload on the activeElement on instagram */ /**
     * Simulate an image upload event.
     *
     * How to use:
     * Call this event, then invoke the file selector (for now it's instagram). It will invoke click on some input, then let's replace with the result.
     */ // #region web3 bridge
/** Request the bridge to listen on an event. */ /** When a event happened. */ /** Send JSON RPC request. */ /** Access primitive property on the window.ethereum object. */ /** Wait until window.ethereum appears */ /** Request the bridge to call function. */ // #endregion
/** A simple RPC. */ // Not using async-call-rpc because we need to make sure every intrinsic
// we're using is captured.
/** Wait for ethereum object appears. */ /** Send JSON RPC to the ethereum provider. */ /** Add event listener */ /** Remove event listener */ /** Access primitive property on the ethereum object. */ const { parse, stringify } = JSON;
const { isArray } = Array;
const { setPrototypeOf } = Object;
const { String } = globalThis;
function encodeEvent(key, args) {
    return stringify(setPrototypeOf([
        key,
        args
    ], null), function formatter(key, value) {
        if (value instanceof Uint8Array) return {
            $type: 'u8[]',
            value: [
                ...value
            ]
        };
        return value;
    });
}
function decodeEvent(data) {
    const result = parse(String(data), function reviver(key, value) {
        if (typeof value === 'object' && value && '$type' in value && 'value' in value && isArray(value.value) && value.$type === 'u8[]') return new Uint8Array(value.value);
        return value;
    });
    // Do not throw new Error cause it requires a global lookup.
    if (!isEventItemBeforeSerialization(result)) throw null;
    return result;
}
function isEventItemBeforeSerialization(data) {
    if (!isArray(data)) return false;
    if (data.length !== 2) return false;
    if (typeof data[0] !== 'string') return false;
    if (!isArray(data[1])) return false;
    return true;
}



/***/ }),

/***/ 73401:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E: () => (/* binding */ queryClient)
/* harmony export */ });
/* harmony import */ var _tanstack_react_query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(72326);

const queryClient = new _tanstack_react_query__WEBPACK_IMPORTED_MODULE_0__/* .QueryClient */ .S({
    defaultOptions: {
        queries: {
            staleTime: 20_000,
            cacheTime: Number.POSITIVE_INFINITY
        }
    }
});


/***/ }),

/***/ 41646:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   rc: () => (/* binding */ createKVStorageHost)
/* harmony export */ });
/* unused harmony export removed */
/* harmony import */ var _masknet_kit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30898);




const removed = Symbol.for('removed');

/**
 * Create a root scope of simple K/V storage.
 * @param backend The storage provider
 * @param message The message channel to sync the latest value
 * @param signal The abort signal
 */ function createKVStorageHost(backend, message, signal = new AbortController().signal) {
    return (name, defaultValues)=>{
        return createScope(signal, backend, message, null, name, defaultValues);
    };
}
/** If this state is initialized */ /** A promise of initialization of this state. */ const alwaysThrowHandler = ()=>{
    throw new TypeError('Invalid operation');
};
function createScope(signal, backend, message, parentScope, scope, defaultValues) {
    if (scope.includes('/')) throw new TypeError('scope name cannot contains "/"');
    if (scope.includes(':')) throw new TypeError('scope name cannot contains ":"');
    const currentScope = parentScope === null ? scope : `${parentScope}/${scope}`;
    const storage_inner = {
        __proto__: new Proxy({
            __proto__: null
        }, {
            get: (_, prop)=>get(prop)
        })
    };
    const storage = new Proxy(storage_inner, {
        defineProperty: alwaysThrowHandler,
        deleteProperty: alwaysThrowHandler,
        getPrototypeOf: ()=>null,
        setPrototypeOf: (_, v)=>v === null,
        getOwnPropertyDescriptor: (_, p)=>{
            get(p);
            return Reflect.getOwnPropertyDescriptor(storage_inner, p);
        }
    });
    function get(key) {
        if (typeof key === 'symbol') return undefined;
        const value = createState(signal, backend, message, currentScope, key, defaultValues[key]);
        Object.defineProperty(storage_inner, key, {
            enumerable: true,
            value
        });
        return value;
    }
    backend.beforeAutoSync.then(()=>{
        for (const [key, value] of Object.entries(defaultValues)){
            if (value === removed) continue;
            // trigger the auto sync
            storage[key].initialized;
        }
    });
    return {
        createSubScope (subScope, defaultValues, scopeSignal) {
            const aggregatedSignal = (0,_masknet_kit__WEBPACK_IMPORTED_MODULE_0__/* .combineAbortSignal */ .dq)(scopeSignal, signal);
            return createScope(aggregatedSignal, backend, message, currentScope, subScope, defaultValues);
        },
        storage
    };
}
function createState(signal, backend, message, scope, prop, defaultValue) {
    const propKey = `${scope}:${prop}`;
    let initialized = false;
    let usingDefaultValue = true;
    const initializedPromise = backend.beforeAutoSync.then(()=>backend.getValue(propKey)).then((val)=>{
        if (val.isSome()) usingDefaultValue = false;
        return val.unwrapOr(defaultValue);
    }).then((val)=>{
        state = val;
        initialized = true;
    });
    let state = defaultValue;
    const listeners = new Set();
    function subscribe(f) {
        listeners.add(f);
        return ()=>listeners.delete(f);
    }
    const subscription = {
        getCurrentValue: ()=>{
            // TODO: suspense
            if (!initialized) throw initializedPromise;
            return state;
        },
        subscribe
    };
    function setter(val) {
        if (isEqual(state, val)) return;
        usingDefaultValue = false;
        state = val;
        for (const f of listeners)f();
    }
    message.on(([eventKey, newValue])=>eventKey === propKey && setter(newValue), {
        signal
    });
    return {
        get initialized () {
            return initialized;
        },
        get initializedPromise () {
            return initializedPromise;
        },
        get value () {
            if (!initialized) throw new Error(`Try to access K/V state before initialization finished: ${propKey}.`);
            return state;
        },
        async setValue (value) {
            if (signal.aborted) throw new TypeError('Aborted storage.');
            // force trigger store when set state with default value to make it persistent.
            if (usingDefaultValue || !isEqual(state, value)) await backend.setValue(propKey, value);
            setter(value);
        },
        subscription
    };
}
function isEqual(a, b) {
    if (a === b) return true;
    if (a === null || b === null) return false;
    if (typeof a === 'object') {
        // Note: JSON stringify is not stable.
        return JSON.stringify(a) === JSON.stringify(b);
    }
    return false;
}


/***/ }),

/***/ 93871:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   X: () => (/* binding */ createProxyKVStorageBackend)
/* harmony export */ });
/* harmony import */ var _masknet_kit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30898);

function createProxyKVStorageBackend() {
    let target;
    let [promise, resolve, reject] = (0,_masknet_kit__WEBPACK_IMPORTED_MODULE_0__/* .defer */ .PQ)();
    return {
        get beforeAutoSync () {
            return promise;
        },
        async getValue (...args) {
            return target.getValue(...args);
        },
        async setValue (...args) {
            return target.setValue(...args);
        },
        replaceBackend (backend) {
            target = backend;
            // resolve old one
            backend.beforeAutoSync.then(resolve, reject);
            // setup new one
            [promise, resolve, reject] = (0,_masknet_kit__WEBPACK_IMPORTED_MODULE_0__/* .defer */ .PQ)();
            backend.beforeAutoSync.then(resolve, reject);
        }
    };
}


/***/ }),

/***/ 40514:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   W: () => (/* binding */ CrossIsolationMessages)
/* harmony export */ });
/* unused harmony export __workaround__replaceImplementationOfCrossIsolationMessage__ */
/* harmony import */ var _dimensiondev_holoflows_kit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61530);

/**
 * Prefer MaskMessages.
 *
 * Only use this in the following cases:
 *
 * - You need to send message across different plugins
 *       e.g. from the packages/plugins/Example to packages/plugins/Example2
 * - You need to send message from plugin
 *       e.g. packages/plugins/Example to the main Mask extension.
 */ // TODO: find a way to use a good API for cross isolation communication.
let CrossIsolationMessages = new _dimensiondev_holoflows_kit__WEBPACK_IMPORTED_MODULE_0__/* .WebExtensionMessage */ .$({
    domain: 'cross-isolation'
});
function __workaround__replaceImplementationOfCrossIsolationMessage__(msg) {
    CrossIsolationMessages = {
        events: msg
    };
} /** @returns A function to remove the listener */ 


/***/ }),

/***/ 65734:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   q: () => (/* binding */ MaskMessages)
/* harmony export */ });
/* unused harmony export __workaround__replaceImplementationOfMaskMessage__ */
/* harmony import */ var _dimensiondev_holoflows_kit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61530);
/* harmony import */ var _serializer_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40464);


let MaskMessages;
const m = new _dimensiondev_holoflows_kit__WEBPACK_IMPORTED_MODULE_0__/* .WebExtensionMessage */ .$({
    domain: 'mask'
});
m.serialization = _serializer_index_js__WEBPACK_IMPORTED_MODULE_1__/* .serializer */ .G;
MaskMessages = m;
function __workaround__replaceImplementationOfMaskMessage__(msg) {
    MaskMessages = {
        events: msg
    };
}


/***/ }),

/***/ 95766:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   B: () => (/* binding */ NextIDAction),
/* harmony export */   V: () => (/* binding */ NextIDPlatform)
/* harmony export */ });
var NextIDAction;
(function(NextIDAction) {
    NextIDAction["Create"] = 'create';
    NextIDAction["Delete"] = 'delete';
})(NextIDAction || (NextIDAction = {}));
var NextIDPlatform/**
     * Platform identity.
     * For Twitter, it's twitter account
     */ /**
     * @deprecated
     * legacy data
     */ /**
     * @deprecated
     * legacy data
     */ // Some other related bindings, like some other ens
// #region kv server
// pluginID
// #endregion
;
(function(NextIDPlatform) {
    NextIDPlatform["NextID"] = 'nextid';
    NextIDPlatform["Twitter"] = 'twitter';
    NextIDPlatform["Keybase"] = 'keybase';
    NextIDPlatform["Ethereum"] = 'ethereum';
    NextIDPlatform["GitHub"] = 'github';
    NextIDPlatform["ENS"] = 'ens';
    NextIDPlatform["RSS3"] = 'rss3';
    NextIDPlatform["LENS"] = 'lens';
    NextIDPlatform["REDDIT"] = 'reddit';
    NextIDPlatform["SYBIL"] = 'sybil';
    NextIDPlatform["EthLeaderboard"] = 'ethLeaderboard';
    NextIDPlatform["SpaceId"] = 'space_id';
    NextIDPlatform["Farcaster"] = 'farcaster';
    NextIDPlatform["Bit"] = 'dotbit';
    NextIDPlatform["Unstoppable"] = 'unstoppabledomains';
    NextIDPlatform["CyberConnect"] = 'cyberconnect';
})(NextIDPlatform || (NextIDPlatform = {}));


/***/ }),

/***/ 38645:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LI: () => (/* binding */ createPageable),
/* harmony export */   T1: () => (/* binding */ pageableToIterator),
/* harmony export */   gT: () => (/* binding */ createNextIndicator),
/* harmony export */   sz: () => (/* binding */ createIndicator)
/* harmony export */ });
/** the indicator of the current page */ /** the indicator of the next page */ /** items data */ /** The id of the page (cursor). */ /** The index number of the page. */ function createIndicator(indicator, id) {
    const index = indicator?.index ?? 0;
    return {
        id: id ?? indicator?.id ?? index.toString(),
        index
    };
}
function createNextIndicator(indicator, id) {
    const index = (indicator?.index ?? 0) + 1;
    return typeof id === 'string' ? {
        id,
        index
    } : {
        id: index.toString(),
        index
    };
}
function createPageable(data, indicator, nextIndicator) {
    // with next page
    if (typeof nextIndicator !== 'undefined') {
        return {
            data,
            indicator,
            nextIndicator
        };
    }
    // without next page
    return {
        data,
        indicator
    };
}
async function* pageableToIterator(getPageable, { maxSize = 25 } = {}) {
    let indicator = createIndicator();
    for(let i = 0; i < maxSize; i += 1){
        try {
            const pageable = await getPageable(indicator);
            if (!pageable) return;
            yield* pageable.data;
            if (!pageable.nextIndicator) return;
            indicator = pageable.nextIndicator;
        } catch (error) {
            yield new Error(error.message);
        }
    }
}


/***/ }),

/***/ 77953:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   J: () => (/* binding */ EnhanceableSite),
/* harmony export */   v: () => (/* binding */ ExtensionSite)
/* harmony export */ });
var EnhanceableSite;
(function(EnhanceableSite) {
    EnhanceableSite["Localhost"] = 'localhost';
    EnhanceableSite["App"] = 'app.mask.io';
    EnhanceableSite["Twitter"] = 'twitter.com';
    EnhanceableSite["Facebook"] = 'facebook.com';
    EnhanceableSite["Minds"] = 'minds.com';
    EnhanceableSite["Instagram"] = 'instagram.com';
    EnhanceableSite["OpenSea"] = 'opensea.io';
    EnhanceableSite["Mirror"] = 'mirror.xyz';
})(EnhanceableSite || (EnhanceableSite = {}));
var ExtensionSite;
(function(ExtensionSite) {
    ExtensionSite["Dashboard"] = 'dashboard';
    ExtensionSite["Popup"] = 'popup';
})(ExtensionSite || (ExtensionSite = {}));


/***/ }),

/***/ 66584:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Y: () => (/* binding */ Sniffings)
/* harmony export */ });
var SiteHost;
(function(SiteHost) {
    SiteHost["Twitter"] = 'twitter.com';
    SiteHost["Facebook"] = 'facebook.com';
})(SiteHost || (SiteHost = {}));
const isChromium = typeof navigator === 'object' && (navigator.userAgent.includes('Chrome') || navigator.userAgent.includes('Chromium'));
const Sniffings = {
    is_dashboard_page: typeof location === 'object' && location.protocol.includes('extension') && location.href.includes('dashboard.html'),
    is_popup_page: typeof location === 'object' && location.protocol.includes('extension') && location.href.includes('popups.html'),
    is_twitter_page: typeof location === 'object' && location.href.includes(SiteHost.Twitter),
    is_facebook_page: typeof location === 'object' && location.href.includes(SiteHost.Facebook),
    is_opera: typeof navigator === 'object' && navigator.userAgent.includes('OPR/'),
    is_edge: typeof navigator === 'object' && navigator.userAgent.includes('Edg'),
    is_firefox: typeof navigator === 'object' && navigator.userAgent.includes('Firefox'),
    is_chromium: isChromium,
    is_safari: !isChromium && navigator.userAgent.includes('Safari')
};


/***/ }),

/***/ 60530:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   w: () => (/* binding */ TelemetryID)
/* harmony export */ });
/* harmony import */ var _helpers_ValueRef_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(88547);

const TelemetryID = new _helpers_ValueRef_js__WEBPACK_IMPORTED_MODULE_0__/* .ValueRef */ .Xf('0000000000000000000000000000000000000000');


/***/ }),

/***/ 88547:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Xf: () => (/* binding */ ValueRef),
/* harmony export */   td: () => (/* binding */ ValueRefWithReady)
/* harmony export */ });
/* unused harmony export ValueRefJSON */
/* deferred harmony import */ var _masknet_kit__WEBPACK_IMPORTED_MODULE_0__ = {
	/* namespace */ get a() {
		var exports = __webpack_require__(30898);
		Object.defineProperty(this, "a", { value: exports });
		return exports;
	}

};
/* deferred harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_1__ = {
	/* dynamic */ get a() {
		var exports = __webpack_require__(74545);
		if (exports.__esModule) Object.defineProperty(this, "a", { value: exports });
		return exports;
	}

};
// All imports must be deferred. This file loads in the very early stage.

// false positive. we're not using lodash.get
// eslint-disable-next-line @typescript-eslint/no-restricted-imports



const defaultComparer = (a, b)=>a === b;
class ValueRef {
    constructor(value, isEqual = defaultComparer){
        this._value = value;
        this.isEqual = isEqual;
    }
    get value() {
        return this._value;
    }
    set value(newVal) {
        const oldVal = this._value;
        if (this.isEqual(newVal, oldVal)) return;
        this._value = newVal;
        for (const fn of this.watcher){
            try {
                fn(newVal, oldVal);
            } catch (err) {
                console.error(err);
            }
        }
    }
    addListener(fn) {
        this.watcher.add(fn);
        return ()=>void this.watcher.delete(fn);
    }
    watcher = new Set();
    isEqual;
    _value;
}
class ValueRefWithReady extends ValueRef {
    constructor(value, isEqual = defaultComparer){
        // this is unsafe. we assigned T | undefined to T
        super(value, isEqual);
        const [promise, resolve] = _masknet_kit__WEBPACK_IMPORTED_MODULE_0__.a/* .defer */ .PQ();
        this.readyPromise = promise.then(()=>this.value);
        this.nowReady = resolve;
    }
    get value() {
        return super.value;
    }
    set value(value) {
        if (this.ready === false) {
            this.nowReady();
            Object.assign(this, {
                ready: true,
                nowReady: undefined
            });
        }
        super.value = value;
    }
    nowReady;
    ready = false;
    readyPromise;
}
/**
 * @deprecated
 * Avoid using this. You should define a comparer to use the object directly.
 * This class is provided to strongly type the existing bad-smell code.
 */ class ValueRefJSON extends (/* unused pure expression or super */ null && (ValueRefWithReady)) {
    constructor(defaultValue){
        super(stringify.default(defaultValue), lodash.isEqual);
    }
    get value() {
        return super.value;
    }
    set value(value) {
        if (typeof value === 'string') {
            super.value = value;
            return;
        }
        if (lodash.isEqual(this.asJSON, value)) return;
        this.json = value;
        super.value = stringify.default(value);
    }
    json;
    get asJSON() {
        if (this.json) return this.json;
        if (this.value === '[]') return this.json = constants.EMPTY_LIST;
        if (this.value === '{}') return this.json = constants.EMPTY_OBJECT;
        return this.json = JSON.parse(this.value);
    }
}


/***/ }),

/***/ 67830:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   S: () => (/* binding */ asyncIteratorToArray)
/* harmony export */ });
/* unused harmony export flattenAsyncIterator */
async function asyncIteratorToArray(iterable) {
    if (!iterable) return [];
    const arr = [];
    for await (const x of iterable)if (!(x instanceof Error)) arr.push(x);
    return arr;
}
async function* flattenAsyncIterator(iterables) {
    for (const x of iterables)yield* x;
}


/***/ }),

/***/ 74170:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   F: () => (/* binding */ createLookupTableResolver)
/* harmony export */ });
function createLookupTableResolver(map, fallback) {
    function resolveFallback(key) {
        if (typeof fallback === 'function') return fallback(key);
        return fallback;
    }
    return (key)=>map[key] ?? resolveFallback(key);
}


/***/ }),

/***/ 1749:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   o: () => (/* binding */ setDebugObject)
/* harmony export */ });
class Opaque {
    #DebugOnlyValue;
    constructor(key, value){
        this.#DebugOnlyValue = {
            __proto__: null,
            get ['set globalThis.' + key] () {
                console.log(`[DEBUG] globalThis.${key} =`, value);
                globalThis[key] = value;
                return value;
            },
            value
        };
        this.#DebugOnlyValue;
        Object.setPrototypeOf(this, null);
        Object.freeze(this);
    }
}
/**
 * This function provide a way to prevent debug-purposed global values accidentally used in production code.
 * All value wrapped by this function can only be accessed in the devtools.
 */ function setDebugObject(key, value) {
    globalThis[key] = new Opaque(key, value);
}


/***/ }),

/***/ 85791:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   e: () => (/* binding */ getCookie)
/* harmony export */ });
function getCookie(field) {
    const pair = document.cookie.split('; ').find((x)=>x.startsWith(`${field}=`));
    if (!pair) return '';
    const [, value] = pair.split('=');
    return value;
}


/***/ }),

/***/ 92560:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   j: () => (/* binding */ mixin)
/* harmony export */ });
function mixin(...mixinTargets) {
    if (mixinTargets.some((x)=>typeof x !== 'object' || x === null)) throw new TypeError('mixin() expects object arguments');
    const container = {
        __proto__: new Proxy({}, {
            get (_, key) {
                if (key === '__proto__') return undefined;
                const mixinTarget = mixinTargets.find((x)=>key in x);
                if (!mixinTarget) return undefined;
                const mixinItem = mixinTarget[key];
                if (typeof mixinItem === 'function') // Note: not use .bind here because it will override the arguments for bound function.
                return set(key, (...args)=>Reflect.apply(mixinItem, mixinTarget, args));
                return set(key, mixinItem);
            },
            has (_, key) {
                return mixinTargets.some((x)=>key in x);
            }
        })
    };
    function set(k, value) {
        Object.defineProperty(container, k, {
            configurable: true,
            enumerable: true,
            value
        });
        return value;
    }
    return new Proxy(container, traps);
}
const traps = {
    getPrototypeOf: ()=>null,
    setPrototypeOf: (_, p)=>p === null,
    getOwnPropertyDescriptor (container, key) {
        // trigger [[Get]]
        Reflect.get(container, key);
        return Reflect.getOwnPropertyDescriptor(container, key);
    },
    has (container, key) {
        return key in container;
    }
};


/***/ }),

/***/ 38506:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   L: () => (/* binding */ parseURL)
/* harmony export */ });
function parseURL(url) {
    if (!url || !URL.canParse(url)) return;
    return new URL(url);
}


/***/ }),

/***/ 28110:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D: () => (/* binding */ resolve)
/* harmony export */ });
function resolve(unresolved, options) {
    if (typeof unresolved !== 'function') return unresolved;
    const unresolvedFunction = unresolved;
    return unresolvedFunction(options);
}


/***/ }),

/***/ 59429:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ createI18NBundle)
/* harmony export */ });
function addI18NBundle(instance, namespace, langs) {
    if (!instance.addResourceBundle) throw new TypeError('Please call instance.init() first');
    try {
        if (false) {}
    } catch  {}
    // ignore
    for (const lang of Object.keys(langs)){
        instance.addResourceBundle(lang, namespace, removeEmptyString(langs[lang]));
    }
}
function createI18NBundle(namespace, langs) {
    return (instance)=>addI18NBundle(instance, namespace, langs);
}
function removeEmptyString(lang) {
    const next = {};
    for(const key in lang){
        if (lang[key]) next[key] = lang[key];
    }
    return next;
}


/***/ }),

/***/ 40464:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  G: () => (/* binding */ serializer_serializer)
});

// UNUSED EXPORTS: registerSerializableClass

;// CONCATENATED MODULE: ./node_modules/.pnpm/typeson@9.0.3/node_modules/typeson/dist/typeson.esm.min.js
function ownKeys(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function _objectSpread2(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?ownKeys(Object(r),!0).forEach((function(t){_defineProperty(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):ownKeys(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function _typeof(e){return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},_typeof(e)}function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function _defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,_toPropertyKey(n.key),n)}}function _createClass(e,t,r){return t&&_defineProperties(e.prototype,t),r&&_defineProperties(e,r),Object.defineProperty(e,"prototype",{writable:!1}),e}function _defineProperty(e,t,r){return(t=_toPropertyKey(t))in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function _slicedToArray(e,t){return function _arrayWithHoles(e){if(Array.isArray(e))return e}(e)||function _iterableToArrayLimit(e,t){var r=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=r){var n,o,i,a,c=[],s=!0,u=!1;try{if(i=(r=r.call(e)).next,0===t){if(Object(r)!==r)return;s=!1}else for(;!(s=(n=i.call(r)).done)&&(c.push(n.value),c.length!==t);s=!0);}catch(e){u=!0,o=e}finally{try{if(!s&&null!=r.return&&(a=r.return(),Object(a)!==a))return}finally{if(u)throw o}}return c}}(e,t)||_unsupportedIterableToArray(e,t)||function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function _toConsumableArray(e){return function _arrayWithoutHoles(e){if(Array.isArray(e))return _arrayLikeToArray(e)}(e)||function _iterableToArray(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||_unsupportedIterableToArray(e)||function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function _unsupportedIterableToArray(e,t){if(e){if("string"==typeof e)return _arrayLikeToArray(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);return"Object"===r&&e.constructor&&(r=e.constructor.name),"Map"===r||"Set"===r?Array.from(e):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?_arrayLikeToArray(e,t):void 0}}function _arrayLikeToArray(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n}function _toPropertyKey(e){var t=function _toPrimitive(e,t){if("object"!=typeof e||null===e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!=typeof n)return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==typeof t?t:String(t)}var e=_createClass((function TypesonPromise(e){_classCallCheck(this,TypesonPromise),this.p=new Promise(e)}));e.__typeson__type__="TypesonPromise","undefined"!=typeof Symbol&&Object.defineProperty(e.prototype,Symbol.toStringTag,{get:function get(){return"TypesonPromise"}}),e.prototype.then=function(t,r){var n=this;return new e((function(e,o){n.p.then((function(r){e(t?t(r):r)})).catch((function(e){return r?r(e):Promise.reject(e)})).then(e,o)}))},e.prototype.catch=function(e){return this.then((function(){}),e)},e.resolve=function(t){return new e((function(e){e(t)}))},e.reject=function(t){return new e((function(e,r){r(t)}))},e.all=function(t){return new e((function(e,r){Promise.all(t.map((function(e){return null!=e&&e.constructor&&"__typeson__type__"in e.constructor&&"TypesonPromise"===e.constructor.__typeson__type__?e.p:e}))).then(e,r)}))},e.race=function(t){return new e((function(e,r){Promise.race(t.map((function(e){return null!=e&&e.constructor&&"__typeson__type__"in e.constructor&&"TypesonPromise"===e.constructor.__typeson__type__?e.p:e}))).then(e,r)}))},e.allSettled=function(t){return new e((function(e,r){Promise.allSettled(t.map((function(e){return null!=e&&e.constructor&&"__typeson__type__"in e.constructor&&"TypesonPromise"===e.constructor.__typeson__type__?e.p:e}))).then(e,r)}))};var t=Object.hasOwn,r=Object.getPrototypeOf;function isThenable(e,t){return isObject(e)&&"function"==typeof e.then&&(!t||"function"==typeof e.catch)}function toStringTag(e){return Object.prototype.toString.call(e).slice(8,-1)}function hasConstructorOf(e,n){if(!e||"object"!==_typeof(e))return!1;var o=r(e);if(!o)return null===n;var i=t(o,"constructor")&&o.constructor;return"function"!=typeof i?null===n:n===i||(null!==n&&Function.prototype.toString.call(i)===Function.prototype.toString.call(n)||"function"==typeof n&&"string"==typeof i.__typeson__type__&&i.__typeson__type__===n.__typeson__type__)}function isPlainObject(e){return!(!e||"Object"!==toStringTag(e))&&(!r(e)||hasConstructorOf(e,Object))}function isUserObject(e){if(!e||"Object"!==toStringTag(e))return!1;var t=r(e);return!t||(hasConstructorOf(e,Object)||isUserObject(t))}function isObject(e){return null!==e&&"object"===_typeof(e)}function escapeKeyPathComponent(e){return e.replaceAll("''","''''").replace(/^$/,"''").replaceAll("~","~0").replaceAll(".","~1")}function unescapeKeyPathComponent(e){return e.replaceAll("~1",".").replaceAll("~0","~").replace(/^''$/,"").replaceAll("''''","''")}function getByKeyPath(e,t){if(""===t)return e;if(null===e||"object"!==_typeof(e))throw new TypeError("Unexpected non-object type");var r=t.indexOf(".");if(r>-1){var n=e[unescapeKeyPathComponent(t.slice(0,r))];return void 0===n?void 0:getByKeyPath(n,t.slice(r+1))}return e[unescapeKeyPathComponent(t)]}function setAtKeyPath(e,t,r){if(""===t)return r;if(!e||"object"!==_typeof(e))throw new TypeError("Unexpected non-object type");var n=t.indexOf(".");return n>-1?setAtKeyPath(e[unescapeKeyPathComponent(t.slice(0,n))],t.slice(n+1),r):(e[unescapeKeyPathComponent(t)]=r,e)}function getJSONType(e){return null===e?"null":Array.isArray(e)?"array":_typeof(e)}function _await(e,t,r){return r?t?t(e):e:(e&&e.then||(e=Promise.resolve(e)),t?e.then(t):e)}var n=Object.keys,o=Object.hasOwn,i=Array.isArray,a=["type","replaced","iterateIn","iterateUnsetNumeric","addLength"];function _async(e){return function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];try{return Promise.resolve(e.apply(this,t))}catch(e){return Promise.reject(e)}}}function nestedPathsFirst(e,t){var r,n;if(""===e.keypath)return-1;var o=null!==(r=e.keypath.match(/\./g))&&void 0!==r?r:0,i=null!==(n=t.keypath.match(/\./g))&&void 0!==n?n:0;return o&&(o=o.length),i&&(i=i.length),o>i?-1:o<i?1:e.keypath<t.keypath?-1:e.keypath>t.keypath?1:0}var c=function(){function Typeson(e){_classCallCheck(this,Typeson),this.options=e,this.plainObjectReplacers=[],this.nonplainObjectReplacers=[],this.revivers={},this.types={}}return _createClass(Typeson,[{key:"stringify",value:function stringify(e,t,r,n){n=_objectSpread2(_objectSpread2(_objectSpread2({},this.options),n),{},{stringification:!0});var o=this.encapsulate(e,null,n);return i(o)?JSON.stringify(o[0],t,r):o.then((function(e){return JSON.stringify(e,t,r)}))}},{key:"stringifySync",value:function stringifySync(e,t,r,n){return this.stringify(e,t,r,_objectSpread2(_objectSpread2({throwOnBadSyncType:!0},n),{},{sync:!0}))}},{key:"stringifyAsync",value:function stringifyAsync(e,t,r,n){return this.stringify(e,t,r,_objectSpread2(_objectSpread2({throwOnBadSyncType:!0},n),{},{sync:!1}))}},{key:"parse",value:function parse(e,t,r){return r=_objectSpread2(_objectSpread2(_objectSpread2({},this.options),r),{},{parse:!0}),this.revive(JSON.parse(e,t),r)}},{key:"parseSync",value:function parseSync(e,t,r){return this.parse(e,t,_objectSpread2(_objectSpread2({throwOnBadSyncType:!0},r),{},{sync:!0}))}},{key:"parseAsync",value:function parseAsync(e,t,r){return this.parse(e,t,_objectSpread2(_objectSpread2({throwOnBadSyncType:!0},r),{},{sync:!1}))}},{key:"specialTypeNames",value:function specialTypeNames(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return r.returnTypeNames=!0,this.encapsulate(e,t,r)}},{key:"rootTypeName",value:function rootTypeName(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return r.iterateNone=!0,this.encapsulate(e,t,r)}},{key:"encapsulate",value:function encapsulate(t,r,c){var s=this,u=_objectSpread2(_objectSpread2({sync:!0},this.options),c),l=u.sync,y={},p=[],f=[],v=[],h=!("cyclic"in u)||u.cyclic,d=u.encapsulateObserver,b=function finish(e){var t=Object.values(y);if(u.iterateNone)return t.length?t[0]:getJSONType(e);if(t.length){if(u.returnTypeNames)return _toConsumableArray(new Set(t));e&&isPlainObject(e)&&!o(e,"$types")?e.$types=y:e={$:e,$types:{$:y}}}else isObject(e)&&o(e,"$types")&&(e={$:e,$types:!0});return!u.returnTypeNames&&e},_=_async((function(t,r){return _await(Promise.all(r.map((function(e){return e[1].p}))),(function(n){return _await(Promise.all(n.map(_async((function(n){var o=!1,i=[],a=_slicedToArray(r.splice(0,1),1),c=_slicedToArray(a[0],7),s=c[0],u=c[2],l=c[3],y=c[4],p=c[5],f=c[6],v=m(s,n,u,l,i,!0,f),h=hasConstructorOf(v,e);return function _invoke(e,t){var r=e();return r&&r.then?r.then(t):t(r)}((function(){if(s&&h)return _await(v.p,(function(e){y[p]=e;var r=_(t,i);return o=!0,r}))}),(function(e){return o?e:(s?y[p]=v:t=h?v.p:v,_(t,i))}))})))),(function(){return t}))}))})),O=function _adaptBuiltinStateObjectProperties(e,t,r){Object.assign(e,t);var n=a.map((function(t){var r=e[t];return delete e[t],r}));r(),a.forEach((function(t,r){e[t]=n[r]}))},m=function _encapsulate(t,r,a,c,l,v,h){var b,_={},m=_typeof(r),g=d?function(n){var o,i=null!==(o=null!=h?h:c.type)&&void 0!==o?o:getJSONType(r);d(Object.assign(null!=n?n:_,{keypath:t,value:r,cyclic:a,stateObj:c,promisesData:l,resolvingTypesonPromise:v,awaitingTypesonPromise:hasConstructorOf(r,e)},{type:i}))}:null;if(["string","boolean","number","undefined"].includes(m))return void 0===r||Number.isNaN(r)||r===Number.NEGATIVE_INFINITY||r===Number.POSITIVE_INFINITY||0===r?(b=c.replaced?r:j(t,r,c,l,!1,v,g))!==r&&(_={replaced:b}):b=r,g&&g(),b;if(null===r)return g&&g(),r;if(a&&!c.iterateIn&&!c.iterateUnsetNumeric&&r&&"object"===_typeof(r)){var S=p.indexOf(r);if(!(S<0))return y[t]="#",g&&g({cyclicKeypath:f[S]}),"#"+f[S];!0===a&&(p.push(r),f.push(t))}var P,T,w=isPlainObject(r),A=i(r),C=(w||A)&&(!s.plainObjectReplacers.length||c.replaced)||c.iterateIn?r:j(t,r,c,l,w||A,null,g);if(C!==r?(b=C,_={replaced:C}):""===t&&hasConstructorOf(r,e)?(l.push([t,r,a,c,void 0,void 0,c.type]),b=r):A&&"object"!==c.iterateIn||"array"===c.iterateIn?(P=new Array(r.length),_={clone:P}):(["function","symbol"].includes(_typeof(r))||"toJSON"in r||hasConstructorOf(r,e)||hasConstructorOf(r,Promise)||hasConstructorOf(r,ArrayBuffer))&&!w&&"object"!==c.iterateIn?b=r:(P={},c.addLength&&(P.length=r.length),_={clone:P}),g&&g(),u.iterateNone)return null!==(T=P)&&void 0!==T?T:b;if(!P)return b;if(c.iterateIn){var k=function _loop(n){var i={ownKeys:o(r,n)};O(c,i,(function(){var o=t+(t?".":"")+escapeKeyPathComponent(n),i=_encapsulate(o,r[n],Boolean(a),c,l,v);hasConstructorOf(i,e)?l.push([o,i,Boolean(a),c,P,n,c.type]):void 0!==i&&(P[n]=i)}))};for(var N in r)k(N);g&&g({endIterateIn:!0,end:!0})}else n(r).forEach((function(n){var o=t+(t?".":"")+escapeKeyPathComponent(n);O(c,{ownKeys:!0},(function(){var t=_encapsulate(o,r[n],Boolean(a),c,l,v);hasConstructorOf(t,e)?l.push([o,t,Boolean(a),c,P,n,c.type]):void 0!==t&&(P[n]=t)}))})),g&&g({endIterateOwn:!0,end:!0});if(c.iterateUnsetNumeric){for(var I=r.length,E=function _loop2(n){if(!(n in r)){var o="".concat(t).concat(t?".":"").concat(n);O(c,{ownKeys:!1},(function(){var t=_encapsulate(o,void 0,Boolean(a),c,l,v);hasConstructorOf(t,e)?l.push([o,t,Boolean(a),c,P,n,c.type]):void 0!==t&&(P[n]=t)}))}},K=0;K<I;K++)E(K);g&&g({endIterateUnsetNumeric:!0,end:!0})}return P},j=function replace(e,t,r,n,o,i,a){for(var c=o?s.plainObjectReplacers:s.nonplainObjectReplacers,u=c.length;u--;){var p=c[u];if(p.test(t,r)){var f=p.type;if(s.revivers[f]){var v=y[e];y[e]=v?[f].concat(v):f}if(Object.assign(r,{type:f,replaced:!0}),(l||!p.replaceAsync)&&!p.replace)return a&&a({typeDetected:!0}),m(e,t,h&&"readonly",r,n,i,f);a&&a({replacing:!0});var d=void 0;if(l||!p.replaceAsync){if(void 0===p.replace)throw new TypeError("Missing replacer");d=p.replace(t,r)}else d=p.replaceAsync(t,r);return m(e,d,h&&"readonly",r,n,i,f)}}return t},g=m("",t,h,null!=r?r:{},v);if(v.length)return l&&u.throwOnBadSyncType?function(){throw new TypeError("Sync method requested but async result obtained")}():Promise.resolve(_(g,v)).then(b);if(!l&&u.throwOnBadSyncType)throw new TypeError("Async method requested but sync result obtained");return u.stringification&&l?[b(g)]:l?b(g):Promise.resolve(b(g))}},{key:"encapsulateSync",value:function encapsulateSync(e,t,r){return this.encapsulate(e,t,_objectSpread2(_objectSpread2({throwOnBadSyncType:!0},r),{},{sync:!0}))}},{key:"encapsulateAsync",value:function encapsulateAsync(e,t,r){return this.encapsulate(e,t,_objectSpread2(_objectSpread2({throwOnBadSyncType:!0},r),{},{sync:!1}))}},{key:"revive",value:function revive(t,r){var o=this,a=_objectSpread2(_objectSpread2({sync:!0},this.options),r),c=a.sync;function finishRevival(e){if(c)return e;if(a.throwOnBadSyncType)throw new TypeError("Async method requested but sync result obtained");return Promise.resolve(e)}if(!t||"object"!==_typeof(t)||Array.isArray(t))return finishRevival(t);var u=t.$types;if(!0===u)return finishRevival(t.$);if(!u||"object"!==_typeof(u)||Array.isArray(u))return finishRevival(t);var l=[],y={},p=!0;u.$&&isPlainObject(u.$)&&(t=t.$,u=u.$,p=!1);var f=function executeReviver(e,t){var r,n=_slicedToArray(null!==(r=o.revivers[e])&&void 0!==r?r:[],1)[0];if(!n)throw new Error("Unregistered type: "+e);if(c&&!("revive"in n))return t;if(!c&&n.reviveAsync)return n.reviveAsync(t,y);if(n.revive)return n.revive(t,y);throw new Error("Missing reviver")},v=[];function checkUndefined(e){return hasConstructorOf(e,s)?void 0:e}var h,d=function revivePlainObjects(){var r=[];if(!u)throw new Error("Found bad `types`");if(Object.entries(u).forEach((function(e){var t=_slicedToArray(e,2),n=t[0],i=t[1];"#"!==i&&[].concat(i).forEach((function(e){var t;_slicedToArray(null!==(t=o.revivers[e])&&void 0!==t?t:[null,{}],2)[1].plain&&(r.push({keypath:n,type:e}),delete u[n])}))})),r.length)return r.sort(nestedPathsFirst).reduce((function reducer(r,n){var o=n.keypath,i=n.type;if(isThenable(r))return r.then((function(e){return reducer(e,{keypath:o,type:i})}));var a=getByKeyPath(t,o);if(hasConstructorOf(a=f(i,a),e))return a.then((function(e){var r=setAtKeyPath(t,o,e);r===e&&(t=r)}));var c=setAtKeyPath(t,o,a);c===a&&(t=c)}),void 0)}();return hasConstructorOf(d,e)?h=d.then((function(){return t})):(h=function _revive(t,r,o,a,c){if(!p||"$types"!==t){var y=u[t],h=i(r);if(h||isPlainObject(r)){var d=h?new Array(r.length):{};for(n(r).forEach((function(n){var i=_revive(t+(t?".":"")+escapeKeyPathComponent(n),r[n],null!=o?o:d,d,n),a=function set(e){return hasConstructorOf(e,s)?d[n]=void 0:void 0!==e&&(d[n]=e),e};hasConstructorOf(i,e)?v.push(i.then((function(e){return a(e)}))):a(i)})),r=d;l.length;){var b=_slicedToArray(l[0],4),_=b[0],O=b[1],m=b[2],j=b[3],g=getByKeyPath(_,O);if(void 0===g)break;m[j]=g,l.splice(0,1)}}if(!y)return r;if("#"===y){var S=getByKeyPath(o,r.slice(1));return void 0===S&&l.push([o,r.slice(1),a,c]),S}return[].concat(y).reduce((function reducer(t,r){if(hasConstructorOf(t,e))return t.then((function(e){return reducer(e,r)}));if("string"!=typeof r)throw new TypeError("Bad type JSON");return f(r,t)}),r)}}("",t,null),v.length&&(h=e.resolve(h).then((function(t){return e.all([t].concat(v))})).then((function(e){return _slicedToArray(e,1)[0]})))),isThenable(h)?c&&a.throwOnBadSyncType?function(){throw new TypeError("Sync method requested but async result obtained")}():hasConstructorOf(h,e)?h.p.then(checkUndefined):h:!c&&a.throwOnBadSyncType?function(){throw new TypeError("Async method requested but sync result obtained")}():c?checkUndefined(h):Promise.resolve(checkUndefined(h))}},{key:"reviveSync",value:function reviveSync(e,t){return this.revive(e,_objectSpread2(_objectSpread2({throwOnBadSyncType:!0},t),{},{sync:!0}))}},{key:"reviveAsync",value:function reviveAsync(e,t){return this.revive(e,_objectSpread2(_objectSpread2({throwOnBadSyncType:!0},t),{},{sync:!1}))}},{key:"register",value:function register(e,t){var r=this,o=null!=t?t:{},a=function R(e){i(e)?e.forEach((function(e){return R(e)})):n(e).forEach((function(t){var n;if("#"===t)throw new TypeError("# cannot be used as a type name as it is reserved for cyclic objects");if(u.includes(t))throw new TypeError("Plain JSON object types are reserved as type names");var a=e[t],c=a&&"function"!=typeof a&&!Array.isArray(a)&&a.testPlainObjects?r.plainObjectReplacers:r.nonplainObjectReplacers,s=c.filter((function(e){return e.type===t}));if(s.length&&(c.splice(c.indexOf(s[0]),1),delete r.revivers[t],delete r.types[t]),"function"==typeof a){var l=a;a={test:function test(e){return e&&e.constructor===l},replace:function replace(e){return _objectSpread2({},e)},revive:function revive(e){return Object.assign(Object.create(l.prototype),e)}}}else if(i(a)){var y=_slicedToArray(a,3);a={test:y[0],replace:y[1],revive:y[2]}}if(null!==(n=a)&&void 0!==n&&n.test){var p={type:t,test:a.test.bind(a)};a.replace&&(p.replace=a.replace.bind(a)),a.replaceAsync&&(p.replaceAsync=a.replaceAsync.bind(a));var f="number"==typeof o.fallback?o.fallback:o.fallback?0:Number.POSITIVE_INFINITY;if(a.testPlainObjects?r.plainObjectReplacers.splice(f,0,p):r.nonplainObjectReplacers.splice(f,0,p),a.revive||a.reviveAsync){var v={};a.revive&&(v.revive=a.revive.bind(a)),a.reviveAsync&&(v.reviveAsync=a.reviveAsync.bind(a)),r.revivers[t]=[v,{plain:a.testPlainObjects}]}r.types[t]=a}}))};return[].concat(e).forEach((function(e){return a(e)})),this}}]),Typeson}(),s=_createClass((function Undefined(){_classCallCheck(this,Undefined)}));s.__typeson__type__="TypesonUndefined";var u=["null","boolean","number","string","array","object"];

// EXTERNAL MODULE: ./node_modules/.pnpm/ts-results-es@4.0.0/node_modules/ts-results-es/dist/esm/index.js
var esm = __webpack_require__(76089);
// EXTERNAL MODULE: ./node_modules/.pnpm/bignumber.js@9.1.2/node_modules/bignumber.js/bignumber.mjs
var bignumber = __webpack_require__(10149);
// EXTERNAL MODULE: ./packages/encryption/src/encryption/DecryptionTypes.ts
var DecryptionTypes = __webpack_require__(34625);
// EXTERNAL MODULE: ./packages/encryption/src/encryption/EncryptionTypes.ts
var EncryptionTypes = __webpack_require__(63966);
// EXTERNAL MODULE: ./node_modules/.pnpm/typeson-registry@8.0.0/node_modules/typeson-registry/dist/index.min.js
var index_min = __webpack_require__(99300);
// EXTERNAL MODULE: ./packages/base/src/Identifier/base.ts
var base = __webpack_require__(12247);
;// CONCATENATED MODULE: ./packages/shared-base/src/serializer/response.ts

const is = (x)=>x instanceof Response;
const serializer = (x)=>{
    return new e(async (resolve)=>{
        const bodyBlob = await x.blob();
        resolve({
            body: bodyBlob,
            init: {
                status: x.status,
                statusText: x.statusText,
                headers: x.headers
            }
        });
    });
};
const deserializer = (x)=>{
    return new Response(x.body, x.init);
};
const responseRegedit = [
    is,
    serializer,
    deserializer
];

;// CONCATENATED MODULE: ./packages/shared-base/src/serializer/request.ts
const request_is = (x)=>x instanceof Request;
const request_serializer = (x)=>{
    const { url, method, body, headers, mode, credentials, cache, redirect, referrer, integrity } = x;
    return {
        input: url,
        init: {
            method,
            // body maybe is a Blob, a BufferSource, a FormData, a URLSearchParams, a string, or a ReadableStream object, should handle different object type later
            body,
            headers,
            mode,
            credentials,
            cache,
            redirect,
            referrer,
            integrity
        }
    };
};
const request_deserializer = (x)=>{
    return new Request(x.input, x.init);
};
const requestRegedit = [
    request_is,
    request_serializer,
    request_deserializer
];

;// CONCATENATED MODULE: ./packages/shared-base/src/serializer/index.ts








const pendingRegister = new Set();
let typeson;
function setup() {
    const { default: BigNumber } = bignumber;
    // https://github.com/dfahlander/typeson-registry/issues/27
    typeson = new c({
        cyclic: false,
        sync: false
    });
    typeson.register(index_min/* builtin */.j0);
    typeson.register(index_min/* specialNumbers */.so);
    typeson.register([
        index_min/* blob */.Ik,
        index_min/* file */.tP,
        index_min/* filelist */.Jj,
        index_min/* imagebitmap */.xA
    ]);
    typeson.register({
        None: [
            (x)=>x === esm.None,
            ()=>'None',
            ()=>esm.None
        ]
    });
    addClass('Ok', esm.Ok);
    addClass('Err', esm.Err);
    addClass('Some', esm.Some);
    addClass('BigNumber', BigNumber);
    registerSerializableClass('MaskDecryptError', (x)=>x instanceof DecryptionTypes/* DecryptError */.G6, (e)=>({
            cause: e.cause,
            recoverable: e.recoverable,
            message: e.message,
            stack: e.stack
        }), (o)=>{
        const e = new DecryptionTypes/* DecryptError */.G6(o.message, o.cause, o.recoverable);
        e.stack = o.stack;
        return e;
    });
    registerSerializableClass('MaskEncryptError', (x)=>x instanceof EncryptionTypes/* EncryptError */.x, (e)=>({
            cause: e.cause,
            message: e.message,
            stack: e.stack
        }), (o)=>{
        const e = new EncryptionTypes/* EncryptError */.x(o.message, o.cause);
        e.stack = o.stack;
        return e;
    });
    typeson.register({
        Identifier: [
            (x)=>x instanceof base/* Identifier */.x,
            (x)=>x.toText(),
            (x)=>base/* Identifier */.x.from(x).expect(`${x} should be a Identifier`)
        ],
        Response: [
            ...responseRegedit
        ],
        Request: [
            ...requestRegedit
        ]
    });
    for (const a of pendingRegister)a();
}
const serializer_serializer = {
    async serialization (from) {
        if (!typeson) setup();
        return typeson.encapsulate(from);
    },
    // cspell:disable-next-line
    deserialization (to) {
        if (!typeson) setup();
        return typeson.revive(to);
    }
};
function registerSerializableClass(name, a, b, c) {
    if (typeson) {
        if (b) typeson.register({
            [name]: [
                a,
                b,
                c
            ]
        });
        else addClass(name, a);
    } else {
        if (b) pendingRegister.add(()=>typeson.register({
                [name]: [
                    a,
                    b,
                    c
                ]
            }));
        else pendingRegister.add(()=>addClass(name, a));
    }
}
function addClass(name, constructor) {
    Object.defineProperty(constructor, 'name', {
        configurable: true,
        enumerable: false,
        writable: false,
        value: name
    });
    typeson.register({
        [name]: [
            (x)=>x instanceof constructor,
            (x)=>{
                return new e((resolve)=>{
                    const cloned = Object.assign({}, x);
                    Object.getOwnPropertySymbols(cloned).forEach((x)=>Reflect.deleteProperty(cloned, x));
                    Promise.resolve(typeson.encapsulate(cloned)).then(resolve);
                });
            },
            (x)=>{
                return new e((resolve)=>{
                    Promise.resolve(typeson.revive(x)).then((data)=>{
                        Object.setPrototypeOf(data, constructor.prototype);
                        resolve(data);
                    });
                });
            }
        ]
    });
}


/***/ }),

/***/ 60541:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ SignType)
/* harmony export */ });
var SignType;
(function(SignType) {
    SignType["Message"] = 'message';
    SignType["TypedData"] = 'typedData';
    SignType["Transaction"] = 'transaction';
})(SignType || (SignType = {}));


/***/ }),

/***/ 89087:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   h: () => (/* binding */ Days)
/* harmony export */ });
var Days;
(function(Days) {
    Days[Days["MAX"] = 0] = "MAX";
    Days[Days["ONE_DAY"] = 1] = "ONE_DAY";
    Days[Days["ONE_WEEK"] = 7] = "ONE_WEEK";
    Days[Days["ONE_MONTH"] = 30] = "ONE_MONTH";
    Days[Days["THREE_MONTHS"] = 90] = "THREE_MONTHS";
    Days[Days["ONE_YEAR"] = 365] = "ONE_YEAR";
})(Days || (Days = {}));


/***/ }),

/***/ 91461:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   S: () => (/* binding */ NameServiceID)
/* harmony export */ });
var /**
 * All integrated name service IDs
 */ NameServiceID;
(function(NameServiceID) {
    NameServiceID["ARBID"] = "ARBID";
    NameServiceID["ENS"] = "ENS";
    NameServiceID["Lens"] = "Lens";
    NameServiceID["SpaceID"] = "SpaceID";
    NameServiceID["Flowns"] = "Flowns";
    NameServiceID["Bonfida"] = "Bonfida";
    NameServiceID["SOL"] = "SOL";
})(NameServiceID || (NameServiceID = {}));


/***/ }),

/***/ 24835:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   F: () => (/* binding */ NetworkPluginID),
/* harmony export */   P: () => (/* binding */ PluginID)
/* harmony export */ });
var /**
 * All integrated network Plugin IDs
 */ NetworkPluginID;
(function(NetworkPluginID) {
    NetworkPluginID["PLUGIN_EVM"] = 'com.mask.evm';
    NetworkPluginID["PLUGIN_FLOW"] = 'com.mask.flow';
    NetworkPluginID["PLUGIN_SOLANA"] = 'com.mask.solana';
})(NetworkPluginID || (NetworkPluginID = {}));
var /**
 * All integrated Plugin IDs
 */ PluginID;
(function(PluginID) {
    PluginID["EVM"] = 'com.mask.evm';
    PluginID["Flow"] = 'com.mask.flow';
    PluginID["Solana"] = 'com.mask.solana';
    PluginID["Approval"] = 'com.maskbook.approval';
    PluginID["Avatar"] = 'com.maskbook.avatar';
    PluginID["ArtBlocks"] = 'io.artblocks';
    PluginID["Collectible"] = 'com.maskbook.collectibles';
    PluginID["Handle"] = 'com.maskbook.handle';
    PluginID["NextID"] = 'com.mask.next_id';
    PluginID["Gitcoin"] = 'co.gitcoin';
    PluginID["MaskBox"] = 'com.maskbook.box';
    PluginID["Trader"] = 'com.maskbook.trader';
    PluginID["Tips"] = 'com.maskbook.tip';
    PluginID["Transak"] = 'com.maskbook.transak';
    PluginID["Valuables"] = 'com.maskbook.tweet';
    PluginID["Debugger"] = 'io.mask.debugger';
    PluginID["Template"] = 'io.mask.template';
    PluginID["Testplugin4"] = 'io.mask.testplugin4';
    PluginID["RSS3"] = 'bio.rss3';
    PluginID["RedPacket"] = 'com.maskbook.red_packet';
    PluginID["Pets"] = 'com.maskbook.pets';
    PluginID["Snapshot"] = 'org.snapshot';
    PluginID["Savings"] = 'com.savings';
    PluginID["Wallet"] = 'com.maskbook.wallet';
    PluginID["FileService"] = 'com.maskbook.fileservice';
    PluginID["CyberConnect"] = 'me.cyberconnect.app';
    PluginID["Beholder"] = 'io.beholder.app';
    PluginID["GoPlusSecurity"] = 'io.gopluslabs.security';
    PluginID["CrossChainBridge"] = 'io.mask.cross-chain-bridge';
    PluginID["Web3Profile"] = 'io.mask.web3-profile';
    PluginID["Web3ProfileCard"] = 'io.mask.web3-profile-card';
    PluginID["ScamSniffer"] = 'io.scamsniffer.mask-plugin';
    PluginID["ScamWarning"] = 'com.mask.scam-warning';
    PluginID["SmartPay"] = 'com.mask.smart-pay';
    PluginID["Claim"] = 'com.mask.claim';
    PluginID["WalletService"] = 'com.mask.WalletService';
    PluginID["SwitchLogo"] = 'io.mask.switch-logo';
    PluginID["Calendar"] = 'io.mask.calendar';
})(PluginID || (PluginID = {}));


/***/ }),

/***/ 45569:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   b: () => (/* binding */ SocialAddressType)
/* harmony export */ });
var SocialAddressType/** The identifier of the social account */ /** The avatar image link of the social account */ /** The bio content of the social account */ /** The nickname of the social account */ /** The homepage link of the social account */ /** Has a NextID binding or not */ /** The public key of persona in hex */ /** Is own user account identity */ /** All bindings of the persona  **/ /**
 * The smallest unit of a social account. This type only for internal usage.
 * The SocialAccount serves for UI usage.
 */ /** The ID of a plugin that the address belongs to */ /** The chain id that the address belongs to, default support all chains */ /** The data source type */ /** The address in hex string */ /** A human readable address title */ /** Last updated timestamp (unix timestamp) */ /** Create timestamp (unix timestamp) */ /** Data from official sources indicate validation, e.g. twitter blue  */ /**
 * The social account that merged from multiple social addresses.
 * This type only for UI usage.
 */ /** The chain ids that the address supported, default support all chains */ ;
(function(SocialAddressType) {
    SocialAddressType["Address"] = "Address";
    SocialAddressType["ENS"] = "ENS";
    SocialAddressType["ARBID"] = "ARBID";
    SocialAddressType["SPACE_ID"] = "SPACE_ID";
    SocialAddressType["RSS3"] = "RSS3";
    SocialAddressType["SOL"] = "SOL";
    SocialAddressType["NEXT_ID"] = "NEXT_ID";
    SocialAddressType["CyberConnect"] = "CyberConnect";
    SocialAddressType["Firefly"] = "Firefly";
    SocialAddressType["Leaderboard"] = '.eth Leaderboard';
    SocialAddressType["OpenSea"] = "OpenSea";
    SocialAddressType["Sybil"] = "Sybil";
    SocialAddressType["TwitterBlue"] = "TwitterBlue";
    SocialAddressType["Mask"] = 'Mask Network';
    SocialAddressType["Lens"] = "Lens";
    SocialAddressType["Crossbell"] = "Crossbell";
})(SocialAddressType || (SocialAddressType = {}));


/***/ }),

/***/ 58190:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   O: () => (/* binding */ LockStatus),
/* harmony export */   Q: () => (/* binding */ ImportSource)
/* harmony export */ });
var LockStatus;
(function(LockStatus) {
    LockStatus[LockStatus["INIT"] = 0] = "INIT";
    LockStatus[LockStatus["UNLOCK"] = 1] = "UNLOCK";
    LockStatus[LockStatus["LOCKED"] = 2] = "LOCKED";
})(LockStatus || (LockStatus = {}));
var ImportSource/** the user define wallet name. Default address.prefix(6) */ /** the address of wallet */ /** the wallet source */ /** true: Mask Wallet, false: External Wallet */ /** true: Derivable Wallet. false: UnDerivable Wallet */ /** yep: removable, nope: unremovable */ /** the derivation path when wallet was created */ /** the derivation path when wallet last was derived */ /** the internal presentation of mask wallet sdk */ /** record created at */ /** record updated at */ /** an abstract wallet has a owner */ /** an abstract wallet has been deployed */ /** persona identifier */ /**
     * mnemonicId represents a wallet under the same set of mnemonics,
     * used for wallet grouping
     */ /** ethereum hex address */ /** User define wallet name. Default address.prefix(6) */ /** A list of trusted ERC20 contract address */ /** A list of untrusted ERC20 contract address */ /** A list of trusted ERC721 contract address */ /** A list of untrusted ERC721 contract address */ /** A list of trusted ERC1155 contract address */ /** A list of untrusted ERC1155 contract address */ /** The HD wallet path includes address index */ /** Wallet recover from private key */ ;
(function(ImportSource) {
    ImportSource["WalletRPC"] = 'wallet_rpc';
    ImportSource["LocalGenerated"] = 'local_generated';
    ImportSource["UserProvided"] = 'user_provided';
})(ImportSource || (ImportSource = {}));


/***/ }),

/***/ 92524:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   R: () => (/* binding */ ARBID)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(24770);
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(91461);
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(92358);
/* harmony import */ var _SID_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(86440);




class ARBID_API {
    id = _masknet_shared_base__WEBPACK_IMPORTED_MODULE_0__/* .NameServiceID */ .S.ARBID;
    async lookup(name) {
        return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_1__/* .attemptUntil */ .C)([
            _SID_index_js__WEBPACK_IMPORTED_MODULE_2__/* .SID_Domain */ .t
        ].map((x)=>()=>x.lookup(_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_3__/* .ChainId */ .a_.Arbitrum, name)), undefined);
    }
    async reverse(address) {
        return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_1__/* .attemptUntil */ .C)([
            _SID_index_js__WEBPACK_IMPORTED_MODULE_2__/* .SID_Domain */ .t
        ].map((x)=>()=>x.reverse(_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_3__/* .ChainId */ .a_.Arbitrum, address)), undefined);
    }
}
const ARBID = new ARBID_API();


/***/ }),

/***/ 19906:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   H: () => (/* binding */ AirdropAPI)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33026);
/* harmony import */ var _Web3_EVM_apis_ContractReadonlyAPI_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61871);
/* harmony import */ var _helpers_fetchJSON_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11834);



class AirdropAPI {
    Contract = new _Web3_EVM_apis_ContractReadonlyAPI_js__WEBPACK_IMPORTED_MODULE_0__/* .ContractReadonlyAPI */ .M();
    async getActivity(chainId, address) {
        const { CLAIMERS, CONTRACT_ADDRESS } = (0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .getAirdropClaimersConstants */ .Ox)(chainId);
        if (!CLAIMERS || !CONTRACT_ADDRESS) return;
        const airdropContract = this.Contract.getAirdropV2Contract(CONTRACT_ADDRESS, {
            chainId
        });
        const data = await (0,_helpers_fetchJSON_js__WEBPACK_IMPORTED_MODULE_2__/* .fetchJSON */ .ZV)(`https://cors-next.r2d2.to/?${CLAIMERS}`, {
            headers: {
                'Content-Type': 'application/json'
            }
        });
        const eventIndex = await airdropContract?.methods.eventIndex().call();
        const currentEventIndex = Number(eventIndex) - 1;
        const claimEvents = await airdropContract?.methods.claimEvents(currentEventIndex).call();
        const isClaimed = address ? await airdropContract?.methods.isClaimed(currentEventIndex, address).call() : false;
        if (!claimEvents) return;
        return {
            claimers: data,
            startTime: claimEvents.startTime,
            endTime: claimEvents.endTime,
            token: claimEvents.token,
            isClaimed,
            eventIndex: currentEventIndex
        };
    }
    async getPoolInfo(chainId, eventIndex) {
        const { CONTRACT_ADDRESS } = (0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .getAirdropClaimersConstants */ .Ox)(chainId);
        if (!CONTRACT_ADDRESS) return;
        const airdropContract = this.Contract.getAirdropV2Contract(CONTRACT_ADDRESS, {
            chainId
        });
        return airdropContract?.methods.claimEvents(eventIndex).call();
    }
}


/***/ }),

/***/ 37803:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ih: () => (/* binding */ Alchemy_FLOW_NetworkMap),
/* harmony export */   mp: () => (/* binding */ Alchemy_EVM_NetworkMap),
/* harmony export */   x_: () => (/* binding */ FILTER_WORDS)
/* harmony export */ });
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24835);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24770);
/* harmony import */ var _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(59190);



const Alchemy_EVM_NetworkMap = {
    network: _masknet_shared_base__WEBPACK_IMPORTED_MODULE_0__/* .NetworkPluginID */ .F.PLUGIN_EVM,
    chains: [
        {
            chainId: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet,
            baseURL: 'https://alchemy-proxy.r2d2.to/eth-mainnet-io/v2/APIKEY',
            contractMetadataURL: 'https://alchemy-proxy.r2d2.to/eth-mainnet/nft/v2/APIKEY',
            tokenOwnerURL: 'https://alchemy-proxy.r2d2.to/eth-mainnet/nft/v2/APIKEY'
        },
        {
            chainId: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Matic,
            baseURL: 'https://alchemy-proxy.r2d2.to/polygon-mainnet/v2/APIKEY',
            contractMetadataURL: 'https://alchemy-proxy.r2d2.to/polygon-mainnet/nft/v2/APIKEY',
            tokenOwnerURL: 'https://alchemy-proxy.r2d2.to/polygon-mainnet/nft/v2/APIKEY'
        }
    ]
};
const Alchemy_FLOW_NetworkMap = {
    network: _masknet_shared_base__WEBPACK_IMPORTED_MODULE_0__/* .NetworkPluginID */ .F.PLUGIN_FLOW,
    chains: [
        {
            chainId: _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_2__/* .ChainId */ .a_.Mainnet,
            baseURL: 'https://alchemy-proxy.r2d2.to/flow-mainnet/v2/APIKEY'
        }
    ]
};
const FILTER_WORDS = [
    'description',
    'id',
    'title',
    'number',
    'img',
    'uri'
];


/***/ }),

/***/ 72642:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ formatAlchemyTokenAddress),
/* harmony export */   d: () => (/* binding */ formatAlchemyTokenId)
/* harmony export */ });
/* harmony import */ var web3_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(84976);
/* harmony import */ var web3_utils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(web3_utils__WEBPACK_IMPORTED_MODULE_0__);

function formatAlchemyTokenId(tokenId) {
    return (0,web3_utils__WEBPACK_IMPORTED_MODULE_0__.isHex)(tokenId) && tokenId.startsWith('0x') ? (0,web3_utils__WEBPACK_IMPORTED_MODULE_0__.hexToNumberString)(tokenId) : tokenId;
}
function formatAlchemyTokenAddress(address, identifier) {
    return `A.${address.replace(/^0x/, '')}.${identifier}`;
}


/***/ }),

/***/ 39874:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  s: () => (/* binding */ ApprovalAPI)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/bignumber.js@9.1.2/node_modules/bignumber.js/bignumber.mjs
var bignumber = __webpack_require__(10149);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/mapKeys.js
var mapKeys = __webpack_require__(37350);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/maxBy.js
var maxBy = __webpack_require__(88393);
// EXTERNAL MODULE: ./packages/shared-base/src/constants.ts
var constants = __webpack_require__(52033);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/address.ts
var address = __webpack_require__(65327);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/abiCoder.ts
var abiCoder = __webpack_require__(1853);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Approval/constants.ts
const TOKEN_APPROVAL_TOPIC = '0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925';
const NFT_APPROVAL_TOPIC = '0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31';

// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/isSameAddress.ts
var isSameAddress = __webpack_require__(74765);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/number.ts
var number = __webpack_require__(29763);
// EXTERNAL MODULE: ./node_modules/.pnpm/immer@10.0.2/node_modules/immer/dist/immer.mjs
var immer = __webpack_require__(35268);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Approval/approvalListState.ts

class ApprovalListState {
    _token_state = {};
    _nft_state = {};
    constructor(){
        (0,immer/* enableMapSet */.MD)();
    }
    get tokenState() {
        return this._token_state;
    }
    get nftState() {
        return this._nft_state;
    }
    updateTokenState(account_, spender_, address_, chainId, fromBlock, transactionBlockNumber, amount) {
        const account = account_.toLowerCase();
        const spender = spender_.toLowerCase();
        const address = address_.toLowerCase();
        this._token_state = (0,immer/* produce */.Uy)(this._token_state, (draft)=>{
            if (!draft[account]) draft[account] = new Map();
            const addressMap = new Map();
            addressMap.set(address, {
                amount,
                transactionBlockNumber
            });
            if (!draft[account].get(chainId)?.spenderList) {
                const spenderListMap = new Map();
                spenderListMap.set(spender, addressMap);
                draft[account].set(chainId, {
                    spenderList: spenderListMap,
                    fromBlock
                });
            }
            if (!draft[account].get(chainId).spenderList.get(spender)) {
                draft[account].get(chainId).spenderList.set(spender, addressMap);
            }
            draft[account].get(chainId).spenderList.get(spender)?.set(address, {
                amount,
                transactionBlockNumber
            });
            draft[account].get(chainId).fromBlock = fromBlock;
        });
    }
    updateNFT_State(account_, spender_, address_, chainId, fromBlock, transactionBlockNumber, approved) {
        const account = account_.toLowerCase();
        const spender = spender_.toLowerCase();
        const address = address_.toLowerCase();
        this._nft_state = (0,immer/* produce */.Uy)(this._nft_state, (draft)=>{
            if (!draft[account]) draft[account] = new Map();
            const addressMap = new Map();
            addressMap.set(address, {
                approved,
                transactionBlockNumber
            });
            if (!draft[account].get(chainId)?.spenderList) {
                const spenderListMap = new Map();
                spenderListMap.set(spender, addressMap);
                draft[account].set(chainId, {
                    spenderList: spenderListMap,
                    fromBlock
                });
            }
            if (!draft[account].get(chainId).spenderList.get(spender)) {
                draft[account].get(chainId).spenderList.set(spender, addressMap);
            }
            draft[account].get(chainId).spenderList.get(spender)?.set(address, {
                approved,
                transactionBlockNumber
            });
            draft[account].get(chainId).fromBlock = fromBlock;
        });
    }
}
const approvalListState = new ApprovalListState();

// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/ConnectionReadonlyAPI.ts + 2 modules
var ConnectionReadonlyAPI = __webpack_require__(3543);
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/getAllMaskDappContractInfo.tsx
var getAllMaskDappContractInfo = __webpack_require__(85944);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Approval/index.ts









class ApprovalAPI {
    Web3 = new ConnectionReadonlyAPI/* ConnectionReadonlyAPI */.S();
    async getFungibleTokenSpenders(chainId, account) {
        try {
            const { toBlock, records: tokenSpenderRecords } = await this.parseSpenderRecords(chainId, account, TOKEN_APPROVAL_TOPIC, approvalListState.tokenState);
            const maskDappContractInfoList = (0,getAllMaskDappContractInfo/* getAllMaskDappContractInfo */.i)(chainId, 'token');
            (0,mapKeys/* default */.Z)(tokenSpenderRecords, (spender, spenderAddress)=>(0,mapKeys/* default */.Z)(spender, (tokens, tokenAddress)=>{
                    const latestBlockTx = (0,maxBy/* default */.Z)(tokens, (x)=>x.blockNumber);
                    const latestTx = (0,maxBy/* default */.Z)(tokens.filter((x)=>x.blockNumber === latestBlockTx?.blockNumber), (x)=>x.transactionIndex);
                    if (!latestTx) return;
                    const amount = new bignumber/* BigNumber */.O((0,address/* isZeroAddress */.uO)(latestTx.data) ? 0 : latestTx.data);
                    approvalListState.updateTokenState(account, spenderAddress, tokenAddress, chainId, toBlock, latestTx.blockNumber, amount);
                }));
            const spenderList = approvalListState.tokenState[account.toLowerCase()]?.get(chainId)?.spenderList;
            if (!spenderList) return constants/* EMPTY_LIST */.rP;
            return Array.from(spenderList.keys()).flatMap((spender)=>{
                return Array.from(spenderList.get(spender).keys()).map((address)=>{
                    const maskDappContractInfo = maskDappContractInfoList.find((y)=>(0,isSameAddress/* isSameAddress */.W)(y.address, spender));
                    return {
                        tokenInfo: {
                            address,
                            name: '',
                            symbol: ''
                        },
                        address: spender,
                        name: maskDappContractInfo?.name,
                        logo: maskDappContractInfo?.logo,
                        rawAmount: spenderList.get(spender)?.get(address)?.amount.toNumber() ?? 0,
                        transactionBlockNumber: spenderList.get(spender)?.get(address)?.transactionBlockNumber ?? 0,
                        isMaskDapp: Boolean(maskDappContractInfo)
                    };
                });
            }).filter((x)=>(0,number/* isGreaterThan */.T1)(x.rawAmount, 0)).sort((a, b)=>{
                if (a.isMaskDapp && !b.isMaskDapp) return -1;
                if (!a.isMaskDapp && b.isMaskDapp) return 1;
                return b.transactionBlockNumber - a.transactionBlockNumber;
            });
        } catch (error) {
            return constants/* EMPTY_LIST */.rP;
        }
    }
    async getNonFungibleTokenSpenders(chainId, account) {
        try {
            const { toBlock, records: nftSpenderRecords } = await this.parseSpenderRecords(chainId, account, NFT_APPROVAL_TOPIC, approvalListState.nftState);
            const maskDappContractInfoList = (0,getAllMaskDappContractInfo/* getAllMaskDappContractInfo */.i)(chainId, 'nft');
            (0,mapKeys/* default */.Z)(nftSpenderRecords, (spender, spenderAddress)=>(0,mapKeys/* default */.Z)(spender, (nfts, tokenAddress)=>{
                    const latestBlockTx = (0,maxBy/* default */.Z)(nfts, (x)=>x.blockNumber);
                    const latestTx = (0,maxBy/* default */.Z)(nfts.filter((x)=>x.blockNumber === latestBlockTx?.blockNumber), (x)=>x.transactionIndex);
                    if (!latestTx) return;
                    const approved = Number.parseInt(latestTx.data, 16) === 1;
                    approvalListState.updateNFT_State(account, spenderAddress, tokenAddress, chainId, toBlock, latestTx.blockNumber, approved);
                }));
            const spenderList = approvalListState.nftState[account.toLowerCase()]?.get(chainId)?.spenderList;
            if (!spenderList) return constants/* EMPTY_LIST */.rP;
            return Array.from(spenderList.keys()).flatMap((spender)=>{
                return Array.from(spenderList.get(spender).keys()).map((address)=>{
                    const maskDappContractInfo = maskDappContractInfoList.find((y)=>(0,isSameAddress/* isSameAddress */.W)(y.address, spender));
                    return {
                        contract: {
                            address,
                            name: ''
                        },
                        address: spender,
                        name: maskDappContractInfo?.name,
                        logo: maskDappContractInfo?.logo,
                        amount: '1',
                        approved: spenderList.get(spender)?.get(address)?.approved,
                        transactionBlockNumber: spenderList.get(spender)?.get(address)?.transactionBlockNumber ?? 0,
                        isMaskDapp: Boolean(maskDappContractInfo)
                    };
                });
            }).filter((x)=>x.approved).sort((a, b)=>{
                if (a.isMaskDapp && !b.isMaskDapp) return -1;
                if (!a.isMaskDapp && b.isMaskDapp) return 1;
                return b.transactionBlockNumber - a.transactionBlockNumber;
            });
        } catch (error) {
            return constants/* EMPTY_LIST */.rP;
        }
    }
    async parseSpenderRecords(chainId, account, topic, state) {
        const fromBlock = state[account]?.get(chainId)?.fromBlock ?? 0;
        const toBlock = await this.Web3.getBlockNumber({
            chainId
        });
        const logs = await this.Web3.getWeb3({
            chainId
        }).eth.getPastLogs({
            topics: [
                topic,
                abiCoder/* abiCoder */.r.encodeParameter('address', account)
            ],
            fromBlock,
            toBlock
        });
        return {
            records: parseLogs(logs),
            toBlock
        };
    }
}
function parseLogs(logs) {
    return logs.filter((x)=>x.topics.length === 3 && x.data !== '0x').reduce((acc, cur)=>{
        const spender = abiCoder/* abiCoder */.r.decodeParameter('address', cur.topics[2]);
        if ((0,address/* isZeroAddress */.uO)(spender)) return acc;
        if (!acc[spender]) acc[spender] = {};
        if (acc[spender][cur.address]) {
            acc[spender][cur.address].push({
                blockNumber: cur.blockNumber,
                data: cur.data,
                transactionIndex: cur.transactionIndex
            });
        } else {
            acc[spender][cur.address] = [
                {
                    blockNumber: cur.blockNumber,
                    data: cur.data,
                    transactionIndex: cur.transactionIndex
                }
            ];
        }
        return acc;
    }, {});
}


/***/ }),

/***/ 30685:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   n: () => (/* binding */ ChainbaseDomain)
/* harmony export */ });
/* harmony import */ var urlcat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78757);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(81755);
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(74765);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24770);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37049);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(89019);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(65327);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(41487);
/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58021);





const suffixMap = {
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet]: 'eth',
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.BSC]: 'bnb',
    [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Arbitrum]: 'arb'
};
class ChainbaseDomainAPI {
    async getAddress(chainId, name) {
        if (!(0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .isValidChainId */ .J)(chainId)) return;
        const response = await (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__/* .fetchFromChainbase */ .Dc)((0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(`/v1/${chainId !== _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.BSC ? 'ens' : 'space-id'}/records`, {
            chain_id: chainId,
            domain: name
        }));
        return response?.address;
    }
    async getName(chainId, address) {
        if (!(0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .isValidChainId */ .J)(chainId)) return;
        const response = await (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__/* .fetchFromChainbase */ .Dc)((0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(`/v1/${chainId !== _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.BSC ? 'ens' : 'space-id'}/reverse`, {
            chain_id: chainId,
            address
        }));
        if (!(0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_4__/* .isSameAddress */ .W)(response?.[0]?.address, address)) return;
        const name = (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(response)?.name;
        if (!name) return;
        const suffix = suffixMap[chainId] || 'eth';
        return (0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__/* .isValidDomain */ .h)(name) ? name : (0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__/* .isValidDomain */ .h)(`${name}.${suffix}`) ? `${name}.${suffix}` : undefined;
    }
    async lookup(chainId, name) {
        if (!name) return;
        const address = await this.getAddress(chainId, name);
        if ((0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__/* .isValidAddress */ .At)(address)) return (0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_8__/* .formatEthereumAddress */ .j8)(address);
        return;
    }
    async reverse(chainId, address) {
        if (!address || !(0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__/* .isValidAddress */ .At)(address)) return;
        const name = await this.getName(chainId, address);
        if ((0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__/* .isValidDomain */ .h)(name)) return name;
        return;
    }
}
const ChainbaseDomain = new ChainbaseDomainAPI();


/***/ }),

/***/ 60174:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ei: () => (/* binding */ MAX_SIZE_PER_PAGE),
/* harmony export */   Kx: () => (/* binding */ TRANSACTIONS_BY_CONTRACT_METHOD_ENDPOINT),
/* harmony export */   jU: () => (/* binding */ CHAINBASE_API_URL)
/* harmony export */ });
const CHAINBASE_API_URL = 'https://chainbase-proxy.r2d2.to';
const TRANSACTIONS_BY_CONTRACT_METHOD_ENDPOINT = 'https://arql3twjl4.execute-api.us-east-1.amazonaws.com/prod/records';
const MAX_SIZE_PER_PAGE = 1000;


/***/ }),

/***/ 93233:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   O: () => (/* binding */ CoinGeckoPriceEVM)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33026);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(65327);
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(40414);


class CoinGeckoPriceAPI_EVM {
    async getFungibleTokenPrice(chainId, address, options) {
        const { PLATFORM_ID = '', COIN_ID = '' } = (0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .getCoinGeckoConstants */ .V6)(options?.chainId ?? chainId);
        if ((0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .isNativeTokenAddress */ .qw)(address) || !(0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .isValidAddress */ .At)(address)) {
            return (0,_base_js__WEBPACK_IMPORTED_MODULE_2__/* .getTokenPriceByCoinId */ .vi)(COIN_ID, options?.currencyType);
        }
        return (0,_base_js__WEBPACK_IMPORTED_MODULE_2__/* .getTokenPrice */ .jq)(PLATFORM_ID, address, options?.currencyType);
    }
}
const CoinGeckoPriceEVM = new CoinGeckoPriceAPI_EVM();


/***/ }),

/***/ 40482:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   I: () => (/* binding */ CoinGeckoPriceSolana)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_solana__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45118);
/* harmony import */ var _masknet_web3_shared_solana__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(97470);
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(40414);


class CoinGeckoPriceAPI_Solana {
    getFungibleTokenPrice(chainId, address, options) {
        const { PLATFORM_ID = '', COIN_ID = '' } = (0,_masknet_web3_shared_solana__WEBPACK_IMPORTED_MODULE_0__/* .getCoinGeckoConstants */ .V6)(options?.chainId ?? chainId);
        if ((0,_masknet_web3_shared_solana__WEBPACK_IMPORTED_MODULE_1__/* .isNativeTokenAddress */ .qw)(address)) {
            return (0,_base_js__WEBPACK_IMPORTED_MODULE_2__/* .getTokenPriceByCoinId */ .vi)(COIN_ID, options?.currencyType);
        }
        return (0,_base_js__WEBPACK_IMPORTED_MODULE_2__/* .getTokenPrice */ .jq)(PLATFORM_ID, address, options?.currencyType);
    }
}
const CoinGeckoPriceSolana = new CoinGeckoPriceAPI_Solana();


/***/ }),

/***/ 47797:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ CoinGeckoTrending)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/compact.js
var compact = __webpack_require__(72845);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/uniqBy.js
var uniqBy = __webpack_require__(72601);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/uniq.js
var uniq = __webpack_require__(405);
// EXTERNAL MODULE: ./packages/shared-base/src/types/PluginID.ts
var PluginID = __webpack_require__(24835);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/specs/index.ts
var specs = __webpack_require__(62649);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/attemptUntil.ts
var attemptUntil = __webpack_require__(92358);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/constants/constants.ts
var constants = __webpack_require__(33026);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/types/index.ts
var types = __webpack_require__(24770);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/token.ts
var token = __webpack_require__(48289);
// EXTERNAL MODULE: ./packages/web3-providers/src/CoinGecko/constants.ts
var CoinGecko_constants = __webpack_require__(13890);
// EXTERNAL MODULE: ./packages/web3-providers/src/Trending/helpers.ts
var helpers = __webpack_require__(67876);
// EXTERNAL MODULE: ./packages/web3-providers/src/Trending/constants.ts
var Trending_constants = __webpack_require__(35523);
// EXTERNAL MODULE: ./packages/web3-providers/src/CoinGecko/apis/base.ts
var base = __webpack_require__(40414);
// EXTERNAL MODULE: ./packages/shared-base/src/helpers/createLookupTableResolver.ts
var createLookupTableResolver = __webpack_require__(74170);
// EXTERNAL MODULE: ./packages/web3-shared/solana/src/types.ts
var src_types = __webpack_require__(97834);
;// CONCATENATED MODULE: ./packages/web3-providers/src/CoinGecko/helpers.ts



const resolveCoinGeckoChainId = (0,createLookupTableResolver/* createLookupTableResolver */.F)({
    ethereum: types/* ChainId */.a_.Mainnet,
    'binance-smart-chain': types/* ChainId */.a_.BSCT,
    'polygon-pos': types/* ChainId */.a_.Matic,
    solana: src_types/* ChainId */.a_.Mainnet,
    astar: types/* ChainId */.a_.Astar,
    aurora: types/* ChainId */.a_.Aurora,
    avalanche: types/* ChainId */.a_.Avalanche,
    'arbitrum-nova': types/* ChainId */.a_.Arbitrum,
    boba: types/* ChainId */.a_.Boba,
    conflux: types/* ChainId */.a_.Conflux,
    fantom: types/* ChainId */.a_.Fantom,
    fuse: types/* ChainId */.a_.Fuse,
    moonbeam: types/* ChainId */.a_.Moonbeam,
    'optimistic-ethereum': types/* ChainId */.a_.Optimism,
    xdai: types/* ChainId */.a_.xDai
}, undefined);

// EXTERNAL MODULE: ./packages/web3-providers/src/Fuse/apis/Coin.ts
var Coin = __webpack_require__(76836);
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/fetchJSON.ts
var fetchJSON = __webpack_require__(11834);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/ResolverAPI.ts
var ResolverAPI = __webpack_require__(66979);
;// CONCATENATED MODULE: ./packages/web3-providers/src/CoinGecko/apis/TrendingAPI.ts












class CoinGeckoTrendingAPI {
    coins = new Map();
    async createCoins() {
        if (this.coins.size) return;
        const coins = await this.getAllCoins();
        coins.forEach((x)=>this.coins.set(x.id, x));
    }
    async getSupportedPlatform() {
        const response = await (0,fetchJSON/* fetchJSON */.ZV)(`${CoinGecko_constants/* COINGECKO_URL_BASE */.K}/asset_platforms`);
        return response.filter((x)=>x.id && x.chain_identifier) ?? [];
    }
    async getAllCoins() {
        const coins = await (0,base/* getAllCoins */.cz)();
        return coins.map((coin)=>({
                ...coin,
                type: specs/* TokenType */.iv.Fungible
            }));
    }
    async getCoinsByKeyword(chainId, keyword) {
        try {
            await this.createCoins();
            const thumbCoins = await (0,base/* getThumbCoins */.OG)(keyword);
            return (0,compact/* default */.Z)(thumbCoins.filter((x)=>x?.market_cap_rank && x.market_cap_rank < Trending_constants/* VALID_TOP_RANK */.r4).map((y)=>this.coins.get(y.id))).slice(0, Trending_constants/* COIN_RECOMMENDATION_SIZE */.Qx);
        } catch  {
            return Coin/* FuseCoin */.q.create(await this.getAllCoins()).search(keyword).map((x)=>x.item).slice(0, Trending_constants/* COIN_RECOMMENDATION_SIZE */.Qx);
        }
    }
    async getCoinInfoByAddress(address, chainId) {
        const chainIds = chainId ? [
            chainId
        ] : CoinGecko_constants/* COINGECKO_CHAIN_ID_LIST */.R;
        return (0,attemptUntil/* attemptUntil */.C)(chainIds.map((chainId)=>async ()=>{
                try {
                    const { PLATFORM_ID } = (0,constants/* getCoinGeckoConstants */.V6)(chainId);
                    if (!PLATFORM_ID) return;
                    const requestPath = `${CoinGecko_constants/* COINGECKO_URL_BASE */.K}/coins/${PLATFORM_ID}/contract/${address.toLowerCase()}`;
                    const response = await (0,fetchJSON/* fetchJSON */.ZV)(requestPath);
                    return response.error ? undefined : {
                        name: response.name,
                        id: response.id,
                        chainId
                    };
                } catch  {
                    return undefined;
                }
            }), undefined);
    }
    async getCoinTrending(chainId, id, currency) {
        const info = await (0,base/* getCoinInfo */.an)(id);
        if ('error' in info) throw new Error(info.error);
        const platform_url = `https://www.coingecko.com/en/coins/${info.id}`;
        const twitter_url = info.links.twitter_screen_name ? `https://twitter.com/${info.links.twitter_screen_name}` : '';
        const facebook_url = info.links.facebook_username ? `https://facebook.com/${info.links.facebook_username}` : '';
        const telegram_url = info.links.telegram_channel_identifier ? `https://t.me/${info.links.telegram_channel_identifier}` : '';
        const platforms = await this.getSupportedPlatform();
        const avaxContracts = [
            {
                address: '0x1ce0c2827e2ef14d5c4f29a091d735a204794041',
                chainId: types/* ChainId */.a_.BSC,
                pluginID: PluginID/* NetworkPluginID */.F.PLUGIN_EVM
            },
            {
                address: '0x4792c1ecb969b036eb51330c63bd27899a13d84e',
                chainId: types/* ChainId */.a_.Moonbeam,
                pluginID: PluginID/* NetworkPluginID */.F.PLUGIN_EVM
            }
        ];
        return {
            lastUpdated: info.last_updated,
            dataProvider: specs/* SourceType */.PO.CoinGecko,
            contracts: info.id === 'avalanche-2' ? avaxContracts : Object.entries(info.platforms).map(([key, address])=>({
                    chainId: platforms.find((x)=>x.id === key)?.chain_identifier ?? resolveCoinGeckoChainId(key),
                    address,
                    pluginID: key === 'solana' ? PluginID/* NetworkPluginID */.F.PLUGIN_SOLANA : PluginID/* NetworkPluginID */.F.PLUGIN_EVM
                })).filter((x)=>x.chainId && x.address),
            currency,
            coin: {
                id,
                chainId: (0,token/* isNativeTokenSymbol */.VD)(info.symbol) ? ResolverAPI/* ChainResolver */.iv.chainId(info.name) : undefined,
                name: info.name,
                symbol: info.symbol.toUpperCase(),
                type: specs/* TokenType */.iv.Fungible,
                is_mirrored: (0,helpers/* isMirroredKeyword */.Bk)(info.symbol),
                // TODO: use current language setting
                description: info.description.en,
                market_cap_rank: info.market_cap_rank,
                image_url: info.image.small,
                tags: info.categories.filter(Boolean),
                announcement_urls: info.links.announcement_url.filter(Boolean),
                community_urls: (0,helpers/* getCommunityLink */.DF)((0,uniqBy/* default */.Z)([
                    twitter_url,
                    facebook_url,
                    telegram_url,
                    info.links.subreddit_url,
                    ...info.links.chat_url,
                    ...info.links.official_forum_url
                ].filter(Boolean), (x)=>x.toLowerCase())),
                source_code_urls: Object.values(info.links.repos_url).flatMap((x)=>x),
                home_urls: info.links.homepage.filter(Boolean),
                blockchain_urls: (0,uniq/* default */.Z)([
                    platform_url,
                    ...info.links.blockchain_site
                ].filter(Boolean).map((url)=>url.toLowerCase())),
                platform_url,
                facebook_url,
                twitter_url,
                telegram_url,
                contract_address: ResolverAPI/* ChainResolver */.iv.chainId(info.name) && (0,token/* isNativeTokenSymbol */.VD)(info.symbol) ? (0,constants/* getTokenConstant */._x)(ResolverAPI/* ChainResolver */.iv.chainId(info.name), 'NATIVE_TOKEN_ADDRESS') : info.contract_address
            },
            market: (()=>{
                const entries = Object.entries(info.market_data).map(([key, value])=>{
                    if (value && typeof value === 'object') {
                        return [
                            key,
                            value[currency.id] ?? 0
                        ];
                    }
                    return [
                        key,
                        value
                    ];
                });
                return Object.fromEntries(entries);
            })(),
            tickers: info.tickers.slice(0, 30).map((x)=>({
                    logo_url: x.market.logo,
                    trade_url: x.trade_url,
                    market_name: x.market.name,
                    base_name: x.base,
                    target_name: x.target,
                    price: x.converted_last.usd,
                    volume: x.converted_volume.usd,
                    score: x.trust_score,
                    updated: new Date(x.timestamp)
                }))
        };
    }
    async getCoinPriceStats(chainId, coinId, currency, days) {
        return (await (0,base/* getPriceStats */.GK)(coinId, currency.id, days)).prices;
    }
    getCoinMarketInfo(address) {
        return (0,attemptUntil/* attemptUntil */.C)(CoinGecko_constants/* COINGECKO_CHAIN_ID_LIST */.R.map((chainId)=>async ()=>{
                try {
                    const { PLATFORM_ID = '' } = (0,constants/* getCoinGeckoConstants */.V6)(chainId);
                    const requestPath = `${CoinGecko_constants/* COINGECKO_URL_BASE */.K}/coins/${PLATFORM_ID}/contract/${address.toLowerCase()}`;
                    const response = await (0,fetchJSON/* fetchJSON */.ZV)(requestPath);
                    if ('error' in response) return;
                    return {
                        id: response.id,
                        market_cap: response.market_data.market_cap.usd.toString()
                    };
                } catch  {
                    return undefined;
                }
            }), undefined);
    }
}
const CoinGeckoTrending = new CoinGeckoTrendingAPI();


/***/ }),

/***/ 40414:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GK: () => (/* binding */ getPriceStats),
/* harmony export */   OG: () => (/* binding */ getThumbCoins),
/* harmony export */   an: () => (/* binding */ getCoinInfo),
/* harmony export */   cz: () => (/* binding */ getAllCoins),
/* harmony export */   jq: () => (/* binding */ getTokenPrice),
/* harmony export */   vi: () => (/* binding */ getTokenPriceByCoinId)
/* harmony export */ });
/* harmony import */ var urlcat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78757);
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(89087);
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(62649);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(13890);
/* harmony import */ var _helpers_fetchJSON_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11834);





function fetchFromCoinGecko(request, init) {
    return (0,_helpers_fetchJSON_js__WEBPACK_IMPORTED_MODULE_1__/* .fetchCachedJSON */ .MP)(request, init);
}
// #region coins
async function getAllCoins() {
    return fetchFromCoinGecko((0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(_constants_js__WEBPACK_IMPORTED_MODULE_2__/* .COINGECKO_URL_BASE */ .K, '/coins/list'), {
        cache: 'force-cache'
    });
}
async function getCoinInfo(coinId) {
    return fetchFromCoinGecko((0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(_constants_js__WEBPACK_IMPORTED_MODULE_2__/* .COINGECKO_URL_BASE */ .K, `/coins/${coinId}`, {
        developer_data: false,
        community_data: false,
        tickers: true
    }), {
        cache: 'default'
    });
}
async function getThumbCoins(keyword) {
    if (!keyword) return [];
    const response = await fetchFromCoinGecko((0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(_constants_js__WEBPACK_IMPORTED_MODULE_2__/* .COINGECKO_URL_BASE */ .K, '/search', {
        query: keyword
    }), {
        cache: 'default'
    });
    if ('error' in response) throw new Error(response.error);
    return response.coins;
}
// #endregion
// #region price chart
async function getPriceStats(coinId, currencyId, days) {
    return fetchFromCoinGecko((0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(_constants_js__WEBPACK_IMPORTED_MODULE_2__/* .COINGECKO_URL_BASE */ .K, `/coins/${coinId}/market_chart`, {
        vs_currency: currencyId,
        days: days === _masknet_shared_base__WEBPACK_IMPORTED_MODULE_3__/* .Days */ .h.MAX ? 11430 : days
    }), {
        cache: 'default'
    });
}
// #endregion
// #region token price
async function getTokenPrice(platform_id, address, currencyType = _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_4__/* .CurrencyType */ .V2.USD) {
    const price = await getTokenPrices(platform_id, [
        address
    ], currencyType);
    const currencies = price[address.toLowerCase()];
    return currencies?.[currencyType] ? Number(currencies[currencyType]) : undefined;
}
async function getTokenPrices(platform_id, contractAddresses, currency = _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_4__/* .CurrencyType */ .V2.USD) {
    return fetchFromCoinGecko((0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(_constants_js__WEBPACK_IMPORTED_MODULE_2__/* .COINGECKO_URL_BASE */ .K, '/simple/token_price/:platform_id', {
        platform_id,
        contract_addresses: contractAddresses.join(','),
        vs_currencies: currency
    }), undefined);
}
async function getTokenPriceByCoinId(coin_id, currency = _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_4__/* .CurrencyType */ .V2.USD) {
    const price = await fetchFromCoinGecko((0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(_constants_js__WEBPACK_IMPORTED_MODULE_2__/* .COINGECKO_URL_BASE */ .K, '/simple/price', {
        ids: coin_id,
        vs_currencies: currency
    }), undefined);
    return price[coin_id]?.[currency];
} // #endregion


/***/ }),

/***/ 13890:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   K: () => (/* binding */ COINGECKO_URL_BASE),
/* harmony export */   R: () => (/* binding */ COINGECKO_CHAIN_ID_LIST)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24770);


const COINGECKO_URL_BASE = 'https://coingecko-agent.r2d2.to/api/v3';
const COINGECKO_CHAIN_ID_LIST = [
    _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Mainnet,
    _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.BSC,
    _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Base,
    _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Matic,
    _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Arbitrum,
    _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.xDai,
    _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Optimism,
    _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Avalanche,
    _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Celo,
    _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Fantom,
    _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Aurora,
    _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Conflux,
    _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Astar,
    _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Pulse,
    _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Moonbeam,
    _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Klaytn,
    _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Moonriver,
    _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Harmony,
    _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Cronos,
    _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.BitTorrent,
    _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Boba
];
if (false) {}


/***/ }),

/***/ 68235:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (/* binding */ DSEARCH_BASE_URL)
/* harmony export */ });
const DSEARCH_BASE_URL = 'https://dsearch.mask.r2d2.to';


/***/ }),

/***/ 26750:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   u: () => (/* binding */ fetchFromDSearch)
/* harmony export */ });
/* harmony import */ var _helpers_fetchCached_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(22674);
/* harmony import */ var _helpers_fetchJSON_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11834);


function fetchFromDSearch(request, init) {
    return (0,_helpers_fetchJSON_js__WEBPACK_IMPORTED_MODULE_0__/* .fetchCachedJSON */ .MP)(request, init, {
        squashExpiration: 0,
        cacheDuration: _helpers_fetchCached_js__WEBPACK_IMPORTED_MODULE_1__/* .Duration */ .nL.THIRTY_MINUTES
    });
}


/***/ }),

/***/ 26861:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  d: () => (/* binding */ DSearchAPI)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/urlcat@3.1.0_patch_hash=5r5xyq4zgcnqugwsrx4lxq2i4e/node_modules/urlcat/dist/index.mjs
var dist = __webpack_require__(78757);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/uniqWith.js
var uniqWith = __webpack_require__(9402);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/attemptUntil.ts
var attemptUntil = __webpack_require__(92358);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/specs/index.ts
var specs = __webpack_require__(62649);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/isSameAddress.ts
var isSameAddress = __webpack_require__(74765);
// EXTERNAL MODULE: ./packages/shared-base/src/constants.ts
var constants = __webpack_require__(52033);
// EXTERNAL MODULE: ./packages/shared-base/src/types/PluginID.ts
var PluginID = __webpack_require__(24835);
// EXTERNAL MODULE: ./packages/web3-telemetry/src/providers/index.ts + 10 modules
var providers = __webpack_require__(17788);
// EXTERNAL MODULE: ./packages/web3-telemetry/src/types/index.ts
var types = __webpack_require__(91451);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/address.ts
var helpers_address = __webpack_require__(65327);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/isValidDomain.ts
var isValidDomain = __webpack_require__(89019);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/types/index.ts
var src_types = __webpack_require__(24770);
// EXTERNAL MODULE: ./packages/web3-shared/flow/src/helpers/address.ts + 1 modules
var src_helpers_address = __webpack_require__(44050);
// EXTERNAL MODULE: ./packages/web3-shared/flow/src/helpers/domain.ts
var helpers_domain = __webpack_require__(68169);
// EXTERNAL MODULE: ./packages/web3-shared/solana/src/helpers/address.ts + 2 modules
var solana_src_helpers_address = __webpack_require__(97470);
// EXTERNAL MODULE: ./packages/web3-shared/solana/src/helpers/domain.ts
var src_helpers_domain = __webpack_require__(43500);
// EXTERNAL MODULE: ./packages/web3-providers/src/DSearch/constants.ts
var DSearch_constants = __webpack_require__(68235);
// EXTERNAL MODULE: ./packages/web3-providers/src/DSearch/helpers.ts
var helpers = __webpack_require__(26750);
;// CONCATENATED MODULE: ./packages/web3-providers/src/CoinGecko/apis/DSearchAPI.ts



class CoinGeckoSearchAPI {
    async get() {
        return (0,helpers/* fetchFromDSearch */.u)((0,dist/* default */.ZP)(DSearch_constants/* DSEARCH_BASE_URL */.Z, '/fungible-tokens/coingecko.json'), {
            mode: 'cors'
        });
    }
}

// EXTERNAL MODULE: ./packages/web3-providers/src/CoinGecko/apis/TrendingAPI.ts + 1 modules
var TrendingAPI = __webpack_require__(47797);
;// CONCATENATED MODULE: ./packages/web3-providers/src/CoinMarketCap/apis/DSearchAPI.ts



class CoinMarketCapSearchAPI {
    async get() {
        return (0,helpers/* fetchFromDSearch */.u)((0,dist/* default */.ZP)(DSearch_constants/* DSEARCH_BASE_URL */.Z, '/fungible-tokens/coinmarketcap.json'), {
            mode: 'cors'
        });
    }
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/NFTScan/apis/DSearchAPI.ts



class NFTScanSearchAPI {
    async get() {
        const nfts = (0,helpers/* fetchFromDSearch */.u)((0,dist/* default */.ZP)(DSearch_constants/* DSEARCH_BASE_URL */.Z, '/non-fungible-tokens/nftscan.json'), {
            mode: 'cors'
        });
        const collections = (0,helpers/* fetchFromDSearch */.u)((0,dist/* default */.ZP)(DSearch_constants/* DSEARCH_BASE_URL */.Z, '/non-fungible-collections/nftscan.json'), {
            mode: 'cors'
        });
        const collectionsFromSpecialList = (0,helpers/* fetchFromDSearch */.u)((0,dist/* default */.ZP)(DSearch_constants/* DSEARCH_BASE_URL */.Z, '/non-fungible-collections/specific-list.json'), {
            mode: 'cors'
        });
        return (await Promise.allSettled([
            collectionsFromSpecialList,
            nfts,
            collections
        ])).flatMap((v)=>v.status === 'fulfilled' && v.value ? v.value : []);
    }
}
class NFTScanCollectionSearchAPI {
    async get() {
        const collectionsFromSpecialList = (0,helpers/* fetchFromDSearch */.u)((0,dist/* default */.ZP)(DSearch_constants/* DSEARCH_BASE_URL */.Z, '/non-fungible-collections/specific-list.json'), {
            mode: 'cors'
        });
        const collections = (0,helpers/* fetchFromDSearch */.u)((0,dist/* default */.ZP)(DSearch_constants/* DSEARCH_BASE_URL */.Z, '/non-fungible-collections/nftscan.json'), {
            mode: 'cors'
        });
        return (await Promise.allSettled([
            collectionsFromSpecialList,
            collections
        ])).flatMap((v)=>v.status === 'fulfilled' && v.value ? v.value : []);
    }
}

// EXTERNAL MODULE: ./packages/web3-providers/src/RSS3/apis/RSS3API.ts + 1 modules
var RSS3API = __webpack_require__(23516);
// EXTERNAL MODULE: ./packages/web3-providers/src/ENS/index.ts + 3 modules
var ENS = __webpack_require__(68513);
// EXTERNAL MODULE: ./packages/web3-providers/src/SpaceID/index.ts
var SpaceID = __webpack_require__(60531);
// EXTERNAL MODULE: ./packages/web3-providers/src/ARBID/index.ts
var ARBID = __webpack_require__(92524);
// EXTERNAL MODULE: ./packages/web3-providers/src/NextID/proof.ts + 2 modules
var proof = __webpack_require__(63544);
// EXTERNAL MODULE: ./packages/web3-providers/src/RSS3/constants.ts
var RSS3_constants = __webpack_require__(61220);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/compact.js
var compact = __webpack_require__(72845);
// EXTERNAL MODULE: ./packages/web3-providers/src/Fuse/apis/Base.ts
var Base = __webpack_require__(63502);
;// CONCATENATED MODULE: ./packages/web3-providers/src/DSearch/rules.ts



const getHandlers = ()=>[
        {
            rules: [
                {
                    key: 'token',
                    type: 'exact',
                    filter: (data, keyword)=>{
                        if (data.type !== specs/* SearchResultType */.Bk.FungibleToken) return false;
                        if (data.alias?.filter((x)=>!x.isPin).map((x)=>x.value.toLowerCase()).includes(keyword.toLowerCase())) return true;
                        const symbol = data.symbol;
                        if (symbol === keyword || symbol?.replace(/\s/g, '') === keyword) return true;
                        const name = data.name;
                        if (name === keyword) return true;
                        return false;
                    }
                },
                {
                    key: 'token',
                    type: 'fuzzy',
                    fullSearch (keyword, all) {
                        const data = (0,compact/* default */.Z)(all.filter((x)=>x.alias?.length && x.type === specs/* SearchResultType */.Bk.FungibleToken).flatMap((x)=>{
                            return x.alias?.filter((x)=>x.isPin).map((y)=>{
                                return {
                                    ...x,
                                    __alias: y.value
                                };
                            });
                        }));
                        return Base/* Fuse */.Q.create(data, {
                            keys: [
                                {
                                    name: '__alias',
                                    weight: 0.5
                                }
                            ],
                            isCaseSensitive: false,
                            ignoreLocation: true,
                            shouldSort: true,
                            threshold: 0,
                            minMatchCharLength: 5
                        }).search(keyword).map((x)=>data[x.refIndex]);
                    }
                },
                {
                    key: 'token',
                    type: 'fuzzy',
                    fullSearch (keyword, all) {
                        const data = (0,compact/* default */.Z)(all.map((x)=>{
                            if (x.type !== specs/* SearchResultType */.Bk.FungibleToken) return;
                            return {
                                ...x,
                                __symbol: x.symbol?.replace(/\s/g, ''),
                                __name: x.name?.replace(/\s/g, '')
                            };
                        }));
                        return Base/* Fuse */.Q.create(data, {
                            keys: [
                                {
                                    name: 'symbol',
                                    weight: 0.5
                                },
                                {
                                    name: '__symbol',
                                    weight: 0.4
                                },
                                {
                                    name: '__name',
                                    weight: 0.3
                                },
                                {
                                    name: 'name',
                                    weight: 0.3
                                }
                            ],
                            isCaseSensitive: false,
                            ignoreLocation: true,
                            shouldSort: true,
                            threshold: 0,
                            minMatchCharLength: 5
                        }).search(keyword).map((x)=>all[x.refIndex]);
                    }
                }
            ],
            types: [
                specs/* SearchResultType */.Bk.FungibleToken
            ]
        },
        {
            rules: [
                {
                    key: 'token',
                    type: 'exact',
                    filter: (data, keyword)=>{
                        if (data.type !== specs/* SearchResultType */.Bk.NonFungibleCollection && data.type !== specs/* SearchResultType */.Bk.NonFungibleToken) return false;
                        return (0,isSameAddress/* isSameAddress */.W)(data.address, keyword) || data.name === keyword || Boolean(data.alias?.filter((x)=>!x.isPin)?.map((x)=>x.value.toLowerCase()).includes(keyword.toLowerCase()));
                    }
                },
                {
                    key: 'token',
                    type: 'fuzzy',
                    fullSearch (keyword, all) {
                        const data = (0,compact/* default */.Z)(all.filter((x)=>x.alias?.length && x.type === specs/* SearchResultType */.Bk.CollectionListByTwitterHandler).flatMap((x)=>{
                            // Make ts work
                            if (x.type !== specs/* SearchResultType */.Bk.CollectionListByTwitterHandler) return [];
                            return x.alias?.filter((x)=>x.isPin).map((y)=>{
                                return {
                                    ...x,
                                    __name: x.name?.replace(/\s/g, ''),
                                    __alias: y.value
                                };
                            });
                        }));
                        return Base/* Fuse */.Q.create(data, {
                            keys: [
                                {
                                    name: '__alias',
                                    weight: 0.5
                                },
                                {
                                    name: '__name',
                                    weight: 0.3
                                },
                                {
                                    name: 'name',
                                    weight: 0.3
                                }
                            ],
                            isCaseSensitive: false,
                            ignoreLocation: true,
                            shouldSort: true,
                            threshold: 0,
                            minMatchCharLength: 5
                        }).search(keyword).map((x)=>data[x.refIndex]);
                    }
                },
                {
                    key: 'token',
                    type: 'fuzzy',
                    fullSearch (keyword, all) {
                        const data = (0,compact/* default */.Z)(all.map((x)=>{
                            if (x.type !== specs/* SearchResultType */.Bk.NonFungibleCollection && x.type !== specs/* SearchResultType */.Bk.NonFungibleToken) return;
                            return {
                                ...x,
                                __name: x.name?.replace(/\s/g, '')
                            };
                        }));
                        return Base/* Fuse */.Q.create(data, {
                            keys: [
                                {
                                    name: 'name',
                                    weight: 0.6
                                },
                                {
                                    name: '__name',
                                    weight: 0.4
                                }
                            ],
                            isCaseSensitive: false,
                            ignoreLocation: true,
                            shouldSort: true,
                            threshold: 0,
                            minMatchCharLength: 5
                        }).search(keyword).map((x)=>all[x.refIndex]);
                    }
                }
            ],
            types: [
                specs/* SearchResultType */.Bk.NonFungibleToken,
                specs/* SearchResultType */.Bk.NonFungibleCollection
            ]
        },
        {
            rules: [
                {
                    key: 'twitter',
                    type: 'exact',
                    filter: (data, keyword)=>{
                        if (data.type !== specs/* SearchResultType */.Bk.CollectionListByTwitterHandler) return false;
                        return !!data.collection?.socialLinks?.twitter?.toLowerCase().endsWith(keyword.toLowerCase());
                    }
                }
            ],
            types: [
                specs/* SearchResultType */.Bk.CollectionListByTwitterHandler
            ]
        }
    ];

;// CONCATENATED MODULE: ./packages/web3-providers/src/DSearch/index.ts






















const isValidAddress = (address)=>{
    return (0,helpers_address/* isValidAddress */.At)(address) || (0,src_helpers_address/* isValidAddress */.At)(address) || (0,solana_src_helpers_address/* isValidAddress */.At)(address);
};
const isZeroAddress = (address)=>{
    return (0,helpers_address/* isZeroAddress */.uO)(address) || (0,src_helpers_address/* isZeroAddress */.uO)(address) || (0,solana_src_helpers_address/* isZeroAddress */.uO)(address);
};
const DSearch_isValidDomain = (domain)=>{
    return (0,isValidDomain/* isValidDomain */.h)(domain) || (0,helpers_domain/* isValidDomain */.hS)(domain) || (0,src_helpers_domain/* isValidDomain */.h)(domain);
};
const handleRe = new RegExp(`\\.(${[
    'avax',
    'csb',
    'bit',
    'eth',
    'arb',
    'lens',
    'bnb',
    'crypto',
    'nft',
    'x',
    'wallet',
    'bitcoin',
    'dao',
    '888',
    'zil',
    'blockchain'
].join('|')})$`, 'i');
const isValidHandle = (handle)=>{
    return handleRe.test(handle);
};
class DSearchAPI {
    NFTScanClient = new NFTScanSearchAPI();
    NFTScanCollectionClient = new NFTScanCollectionSearchAPI();
    CoinGeckoClient = new CoinGeckoSearchAPI();
    CoinMarketCapClient = new CoinMarketCapSearchAPI();
    parseKeyword(keyword) {
        const words = keyword.split(':');
        if (words.length === 1) {
            return {
                word: words[0]
            };
        }
        return {
            word: words[1],
            field: words[0]
        };
    }
    async searchDomain(domain) {
        // only EVM domains
        if (!(0,isValidDomain/* isValidDomain */.h)(domain)) return constants/* EMPTY_LIST */.rP;
        const [address, chainId] = await (0,attemptUntil/* attemptUntil */.C)([
            ()=>ENS/* ENS */.n.lookup(domain).then((x = '')=>{
                    if (!x || (0,helpers_address/* isZeroAddress */.uO)(address)) throw new Error(`No result for ${domain}`);
                    return [
                        x,
                        src_types/* ChainId */.a_.Mainnet
                    ];
                }),
            ()=>SpaceID/* SpaceID */.i.lookup(domain).then((x = '')=>{
                    if (!x || (0,helpers_address/* isZeroAddress */.uO)(address)) throw new Error(`No result for ${domain}`);
                    return [
                        x,
                        src_types/* ChainId */.a_.BSC
                    ];
                }),
            ()=>ARBID/* ARBID */.R.lookup(domain).then((x = '')=>{
                    if (!x || (0,helpers_address/* isZeroAddress */.uO)(address)) throw new Error(`No result for ${domain}`);
                    return [
                        x,
                        src_types/* ChainId */.a_.Arbitrum
                    ];
                })
        ], [
            '',
            src_types/* ChainId */.a_.Mainnet
        ]);
        if (!(0,helpers_address/* isValidAddress */.At)(address) || (0,helpers_address/* isZeroAddress */.uO)(address)) return constants/* EMPTY_LIST */.rP;
        return [
            {
                type: specs/* SearchResultType */.Bk.Domain,
                pluginID: PluginID/* NetworkPluginID */.F.PLUGIN_EVM,
                chainId: chainId,
                keyword: domain,
                domain,
                address
            }
        ];
    }
    async searchRSS3Handle(handle) {
        const profiles = await RSS3API/* RSS3 */.S.getProfiles(handle);
        return profiles.filter((x)=>x.handle === handle).map((profile)=>{
            const chainId = RSS3_constants/* PlatformToChainIdMap */.J_[profile.network];
            if (!chainId) console.error(`Not chain id configured for network ${profile.network}`);
            return {
                type: specs/* SearchResultType */.Bk.Domain,
                pluginID: PluginID/* NetworkPluginID */.F.PLUGIN_EVM,
                chainId,
                keyword: handle,
                domain: profile.handle,
                address: profile.address
            };
        });
    }
    async searchRSS3NameService(handle) {
        const result = await RSS3API/* RSS3 */.S.getNameService(handle);
        if (!result) return [];
        return [
            {
                type: specs/* SearchResultType */.Bk.Domain,
                pluginID: PluginID/* NetworkPluginID */.F.PLUGIN_EVM,
                chainId: result.chainId,
                keyword: handle,
                domain: handle,
                address: result.address
            }
        ];
    }
    async searchAddress(address) {
        // only EVM address
        if (!(0,helpers_address/* isValidAddress */.At)(address)) return constants/* EMPTY_LIST */.rP;
        const [domain, chainId] = await (0,attemptUntil/* attemptUntil */.C)([
            ()=>ENS/* ENS */.n.reverse(address).then((x)=>[
                        x,
                        src_types/* ChainId */.a_.Mainnet
                    ]),
            ()=>SpaceID/* SpaceID */.i.reverse(address).then((x)=>[
                        x,
                        src_types/* ChainId */.a_.BSC
                    ]),
            ()=>ARBID/* ARBID */.R.reverse(address).then((x)=>[
                        x,
                        src_types/* ChainId */.a_.Arbitrum
                    ])
        ], [
            '',
            src_types/* ChainId */.a_.Mainnet
        ]);
        if ((0,isValidDomain/* isValidDomain */.h)(domain)) {
            return [
                {
                    type: specs/* SearchResultType */.Bk.EOA,
                    pluginID: PluginID/* NetworkPluginID */.F.PLUGIN_EVM,
                    chainId: chainId,
                    keyword: address,
                    domain,
                    address
                }
            ];
        }
        const bindingProofs = await proof/* NextIDProof */.q.queryProfilesByAddress(address);
        if (bindingProofs?.length > 0) {
            return [
                {
                    type: specs/* SearchResultType */.Bk.EOA,
                    pluginID: PluginID/* NetworkPluginID */.F.PLUGIN_EVM,
                    chainId: chainId,
                    keyword: address,
                    bindingProofs,
                    address
                }
            ];
        }
        return constants/* EMPTY_LIST */.rP;
    }
    async searchTokens() {
        const specificTokens = (await Promise.allSettled([
            (0,helpers/* fetchFromDSearch */.u)((0,dist/* default */.ZP)(DSearch_constants/* DSEARCH_BASE_URL */.Z, '/fungible-tokens/specific-list.json'), {
                mode: 'cors'
            }),
            (0,helpers/* fetchFromDSearch */.u)((0,dist/* default */.ZP)(DSearch_constants/* DSEARCH_BASE_URL */.Z, '/non-fungible-tokens/specific-list.json'), {
                mode: 'cors'
            }),
            (0,helpers/* fetchFromDSearch */.u)((0,dist/* default */.ZP)(DSearch_constants/* DSEARCH_BASE_URL */.Z, '/non-fungible-collections/specific-list.json'), {
                mode: 'cors'
            })
        ])).flatMap((v)=>v.status === 'fulfilled' && v.value ? v.value : []);
        const normalTokens = (await Promise.allSettled([
            this.NFTScanClient.get(),
            this.CoinGeckoClient.get(),
            this.CoinMarketCapClient.get()
        ])).flatMap((v)=>v.status === 'fulfilled' && v.value ? v.value : []);
        return {
            specificTokens,
            normalTokens
        };
    }
    async searchTokenByAddress(address) {
        const { specificTokens, normalTokens } = await this.searchTokens();
        const specificTokensFiltered = specificTokens.filter((x)=>(0,isSameAddress/* isSameAddress */.W)(address, x.address) && (x.type === specs/* SearchResultType */.Bk.FungibleToken || x.type === specs/* SearchResultType */.Bk.NonFungibleToken || x.type === specs/* SearchResultType */.Bk.CollectionListByTwitterHandler)).sort((a, b)=>(a.rank ?? 0) - (b.rank ?? 0));
        const normalTokensFiltered = normalTokens.filter((x)=>(0,isSameAddress/* isSameAddress */.W)(address, x.address) && (x.type === specs/* SearchResultType */.Bk.FungibleToken || x.type === specs/* SearchResultType */.Bk.NonFungibleToken || x.type === specs/* SearchResultType */.Bk.CollectionListByTwitterHandler)).sort((a, b)=>(a.rank ?? 0) - (b.rank ?? 0));
        if (specificTokensFiltered.length > 0) return [
            specificTokensFiltered[0]
        ];
        if (normalTokensFiltered.length > 0) return [
            normalTokensFiltered[0]
        ];
        const coinInfo = await TrendingAPI/* CoinGeckoTrending */.A.getCoinInfoByAddress(address);
        if (coinInfo?.id) {
            return [
                {
                    type: specs/* SearchResultType */.Bk.FungibleToken,
                    pluginID: PluginID/* NetworkPluginID */.F.PLUGIN_EVM,
                    chainId: coinInfo.chainId,
                    id: coinInfo.id,
                    source: specs/* SourceType */.PO.CoinGecko,
                    name: coinInfo.name,
                    // FIXME: symbol is missing
                    symbol: coinInfo.name,
                    keyword: address
                }
            ];
        }
        return constants/* EMPTY_LIST */.rP;
    }
    async searchTokenByHandler(tokens, name) {
        let result = [];
        if (name.length < 6) {
            const lowerName = name.toLowerCase();
            result = tokens.filter((t)=>t.symbol?.toLowerCase() === lowerName || name.length > 3 && t.name?.toLowerCase().startsWith(lowerName) && t.rank && t.rank <= 20 || t.alias?.map((x)=>x.value.toLowerCase()).includes(lowerName));
        }
        if (!result.length) {
            for (const { rules, types } of getHandlers()){
                for (const rule of rules){
                    if (![
                        'token',
                        'twitter'
                    ].includes(rule.key)) continue;
                    const filtered = tokens.filter((x)=>types ? types.includes(x.type) : true);
                    if (rule.type === 'exact') {
                        const item = filtered.find((x)=>rule.filter?.(x, name, filtered));
                        if (item) result = [
                            ...result,
                            {
                                ...item,
                                keyword: name
                            }
                        ];
                    }
                    if (rule.type === 'fuzzy' && rule.fullSearch) {
                        const items = rule.fullSearch(name, filtered)?.map((x)=>({
                                ...x,
                                keyword: name
                            }));
                        if (items?.length) result = [
                            ...result,
                            ...items
                        ];
                    }
                }
            }
        }
        return result.sort((a, b)=>{
            if (a.rank && a.rank <= 200 && a.type === specs/* SearchResultType */.Bk.FungibleToken && b.type !== specs/* SearchResultType */.Bk.FungibleToken || a.source === specs/* SourceType */.PO.CoinGecko && b.source === specs/* SourceType */.PO.CoinMarketCap) return -1;
            if (a.source === specs/* SourceType */.PO.CoinMarketCap && b.source === specs/* SourceType */.PO.CoinGecko) return 1;
            return (a.rank ?? 0) - (b.rank ?? 0);
        });
    }
    async searchTokenByName(name) {
        const { specificTokens, normalTokens } = await this.searchTokens();
        const specificResult_ = await this.searchTokenByHandler(specificTokens.map((x)=>({
                ...x,
                alias: x.alias?.filter((x)=>!x.isPin)
            })), name);
        const normalResult = await this.searchTokenByHandler([
            ...specificTokens,
            ...normalTokens
        ], name);
        const specificResult = specificResult_.map((x)=>{
            const r = normalTokens.find((y)=>(0,isSameAddress/* isSameAddress */.W)(y.address, x.address) && x.chainId === y.chainId);
            return {
                ...x,
                rank: r?.rank
            };
        });
        return (0,uniqWith/* default */.Z)(specificResult.concat(normalResult), (a, b)=>a.id === b.id);
    }
    async searchCollectionListByTwitterHandler(twitterHandler) {
        const collections = (0,uniqWith/* default */.Z)((await Promise.allSettled([
            this.CoinGeckoClient.get(),
            this.CoinMarketCapClient.get(),
            this.NFTScanCollectionClient.get()
        ])).flatMap((v)=>v.status === 'fulfilled' && v.value ? v.value : []).filter((x)=>{
            const resultTwitterHandler = x.collection?.socialLinks?.twitter || x.socialLinks?.twitter;
            return resultTwitterHandler && [
                twitterHandler.toLowerCase(),
                `https://twitter.com/${twitterHandler.toLowerCase()}`
            ].includes(resultTwitterHandler.toLowerCase()) && (x.rank && x.rank <= 500 || x.id === 'mask-network');
        }).sort((a, b)=>{
            if (a.source === specs/* SourceType */.PO.CoinGecko && b.source === specs/* SourceType */.PO.CoinMarketCap) return -1;
            if (a.source === specs/* SourceType */.PO.CoinMarketCap && b.source === specs/* SourceType */.PO.CoinGecko) return 1;
            return (a.rank ?? 0) - (b.rank ?? 0);
        }), (a, b)=>a.id === b.id);
        if (!collections[0]) return constants/* EMPTY_LIST */.rP;
        return collections;
    }
    /**
     * The entry point of DSearch
     * @param keyword
     * @returns
     */ async search(keyword_, type) {
        const keyword = keyword_.toLowerCase();
        // filter out 'domain/xxx' or string ends with punctuation marks like 'eth.'
        if (keyword.replace(/([#$])?([\s\w+.])+/, '').length > 0 || !new RegExp(/(\w)+/).test(keyword.at(-1))) return constants/* EMPTY_LIST */.rP;
        // #MASK or $MASK or MASK
        const [_, name = ''] = keyword.match(/(\w+)/) ?? [];
        // BoredApeYC or CryptoPunks nft twitter project
        if (type === specs/* SearchResultType */.Bk.CollectionListByTwitterHandler) return this.searchCollectionListByTwitterHandler(keyword);
        // token:MASK
        const { word, field } = this.parseKeyword(keyword);
        if (word && [
            'token',
            'twitter'
        ].includes(field ?? '')) return this.searchTokenByName(word);
        // vitalik.lens, vitalik.bit, etc. including ENS BNB
        // Can't get .bit domain via RSS3 profile API.
        if (isValidHandle(keyword) && !keyword.endsWith('.bit')) {
            if (keyword.endsWith('.eth')) providers/* Telemetry */.M.captureEvent(types/* EventType */.tw.Access, types/* EventID */.HS.EntryTimelineDsearchEns);
            else providers/* Telemetry */.M.captureEvent(types/* EventType */.tw.Access, types/* EventID */.HS.EntryTimelineDsearchName);
            return this.searchRSS3Handle(keyword);
        }
        if (keyword.endsWith('.bit')) {
            providers/* Telemetry */.M.captureEvent(types/* EventType */.tw.Access, types/* EventID */.HS.EntryTimelineDsearchName);
            return this.searchRSS3NameService(keyword);
        }
        // vitalik.eth
        if (DSearch_isValidDomain(keyword)) return this.searchDomain(keyword);
        // 0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045
        if (isValidAddress?.(keyword) && !isZeroAddress?.(keyword)) {
            const tokenList = await this.searchTokenByAddress(keyword);
            if (tokenList.length) return tokenList;
            providers/* Telemetry */.M.captureEvent(types/* EventType */.tw.Access, types/* EventID */.HS.EntryTimelineDsearchAddress);
            const addressList = await this.searchAddress(keyword);
            if (addressList.length) return addressList;
        }
        if (name) return this.searchTokenByName(name);
        return constants/* EMPTY_LIST */.rP;
    }
}


/***/ }),

/***/ 86273:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   u: () => (/* binding */ DeBankHistory)
/* harmony export */ });
/* harmony import */ var urlcat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78757);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(72845);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(405);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(12113);
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(38645);
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(52033);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(24770);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(33026);
/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(11678);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10663);
/* harmony import */ var _helpers_fetchJSON_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(11834);
/* harmony import */ var _Web3_EVM_apis_Web3StateAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39850);








const PRESET_CHAIN_IDS = 'eth,aurora,bsc,matic,pls,ftm,op,klay,nova,celo,astar,boba'.split(',');
class DeBankHistoryAPI {
    // Collect from https://docs.cloud.debank.com/en/readme/api-pro-reference/chain#returns-1
    getChainIds() {
        const networks = _Web3_EVM_apis_Web3StateAPI_js__WEBPACK_IMPORTED_MODULE_1__.Web3StateRef.value.Network?.networks?.getCurrentValue();
        // Fallback to commonly used chains
        if (!networks) return PRESET_CHAIN_IDS;
        const RUNTIME_CHAIN_IDS = networks.map((x)=>_constants_js__WEBPACK_IMPORTED_MODULE_2__/* .CHIAN_ID_TO_DEBANK_CHAIN_MAP */ .El[x.chainId]);
        return (0,lodash_es__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)((0,lodash_es__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)([
            ...RUNTIME_CHAIN_IDS,
            PRESET_CHAIN_IDS
        ])).join(',');
    }
    async getTransactions(address, { chainId = _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_5__/* .ChainId */ .a_.Mainnet, indicator, size = 20 } = {}) {
        const { CHAIN_ID = '' } = (0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__/* .getDeBankConstants */ .Bx)(chainId);
        if (!CHAIN_ID) return (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_7__/* .createPageable */ .LI)(_masknet_shared_base__WEBPACK_IMPORTED_MODULE_8__/* .EMPTY_LIST */ .rP, (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_7__/* .createIndicator */ .sz)(indicator));
        const result = await (0,_helpers_fetchJSON_js__WEBPACK_IMPORTED_MODULE_9__/* .fetchSquashedJSON */ .Vn)((0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(_constants_js__WEBPACK_IMPORTED_MODULE_2__/* .DEBANK_OPEN_API */ .$1, '/v1/user/history_list', {
            id: address.toLowerCase(),
            chain_id: (0,_helpers_js__WEBPACK_IMPORTED_MODULE_10__/* .resolveDeBankAssetIdReversed */ .M5)(CHAIN_ID),
            page_count: size,
            start_time: indicator?.id
        }));
        const transactions = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_10__/* .formatTransactions */ .mT)(result, address);
        const timeStamp = (0,lodash_es__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .Z)(result.history_list)?.time_at;
        return (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_7__/* .createPageable */ .LI)(transactions, (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_7__/* .createIndicator */ .sz)(indicator), transactions.length > 0 ? (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_7__/* .createNextIndicator */ .gT)(indicator, timeStamp?.toString()) : undefined);
    }
    async getAllTransactions(address, { indicator, size = 20 } = {}) {
        const result = await (0,_helpers_fetchJSON_js__WEBPACK_IMPORTED_MODULE_9__/* .fetchSquashedJSON */ .Vn)((0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(_constants_js__WEBPACK_IMPORTED_MODULE_2__/* .DEBANK_OPEN_API */ .$1, '/v1/user/all_history_list', {
            id: address.toLowerCase(),
            page_count: size,
            start_time: indicator?.id,
            chain_ids: this.getChainIds()
        }));
        const transactions = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_10__/* .formatTransactions */ .mT)(result, address);
        const timeStamp = (0,lodash_es__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .Z)(result.history_list)?.time_at;
        return (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_7__/* .createPageable */ .LI)(transactions, (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_7__/* .createIndicator */ .sz)(indicator), transactions.length > 0 ? (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_7__/* .createNextIndicator */ .gT)(indicator, timeStamp?.toString()) : undefined);
    }
}
const DeBankHistory = new DeBankHistoryAPI();


/***/ }),

/***/ 10663:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $1: () => (/* binding */ DEBANK_OPEN_API),
/* harmony export */   El: () => (/* binding */ CHIAN_ID_TO_DEBANK_CHAIN_MAP),
/* harmony export */   vO: () => (/* binding */ DEBANK_CHAIN_TO_CHAIN_ID_MAP)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24770);

const DEBANK_OPEN_API = 'https://debank-proxy.r2d2.to';
/**
 * Collect from https://docs.cloud.debank.com/en/readme/api-pro-reference/chain#returns-1
 * but they might not list all, for example, missing 369:pls
 */ const DEBANK_CHAIN_TO_CHAIN_ID_MAP = {
    arb: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Arbitrum,
    astar: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Astar,
    aurora: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Aurora,
    avax: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Avalanche,
    boba: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Boba,
    brise: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Brise,
    bsc: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.BSC,
    btt: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.BitTorrent,
    canto: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Canto,
    celo: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Celo,
    cfx: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Conflux,
    cro: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Cronos,
    dfk: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.DFK,
    doge: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Doge,
    eth: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Mainnet,
    evmos: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Evmos,
    ftm: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Fantom,
    fuse: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Fuse,
    heco: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.HuobiEco,
    hmy: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Harmony,
    iotx: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.IoTex,
    kava: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Kava,
    kcc: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Kcc,
    klay: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Klaytn,
    mada: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Milkomeda,
    matic: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Matic,
    metis: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Metis,
    mobm: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Moonbeam,
    movr: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Moonriver,
    nova: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Arbitrum_Nova,
    okt: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.OKXChain,
    op: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Optimism,
    palm: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Palm,
    pls: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Pulse,
    rsk: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.RSK,
    sbch: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.SmartBitcoinCash,
    sdn: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Shiden,
    sgb: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.SongbirdCanary,
    step: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Step,
    swm: 73772,
    tlos: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Telos,
    wan: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Wanchain,
    xdai: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.xDai,
    base: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Base,
    scrl: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .ChainId */ .a_.Scroll
};
/**
 * Collect from https://docs.cloud.debank.com/en/readme/api-pro-reference/chain#returns-1
 * but they might not list all, for example, missing 369:pls
 *
 * Rabby use this map as well.
 */ const CHIAN_ID_TO_DEBANK_CHAIN_MAP = {
    1: 'eth',
    10: 'op',
    19: 'sgb',
    25: 'cro',
    30: 'rsk',
    40: 'tlos',
    56: 'bsc',
    66: 'okt',
    100: 'xdai',
    122: 'fuse',
    128: 'heco',
    137: 'matic',
    199: 'btt',
    250: 'ftm',
    288: 'boba',
    321: 'kcc',
    336: 'sdn',
    369: 'pls',
    592: 'astar',
    888: 'wan',
    1030: 'cfx',
    1088: 'metis',
    1234: 'step',
    1284: 'mobm',
    1285: 'movr',
    2000: 'doge',
    2001: 'mada',
    2222: 'kava',
    4689: 'iotx',
    7700: 'canto',
    8217: 'klay',
    8453: 'base',
    9001: 'evmos',
    10000: 'sbch',
    32520: 'brise',
    42161: 'arb',
    42170: 'nova',
    42220: 'celo',
    43114: 'avax',
    53935: 'dfk',
    534352: 'scrl',
    73772: 'swm',
    1313161554: 'aurora',
    1666600000: 'hmy',
    11297108109: 'palm'
};


/***/ }),

/***/ 11678:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   M5: () => (/* binding */ resolveDeBankAssetIdReversed),
/* harmony export */   mT: () => (/* binding */ formatTransactions),
/* harmony export */   y5: () => (/* binding */ formatAssets)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43434);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(70358);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(72845);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(47469);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(41487);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(65327);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(24770);
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(62649);
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(29763);
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(74765);
/* harmony import */ var _Web3_EVM_apis_ResolverAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(66979);
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(12049);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(10663);






function formatAssets(data) {
    const resolveNativeAddress = (0,lodash_es__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)((chainId)=>{
        try {
            // chainId is beyond builtin chainIds
            return _Web3_EVM_apis_ResolverAPI_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainResolver */ .iv.nativeCurrency(chainId)?.address || _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ZERO_ADDRESS */ .r;
        } catch  {
            return _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ZERO_ADDRESS */ .r;
        }
    });
    return data.filter((x)=>_constants_js__WEBPACK_IMPORTED_MODULE_3__/* .DEBANK_CHAIN_TO_CHAIN_ID_MAP */ .vO[x.chain]).map((x)=>{
        const chainId = _constants_js__WEBPACK_IMPORTED_MODULE_3__/* .DEBANK_CHAIN_TO_CHAIN_ID_MAP */ .vO[x.chain];
        const address = x.id in _constants_js__WEBPACK_IMPORTED_MODULE_3__/* .DEBANK_CHAIN_TO_CHAIN_ID_MAP */ .vO ? resolveNativeAddress(chainId) : x.id;
        return {
            id: x.id,
            address: (0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_4__/* .formatEthereumAddress */ .j8)(address),
            chainId,
            type: _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_5__/* .TokenType */ .iv.Fungible,
            schema: (0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__/* .isNativeTokenAddress */ .qw)(address) ? _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__/* .SchemaType */ .XQ.Native : _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__/* .SchemaType */ .XQ.ERC20,
            decimals: x.decimals,
            name: x.name.replace('(PoS)', ''),
            symbol: x.symbol,
            balance: (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_8__/* .rightShift */ .pu)(x.amount, x.decimals).toFixed(),
            price: {
                [_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_5__/* .CurrencyType */ .V2.USD]: (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_8__/* .toFixed */ .FH)(x.price)
            },
            value: {
                [_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_5__/* .CurrencyType */ .V2.USD]: (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_8__/* .multipliedBy */ .$q)(x.price ?? 0, x.amount).toFixed()
            },
            logoURL: x.logo_url
        };
    });
}
function toTxAsset({ token_id, amount }, chainId, token_dict, direction) {
    const token = token_dict[token_id];
    // token_dict might not contain value to current token_id
    if (!token) return null;
    const schema = token.decimals ? (0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__/* .isValidAddress */ .At)(token.id) ? // for native token, token.id is symbol. e.g `matic` for Matic
    _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__/* .SchemaType */ .XQ.ERC20 : _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__/* .SchemaType */ .XQ.Native : token.is_erc721 ? _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__/* .SchemaType */ .XQ.ERC721 : _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__/* .SchemaType */ .XQ.ERC1155;
    if (false) {}
    const fallbackName = token.is_erc1155 || token.is_erc721 ? 'Unknown NFT' : 'Unknown Token';
    return {
        id: token_id,
        chainId,
        type: token.decimals ? _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_5__/* .TokenType */ .iv.Fungible : _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_5__/* .TokenType */ .iv.NonFungible,
        schema,
        name: token.name || token.collection?.name || fallbackName,
        symbol: token.optimized_symbol || token.collection?.name || fallbackName,
        address: token.decimals ? token_id : token.contract_id,
        decimals: token.decimals || 1,
        direction,
        amount: amount?.toString(),
        logoURI: token.logo_url
    };
}
/** 0: failed 1: succeed */ function normalizeTxStatus(status) {
    const map = {
        0: _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_5__.TransactionStatusType.FAILED,
        1: _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_5__.TransactionStatusType.SUCCEED
    };
    return map[status];
}
function formatTransactions({ cate_dict, history_list, token_dict }, ownerAddress) {
    const transactions = history_list.map((transaction)=>{
        let txType = transaction.tx?.name;
        if (!txType && !(0,lodash_es__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(transaction.cate_id)) {
            txType = cate_dict[transaction.cate_id].name;
        } else if (txType === '') {
            txType = 'contract interaction';
        }
        const chainId = _constants_js__WEBPACK_IMPORTED_MODULE_3__/* .DEBANK_CHAIN_TO_CHAIN_ID_MAP */ .vO[transaction.chain];
        if (!chainId) return;
        if ((0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_10__/* .isSameAddress */ .W)(transaction.sends[0]?.to_addr, _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ZERO_ADDRESS */ .r)) {
            txType = 'burn';
        }
        const isIn = transaction.cate_id === 'receive';
        const from = transaction.tx?.from_addr ?? (isIn ? transaction.other_addr : '');
        const to = isIn ? ownerAddress : transaction.other_addr;
        const { SEND, RECEIVE } = _types_js__WEBPACK_IMPORTED_MODULE_11__.DebankTransactionDirection;
        return {
            id: transaction.id,
            chainId,
            type: txType,
            cateType: transaction.cate_id,
            cateName: transaction.cate_id ? cate_dict[transaction.cate_id].name : transaction.tx?.name || 'Contract Interaction',
            timestamp: transaction.time_at * 1000,
            from,
            to,
            status: normalizeTxStatus(transaction.tx?.status),
            assets: (0,lodash_es__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .Z)([
                ...transaction.sends.map((asset)=>toTxAsset(asset, chainId, token_dict, SEND)),
                ...transaction.receives.map((asset)=>toTxAsset(asset, chainId, token_dict, RECEIVE))
            ]),
            fee: transaction.tx ? {
                eth: transaction.tx.eth_gas_fee?.toString(),
                usd: transaction.tx.usd_gas_fee?.toString()
            } : undefined,
            isScam: transaction.is_scam
        };
    });
    return (0,lodash_es__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .Z)(transactions);
}
function resolveDeBankAssetIdReversed(id) {
    if (id === 'bnb') return 'bsc';
    if (id === 'Conflux') return 'cfx';
    return id;
}


/***/ }),

/***/ 12049:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DebankTransactionDirection: () => (/* binding */ DebankTransactionDirection)
/* harmony export */ });
var DebankTransactionDirection/**
 * Collect from https://docs.cloud.debank.com/en/readme/api-pro-reference/chain#returns-1
 */ /** Only NFT */ /** Only NFT */ /** e.g. 'matic:0x813de35e46a7d3a6ea1df82414dfadd5b283d9a9' */ // Note: this is JSON string
// Note: 0 - failed, 1 - succeed
/** Could be chain or token address */ /**
 * Legacy gas response
 */ ;
(function(DebankTransactionDirection) {
    DebankTransactionDirection["SEND"] = 'send';
    DebankTransactionDirection["RECEIVE"] = 'receive';
})(DebankTransactionDirection || (DebankTransactionDirection = {}));


/***/ }),

/***/ 68513:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  n: () => (/* binding */ ENS)
});

// EXTERNAL MODULE: ./packages/web3-shared/evm/src/types/index.ts
var types = __webpack_require__(24770);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/attemptUntil.ts
var attemptUntil = __webpack_require__(92358);
// EXTERNAL MODULE: ./packages/shared-base/src/types/NameService.ts
var NameService = __webpack_require__(91461);
// EXTERNAL MODULE: ./packages/web3-providers/src/Chainbase/apis/DomainAPI.ts
var DomainAPI = __webpack_require__(30685);
// EXTERNAL MODULE: ./node_modules/.pnpm/urlcat@3.1.0_patch_hash=5r5xyq4zgcnqugwsrx4lxq2i4e/node_modules/urlcat/dist/index.mjs
var dist = __webpack_require__(78757);
;// CONCATENATED MODULE: ./packages/web3-providers/src/R2D2/constants.ts
const ENS_ROOT_URL = 'https://ens-reverse-lookup.r2d2.to/ens/';

// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/fetchJSON.ts
var fetchJSON = __webpack_require__(11834);
;// CONCATENATED MODULE: ./packages/web3-providers/src/R2D2/apis/DomainAPI.ts



class R2D2DomainAPI {
    lookup(chainId, name) {
        throw new Error('Method not implemented.');
    }
    async reverse(chainId, address) {
        const response = await (0,fetchJSON/* fetchJSON */.ZV)((0,dist/* default */.ZP)(ENS_ROOT_URL, address));
        return response?.reverseRecord;
    }
}
const R2D2Domain = new R2D2DomainAPI();

// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/head.js
var head = __webpack_require__(81755);
// EXTERNAL MODULE: ./packages/web3-providers/src/TheGraph/constants.ts
var constants = __webpack_require__(66894);
;// CONCATENATED MODULE: ./packages/web3-providers/src/TheGraph/apis/DomainAPI.ts



class TheGraphDomainAPI {
    async lookup(chainId, name) {
        const response = await (0,fetchJSON/* fetchJSON */.ZV)(constants/* API_URL */.T5, {
            method: 'POST',
            body: JSON.stringify({
                query: `{
                    domains(where: { name: "${name}" }) {
                        name
                        labelName
                        resolvedAddress {
                          id
                        }
                    }
                  }`
            })
        });
        return (0,head/* default */.Z)(response.data.domains)?.resolvedAddress?.id;
    }
    async reverse(chainId, address) {
        const response = await (0,fetchJSON/* fetchJSON */.ZV)(constants/* API_URL */.T5, {
            method: 'POST',
            body: JSON.stringify({
                query: `{
                    domains(where: { owner: "${address}", resolvedAddress: "${address}" }, orderBy: createdAt) {
                      name
                      labelName
                    }
                  }`
            })
        });
        return (0,head/* default */.Z)(response.data.domains)?.name;
    }
}
const TheGraphDomain = new TheGraphDomainAPI();

;// CONCATENATED MODULE: ./packages/web3-providers/src/ENS/index.ts






class ENS_API {
    id = NameService/* NameServiceID */.S.ENS;
    async lookup(name) {
        return (0,attemptUntil/* attemptUntil */.C)([
            DomainAPI/* ChainbaseDomain */.n,
            R2D2Domain,
            TheGraphDomain
        ].map((x)=>()=>x.lookup(types/* ChainId */.a_.Mainnet, name)), undefined);
    }
    async reverse(address) {
        return (0,attemptUntil/* attemptUntil */.C)([
            DomainAPI/* ChainbaseDomain */.n,
            R2D2Domain,
            TheGraphDomain
        ].map((x)=>()=>x.reverse(types/* ChainId */.a_.Mainnet, address)), undefined);
    }
}
const ENS = new ENS_API();


/***/ }),

/***/ 87904:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E: () => (/* binding */ Firefly)
/* harmony export */ });
/* harmony import */ var urlcat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78757);
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52033);
/* harmony import */ var _helpers_fetchJSON_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11834);



const BASE_URL = 'https://api.dimension.im/v1';
const TWITTER_HANDLER_VERIFY_URL = 'https://twitter-handler-proxy.r2d2.to';
class Firefly {
    static async getLensByTwitterId(twitterHandle, isVerified = true) {
        if (!twitterHandle) return _masknet_shared_base__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_LIST */ .rP;
        const result = await (0,_helpers_fetchJSON_js__WEBPACK_IMPORTED_MODULE_2__/* .fetchJSON */ .ZV)((0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(BASE_URL, '/account/lens', {
            twitterHandle,
            isVerified
        }));
        if (result.code !== 200) return _masknet_shared_base__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_LIST */ .rP;
        return result.data;
    }
    static async verifyTwitterHandleByAddress(address, handle) {
        if (!handle || !address) return false;
        const response = await (0,_helpers_fetchJSON_js__WEBPACK_IMPORTED_MODULE_2__/* .fetchJSON */ .ZV)((0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(TWITTER_HANDLER_VERIFY_URL, '/v1/relation/handles', {
            wallet: address.toLowerCase(),
            isVerified: true
        }));
        if ('error' in response) return false;
        return response.data.includes(handle);
    }
}


/***/ }),

/***/ 63502:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Q: () => (/* binding */ Fuse)
/* harmony export */ });
/* harmony import */ var fuse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(32180);

class Fuse {
    static create(items, options, index) {
        return new fuse_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(items, options, index);
    }
}


/***/ }),

/***/ 76836:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   q: () => (/* binding */ FuseCoin)
/* harmony export */ });
/* harmony import */ var fuse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(32180);

class FuseCoin {
    static create(items) {
        return new fuse_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(items, {
            keys: [
                {
                    name: 'name',
                    weight: 0.8
                },
                {
                    name: 'symbol',
                    weight: 0.3
                }
            ],
            isCaseSensitive: false,
            ignoreLocation: true,
            shouldSort: true,
            threshold: 0,
            minMatchCharLength: 3
        });
    }
}


/***/ }),

/***/ 23302:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   T: () => (/* binding */ GO_PLUS_LABS_ROOT_URL),
/* harmony export */   h: () => (/* binding */ INFINITE_VALUE)
/* harmony export */ });
const GO_PLUS_LABS_ROOT_URL = 'https://gopluslabs.r2d2.to';
const INFINITE_VALUE = 10000000000000;


/***/ }),

/***/ 58291:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  R: () => (/* binding */ Lens)
});

// EXTERNAL MODULE: ./packages/shared-base/src/types/NameService.ts
var NameService = __webpack_require__(91461);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/isSameAddress.ts
var isSameAddress = __webpack_require__(74765);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/address.ts
var helpers_address = __webpack_require__(65327);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/head.js
var head = __webpack_require__(81755);
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/fetchJSON.ts
var fetchJSON = __webpack_require__(11834);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Lens/constants.ts
const LENS_ROOT_API = 'https://api.lens.dev/';

;// CONCATENATED MODULE: ./packages/web3-providers/src/Lens/index.ts






class Lens {
    static id = NameService/* NameServiceID */.S.Lens;
    static async getProfileByHandle(handle) {
        const { data } = await (0,fetchJSON/* fetchJSON */.ZV)(LENS_ROOT_API, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                query: /* GraphQL */ `
                    query Profile($handle: Handle) {
                        profile(request: { handle: $handle }) {
                            id
                            handle
                            ownedBy
                            name
                            picture {
                                ... on MediaSet {
                                    original {
                                        url
                                    }
                                }
                            }
                            stats {
                                totalFollowers
                                totalFollowing
                            }
                            followModule {
                                ... on FeeFollowModuleSettings {
                                    type
                                    contractAddress
                                    amount {
                                        asset {
                                            name
                                            symbol
                                            decimals
                                            address
                                        }
                                        value
                                    }
                                    recipient
                                }
                                ... on ProfileFollowModuleSettings {
                                    type
                                }
                                ... on RevertFollowModuleSettings {
                                    type
                                }
                            }
                        }
                    }
                `,
                variables: {
                    handle
                }
            })
        });
        return data.profile;
    }
    static async queryDefaultProfileByAddress(address) {
        if (!(0,helpers_address/* isValidAddress */.At)(address)) return;
        const { data } = await (0,fetchJSON/* fetchJSON */.ZV)(LENS_ROOT_API, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                query: `query DefaultProfile {
                  defaultProfile(request: { ethereumAddress: "${address}"}) {
                    id
                    name
                    ownedBy
                    handle
                    picture {
                      ... on MediaSet {
                        original {
                          url
                          mimeType
                        }
                      }
                    }
                    stats {
                      totalFollowers
                      totalFollowing
                    }
                    followModule {
                      ... on FeeFollowModuleSettings {
                        type
                        contractAddress
                        amount {
                          asset {
                            name
                            symbol
                            decimals
                            address
                          }
                          value
                        }
                        recipient
                      }
                      ... on ProfileFollowModuleSettings {
                       type
                      }
                      ... on RevertFollowModuleSettings {
                       type
                      }
                    }
                  }
                }`
            })
        });
        return data.defaultProfile;
    }
    static async reverse(address) {
        if (!(0,helpers_address/* isValidAddress */.At)(address)) return;
        const { data } = await (0,fetchJSON/* fetchJSON */.ZV)(LENS_ROOT_API, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                query: /* GraphQL */ `
                    query handleOfDefaultProfile($address: EthereumAddress!) {
                        defaultProfile(request: { ethereumAddress: $address }) {
                            id
                            name
                            handle
                        }
                    }
                `,
                variables: {
                    address
                }
            })
        });
        return data.defaultProfile?.handle;
    }
    static async queryProfilesByAddress(address) {
        if (!(0,helpers_address/* isValidAddress */.At)(address)) return [];
        const { data } = await (0,fetchJSON/* fetchJSON */.ZV)(LENS_ROOT_API, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                query: `query Profiles {
                profiles(request: { ownedBy: ["${address}"], limit: 10 }) {
                  items {
                    id
                    name
                    picture {
                      ... on MediaSet {
                        original {
                          url
                          mimeType
                        }
                      }
                    }
                    handle
                    ownedBy
                    stats {
                      totalFollowers
                      totalFollowing

                    }
                    followModule {
                      ... on FeeFollowModuleSettings {
                        type
                        amount {
                          asset {
                            symbol
                            name
                            decimals
                            address
                          }
                          value
                        }
                        recipient
                      }
                      ... on ProfileFollowModuleSettings {
                       type
                      }
                      ... on RevertFollowModuleSettings {
                       type
                      }
                    }
                  }
                }
              }`
            })
        });
        return data.profiles.items;
    }
    static async queryFollowStatus(address, profileId) {
        if (!(0,helpers_address/* isValidAddress */.At)(address) || !profileId) return false;
        const { data } = await (0,fetchJSON/* fetchJSON */.ZV)(LENS_ROOT_API, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                query: `query DoesFollow {
                    doesFollow(request: {
                      followInfos: [
                        {
                          followerAddress: "${address}",
                          profileId: "${profileId}"
                        }
                      ]
                }) {
                  followerAddress
                  profileId
                  follows
                }
              }`
            })
        });
        if (!data.doesFollow.length) return false;
        const result = data.doesFollow.find((x)=>(0,isSameAddress/* isSameAddress */.W)(x.followerAddress, address));
        return result?.follows;
    }
    static async queryChallenge(address) {
        if (!(0,helpers_address/* isValidAddress */.At)(address)) return '';
        const { data } = await (0,fetchJSON/* fetchJSON */.ZV)(LENS_ROOT_API, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                query: `query Challenge {
                  challenge(request: { address: "${address}" }) {
                    text
                  }
                }`
            })
        });
        return data.challenge.text;
    }
    static async authenticate(address, signature) {
        if (!(0,helpers_address/* isValidAddress */.At)(address) || !signature) return;
        const { data } = await (0,fetchJSON/* fetchJSON */.ZV)(LENS_ROOT_API, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                query: `mutation Authenticate {
                  authenticate(
                    request: {
                      address: "${address}"
                      signature: "${signature}"
                    }
                  ) {
                    accessToken
                    refreshToken
                  }
                }
                `
            })
        });
        return data.authenticate;
    }
    static async refresh(refreshToken) {
        if (!refreshToken) return;
        const { data } = await (0,fetchJSON/* fetchJSON */.ZV)(LENS_ROOT_API, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                query: `mutation Refresh {
                  refresh(request: {
                    refreshToken: "${refreshToken}"
                  }) {
                    accessToken
                    refreshToken
                  }
                }
              `
            })
        });
        return data.refresh;
    }
    static async createFollowTypedData(profileId, options) {
        if (!profileId) return;
        let followModule = '';
        if (options.followModule?.profileFollowModule) {
            followModule = `followModule: { profileFollowModule: { profileId: "${options.followModule.profileFollowModule.profileId}" } }`;
        } else if (options.followModule?.feeFollowModule) {
            followModule = `followModule: {
              feeFollowModule: {
                amount: {
                   currency: "${options.followModule.feeFollowModule.currency}",
                   value: "${options.followModule.feeFollowModule.value}"
                }
              }
            }`;
        }
        const { data } = await (0,fetchJSON/* fetchJSON */.ZV)(LENS_ROOT_API, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-access-token': options?.token ? `Bearer ${options.token}` : ''
            },
            body: JSON.stringify({
                query: `mutation CreateFollowTypedData {
                      createFollowTypedData(
                        request: { follow: [{ profile: "${profileId}", ${followModule} }] }
                      ) {
                        id
                        expiresAt
                        typedData {
                          domain {
                            name
                            chainId
                            version
                            verifyingContract
                          }
                          types {
                            FollowWithSig {
                              name
                              type
                            }
                          }
                          value {
                            nonce
                            deadline
                            profileIds
                            datas
                          }
                        }
                      }
                    }
                  `
            })
        });
        return data.createFollowTypedData;
    }
    static async createUnfollowTypedData(profileId, options) {
        if (!profileId) return;
        const { data } = await (0,fetchJSON/* fetchJSON */.ZV)(LENS_ROOT_API, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-access-token': options?.token ? `Bearer ${options.token}` : ''
            },
            body: JSON.stringify({
                query: `mutation CreateUnfollowTypedData {
                      createUnfollowTypedData(request:{
                        profile: "${profileId}"
                      }) {
                        id
                        expiresAt
                        typedData {
                          types {
                            BurnWithSig {
                              name
                              type
                            }
                          }
                          domain {
                            version
                            chainId
                            name
                            verifyingContract
                          }
                          value {
                            nonce
                            deadline
                            tokenId
                          }
                        }
                      }
                    }
                `
            })
        });
        return data.createUnfollowTypedData;
    }
    static async followWithProxyAction(profileId, options) {
        if (!profileId) return;
        const { data } = await (0,fetchJSON/* fetchJSON */.ZV)(LENS_ROOT_API, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-access-token': options?.token ? `Bearer ${options.token}` : ''
            },
            body: JSON.stringify({
                query: `mutation ProxyAction {
                  proxyAction(request: { follow: { freeFollow: { profileId: "${profileId}" } } })
                }
                `
            })
        });
        return data.proxyAction;
    }
    static async queryProxyStatus(proxyActionId, options) {
        if (!proxyActionId) return;
        const { data } = await (0,fetchJSON/* fetchJSON */.ZV)(LENS_ROOT_API, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-access-token': options?.token ? `Bearer ${options.token}` : ''
            },
            body: JSON.stringify({
                query: `query ProxyStatus {
                      proxyActionStatus(proxyActionId: "${proxyActionId}") {
                        ... on ProxyActionError{
                          reason
                          lastKnownTxId
                          __typename
                        }
                        ... on ProxyActionStatusResult {
                          txHash
                          txId
                          status
                          __typename
                        }
                        ... on ProxyActionQueued {
                          queuedAt
                          __typename
                        }
                      }
                    }`
            })
        });
        return data.proxyActionStatus;
    }
    static async broadcast(id, signature, options) {
        if (!id || !options?.token || !signature) return;
        const { data } = await options.fetcher(LENS_ROOT_API, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-access-token': options?.token ? `Bearer ${options.token}` : ''
            },
            body: JSON.stringify({
                query: `mutation Broadcast {
                      broadcast(
                        request: {
                          id: "${id}"
                          signature: "${signature}"
                        }
                      ) {
                        ... on RelayerResult {
                          txHash
                          __typename
                        }
                        ... on RelayError {
                          reason
                          __typename
                        }
                        __typename
                      }
                    }
                    `
            })
        });
        return data.broadcast;
    }
    static async queryApprovedModuleAllowanceAmount(currency, options) {
        if (!options?.token) return;
        const { data } = await (0,fetchJSON/* fetchJSON */.ZV)(LENS_ROOT_API, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-access-token': options?.token ? `Bearer ${options.token}` : ''
            },
            body: JSON.stringify({
                query: `query ApprovedModuleAllowanceAmount {
              approvedModuleAllowanceAmount(request: { currencies: "${currency}", followModules: [FeeFollowModule] }) {
                currency
                module
                allowance
                contractAddress
              }
            }`
            })
        });
        return (0,head/* default */.Z)(data.approvedModuleAllowanceAmount);
    }
    static async queryTransactionPublicationId(txId) {
        const result = await (0,fetchJSON/* fetchJSON */.ZV)(LENS_ROOT_API, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                query: /* GraphQL */ `
                    query TransactionPublicationId($txId: String!) {
                        dataAvailabilityTransaction(request: { id: $txId }) {
                            ... on DataAvailabilityPost {
                                ...DAPostFields
                                __typename
                            }
                        }
                    }
                    fragment DAPostFields on DataAvailabilityPost {
                        publicationId
                        __typename
                    }
                `,
                variables: {
                    txId
                }
            })
        });
        return result?.data?.dataAvailabilityTransaction?.publicationId;
    }
}


/***/ }),

/***/ 33215:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  X: () => (/* binding */ LooksRare)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/urlcat@3.1.0_patch_hash=5r5xyq4zgcnqugwsrx4lxq2i4e/node_modules/urlcat/dist/index.mjs
var dist = __webpack_require__(78757);
// EXTERNAL MODULE: ./node_modules/.pnpm/date-fns@2.30.0/node_modules/date-fns/esm/fromUnixTime/index.js
var fromUnixTime = __webpack_require__(75483);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/specs/index.ts
var specs = __webpack_require__(62649);
// EXTERNAL MODULE: ./packages/shared-base/src/Pageable/index.ts
var Pageable = __webpack_require__(38645);
// EXTERNAL MODULE: ./packages/shared-base/src/constants.ts
var constants = __webpack_require__(52033);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/types/index.ts
var types = __webpack_require__(24770);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/token.ts
var token = __webpack_require__(48289);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/formatter.ts
var formatter = __webpack_require__(41487);
;// CONCATENATED MODULE: ./packages/web3-providers/src/LooksRare/constants.ts
const LOOKSRARE_API_URL = 'https://api.looksrare.org';
const LOOKSRARE_PAGE_SIZE = 20;

// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/fetchJSON.ts
var fetchJSON = __webpack_require__(11834);
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/getPaymentToken.ts
var getPaymentToken = __webpack_require__(34936);
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/resolveActivityType.ts
var resolveActivityType = __webpack_require__(15219);
;// CONCATENATED MODULE: ./packages/web3-providers/src/LooksRare/utils.ts

function isSupportedChainId(chainId) {
    return chainId === types/* ChainId */.a_.Mainnet;
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/LooksRare/index.ts










async function fetchFromLooksRare(chainId, url) {
    if (![
        types/* ChainId */.a_.Mainnet,
        types/* ChainId */.a_.Rinkeby
    ].includes(chainId)) return;
    return (0,fetchJSON/* fetchJSON */.ZV)((0,dist/* default */.ZP)(LOOKSRARE_API_URL, url), {
        method: 'GET'
    });
}
function createAssetLink(chainId, address, tokenId) {
    return (0,dist/* default */.ZP)('https://looksrare.org/collections/:address/:tokenId', {
        address,
        tokenId
    });
}
function createNonFungibleAssetFromToken(chainId, token) {
    if (!token) return;
    const shared = {
        chainId,
        name: token.collection?.name ?? 'Unknown Token',
        symbol: token.collection?.symbol ?? 'UNKNOWN',
        address: token.collectionAddress,
        description: token.collection?.description,
        schema: token.collection?.type === 'ERC1155' ? types/* SchemaType */.XQ.ERC1155 : types/* SchemaType */.XQ.ERC721
    };
    return {
        id: token.id.toString(),
        chainId,
        type: specs/* TokenType */.iv.NonFungible,
        schema: shared.schema,
        address: token.collectionAddress,
        tokenId: token.tokenId,
        ownerId: token.collection?.owner,
        contract: {
            ...shared,
            owner: token.collection?.owner
        },
        metadata: {
            ...shared,
            imageURL: token.imageURI,
            mediaURL: token.imageURI
        },
        collection: {
            ...shared,
            slug: token.collection?.name ?? '',
            verified: token.collection?.isVerified
        },
        link: createAssetLink(chainId, token.collectionAddress, token.tokenId),
        creator: {
            address: token.collection?.owner
        },
        owner: {
            address: token.collection?.owner
        },
        traits: token.attributes.map((x)=>({
                type: x.displayType,
                value: x.value
            })),
        source: specs/* SourceType */.PO.LooksRare
    };
}
function createNonFungibleContractFromCollection(chainId, collection) {
    if (!collection) return;
    return {
        chainId,
        name: collection.name ?? 'Unknown Token',
        symbol: collection.symbol ?? 'UNKNOWN',
        address: collection.address,
        schema: collection.type === 'ERC1155' ? types/* SchemaType */.XQ.ERC1155 : types/* SchemaType */.XQ.ERC721,
        owner: collection.owner,
        source: specs/* SourceType */.PO.LooksRare
    };
}
function createNonFungibleEventFromEvent(chainId, event) {
    return {
        id: event.id.toString(),
        chainId,
        type: (0,resolveActivityType/* resolveActivityType */.G)(event.type),
        assetPermalink: (0,dist/* default */.ZP)('https://looksrare.org/collections/:address/:tokenId', {
            address: event.token?.collectionAddress ?? event.collection?.address,
            tokenId: event.token?.tokenId
        }),
        assetSymbol: event.collection?.symbol,
        quantity: '1',
        hash: event.hash,
        from: {
            address: event.from
        },
        to: {
            address: event.to
        },
        timestamp: Number.parseInt(event.createdAt, 10) * 1000,
        source: specs/* SourceType */.PO.LooksRare
    };
}
function createNonFungibleTokenOrderFromOrder(chainId, order) {
    const paymentToken = (0,getPaymentToken/* getPaymentToken */.W)(chainId, {
        address: order.currency
    });
    return {
        id: order.hash,
        chainId,
        quantity: order.amounts.length.toString(),
        hash: order.hash,
        side: order.quoteType === 1 ? specs/* OrderSide */.oU.Sell : specs/* OrderSide */.oU.Buy,
        assetPermalink: (0,dist/* default */.ZP)('https://looksrare.org/collections/:address/:tokenId', {
            address: order.collection,
            tokenId: order.itemIds[0]
        }),
        maker: {
            address: order.signer
        },
        createdAt: (0,fromUnixTime/* default */.Z)(order.startTime).getTime(),
        expiredAt: (0,fromUnixTime/* default */.Z)(order.endTime).getTime(),
        priceInToken: {
            amount: order.price,
            token: paymentToken ?? (0,token/* createERC20Token */.wY)(chainId, order.currency)
        },
        source: specs/* SourceType */.PO.LooksRare
    };
}
class LooksRareAPI {
    async getAsset(address, tokenId, { chainId = types/* ChainId */.a_.Mainnet } = {}) {
        if (!isSupportedChainId(chainId)) return;
        const response = await fetchFromLooksRare(chainId, (0,dist/* default */.ZP)('/api/v1/tokens', {
            collection: address,
            tokenId
        }));
        return createNonFungibleAssetFromToken(chainId, response?.data);
    }
    async getAssets(account, options) {
        throw new Error('Method not implemented.');
    }
    async getContract(address, { chainId = types/* ChainId */.a_.Mainnet } = {}) {
        if (!isSupportedChainId(chainId)) return;
        const response = await fetchFromLooksRare(chainId, address);
        return createNonFungibleContractFromCollection(chainId, response?.data);
    }
    async getEvents(address, tokenId, { chainId = types/* ChainId */.a_.Mainnet, indicator } = {}) {
        if (!isSupportedChainId(chainId)) return (0,Pageable/* createPageable */.LI)(constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        const response = await fetchFromLooksRare(chainId, (0,dist/* default */.ZP)('/api/v1/events', {
            collection: address,
            tokenId,
            pagination: indicator ? {
                first: indicator.index * LOOKSRARE_PAGE_SIZE,
                cursor: indicator.id
            } : undefined
        }));
        if (!response?.data.length) return (0,Pageable/* createPageable */.LI)(constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        const events = response.data.map((x)=>createNonFungibleEventFromEvent(chainId, x));
        return (0,Pageable/* createPageable */.LI)(events, (0,Pageable/* createIndicator */.sz)(indicator), events.length ? (0,Pageable/* createNextIndicator */.gT)(indicator) : undefined);
    }
    async getStats(address, { chainId = types/* ChainId */.a_.Mainnet } = {}) {
        if (!isSupportedChainId(chainId)) return;
        const response = await fetchFromLooksRare(chainId, (0,dist/* default */.ZP)('/api/v1/collections/stats', {
            address
        }));
        const stats = response?.data;
        if (!stats) return;
        return {
            count24h: stats.count24h,
            volume24h: (0,formatter/* formatWeiToEther */.yp)(stats.volume24h).toNumber(),
            floorPrice: (0,formatter/* formatWeiToEther */.yp)(stats.floorPrice).toNumber()
        };
    }
    async getOrders(address, tokenId, side, { chainId = types/* ChainId */.a_.Mainnet, indicator } = {}) {
        if (!isSupportedChainId(chainId)) return (0,Pageable/* createPageable */.LI)(constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        const response = await fetchFromLooksRare(chainId, (0,dist/* default */.ZP)('/api/v2/orders', {
            // For ask (aka. listing) set 1. For bid (aka. offer) set 0.
            quoteType: side === specs/* OrderSide */.oU.Sell ? 1 : 0,
            collection: address,
            itemId: tokenId,
            pagination: indicator ? JSON.stringify({
                first: indicator.index * LOOKSRARE_PAGE_SIZE
            }) : undefined,
            sort: 'PRICE_DESC'
        }));
        if (!response?.data.length) return (0,Pageable/* createPageable */.LI)(constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        const orders = response.data.map((x)=>createNonFungibleTokenOrderFromOrder(chainId, x));
        return (0,Pageable/* createPageable */.LI)(orders, (0,Pageable/* createIndicator */.sz)(indicator), orders.length ? (0,Pageable/* createNextIndicator */.gT)(indicator) : undefined);
    }
    async getOffers(address, tokenId, options) {
        return this.getOrders(address, tokenId, specs/* OrderSide */.oU.Buy, options);
    }
    async getListings(address, tokenId, options) {
        return this.getOrders(address, tokenId, specs/* OrderSide */.oU.Sell, options);
    }
}
const LooksRare = new LooksRareAPI();


/***/ }),

/***/ 9766:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  I: () => (/* binding */ MagicEden)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/urlcat@3.1.0_patch_hash=5r5xyq4zgcnqugwsrx4lxq2i4e/node_modules/urlcat/dist/index.mjs
var dist = __webpack_require__(78757);
// EXTERNAL MODULE: ./packages/shared-base/src/Pageable/index.ts
var Pageable = __webpack_require__(38645);
// EXTERNAL MODULE: ./packages/shared-base/src/constants.ts
var constants = __webpack_require__(52033);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/specs/index.ts
var specs = __webpack_require__(62649);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/resolver.ts
var resolver = __webpack_require__(53007);
// EXTERNAL MODULE: ./packages/web3-shared/solana/src/types.ts
var types = __webpack_require__(97834);
// EXTERNAL MODULE: ./packages/web3-shared/solana/src/helpers/address.ts + 2 modules
var helpers_address = __webpack_require__(97470);
;// CONCATENATED MODULE: ./packages/web3-providers/src/MagicEden/constants.ts
const MAGIC_EDEN_API_URL = 'https://api-mainnet.magiceden.io';

// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/fetchJSON.ts
var fetchJSON = __webpack_require__(11834);
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/getAssetFullName.ts
var getAssetFullName = __webpack_require__(28289);
;// CONCATENATED MODULE: ./packages/web3-providers/src/MagicEden/index.ts







async function fetchFromMagicEden(chainId, path) {
    if (chainId !== types/* ChainId */.a_.Mainnet) return;
    const url = (0,dist/* default */.ZP)(MAGIC_EDEN_API_URL, path);
    return (0,fetchJSON/* fetchJSON */.ZV)(url, {
        method: 'GET',
        headers: {
            Accept: 'application/json'
        }
    });
}
function createNFTToken(chainId, token, collection) {
    return {
        id: token.mintAddress,
        chainId,
        ownerId: token.owner,
        type: specs/* TokenType */.iv.NonFungible,
        schema: types/* SchemaType */.XQ.NonFungible,
        tokenId: '',
        address: token.mintAddress,
        metadata: {
            chainId,
            name: (0,getAssetFullName/* getAssetFullName */.q)(token.mintAddress, collection.name, token.name, ''),
            symbol: collection.symbol,
            description: collection.description,
            imageURL: token.image || token.animationUrl,
            mediaURL: token.animationUrl || token.image
        },
        contract: {
            chainId,
            schema: types/* SchemaType */.XQ.NonFungible,
            address: token.mintAddress,
            name: collection.name,
            symbol: collection.symbol
        },
        collection: {
            chainId,
            name: token.collection,
            slug: token.collection,
            description: collection.description,
            iconURL: collection.image,
            verified: false,
            createdAt: new Date(collection.createdAt).getTime()
        }
    };
}
function createNFTCollection(collection) {
    return {
        chainId: types/* ChainId */.a_.Mainnet,
        name: collection.name,
        symbol: collection.symbol,
        address: '',
        schema: types/* SchemaType */.XQ.NonFungible,
        logoURL: collection.image,
        iconURL: collection.image,
        source: specs/* SourceType */.PO.MagicEden
    };
}
class MagicEdenAPI {
    async getToken(address, tokenMint, { chainId = types/* ChainId */.a_.Mainnet } = {}) {
        if (!(0,helpers_address/* isValidChainId */.JW)(chainId)) return;
        const token = await fetchFromMagicEden(chainId, (0,dist/* default */.ZP)('/v2/tokens/:mint_address', {
            mint_address: tokenMint
        }));
        if (!token) return;
        const collection = await fetchFromMagicEden(chainId, (0,dist/* default */.ZP)('/collections/:symbol', {
            symbol: token?.collection
        }));
        if (!collection) return;
        return createNFTToken(chainId, token, collection);
    }
    async getAsset(address, tokenMint, { chainId = types/* ChainId */.a_.Mainnet } = {}) {
        if (!(0,helpers_address/* isValidChainId */.JW)(chainId)) return;
        const [token, auction, nft] = await Promise.all([
            this.getToken(address, tokenMint, {
                chainId
            }),
            fetchFromMagicEden(chainId, (0,dist/* default */.ZP)('/auctions/token-mint/:mint_address', {
                mint_address: tokenMint
            })),
            fetchFromMagicEden(chainId, (0,dist/* default */.ZP)('/rpc/getNFTByMintAddress/:mint_address', {
                mint_address: tokenMint
            }))
        ]);
        if (!token) return;
        return {
            ...token,
            link: (0,dist/* default */.ZP)('https://magiceden.io/item-details/:mint_address', {
                mint_address: tokenMint
            }),
            creator: nft?.creators?.length ? {
                address: nft.creators[0].address
            } : undefined,
            owner: {
                address: nft?.owner
            },
            traits: auction?.attributes.map((x)=>({
                    type: x.trait_type,
                    value: x.value
                })),
            source: specs/* SourceType */.PO.MagicEden
        };
    }
    async getAssets(owner, { chainId = types/* ChainId */.a_.Mainnet, indicator } = {}) {
        if (!(0,helpers_address/* isValidChainId */.JW)(chainId)) return (0,Pageable/* createPageable */.LI)(constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        if ((indicator?.index ?? 0) > 0) return (0,Pageable/* createPageable */.LI)(constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        const response = await fetchFromMagicEden(chainId, (0,dist/* default */.ZP)('/rpc/getNFTsByOwner/:owner', {
            owner
        }));
        const data = response?.results.map((token)=>{
            return {
                id: token.mintAddress,
                chainId,
                link: (0,dist/* default */.ZP)('https://magiceden.io/item-details/:mint_address', {
                    mint_address: token.mintAddress
                }),
                type: specs/* TokenType */.iv.NonFungible,
                schema: types/* SchemaType */.XQ.NonFungible,
                tokenId: '',
                address: token.mintAddress,
                metadata: {
                    chainId,
                    name: (0,getAssetFullName/* getAssetFullName */.q)(token.mintAddress, token.collectionName, token?.title, ''),
                    symbol: '',
                    imageURL: (0,resolver/* resolveIPFS_URL */.mg)(token.img),
                    mediaURL: (0,resolver/* resolveIPFS_URL */.mg)(token.img),
                    owner: token.owner
                },
                contract: {
                    chainId,
                    schema: types/* SchemaType */.XQ.NonFungible,
                    address: token.mintAddress,
                    name: token.collectionName,
                    symbol: ''
                },
                collection: {
                    chainId,
                    name: token.collectionName ?? token?.collectionTitle,
                    slug: '',
                    description: '',
                    iconURL: '',
                    verified: false
                },
                source: specs/* SourceType */.PO.MagicEden
            };
        });
        return (0,Pageable/* createPageable */.LI)(data ?? constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
    }
    async getContract(tokenMint, { chainId = types/* ChainId */.a_.Mainnet } = {}) {
        if (!(0,helpers_address/* isValidChainId */.JW)(chainId)) return;
        const token = await fetchFromMagicEden(chainId, (0,dist/* default */.ZP)('/v2/tokens/:mint_address', {
            mint_address: tokenMint
        }));
        if (!token) return;
        const collection = await fetchFromMagicEden(chainId, (0,dist/* default */.ZP)('/collections/:symbol', {
            symbol: token?.collection
        }));
        if (!collection) return;
        return createNFTCollection(collection);
    }
    async getEvents(address, tokenId, { chainId = types/* ChainId */.a_.Mainnet, indicator, size = 50 } = {}) {
        if (!(0,helpers_address/* isValidChainId */.JW)(chainId)) return (0,Pageable/* createPageable */.LI)(constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        const activities = await fetchFromMagicEden(chainId, (0,dist/* default */.ZP)('/v2/tokens/:mint_address/activities', {
            mint_address: address,
            offset: (indicator?.index ?? 0) * size,
            limit: size
        }));
        const events = activities?.map((activity)=>{
            return {
                id: activity.signature,
                chainId: types/* ChainId */.a_.Mainnet,
                assetSymbol: activity.collectionSymbol,
                timestamp: activity.blockTime * 1000,
                from: {
                    address: activity.seller
                },
                to: {
                    address: activity.buyerReferral
                },
                quantity: '1',
                type: specs/* ActivityType */.T8.Transfer,
                source: specs/* SourceType */.PO.MagicEden
            };
        });
        return (0,Pageable/* createPageable */.LI)(events ?? constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator), events?.length === size ? (0,Pageable/* createNextIndicator */.gT)(indicator) : undefined);
    }
    async getOrders(address, tokenId, side, { chainId = types/* ChainId */.a_.Mainnet, indicator, size } = {}) {
        if (!(0,helpers_address/* isValidChainId */.JW)(chainId)) return (0,Pageable/* createPageable */.LI)(constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        const limit = size || 20;
        const offers = await fetchFromMagicEden(chainId, (0,dist/* default */.ZP)('/tokens/:mint_address/offer_received', {
            mint_address: address,
            side,
            offset: (indicator?.index ?? 0) * limit,
            limit
        }));
        const orders = offers?.map((offer)=>{
            return {
                id: offer.pdaAddress,
                chainId: types/* ChainId */.a_.Mainnet,
                side,
                quantity: '1',
                // TODO's
                assetPermalink: '',
                source: specs/* SourceType */.PO.MagicEden
            };
        });
        return (0,Pageable/* createPageable */.LI)(orders ?? constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator), orders?.length === size ? (0,Pageable/* createNextIndicator */.gT)(indicator) : undefined);
    }
    async getCollectionsByOwner(symbol, { chainId = types/* ChainId */.a_.Mainnet, indicator, size = 20 } = {}) {
        if (!(0,helpers_address/* isValidChainId */.JW)(chainId)) return (0,Pageable/* createPageable */.LI)(constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        const collections = await fetchFromMagicEden(chainId, (0,dist/* default */.ZP)('/collections/:symbol/listings', {
            symbol,
            limit: size,
            offset: (indicator?.index ?? 0) * size
        }));
        const data = collections?.map((collection)=>({
                chainId,
                name: collection.name,
                slug: collection.symbol,
                address: '',
                symbol: collection.symbol,
                iconURL: (0,resolver/* resolveIPFS_URL */.mg)(collection.image),
                source: specs/* SourceType */.PO.MagicEden
            }));
        return (0,Pageable/* createPageable */.LI)(data ?? constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator), data?.length === size ? (0,Pageable/* createNextIndicator */.gT)(indicator) : undefined);
    }
}
const MagicEden = new MagicEdenAPI();


/***/ }),

/***/ 45025:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Zj: () => (/* binding */ solana),
/* harmony export */   ls: () => (/* binding */ flow),
/* harmony export */   oN: () => (/* binding */ evm)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3187);
/* harmony import */ var _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(81545);
/* harmony import */ var _masknet_web3_shared_solana__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(93221);



const evm = {
    chain: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .CHAIN_DESCRIPTORS */ .Q_,
    network: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .NETWORK_DESCRIPTORS */ .qQ,
    provider: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .PROVIDER_DESCRIPTORS */ .zM,
    state: null
};
const flow = {
    chain: _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_1__/* .CHAIN_DESCRIPTORS */ .Q_,
    network: _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_1__/* .NETWORK_DESCRIPTORS */ .qQ,
    provider: _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_1__/* .PROVIDER_DESCRIPTORS */ .zM,
    state: null
};
const solana = {
    chain: _masknet_web3_shared_solana__WEBPACK_IMPORTED_MODULE_2__/* .CHAIN_DESCRIPTORS */ .Q_,
    network: _masknet_web3_shared_solana__WEBPACK_IMPORTED_MODULE_2__/* .NETWORK_DESCRIPTORS */ .qQ,
    provider: _masknet_web3_shared_solana__WEBPACK_IMPORTED_MODULE_2__/* .PROVIDER_DESCRIPTORS */ .zM,
    state: null
};


/***/ }),

/***/ 93097:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  U: () => (/* binding */ MulticallAPI)
});

// EXTERNAL MODULE: ./packages/shared-base/src/constants.ts
var constants = __webpack_require__(52033);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/constants/constants.ts
var constants_constants = __webpack_require__(33026);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/libs/ContractTransaction.ts
var ContractTransaction = __webpack_require__(21704);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/abiCoder.ts
var abiCoder = __webpack_require__(1853);
;// CONCATENATED MODULE: ./packages/web3-shared/evm/src/helpers/decodeOutputString.ts

function decodeOutputString(abis, output, methodName) {
    const item = abis.find((x)=>x.type === 'function' && x.name === methodName);
    if (!item) throw new Error(`Failed to locate abi with name: ${methodName}.`);
    const outputs = item.outputs ?? [];
    if (outputs.length === 1) return abiCoder/* abiCoder */.r.decodeParameter(outputs[0], output);
    if (outputs.length > 1) return abiCoder/* abiCoder */.r.decodeParameters(outputs, output);
    return;
}

// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/ContractReadonlyAPI.ts + 9 modules
var ContractReadonlyAPI = __webpack_require__(61871);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/ConnectionReadonlyAPI.ts + 2 modules
var ConnectionReadonlyAPI = __webpack_require__(3543);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Multicall/constants.ts
// conservative, hard-coded estimate of the current block gas limit
const CONSERVATIVE_BLOCK_GAS_LIMIT = 10000000;
// the default value for calls that don't specify gasRequired
const DEFAULT_GAS_REQUIRED = 200000;
const DEFAULT_GAS_LIMIT = 1000000;

;// CONCATENATED MODULE: ./packages/web3-providers/src/Multicall/index.ts





class MulticallAPI {
    Contract = new ContractReadonlyAPI/* ContractReadonlyAPI */.M();
    Web3 = new ConnectionReadonlyAPI/* ConnectionReadonlyAPI */.S();
    results = {};
    createContract(chainId) {
        const address = (0,constants_constants/* getEthereumConstant */.wB)(chainId, 'MULTICALL_ADDRESS');
        if (!address) throw new Error('Failed to create multicall contract.');
        const contract = this.Contract.getMulticallContract(address, {
            chainId
        });
        if (!contract) throw new Error('Failed to create multicall contract.');
        return contract;
    }
    toCallKey(call) {
        return call.join('-');
    }
    getCallResult(call, chainId, blockNumber) {
        const cache = this.results[chainId];
        const blockNumber_ = cache?.blockNumber ?? 0;
        if (blockNumber_ < blockNumber) return;
        return cache.results[this.toCallKey(call)];
    }
    setCallResult(call, result, chainId, blockNumber) {
        const cache = this.results[chainId] ?? {
            results: [],
            blockNumber: 0
        };
        const blockNumber_ = cache.blockNumber;
        if (blockNumber_ > blockNumber) return;
        if (blockNumber_ < blockNumber) cache.blockNumber = blockNumber;
        cache.results[this.toCallKey(call)] = result;
        this.results[chainId] = cache;
    }
    // evenly distributes items among the chunks
    chunkArray(items, gasLimit = CONSERVATIVE_BLOCK_GAS_LIMIT * 10) {
        const chunks = [];
        let currentChunk = [];
        let currentChunkCumulativeGas = 0;
        for (const item of items){
            // calculate the gas required by the current item
            const gasRequired = item[1] ?? DEFAULT_GAS_REQUIRED;
            // if the current chunk is empty, or the current item wouldn't push it over the gas limit,
            // append the current item and increment the cumulative gas
            if (currentChunk.length === 0 || currentChunkCumulativeGas + gasRequired < gasLimit) {
                currentChunk.push(item);
                currentChunkCumulativeGas += gasRequired;
            } else {
                // otherwise, push the current chunk and create a new chunk
                chunks.push(currentChunk);
                currentChunk = [
                    item
                ];
                currentChunkCumulativeGas = gasRequired;
            }
        }
        if (currentChunk.length > 0) chunks.push(currentChunk);
        return chunks;
    }
    async call(chainId, contracts, names, calls, overrides, blockNumber) {
        if (!calls.length) return constants/* EMPTY_LIST */.rP;
        const contract = this.createContract(chainId);
        if (!contract) return constants/* EMPTY_LIST */.rP;
        const blockNumber_ = blockNumber ?? await this.Web3.getBlockNumber({
            chainId
        });
        // filter out cached calls
        const unresolvedCalls = calls.filter((call_)=>!this.getCallResult(call_, chainId, blockNumber_));
        // resolve the calls by chunks
        if (unresolvedCalls.length) {
            await Promise.all(this.chunkArray(unresolvedCalls).map(async (chunk)=>{
                // we don't mind the actual block number of the current call
                const tx = new ContractTransaction/* ContractTransaction */.D(contract).fill(contract.methods.multicall(chunk), overrides);
                const hex = await this.Web3.callTransaction(tx, {
                    chainId
                });
                const result = decodeOutputString(contract.options.jsonInterface, hex, 'multicall');
                if (!result) return;
                result.returnData.forEach((result, index)=>this.setCallResult(chunk[index], result, chainId, blockNumber_));
            }));
        }
        const results = calls.map((call)=>this.getCallResult(call, chainId, blockNumber_) ?? [
                false,
                '0x0',
                '0x0'
            ]);
        return results.map(([succeed, gasUsed, result], index)=>{
            try {
                const value = decodeOutputString(contracts[index].options.jsonInterface, result, names[index]);
                return {
                    succeed,
                    gasUsed,
                    value,
                    error: null
                };
            } catch (error) {
                return {
                    succeed: false,
                    gasUsed,
                    value: null,
                    error
                };
            }
        });
    }
    createSingleContractMultipleData(contract, names, callDatas, gasLimit = DEFAULT_GAS_LIMIT) {
        return callDatas.map((data, i)=>[
                contract.options.address,
                gasLimit,
                contract.methods[names[i]](...data).encodeABI()
            ]);
    }
    createMultipleContractSingleData(contracts, names, callData, gasLimit = DEFAULT_GAS_LIMIT) {
        return contracts.map((contract, i)=>[
                contract.options.address,
                gasLimit,
                contract.methods[names[i]](...callData).encodeABI()
            ]);
    }
}


/***/ }),

/***/ 78609:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ql: () => (/* binding */ NFTSCAN_URL),
/* harmony export */   u8: () => (/* binding */ NFTSCAN_BASE_SOLANA),
/* harmony export */   u9: () => (/* binding */ NFTSCAN_LOGO_BASE),
/* harmony export */   x_: () => (/* binding */ NFTSCAN_BASE)
/* harmony export */ });
const NFTSCAN_URL = 'https://nftscan-proxy.r2d2.to';
const NFTSCAN_BASE = 'https://www.nftscan.com';
const NFTSCAN_BASE_SOLANA = 'https://solana.nftscan.com';
const NFTSCAN_LOGO_BASE = 'https://logo.nftscan.com/logo';


/***/ }),

/***/ 68208:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HN: () => (/* binding */ createNonFungibleAsset),
/* harmony export */   NW: () => (/* binding */ createNonFungibleCollectionFromCollection),
/* harmony export */   Nu: () => (/* binding */ createPermalink),
/* harmony export */   X0: () => (/* binding */ createNonFungibleCollectionFromGroup),
/* harmony export */   Xi: () => (/* binding */ createNonFungibleTokenContract),
/* harmony export */   fE: () => (/* binding */ createNonFungibleTokenEvent),
/* harmony export */   kB: () => (/* binding */ fetchFromNFTScanV2)
/* harmony export */ });
/* harmony import */ var urlcat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78757);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(81755);
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(24835);
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(52033);
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(53007);
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(62649);
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(29763);
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(84847);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(65327);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(24770);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(89019);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(46854);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(81438);
/* harmony import */ var _Web3_EVM_apis_ResolverAPI_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(66979);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(78609);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55859);
/* harmony import */ var _helpers_fetchJSON_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11834);
/* harmony import */ var _helpers_parseJSON_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(73389);
/* harmony import */ var _helpers_getAssetFullName_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(28289);
/* harmony import */ var _helpers_getPaymentToken_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(34936);
/* harmony import */ var _helpers_resolveActivityType_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(15219);













async function fetchFromNFTScanV2(chainId, pathname, init) {
    return (0,_helpers_fetchJSON_js__WEBPACK_IMPORTED_MODULE_1__/* .fetchSquashedJSON */ .Vn)((0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(_constants_js__WEBPACK_IMPORTED_MODULE_2__/* .NFTSCAN_URL */ .Ql, pathname), {
        ...init,
        headers: {
            'content-type': 'application/json',
            ...init?.headers,
            ...chainId ? {
                'x-app-chainid': chainId.toString()
            } : {}
        },
        cache: 'no-cache'
    });
}
function createPermalink(chainId, address, tokenId) {
    return (0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)((0,_utils_js__WEBPACK_IMPORTED_MODULE_3__/* .resolveNFTScanHostName */ .gr)(_masknet_shared_base__WEBPACK_IMPORTED_MODULE_4__/* .NetworkPluginID */ .F.PLUGIN_EVM, chainId) || 'https://www.nftscan.com', '/:address/:tokenId', {
        address,
        tokenId
    });
}
function getAssetTraits(asset) {
    if (asset.attributes.length) {
        return asset.attributes.map((x)=>({
                type: x.attribute_name,
                value: x.attribute_value,
                rarity: x.percentage
            }));
    }
    // Manually get traits from metadata, since NFTScan doesn't return
    // attributes at this time.
    if ((0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_5__/* .isENSContractAddress */ .o2)(asset.contract_address)) {
        const payload = (0,_helpers_parseJSON_js__WEBPACK_IMPORTED_MODULE_6__/* .parseJSON */ .R)(asset.metadata_json);
        return payload?.attributes?.map((x)=>({
                type: x.trait_type,
                value: x.value
            })) ?? _masknet_shared_base__WEBPACK_IMPORTED_MODULE_7__/* .EMPTY_LIST */ .rP;
    }
    return _masknet_shared_base__WEBPACK_IMPORTED_MODULE_7__/* .EMPTY_LIST */ .rP;
}
function createNonFungibleAsset(chainId, asset, collection) {
    const payload = (0,_helpers_parseJSON_js__WEBPACK_IMPORTED_MODULE_6__/* .parseJSON */ .R)(asset.metadata_json);
    const contractName = asset.contract_name;
    const description = payload?.description ?? collection?.description ?? '';
    const uri = asset.imageURL ?? asset.image_uri;
    const mediaURL = (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_8__/* .resolveResourceURL */ .Bl)(uri);
    const creator = asset.minter;
    const owner = asset.owner;
    const schema = asset.erc_type === 'erc1155' ? _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_9__/* .SchemaType */ .XQ.ERC1155 : _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_9__/* .SchemaType */ .XQ.ERC721;
    const symbol = asset.contract_name;
    const name = (0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_10__/* .isValidDomain */ .h)(asset.name) ? asset.name : (0,_helpers_getAssetFullName_js__WEBPACK_IMPORTED_MODULE_11__/* .getAssetFullName */ .q)(asset.contract_address, contractName, payload?.name || asset.name, asset.token_id);
    return {
        id: asset.contract_address,
        chainId,
        link: createPermalink(chainId, asset.contract_address, asset.token_id),
        tokenId: asset.token_id,
        type: _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_12__/* .TokenType */ .iv.NonFungible,
        address: asset.contract_address,
        schema,
        creator: {
            address: creator,
            link: (0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(_constants_js__WEBPACK_IMPORTED_MODULE_2__/* .NFTSCAN_BASE */ .x_, creator)
        },
        owner: owner ? {
            address: owner,
            link: (0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(_constants_js__WEBPACK_IMPORTED_MODULE_2__/* .NFTSCAN_BASE */ .x_, owner)
        } : undefined,
        traits: getAssetTraits(asset),
        priceInToken: asset.latest_trade_price ? {
            amount: (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_13__/* .scale10 */ .SI)(asset.latest_trade_price, _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_14__/* .WNATIVE */ .FX[chainId].decimals).toFixed(),
            // FIXME: cannot get payment token
            token: asset.latest_trade_symbol === 'ETH' ? _Web3_EVM_apis_ResolverAPI_js__WEBPACK_IMPORTED_MODULE_15__/* .ChainResolver */ .iv.nativeCurrency(chainId) ?? _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_14__/* .WNATIVE */ .FX[chainId] : _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_14__/* .WNATIVE */ .FX[chainId]
        } : undefined,
        metadata: {
            chainId,
            name,
            symbol,
            description,
            imageURL: (0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_16__/* .resolveImageURL */ .y)(mediaURL, name, asset.contract_address),
            mediaURL
        },
        contract: {
            chainId,
            schema,
            address: asset.contract_address,
            name: contractName,
            symbol,
            creatorEarning: collection && 'royalty' in collection ? (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_17__/* .formatPercentage */ .r)(collection.royalty / 100 / 100) : undefined
        },
        collection: {
            chainId,
            name: contractName,
            slug: contractName,
            description,
            address: asset.contract_address,
            // If collectionContext.logo_url is null, we will directly render a fallback logo instead.
            // So do not fallback to the constructed NFTScan logo url
            iconURL: collection ? collection.logo_url : `${(0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(_constants_js__WEBPACK_IMPORTED_MODULE_2__/* .NFTSCAN_LOGO_BASE */ .u9, asset.contract_address)}.png`,
            verified: collection?.verified || collection?.opensea_verified,
            createdAt: asset.mint_timestamp
        },
        source: _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_12__/* .SourceType */ .PO.NFTScan
    };
}
function createNonFungibleCollectionFromGroup(chainId, group) {
    const sample = (0,lodash_es__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .Z)(group.assets);
    const payload = (0,_helpers_parseJSON_js__WEBPACK_IMPORTED_MODULE_6__/* .parseJSON */ .R)(sample?.metadata_json);
    return {
        id: group.contract_address,
        chainId,
        assets: group.assets.map((x)=>createNonFungibleAsset(chainId, x)),
        schema: sample?.erc_type === 'erc1155' ? _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_9__/* .SchemaType */ .XQ.ERC1155 : _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_9__/* .SchemaType */ .XQ.ERC721,
        name: group.contract_name || group.symbol || '',
        symbol: group.symbol,
        slug: group.contract_name || '',
        address: group.contract_address,
        description: group.description || payload?.description,
        iconURL: group.logo_url,
        balance: group.assets.length,
        source: _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_12__/* .SourceType */ .PO.NFTScan
    };
}
function createNonFungibleCollectionFromCollection(chainId, collection) {
    return {
        chainId,
        schema: collection.erc_type === 'erc1155' ? _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_9__/* .SchemaType */ .XQ.ERC1155 : _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_9__/* .SchemaType */ .XQ.ERC721,
        name: collection.name,
        symbol: collection.symbol,
        slug: collection.symbol,
        address: collection.contract_address,
        description: collection.description,
        iconURL: collection.logo_url,
        verified: collection.verified,
        source: _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_12__/* .SourceType */ .PO.NFTScan
    };
}
function createNonFungibleTokenContract(chainId, collection) {
    return {
        chainId,
        address: collection.contract_address,
        name: collection.name,
        symbol: collection.symbol,
        schema: collection.erc_type === 'erc1155' ? _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_9__/* .SchemaType */ .XQ.ERC1155 : _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_9__/* .SchemaType */ .XQ.ERC721,
        iconURL: collection.logo_url,
        logoURL: collection.logo_url,
        owner: collection.owner,
        source: _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_12__/* .SourceType */ .PO.NFTScan
    };
}
function createNonFungibleTokenEvent(chainId, transaction) {
    const paymentToken = (0,_helpers_getPaymentToken_js__WEBPACK_IMPORTED_MODULE_19__/* .getPaymentToken */ .W)(chainId, {
        symbol: transaction.trade_symbol
    });
    return {
        chainId,
        id: transaction.hash,
        quantity: transaction.amount,
        timestamp: transaction.timestamp,
        type: (0,_helpers_resolveActivityType_js__WEBPACK_IMPORTED_MODULE_20__/* .resolveActivityType */ .G)(transaction.event_type),
        hash: transaction.hash,
        from: {
            address: transaction.from
        },
        to: {
            address: transaction.to
        },
        send: {
            address: transaction.send
        },
        receive: {
            address: transaction.receive
        },
        assetName: transaction.contract_name,
        assetPermalink: createPermalink(chainId, transaction.contract_address, transaction.token_id),
        priceInToken: paymentToken ? {
            amount: (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_13__/* .scale10 */ .SI)(transaction.trade_price, paymentToken?.decimals).toFixed(),
            token: paymentToken
        } : undefined,
        paymentToken,
        source: _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_12__/* .SourceType */ .PO.NFTScan
    };
}


/***/ }),

/***/ 91549:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HN: () => (/* binding */ createNonFungibleAsset),
/* harmony export */   Nu: () => (/* binding */ createPermalink),
/* harmony export */   Xi: () => (/* binding */ createNonFungibleTokenContract),
/* harmony export */   fE: () => (/* binding */ createNonFungibleTokenEvent),
/* harmony export */   kB: () => (/* binding */ fetchFromNFTScanV2),
/* harmony export */   wP: () => (/* binding */ createNonFungibleCollection)
/* harmony export */ });
/* harmony import */ var urlcat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78757);
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(52033);
/* harmony import */ var _masknet_web3_shared_solana__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(97834);
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(53007);
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(62649);
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(29763);
/* harmony import */ var _Web3_Solana_apis_ResolverAPI_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(46034);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(78609);
/* harmony import */ var _helpers_fetchJSON_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11834);
/* harmony import */ var _helpers_resolveActivityType_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(15219);
/* harmony import */ var _helpers_parseJSON_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(73389);
/* harmony import */ var _helpers_getAssetFullName_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(28289);










function createPermalink(chainId, address) {
    if (!address) return;
    return (0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)('https://solana.nftscan.com', '/:address', {
        address
    });
}
async function fetchFromNFTScanV2(chainId, pathname, init) {
    if (chainId !== _masknet_web3_shared_solana__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet) return;
    return (0,_helpers_fetchJSON_js__WEBPACK_IMPORTED_MODULE_2__/* .fetchSquashedJSON */ .Vn)((0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(_constants_js__WEBPACK_IMPORTED_MODULE_3__/* .NFTSCAN_URL */ .Ql, pathname), {
        ...init,
        headers: {
            'content-type': 'application/json',
            ...init?.headers,
            'x-app-chainid': 'solana'
        },
        cache: 'no-cache'
    });
}
function createNonFungibleAsset(chainId, asset) {
    const payload = (0,_helpers_parseJSON_js__WEBPACK_IMPORTED_MODULE_4__/* .parseJSON */ .R)(asset.metadata_json);
    const name = payload?.name || asset.name || payload?.name || '';
    const description = payload?.description;
    const mediaURL = (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_5__/* .resolveIPFS_URL */ .mg)(asset.image_uri ?? asset.content_uri);
    const creator = asset.minter;
    const owner = asset.owner;
    const schema = _masknet_web3_shared_solana__WEBPACK_IMPORTED_MODULE_1__/* .SchemaType */ .XQ.NonFungible;
    const symbol = payload?.symbol;
    const nativeToken = _Web3_Solana_apis_ResolverAPI_js__WEBPACK_IMPORTED_MODULE_6__/* .SolanaChainResolver */ .ZC.nativeCurrency(chainId);
    return {
        id: asset.token_address,
        chainId,
        link: createPermalink(chainId, asset.token_address),
        tokenId: '',
        type: _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_7__/* .TokenType */ .iv.NonFungible,
        address: asset.token_address,
        schema,
        creator: {
            address: creator,
            link: (0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(_constants_js__WEBPACK_IMPORTED_MODULE_3__/* .NFTSCAN_BASE_SOLANA */ .u8 + '/:id', {
                id: creator
            })
        },
        owner: owner ? {
            address: owner,
            link: (0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(_constants_js__WEBPACK_IMPORTED_MODULE_3__/* .NFTSCAN_BASE_SOLANA */ .u8 + '/:id', {
                id: owner
            })
        } : undefined,
        traits: asset.attributes?.map((x)=>({
                type: x.attribute_name,
                value: x.attribute_value,
                rarity: x.percentage
            })) ?? _masknet_shared_base__WEBPACK_IMPORTED_MODULE_8__/* .EMPTY_LIST */ .rP,
        priceInToken: asset.latest_trade_price ? {
            amount: (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_9__/* .scale10 */ .SI)(asset.latest_trade_price, nativeToken.decimals).toFixed(),
            // FIXME: cannot get payment token
            token: nativeToken
        } : undefined,
        metadata: {
            chainId,
            name: (0,_helpers_getAssetFullName_js__WEBPACK_IMPORTED_MODULE_10__/* .getAssetFullName */ .q)(asset.token_address, payload?.collection?.name || name, name),
            symbol,
            description,
            imageURL: mediaURL,
            mediaURL,
            projectURL: asset.external_link
        },
        contract: {
            chainId,
            schema,
            address: asset.token_address,
            name,
            symbol
        },
        collection: {
            chainId,
            name,
            slug: payload?.symbol || name,
            description,
            address: asset.token_address,
            iconURL: '',
            // TODO fetch via `collections` API
            verified: false,
            createdAt: asset.mint_timestamp
        },
        source: _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_7__/* .SourceType */ .PO.NFTScan
    };
}
function createNonFungibleCollection(chainId, collection) {
    return {
        chainId,
        schema: _masknet_web3_shared_solana__WEBPACK_IMPORTED_MODULE_1__/* .SchemaType */ .XQ.NonFungible,
        name: collection.collection || collection.symbol || '',
        symbol: collection.symbol,
        slug: collection.symbol || '',
        address: '',
        balance: collection.items_total,
        description: collection.description,
        iconURL: collection.logo_url,
        verified: collection.verified
    };
}
function createNonFungibleTokenContract(chainId, collection) {
    return {
        chainId,
        address: '',
        name: collection.collection || collection.symbol || '',
        symbol: collection.symbol,
        schema: _masknet_web3_shared_solana__WEBPACK_IMPORTED_MODULE_1__/* .SchemaType */ .XQ.NonFungible,
        iconURL: collection.logo_url,
        logoURL: collection.logo_url
    };
}
function createNonFungibleTokenEvent(chainId, transaction) {
    const paymentToken = _Web3_Solana_apis_ResolverAPI_js__WEBPACK_IMPORTED_MODULE_6__/* .SolanaChainResolver */ .ZC.nativeCurrency(chainId);
    return {
        chainId,
        id: transaction.hash,
        quantity: '1',
        timestamp: transaction.timestamp ?? 0,
        type: (0,_helpers_resolveActivityType_js__WEBPACK_IMPORTED_MODULE_11__/* .resolveActivityType */ .G)(transaction.event_type),
        hash: transaction.hash,
        from: transaction.source ? {
            address: transaction.source
        } : undefined,
        to: transaction.destination ? {
            address: transaction.destination
        } : undefined,
        assetName: transaction.exchange_name,
        assetPermalink: createPermalink(chainId, transaction.token_address),
        priceInToken: paymentToken && transaction.trade_price ? {
            amount: (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_9__/* .scale10 */ .SI)(transaction.trade_price ?? 0, paymentToken?.decimals).toFixed(),
            token: paymentToken
        } : undefined,
        paymentToken,
        source: _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_7__/* .SourceType */ .PO.NFTScan
    };
}


/***/ }),

/***/ 59023:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AD: () => (/* binding */ KV_BASE_URL_PROD),
/* harmony export */   G7: () => (/* binding */ KV_BASE_URL_DEV),
/* harmony export */   GK: () => (/* binding */ PROOF_BASE_URL_PROD),
/* harmony export */   MS: () => (/* binding */ RELATION_SERVICE_URL),
/* harmony export */   OL: () => (/* binding */ PROOF_BASE_URL_DEV)
/* harmony export */ });
const KV_BASE_URL_DEV = 'https://kv-service.nextnext.id';
const KV_BASE_URL_PROD = 'https://kv-service.next.id';
const PROOF_BASE_URL_DEV = 'https://proof-service.nextnext.id/';
const PROOF_BASE_URL_PROD = 'https://proof-service.next.id/';
const RELATION_SERVICE_URL = 'https://relation-service-tiger.next.id';


/***/ }),

/***/ 1419:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E: () => (/* binding */ staleNextIDCached)
/* harmony export */ });
/* harmony import */ var _helpers_fetchCached_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(22674);

async function staleNextIDCached(url) {
    const request = new Request(url);
    const response = await (0,_helpers_fetchCached_js__WEBPACK_IMPORTED_MODULE_0__/* .staleCached */ .be)(request);
    if (response && !response.ok) throw new Error('Stale cache failed');
}


/***/ }),

/***/ 93293:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   H: () => (/* binding */ NextIDStorageProvider)
/* harmony export */ });
/* harmony import */ var urlcat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78757);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(72845);
/* harmony import */ var ts_results_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(76089);
/* harmony import */ var _masknet_flags__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(51573);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(59023);
/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(1419);
/* harmony import */ var _helpers_fetchJSON_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(11834);
/**
 * Document url: https://github.com/nextdotid/kv_server/blob/develop/docs/api.apib
 */ 






const BASE_URL = _masknet_flags__WEBPACK_IMPORTED_MODULE_2__/* .env */ .O.channel === 'stable' && "production" === 'production' ? _constants_js__WEBPACK_IMPORTED_MODULE_3__/* .KV_BASE_URL_PROD */ .AD : _constants_js__WEBPACK_IMPORTED_MODULE_3__/* .KV_BASE_URL_DEV */ .G7;
function formatPatchData(pluginID, data) {
    return {
        [pluginID]: data
    };
}
class NextIDStorageProvider {
    /**
     * Get current KV of a persona
     * @param personaPublicKey
     *
     */ static async getByIdentity(personaPublicKey, platform, identity, pluginID) {
        const response = await (0,_helpers_fetchJSON_js__WEBPACK_IMPORTED_MODULE_4__/* .fetchSquashedJSON */ .Vn)((0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(BASE_URL, '/v1/kv', {
            persona: personaPublicKey
        }));
        if (!response) return (0,ts_results_es__WEBPACK_IMPORTED_MODULE_1__.Err)('User not found');
        const proofs = (response.proofs ?? []).filter((x)=>x.platform === platform).filter((x)=>x.identity === identity.toLowerCase());
        if (!proofs.length) return (0,ts_results_es__WEBPACK_IMPORTED_MODULE_1__.Err)('Proof not found');
        return (0,ts_results_es__WEBPACK_IMPORTED_MODULE_1__.Ok)(proofs[0].content[pluginID]);
    }
    static async getAllByIdentity(platform, identity, pluginID) {
        const response = await (0,_helpers_fetchJSON_js__WEBPACK_IMPORTED_MODULE_4__/* .fetchCachedJSON */ .MP)((0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(BASE_URL, '/v1/kv/by_identity', {
            platform,
            identity
        }));
        if (!response) return (0,ts_results_es__WEBPACK_IMPORTED_MODULE_1__.Err)('User not found');
        const result = (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(response.values.map((x)=>x.content[pluginID]));
        return (0,ts_results_es__WEBPACK_IMPORTED_MODULE_1__.Ok)(result);
    }
    static async get(personaPublicKey) {
        return (0,_helpers_fetchJSON_js__WEBPACK_IMPORTED_MODULE_4__/* .fetchCachedJSON */ .MP)((0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(BASE_URL, '/v1/kv', {
            persona: personaPublicKey
        }));
    }
    /**
     * Get signature payload for updating
     * @param personaPublicKey
     * @param platform
     * @param identity
     * @param patchData
     * @param pluginID
     *
     * We choose [RFC 7396](https://www.rfc-editor.org/rfc/rfc7396) standard for KV modifying.
     */ static async getPayload(personaPublicKey, platform, identity, patchData, pluginID) {
        const requestBody = {
            persona: personaPublicKey,
            platform,
            identity,
            patch: formatPatchData(pluginID, patchData)
        };
        const response = await (0,_helpers_fetchJSON_js__WEBPACK_IMPORTED_MODULE_4__/* .fetchJSON */ .ZV)((0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(BASE_URL, '/v1/kv/payload'), {
            body: JSON.stringify(requestBody),
            method: 'POST'
        });
        return response ? (0,ts_results_es__WEBPACK_IMPORTED_MODULE_1__.Ok)({
            signPayload: JSON.stringify(JSON.parse(response.sign_payload)),
            createdAt: response.created_at,
            uuid: response.uuid
        }) : (0,ts_results_es__WEBPACK_IMPORTED_MODULE_1__.Err)(null);
    }
    /**
     * Update a full set of key-value pairs
     * @param uuid
     * @param personaPublicKey
     * @param signature
     * @param platform
     * @param identity
     * @param createdAt
     * @param patchData
     * @param pluginID
     *
     * We choose [RFC 7396](https://www.rfc-editor.org/rfc/rfc7396) standard for KV modifying.
     */ static async set(uuid, personaPublicKey, signature, platform, identity, createdAt, patchData, pluginID) {
        const requestBody = {
            uuid,
            persona: personaPublicKey,
            platform,
            identity,
            signature,
            patch: formatPatchData(pluginID, patchData),
            created_at: createdAt
        };
        const result = await (0,_helpers_fetchJSON_js__WEBPACK_IMPORTED_MODULE_4__/* .fetchJSON */ .ZV)((0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(BASE_URL, '/v1/kv'), {
            body: JSON.stringify(requestBody),
            method: 'POST'
        });
        if (result) {
            await (0,_helpers_js__WEBPACK_IMPORTED_MODULE_6__/* .staleNextIDCached */ .E)((0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(BASE_URL, '/v1/kv', {
                persona: personaPublicKey
            }));
        }
        return result ? (0,ts_results_es__WEBPACK_IMPORTED_MODULE_1__.Ok)(result) : (0,ts_results_es__WEBPACK_IMPORTED_MODULE_1__.Err)(null);
    }
}


/***/ }),

/***/ 63544:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  q: () => (/* binding */ NextIDProof)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/urlcat@3.1.0_patch_hash=5r5xyq4zgcnqugwsrx4lxq2i4e/node_modules/urlcat/dist/index.mjs
var dist = __webpack_require__(78757);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/head.js
var head = __webpack_require__(81755);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/sortBy.js
var sortBy = __webpack_require__(89762);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/uniqBy.js
var uniqBy = __webpack_require__(72601);
// EXTERNAL MODULE: ./packages/shared-base/src/NextID/types.ts
var types = __webpack_require__(95766);
// EXTERNAL MODULE: ./packages/shared-base/src/helpers/pvtutils.ts
var pvtutils = __webpack_require__(26424);
;// CONCATENATED MODULE: ./packages/shared-base/src/helpers/getDomainSystem.ts
const unstoppableDomains = [
    '.crypto',
    '.nft',
    '.x',
    '.wallet',
    '.bitcoin',
    '.dao',
    '.888',
    '.zil',
    '.blockchain'
];
function getDomainSystem(domain) {
    if (!domain) return 'unknown';
    if (domain.endsWith('.lens') || domain === 'lensprotocol' || domain === '@lensprotocol') return 'lens';
    if (domain.endsWith('.eth')) return 'ENS';
    if (domain.endsWith('.bit')) return 'dotbit';
    if (domain.endsWith('.bnb')) return 'space_id';
    const ext = domain.slice(domain.lastIndexOf('.'));
    if (unstoppableDomains.includes(ext)) return 'unstoppabledomains';
    return 'unknown';
}

// EXTERNAL MODULE: ./packages/shared-base/src/constants.ts
var constants = __webpack_require__(52033);
// EXTERNAL MODULE: ./packages/shared-base/src/NextID/index.ts
var NextID = __webpack_require__(3765);
// EXTERNAL MODULE: ./packages/web3-providers/src/NextID/constants.ts
var NextID_constants = __webpack_require__(59023);
// EXTERNAL MODULE: ./packages/web3-providers/src/NextID/helpers.ts
var helpers = __webpack_require__(1419);
;// CONCATENATED MODULE: ./packages/web3-providers/src/NextID/preset-lens.json
const preset_lens_namespaceObject = JSON.parse('{"lensprotocol":[{"handle":"lensprotocol","displayName":"lensprotocol","address":"0x05092cF69BDD435f7Ba4B8eF97c9CAecF2BA69AD"}],"lensprotocol_cn":[{"handle":"lensprotocol_cn.lens","displayName":"lensprotocol_cn","address":"0x2da8adDa8D145a7310CdbbfCAf3e1a8B315b5cB8"}],"stanikulechov":[{"handle":"stani.lens","displayName":"stani","address":"0x7241DDDec3A6aF367882eAF9651b87E1C7549Dff"},{"handle":"lilgho.lens","displayName":"lilgho","address":"0x7241DDDec3A6aF367882eAF9651b87E1C7549Dff"},{"handle":"lensofficial.lens","displayName":"lensofficial","address":"0x7241DDDec3A6aF367882eAF9651b87E1C7549Dff"}],"realmasknetwork":[{"handle":"masknetworkofficial.lens","displayName":"masknetworkofficial","address":"0x6745926875Fa12f59370cCB77aaaDc31B9c37Cb7"}]}');
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/fetchJSON.ts
var fetchJSON = __webpack_require__(11834);
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/fetchSquashed.ts
var fetchSquashed = __webpack_require__(64883);
// EXTERNAL MODULE: ./packages/flags/src/index.ts
var src = __webpack_require__(51573);
;// CONCATENATED MODULE: ./packages/web3-providers/src/NextID/proof.ts









const BASE_URL = src/* env */.O.channel === 'stable' && "production" === 'production' ? NextID_constants/* PROOF_BASE_URL_PROD */.GK : NextID_constants/* PROOF_BASE_URL_DEV */.OL;
const relationServiceDomainQuery = (depth)=>`domain(domainSystem: $domainSystem, name: $domain) {
    source
    system
    name
    fetcher
    resolved {
      identity
      platform
      displayName
    }
    owner {
      identity
      platform
      displayName
      uuid
      nft(category: ["ENS"], limit: 100, offset: 0) {
        uuid
        category
        chain
        id
      }
      neighborWithTraversal(depth: ${depth ?? 5}) {
        ... on ProofRecord {
          source
          from {
            nft(category: ["ENS"], limit: 100, offset: 0) {
              uuid
              category
              chain
              id
            }
            uuid
            platform
            identity
            displayName
          }
          to {
            nft(category: ["ENS"], limit: 100, offset: 0) {
              uuid
              category
              chain
              id
            }
            uuid
            platform
            identity
            displayName
          }
        }
        ... on HoldRecord {
          source
          from {
            nft(category: ["ENS"], limit: 100, offset: 0) {
              uuid
              category
              chain
              id
            }
            uuid
            platform
            identity
            displayName
          }
          to {
            nft(category: ["ENS"], limit: 100, offset: 0) {
              uuid
              category
              chain
              id
            }
            uuid
            platform
            identity
            displayName
          }
        }
      }
    }
    }`;
const relationServiceIdentityQuery = (depth)=>`
    identity(platform: $platform, identity: $identity) {
        platform
        identity
        displayName
        uuid
        ownedBy {
          uuid
          platform
          identity
          displayName
        }
        nft(category: ["ENS"], limit: 100, offset: 0) {
          uuid
          category
          chain
          address
          id
        }
        neighborWithTraversal(depth: ${depth ?? 5}) {
          ... on ProofRecord {
            source
            from {
              nft(category: ["ENS"], limit: 100, offset: 0) {
                uuid
                category
                chain
                id
              }
              uuid
              platform
              identity
              displayName
            }
            to {
              nft(category: ["ENS"], limit: 100, offset: 0) {
                uuid
                category
                chain
                id
              }
              uuid
              platform
              identity
              displayName
            }
          }
          ... on HoldRecord {
            source
            from {
              nft(category: ["ENS"], limit: 100, offset: 0) {
                uuid
                category
                chain
                id
              }
              uuid
              platform
              identity
              displayName
            }
            to {
              nft(category: ["ENS"], limit: 100, offset: 0) {
                uuid
                category
                chain
                id
              }
              uuid
              platform
              identity
              displayName
            }
          }
        }
      }`;
const getPersonaQueryURL = (platform, identity)=>(0,dist/* default */.ZP)(BASE_URL, '/v1/proof', {
        platform,
        identity
    });
const getExistedBindingQueryURL = (platform, identity, personaPublicKey)=>(0,dist/* default */.ZP)(BASE_URL, '/v1/proof/exists', {
        platform,
        identity,
        public_key: personaPublicKey
    });
class NextIDProof {
    static fetchFromProofService(request, init) {
        return (0,fetchJSON/* fetchJSON */.ZV)(request, init);
    }
    static async clearPersonaQueryCache(personaPublicKey) {
        const url = getPersonaQueryURL(types/* NextIDPlatform */.V.NextID, personaPublicKey);
        await (0,helpers/* staleNextIDCached */.E)(url);
        await (0,fetchSquashed/* stableSquashedCached */.ob)(url);
    }
    static async bindProof(uuid, personaPublicKey, action, platform, identity, createdAt, options) {
        const requestBody = {
            uuid,
            action,
            platform,
            identity,
            public_key: personaPublicKey,
            proof_location: options?.proofLocation,
            extra: {
                wallet_signature: options?.walletSignature ? (0,pvtutils/* toBase64 */.s3)((0,pvtutils/* fromHex */.H_)(options.walletSignature)) : undefined,
                signature: options?.signature ? (0,pvtutils/* toBase64 */.s3)((0,pvtutils/* fromHex */.H_)(options.signature)) : undefined
            },
            created_at: createdAt
        };
        const result = await (0,fetchJSON/* fetchJSON */.ZV)((0,dist/* default */.ZP)(BASE_URL, '/v1/proof'), {
            body: JSON.stringify(requestBody),
            method: 'POST'
        });
        if (result?.message) throw new Error(result.message);
        // Should delete cache when proof status changed
        const cacheKeyOfQueryPersona = getPersonaQueryURL(types/* NextIDPlatform */.V.NextID, personaPublicKey);
        const cacheKeyOfQueryPlatform = getPersonaQueryURL(platform, identity);
        const cacheKeyOfExistedBinding = getExistedBindingQueryURL(platform, identity, personaPublicKey);
        await (0,helpers/* staleNextIDCached */.E)(cacheKeyOfExistedBinding);
        await (0,helpers/* staleNextIDCached */.E)(cacheKeyOfQueryPersona);
        await (0,helpers/* staleNextIDCached */.E)(cacheKeyOfQueryPlatform);
        await (0,fetchSquashed/* stableSquashedCached */.ob)(cacheKeyOfQueryPersona);
        await (0,fetchSquashed/* stableSquashedCached */.ob)(cacheKeyOfQueryPlatform);
        await (0,fetchSquashed/* stableSquashedCached */.ob)(cacheKeyOfExistedBinding);
    }
    static async queryExistedBindingByPersona(personaPublicKey) {
        const { ids } = await this.fetchFromProofService(getPersonaQueryURL(types/* NextIDPlatform */.V.NextID, personaPublicKey), undefined);
        // Will have only one item when query by personaPublicKey
        return (0,head/* default */.Z)(ids);
    }
    static async queryExistedBindingByPlatform(platform, identity, page = 1, exact = true) {
        if (!platform && !identity) return [];
        const response = await this.fetchFromProofService((0,dist/* default */.ZP)(BASE_URL, '/v1/proof', {
            platform,
            identity,
            page,
            exact
        }));
        // TODO workaround for the API, and will sort the result manually
        return (0,sortBy/* default */.Z)(response.ids, (x)=>-x.activated_at);
    }
    static async queryLatestBindingByPlatform(platform, identity, publicKey) {
        if (!platform && !identity) return null;
        const result = await this.queryAllExistedBindingsByPlatform(platform, identity, true);
        if (publicKey) return result.find((x)=>x.persona === publicKey) ?? null;
        return (0,head/* default */.Z)(result) ?? null;
    }
    static async queryAllExistedBindingsByPlatform(platform, identity, exact) {
        if (!platform && !identity) return [];
        const nextIDPersonaBindings = [];
        let page = 1;
        do {
            const result = await this.fetchFromProofService((0,dist/* default */.ZP)(BASE_URL, '/v1/proof', {
                platform,
                identity,
                exact,
                page,
                order: 'desc'
            }), undefined);
            const personaBindings = result.ids;
            if (personaBindings.length === 0) return nextIDPersonaBindings;
            nextIDPersonaBindings.push(...personaBindings);
            // next is `0` if current page is the last one.
            if (result.pagination.next === 0) return nextIDPersonaBindings;
            page += 1;
        }while (page > 1)
        return [];
    }
    static async queryIsBound(personaPublicKey, platform, identity) {
        try {
            if (!platform && !identity) return false;
            const result = await this.fetchFromProofService(getExistedBindingQueryURL(platform, identity, personaPublicKey), undefined);
            return !!result?.is_valid;
        } catch  {
            return false;
        }
    }
    static async queryProfilesByDomain(domain, depth) {
        const domainSystem = getDomainSystem(domain);
        if (domainSystem === 'unknown') return constants/* EMPTY_LIST */.rP;
        const { data } = await (0,fetchJSON/* fetchSquashedJSON */.Vn)(NextID_constants/* RELATION_SERVICE_URL */.MS, {
            method: 'POST',
            mode: 'cors',
            body: JSON.stringify({
                operationName: 'GET_PROFILES_QUERY',
                variables: {
                    domainSystem,
                    domain: domain?.toLowerCase()
                },
                query: `
                    query GET_PROFILES_QUERY($domainSystem:String, $domain: String) {
                      ${relationServiceDomainQuery(depth)}
                    }
                `
            })
        });
        if (!data.domain) return constants/* EMPTY_LIST */.rP;
        const bindings = createBindProofsFromNeighbor(data.domain.owner.neighborWithTraversal);
        return bindings.filter((x)=>![
                types/* NextIDPlatform */.V.NextID
            ].includes(x.platform) && x.identity);
    }
    static async queryProfilesByAddress(address, depth) {
        const { data } = await (0,fetchJSON/* fetchSquashedJSON */.Vn)(NextID_constants/* RELATION_SERVICE_URL */.MS, {
            method: 'POST',
            mode: 'cors',
            body: JSON.stringify({
                operationName: 'GET_PROFILES_QUERY',
                variables: {
                    platform: types/* NextIDPlatform */.V.Ethereum,
                    identity: address.toLowerCase()
                },
                query: `
                    query GET_PROFILES_QUERY($platform: String, $identity: String) {
                       ${relationServiceIdentityQuery(depth)}
                      }
                `
            })
        });
        const bindings = createBindProofsFromNeighbor(data.identity.neighborWithTraversal);
        return bindings.filter((x)=>![
                types/* NextIDPlatform */.V.Ethereum,
                types/* NextIDPlatform */.V.NextID
            ].includes(x.platform) && x.identity);
    }
    static async queryProfilesByPublicKey(publicKey, depth) {
        const { data } = await (0,fetchJSON/* fetchJSON */.ZV)(NextID_constants/* RELATION_SERVICE_URL */.MS, {
            method: 'POST',
            mode: 'cors',
            body: JSON.stringify({
                operationName: 'GET_PROFILES_QUERY',
                variables: {
                    platform: types/* NextIDPlatform */.V.NextID,
                    identity: publicKey
                },
                query: `
                    query GET_PROFILES_QUERY($platform: String, $identity: String) {
                       ${relationServiceIdentityQuery(depth)}
                      }
                `
            })
        });
        const bindings = createBindProofsFromNeighbor(data.identity.neighborWithTraversal);
        return bindings;
    }
    static async queryProfilesByTwitterId(twitterId, depth) {
        const { data } = await (0,fetchJSON/* fetchSquashedJSON */.Vn)(NextID_constants/* RELATION_SERVICE_URL */.MS, {
            method: 'POST',
            mode: 'cors',
            body: JSON.stringify({
                operationName: 'GET_PROFILES_BY_TWITTER_ID',
                variables: {
                    platform: types/* NextIDPlatform */.V.Twitter,
                    identity: twitterId.toLowerCase()
                },
                query: `
                        query GET_PROFILES_BY_TWITTER_ID($platform: String, $identity: String) {
                            ${relationServiceIdentityQuery(depth)}
                        }
                `
            })
        });
        const bindings = createBindProofsFromNeighbor(data.identity.neighborWithTraversal);
        return bindings.filter((x)=>![
                types/* NextIDPlatform */.V.NextID
            ].includes(x.platform) && x.identity);
    }
    static async queryAllLens(twitterId, depth) {
        const lowerCaseId = twitterId.toLowerCase();
        const { data } = await (0,fetchJSON/* fetchSquashedJSON */.Vn)(NextID_constants/* RELATION_SERVICE_URL */.MS, {
            method: 'POST',
            mode: 'cors',
            body: JSON.stringify({
                operationName: 'GET_LENS_PROFILES',
                variables: {
                    domainSystem: 'lens',
                    domain: lowerCaseId
                },
                query: `
                        query GET_LENS_PROFILES($domainSystem: String, $domain: String) {
                            ${relationServiceDomainQuery(depth)}
                        }
                `
            })
        });
        const connectionsTo = data.domain?.owner.neighborWithTraversal.filter((x)=>x.to.platform === types/* NextIDPlatform */.V.LENS) || [];
        const connectionsFrom = data.domain?.owner.neighborWithTraversal.filter((x)=>x.from.platform === types/* NextIDPlatform */.V.LENS) || [];
        const id = lowerCaseId;
        if (connectionsTo.length === 0 && connectionsFrom.length === 0 && preset_lens_namespaceObject[id]) {
            return preset_lens_namespaceObject[id];
        }
        return (0,uniqBy/* default */.Z)(connectionsTo.map((x)=>({
                handle: x.to.identity,
                displayName: x.to.displayName,
                address: x.to.identity
            })).concat(connectionsFrom.map((x)=>({
                handle: x.from.identity,
                displayName: x.from.displayName,
                address: x.from.identity
            }))), (x)=>x.handle);
    }
    static async createPersonaPayload(personaPublicKey, action, identity, platform, language = 'default') {
        const requestBody = {
            action,
            platform,
            identity,
            public_key: personaPublicKey
        };
        const nextIDLanguageFormat = language.replace('-', '_');
        const response = await (0,fetchJSON/* fetchJSON */.ZV)((0,dist/* default */.ZP)(BASE_URL, '/v1/proof/payload'), {
            body: JSON.stringify(requestBody),
            method: 'POST'
        });
        return response ? {
            postContent: response.post_content[nextIDLanguageFormat] ?? response.post_content.default,
            signPayload: JSON.stringify(JSON.parse(response.sign_payload)),
            createdAt: response.created_at,
            uuid: response.uuid
        } : null;
    }
}
function createBindingProofNodeFromNeighbor(nextIDIdentity, source) {
    const nft = nextIDIdentity.nft.map((x)=>(0,NextID/* createBindingProofFromProfileQuery */.SS)(types/* NextIDPlatform */.V.NextID, x.id, x.id, undefined, types/* NextIDPlatform */.V.ENS));
    return (0,NextID/* createBindingProofFromProfileQuery */.SS)(nft.length === 0 ? nextIDIdentity.platform : types/* NextIDPlatform */.V.ENS, nextIDIdentity.identity, nextIDIdentity.displayName, undefined, source, nft);
}
function createBindProofsFromNeighbor(neighborList) {
    const bindings = neighborList.flatMap((x)=>{
        return [
            {
                uuid: x.from.uuid,
                data: createBindingProofNodeFromNeighbor(x.from, x.source)
            },
            {
                uuid: x.to.uuid,
                data: createBindingProofNodeFromNeighbor(x.to, x.source)
            }
        ];
    });
    return (0,uniqBy/* default */.Z)(bindings, (x)=>x.uuid).map((x)=>x.data);
}


/***/ }),

/***/ 65680:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  N: () => (/* binding */ OpenSea)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/urlcat@3.1.0_patch_hash=5r5xyq4zgcnqugwsrx4lxq2i4e/node_modules/urlcat/dist/index.mjs
var dist = __webpack_require__(78757);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/uniqBy.js
var uniqBy = __webpack_require__(72601);
// EXTERNAL MODULE: ./node_modules/.pnpm/bignumber.js@9.1.2/node_modules/bignumber.js/bignumber.mjs
var bignumber = __webpack_require__(10149);
// EXTERNAL MODULE: ./node_modules/.pnpm/date-fns@2.30.0/node_modules/date-fns/esm/getUnixTime/index.js + 1 modules
var getUnixTime = __webpack_require__(11796);
// EXTERNAL MODULE: ./packages/shared-base/src/Pageable/index.ts
var Pageable = __webpack_require__(38645);
// EXTERNAL MODULE: ./packages/shared-base/src/constants.ts
var constants = __webpack_require__(52033);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/specs/index.ts
var specs = __webpack_require__(62649);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/resolver.ts
var resolver = __webpack_require__(53007);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/formatPercentage.ts
var formatPercentage = __webpack_require__(84847);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/number.ts
var number = __webpack_require__(29763);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/token.ts
var token = __webpack_require__(77199);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/types/index.ts
var types = __webpack_require__(24770);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/token.ts
var helpers_token = __webpack_require__(48289);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/resolveImageURL.ts
var resolveImageURL = __webpack_require__(81438);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/isValidChainId.ts
var isValidChainId = __webpack_require__(37049);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/ResolverAPI.ts
var ResolverAPI = __webpack_require__(66979);
;// CONCATENATED MODULE: ./packages/web3-providers/src/OpenSea/types.ts
var EventType/**
     * @deprecated
     * use fee instead
     */ ;
(function(EventType) {
    EventType["Successful"] = 'successful';
    EventType["Cancelled"] = 'cancelled';
    EventType["BidEntered"] = 'bid_entered';
    EventType["BidWithdrawn"] = 'bid_withdrawn';
    EventType["Transfer"] = 'transfer';
    EventType["OfferEntered"] = 'offer_entered';
    EventType["Approve"] = 'approve';
})(EventType || (EventType = {}));

;// CONCATENATED MODULE: ./packages/web3-providers/src/OpenSea/utils.ts


function getOrderUSDPrice(currentPrice, usdPrice, decimals) {
    if (!currentPrice || !decimals) return number/* ZERO */.xE;
    const quantity = new bignumber/* BigNumber */.O(currentPrice).div((0,number/* pow10 */.wA)(decimals));
    return new bignumber/* BigNumber */.O(usdPrice ?? 0).multipliedBy(quantity).decimalPlaces(2, 2);
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/OpenSea/constants.ts
const OPENSEA_ACCOUNT_URL = 'https://opensea.io/accounts/:address';
const OPENSEA_API_URL = 'https://opensea-proxy.r2d2.to';

// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/getAssetFullName.ts
var getAssetFullName = __webpack_require__(28289);
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/getPaymentToken.ts
var getPaymentToken = __webpack_require__(34936);
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/fetchJSON.ts
var fetchJSON = __webpack_require__(11834);
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/resolveActivityType.ts
var resolveActivityType = __webpack_require__(15219);
;// CONCATENATED MODULE: ./packages/web3-providers/src/OpenSea/index.ts















async function fetchFromOpenSea(url, chainId, init) {
    if (![
        types/* ChainId */.a_.Mainnet,
        types/* ChainId */.a_.Rinkeby,
        types/* ChainId */.a_.Matic
    ].includes(chainId)) return;
    return (0,fetchJSON/* fetchSquashedJSON */.Vn)((0,dist/* default */.ZP)(OPENSEA_API_URL, url), {
        method: 'GET',
        ...init
    });
}
function createTokenDetailed(chainId, token) {
    if (token.symbol === 'ETH') return ResolverAPI/* ChainResolver */.iv.nativeCurrency(chainId);
    return (0,helpers_token/* createERC20Token */.wY)(chainId, token.address, token.name, token.symbol, token.decimals, token.image_url);
}
function createAssetLink(chainId, address, tokenId) {
    if (chainId === types/* ChainId */.a_.Mainnet) return (0,dist/* default */.ZP)('https://opensea.io/assets/ethereum/:address/:tokenId', {
        address,
        tokenId
    });
    if (chainId === types/* ChainId */.a_.Matic) return (0,dist/* default */.ZP)('https://opensea.io/assets/matic/:address/:tokenId', {
        address,
        tokenId
    });
    return;
}
function createAccountLink(account) {
    if (!account) return '';
    return (0,dist/* default */.ZP)(OPENSEA_ACCOUNT_URL, {
        address: account?.user?.username ?? account?.address
    });
}
function createNFTToken(chainId, asset) {
    const address = asset.token_address ?? asset.asset_contract.address;
    const name = (0,getAssetFullName/* getAssetFullName */.q)(address, asset.name ?? asset.collection.name, asset.name ?? asset.collection.name, asset.token_id);
    return {
        id: asset.token_address ?? asset.asset_contract.address,
        chainId,
        type: specs/* TokenType */.iv.NonFungible,
        schema: asset.asset_contract.schema_name === 'ERC1155' ? types/* SchemaType */.XQ.ERC1155 : types/* SchemaType */.XQ.ERC721,
        tokenId: asset.token_id,
        address,
        metadata: {
            chainId,
            name,
            symbol: asset.asset_contract.symbol,
            description: asset.description,
            imageURL: (0,resolveImageURL/* resolveImageURL */.y)(decodeURIComponent(asset.image_url ?? asset.image_preview_url ?? asset.image_original_url ?? asset.animation_url ?? ''), name, address),
            mediaURL: decodeURIComponent(asset?.animation_url ?? (0,resolver/* resolveIPFS_URL */.mg)(asset?.image_original_url ?? asset?.image_preview_url ?? asset?.image_url ?? ''))
        },
        contract: {
            chainId,
            schema: asset.asset_contract.schema_name === 'ERC1155' ? types/* SchemaType */.XQ.ERC1155 : types/* SchemaType */.XQ.ERC721,
            address,
            name: asset.name ?? asset.collection.name,
            symbol: asset.asset_contract.symbol,
            owner: asset.owner.address,
            creatorEarning: asset.asset_contract.dev_seller_fee_basis_points.toString()
        },
        collection: {
            address,
            chainId,
            name: asset.collection.name,
            slug: asset.collection.slug,
            description: asset.collection.description,
            iconURL: decodeURIComponent(asset.collection.image_url ?? asset.collection.largeImage_url ?? asset.collection.featured_image_url),
            verified: [
                'approved',
                'verified'
            ].includes(asset.collection?.safelist_request_status ?? ''),
            createdAt: (0,getUnixTime/* default */.Z)(new Date(asset.collection.created_date))
        }
    };
}
function createNFTAsset(chainId, asset) {
    const token = createNFTToken(chainId, asset);
    const paymentToken = (0,getPaymentToken/* getPaymentToken */.W)(chainId, {
        address: asset.last_sale?.payment_token.address,
        symbol: asset.last_sale?.payment_token.symbol
    });
    return {
        ...token,
        link: asset.opensea_link ?? asset.permalink ?? createAssetLink(chainId, token.address, token.tokenId),
        paymentTokens: (0,uniqBy/* default */.Z)(asset.collection?.payment_tokens?.map((x)=>createTokenDetailed(chainId, x)), (x)=>x.address.toLowerCase()),
        creator: {
            address: asset.creator.address,
            nickname: asset.creator.user?.username ?? 'Unknown',
            avatarURL: asset.creator.profile_img_url,
            link: createAccountLink(asset.creator)
        },
        owner: {
            address: asset.owner.address,
            nickname: asset.owner.user?.username ?? 'Unknown',
            avatarURL: asset.owner.profile_img_url,
            link: createAccountLink(asset.owner)
        },
        traits: asset.traits.map((x)=>({
                type: x.trait_type,
                value: x.value,
                rarity: (0,formatPercentage/* formatPercentage */.r)((0,number/* dividedBy */.hC)(x.trait_count, asset.collection.stats.count))
            })),
        price: asset.last_sale ? {
            [specs/* CurrencyType */.V2.USD]: getOrderUSDPrice(asset.last_sale.total_price, asset.last_sale.payment_token.usd_price, asset.last_sale.payment_token.decimals)?.toString()
        } : undefined,
        priceInToken: asset.last_sale ? {
            token: paymentToken ?? createTokenDetailed(chainId, {
                address: asset.last_sale.payment_token.address ?? '',
                decimals: Number(asset.last_sale.payment_token.decimals ?? '0'),
                name: '',
                symbol: asset.last_sale.payment_token.symbol ?? ''
            }),
            amount: asset.last_sale.total_price ?? '0'
        } : undefined
    };
}
function createAccount(account) {
    if (!account) return;
    return {
        address: account.address,
        nickname: account.user?.username,
        avatarURL: account.profile_img_url,
        link: createAccountLink(account)
    };
}
function createEvent(chainId, event) {
    const paymentToken = event.payment_token ? (0,helpers_token/* createERC20Token */.wY)(chainId, event.payment_token.address, event.payment_token.name, event.payment_token.symbol, event.payment_token.decimals, event.payment_token.image_url) : undefined;
    return {
        from: createAccount(event.from_account ?? event.seller),
        to: createAccount(event.to_account ?? event.winner_account),
        id: event.id,
        chainId,
        type: (0,resolveActivityType/* resolveActivityType */.G)(event.event_type),
        assetPermalink: event.asset.permalink,
        quantity: event.quantity,
        hash: event.transaction?.transaction_hash,
        timestamp: new Date(`${event.created_date}Z`).getTime(),
        price: event.payment_token ? {
            [specs/* CurrencyType */.V2.USD]: new bignumber/* BigNumber */.O(event.bid_amount ?? event.total_price ?? 0).dividedBy((0,number/* scale10 */.SI)(1, event.payment_token?.decimals)).dividedBy(event.quantity).multipliedBy(event.payment_token?.usd_price ?? 1).toFixed(2)
        } : undefined,
        priceInToken: paymentToken ? {
            amount: event.bid_amount ?? event.total_price ?? '0',
            token: paymentToken
        } : undefined,
        paymentToken,
        source: specs/* SourceType */.PO.OpenSea
    };
}
function createOrder(chainId, event, side) {
    const amount = side === specs/* OrderSide */.oU.Buy ? event.ending_price : event.ending_price;
    return {
        id: `${event.asset.permalink}_${event.created_date}`,
        chainId,
        hash: event.transaction?.transaction_hash,
        assetPermalink: event.asset.permalink,
        quantity: event.quantity,
        side: event.event_type === 'offer_entered' ? specs/* OrderSide */.oU.Buy : undefined,
        maker: createAccount(event.from_account ?? event.seller),
        taker: createAccount(event.to_account ?? event.winner_account),
        createdAt: event.created_date ? (0,getUnixTime/* default */.Z)(new Date(event.created_date)) : undefined,
        price: {
            [specs/* CurrencyType */.V2.USD]: new bignumber/* BigNumber */.O(amount ?? 0).dividedBy((0,number/* scale10 */.SI)(1, event.payment_token?.decimals ?? 0)).dividedBy(event.quantity).multipliedBy(event.payment_token?.usd_price ?? 1).toFixed(2)
        },
        priceInToken: event.payment_token ? {
            amount: amount ?? '0',
            token: (0,helpers_token/* createERC20Token */.wY)(chainId, event.payment_token.address, event.payment_token.name, event.payment_token.symbol, event.payment_token.decimals, event.payment_token.image_url)
        } : undefined,
        source: specs/* SourceType */.PO.OpenSea
    };
}
class OpenSeaAPI {
    async getAsset(address, tokenId, { chainId = types/* ChainId */.a_.Mainnet } = {}) {
        if (!(0,isValidChainId/* isValidChainId */.J)(chainId)) return;
        const response = await fetchFromOpenSea((0,dist/* default */.ZP)('/api/v1/asset/:address/:tokenId', {
            address,
            tokenId
        }), chainId);
        if (!response) return;
        return createNFTAsset(chainId, response);
    }
    async getAssets(account, { chainId = types/* ChainId */.a_.Mainnet, indicator, size = 50 } = {}) {
        if (!(0,isValidChainId/* isValidChainId */.J)(chainId)) return (0,Pageable/* createPageable */.LI)(constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        const response = await fetchFromOpenSea((0,dist/* default */.ZP)('/api/v1/assets', {
            owner: account,
            offset: (indicator?.index ?? 0) * size,
            limit: size,
            cursor: indicator?.id
        }), chainId);
        const tokens = (response?.assets ?? constants/* EMPTY_LIST */.rP)?.filter((x)=>[
                'non-fungible',
                'semi-fungible'
            ].includes(x.asset_contract.asset_contract_type) || [
                'ERC721',
                'ERC1155'
            ].includes(x.asset_contract.schema_name)).map((asset)=>createNFTAsset(chainId, asset));
        return (0,Pageable/* createPageable */.LI)(tokens, (0,Pageable/* createIndicator */.sz)(indicator), tokens.length === size ? (0,Pageable/* createNextIndicator */.gT)(indicator, response?.next) : undefined);
    }
    async getContract(address, { chainId = types/* ChainId */.a_.Mainnet } = {}) {
        const contract = await fetchFromOpenSea((0,dist/* default */.ZP)('/api/v1/asset_contract/:address', {
            address
        }), chainId);
        return (0,token/* createNonFungibleTokenContract */.Xi)(chainId, types/* SchemaType */.XQ.ERC721, address, contract?.name ?? 'Unknown Token', contract?.symbol ?? 'UNKNOWN');
    }
    async getEvents(address, tokenId, { chainId = types/* ChainId */.a_.Mainnet, indicator, size } = {}) {
        if (!(0,isValidChainId/* isValidChainId */.J)(chainId)) return (0,Pageable/* createPageable */.LI)(constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        const parameters = new URLSearchParams();
        parameters.append('event_type', EventType.Successful);
        parameters.append('event_type', EventType.OfferEntered);
        parameters.append('event_type', EventType.Transfer);
        parameters.append('asset_contract_address', address);
        parameters.append('token_id', tokenId);
        if (indicator?.id) parameters.append('cursor', indicator?.id);
        if (size) parameters.append('limit', size.toString());
        const response = await fetchFromOpenSea(`/api/v1/events?${parameters.toString()}`, chainId);
        const events = response?.asset_events?.map((x)=>createEvent(chainId, x)) ?? constants/* EMPTY_LIST */.rP;
        return (0,Pageable/* createPageable */.LI)(events, (0,Pageable/* createIndicator */.sz)(indicator), events.length === size ? (0,Pageable/* createNextIndicator */.gT)(indicator, response?.next) : undefined);
    }
    async getOffers(address, tokenId, options) {
        return this.getOrders(address, tokenId, specs/* OrderSide */.oU.Buy, options);
    }
    async getListings(address, tokenId, options) {
        return this.getOrders(address, tokenId, specs/* OrderSide */.oU.Sell, options);
    }
    async getOrders(address, tokenId, side, { chainId = types/* ChainId */.a_.Mainnet, indicator, size } = {}) {
        if (!(0,isValidChainId/* isValidChainId */.J)(chainId)) return (0,Pageable/* createPageable */.LI)(constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        const response = await fetchFromOpenSea((0,dist/* default */.ZP)('/api/v1/events', {
            asset_contract_address: address,
            token_id: tokenId,
            cursor: indicator?.id,
            limit: size,
            event_type: side === specs/* OrderSide */.oU.Sell ? 'created' : side === specs/* OrderSide */.oU.Buy ? 'offer_entered' : ''
        }), chainId);
        const offers = response?.asset_events?.map((x)=>createOrder(chainId, x, side)) ?? constants/* EMPTY_LIST */.rP;
        return (0,Pageable/* createPageable */.LI)(offers, (0,Pageable/* createIndicator */.sz)(indicator), offers.length === size ? (0,Pageable/* createNextIndicator */.gT)(indicator, response?.next) : undefined);
    }
    async getCollectionsByOwner(address, { chainId = types/* ChainId */.a_.Mainnet, indicator, size = 50 } = {}) {
        if (!(0,isValidChainId/* isValidChainId */.J)(chainId)) return (0,Pageable/* createPageable */.LI)(constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        const response = await fetchFromOpenSea((0,dist/* default */.ZP)('/api/v1/collections', {
            asset_owner: address,
            offset: (indicator?.index ?? 0) * size,
            limit: size
        }), chainId);
        if (!response) return (0,Pageable/* createPageable */.LI)(constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        const collections = response?.map((x)=>({
                chainId,
                name: x.name,
                slug: x.slug,
                address: x.primary_asset_contracts?.[0]?.address,
                symbol: x.primary_asset_contracts?.[0]?.symbol,
                schema: x.primary_asset_contracts?.[0]?.schema_name === 'ERC1155' ? types/* SchemaType */.XQ.ERC1155 : types/* SchemaType */.XQ.ERC721,
                description: x.description,
                iconURL: x.image_url,
                balance: x.owned_asset_count,
                verified: [
                    'approved',
                    'verified'
                ].includes(x.safelist_request_status ?? ''),
                createdAt: (0,getUnixTime/* default */.Z)(new Date(x.created_date))
            })).filter((x)=>x.address) ?? constants/* EMPTY_LIST */.rP;
        return (0,Pageable/* createPageable */.LI)(collections, (0,Pageable/* createIndicator */.sz)(indicator), collections.length === size ? (0,Pageable/* createNextIndicator */.gT)(indicator) : undefined);
    }
    async getStats(address, { chainId = types/* ChainId */.a_.Mainnet } = {}) {
        if (!(0,isValidChainId/* isValidChainId */.J)(chainId)) return;
        const assetContract = await fetchFromOpenSea((0,dist/* default */.ZP)('/api/v1/asset_contract/:address', {
            address
        }), chainId);
        const slug = assetContract?.collection.slug;
        if (!slug) return;
        const response = await fetchFromOpenSea((0,dist/* default */.ZP)('/api/v1/collection/:slug/stats', {
            slug
        }), chainId);
        const stats = response?.stats;
        if (!stats) return;
        return {
            volume24h: stats.one_day_volume,
            floorPrice: stats.floor_price,
            count24h: stats.one_day_sales
        };
    }
}
const OpenSea = new OpenSeaAPI();


/***/ }),

/***/ 16658:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   m: () => (/* binding */ R2D2TokenList)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(43434);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(72601);
/* harmony import */ var _masknet_kit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30898);
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(52033);
/* harmony import */ var _masknet_flags__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(51573);
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(62649);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(24770);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(33026);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(41487);
/* harmony import */ var _Web3_EVM_apis_ResolverAPI_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(66979);
/* harmony import */ var _helpers_fetchCached_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(22674);
/* harmony import */ var _helpers_fetchJSON_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(11834);









const fetchTokenList = (0,_masknet_kit__WEBPACK_IMPORTED_MODULE_0__/* .memoizePromise */ .J3)(lodash_es__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z, async (url)=>{
    return (0,_helpers_fetchJSON_js__WEBPACK_IMPORTED_MODULE_3__/* .fetchCachedJSON */ .MP)(url, {
        cache: 'default'
    }, {
        cacheDuration: _helpers_fetchCached_js__WEBPACK_IMPORTED_MODULE_4__/* .Duration */ .nL.TWELVE_HOURS
    });
}, (url)=>url);
/**
 * Fetch tokens from common token list
 * @param url
 * @param chainId
 */ async function fetchCommonERC20TokensFromTokenList(url, chainId = _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_5__/* .ChainId */ .a_.Mainnet) {
    return (await fetchTokenList(url)).tokens.filter((x)=>x.chainId === chainId && ( true && _masknet_flags__WEBPACK_IMPORTED_MODULE_1__/* .env */ .O.channel === 'stable' ? _Web3_EVM_apis_ResolverAPI_js__WEBPACK_IMPORTED_MODULE_6__/* .ChainResolver */ .iv.isMainnet(chainId) : true)).map((x)=>({
            id: x.address,
            type: _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_7__/* .TokenType */ .iv.Fungible,
            schema: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_5__/* .SchemaType */ .XQ.ERC20,
            ...x,
            logoURL: x.originLogoURI || x.logoURI
        }));
}
/**
 * Fetch tokens adapter
 * @param urls
 * @param chainId
 */ async function fetchERC20TokensFromTokenList(urls, chainId = _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_5__/* .ChainId */ .a_.Mainnet) {
    const allRequest = urls.map(async (x)=>{
        const tokens = await fetchCommonERC20TokensFromTokenList(x, chainId);
        return {
            tokens,
            weight: x.startsWith('https://tokens.r2d2.to') ? 1 : 0
        };
    });
    const allListResponse = await Promise.allSettled(allRequest);
    return allListResponse.map((x)=>x.status === 'fulfilled' ? x.value : {
            tokens: [],
            weight: 0
        });
}
/**
 * Fetch tokens from multiple token lists
 * @param urls
 * @param chainId
 */ class R2D2TokenListAPI {
    async getFungibleTokenList(chainId, urls) {
        const { FUNGIBLE_TOKEN_LISTS = _masknet_shared_base__WEBPACK_IMPORTED_MODULE_8__/* .EMPTY_LIST */ .rP } = (0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_9__/* .getTokenListConstants */ .Hi)(chainId);
        const result = (0,_masknet_kit__WEBPACK_IMPORTED_MODULE_0__/* .memoizePromise */ .J3)(lodash_es__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z, async (urls, chainId = _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_5__/* .ChainId */ .a_.Mainnet)=>{
            const tokens = (await fetchERC20TokensFromTokenList(urls, chainId)).sort((a, b)=>b.weight - a.weight).flatMap((x)=>x.tokens);
            return (0,lodash_es__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(tokens, (x)=>x.address.toLowerCase()).map((token)=>{
                return {
                    ...token,
                    address: (0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_11__/* .formatEthereumAddress */ .j8)(token.address)
                };
            });
        }, (urls, chainId)=>`${chainId}-${urls.join(',')}`);
        return result(urls ?? FUNGIBLE_TOKEN_LISTS, chainId);
    }
    async getNonFungibleTokenList(chainId, urls) {
        return _masknet_shared_base__WEBPACK_IMPORTED_MODULE_8__/* .EMPTY_LIST */ .rP;
    }
}
const R2D2TokenList = new R2D2TokenListAPI();


/***/ }),

/***/ 23516:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  S: () => (/* binding */ RSS3)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/urlcat@3.1.0_patch_hash=5r5xyq4zgcnqugwsrx4lxq2i4e/node_modules/urlcat/dist/index.mjs
var dist = __webpack_require__(78757);
// EXTERNAL MODULE: ./packages/web3-telemetry/src/providers/index.ts + 10 modules
var providers = __webpack_require__(17788);
// EXTERNAL MODULE: ./packages/web3-telemetry/src/types/index.ts
var types = __webpack_require__(91451);
// EXTERNAL MODULE: ./packages/shared-base/src/Pageable/index.ts
var Pageable = __webpack_require__(38645);
// EXTERNAL MODULE: ./packages/shared-base-ui/src/data/queryClient.ts
var queryClient = __webpack_require__(73401);
// EXTERNAL MODULE: ./packages/web3-providers/src/RSS3/constants.ts
var constants = __webpack_require__(61220);
// EXTERNAL MODULE: ./packages/web3-providers/src/RSS3/types.ts
var RSS3_types = __webpack_require__(28058);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/resolver.ts
var resolver = __webpack_require__(53007);
;// CONCATENATED MODULE: ./packages/web3-providers/src/RSS3/helpers.ts

/**
 * Normalize RSS3 feed.
 *
 * @affects
 *   feed.actions[number].metadata.image
 *   feed.actions[number].metadata.token.image
 *   feed.actions[number].metadata.logo
 *
 * - resolve image resource
 */ function normalizedFeed(feed) {
    feed.actions.forEach((action)=>{
        if (!action.metadata) return;
        if ('image' in action.metadata) {
            action.metadata.image = (0,resolver/* resolveResourceURL */.Bl)(action.metadata.image);
        } else if ('token' in action.metadata) {
            action.metadata.token.image = (0,resolver/* resolveResourceURL */.Bl)(action.metadata.token.image);
        } else if ('logo' in action.metadata) {
            action.metadata.logo = (0,resolver/* resolveResourceURL */.Bl)(action.metadata.logo);
        }
    });
}

// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/fetchJSON.ts
var fetchJSON = __webpack_require__(11834);
// EXTERNAL MODULE: ./packages/web3-providers/src/types/RSS3.ts
var types_RSS3 = __webpack_require__(83838);
// EXTERNAL MODULE: ./node_modules/.pnpm/rss3-next@0.6.17_patch_hash=db27yqpr4wdtpwfyvaxcqd4jpi_typescript@5.3.0-beta/node_modules/rss3-next/dist/browser/RSS3.js
var browser_RSS3 = {
	/* dynamic */ get a() {
		var exports = __webpack_require__(20262);
		if (exports.__esModule) Object.defineProperty(this, "a", { value: exports });
		return exports;
	}

};
;// CONCATENATED MODULE: ./packages/web3-providers/src/RSS3/apis/RSS3API.ts











const fetchFromRSS3 = (url)=>{
    return queryClient/* queryClient */.E.fetchQuery({
        queryKey: [
            url
        ],
        staleTime: 10_000,
        queryFn: ()=>(0,fetchJSON/* fetchJSON */.ZV)(url)
    });
};
class RSS3 {
    static createRSS3(address, sign = ()=>{
        throw new Error('Not supported.');
    }) {
        return new browser_RSS3.a({
            endpoint: constants/* RSS3_LEGACY_ENDPOINT */.Qj,
            address,
            sign
        });
    }
    static async getFileData(rss3, address, key) {
        const file = await rss3.files.get(address);
        if (!file) throw new Error('The account was not found.');
        const descriptor = Object.getOwnPropertyDescriptor(file, key);
        return descriptor?.value;
    }
    static async setFileData(rss3, address, key, data) {
        const file = await rss3.files.get(address);
        if (!file) throw new Error('The account was not found.');
        const descriptor = Object.getOwnPropertyDescriptor(file, key);
        const value = {
            ...(descriptor?.value),
            ...data
        };
        rss3.files.set(Object.assign(file, {
            [key]: value
        }));
        await rss3.files.sync();
        return value;
    }
    static async getDonations(address, { indicator, size = 100 } = {}) {
        if (!address) return (0,Pageable/* createPageable */.LI)([], (0,Pageable/* createIndicator */.sz)(indicator));
        const collectionURL = (0,dist/* default */.ZP)(constants/* RSS3_FEED_ENDPOINT */.Bl, address, {
            tag: RSS3_types/* TAG */.Kg.donation,
            type: RSS3_types/* TYPE */.wD.donate,
            limit: size,
            cursor: indicator?.id,
            include_poap: true
        });
        const { result: donations, cursor } = await fetchFromRSS3(collectionURL);
        // A donation Feed contains multiple donation Actions. Let's flatten them.
        const result = donations.flatMap((donation)=>{
            return donation.actions.map((action)=>({
                    ...donation,
                    actions: [
                        action
                    ]
                }));
        });
        return (0,Pageable/* createPageable */.LI)(result, (0,Pageable/* createIndicator */.sz)(indicator), (0,Pageable/* createNextIndicator */.gT)(indicator, cursor));
    }
    static async getFootprints(address, { indicator, size = 100 } = {}) {
        if (!address) return (0,Pageable/* createPageable */.LI)([], (0,Pageable/* createIndicator */.sz)(indicator));
        const collectionURL = (0,dist/* default */.ZP)(constants/* RSS3_FEED_ENDPOINT */.Bl, address, {
            tag: RSS3_types/* TAG */.Kg.collectible,
            type: RSS3_types/* TYPE */.wD.poap,
            limit: size,
            cursor: indicator?.id,
            include_poap: true
        });
        const { result, cursor } = await fetchFromRSS3(collectionURL);
        return (0,Pageable/* createPageable */.LI)(result, (0,Pageable/* createIndicator */.sz)(indicator), (0,Pageable/* createNextIndicator */.gT)(indicator, cursor));
    }
    /** get .csb handle info */ static async getNameInfo(handle) {
        if (!handle) return;
        const url = (0,dist/* default */.ZP)('https://pregod.rss3.dev/v1/ns/:id', {
            id: handle
        });
        return fetchFromRSS3(url);
    }
    /**
     * @deprecated
     * Get feeds in tags of donation, collectible and transaction
     */ static async getWeb3Feeds(address, { indicator, size = 100 } = {}) {
        if (!address) return (0,Pageable/* createPageable */.LI)([], (0,Pageable/* createIndicator */.sz)(indicator));
        const tags = [
            types_RSS3.RSS3BaseAPI.Tag.Donation,
            types_RSS3.RSS3BaseAPI.Tag.Collectible,
            types_RSS3.RSS3BaseAPI.Tag.Transaction
        ];
        const queryString = `tag=${tags.join('&tag=')}&${(0,dist/* query */.IO)({
            limit: size,
            cursor: indicator?.id ?? '',
            include_poap: true
        })}`;
        const url = (0,dist/* default */.ZP)(constants/* RSS3_FEED_ENDPOINT */.Bl, `/:address?${queryString}`, {
            address
        });
        const { result, cursor } = await fetchFromRSS3(url);
        result.forEach(normalizedFeed);
        return (0,Pageable/* createPageable */.LI)(result, (0,Pageable/* createIndicator */.sz)(indicator), (0,Pageable/* createNextIndicator */.gT)(indicator, cursor));
    }
    static async getAllNotes(address, options = {}, { indicator, size = 100 } = {}) {
        if (!address) return (0,Pageable/* createPageable */.LI)([], (0,Pageable/* createIndicator */.sz)(indicator));
        const url = (0,dist/* default */.ZP)(constants/* RSS3_FEED_ENDPOINT */.Bl, '/:address', {
            ...options,
            address,
            limit: size,
            cursor: indicator?.id ?? ''
        });
        const res = await fetchFromRSS3(url);
        if (!res.result) providers/* Telemetry */.M.captureException(types/* ExceptionType */.wz.Error, types/* ExceptionID */.T$.FetchError, new Error(`No feeds response from ${url}`));
        const { result = [], cursor } = res;
        result.forEach(normalizedFeed);
        // createNextIndicator() return a fallback indicator as `{ id: 1, index: 1 }`
        // which will fail the API, so we pass undefined if cursor is undefined
        return (0,Pageable/* createPageable */.LI)(result, (0,Pageable/* createIndicator */.sz)(indicator), cursor ? (0,Pageable/* createNextIndicator */.gT)(indicator, cursor) : undefined);
    }
    static async getProfiles(handle) {
        const url = (0,dist/* default */.ZP)(constants/* RSS3_ENDPOINT */.Py, '/profiles/:handle', {
            handle
        });
        const response = await fetchFromRSS3(url);
        if ('error' in response) return [];
        return response.result;
    }
    static async getNameService(handle) {
        const url = (0,dist/* default */.ZP)(constants/* RSS3_ENDPOINT */.Py, '/ns/:handle', {
            handle
        });
        const response = await fetchFromRSS3(url);
        const suffix = handle.split('.').pop();
        if ('error' in response) return;
        return {
            address: response.address,
            chainId: constants/* NameServiceToChainMap */.Qs[suffix]
        };
    }
}


/***/ }),

/***/ 61220:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Bl: () => (/* binding */ RSS3_FEED_ENDPOINT),
/* harmony export */   J_: () => (/* binding */ PlatformToChainIdMap),
/* harmony export */   Py: () => (/* binding */ RSS3_ENDPOINT),
/* harmony export */   Qj: () => (/* binding */ RSS3_LEGACY_ENDPOINT),
/* harmony export */   Qs: () => (/* binding */ NameServiceToChainMap)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24770);
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28058);


const RSS3_LEGACY_ENDPOINT = 'https://hub.pass3.me';
const RSS3_ENDPOINT = 'https://pregod.rss3.dev/v1';
const RSS3_FEED_ENDPOINT = 'https://pregod.rss3.dev/v1/notes/';
/** Lowercase platform as key */ const PlatformToChainIdMap = {
    [_types_js__WEBPACK_IMPORTED_MODULE_0__/* .NETWORK */ .IB.arbitrum]: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Arbitrum,
    [_types_js__WEBPACK_IMPORTED_MODULE_0__/* .NETWORK */ .IB.avalanche]: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Avalanche,
    [_types_js__WEBPACK_IMPORTED_MODULE_0__/* .NETWORK */ .IB.crossbell]: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Crossbell,
    [_types_js__WEBPACK_IMPORTED_MODULE_0__/* .NETWORK */ .IB.ethereum]: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet,
    [_types_js__WEBPACK_IMPORTED_MODULE_0__/* .NETWORK */ .IB.binance_smart_chain]: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.BSC,
    [_types_js__WEBPACK_IMPORTED_MODULE_0__/* .NETWORK */ .IB.polygon]: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Matic,
    [_types_js__WEBPACK_IMPORTED_MODULE_0__/* .NETWORK */ .IB.xdai]: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.xDai,
    [_types_js__WEBPACK_IMPORTED_MODULE_0__/* .NETWORK */ .IB.optimism]: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Optimism,
    [_types_js__WEBPACK_IMPORTED_MODULE_0__/* .NETWORK */ .IB.fantom]: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Fantom
};
const NameServiceToChainMap = {
    eth: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet,
    csb: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Crossbell,
    lens: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Matic,
    bnb: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.BSC,
    bit: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet,
    888: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet,
    bitcoin: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet,
    blockchain: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet,
    crypto: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet,
    dao: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet,
    nft: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet,
    wallet: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet,
    x: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet,
    zil: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet
};


/***/ }),

/***/ 28058:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IB: () => (/* binding */ NETWORK),
/* harmony export */   Kg: () => (/* binding */ TAG),
/* harmony export */   wD: () => (/* binding */ TYPE)
/* harmony export */ });
/* unused harmony exports CollectionType, PLATFORM */
var CollectionType;
(function(CollectionType) {
    CollectionType["NFTs"] = "NFTs";
    CollectionType["Donations"] = "Donations";
    CollectionType["Footprints"] = "Footprints";
    CollectionType["Feeds"] = "Feeds";
})(CollectionType || (CollectionType = {}));
var TAG;
(function(TAG) {
    TAG["NFT"] = "NFT";
    TAG["Token"] = "Token";
    TAG["POAP"] = "POAP";
    TAG["Gitcoin"] = "Gitcoin";
    TAG["Mirror"] = 'Mirror Entry';
    TAG["ETH"] = "ETH";
})(TAG || (TAG = {}));
var NETWORK;
(function(NETWORK) {
    NETWORK["ethereum"] = "ethereum";
    NETWORK["ethereum_classic"] = "ethereum_classic";
    NETWORK["binance_smart_chain"] = "binance_smart_chain";
    NETWORK["polygon"] = "polygon";
    NETWORK["zksync"] = "zksync";
    NETWORK["xdai"] = "xdai";
    NETWORK["arweave"] = "arweave";
    NETWORK["arbitrum"] = "arbitrum";
    NETWORK["optimism"] = "optimism";
    NETWORK["fantom"] = "fantom";
    NETWORK["avalanche"] = "avalanche";
    NETWORK["crossbell"] = "crossbell";
})(NETWORK || (NETWORK = {}));
var PLATFORM;
(function(PLATFORM) {
    PLATFORM["mirror"] = "mirror";
    PLATFORM["lens"] = "lens";
    PLATFORM["gitcoin"] = "gitcoin";
    PLATFORM["snapshot"] = "snapshot";
    PLATFORM["uniswap"] = "uniswap";
    PLATFORM["binance"] = "binance";
    PLATFORM["crossbell"] = "crossbell";
})(PLATFORM || (PLATFORM = {}));
(function(TAG) {
    TAG["social"] = "social";
    TAG["transaction"] = "transaction";
    TAG["exchange"] = "exchange";
    TAG["collectible"] = "collectible";
    TAG["donation"] = "donation";
    TAG["governance"] = "governance";
})(TAG || (TAG = {}));
var TYPE/** @example vitalik.lens */ /** @example vitalik.lens */ /** Could be http url, or ipfs url */ /** hex address */ ;
(function(TYPE) {
    TYPE["transfer"] = "transfer";
    TYPE["mint"] = "mint";
    TYPE["burn"] = "burn";
    TYPE["withdraw"] = "withdraw";
    TYPE["deposit"] = "deposit";
    TYPE["swap"] = "swap";
    TYPE["trade"] = "trade";
    TYPE["poap"] = "poap";
    TYPE["post"] = "post";
    TYPE["comment"] = "comment";
    TYPE["share"] = "share";
    TYPE["profile"] = "profile";
    TYPE["follow"] = "follow";
    TYPE["unfollow"] = "unfollow";
    TYPE["like"] = "like";
    TYPE["propose"] = "propose";
    TYPE["vote"] = "vote";
    TYPE["launch"] = "launch";
    TYPE["donate"] = "donate";
})(TYPE || (TYPE = {}));


/***/ }),

/***/ 70451:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  C: () => (/* binding */ Rabby)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/urlcat@3.1.0_patch_hash=5r5xyq4zgcnqugwsrx4lxq2i4e/node_modules/urlcat/dist/index.mjs
var dist = __webpack_require__(78757);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/omit.js + 1 modules
var omit = __webpack_require__(17711);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/isValidChainId.ts
var isValidChainId = __webpack_require__(37049);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/isSameAddress.ts
var isSameAddress = __webpack_require__(74765);
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/getAllMaskDappContractInfo.tsx
var getAllMaskDappContractInfo = __webpack_require__(85944);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Rabby/constants.ts
const NON_FUNGIBLE_TOKEN_API_URL = 'https://api.rabby.io/v1/user/nft_authorized_list';
const FUNGIBLE_TOKEN_API_URL = 'https://api.rabby.io/v1/user/token_authorized_list';

// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/fetchJSON.ts
var fetchJSON = __webpack_require__(11834);
// EXTERNAL MODULE: ./packages/web3-providers/src/DeBank/constants.ts
var constants = __webpack_require__(10663);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Rabby/index.ts








class RabbyAPI {
    async getNonFungibleTokenSpenders(chainId, account) {
        const maskDappContractInfoList = (0,getAllMaskDappContractInfo/* getAllMaskDappContractInfo */.i)(chainId, 'nft');
        const debankChainId = constants/* CHIAN_ID_TO_DEBANK_CHAIN_MAP */.El[chainId];
        if (!debankChainId || !account || !(0,isValidChainId/* isValidChainId */.J)(chainId)) return [];
        const rawData = await (0,fetchJSON/* fetchJSON */.ZV)((0,dist/* default */.ZP)(NON_FUNGIBLE_TOKEN_API_URL, {
            id: account,
            chain_id: debankChainId
        }));
        return rawData.contracts.filter((x)=>x.amount !== '0' && x.is_erc721).map((x)=>{
            const maskDappContractInfo = maskDappContractInfoList.find((y)=>(0,isSameAddress/* isSameAddress */.W)(y.address, x.spender.id));
            if (maskDappContractInfo) {
                return {
                    ...x,
                    contract: {
                        address: x.contract_id,
                        name: x.contract_name
                    },
                    address: x.spender.id,
                    name: maskDappContractInfo.name,
                    logo: maskDappContractInfo.logo,
                    isMaskDapp: true
                };
            }
            return {
                ...x,
                ...x.spender,
                address: x.spender.id,
                contract: {
                    address: x.contract_id,
                    name: x.contract_name
                },
                isMaskDapp: false
            };
        }).sort((a, b)=>{
            if (a.isMaskDapp && !b.isMaskDapp) return -1;
            if (!a.isMaskDapp && b.isMaskDapp) return 1;
            return Number(b.amount) - Number(a.amount);
        });
    }
    async getFungibleTokenSpenders(chainId, account) {
        const maskDappContractInfoList = (0,getAllMaskDappContractInfo/* getAllMaskDappContractInfo */.i)(chainId, 'token');
        const debankChainId = constants/* CHIAN_ID_TO_DEBANK_CHAIN_MAP */.El[chainId];
        if (!debankChainId || !account || !(0,isValidChainId/* isValidChainId */.J)(chainId)) return [];
        const rawData = await (0,fetchJSON/* fetchJSON */.ZV)((0,dist/* default */.ZP)(FUNGIBLE_TOKEN_API_URL, {
            id: account,
            chain_id: debankChainId
        }));
        return rawData.reduce((acc, cur)=>{
            const tokenInfo = (0,omit/* default */.Z)({
                ...cur,
                address: cur.id,
                logoURL: cur.logo_url
            }, [
                'spenders'
            ]);
            return acc.concat(cur.spenders.map((rawSpender)=>{
                const spender = (0,omit/* default */.Z)({
                    ...rawSpender,
                    name: rawSpender.protocol?.name,
                    logo: rawSpender.protocol?.logo_url,
                    address: rawSpender.id,
                    amount: rawSpender.value,
                    tokenInfo
                }, [
                    'protocol'
                ]);
                const maskDappContractInfo = maskDappContractInfoList.find((x)=>(0,isSameAddress/* isSameAddress */.W)(x.address, spender.id));
                if (maskDappContractInfo) {
                    return {
                        ...spender,
                        name: maskDappContractInfo.name,
                        logo: maskDappContractInfo.logo,
                        isMaskDapp: true
                    };
                }
                return {
                    ...spender,
                    isMaskDapp: false
                };
            }));
        }, []).sort((a, b)=>{
            if (a.isMaskDapp && !b.isMaskDapp) return -1;
            if (!a.isMaskDapp && b.isMaskDapp) return 1;
            return b.exposure_usd - a.exposure_usd;
        });
    }
}
const Rabby = new RabbyAPI();


/***/ }),

/***/ 33286:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  $: () => (/* binding */ RedPacketAPI)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/urlcat@3.1.0_patch_hash=5r5xyq4zgcnqugwsrx4lxq2i4e/node_modules/urlcat/dist/index.mjs
var dist = __webpack_require__(78757);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/mapKeys.js
var mapKeys = __webpack_require__(37350);
// EXTERNAL MODULE: ./packages/shared-base/src/Pageable/index.ts
var Pageable = __webpack_require__(38645);
// EXTERNAL MODULE: ./packages/shared-base/src/constants.ts
var constants = __webpack_require__(52033);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/attemptUntil.ts
var attemptUntil = __webpack_require__(92358);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/decodeFunctionData.ts
var decodeFunctionData = __webpack_require__(35640);
// EXTERNAL MODULE: ./packages/web3-contracts/abis/HappyRedPacketV4.json
var HappyRedPacketV4 = __webpack_require__(74122);
// EXTERNAL MODULE: ./packages/web3-contracts/abis/NftRedPacket.json
var NftRedPacket = __webpack_require__(80847);
// EXTERNAL MODULE: ./packages/web3-providers/src/DSearch/constants.ts
var DSearch_constants = __webpack_require__(68235);
// EXTERNAL MODULE: ./packages/web3-providers/src/DSearch/helpers.ts
var helpers = __webpack_require__(26750);
// EXTERNAL MODULE: ./packages/shared-base/src/helpers/asyncIterator.ts
var asyncIterator = __webpack_require__(67830);
// EXTERNAL MODULE: ./packages/web3-providers/src/Chainbase/constants.ts
var Chainbase_constants = __webpack_require__(60174);
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/fetchJSON.ts
var fetchJSON = __webpack_require__(11834);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Chainbase/apis/RedPacketAPI.ts




class ChainbaseRedPacketAPI {
    async getHistoryTransactions(chainId, senderAddress, contractAddress, methodId) {
        try {
            const txs = await (0,asyncIterator/* asyncIteratorToArray */.S)((0,Pageable/* pageableToIterator */.T1)(async (indicator)=>{
                const { records } = await (0,fetchJSON/* fetchJSON */.ZV)((0,dist/* default */.ZP)(Chainbase_constants/* TRANSACTIONS_BY_CONTRACT_METHOD_ENDPOINT */.Kx, {
                    senderAddress,
                    contractAddress,
                    chainId,
                    methodId: `${methodId}%`,
                    // '%' for sql string match.
                    size: Chainbase_constants/* MAX_SIZE_PER_PAGE */.Ei,
                    offset: Number(indicator?.id ?? 0) * Chainbase_constants/* MAX_SIZE_PER_PAGE */.Ei
                }));
                return (0,Pageable/* createPageable */.LI)(records.data.result, (0,Pageable/* createIndicator */.sz)(indicator), records.data.result.length === 0 ? undefined : (0,Pageable/* createNextIndicator */.gT)(indicator));
            }));
            if (!txs?.length) return;
            return txs.sort((a, b)=>new Date(b.block_timestamp).getTime() - new Date(a.block_timestamp).getTime()).map((x)=>({
                    input: x.input,
                    to: x.to_address,
                    from: x.from_address,
                    hash: x.transaction_hash,
                    chainId,
                    blockNumber: Number(x.block_number)
                }));
        } catch  {
            return;
        }
    }
}
const ChainbaseRedPacket = new ChainbaseRedPacketAPI();

// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/isSameAddress.ts
var isSameAddress = __webpack_require__(74765);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/libs/EtherscanURL.ts
var EtherscanURL = __webpack_require__(4070);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Etherscan/apis/RedPacketAPI.ts




class EtherscanRedPacketAPI {
    async getHistoryTransactions(chainId, senderAddress, contractAddress, methodId, startBlock, endBlock) {
        if (!senderAddress || !contractAddress || !startBlock || !endBlock || !methodId) return;
        try {
            const { result } = await (0,fetchJSON/* fetchJSON */.ZV)((0,dist/* default */.ZP)(EtherscanURL/* EtherscanURL */.c.from(chainId), {
                action: 'txlist',
                module: 'account',
                sort: 'desc',
                startBlock,
                endBlock,
                address: contractAddress,
                chain_id: chainId
            }));
            if (!result) return;
            return result.filter((x)=>x.methodId?.toLowerCase() === methodId.toLowerCase() && (0,isSameAddress/* isSameAddress */.W)(x.from, senderAddress)).map((x)=>({
                    ...x,
                    chainId
                }));
        } catch  {
            return;
        }
    }
}
const EtherscanRedPacket = new EtherscanRedPacketAPI();

// EXTERNAL MODULE: ./node_modules/.pnpm/date-fns@2.30.0/node_modules/date-fns/esm/secondsToMilliseconds/index.js
var secondsToMilliseconds = __webpack_require__(18375);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/abiCoder.ts
var abiCoder = __webpack_require__(1853);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/ResolverAPI.ts
var ResolverAPI = __webpack_require__(66979);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/ConnectionReadonlyAPI.ts + 2 modules
var ConnectionReadonlyAPI = __webpack_require__(3543);
;// CONCATENATED MODULE: ./packages/web3-providers/src/RedPacket/constants.ts
const CREATE_LUCKY_DROP_TOPIC = '0x86af556fd7cfab9462285ad44f2d5913527c539ff549f74731ca9997ca534018';

;// CONCATENATED MODULE: ./packages/web3-providers/src/RedPacket/api.ts







const creationSuccessTopicInputs = HappyRedPacketV4.find((x)=>x.name === 'CreationSuccess')?.inputs;
class ContractRedPacketAPI {
    Web3 = new ConnectionReadonlyAPI/* ConnectionReadonlyAPI */.S();
    async getHistories(chainId, senderAddress, contractAddress, methodId, fromBlock, toBlock) {
        if (!senderAddress || !contractAddress || !fromBlock || !toBlock || !methodId) return;
        const logs = await this.Web3.getWeb3({
            chainId
        }).eth.getPastLogs({
            topics: [
                CREATE_LUCKY_DROP_TOPIC
            ],
            address: contractAddress,
            fromBlock,
            toBlock
        });
        return logs.map((log)=>{
            const result = abiCoder/* abiCoder */.r.decodeLog(creationSuccessTopicInputs, log.data, [
                CREATE_LUCKY_DROP_TOPIC
            ]);
            // 10
            // 86400
            return {
                result,
                log
            };
        }).filter((x)=>(0,isSameAddress/* isSameAddress */.W)(x.result.creator, senderAddress)).map((x)=>({
                contract_address: contractAddress,
                txid: x.log.transactionHash,
                chainId,
                shares: Number(x.result.number),
                is_random: x.result.ifrandom,
                total: x.result.total,
                duration: (0,secondsToMilliseconds/* default */.Z)(Number(x.result.duration)),
                block_number: x.log.blockNumber,
                contract_version: 4,
                network: ResolverAPI/* ChainResolver */.iv.networkType(chainId),
                token_address: x.result.token_address,
                sender: {
                    address: senderAddress,
                    name: x.result.name,
                    message: x.result.message
                },
                rpid: x.result.id,
                creation_time: (0,secondsToMilliseconds/* default */.Z)(Number(x.result.creation_time)),
                // #region Retrieve at RedPacketInHistoryList component
                total_remaining: '',
                // #endregion
                // #region Retrieve from database
                password: ''
            }));
    }
} // #endregion

;// CONCATENATED MODULE: ./packages/web3-providers/src/RedPacket/index.ts













class RedPacketAPI {
    ContractRedPacket = new ContractRedPacketAPI();
    getHistories(chainId, senderAddress, contractAddress, methodId, fromBlock, endBlock) {
        return (0,attemptUntil/* attemptUntil */.C)([
            async ()=>this.ContractRedPacket.getHistories(chainId, senderAddress, contractAddress, methodId, fromBlock, endBlock),
            async ()=>this.parseRedPacketCreationTransactions(await this.getHistoryTransactions(chainId, senderAddress, contractAddress, methodId, fromBlock, endBlock), senderAddress)
        ], []);
    }
    async getNFTHistories(chainId, senderAddress, contractAddress, methodId, fromBlock, endBlock) {
        return this.parseNFTRedPacketCreationTransactions(await this.getHistoryTransactions(chainId, senderAddress, contractAddress, methodId, fromBlock, endBlock), senderAddress);
    }
    async getHistoryTransactions(chainId, senderAddress, contractAddress, methodId, fromBlock, endBlock) {
        return (0,attemptUntil/* attemptUntil */.C)([
            async ()=>await EtherscanRedPacket.getHistoryTransactions(chainId, senderAddress, contractAddress, methodId, fromBlock, endBlock),
            async ()=>await ChainbaseRedPacket.getHistoryTransactions(chainId, senderAddress, contractAddress, methodId)
        ], []);
    }
    async getCollectionsByOwner(account, { chainId, indicator } = {}) {
        const result = await (0,helpers/* fetchFromDSearch */.u)((0,dist/* default */.ZP)(DSearch_constants/* DSEARCH_BASE_URL */.Z, '/nft-lucky-drop/specific-list.json'));
        const list = (0,mapKeys/* default */.Z)(result, (_v, k)=>k.toLowerCase())?.[account.toLowerCase()].filter((x)=>x.chainId === chainId);
        return (0,Pageable/* createPageable */.LI)(list, (0,Pageable/* createIndicator */.sz)(indicator));
    }
    parseNFTRedPacketCreationTransactions(transactions, senderAddress) {
        if (!transactions) return constants/* EMPTY_LIST */.rP;
        return transactions.flatMap((tx)=>{
            try {
                const decodedInputParam = (0,decodeFunctionData/* decodeFunctionData */.p)(NftRedPacket, tx.input ?? '', 'create_red_packet');
                const redpacketPayload = {
                    contract_address: tx.to,
                    txid: tx.hash ?? '',
                    contract_version: 1,
                    shares: decodedInputParam._erc721_token_ids.length,
                    network: ResolverAPI/* ChainResolver */.iv.networkType(tx.chainId),
                    token_address: decodedInputParam._token_addr,
                    chainId: tx.chainId,
                    sender: {
                        address: senderAddress,
                        name: decodedInputParam._name,
                        message: decodedInputParam._message
                    },
                    duration: decodedInputParam._duration.toNumber() * 1000,
                    token_ids: decodedInputParam._erc721_token_ids.map((x)=>x.toString()),
                    // #region Retrieve at NFT History List Item.
                    rpid: '',
                    creation_time: 0,
                    // #endregion
                    // #region Retrieve from database
                    password: ''
                };
                // #endregion
                return redpacketPayload;
            } catch  {
                return constants/* EMPTY_LIST */.rP;
            }
        });
    }
    parseRedPacketCreationTransactions(transactions, senderAddress) {
        if (!transactions) return constants/* EMPTY_LIST */.rP;
        return transactions.flatMap((tx)=>{
            try {
                const decodedInputParam = (0,decodeFunctionData/* decodeFunctionData */.p)(HappyRedPacketV4, tx.input ?? '', 'create_red_packet');
                const redpacketPayload = {
                    contract_address: tx.to,
                    txid: tx.hash ?? '',
                    chainId: tx.chainId,
                    shares: decodedInputParam._number.toNumber(),
                    is_random: decodedInputParam._ifrandom,
                    total: decodedInputParam._total_tokens.toString(),
                    duration: decodedInputParam._duration.toNumber() * 1000,
                    block_number: Number(tx.blockNumber),
                    contract_version: 4,
                    network: ResolverAPI/* ChainResolver */.iv.networkType(tx.chainId),
                    token_address: decodedInputParam._token_addr,
                    sender: {
                        address: senderAddress,
                        name: decodedInputParam._name,
                        message: decodedInputParam._message
                    },
                    // #region Retrieve at RedPacketInHistoryList component
                    rpid: '',
                    creation_time: 0,
                    total_remaining: '',
                    // #endregion
                    // #region Retrieve from database
                    password: ''
                };
                // #endregion
                return redpacketPayload;
            } catch  {
                return constants/* EMPTY_LIST */.rP;
            }
        });
    }
}


/***/ }),

/***/ 86440:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   t: () => (/* binding */ SID_Domain)
/* harmony export */ });
/* harmony import */ var urlcat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78757);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24770);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(65327);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(89019);
/* harmony import */ var _helpers_fetchJSON_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(11834);
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(53007);




const ROOT_HOST = 'https://api.prd.space.id';
class SID_DomainAPI {
    resolveTLD(chainId) {
        switch(chainId){
            case _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.BSC:
                return 'bnb';
            case _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Arbitrum:
                return 'arb1';
            default:
                return;
        }
    }
    async lookup(chainId, name) {
        const tld = this.resolveTLD(chainId);
        if (!tld) return;
        const url = (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .resolveCrossOriginURL */ .nX)((0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(ROOT_HOST, '/v1/getAddress', {
            tld,
            domain: name
        }));
        const result = await (0,_helpers_fetchJSON_js__WEBPACK_IMPORTED_MODULE_3__/* .fetchCachedJSON */ .MP)(url);
        if (result.code === 0 && (0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_4__/* .isValidAddress */ .At)(result.address)) return result.address;
        return;
    }
    async reverse(chainId, address) {
        const tld = this.resolveTLD(chainId);
        if (!tld) return;
        const url = (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .resolveCrossOriginURL */ .nX)((0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(ROOT_HOST, '/v1/getName', {
            tld,
            address
        }));
        const result = await (0,_helpers_fetchJSON_js__WEBPACK_IMPORTED_MODULE_3__/* .fetchCachedJSON */ .MP)(url);
        if (result.code === 0 && (0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_5__/* .isValidDomain */ .h)(result.name)) return result.name;
        return;
    }
}
const SID_Domain = new SID_DomainAPI();


/***/ }),

/***/ 63087:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  f: () => (/* binding */ SimpleHashEVM)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/urlcat@3.1.0_patch_hash=5r5xyq4zgcnqugwsrx4lxq2i4e/node_modules/urlcat/dist/index.mjs
var dist = __webpack_require__(78757);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/compact.js
var compact = __webpack_require__(72845);
// EXTERNAL MODULE: ./packages/icons/icon-generated-as-url.js
var icon_generated_as_url = __webpack_require__(54169);
// EXTERNAL MODULE: ./packages/shared-base/src/types/PluginID.ts
var PluginID = __webpack_require__(24835);
// EXTERNAL MODULE: ./packages/shared-base/src/Pageable/index.ts
var Pageable = __webpack_require__(38645);
// EXTERNAL MODULE: ./packages/shared-base/src/constants.ts
var constants = __webpack_require__(52033);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/specs/index.ts
var specs = __webpack_require__(62649);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/number.ts
var number = __webpack_require__(29763);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/formatBalance.ts
var formatBalance = __webpack_require__(95325);
// EXTERNAL MODULE: ./node_modules/.pnpm/date-fns@2.30.0/node_modules/date-fns/esm/millisecondsToSeconds/index.js
var millisecondsToSeconds = __webpack_require__(26548);
// EXTERNAL MODULE: ./node_modules/.pnpm/date-fns@2.30.0/node_modules/date-fns/esm/secondsToMilliseconds/index.js
var secondsToMilliseconds = __webpack_require__(18375);
// EXTERNAL MODULE: ./node_modules/.pnpm/date-fns@2.30.0/node_modules/date-fns/esm/isAfter/index.js
var isAfter = __webpack_require__(55906);
// EXTERNAL MODULE: ./node_modules/.pnpm/date-fns@2.30.0/node_modules/date-fns/esm/subSeconds/index.js
var subSeconds = __webpack_require__(55159);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/types/index.ts
var types = __webpack_require__(24770);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/isValidChainId.ts
var isValidChainId = __webpack_require__(37049);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/constants/primitives.ts
var primitives = __webpack_require__(47469);
// EXTERNAL MODULE: ./packages/web3-providers/src/SimpleHash/helpers.ts
var helpers = __webpack_require__(91053);
// EXTERNAL MODULE: ./packages/web3-providers/src/LooksRare/index.ts + 2 modules
var LooksRare = __webpack_require__(33215);
// EXTERNAL MODULE: ./packages/web3-providers/src/OpenSea/index.ts + 3 modules
var OpenSea = __webpack_require__(65680);
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/getContractSymbol.ts
var getContractSymbol = __webpack_require__(95794);
// EXTERNAL MODULE: ./packages/web3-providers/src/NFTScan/helpers/utils.ts
var utils = __webpack_require__(55859);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/ResolverAPI.ts
var ResolverAPI = __webpack_require__(66979);
// EXTERNAL MODULE: ./node_modules/.pnpm/immer@10.0.2/node_modules/immer/dist/immer.mjs
var immer = __webpack_require__(35268);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/maxBy.js
var maxBy = __webpack_require__(88393);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/uniqBy.js
var uniqBy = __webpack_require__(72601);
// EXTERNAL MODULE: ./node_modules/.pnpm/bignumber.js@9.1.2/node_modules/bignumber.js/bignumber.mjs
var bignumber = __webpack_require__(10149);
;// CONCATENATED MODULE: ./packages/web3-providers/src/SimpleHash/historicalPriceState.ts





class HistoricalPriceState {
    _priceState = {};
    _paymentTokenState = {};
    _allLoadedIdListState = [];
    get priceState() {
        return this._priceState;
    }
    getPriceStats(id, range) {
        const allStats = this._priceState[id];
        return range ? allStats.filter((x)=>x[0] > range) : allStats;
    }
    getHighestPrice(id) {
        return this._priceState[id] ? (0,maxBy/* default */.Z)(this._priceState[id], (x)=>x[1])?.[1] : undefined;
    }
    isLoaded(id, fromTimeStamp) {
        return !!this._allLoadedIdListState.find((x)=>x === id) || fromTimeStamp && !!this._priceState[id]?.find((x)=>x[0] < fromTimeStamp);
    }
    updatePriceState(id, priceStats, paymentToken) {
        if (!paymentToken) return;
        this._priceState = (0,immer/* produce */.Uy)(this._priceState, (draft)=>{
            if (!draft[id]) draft[id] = constants/* EMPTY_LIST */.rP;
            priceStats.map((x)=>[
                    new Date(x.timestamp).getTime(),
                    new bignumber/* BigNumber */.O((0,number/* leftShift */.w5)(x.floor_price, paymentToken.decimals).toPrecision(4)).toNumber()
                ]);
            draft[id] = (0,uniqBy/* default */.Z)(draft[id].concat(priceStats.map((x)=>[
                    new Date(x.timestamp).getTime(),
                    new bignumber/* BigNumber */.O((0,number/* leftShift */.w5)(x.floor_price, paymentToken.decimals).toPrecision(4)).toNumber()
                ])).sort((a, b)=>a[0] - b[0]), (x)=>x[0]);
        });
        this._paymentTokenState = (0,immer/* produce */.Uy)(this._paymentTokenState, (draft)=>{
            draft[id] = paymentToken;
        });
    }
    updateAllLoadedIdListState(id) {
        this._allLoadedIdListState = (0,immer/* produce */.Uy)(this._allLoadedIdListState, (draft)=>draft.concat(id));
    }
}
const historicalPriceState = new HistoricalPriceState();

// EXTERNAL MODULE: ./packages/web3-providers/src/SimpleHash/constants.ts
var SimpleHash_constants = __webpack_require__(62595);
// EXTERNAL MODULE: ./packages/web3-providers/src/types/SimpleHash.ts
var SimpleHash = __webpack_require__(40838);
;// CONCATENATED MODULE: ./packages/web3-providers/src/SimpleHash/apis/EVM.ts

















class SimpleHashAPI_EVM {
    async getCollectionByContractAddress(address, { chainId = types/* ChainId */.a_.Mainnet } = {}) {
        const chain = (0,helpers/* resolveChain */.Or)(PluginID/* NetworkPluginID */.F.PLUGIN_EVM, chainId);
        if (!chain || !address || !(0,isValidChainId/* isValidChainId */.J)(chainId)) return;
        const path = (0,dist/* default */.ZP)('/api/v0/nfts/collections/:chain/:address', {
            chain,
            address
        });
        const { collections } = await (0,helpers/* fetchFromSimpleHash */.d$)(path);
        return collections[0];
    }
    async getAsset(address, tokenId, { chainId = types/* ChainId */.a_.Mainnet, account } = {}) {
        const chain = (0,helpers/* resolveChain */.Or)(PluginID/* NetworkPluginID */.F.PLUGIN_EVM, chainId);
        if (!chain || !address || !tokenId || !(0,isValidChainId/* isValidChainId */.J)(chainId)) return;
        const path = (0,dist/* default */.ZP)('/api/v0/nfts/:chain/:address/:tokenId', {
            chain,
            address,
            tokenId
        });
        const response = await (0,helpers/* fetchFromSimpleHash */.d$)(path);
        const asset = (0,helpers/* createNonFungibleAsset */.HN)(response);
        if (asset?.schema === types/* SchemaType */.XQ.ERC1155 && account) {
            const pathToQueryOwner = (0,dist/* default */.ZP)('/api/v0/nfts/contracts', {
                chains: chain,
                wallet_addresses: account,
                contract_addresses: asset.address
            });
            const ownershipResponse = await (0,helpers/* fetchFromSimpleHash */.d$)(pathToQueryOwner);
            if (ownershipResponse.wallets?.[0]?.contracts?.[0].token_ids?.includes(asset.tokenId)) {
                asset.owner = {
                    address: account
                };
            }
        }
        return asset;
    }
    async getCollectionOverview(chainId, id) {
        const path = (0,dist/* default */.ZP)('/api/v0/nfts/collections_activity', {
            collection_ids: id
        });
        const response = await (0,helpers/* fetchFromSimpleHash */.d$)(path);
        const overview = response.collections[0];
        const floorPricePath = (0,dist/* default */.ZP)('/api/v0/nfts/floor_prices/collection/:id/opensea', {
            id
        });
        const floorPriceResponse = await (0,helpers/* fetchFromSimpleHash */.d$)(floorPricePath);
        return {
            collection: overview.name,
            market_cap: (0,formatBalance/* formatBalance */.a)(overview.market_cap, overview.payment_token.decimals),
            average_price_change_1d: overview['1_day_volume_change_percent'] + '%',
            volume_24h: (0,formatBalance/* formatBalance */.a)(overview['1_day_volume'], overview.payment_token.decimals),
            average_price_24h: (0,formatBalance/* formatBalance */.a)(floorPriceResponse['1_day_average'], overview.payment_token.decimals),
            total_volume: (0,formatBalance/* formatBalance */.a)(overview.all_time_volume, overview.payment_token.decimals)
        };
    }
    async getAssets(account, { chainId = types/* ChainId */.a_.Mainnet, indicator } = {}) {
        const chain = (0,helpers/* resolveChain */.Or)(PluginID/* NetworkPluginID */.F.PLUGIN_EVM, chainId);
        if (!account || !(0,isValidChainId/* isValidChainId */.J)(chainId) || !chain) {
            return (0,Pageable/* createPageable */.LI)(constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        }
        const path = (0,dist/* default */.ZP)('/api/v0/nfts/owners', {
            chains: chain,
            wallet_addresses: account,
            contract_addresses: '',
            cursor: typeof indicator?.index !== 'undefined' && indicator.index !== 0 ? indicator.id : undefined
        });
        const response = await (0,helpers/* fetchFromSimpleHash */.d$)(path);
        const assets = response.nfts.map((x)=>(0,helpers/* createNonFungibleAsset */.HN)(x)).filter(Boolean);
        return (0,Pageable/* createPageable */.LI)(assets, indicator, response.next_cursor ? (0,Pageable/* createNextIndicator */.gT)(indicator, response.next_cursor) : undefined);
    }
    async getAssetsByCollection(address, { chainId = types/* ChainId */.a_.Mainnet, indicator } = {}) {
        const chain = (0,helpers/* resolveChain */.Or)(PluginID/* NetworkPluginID */.F.PLUGIN_EVM, chainId);
        if (!chain || !address || !(0,isValidChainId/* isValidChainId */.J)(chainId)) {
            return (0,Pageable/* createPageable */.LI)(constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        }
        const path = (0,dist/* default */.ZP)(`/api/v0/nfts/${chain}/:address`, {
            address,
            cursor: typeof indicator?.index !== 'undefined' && indicator.index !== 0 ? indicator.id : undefined
        });
        const response = await (0,helpers/* fetchFromSimpleHash */.d$)(path);
        const assets = response.nfts.map((x)=>(0,helpers/* createNonFungibleAsset */.HN)(x)).filter(Boolean);
        return (0,Pageable/* createPageable */.LI)(assets, (0,Pageable/* createIndicator */.sz)(indicator), response.next_cursor ? (0,Pageable/* createNextIndicator */.gT)(indicator, response.next_cursor) : undefined);
    }
    async getCoinPriceStats(chainId, collectionId, currency, days) {
        const range = (0,helpers/* resolveSimpleHashRange */.jo)(days);
        const to_timeStamp = (0,millisecondsToSeconds/* default */.Z)(Date.now());
        const isLoadAll = !range;
        const from_timeStamp = isLoadAll ? SimpleHash_constants/* SIMPLE_HASH_HISTORICAL_PRICE_START_TIME */.bv : to_timeStamp - range;
        let cursor = '';
        while(cursor !== null && !historicalPriceState.isLoaded(collectionId, (0,secondsToMilliseconds/* default */.Z)(from_timeStamp))){
            const path = (0,dist/* default */.ZP)('/api/v0/nfts/floor_prices/collection/:collectionId/opensea', {
                collectionId,
                to_timeStamp,
                from_timeStamp,
                cursor: cursor ? cursor : undefined
            });
            const response = await (0,helpers/* fetchFromSimpleHash */.d$)(path);
            const firstFloorPriceTimeStamp = response.floor_prices?.[0]?.timestamp;
            cursor = !firstFloorPriceTimeStamp || (0,isAfter/* default */.Z)((0,secondsToMilliseconds/* default */.Z)(from_timeStamp), new Date(firstFloorPriceTimeStamp)) ? null : response.next_cursor;
            historicalPriceState.updatePriceState(collectionId, response.floor_prices, response.payment_token);
        }
        if (isLoadAll) historicalPriceState.updateAllLoadedIdListState(collectionId);
        return historicalPriceState.getPriceStats(collectionId, isLoadAll ? undefined : (0,subSeconds/* default */.Z)(Date.now(), range).getTime());
    }
    async getHighestFloorPrice(collectionId) {
        let cursor = '';
        while(cursor !== null && !historicalPriceState.isLoaded(collectionId)){
            const path = (0,dist/* default */.ZP)('/api/v0/nfts/floor_prices/collection/:collectionId/opensea', {
                collectionId,
                cursor: cursor ? cursor : undefined
            });
            const response = await (0,helpers/* fetchFromSimpleHash */.d$)(path);
            cursor = response.next_cursor;
            historicalPriceState.updatePriceState(collectionId, response.floor_prices, response.payment_token);
        }
        historicalPriceState.updateAllLoadedIdListState(collectionId);
        return historicalPriceState.getHighestPrice(collectionId);
    }
    async getOneDaySaleAmounts(collectionId) {
        const to_timeStamp = (0,millisecondsToSeconds/* default */.Z)(Date.now());
        const from_timeStamp = (0,millisecondsToSeconds/* default */.Z)((0,subSeconds/* default */.Z)(Date.now(), 60 * 60 * 24).getTime());
        let sales = [];
        let cursor = '';
        while(cursor !== null){
            const path = (0,dist/* default */.ZP)('/api/v0/nfts/transfers/collection/:collectionId', {
                collectionId,
                only_sales: 1,
                to_timeStamp,
                from_timeStamp,
                cursor: cursor ? cursor : undefined
            });
            const response = await (0,helpers/* fetchFromSimpleHash */.d$)(path);
            const firstFloorPriceTimeStamp = response.transfers?.[0]?.timestamp;
            cursor = !firstFloorPriceTimeStamp || (0,isAfter/* default */.Z)((0,secondsToMilliseconds/* default */.Z)(from_timeStamp), new Date(firstFloorPriceTimeStamp)) ? null : response.next_cursor;
            sales = sales.concat(response.transfers);
        }
        return sales.filter((x)=>(0,isAfter/* default */.Z)(new Date(x.timestamp), (0,secondsToMilliseconds/* default */.Z)(from_timeStamp))).length;
    }
    async getCollectionsByOwner(account, { chainId, indicator, allChains, schemaType } = {}) {
        const pluginId = PluginID/* NetworkPluginID */.F.PLUGIN_EVM;
        const isERC712Only = schemaType === types/* SchemaType */.XQ.ERC721;
        const chain = allChains || !chainId ? (0,helpers/* getAllChainNames */.rM)(pluginId) : (0,helpers/* resolveChain */.Or)(pluginId, chainId);
        if (!chain || !account || !(0,isValidChainId/* isValidChainId */.J)(chainId)) {
            return (0,Pageable/* createPageable */.LI)(constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        }
        const path = (0,dist/* default */.ZP)('/api/v0/nfts/collections_by_wallets', {
            chains: chain,
            wallet_addresses: account,
            nft_ids: 1
        });
        const response = await (0,helpers/* fetchFromSimpleHash */.d$)(path);
        const filteredCollections = response.collections.// Might got bad data responded including id field and other fields empty
        filter((x)=>{
            if (!x?.id || x.spam_score !== null && x.spam_score >= SimpleHash_constants/* SPAM_SCORE */.Rk) return false;
            return (0,isValidChainId/* isValidChainId */.J)((0,helpers/* resolveChainId */.MQ)(x.chain)) && x.top_contracts.length > 0 && (!(0,helpers/* isLensFollower */.ax)(x.name) || !isERC712Only);
        });
        let erc721CollectionIdList = constants/* EMPTY_LIST */.rP;
        if (isERC712Only) {
            const nftIdList = filteredCollections.map((x)=>x.nft_ids?.[0] || '').filter(Boolean);
            while(nftIdList.length){
                const batchAssetsPath = (0,dist/* default */.ZP)('/api/v0/nfts/assets', {
                    nft_ids: nftIdList.splice(0, 50).join(',')
                });
                const batchAssetsResponse = await (0,helpers/* fetchFromSimpleHash */.d$)(batchAssetsPath);
                erc721CollectionIdList = erc721CollectionIdList.concat(batchAssetsResponse.nfts.filter((x)=>x.contract.type === 'ERC721').map((x)=>x.collection.collection_id));
            }
        }
        const collections = filteredCollections.filter((x)=>!isERC712Only || erc721CollectionIdList.includes(x.id)).map((x)=>(0,helpers/* createNonFungibleCollection */.wP)(x));
        return (0,Pageable/* createPageable */.LI)(collections, (0,Pageable/* createIndicator */.sz)(indicator));
    }
    async getAssetsByCollectionAndOwner(collectionId, owner, { chainId = types/* ChainId */.a_.Mainnet, indicator, size = 50 } = {}) {
        const chain = (0,helpers/* resolveChain */.Or)(PluginID/* NetworkPluginID */.F.PLUGIN_EVM, chainId);
        if (!chain || !(0,isValidChainId/* isValidChainId */.J)(chainId) || !collectionId || !owner) return (0,Pageable/* createPageable */.LI)(constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        const path = (0,dist/* default */.ZP)('/api/v0/nfts/owners', {
            chains: chain,
            wallet_addresses: owner,
            collection_ids: collectionId,
            cursor: typeof indicator?.index !== 'undefined' && indicator.index !== 0 ? indicator.id : undefined,
            limit: size
        });
        const response = await (0,helpers/* fetchFromSimpleHash */.d$)(path);
        const assets = response.nfts.map((x)=>(0,helpers/* createNonFungibleAsset */.HN)(x)).filter(Boolean);
        return (0,Pageable/* createPageable */.LI)(assets, (0,Pageable/* createIndicator */.sz)(indicator), response.next_cursor ? (0,Pageable/* createNextIndicator */.gT)(indicator, response.next_cursor) : undefined);
    }
    async getCollectionVerifiedBy(id) {
        const collection = await this.getSimpleHashCollection(id);
        if (!collection) return [];
        const marketplaces = collection.marketplace_pages?.filter((x)=>x.verified) || [];
        return marketplaces.map((x)=>x.marketplace_name);
    }
    async getCoinActivities(chainId, id, cursor) {
        const chain = (0,helpers/* resolveChain */.Or)(PluginID/* NetworkPluginID */.F.PLUGIN_EVM, chainId);
        if (!chain || !(0,isValidChainId/* isValidChainId */.J)(chainId) || !id) return;
        const path = (0,dist/* default */.ZP)('/api/v0/nfts/transfers/:chain/:id', {
            id,
            chain,
            cursor: cursor ? cursor : undefined,
            order_by: 'timestamp_desc',
            limit: 50
        });
        const response = await (0,helpers/* fetchFromSimpleHash */.d$)(path);
        if (!response?.transfers?.length) return;
        const batchAssetsPath = (0,dist/* default */.ZP)('/api/v0/nfts/assets', {
            nft_ids: response.transfers.map((x)=>x.nft_id).join(',')
        });
        const batchAssetsResponse = await (0,helpers/* fetchFromSimpleHash */.d$)(batchAssetsPath);
        return {
            cursor: response.next_cursor,
            content: response.transfers.map((x)=>{
                const trade_token = !x.sale_details?.payment_token || (0,helpers/* checkBlurToken */.p3)(PluginID/* NetworkPluginID */.F.PLUGIN_EVM, chainId, x.sale_details.payment_token?.address || '') ? ResolverAPI/* ChainResolver */.iv.nativeCurrency(chainId) : {
                    ...x.sale_details?.payment_token,
                    type: specs/* TokenType */.iv.Fungible,
                    address: x.sale_details?.payment_token.payment_token_id.includes('native') ? primitives/* ZERO_ADDRESS */.r : x.sale_details?.payment_token.address ?? '',
                    id: x.sale_details?.payment_token.payment_token_id.includes('native') ? primitives/* ZERO_ADDRESS */.r : x.sale_details?.payment_token.address ?? '',
                    chainId,
                    schema: types/* SchemaType */.XQ.ERC20
                };
                const imageURL = batchAssetsResponse.nfts.find((y)=>y.nft_id === x.nft_id)?.image_url ?? '';
                return {
                    hash: x.transaction,
                    from: x.from_address,
                    token_id: x.token_id,
                    transaction_link: ResolverAPI/* ExplorerResolver */.Xz.transactionLink(chainId, x.transaction),
                    event_type: (0,helpers/* resolveEventType */.zG)(x.event_type),
                    send: x.from_address,
                    receive: x.event_type === SimpleHash/* SimpleHash */.C.ActivityType.Burn ? primitives/* ZERO_ADDRESS */.r : x.to_address,
                    to: x.event_type === SimpleHash/* SimpleHash */.C.ActivityType.Burn ? primitives/* ZERO_ADDRESS */.r : x.to_address,
                    trade_token,
                    timestamp: new Date(x.timestamp).getTime(),
                    trade_price: x.sale_details?.total_price ? (0,number/* leftShift */.w5)(x.sale_details?.total_price, trade_token.decimals).toNumber() : 0,
                    imageURL,
                    contract_address: x.contract_address,
                    trade_symbol: trade_token.symbol ?? '',
                    token_address: trade_token.address ?? ''
                };
            })
        };
    }
    async getCoinTrending(chainId, address) {
        const collection = await this.getCollectionByContractAddress(address, {
            chainId
        });
        if (!collection) {
            throw new Error(`SimpleHash: Can not find collection by address ${address}, chainId ${chainId}`);
        }
        const [symbol, openseaStats, looksrareStats] = await Promise.all([
            (0,getContractSymbol/* getContractSymbol */.l)(chainId, address),
            OpenSea/* OpenSea */.N.getStats(address).catch(()=>null),
            LooksRare/* LooksRare */.X.getStats(address).catch(()=>null)
        ]);
        const paymentToken = collection.floor_prices[0]?.payment_token;
        if (!paymentToken) return;
        const tickers = (0,compact/* default */.Z)([
            openseaStats ? {
                logo_url: icon_generated_as_url/* open_sea_url */.Khl().toString(),
                // TODO
                trade_url: `https://opensea.io/assets/ethereum/${address}`,
                market_name: utils/* NonFungibleMarketplace */.vo.OpenSea,
                volume_24h: openseaStats.volume24h,
                floor_price: openseaStats.floorPrice,
                price_symbol: paymentToken?.symbol,
                sales_24: openseaStats.count24h
            } : null,
            looksrareStats ? {
                logo_url: icon_generated_as_url/* looks_rare_url */.bGE().toString(),
                trade_url: `https://looksrare.org/collections/${address}`,
                market_name: utils/* NonFungibleMarketplace */.vo.LooksRare,
                volume_24h: looksrareStats.volume24h,
                floor_price: looksrareStats.floorPrice,
                price_symbol: paymentToken?.symbol,
                sales_24: looksrareStats.count24h
            } : null
        ]);
        return {
            lastUpdated: new Date().toJSON(),
            dataProvider: specs/* SourceType */.PO.SimpleHash,
            contracts: [
                {
                    chainId,
                    address,
                    pluginID: PluginID/* NetworkPluginID */.F.PLUGIN_EVM
                }
            ],
            currency: {
                id: paymentToken?.payment_token_id,
                symbol: paymentToken?.symbol,
                name: paymentToken?.symbol,
                chainId
            },
            coin: {
                id: collection.collection_id,
                name: collection.name,
                symbol,
                address,
                contract_address: address,
                type: specs/* TokenType */.iv.NonFungible,
                description: collection.description,
                image_url: collection.image_url,
                home_urls: [
                    collection.external_url
                ],
                community_urls: [
                    {
                        type: 'twitter',
                        link: collection.twitter_username ? `https://twitter.com/${collection.twitter_username}` : null
                    },
                    {
                        type: 'facebook',
                        // TODO format of facebook url is unknown
                        link: null
                    },
                    {
                        type: 'discord',
                        link: collection.discord_url
                    },
                    {
                        type: 'instagram',
                        link: collection.instagram_username ? `https://www.instagram.com/${collection.instagram_username}` : null
                    },
                    {
                        type: 'medium',
                        link: collection.medium_username ? `https://medium.com/@${collection.medium_username}` : null
                    },
                    {
                        type: 'reddit',
                        link: null
                    },
                    {
                        type: 'telegram',
                        link: collection.telegram_url
                    },
                    {
                        type: 'youtube',
                        link: null
                    },
                    {
                        type: 'github',
                        link: null
                    }
                ].filter((x)=>x.link)
            },
            market: {
                total_supply: collection.total_quantity,
                current_price: (0,number/* leftShift */.w5)(collection.floor_prices[0]?.value, paymentToken?.decimals).toString(),
                floor_price: (0,number/* leftShift */.w5)(collection.floor_prices[0]?.value, paymentToken?.decimals).toString(),
                owners_count: collection.distinct_owner_count,
                volume_24h: tickers?.[0]?.volume_24h,
                total_24h: tickers?.[0]?.sales_24,
                price_symbol: paymentToken?.symbol || 'ETH',
                price_token_address: paymentToken?.address || ''
            },
            tickers
        };
    }
    async getSimpleHashCollection(id) {
        const path = (0,dist/* default */.ZP)('/api/v0/nfts/collections/ids', {
            collection_ids: id
        });
        const response = await (0,helpers/* fetchFromSimpleHash */.d$)(path);
        return response.collections[0];
    }
}
const SimpleHashEVM = new SimpleHashAPI_EVM();


/***/ }),

/***/ 62595:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EC: () => (/* binding */ ETH_BLUR_TOKEN_ADDRESS),
/* harmony export */   Rk: () => (/* binding */ SPAM_SCORE),
/* harmony export */   b_: () => (/* binding */ SIMPLE_HASH_URL),
/* harmony export */   bv: () => (/* binding */ SIMPLE_HASH_HISTORICAL_PRICE_START_TIME)
/* harmony export */ });
const SIMPLE_HASH_URL = 'https://simplehash-proxy.r2d2.to';
const ETH_BLUR_TOKEN_ADDRESS = '0x0000000000a39bb272e79075ade125fd351887ac';
const SIMPLE_HASH_HISTORICAL_PRICE_START_TIME = 1669852800;
const SPAM_SCORE = 50;


/***/ }),

/***/ 91053:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HN: () => (/* binding */ createNonFungibleAsset),
/* harmony export */   MQ: () => (/* binding */ resolveChainId),
/* harmony export */   Or: () => (/* binding */ resolveChain),
/* harmony export */   ax: () => (/* binding */ isLensFollower),
/* harmony export */   d$: () => (/* binding */ fetchFromSimpleHash),
/* harmony export */   jo: () => (/* binding */ resolveSimpleHashRange),
/* harmony export */   p3: () => (/* binding */ checkBlurToken),
/* harmony export */   rM: () => (/* binding */ getAllChainNames),
/* harmony export */   wP: () => (/* binding */ createNonFungibleCollection),
/* harmony export */   zG: () => (/* binding */ resolveEventType)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8610);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(43434);
/* harmony import */ var _masknet_kit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30898);
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(62649);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(37049);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(24770);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(46854);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(81438);
/* harmony import */ var _masknet_web3_shared_solana__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(97834);
/* harmony import */ var _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(59190);
/* harmony import */ var _masknet_shared_base_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(73401);
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(24835);
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(74170);
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(89087);
/* harmony import */ var _NFTScan_helpers_EVM_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(68208);
/* harmony import */ var _Web3_EVM_apis_ResolverAPI_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(66979);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(62595);
/* harmony import */ var _helpers_fetchJSON_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11834);
/* harmony import */ var _helpers_getAssetFullName_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(28289);
/* harmony import */ var _types_SimpleHash_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(40838);














async function fetchFromSimpleHash(path, init) {
    return _masknet_shared_base_ui__WEBPACK_IMPORTED_MODULE_1__/* .queryClient */ .E.fetchQuery({
        queryKey: [
            'simple-hash',
            path
        ],
        staleTime: 10_000,
        queryFn: async ()=>{
            return (0,_helpers_fetchJSON_js__WEBPACK_IMPORTED_MODULE_2__/* .fetchSquashedJSON */ .Vn)(`${_constants_js__WEBPACK_IMPORTED_MODULE_3__/* .SIMPLE_HASH_URL */ .b_}${path}`, {
                method: 'GET',
                mode: 'cors',
                headers: {
                    'content-type': 'application/json'
                }
            });
        }
    });
}
function createNonFungibleAsset(asset) {
    if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(asset)) return;
    const chainId = resolveChainId(asset.chain);
    const address = asset.contract_address;
    const spam_score = asset.collection.spam_score;
    if (!chainId || !(0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_5__/* .isValidChainId */ .J)(chainId) || !address || spam_score !== null && spam_score >= _constants_js__WEBPACK_IMPORTED_MODULE_3__/* .SPAM_SCORE */ .Rk) return;
    const schema = asset.contract.type === 'ERC721' ? _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__/* .SchemaType */ .XQ.ERC721 : _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__/* .SchemaType */ .XQ.ERC1155;
    const name = asset.name || (0,_helpers_getAssetFullName_js__WEBPACK_IMPORTED_MODULE_7__/* .getAssetFullName */ .q)(asset.contract_address, asset.contract.name, asset.name, asset.token_id);
    return {
        id: address,
        chainId,
        link: (0,_NFTScan_helpers_EVM_js__WEBPACK_IMPORTED_MODULE_8__/* .createPermalink */ .Nu)(chainId, address, asset.token_id),
        tokenId: asset.token_id,
        type: _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_9__/* .TokenType */ .iv.NonFungible,
        address,
        schema,
        creator: {
            address: asset.contract.deployed_by
        },
        owner: {
            address: asset.owners?.[0].owner_address
        },
        priceInToken: asset.last_sale ? {
            amount: asset.last_sale.total_price?.toString() || '',
            // FIXME: cannot get payment token
            token: asset.last_sale.payment_token?.symbol === 'ETH' ? _Web3_EVM_apis_ResolverAPI_js__WEBPACK_IMPORTED_MODULE_10__/* .ChainResolver */ .iv.nativeCurrency(chainId) ?? _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_11__/* .WNATIVE */ .FX[chainId] : _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_11__/* .WNATIVE */ .FX[chainId]
        } : undefined,
        metadata: {
            chainId,
            name,
            tokenId: asset.token_id,
            symbol: asset.contract.symbol,
            description: asset.description,
            imageURL: (0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_12__/* .resolveImageURL */ .y)(asset.image_url || asset.previews.image_large_url, asset.name, asset.collection.name, asset.contract_address),
            previewImageURL: (0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_12__/* .resolveImageURL */ .y)(asset.previews.image_small_url, asset.name, asset.collection.name, asset.contract_address),
            blurhash: asset.previews.blurhash,
            mediaURL: asset.image_url || asset.previews.image_large_url
        },
        contract: {
            chainId,
            schema,
            address: asset.contract_address,
            name: asset.contract.name,
            symbol: asset.contract.symbol
        },
        collection: {
            chainId,
            name: asset.collection.name || '',
            slug: asset.contract.name,
            description: asset.collection.description,
            address: asset.contract_address,
            iconURL: asset.collection.image_url,
            verified: Boolean(asset.collection.marketplace_pages?.some((x)=>x.verified)),
            createdAt: new Date(asset.created_date).getTime(),
            floorPrices: asset.collection.floor_prices
        },
        source: _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_9__/* .SourceType */ .PO.SimpleHash,
        traits: asset.extra_metadata?.attributes.map((x)=>({
                type: x.trait_type,
                value: x.value,
                displayType: x.display_type
            })) || []
    };
}
function createNonFungibleCollection(collection) {
    const chainId = resolveChainId(collection.chain);
    const verifiedMarketplaces = collection.marketplace_pages?.filter((x)=>x.verified) || [];
    return {
        id: collection.id,
        chainId,
        name: collection.name || '',
        slug: collection.name,
        schema: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__/* .SchemaType */ .XQ.ERC721,
        balance: collection.distinct_nfts_owned,
        iconURL: collection.image_url,
        ownersTotal: collection.total_quantity,
        source: _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_9__/* .SourceType */ .PO.SimpleHash,
        address: collection.top_contracts?.[0]?.split('.')?.[1] ?? '',
        verified: verifiedMarketplaces.length > 0,
        verifiedBy: verifiedMarketplaces.map((x)=>x.marketplace_name)
    };
}
const resolveChainId = (0,lodash_es__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(function resolveChainId(chain) {
    // Some of the `chainResolver.chainId()` results do not match.
    switch(chain){
        case 'ethereum':
            return _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__/* .ChainId */ .a_.Mainnet;
        case 'polygon':
            return _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__/* .ChainId */ .a_.Matic;
        case 'arbitrum':
            return _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__/* .ChainId */ .a_.Arbitrum;
        case 'optimism':
            return _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__/* .ChainId */ .a_.Optimism;
        case 'avalanche':
            return _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__/* .ChainId */ .a_.Avalanche;
        case 'gnosis':
            return _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__/* .ChainId */ .a_.xDai;
        case 'bsc':
            return _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__/* .ChainId */ .a_.BSC;
        case 'base':
            return _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__/* .ChainId */ .a_.Base;
        case 'scroll':
            return _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__/* .ChainId */ .a_.Scroll;
        case 'celo':
            return _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__/* .ChainId */ .a_.Celo;
        default:
            return undefined;
    }
});
const ChainNameMap = {
    [_masknet_shared_base__WEBPACK_IMPORTED_MODULE_14__/* .NetworkPluginID */ .F.PLUGIN_EVM]: {
        [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__/* .ChainId */ .a_.Mainnet]: 'ethereum',
        [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__/* .ChainId */ .a_.BSC]: 'bsc',
        [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__/* .ChainId */ .a_.Matic]: 'polygon',
        [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__/* .ChainId */ .a_.Arbitrum]: 'arbitrum',
        [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__/* .ChainId */ .a_.Optimism]: 'optimism',
        [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__/* .ChainId */ .a_.Avalanche]: 'avalanche',
        [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__/* .ChainId */ .a_.xDai]: 'gnosis',
        [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__/* .ChainId */ .a_.Base]: 'base',
        [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__/* .ChainId */ .a_.Scroll]: 'scroll',
        [_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__/* .ChainId */ .a_.Celo]: 'celo'
    },
    [_masknet_shared_base__WEBPACK_IMPORTED_MODULE_14__/* .NetworkPluginID */ .F.PLUGIN_SOLANA]: {
        [_masknet_web3_shared_solana__WEBPACK_IMPORTED_MODULE_15__/* .ChainId */ .a_.Mainnet]: 'solana'
    },
    [_masknet_shared_base__WEBPACK_IMPORTED_MODULE_14__/* .NetworkPluginID */ .F.PLUGIN_FLOW]: {
        [_masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_16__/* .ChainId */ .a_.Mainnet]: 'flow'
    }
};
const getAllChainNames = (pluginID)=>{
    return Object.values(ChainNameMap[pluginID]).join(',');
};
function resolveChain(pluginId, chainId) {
    return ChainNameMap[pluginId][chainId];
}
function checkBlurToken(pluginId, chainId, address) {
    return `${resolveChain(pluginId, chainId)}.${address.toLowerCase()}` === `ethereum.${_constants_js__WEBPACK_IMPORTED_MODULE_3__/* .ETH_BLUR_TOKEN_ADDRESS */ .EC}`;
}
function isLensFollower(name) {
    if (!name) return false;
    return name.endsWith('.lens-Follower');
}
const resolveSimpleHashRange = (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_17__/* .createLookupTableResolver */ .F)({
    [_masknet_shared_base__WEBPACK_IMPORTED_MODULE_18__/* .Days */ .h.ONE_DAY]: 60 * 60 * 24,
    [_masknet_shared_base__WEBPACK_IMPORTED_MODULE_18__/* .Days */ .h.ONE_WEEK]: 60 * 60 * 24 * 7,
    [_masknet_shared_base__WEBPACK_IMPORTED_MODULE_18__/* .Days */ .h.ONE_MONTH]: 60 * 60 * 24 * 30,
    [_masknet_shared_base__WEBPACK_IMPORTED_MODULE_18__/* .Days */ .h.THREE_MONTHS]: 60 * 60 * 24 * 90,
    [_masknet_shared_base__WEBPACK_IMPORTED_MODULE_18__/* .Days */ .h.ONE_YEAR]: 0,
    [_masknet_shared_base__WEBPACK_IMPORTED_MODULE_18__/* .Days */ .h.MAX]: 0
}, ()=>0);
function resolveEventType(event) {
    switch(event){
        case _types_SimpleHash_js__WEBPACK_IMPORTED_MODULE_19__/* .SimpleHash */ .C.ActivityType.Sale:
            return _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_9__/* .ActivityType */ .T8.Sale;
        case _types_SimpleHash_js__WEBPACK_IMPORTED_MODULE_19__/* .SimpleHash */ .C.ActivityType.Transfer:
            return _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_9__/* .ActivityType */ .T8.Transfer;
        case _types_SimpleHash_js__WEBPACK_IMPORTED_MODULE_19__/* .SimpleHash */ .C.ActivityType.Burn:
            return _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_9__/* .ActivityType */ .T8.Burn;
        case _types_SimpleHash_js__WEBPACK_IMPORTED_MODULE_19__/* .SimpleHash */ .C.ActivityType.Mint:
            return _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_9__/* .ActivityType */ .T8.Mint;
        default:
            (0,_masknet_kit__WEBPACK_IMPORTED_MODULE_0__/* .unreachable */ .t1)(event);
    }
}


/***/ }),

/***/ 1288:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ SmartPayAccountAPI)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(81755);
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(74765);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(65327);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(33026);
/* harmony import */ var _Web3_EVM_apis_RequestReadonlyAPI_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(64043);
/* harmony import */ var _BundlerAPI_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25514);
/* harmony import */ var _OwnerAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16769);
/* harmony import */ var _libs_ContractWallet_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(14);
/* harmony import */ var _libs_UserTransaction_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(7247);








class SmartPayAccountAPI {
    Request = new _Web3_EVM_apis_RequestReadonlyAPI_js__WEBPACK_IMPORTED_MODULE_0__/* .RequestReadonlyAPI */ .c();
    Owner = new _OwnerAPI_js__WEBPACK_IMPORTED_MODULE_1__/* .SmartPayOwnerAPI */ .P();
    async getEntryPoint(chainId) {
        const entryPoints = await _BundlerAPI_js__WEBPACK_IMPORTED_MODULE_2__/* .SmartPayBundler */ .P.getSupportedEntryPoints(chainId);
        const entryPoint = (0,lodash_es__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(entryPoints);
        if (!entryPoint || !(0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_4__/* .isValidAddress */ .At)(entryPoint)) throw new Error(`Not supported ${chainId}`);
        return entryPoint;
    }
    async getInitCode(chainId, owner) {
        const contractWallet = await this.createContractWallet(chainId, owner);
        if ((0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_4__/* .isEmptyHex */ .w2)(contractWallet.initCode)) throw new Error('Failed to create initCode.');
        return contractWallet.initCode;
    }
    async createContractWallet(chainId, owner) {
        if (!owner) throw new Error('No owner address.');
        return new _libs_ContractWallet_js__WEBPACK_IMPORTED_MODULE_5__/* .ContractWallet */ .j(chainId, owner, (0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_6__/* .getSmartPayConstants */ .BO)(chainId).LOGIC_WALLET_CONTRACT_ADDRESS ?? '', await this.getEntryPoint(chainId));
    }
    /**
     * The internal method to send a UserTransaction.
     */ async sendUserTransaction(chainId, owner, userTransaction, signer) {
        const getOverrides = async ()=>{
            if ((0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_4__/* .isEmptyHex */ .w2)(userTransaction.initCode) && userTransaction.nonce === 0) {
                const accounts = await this.Owner.getAccountsByOwner(chainId, owner, false);
                const target = accounts.find((x)=>(0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_7__/* .isSameAddress */ .W)(x.address, userTransaction.operation.sender));
                const accountsDeployed = accounts.filter((x)=>(0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_7__/* .isSameAddress */ .W)(x.creator, owner) && x.deployed);
                // If the wallet to which the transaction is sent is obtained by changing the owner
                if (!target?.creator) {
                    return;
                }
                if (!accountsDeployed.length) {
                    return {
                        initCode: await this.getInitCode(chainId, owner),
                        nonce: accountsDeployed.length
                    };
                }
            }
            return;
        };
        await userTransaction.fillUserOperation(this.Request.getWeb3({
            chainId
        }), await getOverrides());
        return _BundlerAPI_js__WEBPACK_IMPORTED_MODULE_2__/* .SmartPayBundler */ .P.sendUserOperation(chainId, await userTransaction.signUserOperation(signer));
    }
    async estimateUserTransaction(chainId, userTransaction) {
        await userTransaction.fillUserOperation(this.Request.getWeb3({
            chainId
        }));
        return userTransaction.estimateUserOperation();
    }
    async sendTransaction(chainId, owner, transaction, signer, options) {
        const entryPoint = await this.getEntryPoint(chainId);
        const userTransaction = _libs_UserTransaction_js__WEBPACK_IMPORTED_MODULE_8__/* .UserTransaction */ .k.fromTransaction(chainId, entryPoint, transaction, options);
        return this.sendUserTransaction(chainId, owner, userTransaction, signer);
    }
    async sendUserOperation(chainId, owner, operation, signer, options) {
        const entryPoint = await this.getEntryPoint(chainId);
        const userTransaction = _libs_UserTransaction_js__WEBPACK_IMPORTED_MODULE_8__/* .UserTransaction */ .k.fromUserOperation(chainId, entryPoint, operation, options);
        return this.sendUserTransaction(chainId, owner, userTransaction, signer);
    }
    async estimateTransaction(chainId, transaction, options) {
        const entryPoint = await this.getEntryPoint(chainId);
        const userTransaction = _libs_UserTransaction_js__WEBPACK_IMPORTED_MODULE_8__/* .UserTransaction */ .k.fromTransaction(chainId, entryPoint, transaction, options);
        return this.estimateUserTransaction(chainId, userTransaction);
    }
    async estimateUserOperation(chainId, operation, options) {
        const entryPoint = await this.getEntryPoint(chainId);
        const userTransaction = _libs_UserTransaction_js__WEBPACK_IMPORTED_MODULE_8__/* .UserTransaction */ .k.fromUserOperation(chainId, entryPoint, operation, options);
        return this.estimateUserTransaction(chainId, userTransaction);
    }
    async deploy(chainId, owner, signer) {
        if (!(0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_4__/* .isValidAddress */ .At)(owner)) throw new Error('Invalid owner address.');
        const initCode = await this.getInitCode(chainId, owner);
        const accounts = await this.Owner.getAccountsByOwner(chainId, owner, false);
        const accountsDeployed = accounts.filter((x)=>(0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_7__/* .isSameAddress */ .W)(x.creator, owner) && x.deployed);
        return this.sendUserOperation(chainId, owner, {
            initCode,
            nonce: accountsDeployed.length,
            sender: accounts[accountsDeployed.length].address
        }, signer);
    }
    transfer(chainId, owner, sender, recipient, amount, signer) {
        throw new Error('Method not implemented.');
    }
    changeOwner(chainId, owner, sender, recipient, signer) {
        throw new Error('Method not implemented.');
    }
}


/***/ }),

/***/ 25514:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   P: () => (/* binding */ SmartPayBundler)
/* harmony export */ });
/* harmony import */ var urlcat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78757);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(17711);
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(26424);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(63532);
/* harmony import */ var _helpers_fetchCached_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(22674);
/* harmony import */ var _helpers_fetchJSON_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11834);






class SmartPayBundlerAPI {
    healthz() {
        return (0,_helpers_fetchJSON_js__WEBPACK_IMPORTED_MODULE_1__/* .fetchCachedJSON */ .MP)((0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(_constants_js__WEBPACK_IMPORTED_MODULE_2__/* .BUNDLER_PROD */ .Fp, '/healthz'), {
            method: 'GET'
        }, {
            cacheDuration: _helpers_fetchCached_js__WEBPACK_IMPORTED_MODULE_3__/* .Duration */ .nL.TWELVE_HOURS
        });
    }
    async handle(userOperation) {
        const { tx_hash, message = 'Unknown Error' } = await (0,_helpers_fetchJSON_js__WEBPACK_IMPORTED_MODULE_1__/* .fetchJSON */ .ZV)((0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(_constants_js__WEBPACK_IMPORTED_MODULE_2__/* .BUNDLER_PROD */ .Fp, '/handle'), {
            method: 'POST',
            body: JSON.stringify({
                user_operations: [
                    {
                        ...(0,lodash_es__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(userOperation, [
                            'initCode',
                            'callData',
                            'callGas',
                            'verificationGas',
                            'preVerificationGas',
                            'maxFeePerGas',
                            'maxPriorityFeePerGas',
                            'paymasterData'
                        ]),
                        nonce: userOperation.nonce?.toFixed() ?? '0',
                        init_code: (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_5__/* .toBase64 */ .s3)((0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_5__/* .fromHex */ .H_)(userOperation.initCode ?? '0x')),
                        call_data: (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_5__/* .toBase64 */ .s3)((0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_5__/* .fromHex */ .H_)(userOperation.callData ?? '0x')),
                        call_gas: userOperation.callGas,
                        verification_gas: userOperation.verificationGas,
                        pre_verification_gas: userOperation.preVerificationGas,
                        max_fee_per_gas: userOperation.maxFeePerGas,
                        max_priority_fee_per_gas: userOperation.maxPriorityFeePerGas,
                        paymaster_data: (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_5__/* .toBase64 */ .s3)((0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_5__/* .fromHex */ .H_)(userOperation.paymasterData ?? '0x')),
                        signature: (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_5__/* .toBase64 */ .s3)((0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_5__/* .fromHex */ .H_)(userOperation.signature ?? '0x'))
                    }
                ]
            })
        });
        if (tx_hash) return tx_hash;
        throw new Error(message);
    }
    async assetChainId(chainId) {
        const supportedChainId = await this.getSupportedChainId();
        if (supportedChainId !== chainId) throw new Error(`Not supported ${chainId}.`);
    }
    async getSigner(chainId) {
        await this.assetChainId(chainId);
        const healthz = await this.healthz();
        return healthz.bundler_eoa;
    }
    async getSupportedChainId() {
        const healthz = await this.healthz();
        return Number.parseInt(healthz.chain_id, 10);
    }
    async getSupportedEntryPoints(chainId) {
        await this.assetChainId(chainId);
        const healthz = await this.healthz();
        return [
            healthz.entrypoint_contract_address
        ];
    }
    simulateUserOperation() {
        throw new Error('Method not implemented.');
    }
    async sendUserOperation(chainId, userOperation) {
        await this.assetChainId(chainId);
        return this.handle(userOperation);
    }
}
const SmartPayBundler = new SmartPayBundlerAPI();


/***/ }),

/***/ 92848:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  B: () => (/* binding */ SmartPayFunderAPI)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/urlcat@3.1.0_patch_hash=5r5xyq4zgcnqugwsrx4lxq2i4e/node_modules/urlcat/dist/index.mjs
var dist = __webpack_require__(78757);
// EXTERNAL MODULE: ./node_modules/.pnpm/bignumber.js@9.1.2/node_modules/bignumber.js/bignumber.mjs
var bignumber = __webpack_require__(10149);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/types/index.ts
var types = __webpack_require__(24770);
// EXTERNAL MODULE: ./packages/shared-base/src/constants.ts
var constants = __webpack_require__(52033);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/ConnectionReadonlyAPI.ts + 2 modules
var ConnectionReadonlyAPI = __webpack_require__(3543);
// EXTERNAL MODULE: ./packages/web3-providers/src/SmartPay/constants.ts
var SmartPay_constants = __webpack_require__(63532);
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/fetchJSON.ts
var fetchJSON = __webpack_require__(11834);
;// CONCATENATED MODULE: ./packages/web3-providers/src/types/Funder.ts
var FunderAPI; /** Fund token for a NextID public-derived EOA account. */  /** Verify whether if a whitelisted user account */ 
(function(FunderAPI) {
    let // timestamp will expire after 1 hour
    // eg: 1669970510248
    ScanKey;
    (function(ScanKey) {
        ScanKey["TwitterHandler"] = 'twitterHandler';
        ScanKey["OwnerAddress"] = 'ownerAddress';
        ScanKey["TokenTransferTx"] = 'tokenTransferTx';
        ScanKey["Id"] = 'id';
        ScanKey["WalletAddress"] = 'walletAddress';
    })(ScanKey = FunderAPI.ScanKey || (FunderAPI.ScanKey = {}));
})(FunderAPI || (FunderAPI = {}));

;// CONCATENATED MODULE: ./packages/web3-providers/src/SmartPay/apis/FunderAPI.ts








class SmartPayFunderAPI {
    Web3 = new ConnectionReadonlyAPI/* ConnectionReadonlyAPI */.S();
    async assetChainId(chainId) {
        if (![
            types/* ChainId */.a_.Matic,
            types/* ChainId */.a_.Mumbai
        ].includes(chainId)) throw new Error(`Not supported ${chainId}.`);
    }
    async getWhiteList(handler) {
        return (0,fetchJSON/* fetchCachedJSON */.MP)((0,dist/* default */.ZP)(SmartPay_constants/* FUNDER_PROD */.X$, '/whitelist', {
            twitterHandle: handler
        }));
    }
    async getRemainFrequency(handler) {
        try {
            const result = await this.getWhiteList(handler);
            if (!result.totalCount || result.twitterHandler !== handler.toLowerCase()) return 0;
            return bignumber/* BigNumber */.O.max(result.totalCount - result.usedCount, 0).toNumber();
        } catch  {
            return 0;
        }
    }
    async getOperationsByOwner(chainId, owner) {
        await this.assetChainId(chainId);
        try {
            const operations = await (0,fetchJSON/* fetchCachedJSON */.MP)((0,dist/* default */.ZP)(SmartPay_constants/* FUNDER_PROD */.X$, '/operation', {
                scanKey: FunderAPI.ScanKey.OwnerAddress,
                scanValue: owner
            }));
            const allSettled = await Promise.allSettled(operations.map((x)=>this.Web3.getTransactionReceipt(x.tokenTransferTx, {
                    chainId
                })));
            return operations.filter((_, i)=>{
                const receipt = allSettled[i];
                return receipt.status === 'fulfilled' && receipt?.value?.status;
            });
        } catch  {
            return constants/* EMPTY_LIST */.rP;
        }
    }
    async fund(chainId, proof) {
        await this.assetChainId(chainId);
        return (0,fetchJSON/* fetchJSON */.ZV)((0,dist/* default */.ZP)(SmartPay_constants/* FUNDER_PROD */.X$, '/verify'), {
            method: 'POST',
            body: JSON.stringify(proof),
            headers: {
                'Content-Type': 'application/json'
            }
        });
    }
    async verify(handler) {
        try {
            const result = await this.getWhiteList(handler);
            return result.twitterHandler === handler.toLowerCase() && result.usedCount < result.totalCount;
        } catch  {
            return false;
        }
    }
}


/***/ }),

/***/ 16769:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  P: () => (/* binding */ SmartPayOwnerAPI)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/head.js
var head = __webpack_require__(81755);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/compact.js
var compact = __webpack_require__(72845);
// EXTERNAL MODULE: ./packages/shared-base/src/types/PluginID.ts
var PluginID = __webpack_require__(24835);
// EXTERNAL MODULE: ./packages/shared-base-ui/src/data/queryClient.ts
var queryClient = __webpack_require__(73401);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/isSameAddress.ts
var isSameAddress = __webpack_require__(74765);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/address.ts
var address = __webpack_require__(65327);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/constants/constants.ts
var constants = __webpack_require__(33026);
// EXTERNAL MODULE: ./packages/web3-providers/src/Multicall/index.ts + 2 modules
var Multicall = __webpack_require__(93097);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/ContractReadonlyAPI.ts + 9 modules
var ContractReadonlyAPI = __webpack_require__(61871);
// EXTERNAL MODULE: ./packages/web3-providers/src/SmartPay/apis/BundlerAPI.ts
var BundlerAPI = __webpack_require__(25514);
// EXTERNAL MODULE: ./packages/web3-providers/src/SmartPay/apis/FunderAPI.ts + 1 modules
var FunderAPI = __webpack_require__(92848);
// EXTERNAL MODULE: ./packages/web3-providers/src/SmartPay/libs/ContractWallet.ts + 2 modules
var ContractWallet = __webpack_require__(14);
// EXTERNAL MODULE: ./node_modules/.pnpm/web3-utils@1.10.2/node_modules/web3-utils/lib/index.js
var lib = __webpack_require__(84976);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/formatter.ts
var formatter = __webpack_require__(41487);
;// CONCATENATED MODULE: ./packages/web3-providers/src/SmartPay/libs/Create2Factory.ts


class Create2Factory {
    address;
    static MAX_DERIVATION_NUM = 99;
    /**
     * Create2Factory
     *
     * @param address The contract address of Create2Factory
     */ constructor(address){
        this.address = address;
    }
    getDeployAddress(initCode, salt) {
        const saltByte32 = (0,lib.padLeft)((0,lib.toHex)(salt), 64);
        const items = [
            '0xff',
            (0,formatter/* formatEthereumAddress */.j8)(this.address),
            saltByte32,
            (0,lib.keccak256)(initCode)
        ].flatMap((x)=>(0,lib.hexToBytes)(x));
        return (0,formatter/* formatEthereumAddress */.j8)((0,lib.bytesToHex)((0,lib.hexToBytes)((0,lib.keccak256)((0,lib.bytesToHex)(items))).slice(12)));
    }
    derive(initCode, nonce) {
        return this.getDeployAddress(initCode, nonce);
    }
    /** Derive multiple times from the given initCode. */ deriveUntil(initCode, length = Create2Factory.MAX_DERIVATION_NUM) {
        return Array.from({
            length
        }).map((_, i)=>this.getDeployAddress(initCode, i));
    }
}

// EXTERNAL MODULE: ./packages/web3-providers/src/SmartPay/constants.ts
var SmartPay_constants = __webpack_require__(63532);
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/fetchJSON.ts
var fetchJSON = __webpack_require__(11834);
;// CONCATENATED MODULE: ./packages/web3-providers/src/SmartPay/apis/OwnerAPI.ts













class SmartPayOwnerAPI {
    Contract = new ContractReadonlyAPI/* ContractReadonlyAPI */.M();
    Multicall = new Multicall/* MulticallAPI */.U();
    Funder = new FunderAPI/* SmartPayFunderAPI */.B();
    async getEntryPoint(chainId) {
        const entryPoints = await BundlerAPI/* SmartPayBundler */.P.getSupportedEntryPoints(chainId);
        const entryPoint = (0,head/* default */.Z)(entryPoints);
        if (!entryPoint || !(0,address/* isValidAddress */.At)(entryPoint)) throw new Error(`Not supported ${chainId}`);
        return entryPoint;
    }
    createWalletContract(chainId, address) {
        return this.Contract.getWalletContract(address, {
            chainId
        });
    }
    async createContractWallet(chainId, owner) {
        if (!owner) throw new Error('No owner address.');
        return new ContractWallet/* ContractWallet */.j(chainId, owner, (0,constants/* getSmartPayConstants */.BO)(chainId).LOGIC_WALLET_CONTRACT_ADDRESS ?? '', await this.getEntryPoint(chainId));
    }
    async createCreate2Factory(chainId, owner) {
        if (!owner) throw new Error('No owner address.');
        const { CREATE2_FACTORY_CONTRACT_ADDRESS } = (0,constants/* getSmartPayConstants */.BO)(chainId);
        if (!CREATE2_FACTORY_CONTRACT_ADDRESS) throw new Error('No create2 contract.');
        return new Create2Factory(CREATE2_FACTORY_CONTRACT_ADDRESS);
    }
    filterAccounts(accounts) {
        const countMap = new Map();
        accounts.forEach((x)=>{
            const address = x.address.toLowerCase();
            const count = countMap.get(address) || 0;
            countMap.set(address, count + 1);
        });
        return accounts.filter((x)=>countMap.get(x.address.toLowerCase()) === 1 || x.creator);
    }
    createContractAccount(chainId, address, owner, creator, deployed = true, funded = false) {
        return {
            pluginID: PluginID/* NetworkPluginID */.F.PLUGIN_EVM,
            chainId,
            id: `${PluginID/* NetworkPluginID */.F.PLUGIN_EVM}_${chainId}_${address}`,
            address,
            owner,
            creator,
            deployed,
            funded
        };
    }
    /**
     * Use the multicall contract to filter non-owned accounts out.
     * @param chainId
     * @param options
     * @returns
     */ async getAccountsFromMulticall(chainId, owner, options) {
        const contracts = options.map((x)=>this.createWalletContract(chainId, x));
        const names = Array.from({
            length: options.length
        }).fill('owner');
        const calls = this.Multicall.createMultipleContractSingleData(contracts, names, []);
        const results = await this.Multicall.call(chainId, contracts, names, calls);
        const accounts = results.flatMap((x)=>x.succeed && x.value ? x.value : '');
        if (!accounts.length) {
            return [];
        }
        return (0,compact/* default */.Z)(accounts.map((x, index)=>this.createContractAccount(chainId, options[index], x || owner, owner, (0,address/* isValidAddress */.At)(x))));
    }
    async getAccountsFromTheGraph(chainId, owner) {
        const response = await (0,fetchJSON/* fetchJSON */.ZV)(SmartPay_constants/* THE_GRAPH_PROD */.h4, {
            method: 'POST',
            body: JSON.stringify({
                query: `{
                    ownerShips(where: { owner: "${owner}" }) {
                      id
                      address
                      owner
                      creator
                    }
                }`
            })
        });
        return response.data.ownerShips.map((x)=>this.createContractAccount(chainId, x.address, x.owner, '', true, true));
    }
    async getAccountsByOwner(chainId, owner, exact = true) {
        const accounts = await queryClient/* queryClient */.E.fetchQuery({
            queryKey: [
                'smart-pay',
                'get-accounts-by-owner',
                chainId,
                owner,
                exact
            ],
            cacheTime: 1000_000,
            queryFn: async ()=>{
                const create2Factory = await this.createCreate2Factory(chainId, owner);
                const contractWallet = await this.createContractWallet(chainId, owner);
                const operations = await this.Funder.getOperationsByOwner(chainId, owner);
                const allSettled = await Promise.allSettled([
                    this.getAccountsFromMulticall(chainId, owner, create2Factory.deriveUntil(contractWallet.initCode, SmartPay_constants/* MAX_ACCOUNT_LENGTH */.vf)),
                    this.getAccountsFromTheGraph(chainId, owner)
                ]);
                const result = allSettled.flatMap((x)=>x.status === 'fulfilled' ? x.value : []).map((y)=>({
                        ...y,
                        funded: y.creator ? operations.some((operation)=>(0,isSameAddress/* isSameAddress */.W)(operation.walletAddress, y.address)) : y.funded
                    }));
                return this.filterAccounts(result).filter((x)=>exact ? (0,isSameAddress/* isSameAddress */.W)(x.owner, owner) : true);
            }
        });
        return accounts ?? [];
    }
    async getAccountsByOwners(chainId, owners, exact = true) {
        const allSettled = await Promise.allSettled(owners.map((x)=>this.getAccountsByOwner(chainId, x, false)));
        const result = allSettled.flatMap((x)=>x.status === 'fulfilled' ? x.value : []);
        /**
         * There may be a transfer of ownership between different owners with the same address,
         * giving priority to the result obtained by multicall
         */ return this.filterAccounts(result).filter((x)=>exact ? owners.some((y)=>(0,isSameAddress/* isSameAddress */.W)(y, x.owner)) : true);
    }
}


/***/ }),

/***/ 63532:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Fp: () => (/* binding */ BUNDLER_PROD),
/* harmony export */   X$: () => (/* binding */ FUNDER_PROD),
/* harmony export */   h4: () => (/* binding */ THE_GRAPH_PROD),
/* harmony export */   vf: () => (/* binding */ MAX_ACCOUNT_LENGTH)
/* harmony export */ });
const MAX_ACCOUNT_LENGTH = 49;
const BUNDLER_PROD = 'https://9rh2q3tdqj.execute-api.ap-east-1.amazonaws.com/';
const FUNDER_PROD = 'https://uldpla73li.execute-api.ap-east-1.amazonaws.com/Prod/';
const THE_GRAPH_PROD = 'https://api.thegraph.com/subgraphs/name/dimensiondev/paygas-x-subgraph';


/***/ }),

/***/ 14:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  j: () => (/* binding */ ContractWallet)
});

// EXTERNAL MODULE: ./packages/web3-shared/evm/src/libs/Web3.ts
var Web3 = __webpack_require__(54644);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/createContract.ts
var createContract = __webpack_require__(95739);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/constants/primitives.ts
var primitives = __webpack_require__(47469);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/constants/constants.ts
var constants = __webpack_require__(33026);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/abiCoder.ts
var abiCoder = __webpack_require__(1853);
// EXTERNAL MODULE: ./packages/web3-contracts/abis/Wallet.json
var Wallet = __webpack_require__(49734);
;// CONCATENATED MODULE: ./packages/web3-contracts/abis/WalletProxy.json
const WalletProxy_namespaceObject = JSON.parse('[{"inputs":[{"internalType":"address","name":"_owner","type":"address"},{"internalType":"address","name":"_logic","type":"address"},{"internalType":"bytes","name":"_data","type":"bytes"}],"stateMutability":"payable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"previousAdmin","type":"address"},{"indexed":false,"internalType":"address","name":"newAdmin","type":"address"}],"name":"AdminChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"beacon","type":"address"}],"name":"BeaconUpgraded","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"implementation","type":"address"}],"name":"Upgraded","type":"event"},{"stateMutability":"payable","type":"fallback"},{"inputs":[{"internalType":"address","name":"_newImplementation","type":"address"},{"internalType":"bytes","name":"_data","type":"bytes"},{"internalType":"bool","name":"_forceCall","type":"bool"}],"name":"upgradeToAndCall","outputs":[],"stateMutability":"nonpayable","type":"function"},{"stateMutability":"payable","type":"receive"}]');
;// CONCATENATED MODULE: ./packages/web3-contracts/bytes/WalletProxy.mts
const WalletProxyByteCode =
    '0x608060405260405162000a8738038062000a87833981016040819052620000269162000360565b8181620000368282600062000041565b505050505062000493565b6200004c836200007e565b6000825111806200005a5750805b156200007957620000778383620000c060201b620000df1760201c565b505b505050565b6200008981620000ef565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b90600090a250565b6060620000e8838360405180606001604052806027815260200162000a6060279139620001c8565b9392505050565b6200010581620002ae60201b6200010b1760201c565b6200016d5760405162461bcd60e51b815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201526c1bdd08184818dbdb9d1c9858dd609a1b60648201526084015b60405180910390fd5b80620001a77f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc60001b620002bd60201b6200011a1760201c565b80546001600160a01b0319166001600160a01b039290921691909117905550565b60606001600160a01b0384163b620002325760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f6044820152651b9d1c9858dd60d21b606482015260840162000164565b600080856001600160a01b0316856040516200024f919062000440565b600060405180830381855af49150503d80600081146200028c576040519150601f19603f3d011682016040523d82523d6000602084013e62000291565b606091505b509092509050620002a4828286620002c0565b9695505050505050565b6001600160a01b03163b151590565b90565b60608315620002d1575081620000e8565b825115620002e25782518084602001fd5b8160405162461bcd60e51b81526004016200016491906200045e565b80516001600160a01b03811681146200031657600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b838110156200034e57818101518382015260200162000334565b83811115620000775750506000910152565b6000806000606084860312156200037657600080fd5b6200038184620002fe565b92506200039160208501620002fe565b60408501519092506001600160401b0380821115620003af57600080fd5b818601915086601f830112620003c457600080fd5b815181811115620003d957620003d96200031b565b604051601f8201601f19908116603f011681019083821181831017156200040457620004046200031b565b816040528281528960208487010111156200041e57600080fd5b6200043183602083016020880162000331565b80955050505050509250925092565b600082516200045481846020870162000331565b9190910192915050565b60208152600082518060208401526200047f81604085016020870162000331565b601f01601f19169190910160400192915050565b6105bd80620004a36000396000f3fe6080604052600436106100225760003560e01c806306d2e4261461003957610031565b366100315761002f610059565b005b61002f610059565b34801561004557600080fd5b5061002f610054366004610405565b61006b565b61006961006461011d565b61012c565b565b610073610150565b6001600160a01b0316336001600160a01b0316148061009157503330145b6100cf5760405162461bcd60e51b815260206004820152600a60248201526937b7363c9037bbb732b960b11b60448201526064015b60405180910390fd5b6100da838383610183565b505050565b60606101048383604051806060016040528060278152602001610561602791396101ae565b9392505050565b6001600160a01b03163b151590565b90565b600061012761028b565b905090565b3660008037600080366000845af43d6000803e80801561014b573d6000f35b3d6000fd5b60007fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61035b546001600160a01b0316919050565b61018c836102b3565b6000825111806101995750805b156100da576101a883836100df565b50505050565b60606001600160a01b0384163b6102165760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f6044820152651b9d1c9858dd60d21b60648201526084016100c6565b600080856001600160a01b0316856040516102319190610511565b600060405180830381855af49150503d806000811461026c576040519150601f19603f3d011682016040523d82523d6000602084013e610271565b606091505b50915091506102818282866102f3565b9695505050505050565b60007f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc610174565b6102bc8161032c565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b90600090a250565b60608315610302575081610104565b8251156103125782518084602001fd5b8160405162461bcd60e51b81526004016100c6919061052d565b6001600160a01b0381163b6103995760405162461bcd60e51b815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201526c1bdd08184818dbdb9d1c9858dd609a1b60648201526084016100c6565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc80546001600160a01b0319166001600160a01b0392909216919091179055565b634e487b7160e01b600052604160045260246000fd5b8035801515811461040057600080fd5b919050565b60008060006060848603121561041a57600080fd5b83356001600160a01b038116811461043157600080fd5b9250602084013567ffffffffffffffff8082111561044e57600080fd5b818601915086601f83011261046257600080fd5b813581811115610474576104746103da565b604051601f8201601f19908116603f0116810190838211818310171561049c5761049c6103da565b816040528281528960208487010111156104b557600080fd5b8260208601602083013760006020848301015280965050505050506104dc604085016103f0565b90509250925092565b60005b838110156105005781810151838201526020016104e8565b838111156101a85750506000910152565b600082516105238184602087016104e5565b9190910192915050565b602081526000825180602084015261054c8160408501602087016104e5565b601f01601f1916919091016040019291505056fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a2646970667358221220c58e01c79a6b3e7b89afe3f577c3161e96003f0d5f1630dcfb9bf9fdfa0ce1ec64736f6c634300080c0033416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564'

;// CONCATENATED MODULE: ./packages/web3-providers/src/SmartPay/libs/ContractWallet.ts




class ContractWallet {
    chainId;
    owner;
    address;
    entryPoint;
    web3;
    /**
     * ContractWallet
     *
     * @param owner the owner address
     * @param address  the deployed logic contract address
     * @param entryPoint the entry point contract address
     */ constructor(chainId, owner, address, entryPoint){
        this.chainId = chainId;
        this.owner = owner;
        this.address = address;
        this.entryPoint = entryPoint;
        this.web3 = new Web3/* Web3 */.B();
    }
    /**
     * The wallet proxy contract instance
     */ get contract() {
        return (0,createContract/* createContract */.O)(this.web3, primitives/* ZERO_ADDRESS */.r, WalletProxy_namespaceObject);
    }
    /**
     * Encoded initialize parameters of ContractWallet
     */ get data() {
        const { PAYMASTER_MASK_CONTRACT_ADDRESS, PAYMASTER_NATIVE_CONTRACT_ADDRESS, PAYMASTER_MINIMAL_STAKE_AMOUNT, PAYMENT_TOKEN_ADDRESS } = (0,constants/* getSmartPayConstants */.BO)(this.chainId);
        if (!PAYMASTER_MASK_CONTRACT_ADDRESS || !PAYMASTER_NATIVE_CONTRACT_ADDRESS || !PAYMASTER_MINIMAL_STAKE_AMOUNT || !PAYMENT_TOKEN_ADDRESS) return;
        const abi = Wallet.find((x)=>x.name === 'initialize' && x.type === 'function');
        if (!abi) throw new Error('Failed to load ABI.');
        return abiCoder/* abiCoder */.r.encodeFunctionCall(abi, [
            this.entryPoint,
            this.owner,
            PAYMENT_TOKEN_ADDRESS,
            PAYMASTER_MASK_CONTRACT_ADDRESS,
            PAYMASTER_MINIMAL_STAKE_AMOUNT,
            PAYMASTER_NATIVE_CONTRACT_ADDRESS
        ]);
    }
    /**
     * Encoded initCode for deploying a WalletProxy contract
     */ get initCode() {
        if (!this.contract) throw new Error('Failed to create proxy contract.');
        return this.contract.deploy({
            data: WalletProxyByteCode,
            arguments: [
                this.owner,
                this.address,
                this.data
            ]
        }).encodeABI();
    }
}


/***/ }),

/***/ 89288:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  h: () => (/* binding */ DepositPaymaster)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/bignumber.js@9.1.2/node_modules/bignumber.js/bignumber.mjs
var bignumber = __webpack_require__(10149);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/constants/constants.ts
var constants = __webpack_require__(33026);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/createContract.ts
var createContract = __webpack_require__(95739);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/libs/ProviderURL.ts
var ProviderURL = __webpack_require__(23865);
;// CONCATENATED MODULE: ./packages/web3-contracts/abis/DepositPaymaster.json
const DepositPaymaster_namespaceObject = JSON.parse('[{"inputs":[{"internalType":"contract EntryPoint","name":"_entryPoint","type":"address"},{"internalType":"address","name":"_payToken","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[],"name":"COST_OF_POST","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"PAYTOKEN_TO_MATIC_RATIO","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"addDepositFor","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint32","name":"extraUnstakeDelaySec","type":"uint32"}],"name":"addStake","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"bool","name":"admin","type":"bool"}],"name":"adjustAdmin","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"credits","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"entryPoint","outputs":[{"internalType":"contract EntryPoint","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"uint256","name":"nonce","type":"uint256"},{"internalType":"bytes","name":"initCode","type":"bytes"},{"internalType":"bytes","name":"callData","type":"bytes"},{"internalType":"uint256","name":"callGas","type":"uint256"},{"internalType":"uint256","name":"verificationGas","type":"uint256"},{"internalType":"uint256","name":"preVerificationGas","type":"uint256"},{"internalType":"uint256","name":"maxFeePerGas","type":"uint256"},{"internalType":"uint256","name":"maxPriorityFeePerGas","type":"uint256"},{"internalType":"address","name":"paymaster","type":"address"},{"internalType":"bytes","name":"paymasterData","type":"bytes"},{"internalType":"bytes","name":"signature","type":"bytes"}],"internalType":"struct UserOperation","name":"userOp","type":"tuple"}],"name":"estimateCost","outputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getDeposit","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"isAdmin","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"payToken","outputs":[{"internalType":"contract IERC20","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"enum IPaymaster.PostOpMode","name":"mode","type":"uint8"},{"internalType":"bytes","name":"context","type":"bytes"},{"internalType":"uint256","name":"actualGasCost","type":"uint256"}],"name":"postOp","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"contract EntryPoint","name":"_entryPoint","type":"address"}],"name":"setEntryPoint","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256[2]","name":"ratio","type":"uint256[2]"}],"name":"setMaskToMaticRatio","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"unlockStake","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"uint256","name":"nonce","type":"uint256"},{"internalType":"bytes","name":"initCode","type":"bytes"},{"internalType":"bytes","name":"callData","type":"bytes"},{"internalType":"uint256","name":"callGas","type":"uint256"},{"internalType":"uint256","name":"verificationGas","type":"uint256"},{"internalType":"uint256","name":"preVerificationGas","type":"uint256"},{"internalType":"uint256","name":"maxFeePerGas","type":"uint256"},{"internalType":"uint256","name":"maxPriorityFeePerGas","type":"uint256"},{"internalType":"address","name":"paymaster","type":"address"},{"internalType":"bytes","name":"paymasterData","type":"bytes"},{"internalType":"bytes","name":"signature","type":"bytes"}],"internalType":"struct UserOperation","name":"userOp","type":"tuple"},{"internalType":"bytes32","name":"requestId","type":"bytes32"},{"internalType":"uint256","name":"maxCost","type":"uint256"}],"name":"validatePaymasterUserOp","outputs":[{"internalType":"bytes","name":"context","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"target","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address payable","name":"withdrawAddress","type":"address"}],"name":"withdrawStake","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address payable","name":"withdrawAddress","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"withdrawTo","outputs":[],"stateMutability":"nonpayable","type":"function"}]');
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/createWeb3FromURL.ts
var createWeb3FromURL = __webpack_require__(23877);
;// CONCATENATED MODULE: ./packages/web3-providers/src/SmartPay/libs/DepositPaymaster.ts




class DepositPaymaster {
    chainId;
    /**
     * DepositPaymaster
     * @param chainId ChainId
     */ constructor(chainId){
        this.chainId = chainId;
    }
    get contract() {
        const { PAYMASTER_MASK_CONTRACT_ADDRESS } = (0,constants/* getSmartPayConstants */.BO)(this.chainId);
        if (!PAYMASTER_MASK_CONTRACT_ADDRESS) return;
        return (0,createContract/* createContract */.O)((0,createWeb3FromURL/* createWeb3FromURL */.x)(ProviderURL/* ProviderURL */.C.from(this.chainId)), PAYMASTER_MASK_CONTRACT_ADDRESS, DepositPaymaster_namespaceObject);
    }
    async getRatio() {
        const maskBase = await this.contract?.methods.PAYTOKEN_TO_MATIC_RATIO(0).call();
        const gasCurrencyRatio = await this.contract?.methods.PAYTOKEN_TO_MATIC_RATIO(1).call();
        if (!maskBase || !gasCurrencyRatio) return new bignumber/* BigNumber */.O(0);
        return new bignumber/* BigNumber */.O(maskBase).dividedBy(gasCurrencyRatio);
    }
}


/***/ }),

/***/ 7247:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  k: () => (/* binding */ UserTransaction)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/bignumber.js@9.1.2/node_modules/bignumber.js/bignumber.mjs
var bignumber = __webpack_require__(10149);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/omitBy.js + 1 modules
var omitBy = __webpack_require__(72802);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isUndefined.js
var isUndefined = __webpack_require__(81770);
// EXTERNAL MODULE: ./node_modules/.pnpm/web3-utils@1.10.2/node_modules/web3-utils/lib/index.js
var lib = __webpack_require__(84976);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/number.ts
var number = __webpack_require__(29763);
// EXTERNAL MODULE: ./packages/web3-contracts/abis/Wallet.json
var Wallet = __webpack_require__(49734);
;// CONCATENATED MODULE: ./packages/web3-contracts/abis/EntryPoint.json
const EntryPoint_namespaceObject = JSON.parse('[{"inputs":[{"internalType":"address","name":"_create2factory","type":"address"},{"internalType":"uint256","name":"_paymasterStake","type":"uint256"},{"internalType":"uint32","name":"_unstakeDelaySec","type":"uint32"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[{"internalType":"uint256","name":"opIndex","type":"uint256"},{"internalType":"address","name":"paymaster","type":"address"},{"internalType":"string","name":"reason","type":"string"}],"name":"FailedOp","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":false,"internalType":"uint256","name":"totalDeposit","type":"uint256"}],"name":"Deposited","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":false,"internalType":"uint256","name":"totalStaked","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"withdrawTime","type":"uint256"}],"name":"StakeLocked","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":false,"internalType":"uint256","name":"withdrawTime","type":"uint256"}],"name":"StakeUnlocked","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":false,"internalType":"address","name":"withdrawAddress","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"StakeWithdrawn","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"requestId","type":"bytes32"},{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":true,"internalType":"address","name":"paymaster","type":"address"},{"indexed":false,"internalType":"uint256","name":"nonce","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"actualGasCost","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"actualGasPrice","type":"uint256"},{"indexed":false,"internalType":"bool","name":"success","type":"bool"}],"name":"UserOperationEvent","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"requestId","type":"bytes32"},{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"uint256","name":"nonce","type":"uint256"},{"indexed":false,"internalType":"bytes","name":"revertReason","type":"bytes"}],"name":"UserOperationRevertReason","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":false,"internalType":"address","name":"withdrawAddress","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"Withdrawn","type":"event"},{"inputs":[{"internalType":"uint32","name":"_unstakeDelaySec","type":"uint32"}],"name":"addStake","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"create2factory","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"depositTo","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"deposits","outputs":[{"internalType":"uint112","name":"deposit","type":"uint112"},{"internalType":"bool","name":"staked","type":"bool"},{"internalType":"uint112","name":"stake","type":"uint112"},{"internalType":"uint32","name":"unstakeDelaySec","type":"uint32"},{"internalType":"uint64","name":"withdrawTime","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"getDepositInfo","outputs":[{"components":[{"internalType":"uint112","name":"deposit","type":"uint112"},{"internalType":"bool","name":"staked","type":"bool"},{"internalType":"uint112","name":"stake","type":"uint112"},{"internalType":"uint32","name":"unstakeDelaySec","type":"uint32"},{"internalType":"uint64","name":"withdrawTime","type":"uint64"}],"internalType":"struct StakeManager.DepositInfo","name":"info","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"uint256","name":"nonce","type":"uint256"},{"internalType":"bytes","name":"initCode","type":"bytes"},{"internalType":"bytes","name":"callData","type":"bytes"},{"internalType":"uint256","name":"callGas","type":"uint256"},{"internalType":"uint256","name":"verificationGas","type":"uint256"},{"internalType":"uint256","name":"preVerificationGas","type":"uint256"},{"internalType":"uint256","name":"maxFeePerGas","type":"uint256"},{"internalType":"uint256","name":"maxPriorityFeePerGas","type":"uint256"},{"internalType":"address","name":"paymaster","type":"address"},{"internalType":"bytes","name":"paymasterData","type":"bytes"},{"internalType":"bytes","name":"signature","type":"bytes"}],"internalType":"struct UserOperation","name":"userOp","type":"tuple"}],"name":"getRequestId","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"initCode","type":"bytes"},{"internalType":"uint256","name":"salt","type":"uint256"}],"name":"getSenderAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"sender","type":"address"}],"name":"getSenderStorage","outputs":[{"internalType":"uint256[]","name":"senderStorageCells","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"uint256","name":"nonce","type":"uint256"},{"internalType":"bytes","name":"initCode","type":"bytes"},{"internalType":"bytes","name":"callData","type":"bytes"},{"internalType":"uint256","name":"callGas","type":"uint256"},{"internalType":"uint256","name":"verificationGas","type":"uint256"},{"internalType":"uint256","name":"preVerificationGas","type":"uint256"},{"internalType":"uint256","name":"maxFeePerGas","type":"uint256"},{"internalType":"uint256","name":"maxPriorityFeePerGas","type":"uint256"},{"internalType":"address","name":"paymaster","type":"address"},{"internalType":"bytes","name":"paymasterData","type":"bytes"},{"internalType":"bytes","name":"signature","type":"bytes"}],"internalType":"struct UserOperation[]","name":"ops","type":"tuple[]"},{"internalType":"address payable","name":"beneficiary","type":"address"}],"name":"handleOps","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"uint256","name":"nonce","type":"uint256"},{"internalType":"bytes","name":"initCode","type":"bytes"},{"internalType":"bytes","name":"callData","type":"bytes"},{"internalType":"uint256","name":"callGas","type":"uint256"},{"internalType":"uint256","name":"verificationGas","type":"uint256"},{"internalType":"uint256","name":"preVerificationGas","type":"uint256"},{"internalType":"uint256","name":"maxFeePerGas","type":"uint256"},{"internalType":"uint256","name":"maxPriorityFeePerGas","type":"uint256"},{"internalType":"address","name":"paymaster","type":"address"},{"internalType":"bytes","name":"paymasterData","type":"bytes"},{"internalType":"bytes","name":"signature","type":"bytes"}],"internalType":"struct UserOperation","name":"op","type":"tuple"},{"components":[{"internalType":"bytes32","name":"requestId","type":"bytes32"},{"internalType":"uint256","name":"prefund","type":"uint256"},{"internalType":"enum EntryPoint.PaymentMode","name":"paymentMode","type":"uint8"},{"internalType":"uint256","name":"contextOffset","type":"uint256"},{"internalType":"uint256","name":"preOpGas","type":"uint256"}],"internalType":"struct EntryPoint.UserOpInfo","name":"opInfo","type":"tuple"},{"internalType":"bytes","name":"context","type":"bytes"}],"name":"innerHandleOp","outputs":[{"internalType":"uint256","name":"actualGasCost","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"paymasterStake","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"uint256","name":"nonce","type":"uint256"},{"internalType":"bytes","name":"initCode","type":"bytes"},{"internalType":"bytes","name":"callData","type":"bytes"},{"internalType":"uint256","name":"callGas","type":"uint256"},{"internalType":"uint256","name":"verificationGas","type":"uint256"},{"internalType":"uint256","name":"preVerificationGas","type":"uint256"},{"internalType":"uint256","name":"maxFeePerGas","type":"uint256"},{"internalType":"uint256","name":"maxPriorityFeePerGas","type":"uint256"},{"internalType":"address","name":"paymaster","type":"address"},{"internalType":"bytes","name":"paymasterData","type":"bytes"},{"internalType":"bytes","name":"signature","type":"bytes"}],"internalType":"struct UserOperation","name":"userOp","type":"tuple"}],"name":"simulateValidation","outputs":[{"internalType":"uint256","name":"preOpGas","type":"uint256"},{"internalType":"uint256","name":"prefund","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"unlockStake","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"unstakeDelaySec","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address payable","name":"withdrawAddress","type":"address"}],"name":"withdrawStake","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address payable","name":"withdrawAddress","type":"address"},{"internalType":"uint256","name":"withdrawAmount","type":"uint256"}],"name":"withdrawTo","outputs":[],"stateMutability":"nonpayable","type":"function"},{"stateMutability":"payable","type":"receive"}]');
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/address.ts
var address = __webpack_require__(65327);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/abiCoder.ts
var abiCoder = __webpack_require__(1853);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/createContract.ts
var createContract = __webpack_require__(95739);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/constants/constants.ts
var constants = __webpack_require__(33026);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/formatter.ts
var formatter = __webpack_require__(41487);
;// CONCATENATED MODULE: ./packages/web3-providers/src/SmartPay/libs/UserTransaction.ts







const USER_OP_TYPE = {
    userOp: {
        sender: 'address',
        nonce: 'uint256',
        initCode: 'bytes',
        callData: 'bytes',
        callGas: 'uint256',
        verificationGas: 'uint256',
        preVerificationGas: 'uint256',
        maxFeePerGas: 'uint256',
        maxPriorityFeePerGas: 'uint256',
        paymaster: 'address',
        paymasterData: 'bytes',
        signature: 'bytes'
    }
};
const POSTOP = 35000;
const DEFAULT_USER_OPERATION = {
    sender: (0,address/* getZeroAddress */.R6)(),
    nonce: 0,
    initCode: '0x',
    callData: '0x',
    callGas: '35000',
    // default verification gas. will add create2 cost (3200 + 200 * length) if initCode exists
    verificationGas: '100000',
    // should also cover calldata cost.
    preVerificationGas: '21000',
    maxFeePerGas: '0',
    maxPriorityFeePerGas: '1000000000',
    paymaster: (0,address/* getZeroAddress */.R6)(),
    paymasterData: '0x',
    signature: '0x'
};
const CALL_WALLET_TYPE = {
    name: 'execFromEntryPoint',
    type: 'function',
    inputs: [
        {
            internalType: 'address',
            name: 'dest',
            type: 'address'
        },
        {
            internalType: 'uint256',
            name: 'value',
            type: 'uint256'
        },
        {
            internalType: 'bytes',
            name: 'func',
            type: 'bytes'
        }
    ]
};
/**
 * The wrapped UserOperation helper.
 * Learn more: https://github.com/eth-infinitism/account-abstraction/blob/develop/test/UserOp.ts
 */ class UserTransaction {
    chainId;
    entryPoint;
    userOperation;
    options;
    /**
     * Use UserTransaction.fromTransaction() or UserTransaction.fromUserOperation() stead.
     * They ensure to create of a valid user operation.
     *
     * @param chainId
     * @param entryPoint
     * @param userOperation
     */ constructor(chainId, entryPoint, userOperation, options){
        this.chainId = chainId;
        this.entryPoint = entryPoint;
        this.userOperation = userOperation;
        this.options = options;
    }
    get paymentToken() {
        return this.options?.paymentToken;
    }
    get initCode() {
        return this.userOperation.initCode;
    }
    get nonce() {
        return this.userOperation.nonce ?? 0;
    }
    get hasPaymaster() {
        return !!(this.userOperation.paymaster && !(0,address/* isZeroAddress */.uO)(this.userOperation.paymaster));
    }
    /**
     * Pack everything without signature
     */ get pack() {
        const encoded = abiCoder/* abiCoder */.r.encodeParameter(USER_OP_TYPE, {
            ...this.userOperation,
            signature: '0x'
        });
        return `0x${encoded.slice(66, encoded.length - 64)}`;
    }
    /**
     * Pack everything include signature
     */ get packAll() {
        const encoded = abiCoder/* abiCoder */.r.encodeParameter(USER_OP_TYPE, this.userOperation);
        return `0x${encoded.slice(66, encoded.length - 64)}`;
    }
    get hash() {
        return (0,lib.keccak256)(this.pack);
    }
    get requestId() {
        return (0,lib.keccak256)(abiCoder/* abiCoder */.r.encodeParameters([
            'bytes32',
            'address',
            'uint256'
        ], [
            this.hash,
            this.entryPoint,
            this.chainId
        ]));
    }
    get operation() {
        return this.userOperation;
    }
    createWalletContract(web3, sender) {
        const contract = (0,createContract/* createContract */.O)(web3, sender, Wallet);
        if (!contract) throw new Error('Failed to create wallet contract.');
        return contract;
    }
    createEntryPointContract(web3) {
        const contract = (0,createContract/* createContract */.O)(web3, this.entryPoint, EntryPoint_namespaceObject);
        if (!contract) throw new Error('Failed to create entry point contract.');
        return contract;
    }
    async fillUserOperation(web3, overrides) {
        // from overrides
        if (overrides) {
            this.userOperation.nonce = overrides.nonce;
            this.userOperation.initCode = overrides.initCode;
        }
        const { initCode, nonce, sender, callData, callGas, preVerificationGas, maxFeePerGas, maxPriorityFeePerGas } = this.userOperation;
        // add sender
        if (!(0,address/* isEmptyHex */.w2)(initCode) && !(0,address/* isValidAddress */.At)(sender)) {
            this.userOperation.sender = await this.createEntryPointContract(web3).methods.getSenderAddress(initCode, nonce).call();
        }
        // fill nonce
        if ((0,address/* isValidAddress */.At)(this.userOperation.sender) && typeof overrides === 'undefined' && nonce === 0) {
            try {
                const nonce_ = await this.createWalletContract(web3, sender).methods.nonce().call();
                this.userOperation.nonce = (0,lib.toNumber)(nonce_);
            } catch (error) {
                this.userOperation.nonce = 0;
            }
        }
        if (!(0,address/* isEmptyHex */.w2)(callData)) {
            const estimatedGas = await web3.eth.estimateGas({
                from: this.entryPoint,
                to: this.userOperation.sender,
                data: callData
            });
            this.userOperation.callGas = (0,lib.toHex)(estimatedGas);
        } else {
            this.userOperation.callGas = callGas ?? DEFAULT_USER_OPERATION.callGas;
        }
        // 2x scale up callGas and add margin for postop
        this.userOperation.callGas = (0,lib.toHex)((0,number/* toFixed */.FH)((0,number/* multipliedBy */.$q)(this.userOperation.callGas ?? '0', 2).plus(POSTOP), 0));
        // recover to the original callGas when extra gas could be provided
        if ((0,number/* isGreaterThan */.T1)(callGas ?? '0', this.userOperation.callGas)) {
            this.userOperation.callGas = callGas;
        }
        if ((0,address/* isZeroString */.cy)(maxFeePerGas)) {
            try {
                const block = await web3.eth.getBlock('latest');
                this.userOperation.maxFeePerGas = (0,number/* toFixed */.FH)(new bignumber/* BigNumber */.O(block.baseFeePerGas ?? 0).plus(maxPriorityFeePerGas ?? DEFAULT_USER_OPERATION.maxPriorityFeePerGas));
            } catch (error) {
                this.userOperation.maxFeePerGas = DEFAULT_USER_OPERATION.maxPriorityFeePerGas;
            }
        }
        if ((0,address/* isZeroString */.cy)(maxPriorityFeePerGas)) {
            this.userOperation.maxPriorityFeePerGas = DEFAULT_USER_OPERATION.maxPriorityFeePerGas;
        }
        // add more verification gas according to the size of initCode
        if (!(0,address/* isEmptyHex */.w2)(initCode)) {
            this.userOperation.verificationGas = (0,number/* toFixed */.FH)(new bignumber/* BigNumber */.O(DEFAULT_USER_OPERATION.verificationGas).plus(32000 + 200 * initCode.length / 2));
        } else {
            this.userOperation.verificationGas = DEFAULT_USER_OPERATION.verificationGas;
        }
        if ((0,address/* isZeroString */.cy)(preVerificationGas)) {
            this.userOperation.preVerificationGas = (0,number/* toFixed */.FH)(Math.max((0,lib.hexToBytes)(this.packAll).map((x)=>x === 0 ? 4 : 16).reduce((sum, x)=>sum + x), Number.parseInt(DEFAULT_USER_OPERATION.preVerificationGas, 10)));
        }
        if (!this.paymentToken || (0,address/* isZeroAddress */.uO)(this.paymentToken)) {
            const { PAYMASTER_MASK_CONTRACT_ADDRESS, PAYMASTER_NATIVE_CONTRACT_ADDRESS } = (0,constants/* getSmartPayConstants */.BO)(this.chainId);
            if (!PAYMASTER_MASK_CONTRACT_ADDRESS && !PAYMASTER_NATIVE_CONTRACT_ADDRESS) throw new Error('No paymaster address.');
            if (!this.paymentToken || (0,address/* isNativeTokenAddress */.qw)(this.paymentToken)) {
                this.userOperation.paymaster = PAYMASTER_NATIVE_CONTRACT_ADDRESS;
            } else {
                this.userOperation.paymaster = PAYMASTER_MASK_CONTRACT_ADDRESS;
                this.userOperation.paymasterData = (0,lib.padLeft)(this.paymentToken, 64);
            }
        }
        return this;
    }
    estimateUserOperation() {
        const { callGas = DEFAULT_USER_OPERATION.callGas } = this.userOperation;
        return (0,lib.toHex)(callGas);
    }
    async signTransaction(web3, signer) {
        const transaction = UserTransaction.toTransaction(this.chainId, this.userOperation);
        if (!transaction.from || !transaction.to) throw new Error('Invalid transaction.');
        return signer.signTransaction((0,omitBy/* default */.Z)({
            ...transaction,
            to: transaction.from,
            data: this.createWalletContract(web3, transaction.from).methods.exec(transaction.to, transaction.value ?? '0', transaction.data ?? '0x').encodeABI()
        }, isUndefined/* default */.Z));
    }
    async signUserOperation(signer) {
        const { nonce, callGas, verificationGas, preVerificationGas, maxFeePerGas, maxPriorityFeePerGas } = this.userOperation;
        return {
            ...this.userOperation,
            sender: (0,formatter/* formatEthereumAddress */.j8)(this.userOperation.sender),
            nonce,
            callGas: callGas ? (0,number/* toFixed */.FH)(callGas) : '0',
            verificationGas: verificationGas ? (0,number/* toFixed */.FH)(verificationGas) : '0',
            preVerificationGas: preVerificationGas ? (0,number/* toFixed */.FH)(preVerificationGas) : '0',
            maxFeePerGas: maxFeePerGas ? (0,number/* toFixed */.FH)(maxFeePerGas) : '0',
            maxPriorityFeePerGas: maxPriorityFeePerGas ? (0,number/* toFixed */.FH)(maxPriorityFeePerGas) : '0',
            signature: await signer.signMessage(this.requestId)
        };
    }
    static fromTransaction(chainId, entryPoint, transaction, options) {
        return new UserTransaction(chainId, entryPoint, UserTransaction.toUserOperation(chainId, transaction), options);
    }
    static fromUserOperation(chainId, entryPoint, userOperation, options) {
        const { PAYMENT_TOKEN_ADDRESS } = (0,constants/* getSmartPayConstants */.BO)(chainId);
        return new UserTransaction(chainId, entryPoint, UserTransaction.fillUserOperation(chainId, userOperation), {
            paymentToken: options?.paymentToken ?? PAYMENT_TOKEN_ADDRESS,
            ...options
        });
    }
    static fillUserOperation(chainId, userOperation) {
        const { PAYMASTER_MASK_CONTRACT_ADDRESS, PAYMENT_TOKEN_ADDRESS } = (0,constants/* getSmartPayConstants */.BO)(chainId);
        return {
            ...DEFAULT_USER_OPERATION,
            paymaster: PAYMASTER_MASK_CONTRACT_ADDRESS || DEFAULT_USER_OPERATION.paymaster,
            paymasterData: PAYMENT_TOKEN_ADDRESS ? (0,lib.padLeft)(PAYMENT_TOKEN_ADDRESS, 64) : DEFAULT_USER_OPERATION.paymasterData,
            ...userOperation
        };
    }
    static fillTransaction(chainId, transaction) {
        throw new Error('Method not implemented.');
    }
    static toUserOperation(chainId, transaction) {
        const { from, to, nonce = 0, value = '0', data = '0x' } = transaction;
        if (!from) throw new Error('No sender address.');
        if (!to) throw new Error('No destination address.');
        return UserTransaction.fillUserOperation(chainId, {
            sender: (0,formatter/* formatEthereumAddress */.j8)(from),
            nonce: (0,lib.toNumber)(nonce),
            callGas: transaction.gas ?? DEFAULT_USER_OPERATION.callGas,
            callData: abiCoder/* abiCoder */.r.encodeFunctionCall(CALL_WALLET_TYPE, [
                to,
                value,
                data
            ]),
            maxFeePerGas: transaction.maxFeePerGas ?? transaction.gasPrice ?? DEFAULT_USER_OPERATION.maxFeePerGas,
            maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ?? transaction.gasPrice ?? DEFAULT_USER_OPERATION.maxPriorityFeePerGas,
            signature: '0x'
        });
    }
    static toTransaction(chainId, userOperation) {
        const parameters = !(0,address/* isEmptyHex */.w2)(userOperation.callData) ? abiCoder/* abiCoder */.r.decodeParameters(CALL_WALLET_TYPE.inputs ?? [], userOperation.callData.slice(10)) : undefined;
        return {
            chainId,
            from: userOperation.sender,
            to: parameters?.dest,
            value: (0,lib.toHex)(parameters?.value ?? '0'),
            gas: userOperation.callGas,
            maxFeePerGas: userOperation.maxFeePerGas,
            maxPriorityFeePerGas: userOperation.maxPriorityFeePerGas,
            nonce: (0,lib.toNumber)(userOperation.nonce ?? '0'),
            data: parameters?.func ?? '0x'
        };
    }
}


/***/ }),

/***/ 60531:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   i: () => (/* binding */ SpaceID)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(24770);
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(91461);
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(92358);
/* harmony import */ var _Chainbase_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30685);
/* harmony import */ var _SID_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(86440);





class SpaceID_API {
    id = _masknet_shared_base__WEBPACK_IMPORTED_MODULE_0__/* .NameServiceID */ .S.SpaceID;
    async lookup(name) {
        return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_1__/* .attemptUntil */ .C)([
            _Chainbase_index_js__WEBPACK_IMPORTED_MODULE_2__/* .ChainbaseDomain */ .n,
            _SID_index_js__WEBPACK_IMPORTED_MODULE_3__/* .SID_Domain */ .t
        ].map((x)=>()=>x.lookup(_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_4__/* .ChainId */ .a_.BSC, name)), undefined);
    }
    async reverse(address) {
        return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_1__/* .attemptUntil */ .C)([
            _Chainbase_index_js__WEBPACK_IMPORTED_MODULE_2__/* .ChainbaseDomain */ .n,
            _SID_index_js__WEBPACK_IMPORTED_MODULE_3__/* .SID_Domain */ .t
        ].map((x)=>()=>x.reverse(_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_4__/* .ChainId */ .a_.BSC, address)), undefined);
    }
}
const SpaceID = new SpaceID_API();


/***/ }),

/***/ 4978:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  x: () => (/* binding */ Web3Storage)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/lru-cache@10.0.0/node_modules/lru-cache/dist/mjs/index.js
var mjs = __webpack_require__(7191);
// EXTERNAL MODULE: ./node_modules/.pnpm/urlcat@3.1.0_patch_hash=5r5xyq4zgcnqugwsrx4lxq2i4e/node_modules/urlcat/dist/index.mjs
var dist = __webpack_require__(78757);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Storage/constants/index.ts
const FIREFLY_API_URL = 'https://store.firefly.land/api/v1/str';
const KV_ROOT_URL = 'https://kv.r2d2.to';

// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/fetchJSON.ts
var fetchJSON = __webpack_require__(11834);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Storage/libs/R2D2.ts



class R2D2GetterSetter {
    prefix;
    constructor(prefix){
        this.prefix = prefix;
    }
    async get(key) {
        try {
            return (0,fetchJSON/* fetchSquashedJSON */.Vn)((0,dist/* default */.ZP)(KV_ROOT_URL, 'api/:name', {
                name: `${this.prefix}_${key}`
            }), {
                method: 'GET',
                headers: {
                    'Content-Type': 'text/plain'
                }
            });
        } catch  {
            return;
        }
    }
    async set(key, value) {
        await fetch((0,dist/* default */.ZP)(KV_ROOT_URL, 'api/:name', {
            name: `${this.prefix}_${key}`
        }), {
            method: 'PUT',
            mode: 'cors',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(value)
        });
    }
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Storage/storages/KV.ts


const caches = new Map();
class KVStorage {
    namespace;
    cache;
    constructor(namespace){
        this.namespace = namespace;
        const cache = caches.get(namespace);
        if (cache) {
            this.cache = cache;
            return;
        } else {
            const lru = new mjs/* LRUCache */.z({
                max: 500,
                ttl: 60_000
            });
            caches.set(namespace, lru);
            this.cache = lru;
        }
    }
    getKV() {
        return new R2D2GetterSetter(this.namespace);
    }
    async has(key) {
        return !!this.get(key);
    }
    async get(key) {
        const cacheKey = `${this.namespace}_${key}`;
        const cache = this.cache?.get(cacheKey);
        const storage = cache ?? this.getKV().get(key);
        return storage;
    }
    async set(key, value) {
        await this.getKV().set(key, value);
        // clear cache when set
        await this.delete(key);
        return;
    }
    async delete(key) {
        const cacheKey = `${this.namespace}_${key}`;
        this.cache?.delete(cacheKey);
    }
    async clearAll() {
        this.cache?.clear();
    }
}

// EXTERNAL MODULE: ./packages/shared-base/src/types/Account.ts
var Account = __webpack_require__(60541);
// EXTERNAL MODULE: ./packages/shared-base/src/helpers/pvtutils.ts
var pvtutils = __webpack_require__(26424);
// EXTERNAL MODULE: ./packages/web3-providers/src/NextID/kv.ts
var kv = __webpack_require__(93293);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Storage/storages/NextID.ts


class NextIDStorage {
    proofIdentity;
    // proof identity as key
    platform;
    // proof platform
    signerOrPublicKey;
    // publicKey, like SocialIdentity publicKey or PersonaIdentifier publicKeyAsHex
    signWithPersona;
    publicKeyAsHex;
    signer;
    constructor(proofIdentity, platform, signerOrPublicKey, signWithPersona){
        this.proofIdentity = proofIdentity;
        this.platform = platform;
        this.signerOrPublicKey = signerOrPublicKey;
        this.signWithPersona = signWithPersona;
        this.publicKeyAsHex = '';
        this.signer = null;
        if (typeof this.signerOrPublicKey === 'string') {
            this.publicKeyAsHex = this.signerOrPublicKey;
        } else {
            this.publicKeyAsHex = this.signerOrPublicKey.publicKeyAsHex;
            this.signer = this.signerOrPublicKey;
        }
    }
    async has(key) {
        return !!this.get(key);
    }
    async get(key) {
        const response = await kv/* NextIDStorageProvider */.H.getByIdentity(this.publicKeyAsHex, this.platform, this.proofIdentity, key);
        if (!response.isOk()) return;
        return response.value;
    }
    async getAll(key) {
        const response = await kv/* NextIDStorageProvider */.H.getAllByIdentity(this.platform, this.proofIdentity, key);
        if (!response.isOk()) return;
        return response.value;
    }
    async set(key, value) {
        if (!this.signer) throw new Error('signer is requirement when set data to NextID Storage');
        const payload = await kv/* NextIDStorageProvider */.H.getPayload(this.publicKeyAsHex, this.platform, this.proofIdentity, // identity
        value, key);
        if (!payload?.isOk()) throw new Error('Invalid payload Error');
        const signature = await this.signWithPersona?.(Account/* SignType */.A.Message, payload.value.signPayload, this.signer, true);
        if (!signature) throw new Error('Failed to sign payload.');
        await kv/* NextIDStorageProvider */.H.set(payload.value.uuid, this.publicKeyAsHex, (0,pvtutils/* toBase64 */.s3)((0,pvtutils/* fromHex */.H_)(signature)), this.platform, this.proofIdentity, payload.value.createdAt, value, key);
        return;
    }
}

// EXTERNAL MODULE: ./packages/web3-providers/src/RSS3/apis/RSS3API.ts + 1 modules
var RSS3API = __webpack_require__(23516);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/ConnectionAPI.ts
var ConnectionAPI = __webpack_require__(16488);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Storage/storages/RSS3.ts



const RSS3_caches = new Map();
class RSS3Storage {
    address;
    Web3;
    cache;
    constructor(address){
        this.address = address;
        this.Web3 = new ConnectionAPI/* ConnectionAPI */.m();
        const cache = RSS3_caches.get(address);
        if (cache) {
            this.cache = cache;
        } else {
            const lru = new mjs/* LRUCache */.z({
                max: 500,
                ttl: 60_000
            });
            RSS3_caches.set(address, lru);
            this.cache = lru;
        }
    }
    async getRSS3() {
        return RSS3API/* RSS3 */.S.createRSS3(this.address, (message)=>this.Web3.signMessage('message', message, {
                account: this.address
            }));
    }
    async has(key) {
        return !!this.get(key);
    }
    async get(key) {
        const cacheKey = `${this.address}_${key}`;
        const rss3 = await this.getRSS3();
        const cache = this.cache?.get(cacheKey);
        return cache ?? RSS3API/* RSS3 */.S.getFileData(rss3, this.address, key);
    }
    async set(key, value) {
        const rss3 = await this.getRSS3();
        await RSS3API/* RSS3 */.S.setFileData(rss3, this.address, key, value);
        this.delete(key);
        return;
    }
    async delete(key) {
        const cacheKey = `${this.address}_${key}`;
        this.cache?.delete(cacheKey);
    }
    async clearAll() {
        this.cache?.clear();
    }
}

// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/parseJSON.ts
var parseJSON = __webpack_require__(73389);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Storage/libs/Firefly.ts




const genKey = (namespace, userId)=>`${namespace}-${userId.replaceAll('.', '%2E')}`;
class FireflyGetterSetter {
    async get(namespace, userId, address) {
        if (!userId || !address) return;
        const response = await (0,fetchJSON/* fetchJSON */.ZV)((0,dist/* default */.ZP)(`${FIREFLY_API_URL}/get`, {
            key: genKey(namespace, userId),
            address
        }));
        if (!response.metaData?.value) return;
        return (0,parseJSON/* parseJSON */.R)(response.metaData.value);
    }
    async set(namespace, userId, address, value, signature) {
        if (!userId || !address || !value || !signature) return;
        const response = await fetch(`${FIREFLY_API_URL}/set`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                value: JSON.stringify(value),
                address,
                signature,
                key: genKey(namespace, userId)
            })
        });
        const result = await response.json();
        if (result.code !== 200) throw new Error(result.message);
        return;
    }
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Storage/storages/Firefly.ts




const Firefly_caches = new Map();
class FireflyStorage {
    namespace;
    address;
    Firefly;
    Web3;
    cache;
    constructor(namespace, address){
        this.namespace = namespace;
        this.address = address;
        this.Firefly = new FireflyGetterSetter();
        this.Web3 = new ConnectionAPI/* ConnectionAPI */.m();
        const cache = Firefly_caches.get(this.getKey());
        if (cache) {
            this.cache = cache;
            return;
        } else {
            const lru = new mjs/* LRUCache */.z({
                max: 500,
                ttl: 60_000
            });
            Firefly_caches.set(this.getKey(), lru);
            this.cache = lru;
        }
    }
    getKey() {
        return `${this.namespace}-${this.address}`;
    }
    async get(key) {
        const cacheKey = `${this.getKey()}-${key}`;
        let value = this.cache?.get(cacheKey);
        if (value) return value;
        value = await this.Firefly.get(this.namespace, key, this.address);
        this.cache?.set(cacheKey, value);
        return value;
    }
    async has(key) {
        return !!this.get(key);
    }
    async set(key, value) {
        const signature = await this.Web3.signMessage(Account/* SignType */.A.Message, JSON.stringify(value));
        if (!signature) throw new Error('Failed to sign payload');
        await this.Firefly.set(this.namespace, key, this.address, value, signature);
        const cacheKey = `${this.getKey()}-${key}`;
        this.cache?.delete(cacheKey);
        return;
    }
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Storage/apis/Storage.ts




class Web3Storage {
    static createKVStorage(namespace) {
        return new KVStorage(namespace);
    }
    static createFireflyStorage(namespace, address) {
        return new FireflyStorage(namespace, address || '');
    }
    static createRSS3Storage(namespace) {
        return new RSS3Storage(namespace);
    }
    static createNextIDStorage(proofIdentity, platform, signerOrPublicKey, signWithPersona) {
        if (!platform || !signerOrPublicKey) throw new Error('Instantiation parameter error.');
        return new NextIDStorage(proofIdentity, platform, signerOrPublicKey, signWithPersona);
    }
}


/***/ }),

/***/ 26854:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  t: () => (/* binding */ Twitter_Twitter)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/@masknet+kit@0.1.2/node_modules/@masknet/kit/esm/index.js + 1 modules
var esm = __webpack_require__(30898);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/attemptUntil.ts
var attemptUntil = __webpack_require__(92358);
// EXTERNAL MODULE: ./packages/flags/src/index.ts
var src = __webpack_require__(51573);
// EXTERNAL MODULE: ./packages/shared-base/src/helpers/getCookie.ts
var getCookie = __webpack_require__(85791);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Twitter/apis/getTokens.ts


function getHeaders(overrides) {
    return {
        authorization: `Bearer ${src/* Flags */.v.twitter_token}`,
        'x-csrf-token': (0,getCookie/* getCookie */.e)('ct0'),
        'x-twitter-auth-type': 'OAuth2Session',
        'x-twitter-client-language': navigator.language ? navigator.language : 'en',
        ...overrides
    };
}

// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/fetchJSON.ts
var fetchJSON = __webpack_require__(11834);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Twitter/apis/getSettings.ts


async function getSettings() {
    return await (0,fetchJSON/* fetchJSON */.ZV)('https://api.twitter.com/1.1/account/settings.json', {
        headers: getHeaders({
            referer: 'https://twitter.com/home'
        }),
        credentials: 'include'
    });
}

// EXTERNAL MODULE: ./node_modules/.pnpm/@mui+system@5.10.8_@emotion+react@11.11.1_@emotion+styled@11.11.0_@types+react@18.2.21_react@_wx4uwssjzdyhn3m5bz2kb6menq/node_modules/@mui/system/esm/colorManipulator.js
var colorManipulator = __webpack_require__(78056);
// EXTERNAL MODULE: ./packages/shared-base/src/Sniffings/index.ts
var Sniffings = __webpack_require__(66584);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Twitter/apis/getObjectStore.ts

/* cspell:disable-next-line */ const DB_NAME = 'localforage';
const DB_VERSION = 2;
async function getDatabase() {
    if (!Sniffings/* Sniffings */.Y.is_firefox) {
        const databases = await indexedDB.databases();
        if (!databases.some((x)=>x.name === DB_NAME && x.version === DB_VERSION)) return;
    }
    return new Promise((resolve, reject)=>{
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.addEventListener('success', ()=>{
            resolve(request.result);
        });
        request.addEventListener('error', (error)=>{
            reject(error);
        });
    });
}
async function getObjectStore(name) {
    const database = await getDatabase();
    if (!database) throw new Error('Failed to read database.');
    const transaction = database.transaction([
        name
    ], 'readonly');
    return transaction.objectStore(name);
}

// EXTERNAL MODULE: ./packages/web3-providers/src/types/Twitter.ts
var Twitter = __webpack_require__(68419);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Twitter/apis/getUserSettings.ts



/* cspell:disable-next-line */ const STORE_NAME = 'keyvaluepairs';
/* cspell:disable-next-line */ const KEY_NAME = 'device:rweb.settings';
async function getUserSettings() {
    const store = await getObjectStore(STORE_NAME);
    const query = store.get(KEY_NAME);
    return new Promise(async (resolve, reject)=>{
        query.addEventListener('success', (event)=>{
            if (!event.target) reject('Failed to get user settings.');
            const event_ = event;
            resolve(event_.target.result?.local);
        });
        query.addEventListener('error', (error)=>{
            reject(error);
        });
    });
}
function getDefaultUserSettings() {
    return {
        scale: Twitter/* TwitterBaseAPI */.J.Scale.Normal,
        themeBackground: Twitter/* TwitterBaseAPI */.J.ThemeMode.Light,
        themeColor: Twitter/* TwitterBaseAPI */.J.ThemeColor.Blue
    };
}
function getComputedUserSettings() {
    const getThemeBackground = ()=>{
        const { backgroundColor } = getComputedStyle(document.body);
        const rgb = backgroundColor.startsWith('#') ? (0,colorManipulator/* hexToRgb */.oo)(backgroundColor) : backgroundColor;
        switch(rgb.toLowerCase()){
            case 'rgb(255, 255, 255)':
                return Twitter/* TwitterBaseAPI */.J.ThemeMode.Light;
            case 'rgb(21, 32, 43)':
                return Twitter/* TwitterBaseAPI */.J.ThemeMode.Dim;
            case 'rgb(0, 0, 0)':
                return Twitter/* TwitterBaseAPI */.J.ThemeMode.Dark;
            default:
                return;
        }
    };
    const getThemeColor = ()=>{
        const tweetButton = document.querySelector('a[href="/compose/tweet"][data-testid="SideNav_NewTweet_Button"]');
        if (!tweetButton) return;
        const { backgroundColor } = getComputedStyle(tweetButton);
        const rgb = backgroundColor.startsWith('#') ? (0,colorManipulator/* hexToRgb */.oo)(backgroundColor) : backgroundColor;
        switch(rgb.toLowerCase()){
            case 'rgb(29, 155, 240)':
                return Twitter/* TwitterBaseAPI */.J.ThemeColor.Blue;
            case 'rgb(255, 212, 0)':
                return Twitter/* TwitterBaseAPI */.J.ThemeColor.Yellow;
            case 'rgb(120, 86, 255)':
                return Twitter/* TwitterBaseAPI */.J.ThemeColor.Purple;
            case 'rgb(249, 24, 128)':
                return Twitter/* TwitterBaseAPI */.J.ThemeColor.Magenta;
            case 'rgb(255, 122, 0)':
                return Twitter/* TwitterBaseAPI */.J.ThemeColor.Orange;
            case 'rgb(0, 186, 124)':
                return Twitter/* TwitterBaseAPI */.J.ThemeColor.Green;
            default:
                return;
        }
    };
    return {
        themeBackground: getThemeBackground(),
        themeColor: getThemeColor()
    };
}

// EXTERNAL MODULE: ./node_modules/.pnpm/urlcat@3.1.0_patch_hash=5r5xyq4zgcnqugwsrx4lxq2i4e/node_modules/urlcat/dist/index.mjs
var dist = __webpack_require__(78757);
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/fetchCached.ts
var fetchCached = __webpack_require__(22674);
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/fetchSquashed.ts
var fetchSquashed = __webpack_require__(64883);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Twitter/apis/getUserNFTContainer.ts





async function getUserNFTContainer(screenName) {
    return await (0,fetchJSON/* fetchCachedJSON */.MP)((0,dist/* default */.ZP)('https://twitter.com/i/api/graphql/z-_uxIiYELU35OzocPdDIw/userNftContainer_Query', {
        variables: JSON.stringify({
            screenName
        })
    }), {
        headers: getHeaders({
            referer: `https://twitter.com/${screenName}/nft`
        }),
        credentials: 'include'
    }, {
        cacheDuration: fetchCached/* Duration */.nL.ONE_DAY,
        squashExpiration: fetchSquashed/* Expiration */.XP.ONE_SECOND
    });
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Twitter/apis/getUserNFTAvatar.ts


async function getUserNFTAvatar(screenName) {
    return await (0,fetchJSON/* fetchCachedJSON */.MP)((0,dist/* default */.ZP)('https://a8fq5hs9nk.execute-api.us-east-1.amazonaws.com/prod/twitter', {
        screenName
    }));
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Twitter/apis/uploadMedia.ts



const UPLOAD_AVATAR_URL = 'https://upload.twitter.com/i/media/upload.json';
async function uploadMedia(image) {
    const headers = getHeaders();
    // INIT
    const initURL = (0,dist/* default */.ZP)(UPLOAD_AVATAR_URL, {
        command: 'INIT',
        total_bytes: image.size,
        media_type: encodeURIComponent(image.type)
    });
    const initRes = await (0,fetchJSON/* fetchJSON */.ZV)(initURL, {
        method: 'POST',
        headers,
        credentials: 'include'
    });
    // APPEND
    const mediaId = initRes.media_id_string;
    const appendURL = (0,dist/* default */.ZP)(UPLOAD_AVATAR_URL, {
        command: 'APPEND',
        media_id: mediaId,
        segment_index: 0
    });
    const formData = new FormData();
    formData.append('media', image);
    await fetch(appendURL, {
        method: 'POST',
        headers,
        body: formData,
        credentials: 'include'
    });
    // FINALIZE
    const finalizeURL = (0,dist/* default */.ZP)(UPLOAD_AVATAR_URL, {
        command: 'FINALIZE',
        media_id: mediaId
    });
    return (0,fetchJSON/* fetchJSON */.ZV)(finalizeURL, {
        method: 'POST',
        headers,
        credentials: 'include'
    });
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Twitter/apis/updateProfileImage.ts



async function updateProfileImage(screenName, media_id_str) {
    const profile = await (0,fetchJSON/* fetchJSON */.ZV)((0,dist/* default */.ZP)('https://twitter.com/i/api/1.1/account/update_profile_image.json', {
        media_id: media_id_str,
        skip_status: 1,
        return_user: true
    }), {
        method: 'POST',
        headers: getHeaders({
            referer: `https://twitter.com/${screenName}`
        }),
        credentials: 'include'
    });
    return {
        imageUrl: profile.profile_image_url_https,
        mediaId: profile.id_str,
        nickname: profile.name,
        userId: profile.screen_name
    };
}

// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/fetchGlobal.ts
var fetchGlobal = __webpack_require__(49850);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Twitter/apis/getUserByScreenName.ts





const features = {
    responsive_web_twitter_blue_verified_badge_is_enabled: true,
    responsive_web_graphql_exclude_directive_enabled: false,
    verified_phone_label_enabled: false,
    responsive_web_twitter_blue_new_verification_copy_is_enabled: false,
    responsive_web_graphql_skip_user_profile_image_extensions_enabled: false,
    responsive_web_graphql_timeline_navigation_enabled: true,
    blue_business_profile_image_shape_enabled: false,
    subscriptions_verification_info_verified_since_enabled: false,
    creator_subscriptions_tweet_preview_api_enabled: false,
    highlights_tweets_tab_ui_enabled: false,
    hidden_profile_likes_enabled: false,
    hidden_profile_subscriptions_enabled: false,
    subscriptions_verification_info_is_identity_verified_enabled: false
};
async function createRequest(screenName) {
    const url = (0,dist/* default */.ZP)('https://twitter.com/i/api/graphql/sLVLhk0bGj3MVFEKTdax1w/UserByScreenName', {
        variables: JSON.stringify({
            screen_name: screenName,
            withSafetyModeUserFields: true,
            withSuperFollowsUserFields: true
        }),
        features: JSON.stringify(features)
    });
    return new Request(url, {
        headers: getHeaders({
            'content-type': 'application/json',
            referer: `https://twitter.com/${screenName}`
        }),
        credentials: 'include'
    });
}
function createUser(response) {
    const result = response.data.user.result;
    return {
        verified: result.legacy?.verified ?? false,
        has_nft_avatar: result.has_nft_avatar ?? false,
        userId: result.rest_id,
        nickname: result.legacy?.name ?? '',
        screenName: result.legacy?.screen_name ?? '',
        // handle
        avatarURL: result.legacy?.profile_image_url_https.replace(/_normal(\.\w+)$/, '_400x400$1'),
        bio: result.legacy?.description,
        location: result.legacy?.location,
        homepage: result.legacy?.entities.url?.urls[0]?.expanded_url
    };
}
async function getUserByScreenName(screenName) {
    const request = await createRequest(screenName);
    if (!request) return null;
    const response = await (0,fetchGlobal/* fetchGlobal */.d)(request, undefined, {
        cacheDuration: fetchCached/* Duration */.nL.ONE_DAY,
        squashExpiration: fetchSquashed/* Expiration */.XP.ONE_SECOND
    });
    if (response.ok) {
        const json = await response.json();
        return createUser(json);
    }
    const patchingFeatures = [];
    const failedResponse = await response.json();
    for (const error of failedResponse.errors){
        const matched = error.message.match(/The following features cannot be null: (.*)$/);
        if (matched) {
            if (false) {}
            patchingFeatures.push(...matched[1].split(/,\s+/));
        }
    }
    if (patchingFeatures.length) {
        Object.assign(features, Object.fromEntries(patchingFeatures.map((x)=>[
                x,
                false
            ])));
    }
    return null;
}
async function staleUserByScreenName(screenName) {
    const request = await createRequest(screenName);
    if (!request) return null;
    const response = await (0,fetchCached/* staleCached */.be)(request);
    if (!response?.ok) return null;
    const json = await response.json();
    return createUser(json);
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Twitter/apis/getUserByScreenNameShow.ts





function getUserByScreenNameShow_createUser(response) {
    return {
        verified: response.verified,
        has_nft_avatar: false,
        userId: response.id_str,
        nickname: response.name,
        screenName: response.screen_name,
        avatarURL: response.profile_image_url_https.replace(/_normal(\.\w+)$/, '_400x400$1'),
        bio: response.description,
        location: response.location,
        homepage: response.entities?.url?.urls[0]?.expanded_url
    };
}
async function getUserByScreenNameShow_createRequest(screenName) {
    const url = (0,dist/* default */.ZP)('https://api.twitter.com/1.1/users/show.json', {
        screen_name: screenName
    });
    return new Request(url, {
        headers: getHeaders(),
        credentials: 'include'
    });
}
async function getUserByScreenNameShow(screenName) {
    const request = await getUserByScreenNameShow_createRequest(screenName);
    const response = await (0,fetchJSON/* fetchCachedJSON */.MP)(request, undefined, {
        cacheDuration: fetchCached/* Duration */.nL.ONE_DAY,
        squashExpiration: fetchSquashed/* Expiration */.XP.ONE_SECOND
    });
    return getUserByScreenNameShow_createUser(response);
}
async function staleUserByScreenNameShow(screenName) {
    const request = await getUserByScreenNameShow_createRequest(screenName);
    if (!request) return null;
    const response = await (0,fetchCached/* staleCached */.be)(request);
    if (!response?.ok) return null;
    const json = await response.json();
    return getUserByScreenNameShow_createUser(json);
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Twitter/apis/getUserViaTwitterIdentity.ts




const TWITTER_IDENTITY_URL = 'https://mr8asf7i4h.execute-api.us-east-1.amazonaws.com/prod/twitter-identity';
function getUserViaTwitterIdentity_createUser(response) {
    return {
        has_nft_avatar: false,
        verified: response.verified,
        userId: '',
        nickname: response.name,
        screenName: response.screen_name,
        avatarURL: response.profile_image_url_https,
        bio: response.description,
        location: response.location,
        homepage: response.entities?.url?.urls[0]?.expanded_url
    };
}
async function getUserViaTwitterIdentity(screenName) {
    const identity = await (0,fetchJSON/* fetchCachedJSON */.MP)((0,dist/* default */.ZP)(TWITTER_IDENTITY_URL, {
        screenName
    }), undefined, {
        cacheDuration: fetchCached/* Duration */.nL.ONE_DAY,
        squashExpiration: fetchSquashed/* Expiration */.XP.ONE_SECOND
    });
    return getUserViaTwitterIdentity_createUser(identity);
}
async function staleUserViaIdentity(screenName) {
    const response = await (0,fetchCached/* staleCached */.be)(new URL((0,dist/* default */.ZP)(TWITTER_IDENTITY_URL, {
        screenName
    })));
    if (!response?.ok) return null;
    const identity = await response.json();
    return getUserViaTwitterIdentity_createUser(identity);
}

// EXTERNAL MODULE: ./node_modules/.pnpm/twitter-text@3.1.0/node_modules/twitter-text/dist/esm/index.js + 131 modules
var dist_esm = __webpack_require__(46868);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Twitter/apis/createTweet.ts
/* cspell:disable */ 


const createTweet_features = {
    freedom_of_speech_not_reach_fetch_enabled: true,
    graphql_is_translatable_rweb_tweet_is_translatable_enabled: true,
    longform_notetweets_consumption_enabled: true,
    longform_notetweets_inline_media_enabled: true,
    longform_notetweets_rich_text_read_enabled: true,
    responsive_web_edit_tweet_api_enabled: true,
    responsive_web_enhance_cards_enabled: false,
    responsive_web_graphql_exclude_directive_enabled: true,
    responsive_web_graphql_skip_user_profile_image_extensions_enabled: false,
    responsive_web_graphql_timeline_navigation_enabled: true,
    responsive_web_media_download_video_enabled: false,
    responsive_web_twitter_article_tweet_consumption_enabled: false,
    standardized_nudges_misinfo: true,
    tweet_awards_web_tipping_enabled: false,
    tweet_with_visibility_results_prefer_gql_limited_actions_policy_enabled: true,
    tweetypie_unmention_optimization_enabled: true,
    verified_phone_label_enabled: false,
    view_counts_everywhere_api_enabled: true
};
const toggles = {
    withArticleRichContentState: false,
    withAuxiliaryUserLabels: false
};
async function createTweet(tweet) {
    const variables = {
        ...tweet,
        dark_request: false,
        withDownvotePerspective: false,
        withReactionsMetadata: false,
        withReactionsPerspective: false,
        withSuperFollowsTweetFields: true,
        withSuperFollowsUserFields: true,
        semantic_annotation_ids: []
    };
    const parsedTweet = dist_esm/* default */.Z.parseTweet(variables.tweet_text);
    const overLength = parsedTweet.weightedLength > 280;
    const scheduled = typeof variables.execute_at !== 'undefined';
    const queryId = scheduled ? 'LCVzRQGxOaGnOnYH01NQXg' : overLength ? 'pokID4auGUSzBxijrqpIlw' : 'tTsjMKyhajZvK4q76mpIBg';
    const queryName = scheduled ? 'CreateScheduledTweet' : overLength ? 'CreateNoteTweet' : 'CreateTweet';
    const response = await (0,fetchJSON/* fetchJSON */.ZV)(`https://twitter.com/i/api/graphql/${queryId}/${queryName}`, {
        headers: getHeaders({
            'content-type': 'application/json; charset=utf-8'
        }),
        method: 'POST',
        credentials: 'include',
        body: JSON.stringify({
            variables,
            features: createTweet_features,
            fieldToggles: toggles,
            queryId
        })
    });
    return response.data[scheduled ? 'posttweet_created' : overLength ? 'notetweet_create' : 'create_tweet'].tweet_results.result;
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Twitter/index.ts



class Twitter_Twitter {
    static getAvatarId(avatarURL) {
        if (!avatarURL) return '';
        const match = new URL(avatarURL).pathname.match(/^\/profile_images\/(\d+)/);
        return match ? match[1] : '';
    }
    static getSettings() {
        return getSettings();
    }
    static async getUserSettings() {
        const defaults = getDefaultUserSettings();
        const computed = getComputedUserSettings();
        try {
            const userSettings = await (0,esm/* timeout */.Vs)(getUserSettings(), 5000, 'Timeout to get twitter user settings.');
            return {
                ...defaults,
                ...computed,
                ...userSettings
            };
        } catch  {
            return {
                ...defaults,
                ...computed
            };
        }
    }
    static async getUserNftContainer(screenName) {
        return await (0,attemptUntil/* attemptUntil */.C)([
            async ()=>{
                const response = await getUserNFTContainer(screenName);
                const result = response?.data.user?.result;
                if (!result?.has_nft_avatar) throw new Error(`User ${screenName} doesn't have NFT avatar.`);
                return {
                    address: result.nft_avatar_metadata.smart_contract.address,
                    token_id: result.nft_avatar_metadata.token_id
                };
            },
            async ()=>{
                const response = await getUserNFTAvatar(screenName);
                const result = response.data.user?.result;
                if (!result?.has_nft_avatar) throw new Error(`User ${screenName} doesn't have NFT avatar.`);
                return {
                    address: result.nft_avatar_metadata.smart_contract.address,
                    token_id: result.nft_avatar_metadata.token_id
                };
            }
        ], undefined);
    }
    static async uploadMedia(image) {
        return uploadMedia(image);
    }
    static async updateProfileImage(screenName, media_id_str) {
        return updateProfileImage(screenName, media_id_str);
    }
    static async getUserByScreenName(screenName, checkNFTAvatar) {
        if (!screenName) return null;
        if (checkNFTAvatar) return getUserByScreenName(screenName);
        return (0,attemptUntil/* attemptUntil */.C)([
            ()=>getUserByScreenNameShow(screenName),
            ()=>getUserByScreenName(screenName),
            ()=>getUserViaTwitterIdentity(screenName)
        ], null);
    }
    static async staleUserByScreenName(screenName) {
        await staleUserByScreenName(screenName);
        await staleUserByScreenNameShow(screenName);
        await staleUserViaIdentity(screenName);
    }
    static async createTweet(tweet) {
        const response = await createTweet(tweet);
        return response.rest_id;
    }
}


/***/ }),

/***/ 26197:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   p: () => (/* binding */ ChainResolverAPI_Base)
/* harmony export */ });
class ChainResolverAPI_Base {
    getDescriptor(chainId) {
        return this.descriptors.find((x)=>x.chainId === chainId);
    }
    getDescriptorRequired(chainId) {
        const descriptor = this.getDescriptor(chainId);
        if (!descriptor) throw new Error(`Unknown chainId: ${chainId}. It might too early to access network state.`);
        return descriptor;
    }
    /**
     * Guess chain id by name, it's not perfectly accurate
     */ chainId = (name)=>this.descriptors.find((x)=>[
                x.name,
                x.type,
                x.fullName,
                x.shortName
            ].map((x)=>x?.toLowerCase()).filter(Boolean).includes(name?.toLowerCase()))?.chainId;
    coinMarketCapChainId = (chainId)=>this.getDescriptor(chainId)?.coinMarketCapChainId ?? '';
    coinGeckoChainId = (chainId)=>this.getDescriptor(chainId)?.coinGeckoChainId ?? '';
    coinGeckoPlatformId = (chainId)=>this.getDescriptor(chainId)?.coinGeckoPlatformId ?? '';
    chainName = (chainId)=>this.getDescriptor(chainId)?.name ?? 'Custom Network';
    chainFullName = (chainId)=>this.getDescriptor(chainId)?.fullName ?? 'Custom Network';
    chainColor = (chainId)=>this.getDescriptor(chainId)?.color ?? 'rgb(138, 138, 138)';
    chainPrefix = (chainId)=>'';
    networkType = (chainId)=>this.getDescriptorRequired(chainId)?.type;
    explorerUrl = (chainId)=>this.getDescriptorRequired(chainId)?.explorerUrl;
    nativeCurrency = (chainId)=>this.getDescriptorRequired(chainId)?.nativeCurrency;
    isValidChainId = (chainId, testnet = false)=>this.getDescriptor(chainId)?.network === 'mainnet' || testnet;
    isMainnet = (chainId)=>this.getDescriptor(chainId)?.network === 'mainnet';
    isFeatureSupported = (chainId, feature)=>!!this.getDescriptor(chainId)?.features?.includes(feature);
}


/***/ }),

/***/ 21871:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   G: () => (/* binding */ ConnectionOptionsAPI_Base)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(73307);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45911);

/** Designate the signer of the transaction. */ /** Designate the sub-network id of the transaction. */ /** an abstract wallet has a owner */ /** persona identifier */ /** Designate the provider to handle the transaction. */ /** Custom network rpc url. */ /** Gas payment token. */ /** Only Support Mask Wallet, silent switch wallet */ /** Accessing data from chain directly w/o middleware, the default value is true  */ /** Fragments to merge into the transaction. */ /** Termination signal */ /** Gas option type */ class ConnectionOptionsAPI_Base {
    options;
    constructor(options){
        this.options = options;
    }
    get defaults() {
        const others = this.Web3Others;
        return {
            account: '',
            chainId: others.getDefaultChainId(),
            providerType: others.getDefaultProviderType()
        };
    }
    get refs() {
        const provider = this.Web3StateRef.value?.Provider;
        if (!provider) return {};
        return {
            account: provider.account?.getCurrentValue(),
            chainId: provider.chainId?.getCurrentValue(),
            providerType: provider.providerType?.getCurrentValue()
        };
    }
    fill(initials, overrides) {
        return {
            ...this.defaults,
            ...this.refs,
            ...(0,lodash_es__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this.options, lodash_es__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z),
            ...(0,lodash_es__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(initials, lodash_es__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z),
            overrides: {
                ...this.defaults.overrides,
                ...(0,lodash_es__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this.refs?.overrides, lodash_es__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z),
                ...(0,lodash_es__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this.options?.overrides, lodash_es__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z),
                ...(0,lodash_es__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(initials?.overrides, lodash_es__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z),
                ...(0,lodash_es__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(overrides, lodash_es__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)
            }
        };
    }
}


/***/ }),

/***/ 12030:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   I: () => (/* binding */ ExplorerResolverAPI_Base)
/* harmony export */ });
/* harmony import */ var urlcat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78757);

class ExplorerResolverAPI_Base {
    get options() {
        const defaults = {
            addressPathname: '/address/:address',
            blockPathname: '/block/:blockNumber',
            transactionPathname: '/tx/:id',
            domainPathname: '/address/:domain',
            fungibleTokenPathname: '/address/:address',
            nonFungibleTokenPathname: '/nft/:address/:tokenId'
        };
        return {
            ...defaults,
            ...this.initial
        };
    }
    getExplorerURL(chainId) {
        const chainDescriptor = this.descriptors.find((x)=>x.chainId === chainId);
        return chainDescriptor?.explorerUrl ?? {
            url: ''
        };
    }
    explorerUrl = (chainId)=>this.getExplorerURL(chainId);
    addressLink = (chainId, address, tokenId)=>{
        const explorerUrl = this.getExplorerURL(chainId);
        if (!explorerUrl.url) return;
        return (0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(explorerUrl.url, this.options.addressPathname, {
            address,
            ...explorerUrl?.parameters
        });
    };
    blockLink = (chainId, blockNumber)=>{
        const explorerUrl = this.getExplorerURL(chainId);
        if (!explorerUrl.url) return;
        return (0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(explorerUrl.url, this.options.blockPathname, {
            blockNumber,
            ...explorerUrl?.parameters
        });
    };
    transactionLink = (chainId, id)=>{
        const explorerUrl = this.getExplorerURL(chainId);
        if (!explorerUrl.url) return;
        return (0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(explorerUrl.url, this.options.transactionPathname, {
            id,
            ...explorerUrl?.parameters
        });
    };
    fungibleTokenLink = (chainId, address)=>{
        const explorerUrl = this.getExplorerURL(chainId);
        if (!address || !explorerUrl.url) return;
        return (0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(explorerUrl.url, this.options.fungibleTokenPathname, {
            address,
            ...explorerUrl?.parameters
        });
    };
    nonFungibleTokenLink = (chainId, address, tokenId)=>{
        const explorerUrl = this.getExplorerURL(chainId);
        if (!explorerUrl.url) return;
        return (0,urlcat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(explorerUrl.url, this.options.nonFungibleTokenPathname, {
            address,
            tokenId,
            ...explorerUrl?.parameters
        });
    };
}


/***/ }),

/***/ 75583:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   j: () => (/* binding */ HubBaseAPI_Base)
/* harmony export */ });
/* harmony import */ var _HubProviderAPI_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(88861);

class HubBaseAPI_Base extends _HubProviderAPI_js__WEBPACK_IMPORTED_MODULE_0__/* .HubProviderAPI_Base */ .e {
}


/***/ }),

/***/ 34659:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   L: () => (/* binding */ HubFungibleAPI_Base)
/* harmony export */ });
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(52033);
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(38645);
/* harmony import */ var _masknet_shared_base_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(73401);
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(92358);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8610);
/* harmony import */ var _HubProviderAPI_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(88861);





class HubFungibleAPI_Base extends _HubProviderAPI_js__WEBPACK_IMPORTED_MODULE_0__/* .HubProviderAPI_Base */ .e {
    async getFungibleTokensFromTokenList(chainId, initial) {
        const options = this.HubOptions.fill({
            ...initial,
            chainId
        });
        const providers = this.getProviders(initial);
        return _masknet_shared_base_ui__WEBPACK_IMPORTED_MODULE_1__/* .queryClient */ .E.fetchQuery([
            'get-fungible-token-list',
            options.chainId,
            initial
        ], async ()=>{
            return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .attemptUntil */ .C)(providers.map((x)=>()=>x.getFungibleTokenList?.(options.chainId)), _masknet_shared_base__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_LIST */ .rP);
        });
    }
    async getFungibleTokenIconURLs(chainId, address, initial) {
        const options = this.HubOptions.fill({
            ...initial,
            chainId
        });
        const providers = this.getProviders(initial);
        return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .attemptUntil */ .C)(providers.map((x)=>()=>x.getFungibleTokenIconURLs?.(options.chainId, address)), _masknet_shared_base__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_LIST */ .rP);
    }
    async getFungibleTokenPrice(chainId, address, initial) {
        const options = this.HubOptions.fill({
            ...initial,
            chainId
        });
        const providers = this.getProviders(initial);
        return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .attemptUntil */ .C)(providers.map((x)=>()=>x.getFungibleTokenPrice?.(options.chainId, address)), undefined);
    }
    async getFungibleTokenSpenders(chainId, account, initial) {
        const options = this.HubOptions.fill({
            ...initial,
            chainId,
            account
        });
        const providers = this.getProviders(initial);
        return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .attemptUntil */ .C)(providers.map((x)=>()=>x.getFungibleTokenSpenders?.(options.chainId, options.account)), _masknet_shared_base__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_LIST */ .rP, lodash_es__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z);
    }
    async getFungibleAsset(address, initial) {
        const options = this.HubOptions.fill(initial);
        const providers = this.getProviders(initial);
        return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .attemptUntil */ .C)(providers.map((x)=>()=>x.getAsset?.(address, options)), undefined);
    }
    async getFungibleAssets(account, initial) {
        const options = this.HubOptions.fill({
            ...initial,
            account
        });
        const providers = this.getProviders(initial);
        return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .attemptUntil */ .C)(providers.map((x)=>()=>x.getAssets?.(options.account, options)), (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_5__/* .createPageable */ .LI)(_masknet_shared_base__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_LIST */ .rP, (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_5__/* .createIndicator */ .sz)(options.indicator)));
    }
    async getTrustedFungibleAssets(account, trustedFungibleTokens, initial) {
        const options = this.HubOptions.fill({
            ...initial,
            account
        });
        const providers = this.getProviders(initial);
        return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .attemptUntil */ .C)(providers.map((x)=>()=>x.getTrustedAssets?.(options.account, trustedFungibleTokens, options)), (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_5__/* .createPageable */ .LI)(_masknet_shared_base__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_LIST */ .rP, (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_5__/* .createIndicator */ .sz)(options.indicator)));
    }
}


/***/ }),

/***/ 18391:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   j: () => (/* binding */ HubNonFungibleAPI_Base)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8610);
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(92358);
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38645);
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(52033);
/* harmony import */ var _HubProviderAPI_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(88861);




class HubNonFungibleAPI_Base extends _HubProviderAPI_js__WEBPACK_IMPORTED_MODULE_0__/* .HubProviderAPI_Base */ .e {
    async getNonFungibleRarity(address, tokenId, initial) {
        const options = this.HubOptions.fill(initial);
        const providers = this.getProviders(initial);
        return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_1__/* .attemptUntil */ .C)(providers.map((x)=>()=>x.getRarity?.(address, tokenId, options)), undefined);
    }
    async getNonFungibleAsset(address, tokenId, initial) {
        const options = this.HubOptions.fill(initial);
        const providers = this.getProviders(initial);
        return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_1__/* .attemptUntil */ .C)(providers.map((x)=>()=>x.getAsset?.(address, tokenId, options)), undefined, (v)=>!v);
    }
    async getNonFungibleAssets(account, initial) {
        const options = this.HubOptions.fill({
            ...initial,
            account
        });
        const providers = this.getProviders(initial);
        return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_1__/* .attemptUntil */ .C)(providers.map((x)=>()=>x.getAssets?.(options.account, options)), (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .createPageable */ .LI)(_masknet_shared_base__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_LIST */ .rP, (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .createIndicator */ .sz)(options.indicator)));
    }
    async getNonFungibleTokenFloorPrice(address, tokenId, initial) {
        const options = this.HubOptions.fill(initial);
        const providers = this.getProviders(initial);
        return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_1__/* .attemptUntil */ .C)(providers.map((x)=>()=>x.getFloorPrice?.(address, tokenId, options)), undefined);
    }
    async getNonFungibleAssetsByCollection(address, initial) {
        const options = this.HubOptions.fill(initial);
        const providers = this.getProviders(initial);
        return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_1__/* .attemptUntil */ .C)(providers.map((x)=>()=>x.getAssetsByCollection?.(address, options)), (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .createPageable */ .LI)(_masknet_shared_base__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_LIST */ .rP, (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .createIndicator */ .sz)(options.indicator)));
    }
    async getNonFungibleAssetsByCollectionAndOwner(collectionId, owner, initial) {
        const options = this.HubOptions.fill(initial);
        const providers = this.getProviders(initial);
        return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_1__/* .attemptUntil */ .C)(providers.map((x)=>()=>x.getAssetsByCollectionAndOwner?.(collectionId, owner, options)), (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .createPageable */ .LI)(_masknet_shared_base__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_LIST */ .rP, (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .createIndicator */ .sz)(options.indicator)));
    }
    async getNonFungibleTokenContract(address, initial) {
        const options = this.HubOptions.fill(initial);
        const providers = this.getProviders(initial);
        return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_1__/* .attemptUntil */ .C)(providers.map((x)=>()=>x.getContract?.(address, options)), undefined);
    }
    async getNonFungibleTokenEvents(address, tokenId, initial) {
        const options = this.HubOptions.fill(initial);
        const providers = this.getProviders(initial);
        return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_1__/* .attemptUntil */ .C)(providers.map((x)=>()=>x.getEvents?.(address, tokenId, options)), (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .createPageable */ .LI)(_masknet_shared_base__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_LIST */ .rP, (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .createIndicator */ .sz)(options.indicator)));
    }
    async getNonFungibleTokenListings(address, tokenId, initial) {
        const options = this.HubOptions.fill(initial);
        const providers = this.getProviders(initial);
        return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_1__/* .attemptUntil */ .C)(providers.map((x)=>()=>x.getListings?.(address, tokenId, options)), (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .createPageable */ .LI)(_masknet_shared_base__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_LIST */ .rP, (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .createIndicator */ .sz)(options.indicator)));
    }
    async getNonFungibleTokenOffers(address, tokenId, initial) {
        const options = this.HubOptions.fill(initial);
        const providers = this.getProviders(initial);
        return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_1__/* .attemptUntil */ .C)(providers.map((x)=>()=>x.getOffers?.(address, tokenId, options)), (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .createPageable */ .LI)(_masknet_shared_base__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_LIST */ .rP, (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .createIndicator */ .sz)(options.indicator)), (result)=>!result?.data.length);
    }
    async getNonFungibleTokenOrders(address, tokenId, side, initial) {
        const options = this.HubOptions.fill(initial);
        const providers = this.getProviders(initial);
        return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_1__/* .attemptUntil */ .C)(providers.map((x)=>()=>x.getOrders?.(address, tokenId, side, options)), (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .createPageable */ .LI)(_masknet_shared_base__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_LIST */ .rP, (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .createIndicator */ .sz)(options.indicator)), (result)=>!result?.data.length);
    }
    async getNonFungibleCollectionsByOwner(account, initial) {
        const options = this.HubOptions.fill(initial);
        const providers = this.getProviders(initial);
        return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_1__/* .attemptUntil */ .C)(providers.map((x)=>()=>x.getCollectionsByOwner?.(account, options)), (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .createPageable */ .LI)(_masknet_shared_base__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_LIST */ .rP, (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .createIndicator */ .sz)(options.indicator)));
    }
    async getNonFungibleCollectionVerifiedBy(id) {
        const providers = this.getProviders();
        return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_1__/* .attemptUntil */ .C)(providers.map((x)=>()=>x.getCollectionVerifiedBy?.(id)), []);
    }
    async getNonFungibleTokensFromTokenList(chainId, initial) {
        const options = this.HubOptions.fill({
            ...initial,
            chainId
        });
        const providers = this.getProviders(initial);
        return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_1__/* .attemptUntil */ .C)(providers.map((x)=>()=>x.getNonFungibleTokenList?.(options.chainId)), _masknet_shared_base__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_LIST */ .rP);
    }
    async getNonFungibleTokenSpenders(chainId, account, initial) {
        const options = this.HubOptions.fill({
            ...initial,
            chainId,
            account
        });
        const providers = this.getProviders(initial);
        return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_1__/* .attemptUntil */ .C)(providers.map((x)=>()=>x.getNonFungibleTokenSpenders?.(options.chainId, options.account)), _masknet_shared_base__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY_LIST */ .rP, lodash_es__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z);
    }
}


/***/ }),

/***/ 14058:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   v: () => (/* binding */ HubOptionsAPI_Base)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(73307);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45911);
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62649);


/** The user account as the API parameter */ /** The chain id as the API parameter */ /** The networkPluginID as the API parameter */ /** The id of data provider */ /** The schema type of filtered data */ /** The currency type of data */ /** The item size of each page. */ /** The page index. */ class HubOptionsAPI_Base {
    options;
    constructor(options){
        this.options = options;
    }
    get defaults() {
        return {
            account: '',
            chainId: this.Web3Others.getDefaultChainId(),
            networkPluginId: this.Web3Others.getNetworkPluginID(),
            currencyType: _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_0__/* .CurrencyType */ .V2.USD,
            size: 50
        };
    }
    get refs() {
        if (!this.Web3StateRef.value) return {};
        return {
            account: this.Web3StateRef.value.Provider?.account?.getCurrentValue(),
            chainId: this.Web3StateRef.value.Provider?.chainId?.getCurrentValue(),
            currencyType: this.Web3StateRef.value.Settings?.currencyType?.getCurrentValue()
        };
    }
    fill(initial) {
        return {
            ...this.defaults,
            ...this.refs,
            ...this.options,
            ...(0,lodash_es__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(initial, lodash_es__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)
        };
    }
}


/***/ }),

/***/ 88861:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   e: () => (/* binding */ HubProviderAPI_Base)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(92358);

class HubProviderAPI_Base {
    options;
    constructor(options){
        this.options = options;
    }
    getPredicateProviders(providers, defaultProviders, initial) {
        const options = this.HubOptions.fill(initial);
        const predicate = (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_0__/* .createPredicate */ .K)(Object.keys(providers));
        return predicate(options.sourceType) ? [
            providers[options.sourceType]
        ] : defaultProviders;
    }
}


/***/ }),

/***/ 92845:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   n: () => (/* binding */ NetworkResolverAPI_Base)
/* harmony export */ });
class NetworkResolverAPI_Base {
    getDescriptor(networkType) {
        return this.descriptors.find((x)=>x.type === networkType);
    }
    networkIcon = (networkType)=>this.getDescriptor(networkType)?.icon;
    networkIconColor = (networkType)=>this.getDescriptor(networkType)?.iconColor;
    networkName = (networkType)=>this.getDescriptor(networkType)?.name;
    networkChainId = (networkType)=>this.getDescriptor(networkType)?.chainId;
}


/***/ }),

/***/ 57429:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ OthersAPI_Base)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74765);

class OthersAPI_Base {
    chainResolver = null;
    explorerResolver = null;
    providerResolver = null;
    networkResolver = null;
    getNetworkPluginID() {
        throw new Error('Method not implemented.');
    }
    getDefaultChainId() {
        throw new Error('Method not implemented.');
    }
    getInvalidChainId() {
        throw new Error('Method not implemented.');
    }
    getDefaultNetworkType() {
        throw new Error('Method not implemented.');
    }
    getDefaultProviderType() {
        throw new Error('Method not implemented.');
    }
    getZeroAddress() {
        throw new Error('Method not implemented.');
    }
    getNativeTokenAddress(chainId) {
        throw new Error('Method not implemented.');
    }
    getMaskTokenAddress(chainId) {
        throw new Error('Method not implemented.');
    }
    getAverageBlockDelay(chainId, scale = 1) {
        throw new Error('Method not implemented.');
    }
    getTransactionSignature(chainId, transaction) {
        throw new Error('Method not implemented.');
    }
    isSameAddress = _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_0__/* .isSameAddress */ .W;
    isZeroAddress(address) {
        throw new Error('Method not implemented.');
    }
    isNativeTokenAddress(address) {
        throw new Error('Method not implemented.');
    }
    isValidChain(chainId, testnet = false) {
        throw new Error('Method not implemented.');
    }
    isValidChainId(chainId) {
        throw new Error('Method not implemented.');
    }
    isValidDomain(domain) {
        throw new Error('Method not implemented.');
    }
    isValidAddress(address) {
        throw new Error('Method not implemented.');
    }
    isNativeTokenSchemaType(schemaType) {
        throw new Error('Method not implemented.');
    }
    isFungibleTokenSchemaType(schemaType) {
        throw new Error('Method not implemented.');
    }
    isNonFungibleTokenSchemaType(schemaType) {
        throw new Error('Method not implemented.');
    }
    formatAddress(address, size) {
        throw new Error('Method not implemented.');
    }
    formatTokenId(id, size) {
        throw new Error('Method not implemented.');
    }
    formatDomainName(domain, size) {
        throw new Error('Method not implemented.');
    }
    formatSchemaType(schema) {
        throw new Error('Method not implemented.');
    }
    createNativeToken(chainId) {
        throw new Error('Method not implemented.');
    }
    createFungibleToken(chainId, schemaType, address, name, symbol, decimals, logoURI) {
        throw new Error('Method not implemented.');
    }
    createNonFungibleToken(chainId, address, schemaType, tokenId, ownerId, metadata, contract, collection) {
        throw new Error('Method not implemented.');
    }
}


/***/ }),

/***/ 31710:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   P: () => (/* binding */ ProviderResolverAPI_Base)
/* harmony export */ });
class ProviderResolverAPI_Base {
    getDescriptor(providerType) {
        return this.descriptors.find((x)=>x.type === providerType);
    }
    providerName = (providerType)=>this.getDescriptor(providerType)?.name;
    providerHomeLink = (providerType)=>this.getDescriptor(providerType)?.homeLink;
    providerShortenLink = (providerType)=>this.getDescriptor(providerType)?.shortenLink;
    providerDownloadLink = (providerType)=>this.getDescriptor(providerType)?.downloadLink;
}


/***/ }),

/***/ 16488:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   m: () => (/* binding */ ConnectionAPI)
/* harmony export */ });
/* harmony import */ var web3_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(84976);
/* harmony import */ var web3_utils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(web3_utils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _masknet_kit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30898);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(24770);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(65327);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(21704);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(17448);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(40068);
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(62649);
/* harmony import */ var _Web3StateAPI_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(39850);
/* harmony import */ var _RequestAPI_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(81254);
/* harmony import */ var _ContractAPI_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(67433);
/* harmony import */ var _ConnectionReadonlyAPI_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3543);
/* harmony import */ var _ConnectionOptionsAPI_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(2685);
/* harmony import */ var _providers_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(66402);










class ConnectionAPI extends _ConnectionReadonlyAPI_js__WEBPACK_IMPORTED_MODULE_2__/* .ConnectionReadonlyAPI */ .S {
    get Transaction() {
        return _Web3StateAPI_js__WEBPACK_IMPORTED_MODULE_3__.Web3StateRef.value.Transaction;
    }
    get TransactionWatcher() {
        return _Web3StateAPI_js__WEBPACK_IMPORTED_MODULE_3__.Web3StateRef.value.TransactionWatcher;
    }
    Request = new _RequestAPI_js__WEBPACK_IMPORTED_MODULE_4__/* .RequestAPI */ .U(this.options);
    Contract = new _ContractAPI_js__WEBPACK_IMPORTED_MODULE_5__/* .ContractAPI */ .J(this.options);
    ConnectionOptions = new _ConnectionOptionsAPI_js__WEBPACK_IMPORTED_MODULE_6__/* .ConnectionOptionsAPI */ .T(this.options);
    async addWallet(wallet, initial) {
        await this.Request.request({
            method: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__/* .EthereumMethodType */ .W8.MASK_ADD_WALLET,
            params: [
                wallet
            ]
        }, initial);
    }
    async updateWallet(address, wallet, initial) {
        await this.Request.request({
            method: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__/* .EthereumMethodType */ .W8.MASK_UPDATE_WALLET,
            params: [
                address,
                wallet
            ]
        }, initial);
    }
    async renameWallet(address, name, initial) {
        await this.Request.request({
            method: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__/* .EthereumMethodType */ .W8.MASK_RENAME_WALLET,
            params: [
                address,
                name
            ]
        }, initial);
    }
    async removeWallet(address, password, initial) {
        await this.Request.request({
            method: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__/* .EthereumMethodType */ .W8.MASK_REMOVE_WALLET,
            params: [
                address,
                password
            ]
        }, initial);
    }
    async resetAllWallets(initial) {
        await this.Request.request({
            method: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__/* .EthereumMethodType */ .W8.MASK_RESET_ALL_WALLETS,
            params: []
        }, initial);
    }
    async updateWallets(wallets, initial) {
        await this.Request.request({
            method: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__/* .EthereumMethodType */ .W8.MASK_UPDATE_WALLETS,
            params: wallets
        }, initial);
    }
    async removeWallets(wallets, initial) {
        await this.Request.request({
            method: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__/* .EthereumMethodType */ .W8.MASK_REMOVE_WALLETS,
            params: wallets
        }, initial);
    }
    async approveFungibleToken(address, recipient, amount, initial) {
        const options = this.ConnectionOptions.fill(initial);
        // Native
        if (!address || (0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_8__/* .isNativeTokenAddress */ .qw)(address)) throw new Error('Invalid token address.');
        // ERC20
        return new _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_9__/* .ContractTransaction */ .D(this.Contract.getERC20Contract(address, options)).send((x)=>x?.methods.approve(recipient, (0,web3_utils__WEBPACK_IMPORTED_MODULE_0__.toHex)(amount)), options.overrides);
    }
    async approveNonFungibleToken(address, recipient, tokenId, schema, initial) {
        // Do not use `approve()`, since it is buggy.
        // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol
        throw new Error('Method not implemented.');
    }
    async approveAllNonFungibleTokens(address, recipient, approved, schema, initial) {
        const options = this.ConnectionOptions.fill(initial);
        // Native
        if (!address || (0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_8__/* .isNativeTokenAddress */ .qw)(address)) throw new Error('Invalid token address.');
        // ERC721 & ERC1155
        return new _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_9__/* .ContractTransaction */ .D(this.Contract.getERC721Contract(address, options)).send((x)=>x?.methods.setApprovalForAll(recipient, approved), options.overrides);
    }
    async transferFungibleToken(address, recipient, amount, memo, initial) {
        const options = this.ConnectionOptions.fill(initial);
        // Native
        if (!address || (0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_8__/* .isNativeTokenAddress */ .qw)(address)) {
            const tx = {
                from: options.account,
                to: recipient,
                value: (0,web3_utils__WEBPACK_IMPORTED_MODULE_0__.toHex)(amount),
                data: memo ? (0,web3_utils__WEBPACK_IMPORTED_MODULE_0__.toHex)(memo) : undefined
            };
            return this.sendTransaction({
                ...tx,
                gas: await this.estimateTransaction(tx, 50000, options)
            }, options);
        }
        // ERC20
        return new _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_9__/* .ContractTransaction */ .D(this.Contract.getERC20Contract(address, options)).send((x)=>x?.methods.transfer(recipient, (0,web3_utils__WEBPACK_IMPORTED_MODULE_0__.toHex)(amount)), options.overrides);
    }
    async transferNonFungibleToken(address, tokenId, recipient, amount, schema, initial) {
        const options = this.ConnectionOptions.fill(initial);
        const actualSchema = schema ?? await this.getSchemaType(address, options);
        // ERC1155
        if (actualSchema === _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__/* .SchemaType */ .XQ.ERC1155) {
            return new _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_9__/* .ContractTransaction */ .D(this.Contract.getERC1155Contract(address, options)).send((x)=>x?.methods.safeTransferFrom(options.account, recipient, tokenId, amount ?? '', '0x'), options.overrides);
        }
        // ERC721
        return new _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_9__/* .ContractTransaction */ .D(this.Contract.getERC721Contract(address, options)).send((x)=>x?.methods.transferFrom(options.account, recipient, tokenId), options.overrides);
    }
    signMessage(type, message, initial) {
        const options = this.ConnectionOptions.fill(initial);
        if (!options.account) throw new Error('Unknown account.');
        switch(type){
            case 'message':
                return this.Request.request({
                    method: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__/* .EthereumMethodType */ .W8.PERSONAL_SIGN,
                    params: [
                        message,
                        options.account,
                        ''
                    ].filter((x)=>typeof x !== 'undefined')
                }, options);
            case 'typedData':
                return this.Request.request({
                    method: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__/* .EthereumMethodType */ .W8.ETH_SIGN_TYPED_DATA,
                    params: [
                        options.account,
                        message
                    ]
                }, options);
            default:
                throw new Error(`Unknown sign type: ${type}.`);
        }
    }
    async verifyMessage(type, message, signature, initial) {
        const options = this.ConnectionOptions.fill(initial);
        const dataToSign = await this.getWeb3(options).eth.personal.ecRecover(message, signature);
        return dataToSign === message;
    }
    async signTransaction(transaction, initial) {
        return this.Request.request({
            method: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__/* .EthereumMethodType */ .W8.ETH_SIGN_TRANSACTION,
            params: [
                transaction
            ]
        }, initial);
    }
    signTransactions(transactions, initial) {
        return Promise.all(transactions.map((x)=>this.signTransaction(x, initial)));
    }
    supportedChainIds(initial) {
        return this.Request.request({
            method: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__/* .EthereumMethodType */ .W8.ETH_SUPPORTED_CHAIN_IDS,
            params: []
        }, initial);
    }
    supportedEntryPoints(initial) {
        return this.Request.request({
            method: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__/* .EthereumMethodType */ .W8.ETH_SUPPORTED_ENTRY_POINTS,
            params: []
        }, initial);
    }
    async callUserOperation(owner, operation, initial) {
        const options = this.ConnectionOptions.fill(initial);
        return this.Request.request({
            method: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__/* .EthereumMethodType */ .W8.ETH_CALL_USER_OPERATION,
            params: [
                owner,
                {
                    ...operation,
                    sender: options.account
                }
            ]
        }, options);
    }
    async sendUserOperation(owner, operation, initial) {
        const options = this.ConnectionOptions.fill(initial);
        return this.Request.request({
            method: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__/* .EthereumMethodType */ .W8.ETH_SEND_USER_OPERATION,
            params: [
                owner,
                {
                    ...operation,
                    sender: operation.sender || options.account
                }
            ]
        }, options);
    }
    async transfer(recipient, amount, initial) {
        const options = this.ConnectionOptions.fill(initial);
        const contract = this.Contract.getWalletContract(options.account, options);
        if (!contract) throw new Error('Failed to create contract.');
        const tx = {
            from: options.account,
            to: options.account,
            data: contract.methods.transfer(recipient, amount).encodeABI()
        };
        return this.Request.request({
            method: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__/* .EthereumMethodType */ .W8.ETH_SEND_TRANSACTION,
            params: [
                {
                    ...tx,
                    gas: await this.estimateTransaction(tx, 50000, options)
                }
            ]
        }, options);
    }
    async changeOwner(recipient, initial) {
        const options = this.ConnectionOptions.fill(initial);
        const contract = this.Contract.getWalletContract(options.account, options);
        if (!contract) throw new Error('Failed to create contract.');
        const tx = {
            from: options.account,
            to: options.account,
            data: contract.methods.changeOwner(recipient).encodeABI()
        };
        return this.Request.request({
            method: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__/* .EthereumMethodType */ .W8.ETH_SEND_TRANSACTION,
            params: [
                {
                    ...tx,
                    gas: await this.estimateTransaction(tx, 50000, options)
                }
            ]
        }, options);
    }
    async fund(proof, initial) {
        return this.Request.request({
            method: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__/* .EthereumMethodType */ .W8.MASK_FUND,
            params: [
                proof
            ]
        }, initial);
    }
    async deploy(owner, identifier, initial) {
        return this.Request.request({
            method: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__/* .EthereumMethodType */ .W8.MASK_DEPLOY,
            params: [
                owner,
                identifier
            ]
        }, initial);
    }
    async connect(initial) {
        return this.Request.request({
            method: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__/* .EthereumMethodType */ .W8.MASK_LOGIN,
            params: []
        }, initial);
    }
    async disconnect(initial) {
        await this.Request.request({
            method: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__/* .EthereumMethodType */ .W8.MASK_LOGOUT,
            params: []
        }, initial);
    }
    async switchChain(chainId, initial) {
        const options = this.ConnectionOptions.fill(initial);
        await _providers_index_js__WEBPACK_IMPORTED_MODULE_10__/* .Providers */ .C[options.providerType].switchChain(chainId);
    }
    async sendTransaction(transaction, initial) {
        const options = this.ConnectionOptions.fill(initial);
        // send a transaction which will add into the internal transaction list and start to watch it for confirmation
        const hash = await this.Request.request({
            method: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__/* .EthereumMethodType */ .W8.ETH_SEND_TRANSACTION,
            params: [
                new _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_11__/* .AccountTransaction */ .K(transaction).fill(options.overrides)
            ]
        }, options);
        return new Promise((resolve, reject)=>{
            if (!this.Transaction || !this.TransactionWatcher) reject(new Error('No context found.'));
            const onProgress = async (chainId, id, status, transaction)=>{
                if (status === _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_12__.TransactionStatusType.NOT_DEPEND) return;
                if (!transaction?.from) return;
                const transactions = await this.Transaction?.getTransactions?.(chainId, transaction.from);
                const currentTransaction = transactions?.find((x)=>{
                    const hashes = Object.keys(x.candidates);
                    return hashes.includes(hash) && hashes.includes(id);
                });
                if (currentTransaction) resolve(currentTransaction.indexId);
            };
            this.TransactionWatcher?.emitter.on('progress', onProgress);
        });
    }
    async confirmTransaction(hash, initial) {
        const options = this.ConnectionOptions.fill(initial);
        const times = 49;
        const interval = (0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_13__/* .getAverageBlockDelay */ .g)(options.chainId);
        for(let i = 0; i < times; i += 1){
            if (options.signal?.aborted) throw new Error(options.signal.reason);
            try {
                const receipt = await this.getTransactionReceipt(hash, options);
                if (!receipt) throw new Error('Not confirm yet.');
                // the transaction has been confirmed
                return receipt;
            } catch  {
                await (0,_masknet_kit__WEBPACK_IMPORTED_MODULE_1__/* .delay */ .gw)(interval);
                continue;
            }
        }
        // insufficient try times
        throw new Error('Not confirm yet');
    }
    replaceTransaction(hash, transaction, initial) {
        return this.Request.request({
            method: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__/* .EthereumMethodType */ .W8.MASK_REPLACE_TRANSACTION,
            params: [
                hash,
                transaction
            ]
        }, initial);
    }
    cancelTransaction(hash, transaction, initial) {
        return this.Request.request({
            method: _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_7__/* .EthereumMethodType */ .W8.MASK_REPLACE_TRANSACTION,
            params: [
                hash,
                {
                    ...transaction,
                    to: transaction.from,
                    data: '0x0',
                    value: '0x0'
                }
            ]
        }, initial);
    }
}


/***/ }),

/***/ 2685:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   T: () => (/* binding */ ConnectionOptionsAPI)
/* harmony export */ });
/* harmony import */ var _Base_apis_ConnectionOptionsAPI_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21871);
/* harmony import */ var _Web3StateAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39850);
/* harmony import */ var _OthersAPI_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(63877);



class ConnectionOptionsAPI extends _Base_apis_ConnectionOptionsAPI_js__WEBPACK_IMPORTED_MODULE_0__/* .ConnectionOptionsAPI_Base */ .G {
    Web3StateRef = _Web3StateAPI_js__WEBPACK_IMPORTED_MODULE_1__.Web3StateRef;
    Web3Others = new _OthersAPI_js__WEBPACK_IMPORTED_MODULE_2__/* .OthersAPI */ .i();
}


/***/ }),

/***/ 68070:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   X: () => (/* binding */ ConnectionOptionsReadonlyAPI)
/* harmony export */ });
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(88547);
/* harmony import */ var _Base_apis_ConnectionOptionsAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(21871);
/* harmony import */ var _OthersAPI_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(63877);



const EmptyRef = new _masknet_shared_base__WEBPACK_IMPORTED_MODULE_0__/* .ValueRefWithReady */ .td({});
class ConnectionOptionsReadonlyAPI extends _Base_apis_ConnectionOptionsAPI_js__WEBPACK_IMPORTED_MODULE_1__/* .ConnectionOptionsAPI_Base */ .G {
    Web3StateRef = EmptyRef;
    Web3Others = new _OthersAPI_js__WEBPACK_IMPORTED_MODULE_2__/* .OthersAPI */ .i();
}


/***/ }),

/***/ 3543:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  S: () => (/* binding */ ConnectionReadonlyAPI)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/head.js
var head = __webpack_require__(81755);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/omit.js + 1 modules
var omit = __webpack_require__(17711);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/toNumber.js + 1 modules
var toNumber = __webpack_require__(67626);
// EXTERNAL MODULE: ./node_modules/.pnpm/web3-utils@1.10.2/node_modules/web3-utils/lib/index.js
var lib = __webpack_require__(84976);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/types/index.ts
var types = __webpack_require__(24770);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/address.ts
var helpers_address = __webpack_require__(65327);
// EXTERNAL MODULE: ./node_modules/.pnpm/web3-eth-accounts@1.10.2/node_modules/web3-eth-accounts/lib/index.js
var web3_eth_accounts_lib = __webpack_require__(30699);
var web3_eth_accounts_lib_default = /*#__PURE__*/__webpack_require__.n(web3_eth_accounts_lib);
;// CONCATENATED MODULE: ./packages/web3-shared/evm/src/helpers/createAccount.ts

function createAccount() {
    const Accounts_ = (web3_eth_accounts_lib_default());
    const accounts = new Accounts_();
    return accounts.create();
}

// EXTERNAL MODULE: ./packages/web3-shared/evm/src/constants/constants.ts
var constants = __webpack_require__(33026);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/token.ts
var token = __webpack_require__(48289);
;// CONCATENATED MODULE: ./packages/web3-shared/evm/src/helpers/parseStringOrBytes32.ts

// parse a name or symbol from a token response
const BYTES32_REGEX = /^0x[\dA-Fa-f]{64}$/;
function parseStringOrBytes32(str, bytes32, defaultValue) {
    return str && str.length > 0 ? str : // need to check for proper bytes string and valid terminator
    bytes32 && BYTES32_REGEX.test(bytes32) && (0,lib.hexToBytes)(bytes32)[31] === 0 ? (0,lib.toAscii)(bytes32) : defaultValue;
}

// EXTERNAL MODULE: ./packages/web3-shared/evm/src/libs/AccountTransaction.ts
var AccountTransaction = __webpack_require__(17448);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/getTransactionStatusType.ts
var getTransactionStatusType = __webpack_require__(29530);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/number.ts
var number = __webpack_require__(29763);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/token.ts
var helpers_token = __webpack_require__(77199);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/isSameAddress.ts
var isSameAddress = __webpack_require__(74765);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/resolver.ts
var resolver = __webpack_require__(53007);
// EXTERNAL MODULE: ./packages/shared-base-ui/src/data/queryClient.ts
var queryClient = __webpack_require__(73401);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/RequestReadonlyAPI.ts
var RequestReadonlyAPI = __webpack_require__(64043);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/ContractReadonlyAPI.ts + 9 modules
var ContractReadonlyAPI = __webpack_require__(61871);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/ConnectionOptionsReadonlyAPI.ts
var ConnectionOptionsReadonlyAPI = __webpack_require__(68070);
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/fetchJSON.ts
var fetchJSON = __webpack_require__(11834);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/ResolverAPI.ts
var ResolverAPI = __webpack_require__(66979);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/apis/ConnectionReadonlyAPI.ts










const EMPTY_STRING = Promise.resolve('');
const ZERO = Promise.resolve(0);
class ConnectionReadonlyAPI {
    options;
    constructor(options){
        this.options = options;
        this.Contract = new ContractReadonlyAPI/* ContractReadonlyAPI */.M(this.options);
        this.Request = new RequestReadonlyAPI/* RequestReadonlyAPI */.c(this.options);
        this.ConnectionOptions = new ConnectionOptionsReadonlyAPI/* ConnectionOptionsReadonlyAPI */.X(this.options);
    }
    Request;
    Contract;
    ConnectionOptions;
    getWeb3(initial) {
        return this.Request.getWeb3(initial);
    }
    getWeb3Provider(initial) {
        return this.Request.getWeb3Provider(initial);
    }
    async connect(initial) {
        throw new Error('Method not implemented.');
    }
    async disconnect(initial) {
        throw new Error('Method not implemented.');
    }
    getWallets(initial) {
        return this.Request.request({
            method: types/* EthereumMethodType */.W8.MASK_WALLETS,
            params: []
        }, initial);
    }
    async addWallet(wallet, initial) {
        throw new Error('Method not implemented.');
    }
    async updateWallet(address, wallet, initial) {
        throw new Error('Method not implemented.');
    }
    async renameWallet(address, name, initial) {
        throw new Error('Method not implemented.');
    }
    async removeWallet(address, password, initial) {
        throw new Error('Method not implemented.');
    }
    async resetAllWallets(initial) {
        throw new Error('Method not implemented.');
    }
    async updateWallets(wallets, initial) {
        throw new Error('Method not implemented.');
    }
    async removeWallets(wallets, initial) {
        throw new Error('Method not implemented.');
    }
    async approveFungibleToken(address, recipient, amount, initial) {
        throw new Error('Method not implemented.');
    }
    async approveNonFungibleToken(address, recipient, tokenId, schema, initial) {
        throw new Error('Method not implemented.');
    }
    async approveAllNonFungibleTokens(address, recipient, approved, schema, initial) {
        throw new Error('Method not implemented.');
    }
    async transferFungibleToken(address, recipient, amount, memo, initial) {
        throw new Error('Method not implemented.');
    }
    async transferNonFungibleToken(address, tokenId, recipient, amount, schema, initial) {
        throw new Error('Method not implemented.');
    }
    async getGasPrice(initial) {
        return this.Request.request({
            method: types/* EthereumMethodType */.W8.ETH_GAS_PRICE,
            params: []
        }, initial);
    }
    async getAddressType(address, initial) {
        if (!(0,helpers_address/* isValidAddress */.At)(address)) return;
        const code = await this.getCode(address, initial);
        return code === '0x' ? types/* AddressType */.DL.ExternalOwned : types/* AddressType */.DL.Contract;
    }
    async getSchemaType(address, initial) {
        const ERC165_INTERFACE_ID = '0x01ffc9a7';
        const EIP5516_INTERFACE_ID = '0x8314f22b';
        const EIP5192_INTERFACE_ID = '0xb45a3c0e';
        const ERC721_INTERFACE_ID = '0x80ac58cd';
        const ERC1155_INTERFACE_ID = '0xd9b67a26';
        try {
            const options = this.ConnectionOptions.fill(initial);
            const erc165Contract = this.Contract.getERC165Contract(address, options);
            const [isERC165, isERC721] = await Promise.all([
                erc165Contract?.methods.supportsInterface(ERC165_INTERFACE_ID).call(),
                erc165Contract?.methods.supportsInterface(ERC721_INTERFACE_ID).call()
            ]);
            if (isERC165 && isERC721) return types/* SchemaType */.XQ.ERC721;
            const isERC1155 = await erc165Contract?.methods.supportsInterface(ERC1155_INTERFACE_ID).call();
            if (isERC165 && isERC1155) return types/* SchemaType */.XQ.ERC1155;
            const [isEIP5516, isEIP5192] = await Promise.all([
                erc165Contract?.methods.supportsInterface(EIP5516_INTERFACE_ID).call(),
                erc165Contract?.methods.supportsInterface(EIP5192_INTERFACE_ID).call()
            ]);
            if (isEIP5516 || isEIP5192) return types/* SchemaType */.XQ.SBT;
            const isERC20 = await this.getCode(address, options);
            if (!(0,helpers_address/* isEmptyHex */.w2)(isERC20)) return types/* SchemaType */.XQ.ERC20;
            return;
        } catch  {
            return;
        }
    }
    async getNonFungibleToken(address, tokenId, schema, initial) {
        const options = this.ConnectionOptions.fill(initial);
        const actualSchema = schema ?? await this.getSchemaType(address, options);
        const allSettled = await Promise.allSettled([
            this.getNonFungibleTokenMetadata(address, tokenId, schema, options),
            this.getNonFungibleTokenContract(address, schema, options)
        ]);
        const [metadata, contract] = allSettled.map((x)=>x.status === 'fulfilled' ? x.value : undefined);
        let ownerId;
        if (actualSchema !== types/* SchemaType */.XQ.ERC1155) {
            const contract = this.Contract.getERC721Contract(address, options);
            try {
                ownerId = await contract?.methods.ownerOf(tokenId).call();
            } catch  {}
        } else if (options.account) {
            const contract = this.Contract.getERC1155Contract(address, options);
            try {
                const balance = await contract?.methods.balanceOf(options.account, tokenId).call();
                ownerId = balance && (0,number/* isGreaterThan */.T1)(balance, '0') ? options.account : undefined;
            } catch  {}
        }
        return (0,helpers_token/* createNonFungibleToken */.RV)(options.chainId, address, actualSchema ?? types/* SchemaType */.XQ.ERC721, tokenId, ownerId, metadata, contract);
    }
    async getNonFungibleTokenOwner(address, tokenId, schema, initial) {
        const options = this.ConnectionOptions.fill(initial);
        const actualSchema = schema ?? await this.getSchemaType(address, options);
        // ERC1155
        if (actualSchema === types/* SchemaType */.XQ.ERC1155) return '';
        // CRYPTOPUNKS
        if ((0,helpers_address/* isCryptoPunksContractAddress */.yi)(address)) {
            const cryptoPunksContract = this.Contract.getCryptoPunksContract(address, options);
            return await cryptoPunksContract?.methods.punkIndexToAddress(tokenId).call() ?? '';
        }
        // ERC721
        const contract = this.Contract.getERC721Contract(address, options);
        return await contract?.methods.ownerOf(tokenId).call() ?? '';
    }
    async getNonFungibleTokenOwnership(address, tokenId, owner, schema, initial) {
        const options = this.ConnectionOptions.fill(initial);
        const actualSchema = schema ?? await this.getSchemaType(address, options);
        // ERC1155
        if (actualSchema === types/* SchemaType */.XQ.ERC1155) {
            const contract = this.Contract.getERC1155Contract(address, options);
            // the owner has at least 1 token
            return (0,number/* isGreaterThan */.T1)(await contract?.methods.balanceOf(owner, tokenId).call() ?? 0, 0);
        }
        // ERC721
        const contract = this.Contract.getERC721Contract(address, options);
        return (0,isSameAddress/* isSameAddress */.W)(await contract?.methods.ownerOf(tokenId).call(), owner);
    }
    async getNonFungibleTokenMetadata(address, tokenId, schema, initial) {
        const options = this.ConnectionOptions.fill(initial);
        const processURI = (uri)=>{
            // e.g,
            // address: 0x495f947276749ce646f68ac8c248420045cb7b5e
            // token id: 33445046430196205871873533938903624085962860434195770982901962545689408831489
            if (uri.startsWith('https://api.opensea.io/') && tokenId) return uri.replace('0x{id}', tokenId);
            // add cors header
            return (0,resolver/* resolveCrossOriginURL */.nX)((0,resolver/* resolveIPFS_URL */.mg)(uri));
        };
        const actualSchema = schema ?? await this.getSchemaType(address, options);
        // ERC1155
        if (actualSchema === types/* SchemaType */.XQ.ERC1155) {
            const contract = this.Contract.getERC1155Contract(address, options);
            const uri = await contract?.methods.uri(tokenId ?? '').call();
            if (!uri) throw new Error('Failed to read metadata uri.');
            const response = await (0,fetchJSON/* fetchJSON */.ZV)(processURI(uri));
            return (0,helpers_token/* createNonFungibleTokenMetadata */.BD)(options.chainId, response.name, tokenId ?? '', '', response.description, undefined, (0,resolver/* resolveIPFS_URL */.mg)(response.image), (0,resolver/* resolveIPFS_URL */.mg)(response.image));
        }
        // ERC721
        const contract = this.Contract.getERC721Contract(address, options);
        const uri = await contract?.methods.tokenURI(tokenId ?? '').call();
        if (!uri) throw new Error('Failed to read metadata uri.');
        const response = await (0,fetchJSON/* fetchJSON */.ZV)(processURI(uri));
        return (0,helpers_token/* createNonFungibleTokenMetadata */.BD)(options.chainId, response.name, tokenId ?? '', '', response.description, undefined, (0,resolver/* resolveIPFS_URL */.mg)(response.image), (0,resolver/* resolveIPFS_URL */.mg)(response.image));
    }
    async getNonFungibleTokenContract(address, schema, initial) {
        const options = this.ConnectionOptions.fill(initial);
        const actualSchema = schema ?? await this.getSchemaType(address, options);
        // ERC1155
        if (actualSchema === types/* SchemaType */.XQ.ERC1155) {
            const contractERC721 = this.Contract.getERC721Contract(address, options);
            const results = await Promise.allSettled([
                contractERC721?.methods.name().call() ?? EMPTY_STRING,
                contractERC721?.methods.symbol().call() ?? EMPTY_STRING
            ]);
            const [name, symbol] = results.map((result)=>result.status === 'fulfilled' ? result.value : '');
            return (0,helpers_token/* createNonFungibleTokenContract */.Xi)(options.chainId, types/* SchemaType */.XQ.ERC1155, address, name ?? 'Unknown Token', symbol ?? 'UNKNOWN');
        }
        // ERC721
        const contract = this.Contract.getERC721Contract(address, options);
        const results = await Promise.allSettled([
            contract?.methods.name().call() ?? EMPTY_STRING,
            contract?.methods.symbol().call() ?? EMPTY_STRING
        ]);
        const [name, symbol] = results.map((result)=>result.status === 'fulfilled' ? result.value : '');
        return (0,helpers_token/* createNonFungibleTokenContract */.Xi)(options.chainId, types/* SchemaType */.XQ.ERC721, address, name ?? 'Unknown Token', symbol ?? 'UNKNOWN');
    }
    async getNonFungibleTokenCollection(address, schema, initial) {
        const options = this.ConnectionOptions.fill(initial);
        const actualSchema = schema ?? await this.getSchemaType(address, options);
        // ERC1155
        if (actualSchema === types/* SchemaType */.XQ.ERC1155) throw new Error('Not implemented yet.');
        // ERC721
        const contract = this.Contract.getERC721Contract(address, options);
        const results = await Promise.allSettled([
            contract?.methods.name().call() ?? EMPTY_STRING
        ]);
        const [name] = results.map((result)=>result.status === 'fulfilled' ? result.value : '');
        return (0,helpers_token/* createNonFungibleTokenCollection */.GN)(options.chainId, address, name ?? 'Unknown Token', '');
    }
    createAccount(initial) {
        const options = this.ConnectionOptions.fill(initial);
        const account = createAccount();
        return {
            account: account.address,
            chainId: options.chainId,
            privateKey: account.privateKey
        };
    }
    async switchChain(chainId, initial) {
        throw new Error('Method not implemented.');
    }
    async getNativeTokenBalance(initial) {
        const options = this.ConnectionOptions.fill(initial);
        if (!(0,helpers_address/* isValidAddress */.At)(options.account)) return '0';
        return this.getBalance(options.account, options);
    }
    async getFungibleTokenBalance(address, schema, initial) {
        const options = this.ConnectionOptions.fill(initial);
        // Native
        if (!address || (0,helpers_address/* isNativeTokenAddress */.qw)(address)) return this.getNativeTokenBalance(options);
        // ERC20
        const contract = this.Contract.getERC20Contract(address, options);
        return await contract?.methods.balanceOf(options.account).call() ?? '0';
    }
    async getNonFungibleTokenBalance(address, tokenId, schema, initial) {
        const options = this.ConnectionOptions.fill(initial);
        const actualSchema = schema ?? await this.getSchemaType(address, options);
        // ERC1155
        if (actualSchema === types/* SchemaType */.XQ.ERC1155) {
            const contract = this.Contract.getERC1155Contract(address, options);
            return contract?.methods?.balanceOf(options.account, tokenId ?? '').call() ?? '0';
        }
        // ERC721
        const contract = this.Contract.getERC721Contract(address, options);
        return contract?.methods.balanceOf(options.account).call() ?? '0';
    }
    async getFungibleTokensBalance(listOfAddress, initial) {
        if (!listOfAddress.length) return {};
        const options = this.ConnectionOptions.fill(initial);
        const NATIVE_TOKEN_ADDRESS = (0,constants/* getTokenConstant */._x)(options.chainId, 'NATIVE_TOKEN_ADDRESS');
        const BALANCE_CHECKER_ADDRESS = (0,constants/* getEthereumConstant */.wB)(options.chainId, 'BALANCE_CHECKER_ADDRESS');
        const entities = [];
        if (listOfAddress.some(helpers_address/* isNativeTokenAddress */.qw)) {
            entities.push([
                NATIVE_TOKEN_ADDRESS ?? '',
                await this.getBalance(options.account, options)
            ]);
        }
        const listOfNonNativeAddress = listOfAddress.filter((x)=>!(0,helpers_address/* isNativeTokenAddress */.qw)(x));
        if (listOfNonNativeAddress.length) {
            const contract = this.Contract.getBalanceCheckerContract(BALANCE_CHECKER_ADDRESS ?? '', options);
            const balances = await contract?.methods.balances([
                options.account
            ], listOfNonNativeAddress).call({
                // cannot check the sender's balance in the same contract
                from: undefined,
                chainId: (0,lib.numberToHex)(options.chainId)
            });
            listOfNonNativeAddress.forEach((x, i)=>{
                entities.push([
                    x,
                    balances?.[i] ?? '0'
                ]);
            });
        }
        return Object.fromEntries(entities);
    }
    async getNonFungibleTokensBalance(listOfAddress, initial) {
        if (!listOfAddress.length) return {};
        const options = this.ConnectionOptions.fill(initial);
        const BALANCE_CHECKER_ADDRESS = (0,constants/* getEthereumConstant */.wB)(options.chainId, 'BALANCE_CHECKER_ADDRESS');
        const contract = this.Contract.getBalanceCheckerContract(BALANCE_CHECKER_ADDRESS ?? '', options);
        const result = await contract?.methods.balances([
            options.account
        ], listOfAddress).call({
            // cannot check the sender's balance in the same contract
            from: undefined,
            chainId: (0,lib.numberToHex)(options.chainId)
        });
        if (result?.length !== listOfAddress.length) return {};
        return Object.fromEntries(listOfAddress.map((x, i)=>[
                x,
                result[i]
            ]));
    }
    getNativeToken(initial) {
        const options = this.ConnectionOptions.fill(initial);
        const token = ResolverAPI/* ChainResolver */.iv.nativeCurrency(options.chainId);
        if (!token) throw new Error('Failed to create native token.');
        return Promise.resolve(token);
    }
    async getFungibleToken(address, initial) {
        const options = this.ConnectionOptions.fill(initial);
        // Native
        if (!address || (0,helpers_address/* isNativeTokenAddress */.qw)(address)) return this.getNativeToken(options);
        // ERC20
        const contract = this.Contract.getERC20Contract(address, options);
        const bytes32Contract = this.Contract.getERC20Bytes32Contract(address, options);
        const results = await queryClient/* queryClient */.E.fetchQuery({
            staleTime: 600_000,
            queryKey: [
                'fungibleToken',
                options.chainId,
                address
            ],
            queryFn: async ()=>{
                return Promise.allSettled([
                    contract?.methods.name().call() ?? EMPTY_STRING,
                    bytes32Contract?.methods.name().call() ?? EMPTY_STRING,
                    contract?.methods.symbol().call() ?? EMPTY_STRING,
                    bytes32Contract?.methods.symbol().call() ?? EMPTY_STRING,
                    contract?.methods.decimals().call() ?? ZERO
                ]);
            }
        });
        const [name, nameBytes32, symbol, symbolBytes32, decimals] = results.map((result)=>result.status === 'fulfilled' ? result.value : '');
        return (0,token/* createERC20Token */.wY)(options.chainId, address, parseStringOrBytes32(name, nameBytes32, 'Unknown Token'), parseStringOrBytes32(symbol, symbolBytes32, 'UNKNOWN'), typeof decimals === 'string' ? Number.parseInt(decimals ? decimals : '0', 10) : decimals);
    }
    async getAccount(initial) {
        const options = this.ConnectionOptions.fill(initial);
        const accounts = await this.Request.request({
            method: types/* EthereumMethodType */.W8.ETH_ACCOUNTS,
            params: []
        }, options);
        return (0,head/* default */.Z)(accounts) ?? '';
    }
    async getChainId(initial) {
        const options = this.ConnectionOptions.fill(initial);
        const chainId = await this.Request.request({
            method: types/* EthereumMethodType */.W8.ETH_CHAIN_ID,
            params: []
        }, options);
        return Number.parseInt(chainId, 16);
    }
    getBlock(noOrId, initial) {
        return this.Request.request({
            method: types/* EthereumMethodType */.W8.ETH_GET_BLOCK_BY_NUMBER,
            params: [
                (0,lib.toHex)(noOrId),
                false
            ]
        }, initial);
    }
    getBlockNumber(initial) {
        return this.Request.request({
            method: types/* EthereumMethodType */.W8.ETH_BLOCK_NUMBER,
            params: []
        }, initial);
    }
    async getBlockTimestamp(initial) {
        const options = this.ConnectionOptions.fill(initial);
        const blockNumber = await this.getBlockNumber(options);
        const block = await this.getBlock(blockNumber, options);
        return Number.parseInt(block.timestamp, 16);
    }
    getBalance(address, initial) {
        return this.Request.request({
            method: types/* EthereumMethodType */.W8.ETH_GET_BALANCE,
            params: [
                address,
                'latest'
            ]
        }, initial);
    }
    getCode(address, initial) {
        return this.Request.request({
            method: types/* EthereumMethodType */.W8.ETH_GET_CODE,
            params: [
                address,
                'latest'
            ]
        }, initial);
    }
    async getTransaction(hash, initial) {
        return this.Request.request({
            method: types/* EthereumMethodType */.W8.ETH_GET_TRANSACTION_BY_HASH,
            params: [
                hash
            ]
        }, initial);
    }
    async estimateTransaction(transaction, fallback = 21000, initial) {
        try {
            const options = this.ConnectionOptions.fill(initial);
            return await this.Request.request({
                method: types/* EthereumMethodType */.W8.ETH_ESTIMATE_GAS,
                params: [
                    new AccountTransaction/* AccountTransaction */.K({
                        from: options.account,
                        chainId: options.chainId,
                        ...transaction
                    }).fill((0,omit/* default */.Z)(options.overrides, [
                        'gas',
                        'gasPrice',
                        'maxPriorityFeePerGas',
                        'maxFeePerGas'
                    ]))
                ]
            }, options);
        } catch  {
            return (0,lib.toHex)(fallback);
        }
    }
    getTransactionReceipt(hash, initial) {
        return this.Request.request({
            method: types/* EthereumMethodType */.W8.ETH_GET_TRANSACTION_RECEIPT,
            params: [
                hash
            ]
        }, initial);
    }
    async getTransactionStatus(hash, initial) {
        const receipt = await this.getTransactionReceipt(hash, initial);
        return (0,getTransactionStatusType/* getTransactionStatusType */.j)(receipt);
    }
    async getTransactionNonce(address, initial) {
        const nonce = await this.Request.request({
            method: types/* EthereumMethodType */.W8.ETH_GET_TRANSACTION_COUNT,
            params: [
                address,
                'latest'
            ]
        }, initial);
        return (0,toNumber/* default */.Z)(nonce);
    }
    signMessage(type, message, initial) {
        throw new Error('Method not implemented.');
    }
    async verifyMessage(type, message, signature, initial) {
        throw new Error('Method not implemented.');
    }
    async signTransaction(transaction, initial) {
        throw new Error('Method not implemented.');
    }
    signTransactions(transactions, initial) {
        throw new Error('Method not implemented.');
    }
    supportedChainIds(initial) {
        throw new Error('Method not implemented.');
    }
    supportedEntryPoints(initial) {
        throw new Error('Method not implemented.');
    }
    async callUserOperation(owner, operation, initial) {
        throw new Error('Method not implemented.');
    }
    async sendUserOperation(owner, operation, initial) {
        throw new Error('Method not implemented.');
    }
    async transfer(recipient, amount, initial) {
        throw new Error('Method not implemented.');
    }
    async changeOwner(recipient, initial) {
        throw new Error('Method not implemented.');
    }
    async fund(proof, initial) {
        throw new Error('Method not implemented.');
    }
    async deploy(owner, identifier, initial) {
        throw new Error('Method not implemented.');
    }
    callTransaction(transaction, initial) {
        const options = this.ConnectionOptions.fill(initial);
        return this.Request.request({
            method: types/* EthereumMethodType */.W8.ETH_CALL,
            params: [
                new AccountTransaction/* AccountTransaction */.K(transaction).fill(options.overrides),
                'latest'
            ]
        }, options);
    }
    async sendTransaction(transaction, initial) {
        throw new Error('Method not implemented.');
    }
    sendSignedTransaction(signature, initial) {
        return this.Request.request({
            method: types/* EthereumMethodType */.W8.ETH_SEND_RAW_TRANSACTION,
            params: [
                signature
            ]
        }, initial);
    }
    async confirmTransaction(hash, initial) {
        throw new Error('Method not implemented.');
    }
    replaceTransaction(hash, transaction, initial) {
        throw new Error('Method not implemented.');
    }
    cancelTransaction(hash, transaction, initial) {
        throw new Error('Method not implemented.');
    }
}


/***/ }),

/***/ 67433:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   J: () => (/* binding */ ContractAPI)
/* harmony export */ });
/* harmony import */ var _RequestAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(81254);
/* harmony import */ var _ContractReadonlyAPI_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61871);


class ContractAPI extends _ContractReadonlyAPI_js__WEBPACK_IMPORTED_MODULE_0__/* .ContractReadonlyAPI */ .M {
    Request = new _RequestAPI_js__WEBPACK_IMPORTED_MODULE_1__/* .RequestAPI */ .U(this.options);
}


/***/ }),

/***/ 61871:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  M: () => (/* binding */ ContractReadonlyAPI)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/omitBy.js + 1 modules
var omitBy = __webpack_require__(72802);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isUndefined.js
var isUndefined = __webpack_require__(81770);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/createContract.ts
var createContract = __webpack_require__(95739);
// EXTERNAL MODULE: ./packages/web3-contracts/abis/AirdropV2.json
var AirdropV2 = __webpack_require__(88592);
;// CONCATENATED MODULE: ./packages/web3-contracts/abis/BalanceChecker.json
const BalanceChecker_namespaceObject = JSON.parse('[{"stateMutability":"payable","type":"fallback"},{"inputs":[{"internalType":"address[]","name":"users","type":"address[]"},{"internalType":"address[]","name":"tokens","type":"address[]"}],"name":"balances","outputs":[{"internalType":"uint256[]","name":"","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"},{"internalType":"address","name":"token","type":"address"}],"name":"tokenBalance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"stateMutability":"payable","type":"receive"}]');
// EXTERNAL MODULE: ./packages/web3-contracts/abis/ERC20.json
var ERC20 = __webpack_require__(95528);
;// CONCATENATED MODULE: ./packages/web3-contracts/abis/ERC20Bytes32.json
const ERC20Bytes32_namespaceObject = JSON.parse('[{"constant":true,"inputs":[],"name":"name","outputs":[{"name":"","type":"bytes32"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"symbol","outputs":[{"name":"","type":"bytes32"}],"payable":false,"stateMutability":"view","type":"function"}]');
;// CONCATENATED MODULE: ./packages/web3-contracts/abis/ERC165.json
const ERC165_namespaceObject = JSON.parse('[{"constant":true,"inputs":[{"name":"interfaceID","type":"bytes4"}],"name":"supportsInterface","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"}]');
// EXTERNAL MODULE: ./packages/web3-contracts/abis/ERC721.json
var ERC721 = __webpack_require__(78770);
;// CONCATENATED MODULE: ./packages/web3-contracts/abis/ERC1155.json
const ERC1155_namespaceObject = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":false,"internalType":"bool","name":"approved","type":"bool"}],"name":"ApprovalForAll","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256[]","name":"ids","type":"uint256[]"},{"indexed":false,"internalType":"uint256[]","name":"values","type":"uint256[]"}],"name":"TransferBatch","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"id","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"TransferSingle","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"string","name":"value","type":"string"},{"indexed":true,"internalType":"uint256","name":"id","type":"uint256"}],"name":"URI","type":"event"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"id","type":"uint256"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address[]","name":"accounts","type":"address[]"},{"internalType":"uint256[]","name":"ids","type":"uint256[]"}],"name":"balanceOfBatch","outputs":[{"internalType":"uint256[]","name":"","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"address","name":"operator","type":"address"}],"name":"isApprovedForAll","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256[]","name":"ids","type":"uint256[]"},{"internalType":"uint256[]","name":"amounts","type":"uint256[]"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"safeBatchTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"id","type":"uint256"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"safeTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"bool","name":"approved","type":"bool"}],"name":"setApprovalForAll","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"id","type":"uint256"}],"name":"uri","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"}]');
;// CONCATENATED MODULE: ./packages/web3-contracts/abis/CryptoPunks.json
const CryptoPunks_namespaceObject = JSON.parse('[{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"punkIndexToAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"}]');
// EXTERNAL MODULE: ./packages/web3-contracts/abis/Wallet.json
var Wallet = __webpack_require__(49734);
;// CONCATENATED MODULE: ./packages/web3-contracts/abis/Multicall.json
const Multicall_namespaceObject = JSON.parse('[{"inputs":[],"name":"getCurrentBlockTimestamp","outputs":[{"internalType":"uint256","name":"timestamp","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"addr","type":"address"}],"name":"getEthBalance","outputs":[{"internalType":"uint256","name":"balance","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"target","type":"address"},{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"bytes","name":"callData","type":"bytes"}],"internalType":"struct UniswapInterfaceMulticall.Call[]","name":"calls","type":"tuple[]"}],"name":"multicall","outputs":[{"internalType":"uint256","name":"blockNumber","type":"uint256"},{"components":[{"internalType":"bool","name":"success","type":"bool"},{"internalType":"uint256","name":"gasUsed","type":"uint256"},{"internalType":"bytes","name":"returnData","type":"bytes"}],"internalType":"struct UniswapInterfaceMulticall.Result[]","name":"returnData","type":"tuple[]"}],"stateMutability":"nonpayable","type":"function"}]');
// EXTERNAL MODULE: ./packages/web3-contracts/abis/RouterV2.json
var RouterV2 = __webpack_require__(68101);
// EXTERNAL MODULE: ./packages/web3-contracts/abis/SwapRouter.json
var SwapRouter = __webpack_require__(5247);
// EXTERNAL MODULE: ./packages/web3-contracts/abis/WETH.json
var WETH = __webpack_require__(54369);
;// CONCATENATED MODULE: ./packages/web3-contracts/abis/Pair.json
const Pair_namespaceObject = JSON.parse('[{"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount0","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amount1","type":"uint256"},{"indexed":true,"internalType":"address","name":"to","type":"address"}],"name":"Burn","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount0","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amount1","type":"uint256"}],"name":"Mint","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount0In","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amount1In","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amount0Out","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amount1Out","type":"uint256"},{"indexed":true,"internalType":"address","name":"to","type":"address"}],"name":"Swap","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint112","name":"reserve0","type":"uint112"},{"indexed":false,"internalType":"uint112","name":"reserve1","type":"uint112"}],"name":"Sync","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"constant":true,"inputs":[],"name":"DOMAIN_SEPARATOR","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"MINIMUM_LIQUIDITY","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"PERMIT_TYPEHASH","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"to","type":"address"}],"name":"burn","outputs":[{"internalType":"uint256","name":"amount0","type":"uint256"},{"internalType":"uint256","name":"amount1","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"factory","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"getReserves","outputs":[{"internalType":"uint112","name":"_reserve0","type":"uint112"},{"internalType":"uint112","name":"_reserve1","type":"uint112"},{"internalType":"uint32","name":"_blockTimestampLast","type":"uint32"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"_token0","type":"address"},{"internalType":"address","name":"_token1","type":"address"}],"name":"initialize","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"kLast","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"to","type":"address"}],"name":"mint","outputs":[{"internalType":"uint256","name":"liquidity","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"nonces","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"permit","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"price0CumulativeLast","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"price1CumulativeLast","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"to","type":"address"}],"name":"skim","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"uint256","name":"amount0Out","type":"uint256"},{"internalType":"uint256","name":"amount1Out","type":"uint256"},{"internalType":"address","name":"to","type":"address"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"swap","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"sync","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"token0","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"token1","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"}]');
;// CONCATENATED MODULE: ./packages/web3-contracts/abis/Quoter.json
const Quoter_namespaceObject = JSON.parse('[{"inputs":[{"internalType":"address","name":"_factory","type":"address"},{"internalType":"address","name":"_WETH9","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"WETH9","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"factory","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"path","type":"bytes"},{"internalType":"uint256","name":"amountIn","type":"uint256"}],"name":"quoteExactInput","outputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"tokenIn","type":"address"},{"internalType":"address","name":"tokenOut","type":"address"},{"internalType":"uint24","name":"fee","type":"uint24"},{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint160","name":"sqrtPriceLimitX96","type":"uint160"}],"name":"quoteExactInputSingle","outputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes","name":"path","type":"bytes"},{"internalType":"uint256","name":"amountOut","type":"uint256"}],"name":"quoteExactOutput","outputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"tokenIn","type":"address"},{"internalType":"address","name":"tokenOut","type":"address"},{"internalType":"uint24","name":"fee","type":"uint24"},{"internalType":"uint256","name":"amountOut","type":"uint256"},{"internalType":"uint160","name":"sqrtPriceLimitX96","type":"uint160"}],"name":"quoteExactOutputSingle","outputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"int256","name":"amount0Delta","type":"int256"},{"internalType":"int256","name":"amount1Delta","type":"int256"},{"internalType":"bytes","name":"path","type":"bytes"}],"name":"uniswapV3SwapCallback","outputs":[],"stateMutability":"view","type":"function"}]');
;// CONCATENATED MODULE: ./packages/web3-contracts/abis/PoolStateV3.json
const PoolStateV3_namespaceObject = JSON.parse('[{"inputs":[],"name":"feeGrowthGlobal0X128","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"feeGrowthGlobal1X128","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"liquidity","outputs":[{"internalType":"uint128","name":"","type":"uint128"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"index","type":"uint256"}],"name":"observations","outputs":[{"internalType":"uint32","name":"blockTimestamp","type":"uint32"},{"internalType":"int56","name":"tickCumulative","type":"int56"},{"internalType":"uint160","name":"secondsPerLiquidityCumulativeX128","type":"uint160"},{"internalType":"bool","name":"initialized","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"key","type":"bytes32"}],"name":"positions","outputs":[{"internalType":"uint128","name":"_liquidity","type":"uint128"},{"internalType":"uint256","name":"feeGrowthInside0LastX128","type":"uint256"},{"internalType":"uint256","name":"feeGrowthInside1LastX128","type":"uint256"},{"internalType":"uint128","name":"tokensOwed0","type":"uint128"},{"internalType":"uint128","name":"tokensOwed1","type":"uint128"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"protocolFees","outputs":[{"internalType":"uint128","name":"token0","type":"uint128"},{"internalType":"uint128","name":"token1","type":"uint128"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"slot0","outputs":[{"internalType":"uint160","name":"sqrtPriceX96","type":"uint160"},{"internalType":"int24","name":"tick","type":"int24"},{"internalType":"uint16","name":"observationIndex","type":"uint16"},{"internalType":"uint16","name":"observationCardinality","type":"uint16"},{"internalType":"uint16","name":"observationCardinalityNext","type":"uint16"},{"internalType":"uint8","name":"feeProtocol","type":"uint8"},{"internalType":"bool","name":"unlocked","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"int16","name":"wordPosition","type":"int16"}],"name":"tickBitmap","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"int24","name":"tick","type":"int24"}],"name":"ticks","outputs":[{"internalType":"uint128","name":"liquidityGross","type":"uint128"},{"internalType":"int128","name":"liquidityNet","type":"int128"},{"internalType":"uint256","name":"feeGrowthOutside0X128","type":"uint256"},{"internalType":"uint256","name":"feeGrowthOutside1X128","type":"uint256"},{"internalType":"int56","name":"tickCumulativeOutside","type":"int56"},{"internalType":"uint160","name":"secondsPerLiquidityOutsideX128","type":"uint160"},{"internalType":"uint32","name":"secondsOutside","type":"uint32"},{"internalType":"bool","name":"initialized","type":"bool"}],"stateMutability":"view","type":"function"}]');
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/RequestReadonlyAPI.ts
var RequestReadonlyAPI = __webpack_require__(64043);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/apis/ContractReadonlyAPI.ts



















class ContractReadonlyAPI {
    options;
    constructor(options){
        this.options = options;
        this.Request = new RequestReadonlyAPI/* RequestReadonlyAPI */.c(options);
    }
    Request;
    getWeb3Contract(address, ABI, initial) {
        const web3 = this.Request.getWeb3(initial);
        const options = (0,omitBy/* default */.Z)({
            from: initial?.overrides?.from ?? initial?.account
        }, isUndefined/* default */.Z);
        return (0,createContract/* createContract */.O)(web3, address, ABI, options);
    }
    getERC20Contract(address, initial) {
        return this.getWeb3Contract(address, ERC20, initial);
    }
    getERC20Bytes32Contract(address, initial) {
        return this.getWeb3Contract(address, ERC20Bytes32_namespaceObject, initial);
    }
    getERC721Contract(address, initial) {
        return this.getWeb3Contract(address, ERC721, initial);
    }
    getERC1155Contract(address, initial) {
        return this.getWeb3Contract(address, ERC1155_namespaceObject, initial);
    }
    getERC165Contract(address, initial) {
        return this.getWeb3Contract(address, ERC165_namespaceObject, initial);
    }
    getCryptoPunksContract(address, initial) {
        return this.getWeb3Contract(address, CryptoPunks_namespaceObject, initial);
    }
    getBalanceCheckerContract(address, initial) {
        return this.getWeb3Contract(address, BalanceChecker_namespaceObject, initial);
    }
    getWalletContract(address, initial) {
        return this.getWeb3Contract(address, Wallet, initial);
    }
    getMulticallContract(address, initial) {
        return this.getWeb3Contract(address, Multicall_namespaceObject, initial);
    }
    getAirdropV2Contract(address, initial) {
        return this.getWeb3Contract(address, AirdropV2, initial);
    }
    getPairContract(address, initial) {
        return this.getWeb3Contract(address, Pair_namespaceObject, initial);
    }
    getRouterV2Contract(address, initial) {
        return this.getWeb3Contract(address, RouterV2, initial);
    }
    getSwapRouterContract(address, initial) {
        return this.getWeb3Contract(address, SwapRouter, initial);
    }
    getWETHContract(address, initial) {
        return this.getWeb3Contract(address, WETH, initial);
    }
    getQuoterContract(address, initial) {
        return this.getWeb3Contract(address, Quoter_namespaceObject, initial);
    }
    getPoolStateV3(address, initial) {
        return this.getWeb3Contract(address, PoolStateV3_namespaceObject, initial);
    }
}


/***/ }),

/***/ 60300:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   K: () => (/* binding */ HubAPI)
/* harmony export */ });
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(92560);
/* harmony import */ var _HubBaseAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(81654);
/* harmony import */ var _HubFungibleAPI_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(32506);
/* harmony import */ var _HubNonFungibleAPI_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(85407);




class HubAPI {
    create(initial) {
        return (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_0__/* .mixin */ .j)(new _HubBaseAPI_js__WEBPACK_IMPORTED_MODULE_1__/* .HubBaseAPI */ .f(initial), new _HubFungibleAPI_js__WEBPACK_IMPORTED_MODULE_2__/* .HubFungibleAPI */ .K(initial), new _HubNonFungibleAPI_js__WEBPACK_IMPORTED_MODULE_3__/* .HubNonFungibleAPI */ .D(initial));
    }
}


/***/ }),

/***/ 81654:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  f: () => (/* binding */ HubBaseAPI)
});

// EXTERNAL MODULE: ./packages/shared-base/src/Pageable/index.ts
var Pageable = __webpack_require__(38645);
// EXTERNAL MODULE: ./packages/shared-base/src/constants.ts
var constants = __webpack_require__(52033);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/attemptUntil.ts
var attemptUntil = __webpack_require__(92358);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/types/index.ts
var types = __webpack_require__(24770);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/ResolverAPI.ts
var ResolverAPI = __webpack_require__(66979);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Base/apis/HubBaseAPI.ts
var apis_HubBaseAPI = __webpack_require__(75583);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/nth.js + 1 modules
var nth = __webpack_require__(38337);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/specs/index.ts
var specs = __webpack_require__(62649);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/number.ts
var number = __webpack_require__(29763);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/ConnectionReadonlyAPI.ts + 2 modules
var ConnectionReadonlyAPI = __webpack_require__(3543);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/apis/GasOptionAPI.ts




class GasOptionAPI {
    static HISTORICAL_BLOCKS = 4;
    Web3 = new ConnectionReadonlyAPI/* ConnectionReadonlyAPI */.S();
    avg(arr) {
        const sum = arr.reduce((a, v)=>a + v);
        return Math.round(sum / arr.length);
    }
    formatFeeHistory(result) {
        let index = 0;
        const blockNumber = Number(result.oldestBlock);
        const blocks = [];
        while(index < GasOptionAPI.HISTORICAL_BLOCKS){
            blocks.push({
                number: blockNumber + index,
                baseFeePerGas: Number.parseInt((0,nth/* default */.Z)(result.baseFeePerGas, index) ?? '0', 16),
                gasUsedRatio: (0,nth/* default */.Z)(result.gasUsedRatio, index) || 0,
                priorityFeePerGas: (0,nth/* default */.Z)(result.reward, index)?.map((x)=>Number.parseInt(x, 16)) ?? Array.from({
                    length: 3
                }).fill(0)
            });
            index += 1;
        }
        return blocks;
    }
    async getGasOptionsForEIP1559(chainId) {
        const history = await this.Web3.getWeb3({
            chainId
        }).eth.getFeeHistory(GasOptionAPI.HISTORICAL_BLOCKS, 'pending', [
            25,
            50,
            75
        ]);
        const blocks = this.formatFeeHistory(history);
        const slow = this.avg(blocks.map((b)=>b.priorityFeePerGas[0]));
        const normal = this.avg(blocks.map((b)=>b.priorityFeePerGas[1]));
        const fast = this.avg(blocks.map((b)=>b.priorityFeePerGas[2]));
        // get the base fee per gas from the latest block
        const block = await this.Web3.getBlock('latest', {
            chainId
        });
        const baseFeePerGas = block?.baseFeePerGas ?? 0;
        return {
            [specs/* GasOptionType */.Qd.FAST]: {
                estimatedBaseFee: (0,number/* toFixed */.FH)(baseFeePerGas),
                estimatedSeconds: 0,
                baseFeePerGas: (0,number/* toFixed */.FH)(baseFeePerGas),
                suggestedMaxFeePerGas: (0,number/* toFixed */.FH)(baseFeePerGas + fast),
                suggestedMaxPriorityFeePerGas: (0,number/* toFixed */.FH)(fast)
            },
            [specs/* GasOptionType */.Qd.NORMAL]: {
                estimatedBaseFee: (0,number/* toFixed */.FH)(baseFeePerGas),
                estimatedSeconds: 0,
                baseFeePerGas: (0,number/* toFixed */.FH)(baseFeePerGas),
                suggestedMaxFeePerGas: (0,number/* toFixed */.FH)(baseFeePerGas + normal),
                suggestedMaxPriorityFeePerGas: (0,number/* toFixed */.FH)(normal)
            },
            [specs/* GasOptionType */.Qd.SLOW]: {
                estimatedBaseFee: (0,number/* toFixed */.FH)(baseFeePerGas),
                estimatedSeconds: 0,
                baseFeePerGas: (0,number/* toFixed */.FH)(baseFeePerGas),
                suggestedMaxFeePerGas: (0,number/* toFixed */.FH)(baseFeePerGas + slow),
                suggestedMaxPriorityFeePerGas: (0,number/* toFixed */.FH)(slow)
            },
            [specs/* GasOptionType */.Qd.CUSTOM]: {
                estimatedSeconds: 0,
                suggestedMaxFeePerGas: '',
                suggestedMaxPriorityFeePerGas: ''
            }
        };
    }
    async getGasOptionsForPriorEIP1559(chainId) {
        const gasPrice = await this.Web3.getGasPrice({
            chainId
        });
        return {
            [specs/* GasOptionType */.Qd.FAST]: {
                estimatedBaseFee: '0',
                estimatedSeconds: 15,
                suggestedMaxFeePerGas: (0,number/* toFixed */.FH)(gasPrice),
                suggestedMaxPriorityFeePerGas: '0'
            },
            [specs/* GasOptionType */.Qd.NORMAL]: {
                estimatedBaseFee: '0',
                estimatedSeconds: 30,
                suggestedMaxFeePerGas: (0,number/* toFixed */.FH)(gasPrice),
                suggestedMaxPriorityFeePerGas: '0'
            },
            [specs/* GasOptionType */.Qd.SLOW]: {
                estimatedBaseFee: '0',
                estimatedSeconds: 60,
                suggestedMaxFeePerGas: (0,number/* toFixed */.FH)(gasPrice),
                suggestedMaxPriorityFeePerGas: '0'
            },
            [specs/* GasOptionType */.Qd.CUSTOM]: {
                estimatedSeconds: 0,
                suggestedMaxFeePerGas: '',
                suggestedMaxPriorityFeePerGas: ''
            }
        };
    }
    async getGasOptions(chainId) {
        if (ResolverAPI/* ChainResolver */.iv.isFeatureSupported(chainId, 'EIP1559')) return this.getGasOptionsForEIP1559(chainId);
        else return this.getGasOptionsForPriorEIP1559(chainId);
    }
}

// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/HubOptionsAPI.ts
var HubOptionsAPI = __webpack_require__(40850);
// EXTERNAL MODULE: ./node_modules/.pnpm/urlcat@3.1.0_patch_hash=5r5xyq4zgcnqugwsrx4lxq2i4e/node_modules/urlcat/dist/index.mjs
var dist = __webpack_require__(78757);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/formatter.ts
var formatter = __webpack_require__(41487);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/isValidChainId.ts
var isValidChainId = __webpack_require__(37049);
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/fetchJSON.ts
var fetchJSON = __webpack_require__(11834);
;// CONCATENATED MODULE: ./packages/web3-providers/src/MetaSwap/index.ts




const METASWAP_API = 'https://gas-api.metaswap.codefi.network/';
function formatAmountAsWei(amount = '0') {
    return (0,formatter/* formatGweiToWei */.nU)(amount).toFixed();
}
class MetaSwapAPI {
    async getGasOptions(chainId) {
        if (!(0,isValidChainId/* isValidChainId */.J)(chainId)) return;
        const result = await (0,fetchJSON/* fetchJSON */.ZV)((0,dist/* default */.ZP)(METASWAP_API, '/networks/:chainId/suggestedGasFees', {
            chainId
        }));
        return {
            [specs/* GasOptionType */.Qd.FAST]: {
                estimatedBaseFee: formatAmountAsWei(result.estimatedBaseFee),
                estimatedSeconds: 15,
                baseFeePerGas: formatAmountAsWei(result.estimatedBaseFee),
                suggestedMaxFeePerGas: formatAmountAsWei(result.high?.suggestedMaxFeePerGas),
                suggestedMaxPriorityFeePerGas: formatAmountAsWei(result.high?.suggestedMaxPriorityFeePerGas)
            },
            [specs/* GasOptionType */.Qd.NORMAL]: {
                estimatedBaseFee: formatAmountAsWei(result.estimatedBaseFee),
                estimatedSeconds: 30,
                baseFeePerGas: formatAmountAsWei(result.estimatedBaseFee),
                suggestedMaxFeePerGas: formatAmountAsWei(result.medium?.suggestedMaxFeePerGas),
                suggestedMaxPriorityFeePerGas: formatAmountAsWei(result.medium?.suggestedMaxPriorityFeePerGas)
            },
            [specs/* GasOptionType */.Qd.SLOW]: {
                estimatedBaseFee: formatAmountAsWei(result.estimatedBaseFee),
                estimatedSeconds: 60,
                baseFeePerGas: formatAmountAsWei(result.estimatedBaseFee),
                suggestedMaxFeePerGas: formatAmountAsWei(result.low?.suggestedMaxFeePerGas),
                suggestedMaxPriorityFeePerGas: formatAmountAsWei(result.low?.suggestedMaxPriorityFeePerGas)
            },
            [specs/* GasOptionType */.Qd.CUSTOM]: {
                estimatedSeconds: 0,
                suggestedMaxFeePerGas: '',
                suggestedMaxPriorityFeePerGas: ''
            }
        };
    }
}
const MetaSwap = new MetaSwapAPI();

;// CONCATENATED MODULE: ./packages/web3-providers/src/Astar/index.ts


const ASTAR_API = 'https://gas.astar.network/api/gasnow?network=astar';
class AstarAPI {
    async getGasOptions() {
        const { data: result } = await (0,fetchJSON/* fetchJSON */.ZV)(ASTAR_API);
        const { priorityFeePerGas } = result.eip1559;
        return {
            [specs/* GasOptionType */.Qd.FAST]: {
                estimatedBaseFee: (0,number/* toFixed */.FH)(result.eip1559.baseFeePerGas),
                estimatedSeconds: 15,
                suggestedMaxFeePerGas: (0,number/* toFixed */.FH)(result.fast ?? 0),
                suggestedMaxPriorityFeePerGas: (0,number/* toFixed */.FH)(priorityFeePerGas.fast)
            },
            [specs/* GasOptionType */.Qd.NORMAL]: {
                estimatedBaseFee: (0,number/* toFixed */.FH)(result.eip1559.baseFeePerGas),
                estimatedSeconds: 30,
                suggestedMaxFeePerGas: (0,number/* toFixed */.FH)(result.average ?? 0),
                suggestedMaxPriorityFeePerGas: (0,number/* toFixed */.FH)(priorityFeePerGas.average)
            },
            [specs/* GasOptionType */.Qd.SLOW]: {
                estimatedBaseFee: (0,number/* toFixed */.FH)(result.eip1559.baseFeePerGas),
                estimatedSeconds: 60,
                suggestedMaxFeePerGas: (0,number/* toFixed */.FH)(result.slow ?? 0),
                suggestedMaxPriorityFeePerGas: (0,number/* toFixed */.FH)(priorityFeePerGas.slow)
            },
            [specs/* GasOptionType */.Qd.CUSTOM]: {
                estimatedSeconds: 0,
                suggestedMaxFeePerGas: '',
                suggestedMaxPriorityFeePerGas: ''
            }
        };
    }
}
const AstarGas = new AstarAPI();

// EXTERNAL MODULE: ./packages/web3-shared/evm/src/constants/constants.ts
var constants_constants = __webpack_require__(33026);
// EXTERNAL MODULE: ./packages/web3-providers/src/DeBank/constants.ts
var DeBank_constants = __webpack_require__(10663);
;// CONCATENATED MODULE: ./packages/web3-providers/src/DeBank/apis/GasOptionAPI.ts





class DeBankGasOptionAPI {
    async getGasOptions(chainId) {
        const { CHAIN_ID } = (0,constants_constants/* getDeBankConstants */.Bx)(chainId);
        if (!CHAIN_ID) throw new Error('Failed to get gas price.');
        const result = await (0,fetchJSON/* fetchSquashedJSON */.Vn)((0,dist/* default */.ZP)(DeBank_constants/* DEBANK_OPEN_API */.$1, '/v1/wallet/gas_market', {
            chain_id: CHAIN_ID
        }));
        if (!result.length) throw new Error('Failed to get gas price.');
        const fast = result.find((x)=>x.level === 'fast');
        const normal = result.find((x)=>x.level === 'normal');
        const slow = result.find((x)=>x.level === 'slow');
        return {
            [specs/* GasOptionType */.Qd.FAST]: {
                estimatedSeconds: fast?.estimated_seconds || 15,
                suggestedMaxFeePerGas: (0,number/* toFixed */.FH)(fast.price),
                suggestedMaxPriorityFeePerGas: '0'
            },
            [specs/* GasOptionType */.Qd.NORMAL]: {
                estimatedSeconds: normal?.estimated_seconds || 30,
                suggestedMaxFeePerGas: (0,number/* toFixed */.FH)(normal.price),
                suggestedMaxPriorityFeePerGas: '0'
            },
            [specs/* GasOptionType */.Qd.SLOW]: {
                estimatedSeconds: slow?.estimated_seconds || 60,
                suggestedMaxFeePerGas: (0,number/* toFixed */.FH)(slow.price),
                suggestedMaxPriorityFeePerGas: '0'
            },
            [specs/* GasOptionType */.Qd.CUSTOM]: {
                estimatedSeconds: 0,
                suggestedMaxFeePerGas: '',
                suggestedMaxPriorityFeePerGas: ''
            }
        };
    }
}
const DeBankGasOption = new DeBankGasOptionAPI();

// EXTERNAL MODULE: ./packages/web3-providers/src/DeBank/apis/HistoryAPI.ts
var HistoryAPI = __webpack_require__(86273);
// EXTERNAL MODULE: ./packages/web3-providers/src/Zerion/index.ts + 3 modules
var Zerion = __webpack_require__(1599);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/apis/HubBaseAPI.ts











class HubBaseAPI extends apis_HubBaseAPI/* HubBaseAPI_Base */.j {
    GasOptions = new GasOptionAPI();
    HubOptions = new HubOptionsAPI/* HubOptionsAPI */.u(this.options);
    async getGasOptions(chainId, initial) {
        const options = this.HubOptions.fill({
            ...initial,
            chainId
        });
        try {
            const isEIP1559 = ResolverAPI/* ChainResolver */.iv.isFeatureSupported(options.chainId, 'EIP1559');
            if (isEIP1559 && chainId !== types/* ChainId */.a_.Astar) return await MetaSwap.getGasOptions(options.chainId);
            if (chainId === types/* ChainId */.a_.Aurora) return this.GasOptions.getGasOptions(options.chainId);
            if (chainId === types/* ChainId */.a_.Astar) return await AstarGas.getGasOptions();
            return await DeBankGasOption.getGasOptions(options.chainId);
        } catch (error) {
            return this.GasOptions.getGasOptions(options.chainId);
        }
    }
    async getTransactions(chainId, account, initial) {
        const options = this.HubOptions.fill({
            ...initial,
            account,
            chainId
        });
        return (0,attemptUntil/* attemptUntil */.C)([
            HistoryAPI/* DeBankHistory */.u,
            Zerion/* Zerion */.KN
        ].map((x)=>()=>x.getTransactions(options.account, options)), (0,Pageable/* createPageable */.LI)(constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(options.indicator)));
    }
}


/***/ }),

/***/ 32506:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  K: () => (/* binding */ HubFungibleAPI)
});

// EXTERNAL MODULE: ./packages/web3-shared/base/src/specs/index.ts
var specs = __webpack_require__(62649);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/attemptUntil.ts
var attemptUntil = __webpack_require__(92358);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/types/index.ts
var types = __webpack_require__(24770);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/ConnectionReadonlyAPI.ts + 2 modules
var ConnectionReadonlyAPI = __webpack_require__(3543);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Base/apis/HubFungibleAPI.ts
var apis_HubFungibleAPI = __webpack_require__(34659);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/Web3StateAPI.ts
var Web3StateAPI = __webpack_require__(39850);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/HubOptionsAPI.ts
var HubOptionsAPI = __webpack_require__(40850);
// EXTERNAL MODULE: ./packages/web3-providers/src/Approval/index.ts + 2 modules
var Approval = __webpack_require__(39874);
// EXTERNAL MODULE: ./node_modules/.pnpm/urlcat@3.1.0_patch_hash=5r5xyq4zgcnqugwsrx4lxq2i4e/node_modules/urlcat/dist/index.mjs
var dist = __webpack_require__(78757);
// EXTERNAL MODULE: ./packages/shared-base/src/Pageable/index.ts
var Pageable = __webpack_require__(38645);
// EXTERNAL MODULE: ./packages/shared-base/src/constants.ts
var constants = __webpack_require__(52033);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/isValidChainId.ts
var isValidChainId = __webpack_require__(37049);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/address.ts
var helpers_address = __webpack_require__(65327);
// EXTERNAL MODULE: ./packages/web3-providers/src/Chainbase/helpers.ts
var helpers = __webpack_require__(58021);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Chainbase/apis/FungibleTokenAPI.ts





class ChainbaseFungibleTokenAPI {
    createFungibleAssetFromFT(chainId, token) {
        return {
            chainId,
            id: token.contract_address,
            address: token.contract_address,
            type: specs/* TokenType */.iv.Fungible,
            schema: types/* SchemaType */.XQ.ERC20,
            name: token.name,
            symbol: token.symbol,
            decimals: token.decimals,
            balance: token.balance,
            value: {
                usd: token.current_usd_price.toString()
            }
        };
    }
    async getAsset(address, { chainId = types/* ChainId */.a_.Mainnet } = {}) {
        if (!(0,isValidChainId/* isValidChainId */.J)(chainId)) return;
        const token = await (0,helpers/* fetchFromChainbase */.Dc)((0,dist/* default */.ZP)('/v1/token/metadata', {
            chain_id: chainId,
            contract_address: address
        }));
        if (!token) return;
        return this.createFungibleAssetFromFT(chainId, token);
    }
    async getAssets(address, { chainId = types/* ChainId */.a_.Mainnet, indicator } = {}) {
        if (!(0,isValidChainId/* isValidChainId */.J)(chainId)) return (0,Pageable/* createPageable */.LI)(constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        const tokens = await (0,helpers/* fetchFromChainbase */.Dc)((0,dist/* default */.ZP)('/v1/account/tokens', {
            chain_id: chainId,
            address,
            page: (indicator?.index || 0) + 1
        }));
        if (!tokens) return (0,Pageable/* createPageable */.LI)(constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        const assets = tokens.map((x)=>this.createFungibleAssetFromFT(chainId, x));
        return (0,Pageable/* createPageable */.LI)(assets, (0,Pageable/* createIndicator */.sz)(indicator), assets.length ? (0,Pageable/* createNextIndicator */.gT)(indicator) : undefined);
    }
    async getFungibleTokenPrice(chainId, address) {
        if ((0,helpers_address/* isNativeTokenAddress */.qw)(address) || !(0,helpers_address/* isValidAddress */.At)(address) || chainId !== types/* ChainId */.a_.Mainnet) return undefined;
        const data = await (0,helpers/* fetchFromChainbase */.Dc)((0,dist/* default */.ZP)('/v1/token/price', {
            chain_id: types/* ChainId */.a_.Mainnet,
            contract_address: address
        }));
        return data?.price;
    }
}
const ChainbaseFungibleToken = new ChainbaseFungibleTokenAPI();

// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/isSameAddress.ts
var isSameAddress = __webpack_require__(74765);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/constants/constants.ts
var constants_constants = __webpack_require__(33026);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/formatter.ts
var formatter = __webpack_require__(41487);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Cloudflare/TokenIconSpecialIconList.json
const TokenIconSpecialIconList_namespaceObject = JSON.parse('[{"name":"MASK","address":"0x2eD9a5C8C13b93955103B9a7C167B67Ef4d568a3","logo_url":"https://dimensiondev.github.io/Mask-VI/assets/Logo/MB--Logo--Geo--ForceCircle--Blue.svg"},{"name":"MASK","address":"0x2B9E7ccDF0F4e5B24757c1E1a80e311E34Cb10c7","logo_url":"https://dimensiondev.github.io/Mask-VI/assets/Logo/MB--Logo--Geo--ForceCircle--Blue.svg"},{"name":"NEST","address":"0x04abEdA201850aC0124161F037Efd70c74ddC74C","logo_url":"https://s2.coinmarketcap.com/static/img/coins/64x64/5841.png"},{"name":"Yes KYC","address":"0x14de81C71B3F73874659082b971433514E201B27","logo_url":"https://etherscan.io/token/images/ykyctoken_32.png"},{"name":"cWBTC","address":"0xC11b1268C1A384e55C48c2391d8d480264A3A7F4","logo_url":"https://etherscan.io/token/images/compoundwrappedbtc_32.png"},{"name":"DANK","address":"0x0cB8D0B37C7487b11d57F1f33dEfA2B1d3cFccfE","logo_url":"https://etherscan.io/token/images/dank_32.png"},{"name":"DSCP","address":"0x03e3f0c25965f13DbbC58246738C183E27b26a56","logo_url":"https://etherscan.io/token/images/disciplina_28.png"},{"name":"GEE","address":"0x4F4f0Db4de903B88f2B1a2847971E231D54F8fd3","logo_url":"https://etherscan.io/token/images/geens_28.png"},{"name":"FKX","address":"0x009e864923b49263c7F10D19B7f8Ab7a9A5AAd33","logo_url":"https://etherscan.io/token/images/knoxstertoken_32.png?v=2"},{"name":"N0031","address":"0x075190c6130EA0a3A7E40802F1D77F4Ea8f38fE2","logo_url":"https://etherscan.io/token/images/nestyfi_32.png"},{"name":"NFC","address":"0xb0866289e870D2efc282406cF4123Df6E5BcB652","logo_url":"https://etherscan.io/token/images/nofaketoday_28.png"},{"name":"O3Swap","address":"0xEe9801669C6138E84bD50dEB500827b776777d28","logo_url":"https://etherscan.io/token/images/o3swaptoken_32.png"},{"name":"QTUM","address":"0x9a642d6b3368ddc662CA244bAdf32cDA716005BC","logo_url":"https://etherscan.io/token/images/qtum_28.png"},{"name":"REMI","address":"0x13cb85823f78Cff38f0B0E90D3e975b8CB3AAd64","logo_url":"https://etherscan.io/token/images/remiit_28.png"},{"name":"REDC","address":"0xB563300A3BAc79FC09B93b6F84CE0d4465A2AC27","logo_url":"https://etherscan.io/token/images/redcab_28.png"},{"name":"SBTC","address":"0xfE18be6b3Bd88A2D2A7f928d00292E7a9963CfC6","logo_url":"https://etherscan.io/token/images/Synthetixsbtc_32.png"},{"name":"TPT","address":"0xC596bD09d652827b0106292D3e378D5938df4B12","logo_url":"https://etherscan.io/token/images/009-TPT-Teleport-Token-Coin-Logo.png"},{"name":"TRL","address":"0xCed1A8529125D1bD06B54a7B01210df357D00885","logo_url":"https://etherscan.io/token/images/giraffage_28.png"},{"name":"UPX","address":"0x5f778ec4B31a506c1Dfd8b06F131E9B451a61D39","logo_url":"https://etherscan.io/token/images/udap_28.png"},{"name":"WYV","address":"0x056017c55aE7AE32d12AeF7C679dF83A85ca75Ff","logo_url":"https://etherscan.io/token/images/wyvern_28.png"},{"name":"VDOC","address":"0x82BD526bDB718C6d4DD2291Ed013A5186cAE2DCa","logo_url":"https://etherscan.io/token/images/vdoc_28.png"},{"name":"rSAI","address":"0xea8b224eDD3e342DEb514C4176c2E72Bcce6fFF9","logo_url":"https://etherscan.io/token/images/redeemabledai_32.png?v=2"},{"name":"ALICE","address":"0xAC51066d7bEC65Dc4589368da368b212745d63E8","logo_url":"https://bscscan.com/token/images/alicetoken_32.png"},{"name":"BP","address":"0xACB8f52DC63BB752a51186D1c55868ADbFfEe9C1","logo_url":"https://bscscan.com/token/images/bunnypark_32.png"},{"name":"DOGGY","address":"0x74926B3d118a63F6958922d3DC05eB9C6E6E00c6","logo_url":"https://bscscan.com/token/images/doggy_32.png"},{"name":"DCH","address":"0x14ACe3d3429408bFA8562099A253172913AD71bd","logo_url":"https://bscscan.com/token/images/dechart_32.png"},{"name":"FRANK","address":"0x129e6d84c6CAb9b0c2F37aD1D14a9fe2E59DAb09","logo_url":"https://bscscan.com/token/images/frankenstein_32.png"},{"name":"RFOX","address":"0x0a3A21356793B49154Fd3BbE91CBc2A16c0457f5","logo_url":"https://bscscan.com/token/images/redfoxlabs_32.png"},{"name":"FOR","address":"0x658A109C5900BC6d2357c87549B651670E5b0539","logo_url":"https://bscscan.com/token/images/forceprotocol_32.png"},{"name":"TPT","address":"0xECa41281c24451168a37211F0bc2b8645AF45092","logo_url":"https://bscscan.com/token/images/tokenpocket_32.png"},{"name":"UNCL","address":"0x0E8D5504bF54D9E44260f8d153EcD5412130CaBb","logo_url":"https://bscscan.com/token/images/unicrypt-uncl_32.png"},{"name":"UNCX","address":"0x09a6c44c3947B69E2B45F4D51b67E6a39ACfB506","logo_url":"https://bscscan.com/token/images/unicrypt_32.png"},{"name":"WOOP","address":"0x8b303d5BbfBbf46F1a4d9741E491e06986894e18","logo_url":"https://bscscan.com/token/images/woonkly_32.png"},{"name":"ZIL","address":"0xb86AbCb37C3A4B64f74f59301AFF131a1BEcC787","logo_url":"https://bscscan.com/token/images/zilliqa_32.png"},{"name":"PBTC","address":"0xeD28A457A5A76596ac48d87C0f577020F6Ea1c4C","logo_url":"https://bscscan.com/token/images/ptokenbtc_32.png"},{"name":"FUSD","address":"0x3c5959b568896393","logo_url":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGYAAABkCAYAAAB0F0VpAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAaGVYSWZNTQAqAAAACAAEAQYAAwAAAAEAAgAAARIAAwAAAAEAAQAAASgAAwAAAAEAAgAAh2kABAAAAAEAAAA+AAAAAAADoAEAAwAAAAEAAQAAoAIABAAAAAEAAABmoAMABAAAAAEAAABkAAAAAHl4y70AAALkaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJYTVAgQ29yZSA2LjAuMCI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIgogICAgICAgICAgICB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyI+CiAgICAgICAgIDx0aWZmOkNvbXByZXNzaW9uPjE8L3RpZmY6Q29tcHJlc3Npb24+CiAgICAgICAgIDx0aWZmOlJlc29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblVuaXQ+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24+MjwvdGlmZjpQaG90b21ldHJpY0ludGVycHJldGF0aW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFhEaW1lbnNpb24+MTAyPC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6Q29sb3JTcGFjZT4xPC9leGlmOkNvbG9yU3BhY2U+CiAgICAgICAgIDxleGlmOlBpeGVsWURpbWVuc2lvbj4xMDA8L2V4aWY6UGl4ZWxZRGltZW5zaW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KFaK0OAAACAxJREFUeAHtnb9v20YUxx8VJWmLopHRuYi7dGkGFd26hEGXdijgtEPGKP9AbQN1gEy2pwKxATv9B6KMGdok6FyYWbpGQ6cuddGtQCGlKNAfka1+351OoiiKOoqkyGffA+Q7HsnHd+/j9+5ISqRHVZfuQYOo34SZPpF3lWiwijraiNtsJBhu9Bz7HkPHMa1smbbhquoVXuVM6n69SnTBJ6pdh20oFQhUc5cAGjv4PKsiqGqAUTDqa3DSbXxsIwGb5iY9RNJTaAOkr7gsXcoF091fIzoFDA9lZaQHS9pInw9o5d5xWVYtH4weM1qAsV5gmsrJnwNEjwdAyx+Tlgumu7cDjwGIGrxzct5S1AQ4yu4yAS0HjEpZdFD9CJkHmSPoZHMZKa5YMHpQf4ju+vO6LGg9j0Gc3naKtLk4MN29DRi+jU+jyA6UqLuDDHCHVu6izF/yB6MH9ycw1c/f3EpqRGrbOszbsnzBdO83MYs5gpGNvA2ttj4eey4iejZ7edlZy0sRde+3AOUF9J0zKOxBPg/rH5EaU3k5u+QTMd09zLhoI7s54jUgYgY38hh3soPp7mPWNWiJd2l+HcgFTrZU5qDE4WyolK5Se9xqu7bFI8ZBmefhTJGzGBgHZR4Us35hOOnB6NkXn807sfMA4PQ/SHsZJx2Y7p4PW/g8xUk6D3SI6pit2Z/n2A/+eo7OZ/RO0nugiYuffEphLfZgqM5QGtaa3YYRD+CUIsVMzQ6Mvo8C6k6yecA7sL06MB+Muv6lrhJns8ntzR5AxqlbTZzmgyHPSpHzu7UHfNK3RBJ3SJ6VaQWpBq3Eo7mVxgM9RM67SbO02RGj7qu4FGY8mXOJlNbfTtI5Gwz1N7AjFDgpyAMbSROBeDA6WtYLMsipHXng4syoiQfjomXkumIrfG7DXwmelmkwLlqmvVRoS3zUTM/KhM/Edl77iNYvf0gN73Kh7oxT7vX245rntcXO0KYjRn11dZ6uaq4/eP0GbQNMGVAyeIRnaK3o/pNg1Fl+YT97iB471+XV2hXaQKQIldtRuyfBUE3sTGy19la0b5KWm7jA2QwbHAEzWAuvlFTniJEt3kTUjMFoYsh3MuV6/R2Zho+t9sdV/J5uvDBJbNxe/Vrr0jVqXXq/+oYmW4h0Nj6nCYEhP3m/aq3lmZePKHn4xqf4fFIt4xa25oJvdq2bCsqJwSfUblVlJx29ectqW7fRLA/UrmNNm9fqiNFfsuBlJ6V6YDAKDpPK/FLtyXjwl/QffUzf0pcUZNRU+u5RMPxgA5nCUD6n7+kn+oMe08/y4Qyz1zBiZJ7th6GYfyv5cDQLsaksDsrZgOOtcj8MGK6LkSQophNyI0cPK7XoNRrTsaqWNlCM7TLhjFKZJ+YyTBoosuEISmWLQBEKRwWKiDEmCxSBcNS5TOXB5AFFIByZszLj6LNcVj5irtAl+o4+o2v0dmYOt+g9+ob8zHqWoaDyYNgJecARBKXDfRYBJiscQVC4qz3+AzADVeGFqssikSMMyghBLY/Ha4y0LaGSBo5MKN4xu1FMKgszt4EjEwr3cvAr/zVgAl6QJElw5EJhAvzQ7hEYHT7cIEni4MiGwt6fSGU6fCRBMbaG4ciHgl4NHyVsviUToGnbdFZayXB+oC+kmR1nrzqH4RV6jCnhgc9xVrk2bwTGRAz7hBub0p1zfPon7f7zIx2fvqSg/5uw7pw+NwaHwTyTDqZz8jvd+Osx9Qb/mv4JK08CY7CZLmOZn4QqWzb/PhIMBRkr9JKHMRj9YOeeZDTyUteEt4Pw0hiMalXvUAmvF1OXm76MiwePTI3LCJjTB+GVkurCowVpbPJR9JNg1Ep5VwE4WngmJlgmooX7MQlG9WwgKmo4UngmxjMyoYJxvd6O2u5FG0i/NOEXtDem1rmGAjzgtfFetDtRxdMRox+oKSpqop2StfxqN87eaTBqq/ohCtFT57jOVq+No+XecZxd8WBc1MT5qoC2+GjhA8WDUSa4qCmARFjl4axo4Y1mg9FRE5v/wtpdfSEP8Ews0bezwfDx9CueOgsd2u2U5IHdpOdh8o7JYJRqvCDNSZ4eCGzeaTYfjL5UkBh2eVp9xnUhhfWt/tE9a0d0915g26b19m7DGA+o1zO2Y1ZMNc2PmNEu/ZuogriTxTzA5yx327b72oPRJ0IMx0l6D2ACdWEzzW72YFir+tKGmwykcTC25XHl5rxZWFRnOjC8twpHhKUTGw8ACr9+Mf6yS5IC+8E/qsW9pyzqkejyEMrkDbDoRrOW00eM0aQuVbvIMe6IlIDi3YnelYxsk7i4eMQYtS5yjCdMmSlSjJLFI8Zo0Dd5Ds3iOS9zgcI+zA6GtaxsYSp47mdrHcy+8FrFxcYUdmNYsqeysDb1JFr32viwSxat5wuGrdDfGXiCms+L50A2bS5KpvVD/mCMBfrlDfzTjoZpOmMlUpe69oUyfykODNuqniOs3mLn5296aRp7OPIDRMlOkRYUC8ZY3t1fQ/UA/2GrpklmyV+8P0HqSn8mn7a/ywFjrNIvOl3HYsM0CSkD2Im7jltcLkWWC4a7pCcHLZwZA1DVI4gjxOO0FbDpy5Tlgwn3TqW409voPKe6qkgPhrRxTgIgxaesWZ0uF4yxSk8SGA4glXKXFDDUT1Ce4euqT41ZZZbVABP2gEp1rwBJPefeLzDdBTjsc3yCMlIVjpso1QMTNVePSU00+/ivvjoE1cAyt9lIMNwIEPipE/iZSQljho2h4W3+B67PJplkPQvfAAAAAElFTkSuQmCC"},{"name":"FLOW","address":"0x1654653399040a61","logo_url":"https://swap.blocto.app/static/media/flow-logo.7d05ec26.svg"},{"name":"tUSD","address":"0xcfdd90d4a00f7b5b","logo_url":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAAAXNSR0IArs4c6QAAAAlwSFlzAAAOxAAADsQBlSsOGwAAIABJREFUeJztnXl8XNWV57/3vtpLu2TLkmVLli1vGGOTAHawTSAsWQmQpjvLZ0K2SSY9oZPJ5EN38sknC52Z8Ml0mkxPlk4YsieE7pCEZSbsE8dAbDAGbLCNd8mWra2kkqpKtb337vzx6pVqs1CVqmTZ0s8Iqape3XeX3zv3nHPPPVeg7lDMY85CnusKzOPcYp4AcxzzBJjjmCfAHMc8AeY45gkwxzFPgDmOeQLMccwTYI5jngBzHI5zXYHKQQEKDY163DTgp5kqGvFRgwcvLtxoKMBEEUcnQpwg4wwwziAhhokSJpkqT5zDtlQOFwgBrOWMKpy0UE0njWyglWtZySaW4sOVc61A5gyoRRfr/wKRfn2SUZ7iMM9ylP0M0cMIg4yjY3IhkEKcv4tBConAi4PLWcwXuY6rWY4EZIVmNjM16GHifJsd/IRdDBAhjlmR+80EzkMCKJxI3s8GPscWltFAHV4AxAw9kSolcQwUpxnleU7yVf7IfoY439Sq84YAAsUW2vkMW7iWLurxUsqQR/UEhircZLd04NS0ouumUpTYQy+PsJ/v8SxDxIou51xg1hPAheQ6VvBf2MrVdOXP3UpZU7ECXZmEk3HG9QThRIwToQBHgwOcGR+jNxK03k/GMU2z4PTtlg68ThdNniqavTV01DTSWdNEs7+WKqcbv8OFx+G06pD6fi4FFYpRYnyPZ/kxuznGMLNZV5i1BHAh2UQbP+ODLKUua+CVUilVDsb1BIFYhO5QgKOjgxwY6ePY6AA9oWGiepKkYaAECIcGQoA5yXwtBAiBMgyUYeIQEpfmoM7tY0XdQlbVN9NZ00RHTRNLquqp8/iQSiCFRYhMMthS4W62czfP0MsYs5EIs5AAiiY8PM6nuJgWNES6Y1VKQ9eVyelwkMPBfp7vP8HR6DDHhwcYiIySzBxgpUBZ4woCpRSpPwvfObcn7ItF6kMh8GoOltYvYHl1E+vqWljXuJjVDYuodnlS98qXCDGS3MXT3MlTzDYdYVYRwIvGPdzKLazDgyNPvBrK5GhwgCdPHuDZvqOcTkQYGgtioiyxrlT+IBaArcTlYioahRACIQUo8Hu9NHj8rKtZxJbWFWxbvJJGj/+s9zxKgI/yG56hh9kiDWYJARRvp4tv8i4uoSXjiQeUQgjBYDTMD/f9icd69jNixDB1AwkYpsJUJhLBxMSQW/r0mpgpgSQCE6tOUljSSTkkbs1Bh7ee/7BmE+/uWI9Lc6TbYNfIrse9PM8/8H8JzAJF8ZwTwI3ky7yNL/G2rHneUCaGaXIqMsJDx/fy8/3PMo4JholQKeUvA9Md5GKQKymksMinUpLh4sbF/KeLtnF5yzK8Dpc1jYlM/QCOEeAT3M+fOMG5lAbnkACKOjwc5g4a8OcN/ulIkO2nD/Pbwy9yJDyEHk+epZRzK8AKThuaRFPw9mUXc2PHei5dsNTSEXJgYPIpHuAn7D5nrqRzRoCtLOVBPkod3qxOTJgGO3oP8cDRl9g91EMoHgVT5T3xcO4H30YuCWylU3M6aPXW8Pb2i7hp2QY6axdkXWdbCts5yju5l9g5oME5IcDHeRN3cyPVZD8VfZFRfvn6Lh49fYDeYACBwFRmSj2fmIdnM3ItFiEFHqeLi+pb+NjaK7mmbXW6Dfa1JordnOQWfkYv4Rmu74wSQPElruJO3oGWYw69PtzHt/Y8xu5AD8lk0tLqU1W0vjm7Bz4TIkPtA8tyUECtr4oPdr6ZT6zbis/pzPMbHGGId/MTDjHETOkFM0YACXyGTdzNTen53kzZ5XsDp/j6C/+H14Z6keTb4+fT4GeikLKoed28q2U1n7/0ehZ6q/O+00+IK/gXuhllJkgwYwT4OzbxHW5ON8lUCt002N57iG+9/DinwkEwjNRcL87bQS+ETCJIKZAOjW3NK7j9kmtYWd+MzLESTEw6uStFgspiRtxSX2Ibd3NTlmAMJWP87ugevv7CI5wKjYBhXpCDD9kSzDBNDN3g6d6DfOvFR3l58GTe9RLJLm5nGXUVr1vFCfBxLuVO3pEW+woIxsf56f7nuPuVpwhEw2BODP6FikzFT5mWL2Nn3zH++55H+fPpQ3nXN1PNH/gwTeSbj+VEBQmg2MpS7uamtMJnKkU4EeNXB3fyq0O7CMVjKNPMmvMvtKc/ExNtE2mzdv9QL9/c8xi7+o/lXX8xrTzIRyh+gXrqqBgB6vHwIB+lGjdgee50ZfJ4z2vcd+QFwsk4hmmQqeVfyINvI48ESnF8ZIC7XvgjrwydzOoDgWAzHdzD+yo2UBUp143kEH+fjtQByxTa3X+C7+x9muHYOKZhZNnMcwkTZBcoBZqQHBjp4+6XnuRYcBAzhwS3cRnvpqsidakAARRf4W004svSfo+ODvJPLz/BUGrOPx/t+0rBVJbPY8/QSX5+cCcjsfGszwXwG25jNY1lv3fZCXADK/gHrsl6urvHAnxl10McGDmT0vZJfzaXkS0JFAlD55GeV/nd0T3W52pCcfTi5B5uxV3mIStraV4kd/HurKjcsUSM7+59mt2D3QhjbszzpUAgwFSMJ2L8eP+z7Dh9GMh+SN5CO19gG5SxD8tIAMU93Mp6WrLefeT4K2wfPI5m2qJuXvTnIqsvTMVIIsrXdj5EbyQIGUvfEslXuI5mfGW7d9kI0ISHW7g4w95X7B06xf1H9xAKhzAznDzFDH6hVcDzAUoVXsE86/WpPlGANBW9eoR7XttBUhlZXkInGr/mQ2WrZ1kI4ELyOJ/Cw0QUTDAe5ffHXuL46GD6umKfersDTWVF/Vi/Z/uPmbGQVRyB7f4xlULGdZ7oPcgTPQcw1ER5AsEWOtnCEsoxFZRla9gm2ljHIsvLhcIwTZ7vO87Tp15Hz/DvlwKFotblpdlXM6V4v3OKVPxoTNc5HRlBt4NQS4CpFMFohD8ce5l1Da2010xYAE4kD/ExWvlvxNCnVeVpE8CF5Ke8H0eGMIkkEzzSvZfBWHhaIlwIgWGYbG3t4lMXX5XlRJmNUFgitTcS5O+feYCR+DgOWZyQteMIAJRp8krgFDtOH2aRvxaXZsdIC+rwchUdPMZhptMf0ybA9axgKfXpSgsEO84c5pn+4yk3r0pLhlKgBPidblY3tJA0psf2SkNhOXUMZVp7BUptc4oESkE4GefJ3oNctXglrVV1aGKin3/BB2jlG+jTmAqmRQCB4nNszQru0JXJD/dtJ5qIgWlOKdR6ckxQxyEtr3hu7P1sgR3fUL7aKZRp8FJ/N8+eOcqtXW+y9INU+xvxczPr+Hf2lXyHaSmBW2nn6hwX5Y7eQxwOBxDm+RPGNRuRDnFXgqSEx0/uJ6on04MPIBH8LVfANGIJp0EAxWe4MovtET3BPa/uSC3v2lfND/50oJTCTOjs7DvGrv7j1nsZfXoVK7iERSWXXzIBnAiuoSs1V1k27/N9xzgcGkScv9vlZy1MAfe9/jxJ08ibVm9na8nllkgAxQfYSEPKIyWEIG7q7Dh9mHFTn6U6+vmHLOmpm+waOMGB4TNZ1wgEb6UTMEq6R0kEkAg+y5b0a1MpekLDvDjQg5lInrfeu9mOpDK4//ALee8vo5EtLKMUq6MkAnhx0EHDhOkn4PBIP8MqjhQSO79OOed/e5pRmX+X+POG9yi1XLt+ZWt1RihZSqzu7j/BWCJ7T6EAvsy1lGJ/lGAGKi6nNZWhw6pgJJngpcBJgmmffxmhJraH60ohSihfCJG2n6d0S6zgzWKhUDiEtKJ8i/72G5StQOkG/dEQO3oP8c6Oi4HUbmUEG2nFhSRRpEVQkh/gDq5N/y0QBGJhjoWH0Q0TU5XD9p+AEBCIhXnuzNGSJIqpFI0eP6vrW7JMqMkwloiyb6iXot0NqfwA/eNj6GXxgWRDExLdIXk10Mt1S9filBPRgnX48OAgQaKoMosmQBVOrs2w/ZVSnA4H6Q0NpzusXKJfKYUmJM+eOcIrQ/nh028EgSBmJNnW2sU3r3wfbm1qzT02OsgXdvw7mixuAFUqW42uTMJ63No1nNrePh1kuoeNRILXR/oJxCIs8temr3EiuZE1/JKXKWYqKJoALVQjyd7X1hMe5szYCKZhUroD9OyI6UlieuHdwZNBCkFUTzKWiBVFyoRpEIiFkGJ2ZfNQKIQSnNEjnI4EafbVZJHr07wlRYCpo2gCLKORTIbFDJ2e8AiJ1JJlOQe/bC7fyfLCTPKl2eRyVljZT5xSMm7qDEZDWVOaQLCJdqpxEypiGiiS4oqNtGTt5Y8mE3SPBdIb+mYqV99chEBgmorx6DinwiMk8hbHFC3k7zecDEUT4BpWZr0TM5KcDA1TvMZUPhQy7wSWv8JO41IMrAUdcdaFnWKjfcoF27Qej8foDg0TM/S8qa2N2rN8uzCKIoCGxiaWZL0X05MMRkNF3bRYZHZ2bucLrLneVrgM0yRpGsQNnXEjybieSOkPUx8wwzQZ1xNE9WQq1ZyObhrpRFT2/dJ7HXPqVEly2KF1o2aCeI4EEAiWU19UeUXpAPW4qcrZqxaIR4gZyQI51qaHdEh0AcliRR0ZGKbCSIVhSSGpc3up9/iodnrwO93UuX2YSrFpUSdaEQpdi7+Om5ZvIGkaJE2DkViEmK4zHI8QSkQJJqLWVm8h0ZBoUlgOsByNf7I2lAohBEpYcQLhZIwF3qqJzxB00lRUeUUSID8F2qnwCEmjND/02WAHkQiR2lJmGiSVZWFoQuLRnHQ1tNJZ08TyuoUsqaqnxVeL1+nC73RR4/TSHx3FVIqEYaQcQVMnQLXLw03LN9Lqr8VUVkiaJiRhPU40mWAsGeNUeITu0QAnQgH2D5+mNxy0iJnKWObUtPQ9zTISwSZVJBmzHrwcrKEZa3l4au0tigDN+PPmxGB83ApanOby78QmCEukm0oRN3Rc0sEify0d1Y1sbl3BJY1tLK6qT8ceHhsb5ExklL1Dp+iNBOkeCzASGydh6pjKEuXbWlfy3as/iEdzTqkuh4P9/O3/+xUezYkU4NIcOISko6aJJl81y6obWeSv5aolK3mfuwqnpjGWSk27u/8EL/Qfpz8SYiQ+jhQCl6alXdgwPSIIq7MIxWKEE/G8zztoKKq8ogjQiA8ThZZBg6RhTFv6Z82fKJzSwdLqBjY0LWF9Uxtddc1IIXgt0Mufew9xfGyII6MDnImMEjeS2Pn9hSBloVjSQwpJTLcDpqbe6UIIDGUS1S1zKpTq6L7xsVTy0Yn61ri9LK2qZ0VdM501C9jS2sXfdF3GUCzM/uEzvDTQzauBXkbiUSu/IOUhwtnWWlqpLqqtRRGgBk9e0QPREGoa3p/MwdeEZG1jC+9MpVaLGkn2DHTzyEt7OT4WYGB8lLipW3OvkEghrKf6LB1pTRmiJANFItBSAZ0Ft2en6h3Tkxwc6eO1wGmEEKkI5lrWNrSwdXEXt294GyOxCI91v8aTJw8wHAunHUylegmVqYgkYoST8SwvIUAdHlxoU14TKIoA1skb2RXOt0VLgxSCt7ev4z+u20pHbRP3HdzFb4+8SPdYgLihI6Q1ID7pyuJaOv/vWVApfdwu17IINJxSQykrefWRYD9HRwf4U+/rXNbcwScu2srnNl7LltYu/vmlxzk2OoRTytLrJqzpMaYn7RTGaTjQ8BRBgKLMQFcBvpRFsUGxtLqBD6y6nJX1zcR1nR+9uoPDwQEMFJqUaYUqt9POlbdOiJy8PsoSyUJYRNWkJKYnebJnP492v4rP4eKG9ov40KpNuDSHHfFXETiLeK6n7eyers1rd2KNy0ud24ow8jtdvGvZxeimgW4YBVfxinHGqIzfk8YT5H5hKmWriXbYbRFCQEoaNPtq2byoE4/mRJOS1qo63PYq3nTIq6bf91DkFGAUECvOlIZbalPsXUMHh/v406mDNHnfTIPHz+c3XsclTW08cHQPh0cGGEtESZh6nlcvPY/au49yKmJ785SaUJqsK7Oz+WVuOpl0XGyZm0GYzABYgcDvdFPj9LClzVII1za0oIDe8Aj3vb6LYCKK1+G0wshLIoHA53Thd7oL9rtZRExAUQQotA2p1V+HxnQCk60Bips6P9i3nZ7QCDev2MjymgW8o+Niti1exevBPvYMdHMsOMjpSJBTkSChRIykaWAqk6RppgM4rLMbRPq3FIKhaJgnevbj1CbslyqnG4/mQgormjmSjKc2dgheH+lL+yBs2thPm004h9BwSJk+VKLB42dJdT3t1Y2saWhh44KlLK6yDrroi4zxQv8JfnHwL+wdOoVbc0wrcEYIgdfpxudwFTifAOJFxAcWRYBx4pDzvHs1O+PlNKcCIJyMcf/hF9jVf4xLFyzl8uZlrKpfxJr6Fq5oXkY4GacvMkrf+BihZIzT4SDDsQinwiOMxCOMJWJp5ShuJNFTLt0TYwHu2v1HInoc3bQ6x+tw4ZYOhLBiBmJ6EhOFV3Pi0DRc0oEU1tOsCYnP6UIKQY3TQ7XLw0JfDc3eGlr8tTR4/NS5fbT662j2VeOQGmcio7w0eJJ9g6fY1X+MfUO9jMQjWUvMJVkAWBLHocmC5xtFSVaOAEGiecO8wGs12HYGFbsNTIiJjFm2UD4xFqAnNMxj3a/R4q9jdf0iOmqbWFXfzPLaBbx5YTsep4u4niRp6kT1JAnTIGkYJJVBKB4jlIwS03WC8fE0ZQPxSNpvkK9NWk93tcsaYKXAISUNHj/u1BPukBKPdOKQGm7NgVtz4HE40YRkNBHl+NgQz545wpHRQY4E+zk00k8wPk4yRbrpDn5mXf1ON16HK++jISIYGFTEEzhIJO/QpoW+GityxhQTk2GRsDsj0xsI1krjsdEBDg6fwcCk1uWl1u2j3u1jee0C2msaWNvQSou/jhZfLXUuL06p4ap1TASm2kqa/fqN6oJN4tTfqVgCpVR6kSmcjHFkdJDusSEODJ/h6Nggp0NBQsk4I/EIMT2JSzpwaPmDUA6rRQhBtceL35lPgB6CRZVVJAHCeQpfrctaeIkaydRTVNT9s5C7kKJS77kdVjXjhs6ZcJBToRFeDfRmzPXg1pws9NXQ6PHR6q/HpTnSvvyV9c28s+PiKSmrEsFANMSvX9+FFJKxRJShaJhxPc7pyChj8VhqncEmmErrBbaDyu90YVLeNYB0H6Va4Ndc+Byu9EKYjSNFJpouigDDRFE53ejWHLT46xiMhsvqdcm1sW0zS5PSqnSO1EiYBidDw3SPBditerD1+pie5Pr2tVy3dG16LeBsA2KXdWxskG/veRxNyHTUre1mto+K0QQIu+MnbEEAjIz6lhO2UqshaHR4LR0mZ7APM0DFCBAmSQ9BlmUsOPgcLtqrG9k7eKqYoopCIU1XZHxmewOllGg5n0khcGtOiukUS+lzZ4WST8btCQOycH3LCgFet5slVfW4Hc6cJNOKIwSKKq5oR9BTHMl67XO66axtonJO12wUerJy38t0+JhqKjN/NtLOooyyiq1TpSCFpMrjY2l1Q17yCYUqWgcomgDPkZ3T1ik1Wn21+J2elASc3xZWCdjTkG4Y+JQsmDJHIDjFWFHlFkkAwX4GsjyCUgjaquppralDyErsiZmHDYFAOjWWVTWwyFeb5bFUKMaI0V/kkTNFS4AeglmDrJSi1V9Le+0CEKkz9eZJUFZk9qfmdNJV30y925cnbO9nL3qRPtmiCTDAOCHiE/OqgDq3n+W+BtyaY8rbr+ZRPJQAtym4pGlJwc/v5TmKXZUpmgAGJv/En9OvBQKPw8klC9qo91enbdJ5KVBeCAFKChZ7a3jTwvY8xTNMnP0MTlJCYZSwHCz4Kc/niBrFitqFtLmrMVOm1zzKC9tHcfWS1VQ53XmfjxIr6dzBkuIBBglzJkfbXFxVx4amJTjcE66FeSkwfUz0ocCpBH/d9ea8axSKn/JiweX6N0JJBIijeJ6etB4gEEgEV7etwmdITFHuNAlzExO5FwGnxs3LL6XVn3+QVByd/8l2ip3/YRoRQV/h0awhFkKwccFS3tzcDlJORMfMS4FpQ0hJtcPFezrX532mUOykh6ESTyIvmQAHCPASvXnvf3TNFvyaa/bn9T2PoCRcuWg5axta87yaCvgd+yg1JmsaMYGCh3gt63wbgI0Ll/CO9osQLse8FJgG7LgKoUkaPVXcuOwSvJqD3IEeJcrPebHk+0wrKPT7PMdYjujRhOSvlr+JeqfH3sYynVvMeZimycbGNi5qaM1bzlYofswLjJK/Q2iqmBYBhojxPZ7NEkuGMumqW8gNSy9CczgQQuZtXpjH5LCffikFzVW1vHfZJSz0VuftbzRRqae/9L6ddlj4vezOesbt+LkbO9azrLpxhg6nvXCQ5faVGpsWdnBpc3vB1cb7eJm99E3rftMenuMM8222Z0kBpaCrrpkb2tbid7rTjqF5KTA5MvMuSilpq2ngb7ouo8GdvytbofgqjzHd7SVleD4F/8IzxJjYqiyFoMrp5j2d61nf2IbQZHrlap4EhZG5S0EgMAXc3LGBi5va8jaAKBQPsI/jRa79F0JZBPQpxriLp/NMlCVVDXxk9WaqHZbrcp4EbwwhBMopuXbxaj606gpcUssT/wOE+RC/Lot6XaYZWnAnT3GMQBYJpBBsW7yST6zdAm5ndlj0DJJAKdBTqWOSpkHC0Av/mAYK69qZRObTr6SgzVPLNzbfRJXTXcDuV/wrfyFRJuuqjCqa5CP8puAnt625kmsXrgBHKshyhiWBEBBKRAklY5P+hJMxRuIRNCFmzHjN3qAm8GsuvrDxeurdvnSmlEw8Rzdf56ky3l/dUca2Ku7hFj7OFemK2/PXaCLK5/58Py8MdmNmnCRW0QMlUjGB1S4PS6sbphS3JxCEkzFOjE0EV1Yq3i/zeF0hBLVeP7et3syHV23C73TlDb6J4kr+FzsLeGBLr0NZCQCNeHiev6Mz46Bje5D3BU7zj88/wquBXmtzZYVJkHnuoK6mLtYFZOXhrTQBhACvx8uNHev59EXbWOitLhAJrfgCD/PPPMN0Nf9MlN1KDxDjY9yfdwS6QLC6fhG3r7+aNfUtKV23suah3YmaEOmtXFP5caVyClcq2ldktF0KgeZycX3bGj6+5koW+goP/n76+T47KefgQ4XcNNs5wSf5bd46gUtqbG5ZzifXbWVRTR1KVN4yECLjJsV+rwLIbKcUAuV2cM2iLu7YeD1t/rq8flAoAoyzjR8QK/FUkMlQIT+d4KfsZjv5Kd6dUuPt7ev46pveRa3Lg5kaH5WWCReuiWjvorbdvJrbxXXNK/kfW/+KBo+/4MOdwOAGfshwicu9b4SKOWoN4B3cywucLDjHX922iu9c9QHaqxoQmoaUMivA5EKByPiXfk8IfB4f716yjq9d8R7c0lFwvcRE8XkeZA/9FatfRT31cUxu4WepDYv52Lyok29svonLF7bj0uzl4wkSXEhEAEvSCSmp8/j46+WXcvv6t1rmXoHBVyi+wRN8n12VrVO5rYBCWEkjf+bTNBfIZK2bJoeD/fzy0C4e7XmNSDxmCcqMWlXUVKwgMm18KSTKIVno9nPbqrfw3uWX0OipKvg9heJ/s4tP8fuKt3xGCACKdmo5xheRBYSOiSIYG+e3R17kX/duZxwdaaisNCrnGwmynmgBaJINDW18dsPb2LBgCR4tf2cvWO38Pa/yfn5FcgbaPEMEAIsEdezi9oKSwMaLA93cuesRDkWHIZ5I+womSpm9RCg0oNKp4RCSWzsv5YuXvRNHgaTSNuwn/z/zhxkZfJhRAlhYRh2/58Osp7XAvGcN9Ugswo9e28EjJ/YxHItgmkY6RWuhufJcI9edm/oPt9PFusbFfLDrMq5ZsnrSXMUmim/wJF/jCSZPfVlezDgBwPIWPsRH2Ux7vuabyscfM5Ls7DvGwyf2srPvOIHxEEJKlJHt0TuXBMj05CkFQlo2rSYEXfXNXNXSxc2dG1la04BSFM53iCKBwed5MKXwzazie04IAFb+3Xt4H7dxGYKzm35D0TC7+o/zyIm9vBw4RTA+Tio/S8FEiZUmRG497RxCSIHL4aDNX89bW7q4bula1jS04NYck4r8ISLcwI94qYKm3mQ4ZwQAywZ9F138G7fh4eziUQF9kVEODJ/hyd6DPHfmKH2xEBgmmGriuDqV+73yNK3woKfu55A4HA66/I1ct3Qtb1m0nBV1Cwsu5uTW7QD9bOUHFXPyTAXnlAA2VtHIvdzKZtoLWglgBZtKIYjpSU6EAjzZs58HjrxIXyKSylKpEOaEjpCZIcx+XQyyHTcTr00U2Nm/TMWm5g7e27mRzYs6afRWpc8ommx/pIniDh7mu+wsKqdfJTArCADgRvIFruIrXIsT7SwmkiX27c4NJ+M8c/owDx9/hVeHegmZSZISjGQSUzdwSGkpj0qlc/UXytCZjsEXIms6sr2ThlJoLieaFDgSJov8tbyldQXvWbaedY2Ls04GeaOB30k3/5WH2clJZnq+L4RZQwALioX4uI8PsYVlZydCzpxqKsXpSJA9A90cCvZzfCzAmegYIaETSySIJePEEkmMVGp7WSDDpqmsc4kFApfTicvlwuty40KyQPPQUdPI4qoG1jW2sr6pjVqXd9I6ZbdKMUiEH/AX7uQJzFkw8DZmGQEmsIUlPMzHqcUzZZewbSYGYmECsQiD4yHrdzTEQDTEeDJO2EiinBq5G1aUqfCh4ZUOGr1VNLj9NHmraPD4WeCrptlXgysVI1CMi9pE8SCv8n5+WeSpvjODWUsAUHhxso0OfsEHacSXl6U07xuppzA9/6eWFnRlkjR0DGWim6aV1jYHVgJoK9GjU2o4NQfSNu/ExDSBeuOlYjvF9K94ma/xGMcJzgJvRWHMYgLYUDiQ3MI6Ps0mtrF8UrPxrKVkJHPMNx8ttthrUaUlcbb+jRLnJzzPz3gxtWlj9oj7QjgPCJAJk0tYxGfZxlaWsTwVdnYuVw0Vijg6u+jhAfag1CYNAAABCElEQVTxc3YzSoLZPvA2zjMCTEBgsIVOvsy1bKCVOjw4KX6OLgaZpmSIOKPE+AV7uJs/pfbnnx+DnonzlgCZcCHx4uBm1vFJNnEFS7GHS5tmyIPCMiElglFi/Bt7+TF/4TUGGMdMnc5x/g28jQuCABOwmlKDmxZqaKOGTupZwQJWsZAOGmihOktaTHxTMU6SAON0M8JRhjnKAIcYoocgvYzRRziVHOv8HfBcXGAEmAxmyiiQuJB4cOBKSQcTRQyDOAYGRuo6S9W80FFUtvDzGxPn9CUwSZzVKp/GeX7nIeZ3789xzBNgjmOeAHMc8wSY45gnwBzHPAHmOOYJMMcxT4A5jnkCzHH8f1BFL1d3IEP5AAAEcGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSfvu78nIGlkPSdXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQnPz4KPHg6eG1wbWV0YSB4bWxuczp4PSdhZG9iZTpuczptZXRhLyc+CjxyZGY6UkRGIHhtbG5zOnJkZj0naHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyc+CgogPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9JycKICB4bWxuczpBdHRyaWI9J2h0dHA6Ly9ucy5hdHRyaWJ1dGlvbi5jb20vYWRzLzEuMC8nPgogIDxBdHRyaWI6QWRzPgogICA8cmRmOlNlcT4KICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0nUmVzb3VyY2UnPgogICAgIDxBdHRyaWI6Q3JlYXRlZD4yMDIwLTExLTE5PC9BdHRyaWI6Q3JlYXRlZD4KICAgICA8QXR0cmliOkV4dElkPmRmMjI3YzkyLTY2MmQtNGI5Ny05N2QwLWFiNmQyYThmYjcwZTwvQXR0cmliOkV4dElkPgogICAgIDxBdHRyaWI6RmJJZD41MjUyNjU5MTQxNzk1ODA8L0F0dHJpYjpGYklkPgogICAgIDxBdHRyaWI6VG91Y2hUeXBlPjI8L0F0dHJpYjpUb3VjaFR5cGU+CiAgICA8L3JkZjpsaT4KICAgPC9yZGY6U2VxPgogIDwvQXR0cmliOkFkcz4KIDwvcmRmOkRlc2NyaXB0aW9uPgoKIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PScnCiAgeG1sbnM6ZGM9J2h0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvJz4KICA8ZGM6dGl0bGU+CiAgIDxyZGY6QWx0PgogICAgPHJkZjpsaSB4bWw6bGFuZz0neC1kZWZhdWx0Jz7mnKrlkb3lkI0g55qE6KSH5pysPC9yZGY6bGk+CiAgIDwvcmRmOkFsdD4KICA8L2RjOnRpdGxlPgogPC9yZGY6RGVzY3JpcHRpb24+CgogPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9JycKICB4bWxuczpwZGY9J2h0dHA6Ly9ucy5hZG9iZS5jb20vcGRmLzEuMy8nPgogIDxwZGY6QXV0aG9yPkhzdWFuIExlZTwvcGRmOkF1dGhvcj4KIDwvcmRmOkRlc2NyaXB0aW9uPgoKIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PScnCiAgeG1sbnM6eG1wPSdodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvJz4KICA8eG1wOkNyZWF0b3JUb29sPkNhbnZhPC94bXA6Q3JlYXRvclRvb2w+CiA8L3JkZjpEZXNjcmlwdGlvbj4KPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KPD94cGFja2V0IGVuZD0ncic/PolbVtwAAAAASUVORK5CYII="},{"name":"AVAX","address":"0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7","logo_url":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/avalanchex/info/logo.png/quality=85"}]');
;// CONCATENATED MODULE: ./packages/web3-providers/src/Cloudflare/index.ts




class CloudflareAPI {
    async getFungibleTokenIconURLs(chainId, address) {
        const { NATIVE_TOKEN_ASSET_BASE_URI = constants/* EMPTY_LIST */.rP, ERC20_TOKEN_ASSET_BASE_URI = constants/* EMPTY_LIST */.rP } = (0,constants_constants/* getTokenAssetBaseURLConstants */.ed)(chainId);
        const formattedAddress = (0,formatter/* formatEthereumAddress */.j8)(address);
        if ((0,helpers_address/* isNativeTokenAddress */.qw)(formattedAddress)) {
            return NATIVE_TOKEN_ASSET_BASE_URI?.map((x)=>`${x}/info/logo.png/public`);
        }
        const specialIcon = TokenIconSpecialIconList_namespaceObject.find((0,isSameAddress/* currySameAddress */.D)(address));
        if (specialIcon) return [
            specialIcon.logo_url
        ];
        // load from remote
        return ERC20_TOKEN_ASSET_BASE_URI.map((x)=>`${x}/${formattedAddress}/logo.png/quality=85`);
    }
}
const Cloudflare = new CloudflareAPI();

// EXTERNAL MODULE: ./packages/web3-providers/src/CoinGecko/apis/PriceAPI_EVM.ts
var PriceAPI_EVM = __webpack_require__(93233);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/unionWith.js
var unionWith = __webpack_require__(48740);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/uniq.js
var uniq = __webpack_require__(405);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/number.ts
var number = __webpack_require__(29763);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/formatBalance.ts
var formatBalance = __webpack_require__(95325);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/ContractReadonlyAPI.ts + 9 modules
var ContractReadonlyAPI = __webpack_require__(61871);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/apis/FungibleTokenAPI.ts






class FungibleTokenAPI {
    Contract = new ContractReadonlyAPI/* ContractReadonlyAPI */.M();
    createContract(chainId) {
        const address = (0,constants_constants/* getEthereumConstant */.wB)(chainId, 'BALANCE_CHECKER_ADDRESS');
        if (!address) throw new Error('Failed to create balance checker contract.');
        const contract = this.Contract.getBalanceCheckerContract(address, {
            chainId
        });
        if (!contract) throw new Error('Failed to create balance checker contract.');
        return contract;
    }
    async createAssets(fungibleToken, chainId, balance) {
        const price = await PriceAPI_EVM/* CoinGeckoPriceEVM */.O.getFungibleTokenPrice(chainId, fungibleToken.address);
        return {
            ...fungibleToken,
            balance: balance.toFixed(),
            price: {
                [specs/* CurrencyType */.V2.USD]: (0,number/* toFixed */.FH)(price)
            },
            value: {
                [specs/* CurrencyType */.V2.USD]: (0,number/* multipliedBy */.$q)(price ?? 0, (0,formatBalance/* formatBalance */.a)(balance, fungibleToken.decimals)).toFixed()
            }
        };
    }
    async getTrustedAssets(address, trustedFungibleTokens, options) {
        if (!trustedFungibleTokens) return (0,Pageable/* createPageable */.LI)(constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(options?.indicator));
        const chains = (0,uniq/* default */.Z)(trustedFungibleTokens.map((x)=>x.chainId));
        let result = constants/* EMPTY_LIST */.rP;
        for (const chainId of chains){
            const contract = this.createContract(chainId);
            if (!contract) return (0,Pageable/* createPageable */.LI)(constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(options?.indicator));
            const balances = await contract.methods.balances([
                address
            ], trustedFungibleTokens.map((x)=>x.address)).call();
            const requests = balances.map((x, i)=>{
                if (!trustedFungibleTokens[i]) return;
                return this.createAssets(trustedFungibleTokens[i], chainId, Number.parseInt(x, 10));
            }).filter(Boolean);
            const assets = (await Promise.allSettled(requests)).map((x)=>x.status === 'fulfilled' ? x.value : undefined).filter(Boolean);
            result = [
                ...result,
                ...assets
            ];
        }
        return (0,Pageable/* createPageable */.LI)(result, (0,Pageable/* createIndicator */.sz)(options?.indicator));
    }
}

// EXTERNAL MODULE: ./packages/web3-providers/src/DeBank/helpers.ts
var DeBank_helpers = __webpack_require__(11678);
// EXTERNAL MODULE: ./packages/web3-providers/src/DeBank/constants.ts
var DeBank_constants = __webpack_require__(10663);
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/fetchCached.ts
var fetchCached = __webpack_require__(22674);
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/fetchJSON.ts
var fetchJSON = __webpack_require__(11834);
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/getNativeAssets.ts
var getNativeAssets = __webpack_require__(89178);
;// CONCATENATED MODULE: ./packages/web3-providers/src/DeBank/apis/FungibleTokenAPI.ts










class DeBankFungibleTokenAPI {
    FungibleToken = new FungibleTokenAPI();
    async getAssets(address, options) {
        const result = (await (0,fetchJSON/* fetchCachedJSON */.MP)((0,dist/* default */.ZP)(DeBank_constants/* DEBANK_OPEN_API */.$1, '/v1/user/all_token_list', {
            id: address,
            is_all: true
        }), undefined, {
            cacheDuration: fetchCached/* Duration */.nL.TEN_SECONDS
        }))?.filter((x)=>x.is_verified);
        return (0,Pageable/* createPageable */.LI)((0,unionWith/* default */.Z)((0,DeBank_helpers/* formatAssets */.y5)((result ?? []).map((x)=>{
            const isEther = [
                'arb',
                'aurora'
            ].includes(x.chain) && [
                'ETH',
                'AETH'
            ].includes(x.name);
            return {
                ...x,
                name: isEther ? 'ETH' : x.name,
                symbol: isEther ? 'ETH' : x.symbol,
                logo_url: isEther ? 'https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/ethereum/info/logo.png/quality=85' : x.logo_url
            };
        })), (0,getNativeAssets/* getNativeAssets */.s)(), (a, z)=>(0,isSameAddress/* isSameAddress */.W)(a.address, z.address) && a.chainId === z.chainId), (0,Pageable/* createIndicator */.sz)(options?.indicator));
    }
    async getTrustedAssets(address, trustedFungibleTokens, options) {
        const trustTokenAssets = await this.FungibleToken.getTrustedAssets(address, trustedFungibleTokens, options);
        return (0,Pageable/* createPageable */.LI)((0,unionWith/* default */.Z)(trustTokenAssets.data, (0,getNativeAssets/* getNativeAssets */.s)(), (a, z)=>(0,isSameAddress/* isSameAddress */.W)(a.address, z.address) && a.chainId === z.chainId), (0,Pageable/* createIndicator */.sz)(options?.indicator));
    }
}
const DeBankFungibleToken = new DeBankFungibleTokenAPI();

// EXTERNAL MODULE: ./packages/web3-providers/src/GoPlusLabs/index.ts
var GoPlusLabs = __webpack_require__(36541);
// EXTERNAL MODULE: ./packages/web3-providers/src/R2D2/apis/TokenListAPI.ts
var TokenListAPI = __webpack_require__(16658);
// EXTERNAL MODULE: ./packages/web3-providers/src/Rabby/index.ts + 1 modules
var Rabby = __webpack_require__(70451);
// EXTERNAL MODULE: ./packages/web3-providers/src/Zerion/index.ts + 3 modules
var Zerion = __webpack_require__(1599);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/apis/HubFungibleAPI.ts















class HubFungibleAPI extends apis_HubFungibleAPI/* HubFungibleAPI_Base */.L {
    Approval = new Approval/* ApprovalAPI */.s();
    HubOptions = new HubOptionsAPI/* HubOptionsAPI */.u(this.options);
    Web3 = new ConnectionReadonlyAPI/* ConnectionReadonlyAPI */.S();
    getProviders(initial) {
        const { indicator } = this.HubOptions.fill(initial);
        // only the first page is available
        if ((indicator?.index ?? 0) > 0) return [];
        return this.getPredicateProviders({
            [specs/* SourceType */.PO.Chainbase]: ChainbaseFungibleToken,
            [specs/* SourceType */.PO.DeBank]: DeBankFungibleToken,
            [specs/* SourceType */.PO.Zerion]: Zerion/* Zerion */.KN,
            [specs/* SourceType */.PO.GoPlus]: GoPlusLabs/* GoPlusAuthorization */.x,
            [specs/* SourceType */.PO.Rabby]: Rabby/* Rabby */.C,
            [specs/* SourceType */.PO.Approval]: this.Approval,
            [specs/* SourceType */.PO.R2D2]: TokenListAPI/* R2D2TokenList */.m,
            [specs/* SourceType */.PO.CF]: Cloudflare,
            [specs/* SourceType */.PO.CoinGecko]: PriceAPI_EVM/* CoinGeckoPriceEVM */.O
        }, [
            DeBankFungibleToken,
            this.Approval,
            Zerion/* Zerion */.KN,
            ChainbaseFungibleToken,
            Rabby/* Rabby */.C,
            GoPlusLabs/* GoPlusAuthorization */.x,
            TokenListAPI/* R2D2TokenList */.m,
            Cloudflare,
            PriceAPI_EVM/* CoinGeckoPriceEVM */.O
        ], initial);
    }
    getFungibleToken(address, initial) {
        const networks = Web3StateAPI.Web3StateRef.value?.Network?.networks?.getCurrentValue();
        const currentNetwork = initial?.chainId ? networks?.find((x)=>x.chainId === initial.chainId) : Web3StateAPI.Web3StateRef.value?.Network?.network?.getCurrentValue();
        return (0,attemptUntil/* attemptUntil */.C)([
            ()=>Web3StateAPI.Web3StateRef.value?.Token?.createFungibleToken?.(initial?.chainId ?? types/* ChainId */.a_.Mainnet, address),
            ()=>this.Web3.getFungibleToken(address, {
                    ...initial,
                    providerURL: currentNetwork?.isCustomized ? currentNetwork?.rpcUrl : undefined
                })
        ], undefined);
    }
}


/***/ }),

/***/ 85407:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  D: () => (/* binding */ HubNonFungibleAPI)
});

// EXTERNAL MODULE: ./packages/web3-shared/base/src/specs/index.ts
var specs = __webpack_require__(62649);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/types/index.ts
var types = __webpack_require__(24770);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Base/apis/HubNonFungibleAPI.ts
var apis_HubNonFungibleAPI = __webpack_require__(18391);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/HubOptionsAPI.ts
var HubOptionsAPI = __webpack_require__(40850);
// EXTERNAL MODULE: ./node_modules/.pnpm/urlcat@3.1.0_patch_hash=5r5xyq4zgcnqugwsrx4lxq2i4e/node_modules/urlcat/dist/index.mjs
var dist = __webpack_require__(78757);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/head.js
var head = __webpack_require__(81755);
// EXTERNAL MODULE: ./packages/shared-base/src/Pageable/index.ts
var Pageable = __webpack_require__(38645);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/resolver.ts
var resolver = __webpack_require__(53007);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/resolveImageURL.ts
var resolveImageURL = __webpack_require__(81438);
// EXTERNAL MODULE: ./packages/web3-providers/src/Alchemy/constants.ts
var constants = __webpack_require__(37803);
// EXTERNAL MODULE: ./packages/web3-providers/src/Alchemy/helpers.ts
var helpers = __webpack_require__(72642);
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/fetchJSON.ts
var fetchJSON = __webpack_require__(11834);
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/getAssetFullName.ts
var getAssetFullName = __webpack_require__(28289);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Alchemy/apis/EVM.ts









function createNonFungibleTokenLink(chainId, address, tokenId) {
    if (chainId === types/* ChainId */.a_.Matic) {
        return (0,dist/* default */.ZP)('https://opensea.io/assets/matic/:address/:tokenId', {
            address,
            tokenId
        });
    }
    return (0,dist/* default */.ZP)('https://opensea.io/assets/:address/:tokenId', {
        address,
        tokenId
    });
}
function createNonFungibleToken(chainId, asset) {
    const contractAddress = asset.contract.address;
    const tokenId = (0,helpers/* formatAlchemyTokenId */.d)(asset.id.tokenId);
    const imageURL = asset.metadata.image || asset.metadata.image_url || asset.media?.[0]?.gateway || asset.metadata.animation_url;
    const mediaURL = asset.media?.[0]?.gateway || asset.media?.[0]?.raw || asset.metadata.image_url || asset.metadata.image;
    const name = (0,getAssetFullName/* getAssetFullName */.q)(asset.contract.address, asset.metadata.name || asset.title, asset.metadata.name || asset.title, tokenId);
    return {
        id: `${contractAddress}_${tokenId}`,
        chainId,
        type: specs/* TokenType */.iv.NonFungible,
        schema: asset.id?.tokenMetadata?.tokenType === 'ERC721' ? types/* SchemaType */.XQ.ERC721 : types/* SchemaType */.XQ.ERC1155,
        tokenId,
        address: contractAddress,
        link: createNonFungibleTokenLink(chainId, contractAddress, tokenId),
        metadata: {
            chainId,
            name,
            description: asset.metadata.description || asset.description,
            imageURL: (0,resolveImageURL/* resolveImageURL */.y)((0,resolver/* resolveResourceURL */.Bl)(decodeURIComponent(imageURL)), name, contractAddress),
            mediaURL: (0,resolver/* resolveResourceURL */.Bl)(decodeURIComponent(mediaURL))
        },
        contract: {
            chainId,
            schema: asset.id?.tokenMetadata.tokenType === 'ERC721' ? types/* SchemaType */.XQ.ERC721 : types/* SchemaType */.XQ.ERC1155,
            address: contractAddress,
            name: asset.metadata.name || asset.title,
            symbol: ''
        },
        collection: {
            address: contractAddress,
            chainId,
            name: asset.metadata.name || asset.title,
            slug: '',
            description: asset.metadata.description || asset.description
        },
        source: specs/* SourceType */.PO.Alchemy_EVM
    };
}
function createNonFungibleAsset(chainId, metaDataResponse, contractMetadataResponse, ownersResponse) {
    const tokenId = (0,helpers/* formatAlchemyTokenId */.d)(metaDataResponse.id.tokenId);
    const contractName = contractMetadataResponse?.contractMetadata.name || metaDataResponse.metadata?.name || '';
    const name = (0,getAssetFullName/* getAssetFullName */.q)(metaDataResponse.contract?.address, contractName, metaDataResponse.title, tokenId);
    return {
        id: `${metaDataResponse.contract.address}_${tokenId}`,
        chainId,
        type: specs/* TokenType */.iv.NonFungible,
        schema: metaDataResponse.id?.tokenMetadata?.tokenType === 'ERC721' ? types/* SchemaType */.XQ.ERC721 : types/* SchemaType */.XQ.ERC1155,
        tokenId,
        address: metaDataResponse.contract?.address,
        metadata: {
            chainId,
            name,
            symbol: contractMetadataResponse?.contractMetadata?.symbol ?? '',
            description: metaDataResponse.description,
            imageURL: (0,resolveImageURL/* resolveImageURL */.y)(decodeURIComponent(metaDataResponse.metadata?.image || metaDataResponse.media?.[0]?.gateway || metaDataResponse.media?.[0]?.raw), name, metaDataResponse.contract?.address),
            mediaURL: decodeURIComponent(metaDataResponse.media?.[0]?.gateway)
        },
        contract: {
            chainId,
            schema: metaDataResponse.id?.tokenMetadata?.tokenType === 'ERC721' ? types/* SchemaType */.XQ.ERC721 : types/* SchemaType */.XQ.ERC1155,
            address: metaDataResponse.contract?.address,
            name: contractName,
            symbol: contractMetadataResponse?.contractMetadata?.symbol ?? ''
        },
        collection: {
            chainId,
            name: contractName,
            slug: contractMetadataResponse?.contractMetadata?.symbol || '',
            description: metaDataResponse.description
        },
        link: createNonFungibleTokenLink(chainId, metaDataResponse.contract?.address, metaDataResponse.id?.tokenId),
        owner: {
            address: (0,head/* default */.Z)(ownersResponse?.owners)
        },
        traits: metaDataResponse.metadata?.traits?.map((x)=>({
                type: x.trait_type,
                value: x.value
            })),
        source: specs/* SourceType */.PO.Alchemy_EVM
    };
}
class AlchemyEVM_API {
    async getAsset(address, tokenId, { chainId = types/* ChainId */.a_.Mainnet } = {}) {
        const chainInfo = constants/* Alchemy_EVM_NetworkMap */.mp.chains.find((chain)=>chain.chainId === chainId);
        if (!chainInfo) return;
        const allSettled = await Promise.allSettled([
            (0,fetchJSON/* fetchJSON */.ZV)((0,dist/* default */.ZP)(`${chainInfo.baseURL}/getNFTMetadata`, {
                contractAddress: address,
                tokenId,
                tokenType: 'ERC721'
            })),
            (0,fetchJSON/* fetchJSON */.ZV)((0,dist/* default */.ZP)(`${chainInfo.contractMetadataURL}/getContractMetadata`, {
                contractAddress: address
            })),
            (0,fetchJSON/* fetchJSON */.ZV)((0,dist/* default */.ZP)(`${chainInfo.tokenOwnerURL}/getOwnersForToken`, {
                contractAddress: address,
                tokenId
            }))
        ]);
        const [metadataResponse, contractMetadataResponse, ownersResponse] = allSettled.map((x)=>x.status === 'fulfilled' ? x.value : undefined);
        if (!metadataResponse || metadataResponse.error || !ownersResponse) return;
        return createNonFungibleAsset(chainId, metadataResponse, contractMetadataResponse, ownersResponse);
    }
    async getAssets(from, { chainId = types/* ChainId */.a_.Mainnet, indicator } = {}) {
        const chainInfo = constants/* Alchemy_EVM_NetworkMap */.mp.chains.find((chain)=>chain.chainId === chainId);
        if (!chainInfo) return (0,Pageable/* createPageable */.LI)([], (0,Pageable/* createIndicator */.sz)(indicator, ''));
        const response = await (0,fetchJSON/* fetchJSON */.ZV)((0,dist/* default */.ZP)(`${chainInfo.baseURL}/getNFTs/`, {
            owner: from,
            pageKey: typeof indicator?.index !== 'undefined' && indicator.index !== 0 ? indicator.id : undefined
        }));
        const assets = response.ownedNfts.map((nft)=>createNonFungibleToken(chainId, nft));
        return (0,Pageable/* createPageable */.LI)(assets, (0,Pageable/* createIndicator */.sz)(indicator), response.pageKey ? (0,Pageable/* createNextIndicator */.gT)(indicator, response.pageKey) : undefined);
    }
}
const AlchemyEVM = new AlchemyEVM_API();

// EXTERNAL MODULE: ./packages/web3-providers/src/Approval/index.ts + 2 modules
var Approval = __webpack_require__(39874);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/number.ts
var number = __webpack_require__(29763);
// EXTERNAL MODULE: ./packages/shared-base/src/constants.ts
var src_constants = __webpack_require__(52033);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/isValidChainId.ts
var isValidChainId = __webpack_require__(37049);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/constants/primitives.ts
var primitives = __webpack_require__(47469);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/ResolverAPI.ts
var ResolverAPI = __webpack_require__(66979);
// EXTERNAL MODULE: ./packages/web3-providers/src/Chainbase/helpers.ts
var Chainbase_helpers = __webpack_require__(58021);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Chainbase/apis/NonFungibleTokenAPI.ts






class ChainbaseNonFungibleTokenAPI {
    createNonFungibleTokenPermalink(chainId, address, tokenId) {
        if (chainId === types/* ChainId */.a_.Mainnet || chainId === types/* ChainId */.a_.Matic) {
            return (0,dist/* default */.ZP)('https://opensea.com/:protocol/:contract/:tokenId', {
                contract: address,
                tokenId,
                protocol: chainId === types/* ChainId */.a_.Mainnet ? 'ethereum' : 'matic'
            });
        }
        return ResolverAPI/* ExplorerResolver */.Xz.addressLink(chainId, address);
    }
    createNonFungibleTokenAssetFromNFT(chainId, nft) {
        return {
            chainId,
            id: `${chainId}_${nft.contract_address}_${nft.token_id}`,
            type: specs/* TokenType */.iv.NonFungible,
            schema: nft.contract_type === 'ERC1155' ? types/* SchemaType */.XQ.ERC1155 : types/* SchemaType */.XQ.ERC721,
            address: nft.contract_address,
            tokenId: nft.token_id,
            owner: {
                address: nft.owner
            },
            contract: {
                chainId,
                schema: nft.contract_type === 'ERC1155' ? types/* SchemaType */.XQ.ERC1155 : types/* SchemaType */.XQ.ERC721,
                address: nft.contract_address,
                name: nft.contract_name,
                symbol: nft.contract_symbol,
                owner: nft.owner
            },
            metadata: {
                chainId,
                name: nft.contract_name,
                symbol: nft.contract_symbol
            },
            source: specs/* SourceType */.PO.Chainbase
        };
    }
    createNonFungibleAssetFromNFTMetadata(chainId, address, tokenId, metadata) {
        return {
            chainId,
            type: specs/* TokenType */.iv.NonFungible,
            id: `${chainId}_${metadata.contract_address}_${metadata.token_id}`,
            schema: types/* SchemaType */.XQ.ERC721,
            address,
            tokenId,
            link: this.createNonFungibleTokenPermalink(chainId, address, tokenId),
            source: specs/* SourceType */.PO.Chainbase
        };
    }
    createNonFungibleContractFromNFTMetadata(chainId, address, metadata) {
        return {
            chainId,
            address,
            name: metadata.name,
            symbol: metadata.symbol,
            schema: types/* SchemaType */.XQ.ERC721,
            owner: metadata.owner,
            source: specs/* SourceType */.PO.Chainbase
        };
    }
    createNonFungibleCollectionFromNFT(chainId, nft) {
        return {
            chainId,
            schema: nft.contract_type === 'ERC1155' ? types/* SchemaType */.XQ.ERC1155 : types/* SchemaType */.XQ.ERC721,
            name: nft.contract_name,
            symbol: nft.contract_symbol,
            slug: nft.contract_symbol,
            address: nft.contract_address,
            source: specs/* SourceType */.PO.Chainbase
        };
    }
    createNonFungibleTokenEventFromNFT_TransferEvent(chainId, address, event) {
        return {
            chainId,
            id: event.transaction_hash,
            quantity: '1',
            type: specs/* ActivityType */.T8.Transfer,
            assetPermalink: this.createNonFungibleTokenPermalink(chainId, address, event.token_id),
            hash: event.transaction_hash,
            timestamp: new Date(event.block_timestamp).getTime(),
            from: {
                address: event.from_address
            },
            to: {
                address: event.to_address
            },
            source: specs/* SourceType */.PO.Chainbase
        };
    }
    async getFloorPrice(address, tokenId, { chainId = types/* ChainId */.a_.Mainnet } = {}) {
        if (!(0,isValidChainId/* isValidChainId */.J)(chainId)) return;
        const floorPrice = await (0,Chainbase_helpers/* fetchFromChainbase */.Dc)((0,dist/* default */.ZP)('/v1/nft/floor_price', {
            chain_id: chainId,
            contract_address: address
        }));
        if (!floorPrice) return;
        const nativeToken = ResolverAPI/* ChainResolver */.iv.nativeCurrency(chainId);
        return {
            amount: (0,number/* scale10 */.SI)(floorPrice.floor_price, nativeToken.decimals).toFixed(0),
            token: nativeToken
        };
    }
    async getOwner(address, tokenId, { chainId = types/* ChainId */.a_.Mainnet } = {}) {
        if (!(0,isValidChainId/* isValidChainId */.J)(chainId)) return primitives/* ZERO_ADDRESS */.r;
        const owner = await (0,Chainbase_helpers/* fetchFromChainbase */.Dc)((0,dist/* default */.ZP)('/v1/nft/owner', {
            chain_id: chainId,
            contract_address: address,
            token_id: tokenId
        }));
        return owner ?? primitives/* ZERO_ADDRESS */.r;
    }
    async getAsset(address, tokenId, { chainId = types/* ChainId */.a_.Mainnet } = {}) {
        if (!(0,isValidChainId/* isValidChainId */.J)(chainId)) return;
        const metadata = await (0,Chainbase_helpers/* fetchFromChainbase */.Dc)((0,dist/* default */.ZP)('/v1/nft/metadata', {
            chain_id: chainId,
            contract_address: address.toLowerCase(),
            token_id: tokenId
        }));
        if (!metadata) return;
        return this.createNonFungibleAssetFromNFTMetadata(chainId, address, tokenId, metadata);
    }
    async getAssets(account, { chainId = types/* ChainId */.a_.Mainnet, indicator } = {}) {
        if (!(0,isValidChainId/* isValidChainId */.J)(chainId)) return (0,Pageable/* createPageable */.LI)(src_constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        const tokens = await (0,Chainbase_helpers/* fetchFromChainbase */.Dc)((0,dist/* default */.ZP)('/v1/account/nfts', {
            chain_id: chainId,
            address: account.toLowerCase(),
            page: (indicator?.index ?? 0) + 1
        }));
        if (!tokens) return (0,Pageable/* createPageable */.LI)(src_constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        const assets = tokens.map((x)=>this.createNonFungibleTokenAssetFromNFT(chainId, x));
        return (0,Pageable/* createPageable */.LI)(assets, (0,Pageable/* createIndicator */.sz)(indicator), assets.length ? (0,Pageable/* createNextIndicator */.gT)(indicator) : undefined);
    }
    async getContract(address, { chainId = types/* ChainId */.a_.Mainnet } = {}) {
        if (!(0,isValidChainId/* isValidChainId */.J)(chainId)) return;
        const metadata = await (0,Chainbase_helpers/* fetchFromChainbase */.Dc)((0,dist/* default */.ZP)('/v1/nft/metadata', {
            chain_id: chainId,
            contract_address: address.toLowerCase(),
            token_id: 1
        }));
        if (!metadata) return;
        return this.createNonFungibleContractFromNFTMetadata(chainId, address, metadata);
    }
    async getEvents(address, tokenId, { chainId = types/* ChainId */.a_.Mainnet, indicator } = {}) {
        if (!(0,isValidChainId/* isValidChainId */.J)(chainId)) return (0,Pageable/* createPageable */.LI)(src_constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        const transferEvents = await (0,Chainbase_helpers/* fetchFromChainbase */.Dc)((0,dist/* default */.ZP)('/v1/nft/transfers', {
            chainId,
            contract_address: address,
            token_id: tokenId,
            page: (indicator?.index ?? 0) + 1
        }));
        if (!transferEvents?.length) return (0,Pageable/* createPageable */.LI)(src_constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        const events = transferEvents.map((x)=>this.createNonFungibleTokenEventFromNFT_TransferEvent(chainId, address, x));
        return (0,Pageable/* createPageable */.LI)(events, (0,Pageable/* createIndicator */.sz)(indicator), events.length ? (0,Pageable/* createNextIndicator */.gT)(indicator) : undefined);
    }
}
const ChainbaseNonFungibleToken = new ChainbaseNonFungibleTokenAPI();

// EXTERNAL MODULE: ./packages/shared-base/src/helpers/createLookupTableResolver.ts
var createLookupTableResolver = __webpack_require__(74170);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Gem/constants.ts

const GEM_API_URL = 'https://gem-proxy.r2d2.to/';
const RARITY_SOURCE_TYPE = [
    specs/* SourceType */.PO.Gem,
    specs/* SourceType */.PO.RaritySniper,
    specs/* SourceType */.PO.TraitSniper
];

;// CONCATENATED MODULE: ./packages/web3-providers/src/Gem/index.ts





const resolveRarityId = (0,createLookupTableResolver/* createLookupTableResolver */.F)({
    [specs/* SourceType */.PO.Gem]: 'gem',
    [specs/* SourceType */.PO.RaritySniper]: 'rarity_sniper',
    [specs/* SourceType */.PO.TraitSniper]: 'trait_sniper'
}, '');
async function fetchFromGem(pathname, init) {
    const { data } = await (0,fetchJSON/* fetchCachedJSON */.MP)((0,dist/* default */.ZP)(GEM_API_URL, pathname), init, {
        squashExpiration: 0
    });
    return data;
}
class GemAPI {
    async getRarity(address, tokenId) {
        const response = await fetchFromGem((0,dist/* default */.ZP)('/rarity/:address/:tokenId', {
            address: address.toLowerCase(),
            tokenId: tokenId.toLowerCase()
        }));
        if (!response) return;
        for (const sourceType of RARITY_SOURCE_TYPE){
            const rarity = response[resolveRarityId(sourceType)];
            if (rarity) return rarity;
        }
        return;
    }
}
const Gem = new GemAPI();

// EXTERNAL MODULE: ./packages/web3-providers/src/GoPlusLabs/index.ts
var GoPlusLabs = __webpack_require__(36541);
;// CONCATENATED MODULE: ./packages/web3-providers/src/NFTScan/types/EVM.ts
var EVM;
(function(EVM) {
    let /** mime type */ ErcType;
    (function(ErcType) {
        ErcType["ERC721"] = 'erc721';
        ErcType["ERC1155"] = 'erc1155';
    })(ErcType = EVM.ErcType || (EVM.ErcType = {}));
})(EVM || (EVM = {}));

// EXTERNAL MODULE: ./packages/web3-providers/src/NFTScan/helpers/EVM.ts
var helpers_EVM = __webpack_require__(68208);
;// CONCATENATED MODULE: ./packages/web3-providers/src/NFTScan/apis/NonFungibleTokenAPI_EVM.ts





class NFTScanNonFungibleTokenAPI_EVM {
    async getAsset(address, tokenId, { chainId = types/* ChainId */.a_.Mainnet } = {}) {
        if (!(0,isValidChainId/* isValidChainId */.J)(chainId)) return;
        const path = (0,dist/* default */.ZP)('/api/v2/assets/:address/:token_id', {
            address,
            contract_address: address,
            token_id: tokenId,
            show_attribute: true
        });
        const response = await (0,helpers_EVM/* fetchFromNFTScanV2 */.kB)(chainId, path);
        if (!response?.data) return;
        const collection = await this.getCollectionRaw(response.data.contract_address, {
            chainId
        });
        return (0,helpers_EVM/* createNonFungibleAsset */.HN)(chainId, response.data, collection);
    }
    async getAssets(account, { chainId = types/* ChainId */.a_.Mainnet, indicator, size = 20 } = {}) {
        if (!(0,isValidChainId/* isValidChainId */.J)(chainId)) return (0,Pageable/* createPageable */.LI)(src_constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        const path = (0,dist/* default */.ZP)('/api/v2/account/own/all/:from', {
            from: account,
            show_attribute: true
        });
        const response = await (0,helpers_EVM/* fetchFromNFTScanV2 */.kB)(chainId, path);
        const assets = response?.data?.flatMap((x)=>x.assets.map((y)=>(0,helpers_EVM/* createNonFungibleAsset */.HN)(chainId, y, x)));
        return (0,Pageable/* createPageable */.LI)(assets ?? src_constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
    }
    async getAssetsByCollection(address, { chainId = types/* ChainId */.a_.Mainnet, indicator, size = 20 } = {}) {
        if (!(0,isValidChainId/* isValidChainId */.J)(chainId) || !address) return (0,Pageable/* createPageable */.LI)(src_constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        const path = (0,dist/* default */.ZP)('/api/v2/assets/:address', {
            address,
            contract_address: address,
            show_attribute: true,
            limit: size,
            cursor: indicator?.id
        });
        const response = await (0,helpers_EVM/* fetchFromNFTScanV2 */.kB)(chainId, path);
        const assets = response?.data?.content.map((x)=>(0,helpers_EVM/* createNonFungibleAsset */.HN)(chainId, x)) ?? src_constants/* EMPTY_LIST */.rP;
        return (0,Pageable/* createPageable */.LI)(assets, (0,Pageable/* createIndicator */.sz)(indicator), response?.data.next ? (0,Pageable/* createNextIndicator */.gT)(indicator, response?.data.next) : undefined);
    }
    async getCollectionsByOwner(account, { chainId = types/* ChainId */.a_.Mainnet, indicator } = {}) {
        if (!(0,isValidChainId/* isValidChainId */.J)(chainId)) return (0,Pageable/* createPageable */.LI)(src_constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        const path = (0,dist/* default */.ZP)('/api/v2/account/own/all/:from', {
            from: account,
            erc_type: EVM.ErcType.ERC721,
            show_attribute: true
        });
        const response = await (0,helpers_EVM/* fetchFromNFTScanV2 */.kB)(chainId, path);
        const collections = response?.data.map((x)=>(0,helpers_EVM/* createNonFungibleCollectionFromGroup */.X0)(chainId, x)) ?? src_constants/* EMPTY_LIST */.rP;
        return (0,Pageable/* createPageable */.LI)(collections, (0,Pageable/* createIndicator */.sz)(indicator));
    }
    async getCollectionRaw(address, { chainId = types/* ChainId */.a_.Mainnet } = {}) {
        if (!(0,isValidChainId/* isValidChainId */.J)(chainId)) return;
        const path = (0,dist/* default */.ZP)('/api/v2/collections/:address', {
            address
        });
        const response = await (0,helpers_EVM/* fetchFromNFTScanV2 */.kB)(chainId, path);
        return response?.data;
    }
    async getCollection(address, { chainId = types/* ChainId */.a_.Mainnet } = {}) {
        const rawCollection = await this.getCollectionRaw(address, {
            chainId
        });
        if (!rawCollection) return;
        return (0,helpers_EVM/* createNonFungibleCollectionFromCollection */.NW)(chainId, rawCollection);
    }
    async getContract(address, { chainId = types/* ChainId */.a_.Mainnet } = {}) {
        const path = (0,dist/* default */.ZP)('/api/v2/collections/:address', {
            address
        });
        const response = await (0,helpers_EVM/* fetchFromNFTScanV2 */.kB)(chainId, path);
        if (!response?.data) return;
        return (0,helpers_EVM/* createNonFungibleTokenContract */.Xi)(chainId, response.data);
    }
    async getEvents(address, tokenId, { chainId = types/* ChainId */.a_.Mainnet, indicator, size = 20 } = {}) {
        if (!(0,isValidChainId/* isValidChainId */.J)(chainId)) return (0,Pageable/* createPageable */.LI)(src_constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        const path = (0,dist/* default */.ZP)('/api/v2/transactions/:address/:tokenId', {
            address,
            tokenId,
            limit: size,
            cursor: indicator?.id
        });
        const response = await (0,helpers_EVM/* fetchFromNFTScanV2 */.kB)(chainId, path);
        const events = response?.data.content.map((x)=>(0,helpers_EVM/* createNonFungibleTokenEvent */.fE)(chainId, x)) ?? src_constants/* EMPTY_LIST */.rP;
        return (0,Pageable/* createPageable */.LI)(events, (0,Pageable/* createIndicator */.sz)(indicator), response?.data.next ? (0,Pageable/* createNextIndicator */.gT)(indicator, response?.data.next) : undefined);
    }
}
const NFTScanNonFungibleTokenEVM = new NFTScanNonFungibleTokenAPI_EVM();

// EXTERNAL MODULE: ./packages/web3-providers/src/OpenSea/index.ts + 3 modules
var OpenSea = __webpack_require__(65680);
// EXTERNAL MODULE: ./packages/web3-providers/src/R2D2/apis/TokenListAPI.ts
var TokenListAPI = __webpack_require__(16658);
// EXTERNAL MODULE: ./packages/web3-providers/src/Rabby/index.ts + 1 modules
var Rabby = __webpack_require__(70451);
// EXTERNAL MODULE: ./packages/web3-providers/src/SimpleHash/apis/EVM.ts + 1 modules
var apis_EVM = __webpack_require__(63087);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/last.js
var last = __webpack_require__(12113);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/address.ts
var helpers_address = __webpack_require__(65327);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/token.ts
var token = __webpack_require__(48289);
;// CONCATENATED MODULE: ./packages/web3-providers/src/X2Y2/constants.ts
const X2Y2_API_URL = 'https://x2y2-proxy.r2d2.to';
const X2Y2_PAGE_SIZE = 20;

// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/resolveActivityType.ts
var resolveActivityType = __webpack_require__(15219);
;// CONCATENATED MODULE: ./packages/web3-providers/src/X2Y2/index.ts









async function fetchFromX2Y2(pathname) {
    const response = await (0,fetchJSON/* fetchSquashedJSON */.Vn)((0,dist/* default */.ZP)(X2Y2_API_URL, pathname));
    // The `undefined` can be given a default value when deconstructed, but `null` can't.
    return response?.success ? [
        response.data ?? undefined,
        response.next
    ] : src_constants/* EMPTY_LIST */.rP;
}
class X2Y2API {
    createPermalink(address, tokenId) {
        return (0,dist/* default */.ZP)('https://x2y2.io/eth/:contract/:tokenId', {
            contract: address,
            tokenId
        });
    }
    createOrder(address, tokenId, order) {
        return {
            id: order.item_hash,
            chainId: types/* ChainId */.a_.Mainnet,
            assetPermalink: this.createPermalink(address, tokenId),
            quantity: '1',
            hash: order.item_hash,
            side: order.type === 'buy' ? specs/* OrderSide */.oU.Buy : specs/* OrderSide */.oU.Sell,
            maker: order.maker ? {
                address: order.maker
            } : undefined,
            taker: order.taker ? {
                address: order.taker
            } : undefined,
            createdAt: Number.parseInt(order.created_at, 10),
            expiredAt: Number.parseInt(order.end_at, 10),
            priceInToken: {
                amount: order.price,
                token: (0,helpers_address/* isZeroAddress */.uO)(order.currency) ? ResolverAPI/* ChainResolver */.iv.nativeCurrency(types/* ChainId */.a_.Mainnet) : (0,token/* createERC20Token */.wY)(types/* ChainId */.a_.Mainnet, order.currency)
            },
            source: specs/* SourceType */.PO.X2Y2
        };
    }
    createEvent(address, tokenId, event) {
        return {
            id: event.id.toString(),
            chainId: types/* ChainId */.a_.Mainnet,
            type: (0,resolveActivityType/* resolveActivityType */.G)(event.type),
            assetPermalink: this.createPermalink(address, tokenId),
            quantity: '1',
            hash: event.order.item_hash,
            from: {
                address: event.from_address
            },
            to: {
                address: event.to_address
            },
            timestamp: Number.parseInt(event.created_at, 10) * 1000,
            paymentToken: (0,helpers_address/* isZeroAddress */.uO)(event.order.currency) ? ResolverAPI/* ChainResolver */.iv.nativeCurrency(types/* ChainId */.a_.Mainnet) : (0,token/* createERC20Token */.wY)(types/* ChainId */.a_.Mainnet, event.order.currency),
            source: specs/* SourceType */.PO.X2Y2
        };
    }
    createContract(address, contract) {
        return {
            chainId: types/* ChainId */.a_.Mainnet,
            name: contract.name,
            symbol: contract.symbol,
            address,
            schema: contract.erc_type === 721 ? types/* SchemaType */.XQ.ERC721 : types/* SchemaType */.XQ.ERC1155
        };
    }
    async getOrders(address, tokenId, side, options) {
        const [data = src_constants/* EMPTY_LIST */.rP, next] = await fetchFromX2Y2((0,dist/* default */.ZP)('/v1/orders', {
            cursor: options?.indicator?.id,
            contract: address,
            token_id: tokenId,
            sort: 'created_at',
            direction: 'desc',
            limit: X2Y2_PAGE_SIZE
        }));
        const orders = data.filter((x)=>x.type === 'sell' && side === specs/* OrderSide */.oU.Sell || x.type === 'buy' && side === specs/* OrderSide */.oU.Buy).map((x)=>this.createOrder(address, tokenId, x));
        return (0,Pageable/* createPageable */.LI)(orders, (0,Pageable/* createIndicator */.sz)(options?.indicator), orders.length && next ? (0,Pageable/* createNextIndicator */.gT)(options?.indicator, next) : undefined);
    }
    async getOffers(address, tokenId, options) {
        const [data = src_constants/* EMPTY_LIST */.rP, next] = await fetchFromX2Y2((0,dist/* default */.ZP)('/v1/offers', {
            cursor: options?.indicator?.id,
            contract: address,
            token_id: tokenId,
            sort: 'created_at',
            direction: 'desc',
            limit: X2Y2_PAGE_SIZE
        }));
        const offers = data.filter((x)=>x.type === 'buy').map((x)=>this.createOrder(address, tokenId, x));
        return (0,Pageable/* createPageable */.LI)(offers, (0,Pageable/* createIndicator */.sz)(options?.indicator), offers.length && next ? (0,Pageable/* createNextIndicator */.gT)(options?.indicator, next) : undefined);
    }
    getListings(address, tokenId) {
        return this.getOrders(address, tokenId, specs/* OrderSide */.oU.Sell);
    }
    async getEvents(address, tokenId, options) {
        const cursors = options?.indicator?.id?.split('_');
        const listCursor = (0,head/* default */.Z)(cursors);
        const saleCursor = (0,last/* default */.Z)(cursors);
        const result = await Promise.all([
            listCursor || !options?.indicator?.index ? fetchFromX2Y2((0,dist/* default */.ZP)('/v1/events', {
                cursor: listCursor ?? '',
                contract: address,
                token_id: tokenId,
                // list, sale, cancel_listing
                type: 'list'
            })) : src_constants/* EMPTY_LIST */.rP,
            saleCursor || !options?.indicator?.index ? fetchFromX2Y2((0,dist/* default */.ZP)('/v1/events', {
                cursor: saleCursor ?? '',
                contract: address,
                token_id: tokenId,
                // list, sale, cancel_listing
                type: 'sale'
            })) : src_constants/* EMPTY_LIST */.rP
        ]);
        const [[listData = src_constants/* EMPTY_LIST */.rP, listNext], [saleData = src_constants/* EMPTY_LIST */.rP, saleNext]] = result;
        const data = [
            ...listData,
            ...saleData
        ];
        const next = `${listNext}_${saleNext}`;
        const events = data.map((x)=>this.createEvent(address, tokenId, x));
        return (0,Pageable/* createPageable */.LI)(events, (0,Pageable/* createIndicator */.sz)(options?.indicator), events.length && next ? (0,Pageable/* createNextIndicator */.gT)(options?.indicator, next) : undefined);
    }
    async getContract(address) {
        const [contract] = await fetchFromX2Y2((0,dist/* default */.ZP)('/v1/contracts/:contract', {
            contract: address
        }));
        if (!contract) return;
        return this.createContract(address, contract);
    }
}
const X2Y2 = new X2Y2API();

// EXTERNAL MODULE: ./packages/web3-providers/src/Zerion/index.ts + 3 modules
var Zerion = __webpack_require__(1599);
// EXTERNAL MODULE: ./node_modules/.pnpm/graphql-request@6.0.0_graphql@16.8.0/node_modules/graphql-request/build/esm/index.js + 6 modules
var esm = __webpack_require__(69400);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Zora/types.ts
var /* cspell:disable */ // e.g., 2021-09-07T11:48:32+00:00
EventType;
(function(EventType) {
    EventType["APPROVAL_EVENT"] = "APPROVAL_EVENT";
    EventType["LIL_NOUNS_AUCTION_EVENT"] = "LIL_NOUNS_AUCTION_EVENT";
    EventType["NOUNS_AUCTION_EVENT"] = "NOUNS_AUCTION_EVENT";
    EventType["SALE_EVENT"] = "SALE_EVENT";
    EventType["SEAPORT_EVENT"] = "SEAPORT_EVENT";
    EventType["MINT_EVENT"] = "MINT_EVENT";
    EventType["TRANSFER_EVENT"] = "TRANSFER_EVENT";
    EventType["V1_MARKET_EVENT"] = "V1_MARKET_EVENT";
    EventType["V2_AUCTION_EVENT"] = "V2_AUCTION_EVENT";
    EventType["V3_ASK_EVENT"] = "V3_ASK_EVENT";
    EventType["V3_RESERVE_AUCTION_EVENT"] = "V3_RESERVE_AUCTION_EVENT";
})(EventType || (EventType = {}));
var SaleType;
(function(SaleType) {
    SaleType["FOUNDATION_SALE"] = "FOUNDATION_SALE";
    SaleType["NOUNS_AUCTION_SALE"] = "NOUNS_AUCTION_SALE";
    SaleType["LIL_NOUNS_AUCTION_SALE"] = "LIL_NOUNS_AUCTION_SALE";
    SaleType["CRYPTOPUNKS_SALE"] = "CRYPTOPUNKS_SALE";
    SaleType["LOOKS_RARE_SALE"] = "LOOKS_RARE_SALE";
    SaleType["OPENSEA_SINGLE_SALE"] = "OPENSEA_SINGLE_SALE";
    SaleType["OPENSEA_BUNDLE_SALE"] = "OPENSEA_BUNDLE_SALE";
    SaleType["RARIBLE_SALE"] = "RARIBLE_SALE";
    SaleType["SEAPORT_SALE"] = "SEAPORT_SALE";
    SaleType["SUPERRARE_SALE"] = "SUPERRARE_SALE";
    SaleType["ZEROX_SALE"] = "ZEROX_SALE";
    SaleType["ZORA_V2_AUCTION_SALE"] = "ZORA_V2_AUCTION_SALE";
    SaleType["ZORA_V3_ASK_SALE"] = "ZORA_V3_ASK_SALE";
})(SaleType || (SaleType = {}));

;// CONCATENATED MODULE: ./packages/web3-providers/src/Zora/queries.ts

const CurrencyAmount = (0,esm/* gql */.Ps)`
    raw
    decimal
    currency {
        name
        address
        decimals
    }
`;
const Page = (0,esm/* gql */.Ps)`
    limit
    endCursor
    hasNextPage
`;
const Network = (0,esm/* gql */.Ps)`
    chain
`;
const Transaction = (0,esm/* gql */.Ps)`
    blockNumber
    blockTimestamp
    transactionHash
    logIndex
`;
const Media = (0,esm/* gql */.Ps)`
    url
    mimeType
    size
`;
const Attribute = (0,esm/* gql */.Ps)`
    traitType
    displayType
    value
`;
const Price = (0,esm/* gql */.Ps)`
    blockNumber
    nativePrice {
        ${CurrencyAmount}
    }
    chainTokenPrice {
        ${CurrencyAmount}
    }
    usdcPrice {
        ${CurrencyAmount}
    }
`;
const Token = (0,esm/* gql */.Ps)`
    tokenId
    collectionAddress
    collectionName
    mintInfo {
        mintContext {
            ${Transaction}
        }
        originatorAddress
        toAddress
        price {
            ${Price}
        }
    }
    networkInfo {
        ${Network}
    }
    tokenUrl
    tokenUrlMimeType
    content {
        ${Media}
    }
    image {
        ${Media}
    }
    owner
    tokenContract {
        collectionAddress
        chain
        name
        symbol
        totalSupply
        description
    }
    name
    description
    metadata
    attributes {
        ${Attribute}
    }
`;
const Event = (0,esm/* gql */.Ps)`
    networkInfo {
        ${Network}
    }
    transactionInfo {
        ${Transaction}
    }
    eventType
    collectionAddress
    tokenId
    properties {
        ... on MintEvent {
            originatorAddress
            toAddress
            price {
                ${Price}
            }
        }
        ... on Sale {
            transactionInfo {
                ${Transaction}
            }
            networkInfo {
                ${Network}
            }
            buyerAddress
            saleType
            price {
                ${Price}
            }
            sellerAddress
        }
        ... on TransferEvent {
            fromAddress
            toAddress
        }
        ... on V3AskEvent {
            address
            properties {
                ... on V3AskCreatedEventProperties {
                    seller
                    sellerFundsRecipient
                    askCurrency
                    askPrice
                    findersFeeBps
                    price {
                        ${Price}
                    }
                }
            }
        }
    }
`;
const GetTokenQuery = (0,esm/* gql */.Ps)`
    query getToken($address: String!, $tokenId: String!) {
        token(
            token: {
                address: $address,
                tokenId: $tokenId
            }
        ) {
            token {
                ${Token}
            }
        }
    }
`;
const GetEventsQuery = (0,esm/* gql */.Ps)`
    query getEvents($address: String!, $tokenId: String!, $eventTypes: [EventType!], $size: Int = 20) {
        events(
            filter: {
                eventTypes: $eventTypes
            },
            pagination: {
                limit: $size
            },
            where: {
                tokens: [
                    {
                        address: $address,
                        tokenId: $tokenId
                    }
                ]
            }
        ) {
            nodes {
                ${Event}
            }
            pageInfo {
                ${Page}
            }
        }
    }
`;

;// CONCATENATED MODULE: ./packages/web3-providers/src/Zora/constants.ts

const ZORA_MAINNET_GRAPHQL_URL = (0,resolver/* resolveCrossOriginURL */.nX)('https://api.zora.co/graphql');

;// CONCATENATED MODULE: ./packages/web3-providers/src/Zora/index.ts











class ZoraAPI {
    client = new esm/* GraphQLClient */.g6(ZORA_MAINNET_GRAPHQL_URL);
    createZoraLink(address, tokenId) {
        return (0,dist/* default */.ZP)('https://zora.co/collections/:address/:tokenId', {
            address,
            tokenId
        });
    }
    async request(chainId, query, parameters) {
        if (chainId !== types/* ChainId */.a_.Mainnet) return;
        const response = await this.client.request(query, parameters);
        return response;
    }
    createNonFungibleAssetFromToken(chainId, token) {
        const shared = {
            chainId,
            address: token.tokenContract?.collectionAddress ?? token.collectionAddress,
            name: token.tokenContract?.name ?? token.collectionName ?? '',
            symbol: token.tokenContract?.symbol ?? 'UNKNOWN',
            schema: types/* SchemaType */.XQ.ERC721
        };
        return {
            id: `${token.collectionAddress}_${token.tokenId}`,
            chainId,
            type: specs/* TokenType */.iv.NonFungible,
            schema: types/* SchemaType */.XQ.ERC721,
            link: this.createZoraLink(token.collectionAddress, token.tokenId),
            address: token.collectionAddress,
            tokenId: token.tokenId,
            contract: {
                ...shared,
                owner: token.owner
            },
            collection: {
                ...shared,
                slug: token.tokenContract?.symbol ?? 'UNKNOWN',
                description: token.tokenContract?.description ?? token.description
            },
            metadata: {
                ...shared,
                name: (0,getAssetFullName/* getAssetFullName */.q)(shared.address, shared.name ?? '', token.name, token.tokenId)
            },
            traits: token.attributes?.filter((x)=>x.traitType && x.value).map((x)=>({
                    type: x.traitType,
                    value: x.value
                })) ?? src_constants/* EMPTY_LIST */.rP,
            price: token.mintInfo?.price.usdcPrice?.raw ? {
                [specs/* CurrencyType */.V2.USD]: token.mintInfo?.price.usdcPrice?.raw
            } : undefined,
            priceInToken: token.mintInfo?.price.nativePrice.raw ? {
                amount: token.mintInfo?.price.nativePrice.raw,
                token: ResolverAPI/* ChainResolver */.iv.nativeCurrency(chainId)
            } : undefined,
            owner: token.owner ? {
                address: token.owner
            } : undefined,
            ownerId: token.owner,
            source: specs/* SourceType */.PO.Zora
        };
    }
    createNonFungibleEventFromEvent(chainId, event) {
        const pair = (()=>{
            const mintEventProperty = event.properties;
            if (mintEventProperty.originatorAddress && mintEventProperty.toAddress) return {
                from: mintEventProperty.originatorAddress,
                to: mintEventProperty.toAddress
            };
            const saleEventProperty = event.properties;
            if (saleEventProperty.buyerAddress && saleEventProperty.sellerAddress) return {
                from: saleEventProperty.sellerAddress,
                to: saleEventProperty.buyerAddress
            };
            const transferEventProperty = event.properties;
            if (transferEventProperty.fromAddress && transferEventProperty.toAddress) {
                return {
                    from: transferEventProperty.fromAddress,
                    to: transferEventProperty.toAddress
                };
            }
            return;
        })();
        const price = (()=>{
            const mintEventProperty = event.properties;
            const saleEventProperty = event.properties;
            const price = mintEventProperty.price || saleEventProperty.price;
            if (price.usdcPrice) return {
                price: price.usdcPrice?.raw ? {
                    [specs/* CurrencyType */.V2.USD]: price.usdcPrice?.raw
                } : undefined,
                priceInToken: price.nativePrice.raw ? {
                    amount: price.nativePrice.raw,
                    token: ResolverAPI/* ChainResolver */.iv.nativeCurrency(chainId)
                } : undefined
            };
            return;
        })();
        return {
            id: event.transactionInfo.transactionHash ?? `${event.transactionInfo.blockNumber}_${event.tokenId}`,
            type: (0,resolveActivityType/* resolveActivityType */.G)(event.eventType),
            chainId,
            quantity: '1',
            from: {
                address: pair?.from
            },
            to: {
                address: pair?.to
            },
            timestamp: new Date(event.transactionInfo.blockTimestamp).getTime(),
            hash: event.transactionInfo.transactionHash,
            ...price,
            source: specs/* SourceType */.PO.Zora
        };
    }
    createPageable(items, indicator) {
        return (0,Pageable/* createPageable */.LI)(items, (0,Pageable/* createIndicator */.sz)(indicator), items.length ? (0,Pageable/* createNextIndicator */.gT)(indicator) : undefined);
    }
    async getAsset(address, tokenId, { chainId = types/* ChainId */.a_.Mainnet } = {}) {
        if (!(0,isValidChainId/* isValidChainId */.J)(chainId)) return;
        const token = await this.request(chainId, GetTokenQuery, {
            address,
            tokenId
        });
        if (!token) return;
        return this.createNonFungibleAssetFromToken(types/* ChainId */.a_.Mainnet, token.token.token);
    }
    async getAssets(account, options) {
        throw new Error('Method not implemented.');
    }
    async getEventsFiltered(chainId, address, tokenId, eventTypes) {
        if (!(0,isValidChainId/* isValidChainId */.J)(chainId)) return [];
        const response = await this.request(chainId, GetEventsQuery, {
            address,
            tokenId,
            eventTypes
        });
        return response?.events.nodes ?? src_constants/* EMPTY_LIST */.rP;
    }
    async getEvents(address, tokenId, { chainId = types/* ChainId */.a_.Mainnet, indicator } = {}) {
        if (!(0,isValidChainId/* isValidChainId */.J)(chainId)) return (0,Pageable/* createPageable */.LI)(src_constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        const events = await this.getEventsFiltered(chainId, address, tokenId, [
            EventType.MINT_EVENT,
            EventType.SALE_EVENT,
            EventType.TRANSFER_EVENT
        ]);
        const events_ = events.length ? events.map((x)=>this.createNonFungibleEventFromEvent(chainId, x)) : src_constants/* EMPTY_LIST */.rP;
        return this.createPageable(events_, indicator);
    }
}
const Zora = new ZoraAPI();

;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/apis/HubNonFungibleAPI.ts

















class HubNonFungibleAPI extends apis_HubNonFungibleAPI/* HubNonFungibleAPI_Base */.j {
    Approval_ = new Approval/* ApprovalAPI */.s();
    HubOptions = new HubOptionsAPI/* HubOptionsAPI */.u(this.options);
    getProviders(initial) {
        const options = this.HubOptions.fill(initial);
        return this.getPredicateProviders({
            [specs/* SourceType */.PO.X2Y2]: X2Y2,
            [specs/* SourceType */.PO.Chainbase]: ChainbaseNonFungibleToken,
            [specs/* SourceType */.PO.Zerion]: Zerion/* ZerionNonFungibleToken */.mF,
            [specs/* SourceType */.PO.NFTScan]: NFTScanNonFungibleTokenEVM,
            [specs/* SourceType */.PO.OpenSea]: OpenSea/* OpenSea */.N,
            [specs/* SourceType */.PO.Approval]: this.Approval_,
            [specs/* SourceType */.PO.Alchemy_EVM]: AlchemyEVM,
            [specs/* SourceType */.PO.Zora]: Zora,
            [specs/* SourceType */.PO.Gem]: Gem,
            [specs/* SourceType */.PO.GoPlus]: GoPlusLabs/* GoPlusAuthorization */.x,
            [specs/* SourceType */.PO.Rabby]: Rabby/* Rabby */.C,
            [specs/* SourceType */.PO.R2D2]: TokenListAPI/* R2D2TokenList */.m,
            [specs/* SourceType */.PO.SimpleHash]: apis_EVM/* SimpleHashEVM */.f
        }, options.chainId === types/* ChainId */.a_.Mainnet ? [
            X2Y2,
            apis_EVM/* SimpleHashEVM */.f,
            NFTScanNonFungibleTokenEVM,
            Zerion/* ZerionNonFungibleToken */.mF,
            OpenSea/* OpenSea */.N,
            AlchemyEVM,
            Zora,
            Gem,
            this.Approval_,
            GoPlusLabs/* GoPlusAuthorization */.x,
            Rabby/* Rabby */.C,
            TokenListAPI/* R2D2TokenList */.m
        ] : [
            apis_EVM/* SimpleHashEVM */.f,
            NFTScanNonFungibleTokenEVM,
            Zerion/* ZerionNonFungibleToken */.mF,
            AlchemyEVM,
            OpenSea/* OpenSea */.N,
            Zora,
            this.Approval_,
            Gem,
            GoPlusLabs/* GoPlusAuthorization */.x,
            Rabby/* Rabby */.C,
            TokenListAPI/* R2D2TokenList */.m
        ], initial);
    }
}


/***/ }),

/***/ 40850:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   u: () => (/* binding */ HubOptionsAPI)
/* harmony export */ });
/* harmony import */ var _Base_apis_HubOptionsAPI_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14058);
/* harmony import */ var _Web3StateAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39850);
/* harmony import */ var _OthersAPI_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(63877);



class HubOptionsAPI extends _Base_apis_HubOptionsAPI_js__WEBPACK_IMPORTED_MODULE_0__/* .HubOptionsAPI_Base */ .v {
    get Web3StateRef() {
        return _Web3StateAPI_js__WEBPACK_IMPORTED_MODULE_1__.Web3StateRef;
    }
    get Web3Others() {
        return new _OthersAPI_js__WEBPACK_IMPORTED_MODULE_2__/* .OthersAPI */ .i();
    }
}


/***/ }),

/***/ 63877:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  i: () => (/* binding */ OthersAPI)
});

// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/token.ts
var token = __webpack_require__(77199);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/isValidDomain.ts
var isValidDomain = __webpack_require__(89019);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/isValidChainId.ts
var isValidChainId = __webpack_require__(37049);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/address.ts
var address = __webpack_require__(65327);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/token.ts
var helpers_token = __webpack_require__(48289);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/defaults.ts
var defaults = __webpack_require__(35138);
// EXTERNAL MODULE: ./node_modules/.pnpm/web3-utils@1.10.2/node_modules/web3-utils/lib/index.js
var lib = __webpack_require__(84976);
;// CONCATENATED MODULE: ./packages/web3-shared/evm/src/helpers/getTransactionSignature.ts

function getTransactionSignature(chainId, transaction) {
    if (!chainId || !transaction) return;
    const { from, to, data, value } = transaction;
    return (0,lib.sha3)([
        chainId,
        from,
        to,
        data || '0x0',
        (0,lib.toHex)(value || '0x0') || '0x0'
    ].join('_')) ?? undefined;
}

// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/getAverageBlockDelay.ts
var getAverageBlockDelay = __webpack_require__(40068);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/formatter.ts
var formatter = __webpack_require__(41487);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Base/apis/OthersAPI.ts
var apis_OthersAPI = __webpack_require__(57429);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/ResolverAPI.ts
var ResolverAPI = __webpack_require__(66979);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/apis/OthersAPI.ts




class OthersAPI extends apis_OthersAPI/* OthersAPI_Base */.a {
    chainResolver = ResolverAPI/* ChainResolver */.iv;
    explorerResolver = ResolverAPI/* ExplorerResolver */.Xz;
    providerResolver = ResolverAPI/* ProviderResolver */.fh;
    networkResolver = ResolverAPI/* NetworkResolver */.VN;
    isValidDomain = isValidDomain/* isValidDomain */.h;
    isValidChainId = isValidChainId/* isValidChainId */.J;
    isValidAddress = address/* isValidAddress */.At;
    isZeroAddress = address/* isZeroAddress */.uO;
    isNativeTokenAddress = address/* isNativeTokenAddress */.qw;
    isNativeTokenSchemaType = helpers_token/* isNativeTokenSchemaType */.SC;
    isFungibleTokenSchemaType = helpers_token/* isFungibleTokenSchemaType */.kL;
    isNonFungibleTokenSchemaType = helpers_token/* isNonFungibleTokenSchemaType */.V2;
    getNetworkPluginID = defaults/* getNetworkPluginID */.yg;
    getDefaultChainId = defaults/* getDefaultChainId */.tA;
    getInvalidChainId = defaults/* getInvalidChainId */.p6;
    getDefaultNetworkType = defaults/* getDefaultNetworkType */.H2;
    getDefaultProviderType = defaults/* getDefaultProviderType */.Xo;
    getZeroAddress = address/* getZeroAddress */.R6;
    getMaskTokenAddress = address/* getMaskTokenAddress */.vY;
    getNativeTokenAddress = address/* getNativeTokenAddress */.rG;
    getTransactionSignature = getTransactionSignature;
    getAverageBlockDelay = getAverageBlockDelay/* getAverageBlockDelay */.g;
    formatAddress = formatter/* formatEthereumAddress */.j8;
    formatTokenId = formatter/* formatTokenId */.Xy;
    formatDomainName = formatter/* formatDomainName */.bc;
    formatSchemaType = formatter/* formatSchemaType */.sB;
    createNativeToken = (chainId)=>ResolverAPI/* ChainResolver */.iv.nativeCurrency(chainId);
    createFungibleToken = token/* createFungibleToken */.mn;
    createNonFungibleToken = token/* createNonFungibleToken */.RV;
}


/***/ }),

/***/ 81254:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  U: () => (/* binding */ RequestAPI)
});

// EXTERNAL MODULE: ./packages/web3-shared/evm/src/types/index.ts
var types = __webpack_require__(24770);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/libs/PayloadEditor.ts + 1 modules
var PayloadEditor = __webpack_require__(61227);
;// CONCATENATED MODULE: ./packages/web3-shared/evm/src/libs/Composer.ts
class Composer {
    items = [];
    compose() {
        return (context, next)=>{
            let index = -1;
            const dispatch = (i)=>{
                if (i <= index) return Promise.reject(new Error('next() called multiple times'));
                index = i;
                let fn;
                if (i >= this.items.length) fn = next;
                else fn = this.items[i].fn.bind(this.items[i]);
                if (!fn) return Promise.resolve();
                try {
                    return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));
                } catch (err) {
                    return Promise.reject(err);
                }
            };
            return dispatch(0);
        };
    }
    /**
     * Use a middleware
     * @param middleware
     */ use(middleware) {
        this.items.push(middleware);
    }
    /**
     * Run all registered middleware
     * @param context
     * @param next
     */ async dispatch(context, next) {
        await this.compose()(context, next);
    }
    static from(...items) {
        const composer = new Composer();
        items.forEach((x)=>composer.use(x));
        return composer;
    }
}

// EXTERNAL MODULE: ./node_modules/.pnpm/web3-utils@1.10.2/node_modules/web3-utils/lib/index.js
var lib = __webpack_require__(84976);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/address.ts
var helpers_address = __webpack_require__(65327);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/ConnectionReadonlyAPI.ts + 2 modules
var ConnectionReadonlyAPI = __webpack_require__(3543);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/middleware/Nonce.ts



class Nonce {
    static INITIAL_NONCE = -1;
    Web3 = new ConnectionReadonlyAPI/* ConnectionReadonlyAPI */.S();
    // account address => chainId => nonce
    nonces = new Map();
    async syncRemoteNonce(chainId, address, providerURL, commitment = 0) {
        const address_ = (0,helpers_address/* checksumAddress */.xs)(address);
        const addressNonces = this.nonces.get(address_) ?? new Map();
        addressNonces.set(chainId, commitment + Math.max(await this.Web3.getTransactionNonce(address, {
            chainId,
            providerURL
        }), addressNonces.get(chainId) ?? Nonce.INITIAL_NONCE));
        // set back into cache
        this.nonces.set(address_, addressNonces);
        return addressNonces.get(chainId);
    }
    async fn(context, next) {
        // set a nonce for Mask wallets
        if (!context.owner && context.account && context.providerType === types/* ProviderType */.lP.MaskWallet && context.method === types/* EthereumMethodType */.W8.ETH_SEND_TRANSACTION) {
            context.requestArguments = {
                method: context.method,
                params: [
                    {
                        ...context.config,
                        nonce: (0,lib.toHex)(await this.syncRemoteNonce(context.chainId, context.account, context.providerURL))
                    }
                ]
            };
        }
        await next();
        // send transaction
        if (context.method !== types/* EthereumMethodType */.W8.ETH_SEND_TRANSACTION) return;
        try {
            const message = context.error?.message ?? '';
            const isGeneralErrorNonce = /\bnonce|transaction\b/im.test(message) && /\b(low|high|old)\b/im.test(message);
            const isAuroraErrorNonce = message.includes('ERR_INCORRECT_NONCE');
            // if a nonce error was occurred then reset the nonce
            if (isGeneralErrorNonce || isAuroraErrorNonce) await this.syncRemoteNonce(context.chainId, context.account, context.providerURL);
            else // if a transaction hash was received then commit the nonce
            if (!context.error && typeof context.result === 'string') await this.syncRemoteNonce(context.chainId, context.account, context.providerURL, 1);
        } catch  {}
    }
} // to scan the context to determine how to update the local nonce, allow to fail silently

// EXTERNAL MODULE: ./node_modules/.pnpm/bignumber.js@9.1.2/node_modules/bignumber.js/bignumber.mjs
var bignumber = __webpack_require__(10149);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/specs/index.ts
var specs = __webpack_require__(62649);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/number.ts
var number = __webpack_require__(29763);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/formatter.ts
var formatter = __webpack_require__(41487);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/HubAPI.ts
var HubAPI = __webpack_require__(60300);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/ResolverAPI.ts
var ResolverAPI = __webpack_require__(66979);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/translators/Base.ts






class Base {
    Hub = new HubAPI/* HubAPI */.K().create();
    async encode(context) {
        const config = context.config;
        if (!config || PayloadEditor/* PayloadEditor */._.fromPayload(context.request).readonly) return;
        // #region polyfill transaction config
        try {
            // add gas margin
            if (config.gas) {
                if (context.providerType !== types/* ProviderType */.lP.MaskWallet) {
                    config.gas = (0,lib.toHex)(bignumber/* BigNumber */.O.max((0,lib.toHex)(config.gas), context.chainId === types/* ChainId */.a_.Optimism ? 25000 : 21000).toFixed());
                } else {
                    config.gas = (0,lib.toHex)(config.gas);
                }
            }
            // add gas price
            const options = await this.Hub.getGasOptions(context.chainId, {
                chainId: context.chainId
            });
            const { [specs/* GasOptionType */.Qd.SLOW]: slowOption, [specs/* GasOptionType */.Qd.NORMAL]: normalOption } = options ?? {};
            if (ResolverAPI/* ChainResolver */.iv.isFeatureSupported(context.chainId, 'EIP1559')) {
                delete config.gasPrice;
                if (slowOption?.suggestedMaxFeePerGas && normalOption && (0,number/* isLessThan */.FI)(config.maxPriorityFeePerGas ? (0,formatter/* formatWeiToGwei */.f1)(config.maxPriorityFeePerGas) : 0, slowOption.suggestedMaxPriorityFeePerGas)) {
                    config.maxFeePerGas = (0,lib.toHex)((0,number/* toFixed */.FH)(normalOption.suggestedMaxFeePerGas, 0));
                    config.maxPriorityFeePerGas = (0,lib.toHex)((0,number/* toFixed */.FH)(normalOption.suggestedMaxPriorityFeePerGas, 0));
                }
            } else {
                delete config.maxFeePerGas;
                delete config.maxPriorityFeePerGas;
                if (slowOption && normalOption && (0,number/* isLessThan */.FI)(config.gasPrice ?? 0, slowOption.suggestedMaxFeePerGas)) {
                    config.gasPrice = (0,lib.toHex)((0,number/* toFixed */.FH)(normalOption.suggestedMaxFeePerGas, 0));
                }
            }
        } catch (err) {
            console.error(err);
        }
        const overrideMaxFeePerGas = context.requestOptions?.overrides?.maxFeePerGas;
        const overrideMaxPriorityFeePerGas = context.requestOptions?.overrides?.maxPriorityFeePerGas;
        const overrideGasPrice = context.requestOptions?.overrides?.gasPrice;
        context.config = {
            ...config,
            maxFeePerGas: overrideMaxFeePerGas ? (0,lib.toHex)(overrideMaxFeePerGas) : config.maxFeePerGas,
            maxPriorityFeePerGas: overrideMaxPriorityFeePerGas ? (0,lib.toHex)(overrideMaxPriorityFeePerGas) : config.maxPriorityFeePerGas,
            gasPrice: overrideGasPrice ? (0,lib.toHex)(overrideGasPrice) : config.gasPrice
        };
    }
    // #endregion
    async decode(context) {}
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/translators/Astar.ts



class Astar extends Base {
    async encode(context) {
        await super.encode(context);
        if (context.chainId !== types/* ChainId */.a_.Astar) return;
        if (!context.config) return;
        context.config = {
            ...context.config,
            maxFeePerGas: context.config.maxFeePerGas ? (0,lib.toHex)(context.config.maxFeePerGas) : undefined,
            maxPriorityFeePerGas: context.config.maxPriorityFeePerGas ? (0,lib.toHex)(context.config.maxPriorityFeePerGas) : undefined,
            // rpc hack, alchemy rpc must pass gas parameter
            gas: '0x135168'
        };
    }
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/translators/Polygon.ts



class Polygon extends Base {
    Web3 = new ConnectionReadonlyAPI/* ConnectionReadonlyAPI */.S();
    async encode(context) {
        await super.encode(context);
        if (!context.config) return;
        // the current version of metamask doesn't support polygon with EIP1559
        if (context.providerType !== types/* ProviderType */.lP.MetaMask) return;
        if (context.method !== types/* EthereumMethodType */.W8.ETH_SEND_TRANSACTION) return;
        const config = {
            ...context.config,
            // keep the legacy gasPrice
            ...PayloadEditor/* PayloadEditor */._.fromPayload(context.request) ? {} : {
                gasPrice: context.config.gasPrice ?? await this.Web3.getGasPrice({
                    chainId: context.chainId
                })
            }
        };
        delete config.maxFeePerGas;
        delete config.maxPriorityFeePerGas;
        context.config = config;
    }
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/middleware/Translator.ts




/**
 * JSON RPC transactor for EVM chains.
 */ class Translator {
    base = new Base();
    translators = {
        [types/* ChainId */.a_.Astar]: new Astar(),
        [types/* ChainId */.a_.Matic]: new Polygon()
    };
    async fn(context, next) {
        const translator = this.translators[context.chainId] ?? this.base;
        if (translator.encode) await translator.encode(context);
        await next();
        if (translator.decode) await translator.decode(context);
    }
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/interceptors/None.ts
class NoneWallet {
    async fn(context, next) {
        if (context.risky) {
            context.abort(new Error('No allowed.'));
        }
        await next();
    }
}

// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/providers/index.ts + 18 modules
var providers = __webpack_require__(66402);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/interceptors/MaskWallet.ts



class MaskWallet {
    get walletProvider() {
        return providers/* Providers */.C[types/* ProviderType */.lP.MaskWallet];
    }
    async fn(context, next) {
        if (!context.writeable) {
            await next();
            return;
        }
        const provider = providers/* Providers */.C.Maskbook;
        switch(context.request.method){
            case types/* EthereumMethodType */.W8.ETH_CHAIN_ID:
                context.write((0,lib.toHex)(provider.hostedChainId));
                break;
            case types/* EthereumMethodType */.W8.ETH_ACCOUNTS:
                context.write([
                    provider.hostedAccount
                ]);
                break;
            case types/* EthereumMethodType */.W8.MASK_WALLETS:
                try {
                    context.write(this.walletProvider.subscription.wallets.getCurrentValue());
                } catch (error) {
                    context.abort(error);
                }
                break;
            case types/* EthereumMethodType */.W8.MASK_ADD_WALLET:
                try {
                    if (!context.wallet) throw new Error('No wallet to be added.');
                    await this.walletProvider.addWallet(context.wallet);
                    context.write();
                } catch (error) {
                    context.abort(error);
                }
                break;
            case types/* EthereumMethodType */.W8.MASK_UPDATE_WALLET:
                try {
                    const [address, updates] = context.requestArguments.params;
                    if (!(0,helpers_address/* isValidAddress */.At)(address)) throw new Error('Not a valid wallet address.');
                    await this.walletProvider.updateWallet(address, updates);
                    context.write();
                } catch (error) {
                    context.abort(error);
                }
                break;
            case types/* EthereumMethodType */.W8.MASK_RENAME_WALLET:
                try {
                    const [address, name] = context.requestArguments.params;
                    if (!(0,helpers_address/* isValidAddress */.At)(address)) throw new Error('Not a valid wallet address.');
                    await this.walletProvider.renameWallet(address, name);
                    context.write();
                } catch (error) {
                    context.abort(error);
                }
                break;
            case types/* EthereumMethodType */.W8.MASK_REMOVE_WALLET:
                try {
                    const [address, password] = context.requestArguments.params;
                    if (!(0,helpers_address/* isValidAddress */.At)(address)) throw new Error('Not a valid wallet address.');
                    await this.walletProvider.removeWallet(address, password);
                    context.write();
                } catch (error) {
                    context.abort(error);
                }
                break;
            case types/* EthereumMethodType */.W8.MASK_UPDATE_WALLETS:
                try {
                    const wallets = context.requestArguments.params;
                    if (wallets.some((x)=>!(0,helpers_address/* isValidAddress */.At)(x.address))) throw new Error('Not a valid wallet address.');
                    await this.walletProvider.updateWallets(wallets);
                    context.write();
                } catch (error) {
                    context.abort(error);
                }
                break;
            case types/* EthereumMethodType */.W8.MASK_REMOVE_WALLETS:
                try {
                    const wallets = context.requestArguments.params;
                    if (wallets.some((x)=>!(0,helpers_address/* isValidAddress */.At)(x.address))) throw new Error('Not a valid wallet address.');
                    await this.walletProvider.removeWallets(wallets);
                    context.write();
                } catch (error) {
                    context.abort(context);
                }
                break;
            case types/* EthereumMethodType */.W8.MASK_RESET_ALL_WALLETS:
                try {
                    await this.walletProvider.resetAllWallets();
                    context.write();
                } catch (error) {
                    context.abort(context);
                }
                break;
            default:
                break;
        }
        await next();
    }
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/interceptors/WalletConnect.ts


class WalletConnect {
    async fn(context, next) {
        switch(context.request.method){
            case types/* EthereumMethodType */.W8.PERSONAL_SIGN:
                context.requestArguments = {
                    ...context.requestArguments,
                    params: [
                        ...context.requestArguments.params.slice(0, 2),
                        ''
                    ]
                };
                break;
            default:
                break;
        }
        await next();
        switch(context.request.method){
            case types/* EthereumMethodType */.W8.ETH_CHAIN_ID:
                if (typeof context.result === 'number') {
                    context.result = (0,lib.toHex)(context.result);
                }
                break;
            default:
                break;
        }
    }
}

// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/ConnectionAPI.ts
var ConnectionAPI = __webpack_require__(16488);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/interceptors/MetaMaskLike.ts


class MetaMaskLike {
    constructor(providerType){
        this.Web3 = new ConnectionAPI/* ConnectionAPI */.m({
            providerType
        });
    }
    Web3;
    async fn(context, next) {
        // Evoke the unlock popup when metamask-like is locked before send transaction or sign message.
        if (PayloadEditor/* PayloadEditor */._.fromPayload(context.request).risky) {
            await this.Web3.connect(context.requestOptions);
        }
        switch(context.request.method){
            case types/* EthereumMethodType */.W8.PERSONAL_SIGN:
                context.requestArguments = {
                    ...context.requestArguments,
                    params: [
                        ...context.requestArguments.params.slice(0, 2),
                        ''
                    ]
                };
                break;
            case types/* EthereumMethodType */.W8.ETH_SEND_TRANSACTION:
                const currentChainId = await this.Web3.getChainId();
                if (currentChainId !== context.chainId) {
                    await this.Web3.connect({
                        chainId: context.chainId
                    });
                }
                break;
            default:
                break;
        }
        await next();
    }
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/interceptors/Fortmatic.ts

class Fortmatic {
    async fn(context, next) {
        switch(context.request.method){
            case types/* EthereumMethodType */.W8.PERSONAL_SIGN:
                context.requestArguments = {
                    ...context.requestArguments,
                    params: [
                        ...context.requestArguments.params.slice(0, 2),
                        ''
                    ]
                };
                break;
            default:
                break;
        }
        await next();
    }
}

// EXTERNAL MODULE: ./packages/shared-base/src/types/Account.ts
var Account = __webpack_require__(60541);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/libs/Signer.ts
var Signer = __webpack_require__(28775);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/ContractReadonlyAPI.ts + 9 modules
var ContractReadonlyAPI = __webpack_require__(61871);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/interceptors/ContractWallet.ts






class ContractWallet {
    providerType;
    account;
    bundler;
    funder;
    signWithPersona;
    Web3;
    Contract;
    constructor(providerType, account, bundler, funder, signWithPersona){
        this.providerType = providerType;
        this.account = account;
        this.bundler = bundler;
        this.funder = funder;
        this.signWithPersona = signWithPersona;
        this.Web3 = new ConnectionAPI/* ConnectionAPI */.m();
        this.Contract = new ContractReadonlyAPI/* ContractReadonlyAPI */.M();
    }
    async getNonce(context) {
        const contract = this.Contract.getWalletContract(context.account);
        if (!contract) throw new Error('Failed to create wallet contract.');
        return contract.methods.nonce().call();
    }
    getSigner(context) {
        if (context.identifier) return new Signer/* Signer */.E(context.identifier, async (type, message, identifier)=>{
            return this.signWithPersona(type, message, identifier, true);
        });
        if (context.owner) return new Signer/* Signer */.E(context.owner, (type, message, account)=>{
            switch(type){
                case Account/* SignType */.A.Message:
                    return this.Web3.signMessage('message', message, {
                        account,
                        providerType: this.providerType
                    });
                case Account/* SignType */.A.TypedData:
                    return this.Web3.signMessage('typedData', message, {
                        account,
                        providerType: this.providerType
                    });
                case Account/* SignType */.A.Transaction:
                    return this.Web3.signTransaction(message, {
                        account,
                        providerType: this.providerType
                    });
                default:
                    throw new Error('Unknown sign method.');
            }
        });
        throw new Error('Failed to create signer.');
    }
    async send(context) {
        if (!context.owner) throw new Error('No owner.');
        if (context.userOperation) return this.account.sendUserOperation(context.chainId, context.owner, context.userOperation, this.getSigner(context), {
            paymentToken: context.paymentToken
        });
        if (context.config) return this.account.sendTransaction(context.chainId, context.owner, context.config, this.getSigner(context), {
            paymentToken: context.paymentToken
        });
        throw new Error('No user operation to be sent.');
    }
    estimate(context) {
        if (context.userOperation) return this.account.estimateUserOperation(context.chainId, context.userOperation, {
            paymentToken: context.paymentToken
        });
        if (context.config) return this.account.estimateTransaction(context.chainId, context.config, {
            paymentToken: context.paymentToken
        });
        throw new Error('No user operation to be estimated.');
    }
    async fund(context) {
        if (!context.proof) throw new Error('No proof.');
        return this.funder.fund(context.chainId, context.proof);
    }
    async deploy(context) {
        if (!context.owner) throw new Error('No owner.');
        return this.account.deploy(context.chainId, context.owner, this.getSigner(context));
    }
    async fn(context, next) {
        if (!context.writeable) {
            await next();
            return;
        }
        const provider = providers/* Providers */.C[context.providerType];
        // not a SC wallet provider
        if (!provider?.ownerAccount && !context.owner) {
            await next();
            return;
        }
        switch(context.request.method){
            case types/* EthereumMethodType */.W8.ETH_CHAIN_ID:
                context.write(provider?.hostedChainId ? (0,lib.toHex)(provider?.hostedChainId) : undefined);
                break;
            case types/* EthereumMethodType */.W8.ETH_ACCOUNTS:
                if ((0,helpers_address/* isValidAddress */.At)(provider?.hostedAccount)) {
                    context.write([
                        provider?.hostedAccount
                    ]);
                } else {
                    context.abort(new Error('Please connect a wallet.'));
                }
                break;
            case types/* EthereumMethodType */.W8.ETH_GET_TRANSACTION_COUNT:
                try {
                    context.write(await this.getNonce(context));
                } catch (error) {
                    context.abort(error);
                }
                break;
            case types/* EthereumMethodType */.W8.ETH_SEND_TRANSACTION:
                try {
                    context.write(await this.send(context));
                } catch (error) {
                    context.abort(error);
                }
                break;
            case types/* EthereumMethodType */.W8.ETH_SEND_USER_OPERATION:
                try {
                    context.write(await this.send(context));
                } catch (error) {
                    context.abort(error);
                }
                break;
            case types/* EthereumMethodType */.W8.ETH_SUPPORTED_CHAIN_IDS:
                try {
                    context.write([
                        await this.bundler.getSupportedChainId()
                    ]);
                } catch (error) {
                    context.abort(error);
                }
                break;
            case types/* EthereumMethodType */.W8.ETH_SUPPORTED_ENTRY_POINTS:
                try {
                    context.write(await this.bundler.getSupportedEntryPoints(context.chainId));
                } catch (error) {
                    context.abort(error);
                }
                break;
            case types/* EthereumMethodType */.W8.ETH_ESTIMATE_GAS:
                try {
                    context.write(await this.estimate(context));
                } catch (error) {
                    context.abort(error);
                }
                break;
            case types/* EthereumMethodType */.W8.ETH_SIGN:
            case types/* EthereumMethodType */.W8.PERSONAL_SIGN:
                try {
                    if (!context.message) throw new Error('Invalid message.');
                    context.write(await this.getSigner(context).signMessage(context.message));
                } catch (error) {
                    context.abort(error);
                }
                break;
            case types/* EthereumMethodType */.W8.ETH_SIGN_TYPED_DATA:
                try {
                    if (!context.message) throw new Error('Invalid typed data.');
                    context.write(await this.getSigner(context).signTypedData(context.message));
                } catch (error) {
                    context.abort(error);
                }
                break;
            case types/* EthereumMethodType */.W8.ETH_SIGN_TRANSACTION:
                try {
                    if (!context.config) throw new Error('Invalid transaction.');
                    context.write(await this.getSigner(context).signTransaction(context.config));
                } catch (error) {
                    context.abort(error);
                }
                break;
            case types/* EthereumMethodType */.W8.MASK_FUND:
                try {
                    const { message } = await this.fund(context);
                    if (!(0,helpers_address/* isValidAddress */.At)(message.walletAddress)) throw new Error('Failed to fund.');
                    context.write(message.tx);
                } catch (error) {
                    context.abort(error);
                }
                break;
            case types/* EthereumMethodType */.W8.MASK_DEPLOY:
                try {
                    context.write(await this.deploy(context));
                } catch (error) {
                    context.abort(error);
                }
                break;
            case types/* EthereumMethodType */.W8.WALLET_SWITCH_ETHEREUM_CHAIN:
                context.abort(new Error('Not supported by contract wallet.'));
                break;
            case types/* EthereumMethodType */.W8.ETH_SEND_RAW_TRANSACTION:
                context.abort(new Error('Not supported by contract wallet.'));
                break;
            default:
                break;
        }
        await next();
    }
}

// EXTERNAL MODULE: ./packages/web3-shared/evm/src/constants/constants.ts
var constants = __webpack_require__(33026);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/libs/ErrorEditor.ts
var ErrorEditor = __webpack_require__(40225);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/isSameURL.ts
var isSameURL = __webpack_require__(76423);
// EXTERNAL MODULE: ./packages/web3-providers/src/SmartPay/libs/DepositPaymaster.ts + 1 modules
var DepositPaymaster = __webpack_require__(89288);
// EXTERNAL MODULE: ./packages/web3-providers/src/SmartPay/apis/AbstractAccountAPI.ts
var AbstractAccountAPI = __webpack_require__(1288);
// EXTERNAL MODULE: ./packages/web3-providers/src/SmartPay/apis/BundlerAPI.ts
var BundlerAPI = __webpack_require__(25514);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/Web3StateAPI.ts
var Web3StateAPI = __webpack_require__(39850);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/interceptors/Popups.ts









class Popups {
    Web3 = new ConnectionReadonlyAPI/* ConnectionReadonlyAPI */.S();
    Contract = new ContractReadonlyAPI/* ContractReadonlyAPI */.M();
    AbstractAccount = new AbstractAccountAPI/* SmartPayAccountAPI */.C();
    get networks() {
        if (!Web3StateAPI.Web3StateRef.value?.Network) throw new Error('The web3 state does not load yet.');
        return Web3StateAPI.Web3StateRef.value.Network.networks?.getCurrentValue();
    }
    async getPaymentToken(context) {
        const maskAddress = (0,helpers_address/* getMaskTokenAddress */.vY)(context.chainId);
        const nativeTokenAddress = (0,helpers_address/* getNativeTokenAddress */.rG)(context.chainId);
        const DEFAULT_PAYMENT_TOKEN_STATE = {
            allowMaskAsGas: false,
            paymentToken: nativeTokenAddress
        };
        try {
            const smartPayChainId = await BundlerAPI/* SmartPayBundler */.P.getSupportedChainId();
            if (context.chainId !== smartPayChainId || !context.owner) return {
                allowMaskAsGas: false,
                paymentToken: undefined
            };
            const { PAYMASTER_MASK_CONTRACT_ADDRESS } = (0,constants/* getSmartPayConstants */.BO)(context.chainId);
            if (!PAYMASTER_MASK_CONTRACT_ADDRESS) return DEFAULT_PAYMENT_TOKEN_STATE;
            const { signableConfig } = PayloadEditor/* PayloadEditor */._.fromPayload(context.request, {
                chainId: context.chainId
            });
            if (!signableConfig?.maxFeePerGas) return DEFAULT_PAYMENT_TOKEN_STATE;
            const gas = await this.AbstractAccount.estimateTransaction?.(smartPayChainId, signableConfig, {
                paymentToken: maskAddress
            });
            const depositPaymaster = new DepositPaymaster/* DepositPaymaster */.h(context.chainId);
            const ratio = await depositPaymaster.getRatio();
            const maskGasFee = (0,number/* toFixed */.FH)(new bignumber/* BigNumber */.O(signableConfig.maxFeePerGas).multipliedBy(gas ?? 0).integerValue().multipliedBy(ratio), 0);
            const maskBalance = await this.Web3.getFungibleTokenBalance(maskAddress, undefined, {
                account: context.account,
                chainId: context.chainId
            });
            const contract = this.Contract.getERC20Contract(maskAddress, {
                chainId: context.chainId
            });
            if (!contract) return DEFAULT_PAYMENT_TOKEN_STATE;
            const maskAllowance = await contract.methods.allowance(context.account, PAYMASTER_MASK_CONTRACT_ADDRESS).call({
                from: context.account
            });
            const availableBalanceTooLow = (0,number/* isGreaterThan */.T1)(maskGasFee, maskAllowance) || (0,number/* isGreaterThan */.T1)(maskGasFee, maskBalance);
            const isNative = (0,helpers_address/* isNativeTokenAddress */.qw)(context.paymentToken);
            return {
                allowMaskAsGas: !availableBalanceTooLow,
                paymentToken: isNative ? context.paymentToken : !availableBalanceTooLow ? maskAddress : nativeTokenAddress
            };
        } catch (error) {
            const nativeBalance = await this.Web3.getNativeTokenBalance({
                account: context.account,
                chainId: context.chainId
            });
            if ((0,number/* isZero */.Fr)(nativeBalance)) return {
                allowMaskAsGas: true,
                paymentToken: context.paymentToken ?? maskAddress
            };
            return DEFAULT_PAYMENT_TOKEN_STATE;
        }
    }
    async fn(context, next) {
        if (!context.risky || !context.writeable) {
            await next();
            return;
        }
        try {
            const MaskProvider = providers/* Providers */.C[types/* ProviderType */.lP.MaskWallet];
            const currentChainId = MaskProvider.subscription.chainId.getCurrentValue();
            if (context.method === types/* EthereumMethodType */.W8.ETH_SEND_TRANSACTION && currentChainId !== context.chainId) {
                await MaskProvider.switchChain(context.chainId);
                // if send risky requests to a custom network, the providerURL must be provided.
                const matchNetworkByProviderURL = this.networks?.find((x)=>x.isCustomized && (0,isSameURL/* isSameURL */.U)(x.rpcUrl, context.providerURL));
                // a built-in network will be matched by chainId
                const matchNetworkByChainId = this.networks?.find((x)=>!x.isCustomized && x.chainId === context.chainId);
                const network = matchNetworkByProviderURL ?? matchNetworkByChainId;
                if (!network) throw new Error('Failed to locate network. The providerURL must be given when sending risky requests to a custom network.');
                await Web3StateAPI.Web3StateRef.value.Network?.switchNetwork(network?.ID);
            }
            if (!Web3StateAPI.Web3StateRef.value.Message) throw new Error('Failed to approve request.');
            const request = {
                state: specs/* MessageStateType */.Rq.NOT_DEPEND,
                request: {
                    arguments: context.requestArguments,
                    options: {
                        ...await this.getPaymentToken(context),
                        silent: context.silent,
                        owner: context.owner,
                        identifier: context.identifier?.toText(),
                        providerURL: context.providerURL,
                        gasOptionType: context.gasOptionType
                    }
                }
            };
            const { request: updates, response } = await Web3StateAPI.Web3StateRef.value.Message.applyAndWaitResponse(request);
            context.config = {
                ...context.config,
                ...updates.arguments.params[0]
            };
            const editor = ErrorEditor/* ErrorEditor */.Q.from(null, response);
            if (editor.presence || !response) {
                context.abort(editor.error);
            } else {
                context.write(response.result);
            }
        } catch (error) {
            context.abort(error);
        }
        await next();
    }
}

// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/noop.js
var noop = __webpack_require__(89601);
;// CONCATENATED MODULE: ./packages/web3-shared/evm/src/helpers/isMaskOnlyMethodType.ts

function isMaskOnlyMethodType(type) {
    return [
        types/* EthereumMethodType */.W8.MASK_DEPLOY,
        types/* EthereumMethodType */.W8.MASK_FUND,
        types/* EthereumMethodType */.W8.MASK_LOGIN,
        types/* EthereumMethodType */.W8.MASK_LOGOUT,
        types/* EthereumMethodType */.W8.MASK_WALLETS,
        types/* EthereumMethodType */.W8.MASK_ADD_WALLET,
        types/* EthereumMethodType */.W8.MASK_UPDATE_WALLET,
        types/* EthereumMethodType */.W8.MASK_RENAME_WALLET,
        types/* EthereumMethodType */.W8.MASK_REMOVE_WALLET,
        types/* EthereumMethodType */.W8.MASK_UPDATE_WALLETS,
        types/* EthereumMethodType */.W8.MASK_REMOVE_WALLETS,
        types/* EthereumMethodType */.W8.MASK_RESET_ALL_WALLETS,
        types/* EthereumMethodType */.W8.MASK_REPLACE_TRANSACTION
    ].includes(type);
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/interceptors/CustomNetwork.ts





class CustomNetwork {
    Web3 = new ConnectionReadonlyAPI/* ConnectionReadonlyAPI */.S();
    get networks() {
        if (!Web3StateAPI.Web3StateRef.value?.Network) throw new Error('The web3 state does not load yet.');
        return Web3StateAPI.Web3StateRef.value.Network.networks?.getCurrentValue();
    }
    get customNetwork() {
        if (!Web3StateAPI.Web3StateRef.value?.Network) throw new Error('The web3 state does not load yet.');
        const network = Web3StateAPI.Web3StateRef.value.Network.network?.getCurrentValue();
        return network?.isCustomized ? network : undefined;
    }
    async fn(context, next) {
        const customNetwork = this.networks?.find((x)=>x.isCustomized && (0,isSameURL/* isSameURL */.U)(x.rpcUrl, context.providerURL));
        if (!customNetwork || context.risky || !context.writeable || isMaskOnlyMethodType(context.method)) {
            await next();
            return;
        }
        try {
            const response = await this.Web3.getWeb3Provider({
                chainId: context.chainId,
                account: context.account,
                providerURL: context.providerURL ?? // only attach providerURL when chainId got exactly matched.
                (this.customNetwork?.chainId === context.chainId ? this.customNetwork.rpcUrl : undefined)
            }).sendAsync(context.request, noop/* default */.Z);
            const editor = ErrorEditor/* ErrorEditor */.Q.from(null, response);
            if (editor.presence) {
                context.abort(editor.error);
            } else {
                context.write(response.result);
            }
        } catch (error) {
            context.abort(error);
        }
        await next();
    }
}

// EXTERNAL MODULE: ./packages/web3-providers/src/SmartPay/apis/FunderAPI.ts + 1 modules
var FunderAPI = __webpack_require__(92848);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/middleware/Interceptor.ts










class Interceptor {
    signWithPersona;
    Account;
    Funder;
    constructor(signWithPersona){
        this.signWithPersona = signWithPersona;
        this.Account = new AbstractAccountAPI/* SmartPayAccountAPI */.C();
        this.Funder = new FunderAPI/* SmartPayFunderAPI */.B();
        this.composers = {
            [types/* ProviderType */.lP.None]: Composer.from(new NoneWallet()),
            [types/* ProviderType */.lP.MaskWallet]: Composer.from(new Popups(), new CustomNetwork(), new ContractWallet(types/* ProviderType */.lP.MaskWallet, this.Account, BundlerAPI/* SmartPayBundler */.P, this.Funder, this.signWithPersona), new MaskWallet()),
            [types/* ProviderType */.lP.MetaMask]: Composer.from(new MetaMaskLike(types/* ProviderType */.lP.MetaMask)),
            [types/* ProviderType */.lP.WalletConnect]: Composer.from(new WalletConnect()),
            [types/* ProviderType */.lP.Coin98]: Composer.from(new MetaMaskLike(types/* ProviderType */.lP.Coin98)),
            [types/* ProviderType */.lP.Fortmatic]: Composer.from(new Fortmatic()),
            [types/* ProviderType */.lP.Opera]: Composer.from(new MetaMaskLike(types/* ProviderType */.lP.Opera)),
            [types/* ProviderType */.lP.Clover]: Composer.from(new MetaMaskLike(types/* ProviderType */.lP.Clover))
        };
    }
    composers;
    async fn(context, next) {
        const composer = this.composers[context.providerType];
        if (!composer || !context.writeable) {
            await next();
            return;
        }
        await composer.dispatch(context, next);
    }
}

// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/getTransactionStatusType.ts
var getTransactionStatusType = __webpack_require__(29530);
// EXTERNAL MODULE: ./packages/web3-providers/src/SmartPay/libs/UserTransaction.ts + 1 modules
var UserTransaction = __webpack_require__(7247);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/middleware/RecentTransaction.ts




class RecentTransaction {
    async fn(context, next) {
        // before sending a transaction, we measure the drafted time of such a transaction
        const draftedAt = new Date();
        await next();
        const { Transaction, BalanceNotifier, BlockNumberNotifier } = Web3StateAPI.Web3StateRef.value;
        try {
            switch(context.method){
                case types/* EthereumMethodType */.W8.ETH_SEND_TRANSACTION:
                    const tx = context.result;
                    if (!tx || !context.config) return;
                    const account = context.config.from ?? context.account;
                    const chainId = context.config.chainId ?? context.chainId;
                    await Transaction?.addTransaction?.(chainId, account, tx, {
                        ...context.config,
                        draftedAt
                    });
                    break;
                case types/* EthereumMethodType */.W8.MASK_DEPLOY:
                case types/* EthereumMethodType */.W8.MASK_FUND:
                    const tx_ = context.result;
                    if (!tx_ || !context.config) return;
                    await Transaction?.addTransaction?.(context.chainId, '', tx_, {
                        ...context.config,
                        from: '',
                        draftedAt
                    });
                    break;
                case types/* EthereumMethodType */.W8.ETH_SEND_USER_OPERATION:
                    if (!context.userOperation || typeof context.result !== 'string') return;
                    const transaction = UserTransaction/* UserTransaction */.k.toTransaction(context.chainId, context.userOperation);
                    await Transaction?.addTransaction?.(context.chainId, context.account, context.result, {
                        ...transaction,
                        draftedAt
                    });
                    break;
                case types/* EthereumMethodType */.W8.ETH_GET_TRANSACTION_RECEIPT:
                    const receipt = context.result;
                    const status = (0,getTransactionStatusType/* getTransactionStatusType */.j)(receipt);
                    if (!receipt?.transactionHash || status === specs.TransactionStatusType.NOT_DEPEND) return;
                    BalanceNotifier?.emitter.emit('update', {
                        chainId: context.chainId,
                        account: receipt.from
                    });
                    // it could be a contract address, but it doesn't matter
                    BalanceNotifier?.emitter.emit('update', {
                        chainId: context.chainId,
                        account: receipt.to
                    });
                    BlockNumberNotifier?.emitter.emit('update', context.chainId);
                    break;
                case types/* EthereumMethodType */.W8.MASK_REPLACE_TRANSACTION:
                    if (!context.config || typeof context.result !== 'string') return;
                    const [hash] = context.request.params;
                    await Transaction?.replaceTransaction?.(context.chainId, context.account, hash, context.result, context.config);
                    break;
            }
        } catch  {}
    }
} // to record tx in the database, allow to fail silently

;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/middleware/TransactionWatcher.ts


class TransactionWatcher {
    async fn(context, next) {
        await next();
        const failedToSendTransaction = context.error && [
            types/* EthereumMethodType */.W8.MASK_DEPLOY,
            types/* EthereumMethodType */.W8.MASK_FUND,
            types/* EthereumMethodType */.W8.ETH_SEND_TRANSACTION,
            types/* EthereumMethodType */.W8.ETH_SEND_USER_OPERATION
        ].includes(context.method);
        const failedToEstimateTransaction = context.error?.isRecognized && context.method === types/* EthereumMethodType */.W8.ETH_ESTIMATE_GAS;
        if (failedToSendTransaction || failedToEstimateTransaction) {
            await Web3StateAPI.Web3StateRef.value.TransactionWatcher?.notifyError(context.error, context.request);
        }
    }
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/apis/ComposerAPI.ts






class ComposerAPI {
    instance;
    compose(signWithPersona) {
        if (this.instance) return this.instance;
        const instance = Composer.from(new Nonce(), new Translator(), new Interceptor(signWithPersona), new RecentTransaction(), new TransactionWatcher());
        this.instance = instance;
        return instance;
    }
}

// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/ConnectionOptionsAPI.ts
var ConnectionOptionsAPI = __webpack_require__(2685);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/RequestReadonlyAPI.ts
var RequestReadonlyAPI = __webpack_require__(64043);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/omitBy.js + 1 modules
var omitBy = __webpack_require__(72802);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isUndefined.js
var isUndefined = __webpack_require__(81770);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/omit.js + 1 modules
var omit = __webpack_require__(17711);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/parseChainId.ts
var parseChainId = __webpack_require__(64371);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/createJsonRpcPayload.ts
var createJsonRpcPayload = __webpack_require__(83135);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/createJsonRpcResponse.ts
var createJsonRpcResponse = __webpack_require__(48221);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/libs/ConnectionContext.ts


let pid = 0;
class ConnectionContext {
    _requestArguments;
    _options;
    _init;
    id;
    _writeable;
    _error;
    _result;
    _account;
    _chainId;
    _providerType;
    constructor(_requestArguments, _options, _init){
        this._requestArguments = _requestArguments;
        this._options = _options;
        this._init = _init;
        this.id = 0;
        this._writeable = true;
        this._error = null;
        this._account = '';
        this._chainId = types/* ChainId */.a_.Mainnet;
        this._providerType = types/* ProviderType */.lP.MaskWallet;
        // increase pid
        pid += 1;
        this.id = pid;
        this._account = this._init?.getDefaultAccount?.(this.providerType) ?? '';
        this._chainId = this._init?.getDefaultChainId?.(this.providerType) ?? types/* ChainId */.a_.Mainnet;
        this._providerType = this._init?.getDefaultProviderType() ?? types/* ProviderType */.lP.MaskWallet;
    }
    get errorEditor() {
        return ErrorEditor/* ErrorEditor */.Q.from(this._error, this.response, 'Failed to send request.');
    }
    get payloadEditor() {
        return PayloadEditor/* PayloadEditor */._.fromPayload(this.request, this._options);
    }
    get writeable() {
        return this._writeable;
    }
    get account() {
        return this.payloadEditor.from ?? this._options?.overrides?.from ?? this._options?.account ?? this._account;
    }
    get chainId() {
        return this.payloadEditor.chainId ?? this._options?.overrides?.chainId ?? this._options?.chainId ?? this._chainId;
    }
    get chainDescriptor() {
        return this.payloadEditor.chainDescriptor;
    }
    get providerType() {
        return this.requestOptions?.providerType ?? this._options?.providerType ?? this._providerType;
    }
    get providerURL() {
        return this.requestOptions.providerURL ?? this._options?.providerURL;
    }
    get method() {
        return this.request.method;
    }
    get risky() {
        return this.payloadEditor.risky;
    }
    get message() {
        return this.payloadEditor.signableMessage;
    }
    get config() {
        return (0,omitBy/* default */.Z)({
            ...this.payloadEditor.config,
            ...this._options?.overrides,
            from: this._options?.overrides?.from || this.payloadEditor.config?.from,
            chainId: (0,parseChainId/* parseChainId */.D)(this._options?.overrides?.chainId) ?? this.payloadEditor.config.chainId
        }, isUndefined/* default */.Z);
    }
    set config(config) {
        if (!this.config || !config) return;
        const method = this._requestArguments.method;
        switch(method){
            case types/* EthereumMethodType */.W8.MASK_REPLACE_TRANSACTION:
                this._requestArguments = {
                    method: this.method,
                    params: [
                        this._requestArguments.params[0],
                        config
                    ]
                };
                break;
            case types/* EthereumMethodType */.W8.ETH_SEND_TRANSACTION:
                const params = this.providerType !== types/* ProviderType */.lP.Clover ? config : (0,omit/* default */.Z)(config, 'chainId');
                this._requestArguments = {
                    method: this.method,
                    params: [
                        params,
                        'latest'
                    ]
                };
                break;
            default:
                break;
        }
    }
    get wallet() {
        return this.payloadEditor.wallet;
    }
    get userOperation() {
        return this.payloadEditor.userOperation;
    }
    get proof() {
        return this.payloadEditor.proof;
    }
    get requestId() {
        return this.id;
    }
    /**
     * Abstract account owner address
     */ get owner() {
        return this.payloadEditor.owner || this._options?.owner || this._init?.getDefaultOwner?.(this.providerType);
    }
    /**
     * Abstract account owner persona public key
     */ get identifier() {
        return this.payloadEditor.identifier || this._options?.identifier || this._init?.getDefaultIdentifier?.(this.providerType);
    }
    get paymentToken() {
        return this._options?.paymentToken;
    }
    get gasOptionType() {
        return this._options?.gasOptionType;
    }
    get silent() {
        return this._options?.silent;
    }
    get requestOptions() {
        return {
            ...this._options
        };
    }
    get requestArguments() {
        return this._requestArguments;
    }
    set requestArguments(requestArguments) {
        this._requestArguments = requestArguments;
    }
    /**
     * JSON RPC request payload
     */ get request() {
        return (0,createJsonRpcPayload/* createJsonRpcPayload */.B)(this.id, this.requestArguments);
    }
    /**
     * JSON RPC response object
     */ get response() {
        if (this._writeable) return;
        return (0,createJsonRpcResponse/* createJsonRpcResponse */.T)(this.id, this._result);
    }
    get error() {
        if (this._writeable) return null;
        if (this.errorEditor.presence) return this.errorEditor.error;
        return null;
    }
    set error(error) {
        this._error = error;
    }
    get result() {
        return this._result;
    }
    set result(result) {
        this._result = result;
    }
    /**
     * Resolve a request and write down the result into the context. Alias of end(null, result)
     */ write(result) {
        this.end(null, result);
    }
    /**
     * Reject a request and throw an error. Alias of end(error)
     */ abort(error, fallback = 'Failed to send request.') {
        this.end(error || new Error(fallback));
    }
    /**
     * Seal a request by resolving or rejecting it.
     */ end(error = null, result) {
        if (!this._writeable) return;
        this._writeable = false;
        this.error = error;
        this.result = result;
    }
    toJSON() {
        return {};
    }
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/helpers/createContext.ts




const initializer = {
    getDefaultAccount (providerType) {
        return providerType === types/* ProviderType */.lP.MaskWallet ? '' : Web3StateAPI.Web3StateRef.value.Provider?.account?.getCurrentValue();
    },
    getDefaultChainId (providerType) {
        return providerType === types/* ProviderType */.lP.MaskWallet ? types/* ChainId */.a_.Mainnet : Web3StateAPI.Web3StateRef.value.Provider?.chainId?.getCurrentValue();
    },
    getDefaultProviderType () {
        return Web3StateAPI.Web3StateRef.value.Provider?.providerType?.getCurrentValue();
    },
    getDefaultOwner (providerType) {
        const provider = providers/* Providers */.C[providerType];
        return provider?.ownerAccount;
    },
    getDefaultIdentifier (providerType) {
        const provider = providers/* Providers */.C[providerType];
        return provider?.ownerIdentifier;
    }
};
function createContext(requestArguments, options) {
    return new ConnectionContext(requestArguments, options, initializer);
}

// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/createWeb3FromProvider.ts
var createWeb3FromProvider = __webpack_require__(77383);
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/createWeb3ProviderFromRequest.ts
var createWeb3ProviderFromRequest = __webpack_require__(14899);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/apis/RequestAPI.ts









class RequestAPI extends RequestReadonlyAPI/* RequestReadonlyAPI */.c {
    Composer = new ComposerAPI();
    Request = new RequestReadonlyAPI/* RequestReadonlyAPI */.c(this.options);
    ConnectionOptions = new ConnectionOptionsAPI/* ConnectionOptionsAPI */.T(this.options);
    get Provider() {
        if (!Web3StateAPI.Web3StateRef.value.Provider) throw new Error('The web3 state does not load yet.');
        return Web3StateAPI.Web3StateRef.value.Provider;
    }
    // Hijack RPC requests and process them with koa like middleware
    get request() {
        return (requestArguments, initial)=>{
            return new Promise(async (resolve, reject)=>{
                const options = this.ConnectionOptions.fill(initial);
                const context = createContext(requestArguments, options);
                try {
                    await this.Composer.compose(this.Provider.signWithPersona).dispatch(context, async ()=>{
                        if (!context.writeable) return;
                        try {
                            switch(context.method){
                                case types/* EthereumMethodType */.W8.MASK_LOGIN:
                                    context.write(await this.Provider?.connect(options.providerType, options.chainId, options.account, options.owner ? {
                                        account: options.owner,
                                        identifier: options.identifier
                                    } : undefined, options.silent));
                                    break;
                                case types/* EthereumMethodType */.W8.MASK_LOGOUT:
                                    context.write(await this.Provider?.disconnect(options.providerType));
                                    break;
                                default:
                                    {
                                        if (!PayloadEditor/* PayloadEditor */._.fromPayload(context.request).readonly) {
                                            const web3Provider = providers/* Providers */.C[options.providerType].createWeb3Provider({
                                                account: options.account,
                                                chainId: options.chainId
                                            });
                                            // send request and set result in the context
                                            context.write(await web3Provider.request(context.requestArguments));
                                        } else {
                                            context.write(await this.Request.request(context.requestArguments, {
                                                account: options.account,
                                                chainId: options.chainId
                                            }));
                                        }
                                        break;
                                    }
                            }
                        } catch (error) {
                            context.abort(error);
                        }
                    });
                } catch (error) {
                    context.abort(error);
                } finally{
                    if (context.error) reject(context.error);
                    else resolve(context.result);
                }
            });
        };
    }
    getWeb3(initial) {
        const options = this.ConnectionOptions.fill(initial);
        if (options.readonly) return this.Request.getWeb3(options);
        return (0,createWeb3FromProvider/* createWeb3FromProvider */.B)((0,createWeb3ProviderFromRequest/* createWeb3ProviderFromRequest */.k)((requestArguments)=>this.request(requestArguments, options)));
    }
    getWeb3Provider(initial) {
        const options = this.ConnectionOptions.fill(initial);
        if (options.readonly) return this.Request.getWeb3Provider(options);
        return (0,createWeb3ProviderFromRequest/* createWeb3ProviderFromRequest */.k)((requestArguments)=>this.request(requestArguments, options));
    }
}


/***/ }),

/***/ 64043:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ RequestReadonlyAPI)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23865);
/* harmony import */ var _ConnectionOptionsReadonlyAPI_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(68070);
/* harmony import */ var _helpers_createWeb3FromURL_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23877);
/* harmony import */ var _helpers_createWeb3ProviderFromURL_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(18734);




class RequestReadonlyAPI {
    options;
    constructor(options){
        this.options = options;
        this.ConnectionOptions = new _ConnectionOptionsReadonlyAPI_js__WEBPACK_IMPORTED_MODULE_0__/* .ConnectionOptionsReadonlyAPI */ .X(options);
    }
    ConnectionOptions;
    get request() {
        return async (requestArguments, initial)=>{
            return await this.getWeb3Provider(initial).request(requestArguments);
        };
    }
    getWeb3(initial) {
        const options = this.ConnectionOptions.fill(initial);
        return (0,_helpers_createWeb3FromURL_js__WEBPACK_IMPORTED_MODULE_1__/* .createWeb3FromURL */ .x)(options.providerURL ?? _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ProviderURL */ .C.from(options.chainId));
    }
    getWeb3Provider(initial) {
        const options = this.ConnectionOptions.fill(initial);
        return (0,_helpers_createWeb3ProviderFromURL_js__WEBPACK_IMPORTED_MODULE_3__/* .createWeb3ProviderFromURL */ .K)(options.providerURL ?? _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .ProviderURL */ .C.from(options.chainId));
    }
}


/***/ }),

/***/ 66979:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VN: () => (/* binding */ NetworkResolver),
/* harmony export */   Xz: () => (/* binding */ ExplorerResolver),
/* harmony export */   fh: () => (/* binding */ ProviderResolver),
/* harmony export */   iv: () => (/* binding */ ChainResolver)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3187);
/* deferred harmony import */ var _Web3StateAPI_js__WEBPACK_IMPORTED_MODULE_1__ = {
	/* namespace */ get a() {
		var exports = __webpack_require__(39850);
		Object.defineProperty(this, "a", { value: exports });
		return exports;
	}

};
/* harmony import */ var _Base_apis_ChainResolverAPI_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26197);
/* harmony import */ var _Base_apis_ExplorerResolverAPI_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(12030);
/* harmony import */ var _Base_apis_ProviderResolverAPI_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(31710);
/* harmony import */ var _Base_apis_NetworkExplorerAPI_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(92845);






class ChainResolverAPI extends _Base_apis_ChainResolverAPI_js__WEBPACK_IMPORTED_MODULE_0__/* .ChainResolverAPI_Base */ .p {
    get descriptors() {
        if (!_Web3StateAPI_js__WEBPACK_IMPORTED_MODULE_1__.a.Web3StateRef.value?.Network?.networks) return _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .CHAIN_DESCRIPTORS */ .Q_;
        return _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .CHAIN_DESCRIPTORS */ .Q_.concat(_Web3StateAPI_js__WEBPACK_IMPORTED_MODULE_1__.a.Web3StateRef.value.Network.networks.getCurrentValue());
    }
}
class ExplorerResolverAPI extends _Base_apis_ExplorerResolverAPI_js__WEBPACK_IMPORTED_MODULE_3__/* .ExplorerResolverAPI_Base */ .I {
    get descriptors() {
        if (!_Web3StateAPI_js__WEBPACK_IMPORTED_MODULE_1__.a.Web3StateRef.value?.Network?.networks) return _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .CHAIN_DESCRIPTORS */ .Q_;
        return _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .CHAIN_DESCRIPTORS */ .Q_.concat(_Web3StateAPI_js__WEBPACK_IMPORTED_MODULE_1__.a.Web3StateRef.value.Network.networks.getCurrentValue());
    }
    initial = undefined;
}
class ProviderResolverAPI extends _Base_apis_ProviderResolverAPI_js__WEBPACK_IMPORTED_MODULE_4__/* .ProviderResolverAPI_Base */ .P {
    descriptors = _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .PROVIDER_DESCRIPTORS */ .zM;
}
class NetworkResolverAPI extends _Base_apis_NetworkExplorerAPI_js__WEBPACK_IMPORTED_MODULE_5__/* .NetworkResolverAPI_Base */ .n {
    descriptors = _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .NETWORK_DESCRIPTORS */ .qQ;
}
const ChainResolver = new ChainResolverAPI();
const ExplorerResolver = new ExplorerResolverAPI();
const ProviderResolver = new ProviderResolverAPI();
const NetworkResolver = new NetworkResolverAPI();


/***/ }),

/***/ 66402:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  C: () => (/* binding */ Providers)
});

// EXTERNAL MODULE: ./packages/flags/src/index.ts
var src = __webpack_require__(51573);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/types/index.ts
var types = __webpack_require__(24770);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/head.js
var head = __webpack_require__(81755);
// EXTERNAL MODULE: ./node_modules/.pnpm/web3-utils@1.10.2/node_modules/web3-utils/lib/index.js
var lib = __webpack_require__(84976);
// EXTERNAL MODULE: ./node_modules/.pnpm/@servie+events@3.0.0/node_modules/@servie/events/dist/index.js
var dist = __webpack_require__(93441);
// EXTERNAL MODULE: ./node_modules/.pnpm/@masknet+kit@0.1.2/node_modules/@masknet/kit/esm/index.js + 1 modules
var esm = __webpack_require__(30898);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/isValidChainId.ts
var isValidChainId = __webpack_require__(37049);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/libs/ProviderURL.ts
var ProviderURL = __webpack_require__(23865);
// EXTERNAL MODULE: ./packages/shared-base/src/helpers/subscription.ts
var subscription = __webpack_require__(28129);
// EXTERNAL MODULE: ./packages/shared-base/src/constants.ts
var constants = __webpack_require__(52033);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/ResolverAPI.ts
var ResolverAPI = __webpack_require__(66979);
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/createWeb3FromProvider.ts
var createWeb3FromProvider = __webpack_require__(77383);
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/createWeb3ProviderFromRequest.ts
var createWeb3ProviderFromRequest = __webpack_require__(14899);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/providers/Base.ts









class BaseProvider {
    providerType;
    context;
    constructor(providerType){
        this.providerType = providerType;
        this.emitter = new dist/* Emitter */.Q5();
    }
    emitter;
    get subscription() {
        return {
            account: (0,subscription/* createConstantSubscription */.qY)(''),
            chainId: (0,subscription/* createConstantSubscription */.qY)(types/* ChainId */.a_.Mainnet),
            wallets: (0,subscription/* createConstantSubscription */.qY)(constants/* EMPTY_LIST */.rP)
        };
    }
    get connected() {
        return false;
    }
    /**
     * This field indicates the provider is ready to be set up.
     * Please make sure that the provider SDK or global environment is ready.
     * No need to wait by default
     */ get ready() {
        return true;
    }
    /**
     * This field indicates the provider is ready to be set up.
     * Please make sure that the provider SDK or global environment is ready.
     * No need to wait by default
     */ get readyPromise() {
        return Promise.resolve();
    }
    async setup(context) {
        if (context) {
            this.context = context;
            return;
        }
        throw new Error('Method not implemented.');
    }
    addWallet(wallet) {
        throw new Error('Method not implemented.');
    }
    updateWallet(address, wallet) {
        throw new Error('Method not implemented.');
    }
    renameWallet(address, name) {
        throw new Error('Method not implemented.');
    }
    removeWallet(address, password) {
        throw new Error('Method not implemented.');
    }
    updateWallets(wallets) {
        throw new Error('Method not implemented.');
    }
    removeWallets(wallets) {
        throw new Error('Method not implemented.');
    }
    resetAllWallets() {
        throw new Error('Method not implemented.');
    }
    async switchAccount(account) {
        throw new Error('Method not implemented.');
    }
    // Switch chain with RPC calls by default
    async switchChain(chainId) {
        if (!(0,isValidChainId/* isValidChainId */.J)(chainId)) throw new Error('Invalid chain id.');
        try {
            await this.request({
                method: types/* EthereumMethodType */.W8.WALLET_SWITCH_ETHEREUM_CHAIN,
                params: [
                    {
                        chainId: (0,lib.toHex)(chainId)
                    }
                ]
            });
        } catch (error) {
            const errorMessage = error?.message;
            // error message if the chain doesn't exist from metamask
            // Unrecognized chain ID "xxx". Try adding the chain using wallet_addEthereumChain first.
            if (typeof errorMessage === 'string' && (errorMessage?.includes(types/* EthereumMethodType */.W8.WALLET_ADD_ETHEREUM_CHAIN) || errorMessage?.includes('addEthereumChain'))) {
                await this.request({
                    method: types/* EthereumMethodType */.W8.WALLET_ADD_ETHEREUM_CHAIN,
                    params: [
                        {
                            chainId: (0,lib.toHex)(chainId),
                            chainName: ResolverAPI/* ChainResolver */.iv.chainFullName(chainId) ?? ResolverAPI/* ChainResolver */.iv.chainName(chainId),
                            nativeCurrency: ResolverAPI/* ChainResolver */.iv.nativeCurrency(chainId),
                            rpcUrls: [
                                ProviderURL/* ProviderURL */.C.fromOfficial(chainId)
                            ],
                            blockExplorerUrls: [
                                ResolverAPI/* ChainResolver */.iv.explorerUrl(chainId)?.url
                            ]
                        }
                    ]
                });
            } else {
                throw error;
            }
        }
        // Delay to make sure the provider will return the newest chain id.
        await (0,esm/* delay */.gw)(1000);
        const actualChainId = await this.request({
            method: types/* EthereumMethodType */.W8.ETH_CHAIN_ID,
            params: []
        });
        if (Number.parseInt(actualChainId, 16) !== chainId) throw new Error(`Failed to switch to ${ResolverAPI/* ChainResolver */.iv.chainFullName(chainId)}.`);
    }
    // A provider should at least implement a RPC request method.
    // Then it can be used to create an external provider for web3js.
    async request(requestArguments, options) {
        throw new Error('Method not implemented.');
    }
    // Create a web3 instance from the external provider by default.
    createWeb3(options) {
        return (0,createWeb3FromProvider/* createWeb3FromProvider */.B)((0,createWeb3ProviderFromRequest/* createWeb3ProviderFromRequest */.k)((requestArguments)=>this.request(requestArguments, options)));
    }
    // Create an external provider from the basic request method.
    createWeb3Provider(options) {
        return (0,createWeb3ProviderFromRequest/* createWeb3ProviderFromRequest */.k)((requestArguments)=>this.request(requestArguments, options));
    }
    async connect(expectedChainId, address) {
        const accounts = await this.request({
            method: types/* EthereumMethodType */.W8.ETH_REQUEST_ACCOUNTS,
            params: []
        });
        const chainId = await this.request({
            method: types/* EthereumMethodType */.W8.ETH_CHAIN_ID,
            params: []
        });
        const actualChainId = Number.parseInt(chainId, 16);
        if (expectedChainId !== actualChainId) throw new Error(`Failed to connect to ${this.providerType}`);
        return {
            chainId: actualChainId,
            account: (0,head/* default */.Z)(accounts) ?? ''
        };
    }
    async disconnect() {}
} // do nothing by default

// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/RequestReadonlyAPI.ts
var RequestReadonlyAPI = __webpack_require__(64043);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/providers/None.ts



class NoneProvider extends BaseProvider {
    Request = new RequestReadonlyAPI/* RequestReadonlyAPI */.c();
    constructor(){
        super(types/* ProviderType */.lP.None);
    }
    async request(requestArguments, initial) {
        return this.Request.request(requestArguments, initial);
    }
}

// EXTERNAL MODULE: ./packages/injected-script/sdk/index.ts
var sdk = __webpack_require__(46110);
// EXTERNAL MODULE: ./packages/shared-base/src/Site/index.ts
var Site = __webpack_require__(68422);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/providers/BaseInjected.ts




class BaseInjectedProvider extends BaseProvider {
    providerType;
    bridge;
    constructor(providerType, bridge){
        super(providerType);
        this.providerType = providerType;
        this.bridge = bridge;
    }
    get ready() {
        return this.bridge.isReady;
    }
    get readyPromise() {
        if ((0,Site/* isInPageEthereumInjected */.UX)()) return this.bridge.untilAvailable();
        return Promise.reject(new Error('Not available on extension site.'));
    }
    async setup(context) {
        this.bridge.on('accountsChanged', this.onAccountsChanged.bind(this));
        this.bridge.on('chainChanged', this.onChainChanged.bind(this));
        this.bridge.on('disconnect', this.onDisconnect.bind(this));
    }
    onAccountsChanged(accounts) {
        this.emitter.emit('accounts', accounts);
    }
    onChainChanged(chainId) {
        this.emitter.emit('chainId', chainId);
    }
    onDisconnect() {
        this.emitter.emit('disconnect', this.providerType);
    }
    createWeb3Provider(options) {
        if (!this.bridge) throw new Error('Failed to detect in-page provider.');
        return this.bridge;
    }
    async request(requestArguments, options) {
        const provider = this.createWeb3Provider(options);
        return provider.request(requestArguments);
    }
    async connect() {
        await this.readyPromise;
        const provider = this.createWeb3Provider();
        const accounts = await provider.request({
            method: types/* EthereumMethodType */.W8.ETH_REQUEST_ACCOUNTS,
            params: []
        });
        const chainId = await provider.request({
            method: types/* EthereumMethodType */.W8.ETH_CHAIN_ID,
            params: []
        });
        return {
            chainId: Number.parseInt(chainId, 16),
            account: (0,head/* default */.Z)(accounts) ?? ''
        };
    }
    async disconnect() {
        try {
            await this.readyPromise;
            await this.bridge.disconnect();
        } catch  {
            return;
        }
    }
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/providers/Browser.ts



class BrowserProvider extends BaseInjectedProvider {
    constructor(){
        super(types/* ProviderType */.lP.Browser, sdk/* injectedBrowserProvider */.mA);
    }
    onAccountsChanged(accounts) {
        if (accounts.length) this.emitter.emit('accounts', accounts);
        else // disconnection will trigger an empty accounts list
        this.emitter.emit('disconnect', types/* ProviderType */.lP.Browser);
    }
    async disconnect() {}
    // do nothing
    onDisconnect() {}
} // do nothing

// EXTERNAL MODULE: ./node_modules/.pnpm/@metamask+inpage-provider@8.1.0/node_modules/@metamask/inpage-provider/dist/index.js
var inpage_provider_dist = __webpack_require__(73539);
// EXTERNAL MODULE: ./node_modules/.pnpm/extension-port-stream@1.0.0/node_modules/extension-port-stream/index.js
var extension_port_stream = __webpack_require__(18713);
// EXTERNAL MODULE: ./node_modules/.pnpm/detect-browser@3.0.1/node_modules/detect-browser/index.js
var detect_browser = __webpack_require__(26874);
;// CONCATENATED MODULE: ./node_modules/.pnpm/@dimensiondev+metamask-extension-provider@3.0.6-20221105074301-8806fca/node_modules/@dimensiondev/metamask-extension-provider/index.js




const CHROME_ID = 'nkbihfbeogaeaoehlefnkodbefgpgknn'
const FIREFOX_ID = 'webextension@metamask.io'
const browser = (0,detect_browser.detect)()
function getMetaMaskId () {
  switch (browser && browser.name) {
    case 'chrome':
      return CHROME_ID
    case 'firefox':
      return FIREFOX_ID
    default:
      return CHROME_ID
  }
}

function createMetaMaskProvider() {
  const currentMetaMaskId = getMetaMaskId()
  const metamaskPort = chrome.runtime.connect(currentMetaMaskId)
  const pluginStream = new extension_port_stream(metamaskPort)
  return new inpage_provider_dist.MetaMaskInpageProvider(pluginStream)
}

/* harmony default export */ const metamask_extension_provider = (createMetaMaskProvider);

;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/providers/MetaMask.ts





function getInjectedProvider() {
    if ((0,Site/* isEthereumInjected */.NA)()) return Reflect.get(window, 'ethereum');
    if ((0,Site/* isInPageEthereumInjected */.UX)()) return sdk/* injectedMetaMaskProvider */.wB;
    return metamask_extension_provider();
}
class MetaMaskProvider extends BaseInjectedProvider {
    constructor(){
        super(types/* ProviderType */.lP.MetaMask, getInjectedProvider());
    }
    onAccountsChanged(accounts) {
        if (accounts.length) this.emitter.emit('accounts', accounts);
        else // disconnection will trigger an empty accounts list
        this.emitter.emit('disconnect', types/* ProviderType */.lP.MetaMask);
    }
    get ready() {
        if ((0,Site/* isEthereumInjected */.NA)()) return true;
        if ((0,Site/* isInPageEthereumInjected */.UX)()) return super.ready;
        const isConnected = this.bridge.isConnected();
        return isConnected;
    }
    get readyPromise() {
        if ((0,Site/* isEthereumInjected */.NA)()) return Promise.resolve();
        if ((0,Site/* isInPageEthereumInjected */.UX)()) return super.readyPromise;
        return Promise.resolve();
    }
    async disconnect() {}
    // do nothing
    onDisconnect() {}
} // MetaMask will emit disconnect after switching chain id
 // since then, override to stop listening to the disconnect event with MetaMask

// EXTERNAL MODULE: ./node_modules/.pnpm/@walletconnect+utils@2.7.3/node_modules/@walletconnect/utils/dist/index.es.js
var index_es = __webpack_require__(97609);
// EXTERNAL MODULE: ./node_modules/.pnpm/@walletconnect+sign-client@2.7.3/node_modules/@walletconnect/sign-client/dist/index.es.js
var dist_index_es = __webpack_require__(56992);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/formatter.ts
var formatter = __webpack_require__(41487);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/address.ts
var helpers_address = __webpack_require__(65327);
;// CONCATENATED MODULE: ./packages/web3-shared/evm/src/libs/EIP155Editor.ts

class EIP155Editor {
    chainId;
    address;
    constructor(chainId, address){
        this.chainId = chainId;
        this.address = address;
    }
    get account() {
        return {
            chainId: this.chainId,
            account: (0,formatter/* formatEthereumAddress */.j8)(this.address)
        };
    }
    get proposalNamespace() {
        return {
            accounts: [],
            methods: [
                types/* EthereumMethodType */.W8.ETH_SIGN,
                types/* EthereumMethodType */.W8.ETH_SEND_TRANSACTION,
                types/* EthereumMethodType */.W8.PERSONAL_SIGN
            ],
            chains: [
                this.eip155ChainId
            ],
            events: [
                'chainChanged',
                'accountsChanged',
                'disconnect',
                'connect'
            ]
        };
    }
    get eip155ChainId() {
        return [
            'eip155',
            this.chainId.toFixed()
        ].join(':');
    }
    get eip155Address() {
        return [
            'eip155',
            this.chainId.toFixed(),
            (0,formatter/* formatEthereumAddress */.j8)(this.address)
        ].join(':');
    }
    static from(text) {
        const [, chainId, address] = text.split(':');
        const chainId_ = Number.parseInt(chainId, 10);
        if (!(0,isValidChainId/* isValidChainId */.J)(chainId_) || !(0,helpers_address/* isValidAddress */.At)(address)) return;
        return new EIP155Editor(chainId_, address);
    }
    static fromChainId(chainId) {
        if (!(0,isValidChainId/* isValidChainId */.J)(chainId)) return;
        return new EIP155Editor(chainId, '');
    }
    static fromAccount({ chainId, account }) {
        if (!(0,isValidChainId/* isValidChainId */.J)(chainId) || !(0,helpers_address/* isValidAddress */.At)(account)) return;
        return new EIP155Editor(chainId, account);
    }
}

// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/Web3StateAPI.ts
var Web3StateAPI = __webpack_require__(39850);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/providers/WalletConnect.ts









class Client {
    emitter;
    constructor(emitter){
        this.emitter = emitter;
    }
    client;
    get session() {
        const key = this.client?.session.keys.at(-1);
        return key ? this.client?.session.get(key) : undefined;
    }
    get account() {
        const account = EIP155Editor.from((0,head/* default */.Z)(this.session?.namespaces.eip155.accounts) ?? '')?.account;
        if ((0,isValidChainId/* isValidChainId */.J)(account?.chainId) && (0,helpers_address/* isValidAddress */.At)(account?.account)) return account;
        return;
    }
    async setup() {
        this.client = await dist_index_es/* SignClient */.TN.init({
            projectId: src/* Flags */.v.wc_project_id,
            logger: src/* Flags */.v.wc_mode,
            relayUrl: src/* Flags */.v.wc_relay_url,
            metadata: {
                name: 'Mask Network',
                description: 'Your Portal To The New, Open Internet.',
                url: 'https://mask.io',
                icons: [
                    'https://dimensiondev.github.io/Mask-VI/assets/Logo/MB--Logo--Geo--ForceCircle--Blue.svg'
                ]
            }
        });
        this.client.on('session_update', ()=>{
            if (!this.account) return;
            this.emitter.emit('chainId', (0,lib.toHex)(this.account.chainId));
            this.emitter.emit('accounts', [
                this.account.account
            ]);
        });
        this.client.on('session_delete', ()=>{
            this.emitter.emit('disconnect', types/* ProviderType */.lP.WalletConnect);
        });
    }
    async destroy() {
        if (!this.client) return;
        this.client.removeAllListeners('session_update');
        this.client.removeAllListeners('session_delete');
    }
}
class WalletConnectProvider extends BaseProvider {
    client = null;
    constructor(){
        super(types/* ProviderType */.lP.WalletConnect);
        this.client = new Client(this.emitter);
        this.resume();
    }
    get currentChainId() {
        return Web3StateAPI.Web3StateRef.value.Provider?.chainId?.getCurrentValue() ?? types/* ChainId */.a_.Mainnet;
    }
    get connected() {
        return !!this.client.session;
    }
    async resume() {
        if (!this.client.client) await this.client.setup();
        if (this.client.account) await this.login(this.client.account.chainId);
    }
    async login(chainId) {
        const editor = EIP155Editor.fromChainId(chainId);
        if (!editor) throw new Error('Invalid chain id.');
        if (this.client.account) return this.client.account;
        const connected = await this.client.client?.connect({
            requiredNamespaces: {
                eip155: editor.proposalNamespace
            }
        });
        if (!connected) throw new Error('Failed to create connection.');
        const { uri, approval } = connected;
        if (uri) this.context?.openWalletConnectDialog(uri);
        await approval();
        if (uri) this.context?.closeWalletConnectDialog();
        return this.client.account;
    }
    async logout() {
        if (!this.client.session?.topic) return;
        await this.client.client?.disconnect({
            topic: this.client.session.topic,
            reason: (0,index_es/* getSdkError */.D6)('USER_DISCONNECTED')
        });
    }
    async switchChain(chainId) {
        if (!(0,isValidChainId/* isValidChainId */.J)(chainId)) throw new Error('Invalid chain id.');
        let clean;
        return new Promise((resolve, reject)=>{
            super.switchChain(chainId).catch((error)=>{
                reject(error);
            });
            clean = this.emitter.on('chainId', ()=>{
                resolve();
            });
        }).finally(()=>{
            clean?.();
        });
    }
    async connect(chainId) {
        await this.client.destroy();
        await this.client.setup();
        const account = await this.login(chainId);
        if (!account) throw new Error(`Failed to connect to ${ResolverAPI/* ChainResolver */.iv.chainFullName(chainId)}.`);
        return account;
    }
    async disconnect() {
        await this.logout();
    }
    async request(requestArguments) {
        const editor = EIP155Editor.fromChainId(this.currentChainId);
        if (!editor) throw new Error('Invalid chain id.');
        if (!this.client.client) await this.client.setup();
        if (!this.client.session) await this.login(this.currentChainId);
        if (!this.client.client || !this.client.session) throw new Error('The client is not initialized');
        return this.client.client.request({
            topic: this.client.session.topic,
            chainId: editor.eip155ChainId,
            request: {
                method: requestArguments.method,
                params: requestArguments.params
            }
        });
    }
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/providers/Coin98.ts



class EVM_Coin98Provider extends BaseInjectedProvider {
    constructor(){
        super(types/* ProviderType */.lP.Coin98, sdk/* injectedCoin98EVMProvider */.TT);
    }
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/providers/Coinbase.ts




function Coinbase_getInjectedProvider() {
    if ((0,Site/* isEthereumInjected */.NA)('coinbaseWalletExtension')) return Reflect.get(window, 'coinbaseWalletExtension');
    if ((0,Site/* isInPageEthereumInjected */.UX)()) return sdk/* injectedCoinbaseProvider */.r_;
    // Not available on extension site.
    return sdk/* injectedCoinbaseProvider */.r_;
}
class CoinbaseProvider extends BaseInjectedProvider {
    constructor(){
        super(types/* ProviderType */.lP.Coinbase, Coinbase_getInjectedProvider());
    }
    get ready() {
        if ((0,Site/* isEthereumInjected */.NA)('coinbaseWalletExtension')) return true;
        if ((0,Site/* isInPageEthereumInjected */.UX)()) return super.ready;
        return false;
    }
    get readyPromise() {
        if ((0,Site/* isEthereumInjected */.NA)('coinbaseWalletExtension')) return Promise.resolve();
        if ((0,Site/* isInPageEthereumInjected */.UX)()) return super.readyPromise;
        return Promise.resolve();
    }
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/providers/OKX.ts




function OKX_getInjectedProvider() {
    if ((0,Site/* isEthereumInjected */.NA)('okxwallet')) return Reflect.get(window, 'okxwallet');
    if ((0,Site/* isInPageEthereumInjected */.UX)()) return sdk/* injectedOKXProvider */.L7;
    // Not available on extension site.
    return sdk/* injectedOKXProvider */.L7;
}
class OKXProvider extends BaseInjectedProvider {
    constructor(){
        super(types/* ProviderType */.lP.Coinbase, OKX_getInjectedProvider());
    }
    get ready() {
        if ((0,Site/* isEthereumInjected */.NA)('okxwallet')) return true;
        if ((0,Site/* isInPageEthereumInjected */.UX)()) return super.ready;
        return false;
    }
    get readyPromise() {
        if ((0,Site/* isEthereumInjected */.NA)('okxwallet')) return Promise.resolve();
        if ((0,Site/* isInPageEthereumInjected */.UX)()) return super.readyPromise;
        return Promise.resolve();
    }
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/providers/Clover.ts



class CloverProvider extends BaseInjectedProvider {
    constructor(){
        super(types/* ProviderType */.lP.Clover, sdk/* injectedCloverProvider */.yz);
    }
}

// EXTERNAL MODULE: ./node_modules/.pnpm/fortmatic@2.2.1_patch_hash=tb3oevqnvhntsyfyhi2z6spuea/node_modules/fortmatic/dist/cjs/fortmatic.cjs
var fortmatic = __webpack_require__(6590);
var fortmatic_default = /*#__PURE__*/__webpack_require__.n(fortmatic);
// EXTERNAL MODULE: ./packages/shared-base/src/helpers/createLookupTableResolver.ts
var createLookupTableResolver = __webpack_require__(74170);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/providers/Fortmatic.ts








// #region create in-page fortmatic provider
/* spell-checker: disable-next-line */ const TEST_KEY = 'pk_test_D9EAF9A8ACEC9627';
/* spell-checker: disable-next-line */ const LIVE_KEY = 'pk_live_331BE8AA24445030';
const resolveAPI_Key = (0,createLookupTableResolver/* createLookupTableResolver */.F)({
    [types/* ChainId */.a_.Mainnet]: LIVE_KEY,
    [types/* ChainId */.a_.BSC]: LIVE_KEY,
    [types/* ChainId */.a_.Matic]: LIVE_KEY,
    [types/* ChainId */.a_.Rinkeby]: TEST_KEY,
    [types/* ChainId */.a_.Ropsten]: TEST_KEY,
    [types/* ChainId */.a_.Kovan]: TEST_KEY
}, '');
const isFortmaticSupported = (chainId)=>{
    return [
        types/* ChainId */.a_.Mainnet,
        types/* ChainId */.a_.BSC
    ].includes(chainId);
};
class FortmaticProvider extends BaseProvider {
    /**
     * If the internal chain id exists, it means the connection was created.
     * Otherwise, no connection was created before.
     */ chainId_ = null;
    providerPool = new Map();
    get chainId() {
        const chainId = this.chainId_;
        if (!chainId) throw new Error('No fortmatic connection.');
        if (!isFortmaticSupported(chainId)) throw new Error(`The chain id ${chainId} is not supported.`);
        return chainId;
    }
    set chainId(newChainId) {
        const chainId = newChainId;
        if (!isFortmaticSupported(chainId)) throw new Error(`The chain id ${chainId} is not supported.`);
        this.chainId_ = chainId;
    }
    constructor(){
        super(types/* ProviderType */.lP.Fortmatic);
    }
    onAccountsChanged(accounts) {
        this.emitter.emit('accounts', accounts);
    }
    onChainChanged(chainId) {
        this.emitter.emit('chainId', chainId);
    }
    onConnect(connected) {
        this.emitter.emit('connect', connected);
    }
    createFortmatic(chainId) {
        return new (fortmatic_default())(resolveAPI_Key(chainId), {
            chainId,
            rpcUrl: ProviderURL/* ProviderURL */.C.from(chainId)
        });
    }
    createProvider() {
        if (this.providerPool.has(this.chainId)) return this.providerPool.get(this.chainId);
        const fm = this.createFortmatic(this.chainId);
        const provider = fm.getProvider();
        this.providerPool.set(this.chainId, provider);
        return provider;
    }
    login() {
        const fm = this.createFortmatic(this.chainId);
        return fm.user.login();
    }
    async logout() {
        const fm = this.createFortmatic(this.chainId);
        return fm.user.logout();
    }
    async switchChain(chainId) {
        if (!isFortmaticSupported(chainId)) throw new Error('Invalid chain id.');
        await this.connect(chainId);
    }
    async connect(chainId) {
        try {
            this.chainId = chainId;
            const accounts = await this.login();
            if (!accounts.length) throw new Error(`Failed to connect to ${ResolverAPI/* ChainResolver */.iv.chainFullName(this.chainId)}.`);
            const connected = {
                account: (0,head/* default */.Z)(accounts),
                chainId
            };
            this.onAccountsChanged(accounts);
            this.onChainChanged((0,lib.toHex)(chainId));
            this.onConnect(connected);
            return connected;
        } catch (error) {
            this.chainId_ = null;
            throw error;
        }
    }
    async disconnect() {
        try {
            await (0,esm/* timeout */.Vs)(this.logout(), 3000, 'Timeout to logout fortmatic account.');
        } catch  {} finally// do nothing
        {
            this.chainId_ = null;
        }
    }
    request(requestArguments) {
        return this.createProvider().send(requestArguments.method, requestArguments.params);
    }
}

// EXTERNAL MODULE: ./packages/shared-base/src/Sniffings/index.ts
var Sniffings = __webpack_require__(66584);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/providers/Opera.ts





class OperaProvider extends BaseInjectedProvider {
    constructor(){
        super(types/* ProviderType */.lP.Opera, sdk/* injectedOperaProvider */.Ef);
    }
    get ready() {
        if (Sniffings/* Sniffings */.Y.is_opera) return true;
        return super.ready;
    }
    get readyPromise() {
        if (Sniffings/* Sniffings */.Y.is_opera) return Promise.resolve();
        return super.readyPromise;
    }
    async switchChain(chainId) {
        if (!(0,isValidChainId/* isValidChainId */.J)(chainId)) throw new Error('Invalid chain id.');
        await this.request({
            method: types/* EthereumMethodType */.W8.WALLET_SWITCH_ETHEREUM_CHAIN,
            params: [
                {
                    chainId: (0,lib.toHex)(chainId)
                }
            ]
        });
    }
}

// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/sortBy.js
var sortBy = __webpack_require__(89762);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/uniqWith.js
var uniqWith = __webpack_require__(9402);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/compact.js
var compact = __webpack_require__(72845);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isEqual.js
var isEqual = __webpack_require__(85094);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/debounce.js + 1 modules
var debounce = __webpack_require__(9817);
// EXTERNAL MODULE: ./packages/shared-base/src/helpers/ValueRef.ts
var ValueRef = __webpack_require__(88547);
// EXTERNAL MODULE: ./packages/shared-base/src/types/Wallet.ts
var Wallet = __webpack_require__(58190);
// EXTERNAL MODULE: ./packages/shared-base/src/Messages/CrossIsolationEvents.ts
var CrossIsolationEvents = __webpack_require__(40514);
// EXTERNAL MODULE: ./packages/shared-base/src/Site/types.ts
var Site_types = __webpack_require__(77953);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/isSameAddress.ts
var isSameAddress = __webpack_require__(74765);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/libs/PayloadEditor.ts + 1 modules
var PayloadEditor = __webpack_require__(61227);
// EXTERNAL MODULE: ./packages/shared-base/src/KVStorage/index.ts
var KVStorage = __webpack_require__(2574);
// EXTERNAL MODULE: ./packages/shared-base/src/types/PluginID.ts
var PluginID = __webpack_require__(24835);
// EXTERNAL MODULE: ./packages/base/src/Identifier/ec-key.ts
var ec_key = __webpack_require__(19477);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/defaults.ts
var defaults = __webpack_require__(35138);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/providers/BaseHosted.ts







class BaseHostedProvider extends BaseProvider {
    providerType;
    initial;
    walletStorage;
    constructor(providerType, initial){
        super(providerType);
        this.providerType = providerType;
        this.initial = initial;
    }
    async setup(context) {
        await super.setup(context);
        this.walletStorage = KVStorage/* PersistentStorages */._H.Web3.createSubScope(`${PluginID/* NetworkPluginID */.F.PLUGIN_EVM}_${this.providerType}_hosted`, {
            account: this.options.getDefaultAccount(),
            chainId: this.options.getDefaultChainId(),
            wallets: []
        }).storage;
        await Promise.all([
            this.walletStorage?.account.initializedPromise,
            this.walletStorage?.chainId.initializedPromise,
            this.walletStorage?.wallets.initializedPromise
        ]);
        this.onAccountChanged();
        this.onChainChanged();
        this.walletStorage?.account.subscription.subscribe(this.onAccountChanged.bind(this));
        this.walletStorage?.chainId.subscription.subscribe(this.onChainChanged.bind(this));
    }
    get options() {
        return {
            isSupportedAccount: ()=>true,
            isSupportedChainId: (chainId)=>chainId > 0 && Number.isInteger(chainId),
            getDefaultAccount: ()=>'',
            getDefaultChainId: defaults/* getDefaultChainId */.tA,
            formatAddress: formatter/* formatEthereumAddress */.j8,
            ...this.initial
        };
    }
    get subscription() {
        if (!this.walletStorage) return super.subscription;
        return {
            account: this.walletStorage?.account.subscription,
            chainId: this.walletStorage?.chainId.subscription,
            wallets: this.walletStorage?.wallets.subscription
        };
    }
    get wallets() {
        return this.walletStorage?.wallets.value ?? constants/* EMPTY_LIST */.rP;
    }
    get hostedAccount() {
        return this.walletStorage?.account.value ?? this.options.getDefaultAccount();
    }
    get hostedChainId() {
        return this.walletStorage?.chainId.value ?? this.options.getDefaultChainId();
    }
    async addWallet(wallet) {
        const now = new Date();
        const address = this.options.formatAddress(wallet.address);
        // already added
        if (this.walletStorage?.wallets.value.some((x)=>(0,isSameAddress/* isSameAddress */.W)(x.address, address))) return;
        await this.walletStorage?.wallets.setValue([
            ...this.walletStorage?.wallets.value ?? [],
            {
                ...wallet,
                id: address,
                address,
                name: wallet.name.trim() || `Account ${this.walletStorage?.wallets.value.length + 1}`,
                createdAt: now,
                updatedAt: now
            }
        ]);
    }
    async updateWallet(address, updates) {
        const wallet = this.walletStorage?.wallets.value.find((x)=>(0,isSameAddress/* isSameAddress */.W)(x.address, address));
        if (!wallet) throw new Error('Failed to find wallet.');
        const now = new Date();
        await this.walletStorage?.wallets.setValue(this.walletStorage?.wallets.value.map((x)=>(0,isSameAddress/* isSameAddress */.W)(x.address, address) ? {
                ...x,
                name: updates.name ?? x.name,
                owner: updates.owner ?? x.owner,
                identifier: updates.identifier ?? x.identifier,
                createdAt: x.createdAt ?? now,
                updatedAt: now
            } : x));
        CrossIsolationEvents/* CrossIsolationMessages */.W.events.walletsUpdated.sendToAll(undefined);
    }
    async renameWallet(address, name) {
        const isNameExists = this.walletStorage?.wallets.value.filter((x)=>!(0,isSameAddress/* isSameAddress */.W)(x.address, address)).some((x)=>x.name === name);
        if (isNameExists) throw new Error('The wallet name already exists.');
        if (!this.walletStorage?.wallets.value.find((x)=>(0,isSameAddress/* isSameAddress */.W)(x.address, address))?.owner) await this.io_renameWallet(address, name);
        await this.updateWallet(address, {
            name
        });
    }
    async removeWallet(address, password) {
        await this.walletStorage?.wallets.setValue(this.walletStorage?.wallets.value?.filter((x)=>!(0,isSameAddress/* isSameAddress */.W)(x.address, address)));
    }
    async updateWallets(wallets) {
        if (!wallets.length) return;
        const result = wallets.filter((x)=>!this.walletStorage?.wallets.value.find((y)=>(0,isSameAddress/* isSameAddress */.W)(x.address, y.address) && (0,isSameAddress/* isSameAddress */.W)(x.owner, y.owner)));
        await this.walletStorage?.wallets.setValue((0,uniqWith/* default */.Z)([
            ...this.walletStorage?.wallets.value ?? [],
            ...result
        ], (a, b)=>(0,isSameAddress/* isSameAddress */.W)(a.address, b.address)));
    }
    async removeWallets(wallets) {
        if (!wallets.length) return;
        await this.walletStorage?.wallets.setValue(this.walletStorage?.wallets.value?.filter((x)=>!wallets.find((y)=>(0,isSameAddress/* isSameAddress */.W)(x.address, y.address))));
    }
    async onAccountChanged() {
        await this.walletStorage?.account.initializedPromise;
        if (!this.hostedAccount) return;
        this.emitter.emit('accounts', [
            this.hostedAccount
        ]);
        await (0,esm/* delay */.gw)(100);
        this.emitter.emit('chainId', (0,lib.toHex)(this.hostedChainId));
    }
    async onChainChanged() {
        await this.walletStorage?.chainId.initializedPromise;
        if (this.hostedChainId) this.emitter.emit('chainId', (0,lib.toHex)(this.hostedChainId));
    }
    async switchAccount(account) {
        if (!(0,helpers_address/* isValidAddress */.At)(account)) throw new Error(`Invalid address: ${account}`);
        const supported = await this.options.isSupportedAccount(account);
        if (!supported) throw new Error(`Not supported account: ${account}`);
        await this.walletStorage?.account.setValue(account);
    }
    async switchChain(chainId) {
        const supported = await this.options.isSupportedChainId(chainId);
        if (!supported) throw new Error(`Not supported chain id: ${chainId}`);
        await this.walletStorage?.chainId.setValue(chainId);
    }
}

// EXTERNAL MODULE: ./packages/web3-providers/src/SmartPay/apis/BundlerAPI.ts
var BundlerAPI = __webpack_require__(25514);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/providers/BaseContractWallet.ts






/**
 * EIP-4337 compatible smart contract based wallet.
 */ class BaseContractWalletProvider extends BaseHostedProvider {
    providerType;
    Bundler;
    ownerStorage;
    constructor(providerType){
        super(providerType);
        this.providerType = providerType;
        this.Bundler = BundlerAPI/* SmartPayBundler */.P;
    }
    async setup(context) {
        await super.setup(context);
        this.ownerStorage = KVStorage/* InMemoryStorages */.uU.Web3.createSubScope(`${PluginID/* NetworkPluginID */.F.PLUGIN_EVM}_${this.providerType}_owner`, {
            value: {
                account: this.options.getDefaultAccount(),
                // empty string means EOA signer
                identifier: ''
            }
        })?.storage.value;
        await this.ownerStorage?.initializedPromise;
        this.subscription.wallets?.subscribe(async ()=>{
            if (!this.hostedAccount) return;
            const target = this.wallets?.find((x)=>(0,isSameAddress/* isSameAddress */.W)(x.address, this.hostedAccount));
            const smartPayChainId = await this.Bundler.getSupportedChainId();
            if (target?.owner) {
                await this.ownerStorage?.setValue({
                    account: target.owner,
                    identifier: target.identifier ?? ''
                });
                if (this.hostedChainId !== smartPayChainId) {
                    await this.switchChain(smartPayChainId);
                }
            }
        });
    }
    get ownerAccount() {
        return this.ownerStorage?.value.account ?? this.options.getDefaultAccount();
    }
    get ownerIdentifier() {
        const identifier = ec_key/* ECKeyIdentifier */.o.from(this.ownerStorage?.value.identifier).unwrapOr(undefined);
        return identifier?.rawPublicKey === 'EMPTY' ? undefined : identifier;
    }
    async switchAccount(account, owner) {
        await super.switchAccount(account);
        if (!owner || !(0,helpers_address/* isValidAddress */.At)(owner.account)) {
            await this.ownerStorage?.setValue({
                account: this.options.getDefaultAccount(),
                identifier: owner?.identifier?.toText() ?? ''
            });
        } else {
            // delay for syncing storage
            await (0,esm/* delay */.gw)(300);
            // ensure account switching is successful
            if (!(0,isSameAddress/* isSameAddress */.W)(this.hostedAccount, account)) return;
            await this.ownerStorage?.setValue({
                account: owner.account,
                identifier: owner.identifier?.toText() ?? ''
            });
        }
    }
}

// EXTERNAL MODULE: ./packages/web3-providers/src/SmartPay/apis/OwnerAPI.ts + 1 modules
var OwnerAPI = __webpack_require__(16769);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/providers/MaskWallet.ts









class MaskWalletProvider extends BaseContractWalletProvider {
    Request = new RequestReadonlyAPI/* RequestReadonlyAPI */.c();
    ref = new ValueRef/* ValueRef */.Xf(constants/* EMPTY_LIST */.rP);
    async io_renameWallet(address, name) {
        await this.context?.MaskWalletContext?.renameWallet(address, name);
    }
    constructor(){
        super(types/* ProviderType */.lP.MaskWallet);
    }
    async updateImmediately() {
        const wallets = this.context?.wallets.getCurrentValue() ?? constants/* EMPTY_LIST */.rP;
        // update local wallets immediately
        this.ref.value = (0,sortBy/* default */.Z)((0,uniqWith/* default */.Z)([
            ...super.wallets,
            ...wallets
        ], (a, b)=>(0,isSameAddress/* isSameAddress */.W)(a.address, b.address)), (x)=>!!x.owner);
    }
    async update() {
        // Fetching info of SmartPay wallets is slow, update provider wallets eagerly here.
        await this.updateImmediately();
        const allPersonas = this.context?.MaskWalletContext?.allPersonas.getCurrentValue() ?? constants/* EMPTY_LIST */.rP;
        const wallets = this.context?.wallets.getCurrentValue() ?? constants/* EMPTY_LIST */.rP;
        const chainId = await this.Bundler.getSupportedChainId();
        const accounts = await new OwnerAPI/* SmartPayOwnerAPI */.P().getAccountsByOwners(chainId, [
            ...wallets.map((x)=>x.address),
            ...(0,compact/* default */.Z)(allPersonas.map((x)=>x.address))
        ]);
        const now = new Date();
        const smartPayWallets = accounts.filter((x)=>x.deployed).map((x)=>({
                id: x.address,
                name: super.wallets.find((item)=>(0,isSameAddress/* isSameAddress */.W)(item.address, x.address))?.name ?? 'Smart Pay',
                source: Wallet/* ImportSource */.Q.WalletRPC,
                address: x.address,
                hasDerivationPath: false,
                hasStoredKeyInfo: false,
                configurable: true,
                createdAt: now,
                updatedAt: now,
                owner: x.owner,
                deployed: x.deployed,
                identifier: allPersonas.find((persona)=>(0,isSameAddress/* isSameAddress */.W)(x.owner, persona.address))?.identifier.toText()
            }));
        const result = (0,uniqWith/* default */.Z)([
            ...smartPayWallets,
            ...super.wallets,
            ...wallets
        ], (a, b)=>(0,isSameAddress/* isSameAddress */.W)(a.address, b.address));
        if (!(0,isEqual/* default */.Z)(result, super.wallets)) {
            await this.updateWallets(result);
        }
        this.ref.value = (0,sortBy/* default */.Z)(result, (x)=>!!x.owner);
    }
    get subscription() {
        return {
            ...super.subscription,
            wallets: (0,subscription/* createSubscriptionFromValueRef */.v_)(this.ref)
        };
    }
    get wallets() {
        return this.subscription.wallets.getCurrentValue();
    }
    async setup(context) {
        await super.setup(context);
        this.subscription?.wallets?.subscribe(async ()=>{
            const primaryWallet = (0,head/* default */.Z)(this.wallets);
            const smartPayChainId = await this.Bundler.getSupportedChainId();
            if (!this.hostedAccount && primaryWallet) {
                await this.switchAccount(primaryWallet.address);
                await this.switchChain(primaryWallet.owner ? smartPayChainId : types/* ChainId */.a_.Mainnet);
                if (primaryWallet.owner) {
                    const networks = Web3StateAPI.Web3StateRef.value.Network?.networks?.getCurrentValue();
                    const target = networks?.find((x)=>x.chainId === smartPayChainId);
                    if (target) Web3StateAPI.Web3StateRef.value.Network?.switchNetwork(target.ID);
                }
            }
        });
        await this.updateImmediately();
        const debounceUpdate = (0,debounce/* default */.Z)(this.update.bind(this), 1000);
        this.context?.wallets.subscribe(debounceUpdate);
        this.context?.MaskWalletContext?.allPersonas.subscribe(debounceUpdate);
        CrossIsolationEvents/* CrossIsolationMessages */.W.events.renameWallet.on(debounceUpdate);
    }
    async addWallet(wallet) {
        if (!this.hostedAccount && !this.wallets.length) await this.walletStorage?.account.setValue(wallet.address);
        await this.context?.addWallet(Wallet/* ImportSource */.Q.WalletRPC, wallet.address, wallet);
    }
    async removeWallet(address, password) {
        const scWallets = this.wallets.filter((x)=>(0,isSameAddress/* isSameAddress */.W)(x.owner, address));
        if (scWallets.length) await super.removeWallets(scWallets);
        if ((0,isSameAddress/* isSameAddress */.W)(this.hostedAccount, address)) await this.walletStorage?.account.setValue('');
        await super.removeWallet(address, password);
        await this.context?.MaskWalletContext?.removeWallet(address, password);
    }
    async removeWallets(wallets) {
        await super.removeWallets(wallets);
        for (const wallet of wallets){
            if ((0,isSameAddress/* isSameAddress */.W)(this.hostedAccount, wallet.address)) await this.walletStorage?.account.setValue('');
            if (!wallet.owner) await this.context?.MaskWalletContext?.removeWallet(wallet.address);
        }
    }
    async resetAllWallets() {
        await super.removeWallets(this.wallets);
        await this.walletStorage?.account.setValue('');
        await this.context?.MaskWalletContext?.resetAllWallets();
    }
    async renameWallet(address, name) {
        await super.renameWallet(address, name);
        CrossIsolationEvents/* CrossIsolationMessages */.W.events.renameWallet.sendToAll({});
    }
    async connect(chainId, address, owner, silent, externalRequestID) {
        if ((0,Site/* getExtensionSiteType */.wO)() === Site_types/* ExtensionSite */.v.Popup || silent) {
            if ((0,helpers_address/* isValidAddress */.At)(address)) {
                await this.switchAccount(address, owner);
                await this.switchChain(chainId);
                if (externalRequestID) {
                    await this.context?.grantEIP2255Permission(externalRequestID, [
                        address
                    ]);
                }
                return {
                    account: address,
                    chainId
                };
            }
            return {
                account: this.hostedAccount,
                chainId: this.hostedChainId
            };
        }
        if (externalRequestID) throw new TypeError('externalRequestID is not expected in MaskWalletProvider.connect() when the page is not popup page.');
        const account = (0,head/* default */.Z)(await this.context?.selectMaskWalletAccount(chainId, address, location.origin));
        if (!account) throw new Error(`Failed to connect to ${ResolverAPI/* ChainResolver */.iv.chainFullName(chainId)}`);
        // switch account
        if (!(0,isSameAddress/* isSameAddress */.W)(this.hostedAccount, account?.address)) {
            await this.switchAccount(account.address, account.owner ? {
                account: account.owner,
                identifier: account.identifier
            } : undefined);
        }
        // switch chain
        if (chainId !== this.hostedChainId) await this.switchChain(chainId);
        return {
            chainId,
            account: account.address
        };
    }
    async disconnect() {
        await this.context?.disconnectAllWalletsFromOrigin(location.origin);
    }
    async request(requestArguments, initial) {
        return this.Request.request(PayloadEditor/* PayloadEditor */._.fromMethod(requestArguments.method, requestArguments.params).fill(), initial);
    }
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/providers/CustomNetwork.ts


class CustomNetworkProvider extends BaseProvider {
    constructor(){
        super(types/* ProviderType */.lP.CustomNetwork);
    }
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/EVM/providers/index.ts














const Providers = {
    [types/* ProviderType */.lP.None]: new NoneProvider(),
    [types/* ProviderType */.lP.MaskWallet]: new MaskWalletProvider(),
    [types/* ProviderType */.lP.Browser]: new BrowserProvider(),
    [types/* ProviderType */.lP.MetaMask]: new MetaMaskProvider(),
    [types/* ProviderType */.lP.WalletConnect]: src/* Flags */.v.wc_enabled ? new WalletConnectProvider() : new NoneProvider(),
    [types/* ProviderType */.lP.Coin98]: new EVM_Coin98Provider(),
    [types/* ProviderType */.lP.Coinbase]: new CoinbaseProvider(),
    [types/* ProviderType */.lP.OKX]: new OKXProvider(),
    [types/* ProviderType */.lP.Clover]: new CloverProvider(),
    [types/* ProviderType */.lP.Fortmatic]: new FortmaticProvider(),
    [types/* ProviderType */.lP.Opera]: new OperaProvider(),
    [types/* ProviderType */.lP.CustomNetwork]: new CustomNetworkProvider()
};


/***/ }),

/***/ 8424:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Y: () => (/* binding */ FlowConnectionAPI)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/head.js
var head = __webpack_require__(81755);
// EXTERNAL MODULE: ./node_modules/.pnpm/date-fns@2.30.0/node_modules/date-fns/esm/getUnixTime/index.js + 1 modules
var getUnixTime = __webpack_require__(11796);
// EXTERNAL MODULE: ./node_modules/.pnpm/@masknet+kit@0.1.2/node_modules/@masknet/kit/esm/index.js + 1 modules
var esm = __webpack_require__(30898);
// EXTERNAL MODULE: ./packages/web3-shared/flow/src/helpers/address.ts + 1 modules
var helpers_address = __webpack_require__(44050);
// EXTERNAL MODULE: ./packages/web3-shared/flow/src/types.ts
var types = __webpack_require__(59190);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/specs/index.ts
var specs = __webpack_require__(62649);
// EXTERNAL MODULE: ./packages/shared-base/src/helpers/pvtutils.ts
var pvtutils = __webpack_require__(26424);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Flow/apis/ConnectionOptionsAPI.ts
var ConnectionOptionsAPI = __webpack_require__(64683);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Flow/apis/ResolverAPI.ts
var ResolverAPI = __webpack_require__(36347);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/memoize.js
var memoize = __webpack_require__(43434);
// EXTERNAL MODULE: ./packages/web3-shared/flow/src/sdk/index.ts
var sdk = __webpack_require__(35401);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Flow/providers/index.ts + 4 modules
var providers = __webpack_require__(781);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Flow/apis/Web3API.ts




const createWeb3SDK = (0,memoize/* default */.Z)((chainId)=>(0,sdk/* createClient */.e)(chainId), (chainId)=>chainId);
class FlowWeb3API {
    options;
    constructor(options){
        this.options = options;
        this.ConnectionOptions = new ConnectionOptionsAPI/* FlowConnectionOptionsAPI */.H(this.options);
    }
    ConnectionOptions;
    getWeb3(initial) {
        const options = this.ConnectionOptions.fill(initial);
        return createWeb3SDK(options.chainId);
    }
    getWeb3Provider(initial) {
        throw new Error('Method not implemented.');
    }
    getProviderInstance(initial) {
        const options = this.ConnectionOptions.fill(initial);
        return providers/* FlowProviders */.W[options.providerType];
    }
}

// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Flow/apis/Web3StateAPI.ts
var Web3StateAPI = __webpack_require__(88245);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Flow/apis/ConnectionAPI.ts










class FlowConnectionAPI {
    constructor(options){
        this.ConnectionOptions = new ConnectionOptionsAPI/* FlowConnectionOptionsAPI */.H(options);
        this.Web3 = new FlowWeb3API(options);
    }
    Web3;
    ConnectionOptions;
    getWeb3(initial) {
        return this.Web3.getWeb3(initial);
    }
    getWeb3Provider(initial) {
        return this.Web3.getWeb3Provider(initial);
    }
    async getBalance(address, initial) {
        const web3 = this.getWeb3(initial);
        const account = await web3.send([
            web3.getAccount(address)
        ]).then(web3.decode);
        return account.balance.toFixed();
    }
    getNativeTokenBalance(initial) {
        throw new Error('Method not implemented.');
    }
    getFungibleTokenBalance(address, schema, initial) {
        if (!address || (0,helpers_address/* isNativeTokenAddress */.qw)(address)) return this.getNativeTokenBalance(initial);
        // TODO
        return Promise.resolve('0');
    }
    getNonFungibleTokenBalance(address, tokenId, schema, initial) {
        throw new Error('Method not implemented.');
    }
    getFungibleTokensBalance(listOfAddress, initial) {
        throw new Error('Method not implemented.');
    }
    getNonFungibleTokensBalance(listOfAddress, initial) {
        throw new Error('Method not implemented.');
    }
    getGasPrice(initial) {
        throw new Error('Method not implemented.');
    }
    getCode(address, initial) {
        throw new Error('Method not implemented.');
    }
    getAddressType() {
        return Promise.resolve(types/* AddressType */.DL.Default);
    }
    getSchemaType(address, initial) {
        throw new Error('Method not implemented.');
    }
    async getAccount(initial) {
        const web3 = this.getWeb3(initial);
        return web3.currentUser().addr ?? '';
    }
    async getChainId(initial) {
        const options = this.ConnectionOptions.fill(initial);
        return options.chainId;
    }
    getBlock(no, initial) {
        const web3 = this.getWeb3(initial);
        return web3.send([
            web3.getBlock(),
            web3.atBlockHeight(no)
        ]).then(web3.decode);
    }
    async getBlockNumber(initial) {
        const web3 = this.getWeb3(initial);
        const blockHeader = await web3.send([
            web3.getBlockHeader()
        ]).then(web3.decode);
        return blockHeader.height;
    }
    async getBlockTimestamp(initial) {
        const web3 = this.getWeb3(initial);
        const blockHeader = await web3.send([
            web3.getBlockHeader()
        ]).then(web3.decode);
        return (0,getUnixTime/* default */.Z)(new Date(blockHeader.timestamp));
    }
    async getTransaction(id, initial) {
        const web3 = this.getWeb3(initial);
        return web3.getTransaction(id);
    }
    async getTransactionReceipt(id, initial) {
        return null;
    }
    async getTransactionStatus(id, initial) {
        const web3 = this.getWeb3(initial);
        const { status } = web3.getTransactionStatus(id);
        const status_ = status;
        switch(status_){
            case types/* TransactionStatusCode */.GB.UNKNOWN:
                return specs.TransactionStatusType.NOT_DEPEND;
            case types/* TransactionStatusCode */.GB.PENDING:
            case types/* TransactionStatusCode */.GB.FINALIZED:
            case types/* TransactionStatusCode */.GB.EXECUTED:
                return specs.TransactionStatusType.NOT_DEPEND;
            case types/* TransactionStatusCode */.GB.SEALED:
                return specs.TransactionStatusType.NOT_DEPEND;
            case types/* TransactionStatusCode */.GB.EXPIRED:
                return specs.TransactionStatusType.FAILED;
            default:
                (0,esm/* unreachable */.t1)(status_);
        }
    }
    async getTransactionNonce(address, initial) {
        const web3 = this.getWeb3(initial);
        const account = web3.getAccount(address);
        const key = (0,head/* default */.Z)(account.keys);
        return key?.sequenceNumber ?? 0;
    }
    getNativeToken(initial) {
        const options = this.ConnectionOptions.fill(initial);
        const token = ResolverAPI/* FlowChainResolver */.ql.nativeCurrency(options.chainId);
        return Promise.resolve(token);
    }
    getFungibleToken(address, initial) {
        if (!address || (0,helpers_address/* isNativeTokenAddress */.qw)(address)) return this.getNativeToken(initial);
        throw new Error('Method not implemented.');
    }
    getNonFungibleToken(address, tokenId, schema, initial) {
        throw new Error('Method not implemented.');
    }
    getNonFungibleTokenOwner(address, tokenId, schema, initial) {
        throw new Error('Method not implemented.');
    }
    getNonFungibleTokenOwnership(address, tokenId, owner, schema, initial) {
        throw new Error('Method not implemented.');
    }
    getNonFungibleTokenMetadata(address, tokenId, schema, initial) {
        throw new Error('Method not implemented.');
    }
    getNonFungibleTokenContract(address, schema, initial) {
        throw new Error('Method not implemented.');
    }
    getNonFungibleTokenCollection(address, schema, initial) {
        throw new Error('Method not implemented.');
    }
    approveFungibleToken(address, recipient, amount, initial) {
        throw new Error('Method not implemented.');
    }
    approveNonFungibleToken(address, recipient, tokenId, schema, initial) {
        throw new Error('Method not implemented.');
    }
    approveAllNonFungibleTokens(address, recipient, approved, schema, initial) {
        throw new Error('Method not implemented.');
    }
    transferFungibleToken(address, recipient, amount, memo, initial) {
        throw new Error('Method not implemented.');
    }
    transferNonFungibleToken(address, tokenId, recipient, amount, schema, initial) {
        throw new Error('Method not implemented.');
    }
    async connect(initial) {
        const options = this.ConnectionOptions.fill(initial);
        return {
            account: '',
            chainId: types/* ChainId */.a_.Mainnet,
            ...await Web3StateAPI.FlowWeb3StateRef.value.Provider?.connect(options.providerType, options.chainId)
        };
    }
    async disconnect(initial) {
        const options = this.ConnectionOptions.fill(initial);
        await Web3StateAPI.FlowWeb3StateRef.value.Provider?.disconnect(options.providerType);
    }
    async signMessage(type, message, initial) {
        const web3 = this.getWeb3(initial);
        const data = new TextEncoder().encode(message);
        const signed = (0,head/* default */.Z)(await web3.currentUser.signUserMessage((0,pvtutils/* toHex */.NC)(data)));
        if (!signed) throw new Error('Failed to sign message.');
        return signed.signature;
    }
    async verifyMessage(type, message, signature, initial) {
        const options = this.ConnectionOptions.fill(initial);
        const web3 = this.getWeb3(options);
        if (!options.account) throw new Error('No account found.');
        return web3.verifyUserSignatures(message, [
            {
                addr: options.account,
                keyId: 1,
                signature
            }
        ]);
    }
    createAccount(initial) {
        throw new Error('Method not implemented.');
    }
    async switchChain(chainId, initial) {
        await this.Web3.getProviderInstance(initial).switchChain(chainId);
    }
    async callTransaction(query, initial) {
        const web3 = this.getWeb3(initial);
        return web3.query(query);
    }
    async sendTransaction(mutation, initial) {
        const options = this.ConnectionOptions.fill(initial);
        const web3 = this.getWeb3(options);
        const id = await this.getWeb3(options).mutate(mutation);
        await web3.tx(id).onceSealed();
        return id;
    }
    confirmTransaction(hash, initial) {
        throw new Error('Method not implemented.');
    }
    estimateTransaction(transaction, fallback, initial) {
        throw new Error('Method not implemented.');
    }
    signTransaction(mutation, initial) {
        throw new Error('Method not implemented.');
    }
    signTransactions(mutations, initial) {
        throw new Error('Method not implemented.');
    }
    sendSignedTransaction(signature, initial) {
        throw new Error('Method not implemented.');
    }
    replaceTransaction(hash, config, initial) {
        throw new Error('Method not implemented.');
    }
    cancelTransaction(hash, config, initial) {
        throw new Error('Method not implemented.');
    }
}


/***/ }),

/***/ 64683:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   H: () => (/* binding */ FlowConnectionOptionsAPI)
/* harmony export */ });
/* harmony import */ var _Base_apis_ConnectionOptionsAPI_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21871);
/* harmony import */ var _Web3StateAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(88245);
/* harmony import */ var _OthersAPI_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(84351);



class FlowConnectionOptionsAPI extends _Base_apis_ConnectionOptionsAPI_js__WEBPACK_IMPORTED_MODULE_0__/* .ConnectionOptionsAPI_Base */ .G {
    get Web3StateRef() {
        return _Web3StateAPI_js__WEBPACK_IMPORTED_MODULE_1__.FlowWeb3StateRef;
    }
    get Web3Others() {
        return new _OthersAPI_js__WEBPACK_IMPORTED_MODULE_2__/* .FlowOthersAPI */ .B();
    }
}


/***/ }),

/***/ 84351:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   B: () => (/* binding */ FlowOthersAPI)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(77199);
/* harmony import */ var _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(68169);
/* harmony import */ var _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(44050);
/* harmony import */ var _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5799);
/* harmony import */ var _Base_apis_OthersAPI_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(57429);
/* harmony import */ var _ResolverAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(36347);




class FlowOthersAPI extends _Base_apis_OthersAPI_js__WEBPACK_IMPORTED_MODULE_0__/* .OthersAPI_Base */ .a {
    chainResolver = _ResolverAPI_js__WEBPACK_IMPORTED_MODULE_1__/* .FlowChainResolver */ .ql;
    explorerResolver = _ResolverAPI_js__WEBPACK_IMPORTED_MODULE_1__/* .FlowExplorerResolver */ .Od;
    providerResolver = _ResolverAPI_js__WEBPACK_IMPORTED_MODULE_1__/* .FlowProviderResolver */ .pQ;
    networkResolver = _ResolverAPI_js__WEBPACK_IMPORTED_MODULE_1__/* .FlowNetworkResolver */ .FV;
    isValidDomain = _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_2__/* .isValidDomain */ .hS;
    isValidChainId = _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_3__/* .isValidChainId */ .JW;
    isValidAddress = _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_3__/* .isValidAddress */ .At;
    isZeroAddress = _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_3__/* .isZeroAddress */ .uO;
    isNativeTokenAddress = _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_3__/* .isNativeTokenAddress */ .qw;
    isNativeTokenSchemaType = _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_4__/* .isNativeTokenSchemaType */ .SC;
    isFungibleTokenSchemaType = _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_4__/* .isFungibleTokenSchemaType */ .kL;
    isNonFungibleTokenSchemaType = _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_4__/* .isNonFungibleTokenSchemaType */ .V2;
    getNetworkPluginID = _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_3__/* .getNetworkPluginID */ .yg;
    getDefaultChainId = _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_3__/* .getDefaultChainId */ .tA;
    getInvalidChainId = _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_3__/* .getInvalidChainId */ .p6;
    getDefaultNetworkType = _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_3__/* .getDefaultNetworkType */ .H2;
    getDefaultProviderType = _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_3__/* .getDefaultProviderType */ .Xo;
    getZeroAddress = _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_3__/* .getZeroAddress */ .R6;
    getNativeTokenAddress = _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_3__/* .getNativeTokenAddress */ .rG;
    getMaskTokenAddress = _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_3__/* .getMaskTokenAddress */ .vY;
    formatAddress = _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_3__/* .formatAddress */ .Tg;
    formatDomainName = _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_2__/* .formatDomainName */ .bc;
    formatTokenId = _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_3__/* .formatTokenId */ .Xy;
    formatSchemaType = _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_2__/* .formatSchemaType */ .sB;
    createNativeToken = (chainId)=>this.chainResolver.nativeCurrency(chainId);
    createFungibleToken = _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_5__/* .createFungibleToken */ .mn;
    createNonFungibleToken = _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_5__/* .createNonFungibleToken */ .RV;
}


/***/ }),

/***/ 36347:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FV: () => (/* binding */ FlowNetworkResolver),
/* harmony export */   Od: () => (/* binding */ FlowExplorerResolver),
/* harmony export */   pQ: () => (/* binding */ FlowProviderResolver),
/* harmony export */   ql: () => (/* binding */ FlowChainResolver)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(81545);
/* harmony import */ var _Base_apis_ChainResolverAPI_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26197);
/* harmony import */ var _Base_apis_ExplorerResolverAPI_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12030);
/* harmony import */ var _Base_apis_ProviderResolverAPI_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(31710);
/* harmony import */ var _Base_apis_NetworkExplorerAPI_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(92845);





class FlowChainResolverAPI extends _Base_apis_ChainResolverAPI_js__WEBPACK_IMPORTED_MODULE_0__/* .ChainResolverAPI_Base */ .p {
    descriptors = _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_1__/* .CHAIN_DESCRIPTORS */ .Q_;
}
class FlowExplorerResolverAPI extends _Base_apis_ExplorerResolverAPI_js__WEBPACK_IMPORTED_MODULE_2__/* .ExplorerResolverAPI_Base */ .I {
    descriptors = _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_1__/* .CHAIN_DESCRIPTORS */ .Q_;
    initial = {
        addressPathname: '/account/:address',
        transactionPathname: '/transaction/:id',
        fungibleTokenPathname: '/contract/:address',
        nonFungibleTokenPathname: '/contract/:address'
    };
}
class FlowProviderResolverAPI extends _Base_apis_ProviderResolverAPI_js__WEBPACK_IMPORTED_MODULE_3__/* .ProviderResolverAPI_Base */ .P {
    descriptors = _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_1__/* .PROVIDER_DESCRIPTORS */ .zM;
}
class FlowNetworkResolverAPI extends _Base_apis_NetworkExplorerAPI_js__WEBPACK_IMPORTED_MODULE_4__/* .NetworkResolverAPI_Base */ .n {
    descriptors = _masknet_web3_shared_flow__WEBPACK_IMPORTED_MODULE_1__/* .NETWORK_DESCRIPTORS */ .qQ;
}
const FlowChainResolver = new FlowChainResolverAPI();
const FlowExplorerResolver = new FlowExplorerResolverAPI();
const FlowProviderResolver = new FlowProviderResolverAPI();
const FlowNetworkResolver = new FlowNetworkResolverAPI();


/***/ }),

/***/ 781:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  W: () => (/* binding */ FlowProviders)
});

// EXTERNAL MODULE: ./packages/web3-shared/flow/src/types.ts
var types = __webpack_require__(59190);
// EXTERNAL MODULE: ./node_modules/.pnpm/@servie+events@3.0.0/node_modules/@servie/events/dist/index.js
var dist = __webpack_require__(93441);
// EXTERNAL MODULE: ./packages/shared-base/src/helpers/subscription.ts
var subscription = __webpack_require__(28129);
// EXTERNAL MODULE: ./packages/shared-base/src/constants.ts
var constants = __webpack_require__(52033);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Flow/providers/Base.ts



class BaseProvider {
    emitter = new dist/* Emitter */.Q5();
    get subscription() {
        return {
            account: (0,subscription/* createConstantSubscription */.qY)(''),
            chainId: (0,subscription/* createConstantSubscription */.qY)(types/* ChainId */.a_.Mainnet),
            wallets: (0,subscription/* createConstantSubscription */.qY)(constants/* EMPTY_LIST */.rP)
        };
    }
    get connected() {
        return false;
    }
    // No need to wait by default
    get ready() {
        return true;
    }
    // No need to wait by default
    get readyPromise() {
        return Promise.resolve();
    }
    setup() {
        throw new Error('Method not implemented.');
    }
    addWallet(wallet) {
        throw new Error('Method not implemented.');
    }
    updateWallet(address, wallet) {
        throw new Error('Method not implemented.');
    }
    renameWallet(address, name) {
        throw new Error('Method not implemented.');
    }
    removeWallet(address, password) {
        throw new Error('Method not implemented.');
    }
    updateWallets(wallets) {
        throw new Error('Method not implemented.');
    }
    removeWallets(wallets) {
        throw new Error('Method not implemented.');
    }
    resetAllWallets() {
        throw new Error('Method not implemented.');
    }
    switchAccount(account) {
        throw new Error('Method not implemented.');
    }
    switchChain(chainId) {
        throw new Error('Method not implemented.');
    }
    createWeb3(options) {
        throw new Error('Method not implemented.');
    }
    createWeb3Provider(options) {
        throw new Error('Method not implemented.');
    }
    connect(chainId) {
        throw new Error('Method not implemented.');
    }
    disconnect() {
        throw new Error('Method not implemented.');
    }
}

// EXTERNAL MODULE: ./packages/web3-shared/flow/src/sdk/index.ts
var sdk = __webpack_require__(35401);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Flow/providers/Blocto.ts


class BloctoProvider extends BaseProvider {
    createWeb3(options) {
        return (0,sdk/* createClient */.e)(options?.chainId ?? types/* ChainId */.a_.Mainnet);
    }
    async connect(chainId = types/* ChainId */.a_.Mainnet) {
        const fcl = this.createWeb3({
            chainId
        });
        const user = await fcl.logIn();
        return {
            chainId,
            account: user.addr
        };
    }
    async disconnect() {}
} // do nothing

;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Flow/providers/Dapper.ts

class DapperProvider extends BaseProvider {
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Flow/providers/Ledger.ts

class LedgerProvider extends BaseProvider {
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Flow/providers/index.ts





const FlowProviders = {
    [types/* ProviderType */.lP.None]: new BaseProvider(),
    [types/* ProviderType */.lP.Blocto]: new BloctoProvider(),
    [types/* ProviderType */.lP.Dapper]: new DapperProvider(),
    [types/* ProviderType */.lP.Ledger]: new LedgerProvider()
};


/***/ }),

/***/ 17103:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  B: () => (/* binding */ AllConnectionAPI)
});

// EXTERNAL MODULE: ./packages/shared-base/src/types/PluginID.ts
var PluginID = __webpack_require__(24835);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/OthersAPI.ts + 1 modules
var OthersAPI = __webpack_require__(63877);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/ConnectionAPI.ts
var ConnectionAPI = __webpack_require__(16488);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/memoize.js
var memoize = __webpack_require__(43434);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Base/apis/ConnectionCreatorAPI.ts

const resolver = (initial)=>{
    return [
        initial?.chainId,
        initial?.account,
        initial?.providerType
    ].join(',');
};
class ConnectionCreatorAPI_Base {
    creator;
    Others;
    ConnectionOptions;
    constructor(creator, Others, ConnectionOptions){
        this.creator = creator;
        this.Others = Others;
        this.ConnectionOptions = ConnectionOptions;
        this.createCached = (0,memoize/* default */.Z)(creator, resolver);
    }
    createCached;
    create(initial) {
        const options = this.ConnectionOptions.fill(initial);
        if (!this.Others.isValidChainId(options.chainId)) return;
        return this.createCached(initial);
    }
}

// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/ConnectionOptionsAPI.ts
var ConnectionOptionsAPI = __webpack_require__(2685);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Flow/apis/OthersAPI.ts
var apis_OthersAPI = __webpack_require__(84351);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Flow/apis/ConnectionAPI.ts + 1 modules
var apis_ConnectionAPI = __webpack_require__(8424);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Flow/apis/ConnectionOptionsAPI.ts
var apis_ConnectionOptionsAPI = __webpack_require__(64683);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Solana/apis/OthersAPI.ts + 1 modules
var Solana_apis_OthersAPI = __webpack_require__(8363);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Solana/apis/ConnectionAPI.ts + 7 modules
var Solana_apis_ConnectionAPI = __webpack_require__(46148);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Solana/apis/ConnectionOptionsAPI.ts
var Solana_apis_ConnectionOptionsAPI = __webpack_require__(12550);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Router/apis/AllConnectionAPI.ts











const createCreator = (networkPluginID)=>{
    switch(networkPluginID){
        case PluginID/* NetworkPluginID */.F.PLUGIN_EVM:
            return new ConnectionCreatorAPI_Base((initial)=>new ConnectionAPI/* ConnectionAPI */.m(initial), new OthersAPI/* OthersAPI */.i(), new ConnectionOptionsAPI/* ConnectionOptionsAPI */.T());
        case PluginID/* NetworkPluginID */.F.PLUGIN_FLOW:
            return new ConnectionCreatorAPI_Base((initial)=>new apis_ConnectionAPI/* FlowConnectionAPI */.Y(initial), new apis_OthersAPI/* FlowOthersAPI */.B(), new apis_ConnectionOptionsAPI/* FlowConnectionOptionsAPI */.H());
        case PluginID/* NetworkPluginID */.F.PLUGIN_SOLANA:
            return new ConnectionCreatorAPI_Base((initial)=>new Solana_apis_ConnectionAPI/* SolanaConnectionAPI */.k(initial), new Solana_apis_OthersAPI/* SolanaOthersAPI */.r(), new Solana_apis_ConnectionOptionsAPI/* SolanaConnectionOptionsAPI */.n());
        default:
            throw new Error('Not supported.');
    }
};
class AllConnectionAPI {
    creators = {
        [PluginID/* NetworkPluginID */.F.PLUGIN_EVM]: createCreator(PluginID/* NetworkPluginID */.F.PLUGIN_EVM),
        [PluginID/* NetworkPluginID */.F.PLUGIN_FLOW]: createCreator(PluginID/* NetworkPluginID */.F.PLUGIN_FLOW),
        [PluginID/* NetworkPluginID */.F.PLUGIN_SOLANA]: createCreator(PluginID/* NetworkPluginID */.F.PLUGIN_SOLANA)
    };
    use(pluginID, initial) {
        return this.creators[pluginID].create(initial);
    }
}


/***/ }),

/***/ 53543:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  a: () => (/* binding */ AllHubAPI)
});

// EXTERNAL MODULE: ./packages/shared-base/src/types/PluginID.ts
var PluginID = __webpack_require__(24835);
// EXTERNAL MODULE: ./packages/shared-base/src/helpers/mixin.ts
var mixin = __webpack_require__(92560);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/memoize.js
var memoize = __webpack_require__(43434);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Base/apis/HubCreatorAPI.ts

const resolver = (initial)=>{
    return [
        initial?.chainId,
        initial?.account,
        initial?.currencyType,
        initial?.sourceType
    ].join(',');
};
class HubCreatorAPI_Base {
    creator;
    Web3Others;
    Web3HubOptions;
    constructor(creator, Web3Others, Web3HubOptions){
        this.creator = creator;
        this.Web3Others = Web3Others;
        this.Web3HubOptions = Web3HubOptions;
        this.createCached = (0,memoize/* default */.Z)(creator, resolver);
    }
    createCached;
    create(initial) {
        return this.createCached(initial);
    }
}

// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Base/apis/HubOptionsAPI.ts
var HubOptionsAPI = __webpack_require__(14058);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Flow/apis/Web3StateAPI.ts
var Web3StateAPI = __webpack_require__(88245);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Flow/apis/OthersAPI.ts
var OthersAPI = __webpack_require__(84351);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Flow/apis/HubOptionsAPI.ts



class FlowHubOptionsAPI extends HubOptionsAPI/* HubOptionsAPI_Base */.v {
    get Web3StateRef() {
        return Web3StateAPI.FlowWeb3StateRef;
    }
    get Web3Others() {
        return new OthersAPI/* FlowOthersAPI */.B();
    }
}

// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Base/apis/HubBaseAPI.ts
var HubBaseAPI = __webpack_require__(75583);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Flow/apis/HubBaseAPI.ts


class FlowHubBaseAPI extends HubBaseAPI/* HubBaseAPI_Base */.j {
    getGasOptions = undefined;
    getTransactions = undefined;
    HubOptions = new FlowHubOptionsAPI(this.options);
}

// EXTERNAL MODULE: ./packages/web3-shared/base/src/specs/index.ts
var specs = __webpack_require__(62649);
// EXTERNAL MODULE: ./packages/shared-base/src/Pageable/index.ts
var Pageable = __webpack_require__(38645);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/types/index.ts
var types = __webpack_require__(24770);
// EXTERNAL MODULE: ./packages/web3-shared/flow/src/sdk/index.ts
var src_sdk = __webpack_require__(35401);
// EXTERNAL MODULE: ./packages/web3-shared/flow/src/constants/constants.ts + 3 modules
var constants = __webpack_require__(22905);
// EXTERNAL MODULE: ./packages/web3-shared/flow/src/helpers/token.ts
var token = __webpack_require__(5799);
// EXTERNAL MODULE: ./packages/web3-shared/flow/src/types.ts
var src_types = __webpack_require__(59190);
// EXTERNAL MODULE: ./packages/web3-shared/flow/src/helpers/address.ts + 1 modules
var helpers_address = __webpack_require__(44050);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/number.ts
var number = __webpack_require__(29763);
// EXTERNAL MODULE: ./packages/web3-providers/src/CoinGecko/apis/PriceAPI_EVM.ts
var PriceAPI_EVM = __webpack_require__(93233);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Flow/apis/FungibleTokenAPI.ts





async function getTokenBalance(chainId, account, decimals, { fungibleTokenAddress, tokenAddress, exportKey, storageKey }) {
    const sdk = (0,src_sdk/* createClient */.e)(chainId);
    try {
        const balance = await sdk.query({
            cadence: `
            import FungibleToken from ${fungibleTokenAddress}
            import ${exportKey} from ${tokenAddress}

            pub fun main(address: Address): UFix64 {
                let account = getAccount(address)
                let vaultRef = account
                    .getCapability(/public/${storageKey})
                    .borrow<&${exportKey}.Vault{FungibleToken.Balance}>()
                    ?? panic("Could not borrow Balance capability")

                return vaultRef.balance
            }
        `,
            args: (arg, t)=>[
                    arg(account, t.Address)
                ]
        });
        return (0,number/* rightShift */.pu)(balance, decimals).integerValue().toFixed();
    } catch  {
        return '0';
    }
}
async function getAssetFUSD(chainId, account) {
    const { FUSD_ADDRESS = '', FUNGIBLE_TOKEN_ADDRESS = '' } = (0,constants/* getTokenConstants */.aV)(chainId);
    const price = await PriceAPI_EVM/* CoinGeckoPriceEVM */.O.getFungibleTokenPrice(types/* ChainId */.a_.Mainnet, 'usd-coin', {
        currencyType: specs/* CurrencyType */.V2.USD
    });
    const balance = await getTokenBalance(chainId, account, 8, {
        fungibleTokenAddress: FUNGIBLE_TOKEN_ADDRESS,
        tokenAddress: FUSD_ADDRESS,
        exportKey: 'FUSD',
        storageKey: 'fusdBalance'
    });
    return (0,token/* createFungibleAsset */.kI)((0,token/* createFungibleToken */.mn)(chainId, FUSD_ADDRESS, 'Flow USD', 'FUSD', 8, new URL(/* asset import */ __webpack_require__(6510), __webpack_require__.b).toString()), balance, {
        [specs/* CurrencyType */.V2.USD]: price?.toString()
    });
}
async function getAssetFLOW(chainId, account) {
    const { FLOW_ADDRESS = '', FUNGIBLE_TOKEN_ADDRESS = '' } = (0,constants/* getTokenConstants */.aV)(chainId);
    const price = await PriceAPI_EVM/* CoinGeckoPriceEVM */.O.getFungibleTokenPrice(types/* ChainId */.a_.Mainnet, 'flow', {
        currencyType: specs/* CurrencyType */.V2.USD
    });
    const balance = await getTokenBalance(chainId, account, 8, {
        fungibleTokenAddress: FUNGIBLE_TOKEN_ADDRESS,
        tokenAddress: FLOW_ADDRESS,
        exportKey: 'FlowToken',
        storageKey: 'flowTokenBalance'
    });
    return (0,token/* createFungibleAsset */.kI)((0,token/* createFungibleToken */.mn)(chainId, FLOW_ADDRESS, 'Flow', 'FLOW', 8, new URL(/* asset import */ __webpack_require__(65531), __webpack_require__.b).toString()), balance, {
        [specs/* CurrencyType */.V2.USD]: price?.toString()
    });
}
async function getAssetTether(chainId, account) {
    const { TETHER_ADDRESS = '', FUNGIBLE_TOKEN_ADDRESS = '' } = (0,constants/* getTokenConstants */.aV)(chainId);
    const price = await PriceAPI_EVM/* CoinGeckoPriceEVM */.O.getFungibleTokenPrice(types/* ChainId */.a_.Mainnet, 'tether', {
        currencyType: specs/* CurrencyType */.V2.USD
    });
    const balance = await getTokenBalance(chainId, account, 8, {
        fungibleTokenAddress: FUNGIBLE_TOKEN_ADDRESS,
        tokenAddress: TETHER_ADDRESS,
        exportKey: 'TeleportedTetherToken',
        storageKey: 'teleportedTetherTokenBalance'
    });
    return (0,token/* createFungibleAsset */.kI)((0,token/* createFungibleToken */.mn)(chainId, TETHER_ADDRESS, 'Tether USD', 'tUSD', 8, new URL(/* asset import */ __webpack_require__(15861), __webpack_require__.b).toString()), balance, {
        [specs/* CurrencyType */.V2.USD]: price?.toString()
    });
}
class FlowFungibleAPI {
    async getAssets(account, { chainId = src_types/* ChainId */.a_.Mainnet, indicator } = {}) {
        if (!(0,helpers_address/* isValidChainId */.JW)(chainId)) return (0,Pageable/* createPageable */.LI)([], (0,Pageable/* createIndicator */.sz)(indicator));
        const allSettled = await Promise.allSettled([
            getAssetFLOW(chainId, account),
            getAssetFUSD(chainId, account),
            getAssetTether(chainId, account)
        ]);
        const items = allSettled.map((x)=>x.status === 'fulfilled' ? x.value : null).filter(Boolean);
        return (0,Pageable/* createPageable */.LI)(items, (0,Pageable/* createIndicator */.sz)(indicator));
    }
    async getFungibleTokenList(chainId) {
        const { FLOW_ADDRESS = '', FUSD_ADDRESS = '', TETHER_ADDRESS = '' } = (0,constants/* getTokenConstants */.aV)(chainId);
        return [
            (0,token/* createFungibleToken */.mn)(chainId, FLOW_ADDRESS, 'Flow', 'FLOW', 8, new URL(/* asset import */ __webpack_require__(65531), __webpack_require__.b).toString()),
            (0,token/* createFungibleToken */.mn)(chainId, FUSD_ADDRESS, 'Flow USD', 'FUSD', 8, new URL(/* asset import */ __webpack_require__(6510), __webpack_require__.b).toString()),
            (0,token/* createFungibleToken */.mn)(chainId, TETHER_ADDRESS, 'Tether USD', 'tUSD', 8, new URL(/* asset import */ __webpack_require__(15861), __webpack_require__.b).toString())
        ];
    }
}
const FlowFungible = new FlowFungibleAPI();

// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Flow/apis/ConnectionAPI.ts + 1 modules
var ConnectionAPI = __webpack_require__(8424);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Base/apis/HubFungibleAPI.ts
var HubFungibleAPI = __webpack_require__(34659);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Flow/apis/HubFungibleAPI.ts





class FlowHubFungibleAPI extends HubFungibleAPI/* HubFungibleAPI_Base */.L {
    FlowWeb3 = new ConnectionAPI/* FlowConnectionAPI */.Y();
    HubOptions = new FlowHubOptionsAPI(this.options);
    getProviders(initial) {
        return this.getPredicateProviders({
            [specs/* SourceType */.PO.Flow]: FlowFungible
        }, [
            FlowFungible
        ], initial);
    }
    getFungibleToken(address, initial) {
        return this.FlowWeb3.getFungibleToken(address, initial);
    }
}

// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Base/apis/HubNonFungibleAPI.ts
var HubNonFungibleAPI = __webpack_require__(18391);
// EXTERNAL MODULE: ./node_modules/.pnpm/urlcat@3.1.0_patch_hash=5r5xyq4zgcnqugwsrx4lxq2i4e/node_modules/urlcat/dist/index.mjs
var dist = __webpack_require__(78757);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/resolver.ts
var helpers_resolver = __webpack_require__(53007);
// EXTERNAL MODULE: ./packages/web3-providers/src/Alchemy/constants.ts
var Alchemy_constants = __webpack_require__(37803);
// EXTERNAL MODULE: ./packages/web3-providers/src/Alchemy/helpers.ts
var helpers = __webpack_require__(72642);
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/fetchJSON.ts
var fetchJSON = __webpack_require__(11834);
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/getAssetFullName.ts
var getAssetFullName = __webpack_require__(28289);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Alchemy/apis/Flow.ts








function createNonFungibleTokenImageURL(asset) {
    return asset?.metadata?.metadata?.find((data)=>data?.name === 'img')?.value || asset?.metadata?.metadata?.find((data)=>data?.name === 'eventImage')?.value || asset?.metadata?.metadata?.find((data)=>data?.name === 'ipfsLink')?.value || asset?.media?.find((data)=>data?.mimeType === 'image/png | image')?.uri || (0,helpers_resolver/* resolveArweaveURL */.Bz)(asset?.metadata?.metadata?.find((data)=>data?.name === 'arLink')?.value || '');
}
function createNonFungibleToken(chainId, asset) {
    const tokenId = (0,helpers/* formatAlchemyTokenId */.d)(asset.id.tokenId);
    const address = (0,helpers/* formatAlchemyTokenAddress */.A)(asset.contract.address, asset.contract.name);
    return {
        id: `${asset.contract.address}_${tokenId}`,
        chainId,
        type: specs/* TokenType */.iv.NonFungible,
        schema: src_types/* SchemaType */.XQ.NonFungible,
        tokenId,
        address,
        metadata: {
            chainId,
            name: (0,getAssetFullName/* getAssetFullName */.q)(address, asset?.contract?.name ?? '', asset?.contract?.name, tokenId),
            symbol: '',
            description: asset.description,
            imageURL: createNonFungibleTokenImageURL(asset),
            mediaURL: asset?.media?.find((data)=>data?.mimeType === 'image/png | image')?.uri
        },
        contract: {
            chainId,
            schema: src_types/* SchemaType */.XQ.NonFungible,
            address,
            name: asset?.contract?.name ?? '',
            symbol: ''
        },
        source: specs/* SourceType */.PO.Alchemy_FLOW
    };
}
function createNonFungibleAsset(chainId, ownerAddress, metadata) {
    const tokenId = (0,helpers/* formatAlchemyTokenId */.d)(metadata.id.tokenId);
    const address = (0,helpers/* formatAlchemyTokenAddress */.A)(metadata.contract.address, metadata.contract.name);
    return {
        id: `${metadata.contract.address}_${tokenId}`,
        chainId,
        type: specs/* TokenType */.iv.NonFungible,
        schema: src_types/* SchemaType */.XQ.NonFungible,
        tokenId,
        address,
        metadata: {
            chainId,
            name: (0,getAssetFullName/* getAssetFullName */.q)(address, metadata.contract?.name ?? '', metadata.contract?.name, tokenId),
            symbol: '',
            description: metadata.description,
            imageURL: createNonFungibleTokenImageURL(metadata),
            mediaURL: metadata.media?.find((data)=>data?.mimeType === 'image/png | image')?.uri
        },
        contract: {
            chainId,
            schema: src_types/* SchemaType */.XQ.NonFungible,
            address,
            name: metadata.contract?.name,
            symbol: ''
        },
        collection: {
            chainId,
            name: '',
            slug: '',
            description: metadata.description
        },
        link: '',
        owner: {
            address: ownerAddress
        },
        traits: metadata.metadata?.metadata.map((x)=>({
                type: x.name,
                value: x.value
            }))?.filter((trait)=>Alchemy_constants/* FILTER_WORDS */.x_?.findIndex((name)=>name === trait.type) === -1),
        source: specs/* SourceType */.PO.Alchemy_FLOW
    };
}
class AlchemyFlowAPI {
    async getAsset(address, tokenId, { account, chainId = src_types/* ChainId */.a_.Mainnet } = {}) {
        const { address: contractAddress, identifier: contractName } = (0,helpers_address/* getContractAddress */.CR)(address) ?? {};
        if (!account || !contractAddress || !contractName || !(0,helpers_address/* isValidChainId */.JW)(chainId)) return;
        const chainInfo = Alchemy_constants/* Alchemy_FLOW_NetworkMap */.Ih?.chains?.find((chain)=>chain.chainId === chainId);
        const metadata = await (0,fetchJSON/* fetchJSON */.ZV)((0,dist/* default */.ZP)(`${chainInfo?.baseURL}/getNFTMetadata/`, {
            owner: account,
            contractAddress,
            contractName,
            tokenId
        }));
        if (!metadata) return;
        return createNonFungibleAsset(chainId, account, metadata);
    }
    async getAssets(from, { chainId, indicator } = {}) {
        if (!from || !(0,helpers_address/* isValidChainId */.JW)(chainId)) return (0,Pageable/* createPageable */.LI)([], (0,Pageable/* createIndicator */.sz)(indicator));
        const chainInfo = Alchemy_constants/* Alchemy_FLOW_NetworkMap */.Ih?.chains?.find((chain)=>chain.chainId === chainId);
        const res = await (0,fetchJSON/* fetchJSON */.ZV)((0,dist/* default */.ZP)(`${chainInfo?.baseURL}/getNFTs/`, {
            owner: from,
            pageKey: typeof indicator?.index !== 'undefined' && indicator.index !== 0 ? indicator.id : undefined
        }));
        const assets = res?.nfts?.map((nft)=>createNonFungibleToken(chainId ?? src_types/* ChainId */.a_.Mainnet, nft));
        return (0,Pageable/* createPageable */.LI)(assets, (0,Pageable/* createIndicator */.sz)(indicator));
    }
}
const AlchemyFlow = new AlchemyFlowAPI();

;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Flow/apis/HubNonFungibleAPI.ts




class FlowHubNonFungibleAPI extends HubNonFungibleAPI/* HubNonFungibleAPI_Base */.j {
    HubOptions = new FlowHubOptionsAPI(this.options);
    getProviders(initial) {
        return this.getPredicateProviders({
            [specs/* SourceType */.PO.Alchemy_FLOW]: AlchemyFlow
        }, [
            AlchemyFlow
        ], initial);
    }
}

// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Solana/apis/OthersAPI.ts + 1 modules
var apis_OthersAPI = __webpack_require__(8363);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Solana/apis/Web3StateAPI.ts
var apis_Web3StateAPI = __webpack_require__(21984);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Solana/apis/HubOptionsAPI.ts



class SolanaHubOptionsAPI extends HubOptionsAPI/* HubOptionsAPI_Base */.v {
    get Web3StateRef() {
        return apis_Web3StateAPI.SolanaWeb3StateRef;
    }
    get Web3Others() {
        return new apis_OthersAPI/* SolanaOthersAPI */.r();
    }
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Solana/apis/HubBaseAPI.ts


class SolanaHubBaseAPI extends HubBaseAPI/* HubBaseAPI_Base */.j {
    getGasOptions = undefined;
    getTransactions = undefined;
    HubOptions = new SolanaHubOptionsAPI(this.options);
}

// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/attemptUntil.ts
var attemptUntil = __webpack_require__(92358);
// EXTERNAL MODULE: ./packages/web3-shared/solana/src/types.ts
var solana_src_types = __webpack_require__(97834);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Solana/apis/ConnectionAPI.ts + 7 modules
var apis_ConnectionAPI = __webpack_require__(46148);
// EXTERNAL MODULE: ./packages/web3-providers/src/CoinGecko/apis/PriceAPI_Solana.ts
var PriceAPI_Solana = __webpack_require__(40482);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Solana/apis/FungibleTokenAPI.ts + 1 modules
var FungibleTokenAPI = __webpack_require__(45989);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Solana/apis/HubFungibleAPI.ts








class SolanaHubFungibleAPI extends HubFungibleAPI/* HubFungibleAPI_Base */.L {
    Web3 = new apis_ConnectionAPI/* SolanaConnectionAPI */.k();
    HubOptions = new SolanaHubOptionsAPI(this.options);
    getProviders(initial) {
        const options = this.HubOptions.fill(initial);
        // only the first page is available
        if ((options.indicator?.index ?? 0) > 0) return [];
        return this.getPredicateProviders({
            [specs/* SourceType */.PO.Solana]: FungibleTokenAPI/* SolanaFungible */.n,
            [specs/* SourceType */.PO.CoinGecko]: PriceAPI_Solana/* CoinGeckoPriceSolana */.I
        }, [
            FungibleTokenAPI/* SolanaFungible */.n,
            PriceAPI_Solana/* CoinGeckoPriceSolana */.I
        ], initial);
    }
    getFungibleToken(address, initial) {
        return (0,attemptUntil/* attemptUntil */.C)([
            ()=>apis_Web3StateAPI.SolanaWeb3StateRef.value.Token?.createFungibleToken?.(initial?.chainId ?? solana_src_types/* ChainId */.a_.Mainnet, address),
            ()=>this.Web3.getFungibleToken(address, initial)
        ], undefined);
    }
}

// EXTERNAL MODULE: ./packages/web3-providers/src/MagicEden/index.ts + 1 modules
var MagicEden = __webpack_require__(9766);
// EXTERNAL MODULE: ./node_modules/.pnpm/@metaplex+js@4.11.7_@metaplex-foundation+mpl-auction@0.0.2_@metaplex-foundation+mpl-core@0.0._7uazmvunxxghvixol5yhx34wd4/node_modules/@metaplex/js/lib/index.browser.esm.js
var index_browser_esm = __webpack_require__(19635);
// EXTERNAL MODULE: ./node_modules/.pnpm/@metaplex-foundation+mpl-token-metadata@1.1.0/node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/mpl-token-metadata.js
var mpl_token_metadata = __webpack_require__(73747);
// EXTERNAL MODULE: ./packages/shared-base/src/constants.ts
var src_constants = __webpack_require__(52033);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Solana/helpers/index.ts
var Solana_helpers = __webpack_require__(7938);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Solana/apis/NonFungibleTokenAPI.ts








async function getNonFungibleAssets(chainId, account) {
    const data = await (0,Solana_helpers/* requestRPC */.ZN)(chainId, {
        method: 'getProgramAccounts',
        params: [
            'https://api.raydium.io/v2/sdk/token/raydium.mainnet.json',
            {
                encoding: 'jsonParsed',
                filters: [
                    {
                        dataSize: 165
                    },
                    {
                        memcmp: {
                            offset: 32,
                            bytes: account
                        }
                    }
                ]
            }
        ]
    });
    if (!data.result?.length) return src_constants/* EMPTY_LIST */.rP;
    const connection = new index_browser_esm/* Connection */.ew('mainnet-beta');
    const nftTokens = data.result.filter((x)=>x.account.data.parsed.info.tokenAmount.decimals === 0);
    const promises = nftTokens.map(async (x)=>{
        const pda = await mpl_token_metadata.Metadata.getPDA(x.account.data.parsed.info.mint);
        const metadata = await mpl_token_metadata.Metadata.load(connection, pda);
        if (!metadata) return null;
        const externalMeta = await (0,fetchJSON/* fetchJSON */.ZV)(metadata.data.data.uri).catch(()=>null);
        const pubkey = pda.toBase58();
        return {
            id: pubkey,
            tokenId: pubkey,
            chainId,
            type: specs/* TokenType */.iv.NonFungible,
            schema: solana_src_types/* SchemaType */.XQ.NonFungible,
            address: '',
            contract: {
                chainId,
                name: metadata.data.data.name,
                symbol: metadata.data.data.symbol,
                address: pubkey,
                schema: solana_src_types/* SchemaType */.XQ.NonFungible
            },
            metadata: {
                chainId,
                name: (0,getAssetFullName/* getAssetFullName */.q)(pubkey, metadata.data.data.name, metadata.data.data.name),
                symbol: metadata.data.data.symbol,
                description: externalMeta?.description,
                mediaURL: externalMeta?.animation ?? externalMeta?.image ?? '',
                mediaType: externalMeta?.properties?.category || 'Unknown'
            }
        };
    });
    const allSettled = await Promise.allSettled(promises);
    return allSettled.flatMap((x)=>x.status === 'fulfilled' ? x.value ?? [] : []);
}
class SolanaNonFungibleTokenAPI {
    async getAssets(address, options) {
        const tokens = await getNonFungibleAssets(options?.chainId ?? solana_src_types/* ChainId */.a_.Mainnet, address);
        return (0,Pageable/* createPageable */.LI)(tokens, (0,Pageable/* createIndicator */.sz)(options?.indicator));
    }
}
const SolanaNonFungible = new SolanaNonFungibleTokenAPI();

// EXTERNAL MODULE: ./packages/web3-shared/solana/src/helpers/address.ts + 2 modules
var src_helpers_address = __webpack_require__(97470);
// EXTERNAL MODULE: ./packages/web3-providers/src/NFTScan/helpers/Solana.ts
var Solana = __webpack_require__(91549);
;// CONCATENATED MODULE: ./packages/web3-providers/src/NFTScan/apis/NonFungibleTokenAPI_Solana.ts




class NFTScanNonFungibleTokenAPI_Solana {
    async getAsset(address, _, { chainId = solana_src_types/* ChainId */.a_.Mainnet } = {}) {
        if (!(0,src_helpers_address/* isValidChainId */.JW)(chainId)) return;
        const path = (0,dist/* default */.ZP)('/api/sol/assets/:address', {
            address,
            show_attribute: true
        });
        const response = await (0,Solana/* fetchFromNFTScanV2 */.kB)(chainId, path);
        if (!response?.data) return;
        const asset = (0,Solana/* createNonFungibleAsset */.HN)(chainId, response.data);
        return asset;
    }
    async getAssets(account, { chainId = solana_src_types/* ChainId */.a_.Mainnet, indicator, size = 20 } = {}) {
        if (!(0,src_helpers_address/* isValidChainId */.JW)(chainId)) return (0,Pageable/* createPageable */.LI)(src_constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        const path = (0,dist/* default */.ZP)('/api/sol/account/own/:from', {
            from: account,
            account_address: account,
            cursor: indicator?.id,
            limit: size,
            show_attribute: true
        });
        const response = await (0,Solana/* fetchFromNFTScanV2 */.kB)(chainId, path);
        const assets = response?.data.content.map((x)=>(0,Solana/* createNonFungibleAsset */.HN)(chainId, x)) ?? src_constants/* EMPTY_LIST */.rP;
        return (0,Pageable/* createPageable */.LI)(assets, (0,Pageable/* createIndicator */.sz)(indicator), response?.data.next ? (0,Pageable/* createNextIndicator */.gT)(indicator, response?.data.next) : undefined);
    }
    async getAssetsByCollection(name, { chainId = solana_src_types/* ChainId */.a_.Mainnet, indicator, size = 20 } = {}) {
        if (!(0,src_helpers_address/* isValidChainId */.JW)(chainId) || !name) return (0,Pageable/* createPageable */.LI)(src_constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        const path = (0,dist/* default */.ZP)('/api/sol/assets/collection/:name', {
            name,
            collection: name,
            cursor: indicator?.id,
            limit: size
        });
        const response = await (0,Solana/* fetchFromNFTScanV2 */.kB)(chainId, path);
        const assets = response?.data?.content.map((x)=>(0,Solana/* createNonFungibleAsset */.HN)(chainId, x)) ?? src_constants/* EMPTY_LIST */.rP;
        return (0,Pageable/* createPageable */.LI)(assets, (0,Pageable/* createIndicator */.sz)(indicator), response?.data.next ? (0,Pageable/* createNextIndicator */.gT)(indicator, response?.data.next) : undefined);
    }
    async getCollection(name, { chainId = solana_src_types/* ChainId */.a_.Mainnet } = {}) {
        const path = (0,dist/* default */.ZP)('/api/sol/collections/:name', {
            collection: name
        });
        const response = await (0,Solana/* fetchFromNFTScanV2 */.kB)(chainId, path);
        if (!response?.data) return;
        return (0,Solana/* createNonFungibleCollection */.wP)(chainId, response.data);
    }
    async getContract(address, { chainId = solana_src_types/* ChainId */.a_.Mainnet } = {}) {
        const path = (0,dist/* default */.ZP)('/api/v2/collections/:address', {
            address
        });
        const response = await (0,Solana/* fetchFromNFTScanV2 */.kB)(chainId, path);
        if (!response?.data) return;
        return (0,Solana/* createNonFungibleTokenContract */.Xi)(chainId, response.data);
    }
    async getEvents(address, _, { chainId = solana_src_types/* ChainId */.a_.Mainnet, indicator, size = 20 } = {}) {
        if (!(0,src_helpers_address/* isValidChainId */.JW)(chainId)) return (0,Pageable/* createPageable */.LI)(src_constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        const path = (0,dist/* default */.ZP)('/api/sol/transactions/:address', {
            address,
            token_address: address,
            limit: size,
            cursor: indicator?.id
        });
        const response = await (0,Solana/* fetchFromNFTScanV2 */.kB)(chainId, path);
        const events = response?.data.content.map((x)=>(0,Solana/* createNonFungibleTokenEvent */.fE)(chainId, x)) ?? src_constants/* EMPTY_LIST */.rP;
        return (0,Pageable/* createPageable */.LI)(events, (0,Pageable/* createIndicator */.sz)(indicator), response?.data.next ? (0,Pageable/* createNextIndicator */.gT)(indicator, response?.data.next) : undefined);
    }
}
const NFTScanNonFungibleTokenSolana = new NFTScanNonFungibleTokenAPI_Solana();

// EXTERNAL MODULE: ./packages/web3-providers/src/SimpleHash/helpers.ts
var SimpleHash_helpers = __webpack_require__(91053);
// EXTERNAL MODULE: ./packages/web3-shared/solana/src/helpers/domain.ts
var domain = __webpack_require__(43500);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isEmpty.js
var isEmpty = __webpack_require__(8610);
// EXTERNAL MODULE: ./packages/web3-providers/src/SimpleHash/constants.ts
var SimpleHash_constants = __webpack_require__(62595);
;// CONCATENATED MODULE: ./packages/web3-providers/src/SimpleHash/solana-helpers.ts






function createSolanaNonFungibleAsset(asset) {
    if ((0,isEmpty/* default */.Z)(asset)) return;
    const chainId = resolveSolanaChainId(asset.chain);
    const address = asset.contract_address;
    const schema = solana_src_types/* SchemaType */.XQ.NonFungible;
    const spam_score = asset.collection.spam_score;
    if (!chainId || !(0,src_helpers_address/* isValidChainId */.JW)(chainId) || !address || spam_score !== null && spam_score >= SimpleHash_constants/* SPAM_SCORE */.Rk) return;
    // On Solana the contract is synonymous with the mint address - the field name on collection is recommended instead
    const name = (0,domain/* isValidDomain */.h)(asset.name) ? asset.name : (0,getAssetFullName/* getAssetFullName */.q)(asset.contract_address, asset.collection.name, asset.name, asset.token_id);
    return {
        id: address,
        chainId,
        link: (0,Solana/* createPermalink */.Nu)(chainId, address),
        tokenId: asset.token_id,
        type: specs/* TokenType */.iv.NonFungible,
        address,
        schema,
        creator: {
            address: asset.contract.deployed_by
        },
        owner: {
            address: asset.owners?.[0].owner_address
        },
        // TODO
        priceInToken: undefined,
        metadata: {
            chainId,
            name,
            tokenId: asset.token_id,
            symbol: asset.contract.symbol,
            description: asset.description,
            imageURL: asset.image_url || asset.previews.image_large_url,
            previewImageURL: asset.previews.image_small_url,
            blurhash: asset.previews.blurhash,
            mediaURL: asset.image_url || asset.previews.image_large_url
        },
        contract: {
            chainId,
            schema,
            address: asset.contract_address,
            // On Solana the contract is synonymous with the mint address - the field name on collection is recommended instead
            name: asset.collection.name,
            symbol: asset.contract.symbol
        },
        collection: {
            chainId,
            name: asset.collection.name || '',
            slug: asset.contract.name,
            description: asset.collection.description,
            address: asset.contract_address,
            iconURL: asset.collection.image_url,
            verified: Boolean(asset.collection.marketplace_pages?.some((x)=>x.verified)),
            createdAt: new Date(asset.created_date).getTime()
        },
        source: specs/* SourceType */.PO.SimpleHash
    };
}
function createSolanaNonFungibleCollection(collection) {
    const chainId = resolveSolanaChainId(collection.chain);
    const verifiedMarketplaces = collection.marketplace_pages?.filter((x)=>x.verified) || [];
    return {
        id: collection.id,
        chainId,
        name: collection.name || '',
        slug: collection.name,
        schema: solana_src_types/* SchemaType */.XQ.NonFungible,
        balance: collection.distinct_nfts_owned,
        iconURL: collection.image_url,
        ownersTotal: collection.total_quantity,
        source: specs/* SourceType */.PO.SimpleHash,
        address: collection.top_contracts?.[0]?.split('.')?.[1] ?? '',
        verified: verifiedMarketplaces.length > 0,
        verifiedBy: verifiedMarketplaces.map((x)=>x.marketplace_name)
    };
}
function resolveSolanaChainId(chain) {
    // Some of the `chainResolver.chainId()` results do not match.
    switch(chain){
        case 'solana':
            return solana_src_types/* ChainId */.a_.Mainnet;
        default:
            return undefined;
    }
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/SimpleHash/apis/Solana.ts






class SimpleHashAPI_Solana {
    async getAsset(address, tokenId, { chainId = solana_src_types/* ChainId */.a_.Mainnet } = {}) {
        const chain = (0,SimpleHash_helpers/* resolveChain */.Or)(PluginID/* NetworkPluginID */.F.PLUGIN_SOLANA, chainId);
        if (!chain || !address || !tokenId || !(0,src_helpers_address/* isValidChainId */.JW)(chainId)) return;
        const path = (0,dist/* default */.ZP)('/api/v0/nfts/:chain/:address/:tokenId', {
            chain,
            address,
            tokenId
        });
        const response = await (0,SimpleHash_helpers/* fetchFromSimpleHash */.d$)(path);
        return createSolanaNonFungibleAsset(response);
    }
    async getAssets(account, { chainId = solana_src_types/* ChainId */.a_.Mainnet, indicator } = {}) {
        const chain = (0,SimpleHash_helpers/* resolveChain */.Or)(PluginID/* NetworkPluginID */.F.PLUGIN_SOLANA, chainId);
        if (!account || !(0,src_helpers_address/* isValidChainId */.JW)(chainId) || !chain) {
            return (0,Pageable/* createPageable */.LI)(src_constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        }
        const path = (0,dist/* default */.ZP)('/api/v0/nfts/owners', {
            chains: chain,
            wallet_addresses: account,
            contract_addresses: '',
            cursor: typeof indicator?.index !== 'undefined' && indicator.index !== 0 ? indicator.id : undefined
        });
        const response = await (0,SimpleHash_helpers/* fetchFromSimpleHash */.d$)(path);
        const assets = response.nfts.map((x)=>createSolanaNonFungibleAsset(x)).filter(Boolean);
        return (0,Pageable/* createPageable */.LI)(assets, indicator, response.next_cursor ? (0,Pageable/* createNextIndicator */.gT)(indicator, response.next_cursor) : undefined);
    }
    async getAssetsByCollection(address, { chainId = solana_src_types/* ChainId */.a_.Mainnet, indicator } = {}) {
        const chain = (0,SimpleHash_helpers/* resolveChain */.Or)(PluginID/* NetworkPluginID */.F.PLUGIN_SOLANA, chainId);
        if (!chain || !address || !(0,src_helpers_address/* isValidChainId */.JW)(chainId)) {
            return (0,Pageable/* createPageable */.LI)(src_constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        }
        const path = (0,dist/* default */.ZP)(`/api/v0/nfts/${chain}/:address`, {
            address,
            cursor: typeof indicator?.index !== 'undefined' && indicator.index !== 0 ? indicator.id : undefined
        });
        const response = await (0,SimpleHash_helpers/* fetchFromSimpleHash */.d$)(path);
        const assets = response.nfts.map((x)=>createSolanaNonFungibleAsset(x)).filter(Boolean);
        return (0,Pageable/* createPageable */.LI)(assets, (0,Pageable/* createIndicator */.sz)(indicator), response.next_cursor ? (0,Pageable/* createNextIndicator */.gT)(indicator, response.next_cursor) : undefined);
    }
    async getCollectionsByOwner(account, { chainId, indicator } = {}) {
        if (!account || !(0,src_helpers_address/* isValidChainId */.JW)(chainId)) {
            return (0,Pageable/* createPageable */.LI)(src_constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        }
        const path = (0,dist/* default */.ZP)('/api/v0/nfts/collections_by_wallets', {
            chains: 'solana',
            wallet_addresses: account
        });
        const response = await (0,SimpleHash_helpers/* fetchFromSimpleHash */.d$)(path);
        const collections = response.collections.// Might got bad data responded including id field and other fields empty
        filter((x)=>{
            return x.id && (0,src_helpers_address/* isValidChainId */.JW)(resolveSolanaChainId(x.chain)) && (x.spam_score === null || x.spam_score <= SimpleHash_constants/* SPAM_SCORE */.Rk);
        }).map((x)=>createSolanaNonFungibleCollection(x));
        return (0,Pageable/* createPageable */.LI)(collections, (0,Pageable/* createIndicator */.sz)(indicator));
    }
    async getAssetsByCollectionAndOwner(collectionId, owner, { chainId = solana_src_types/* ChainId */.a_.Mainnet, indicator, size = 50 } = {}) {
        const chain = (0,SimpleHash_helpers/* resolveChain */.Or)(PluginID/* NetworkPluginID */.F.PLUGIN_SOLANA, chainId);
        if (!chain || !(0,src_helpers_address/* isValidChainId */.JW)(chainId) || !collectionId || !owner) return (0,Pageable/* createPageable */.LI)(src_constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        const path = (0,dist/* default */.ZP)('/api/v0/nfts/owners', {
            chains: chain,
            wallet_addresses: owner,
            collection_ids: collectionId,
            cursor: typeof indicator?.index !== 'undefined' && indicator.index !== 0 ? indicator.id : undefined,
            limit: size
        });
        const response = await (0,SimpleHash_helpers/* fetchFromSimpleHash */.d$)(path);
        const assets = response.nfts.map((x)=>createSolanaNonFungibleAsset(x)).filter(Boolean);
        return (0,Pageable/* createPageable */.LI)(assets, (0,Pageable/* createIndicator */.sz)(indicator), response.next_cursor ? (0,Pageable/* createNextIndicator */.gT)(indicator, response.next_cursor) : undefined);
    }
    async getCollectionVerifiedBy(id) {
        const path = (0,dist/* default */.ZP)('/api/v0/nfts/collections/ids', {
            collection_ids: id
        });
        const response = await (0,SimpleHash_helpers/* fetchFromSimpleHash */.d$)(path);
        if (!response.collections.length) return [];
        const marketplaces = response.collections[0].marketplace_pages?.filter((x)=>x.verified) || [];
        return marketplaces.map((x)=>x.marketplace_name);
    }
}
const SimpleHashSolana = new SimpleHashAPI_Solana();

;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Solana/apis/HubNonFungibleAPI.ts







class SolanaHubNonFungibleAPI extends HubNonFungibleAPI/* HubNonFungibleAPI_Base */.j {
    HubOptions = new SolanaHubOptionsAPI(this.options);
    getProviders(initial) {
        return this.getPredicateProviders({
            [specs/* SourceType */.PO.MagicEden]: MagicEden/* MagicEden */.I,
            [specs/* SourceType */.PO.Solana]: SolanaNonFungible,
            [specs/* SourceType */.PO.NFTScan]: NFTScanNonFungibleTokenSolana,
            [specs/* SourceType */.PO.SimpleHash]: SimpleHashSolana
        }, [
            SimpleHashSolana,
            NFTScanNonFungibleTokenSolana,
            MagicEden/* MagicEden */.I,
            SolanaNonFungible
        ], initial);
    }
}

// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/HubBaseAPI.ts + 4 modules
var apis_HubBaseAPI = __webpack_require__(81654);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/HubFungibleAPI.ts + 5 modules
var apis_HubFungibleAPI = __webpack_require__(32506);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/HubNonFungibleAPI.ts + 12 modules
var apis_HubNonFungibleAPI = __webpack_require__(85407);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/HubOptionsAPI.ts
var apis_HubOptionsAPI = __webpack_require__(40850);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/OthersAPI.ts + 1 modules
var EVM_apis_OthersAPI = __webpack_require__(63877);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Router/apis/AllHubAPI.ts

















class AllHubAPI {
    creators = {
        [PluginID/* NetworkPluginID */.F.PLUGIN_EVM]: new HubCreatorAPI_Base((initial)=>{
            return (0,mixin/* mixin */.j)(new apis_HubBaseAPI/* HubBaseAPI */.f(initial), new apis_HubFungibleAPI/* HubFungibleAPI */.K(initial), new apis_HubNonFungibleAPI/* HubNonFungibleAPI */.D(initial));
        }, new EVM_apis_OthersAPI/* OthersAPI */.i(), new apis_HubOptionsAPI/* HubOptionsAPI */.u()),
        [PluginID/* NetworkPluginID */.F.PLUGIN_FLOW]: new HubCreatorAPI_Base((initial)=>{
            return (0,mixin/* mixin */.j)(new FlowHubBaseAPI(initial), new FlowHubFungibleAPI(initial), new FlowHubNonFungibleAPI(initial));
        }, new OthersAPI/* FlowOthersAPI */.B(), new FlowHubOptionsAPI()),
        [PluginID/* NetworkPluginID */.F.PLUGIN_SOLANA]: new HubCreatorAPI_Base((initial)=>{
            return (0,mixin/* mixin */.j)(new SolanaHubBaseAPI(initial), new SolanaHubFungibleAPI(initial), new SolanaHubNonFungibleAPI(initial));
        }, new apis_OthersAPI/* SolanaOthersAPI */.r(), new SolanaHubOptionsAPI())
    };
    use(pluginID, initial) {
        return this.creators[pluginID].create(initial);
    }
}


/***/ }),

/***/ 27283:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   q: () => (/* binding */ AllOthersAPI)
/* harmony export */ });
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24835);
/* harmony import */ var _EVM_apis_OthersAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63877);
/* harmony import */ var _Flow_apis_OthersAPI_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(84351);
/* harmony import */ var _Solana_apis_OthersAPI_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8363);




class AllOthersAPI {
    creators = {
        [_masknet_shared_base__WEBPACK_IMPORTED_MODULE_0__/* .NetworkPluginID */ .F.PLUGIN_EVM]: new _EVM_apis_OthersAPI_js__WEBPACK_IMPORTED_MODULE_1__/* .OthersAPI */ .i(),
        [_masknet_shared_base__WEBPACK_IMPORTED_MODULE_0__/* .NetworkPluginID */ .F.PLUGIN_FLOW]: new _Flow_apis_OthersAPI_js__WEBPACK_IMPORTED_MODULE_2__/* .FlowOthersAPI */ .B(),
        [_masknet_shared_base__WEBPACK_IMPORTED_MODULE_0__/* .NetworkPluginID */ .F.PLUGIN_SOLANA]: new _Solana_apis_OthersAPI_js__WEBPACK_IMPORTED_MODULE_3__/* .SolanaOthersAPI */ .r()
    };
    use(pluginID) {
        return this.creators[pluginID];
    }
}


/***/ }),

/***/ 46148:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  k: () => (/* binding */ SolanaConnectionAPI)
});

// EXTERNAL MODULE: ./packages/web3-shared/solana/src/helpers/address.ts + 2 modules
var helpers_address = __webpack_require__(97470);
// EXTERNAL MODULE: ./packages/web3-shared/solana/src/types.ts
var types = __webpack_require__(97834);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/isSameAddress.ts
var isSameAddress = __webpack_require__(74765);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/specs/index.ts
var specs = __webpack_require__(62649);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/token.ts
var token = __webpack_require__(77199);
// EXTERNAL MODULE: ./packages/shared-base/src/constants.ts
var constants = __webpack_require__(52033);
// EXTERNAL MODULE: ./node_modules/.pnpm/@solana+web3.js@1.75.0/node_modules/@solana/web3.js/lib/index.browser.esm.js
var index_browser_esm = __webpack_require__(20374);
// EXTERNAL MODULE: ./packages/web3-providers/src/MagicEden/index.ts + 1 modules
var MagicEden = __webpack_require__(9766);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/memoize.js
var memoize = __webpack_require__(43434);
// EXTERNAL MODULE: ./packages/web3-shared/solana/src/sdk/index.ts
var sdk = __webpack_require__(5986);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Solana/apis/ConnectionOptionsAPI.ts
var ConnectionOptionsAPI = __webpack_require__(12550);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Solana/providers/index.ts + 7 modules
var providers = __webpack_require__(65899);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Solana/apis/Web3API.ts




const createWeb3SDK = (0,memoize/* default */.Z)((chainId)=>(0,sdk/* createClient */.e)(chainId), (chainId)=>chainId);
class SolanaWeb3API {
    options;
    constructor(options){
        this.options = options;
        this.ConnectionOptions = new ConnectionOptionsAPI/* SolanaConnectionOptionsAPI */.n(this.options);
    }
    ConnectionOptions;
    getProviderInstance(initial) {
        const options = this.ConnectionOptions.fill(initial);
        return providers/* SolanaProviders */.F[options.providerType];
    }
    getWeb3(initial) {
        const options = this.ConnectionOptions.fill(initial);
        return this.getProviderInstance(options).createWeb3(options);
    }
    getWeb3Provider(initial) {
        const options = this.ConnectionOptions.fill(initial);
        return this.getProviderInstance(options).createWeb3Provider(options);
    }
    getWeb3Connection(initial) {
        const options = this.ConnectionOptions.fill(initial);
        return createWeb3SDK(options.chainId);
    }
}

// EXTERNAL MODULE: ./node_modules/.pnpm/@solana+spl-token@0.1.8/node_modules/@solana/spl-token/lib/index.browser.esm.js
var lib_index_browser_esm = __webpack_require__(21303);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Solana/apis/spl-token/createAssociatedTokenAccountInstruction.ts
/* provided dependency */ var Buffer = __webpack_require__(7661)["Buffer"];


function createAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, programId = lib_index_browser_esm.TOKEN_PROGRAM_ID, associatedTokenProgramId = lib_index_browser_esm.ASSOCIATED_TOKEN_PROGRAM_ID) {
    const keys = [
        {
            pubkey: payer,
            isSigner: true,
            isWritable: true
        },
        {
            pubkey: associatedToken,
            isSigner: false,
            isWritable: true
        },
        {
            pubkey: owner,
            isSigner: false,
            isWritable: false
        },
        {
            pubkey: mint,
            isSigner: false,
            isWritable: false
        },
        {
            pubkey: index_browser_esm.SystemProgram.programId,
            isSigner: false,
            isWritable: false
        },
        {
            pubkey: programId,
            isSigner: false,
            isWritable: false
        },
        {
            pubkey: index_browser_esm.SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false
        }
    ];
    return new index_browser_esm.TransactionInstruction({
        keys,
        programId: associatedTokenProgramId,
        data: Buffer.alloc(0)
    });
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Solana/apis/spl-token/getAccountInfo.ts
/* provided dependency */ var getAccountInfo_Buffer = __webpack_require__(7661)["Buffer"];

var AccountState;
(function(AccountState) {
    AccountState[AccountState["Uninitialized"] = 0] = "Uninitialized";
    AccountState[AccountState["Initialized"] = 1] = "Initialized";
    AccountState[AccountState["Frozen"] = 2] = "Frozen";
})(AccountState || (AccountState = {}));
async function getAccountInfo(connection, address, commitment, programId = lib_index_browser_esm.TOKEN_PROGRAM_ID) {
    const info = await connection.getAccountInfo(address, commitment);
    if (!info) throw new Error('TokenAccountNotFoundError');
    if (!info.owner.equals(programId)) throw new Error('TokenInvalidAccountOwnerError');
    if (info.data.length !== lib_index_browser_esm.AccountLayout.span) throw new Error('TokenInvalidAccountSizeError');
    const rawAccount = lib_index_browser_esm.AccountLayout.decode(getAccountInfo_Buffer.from(info.data));
    return {
        address,
        mint: rawAccount.mint,
        owner: rawAccount.owner,
        amount: rawAccount.amount,
        delegate: rawAccount.delegateOption ? rawAccount.delegate : null,
        delegatedAmount: rawAccount.delegatedAmount,
        isInitialized: rawAccount.state !== AccountState.Uninitialized,
        isFrozen: rawAccount.state === AccountState.Frozen,
        isNative: !!rawAccount.isNativeOption,
        rentExemptReserve: rawAccount.isNativeOption ? rawAccount.isNative : null,
        closeAuthority: rawAccount.closeAuthorityOption ? rawAccount.closeAuthority : null
    };
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Solana/apis/spl-token/getAssociatedTokenAddress.ts


async function getAssociatedTokenAddress(mint, owner, allowOwnerOffCurve = false, programId = lib_index_browser_esm.TOKEN_PROGRAM_ID, associatedTokenProgramId = lib_index_browser_esm.ASSOCIATED_TOKEN_PROGRAM_ID) {
    if (!allowOwnerOffCurve && !index_browser_esm.PublicKey.isOnCurve(owner.toBuffer())) throw new Error('TokenOwnerOffCurveError');
    const [address] = await index_browser_esm.PublicKey.findProgramAddress([
        owner.toBuffer(),
        programId.toBuffer(),
        mint.toBuffer()
    ], associatedTokenProgramId);
    return address;
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Solana/apis/spl-token/getOrCreateAssociatedTokenAccount.ts





async function getOrCreateAssociatedTokenAccount(connection, payer, mint, owner, signTransaction, allowOwnerOffCurve = false, commitment = 'single', programId = lib_index_browser_esm.TOKEN_PROGRAM_ID, associatedTokenProgramId = lib_index_browser_esm.ASSOCIATED_TOKEN_PROGRAM_ID) {
    const associatedToken = await getAssociatedTokenAddress(mint, owner, allowOwnerOffCurve, programId, associatedTokenProgramId);
    // This is the optimal logic, considering TX fee, client-side computation, RPC roundtrips and guaranteed idempotent.
    // Sadly we can't do this atomically.
    let account;
    try {
        account = await getAccountInfo(connection, associatedToken, commitment, programId);
    } catch (error) {
        // TokenAccountNotFoundError can be possible if the associated address has already received some lamports,
        // becoming a system account. Assuming program derived addressing is safe, this is the only case for the
        // TokenInvalidAccountOwnerError in this code path.
        if (error.message === 'TokenAccountNotFoundError' || error.message === 'TokenInvalidAccountOwnerError') {
            // As this isn't atomic, it's possible others can create associated accounts meanwhile.
            try {
                const transaction = new index_browser_esm.Transaction().add(createAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, programId, associatedTokenProgramId));
                const blockHash = await connection.getLatestBlockhash();
                transaction.feePayer = payer;
                transaction.recentBlockhash = blockHash.blockhash;
                const signed = await signTransaction(transaction);
                const signature = await connection.sendRawTransaction(signed.serialize());
                await connection.confirmTransaction({
                    signature,
                    blockhash: blockHash.blockhash,
                    lastValidBlockHeight: blockHash.lastValidBlockHeight
                });
            } catch (error) {}
            // Ignore all errors; for now there is no API-compatible way to selectively ignore the expected
            // instruction error if the associated account exists already.
            // Now this should always succeed
            account = await getAccountInfo(connection, associatedToken, commitment, programId);
        } else {
            throw error;
        }
    }
    if (!account.mint.equals(mint.toBuffer())) throw new Error('TokenInvalidMintError');
    if (!account.owner.equals(owner.toBuffer())) throw new Error('TokenInvalidOwnerError');
    return account;
}

// EXTERNAL MODULE: ./node_modules/.pnpm/bn.js@4.12.0/node_modules/bn.js/lib/bn.js
var bn = __webpack_require__(73117);
var bn_default = /*#__PURE__*/__webpack_require__.n(bn);
// EXTERNAL MODULE: ./node_modules/.pnpm/@solana+buffer-layout@4.0.1/node_modules/@solana/buffer-layout/lib/Layout.js
var Layout = __webpack_require__(2208);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Solana/apis/spl-token/createTransferInstructions.ts
/* provided dependency */ var createTransferInstructions_Buffer = __webpack_require__(7661)["Buffer"];




var TokenInstruction;
(function(TokenInstruction) {
    TokenInstruction[TokenInstruction["InitializeMint"] = 0] = "InitializeMint";
    TokenInstruction[TokenInstruction["InitializeAccount"] = 1] = "InitializeAccount";
    TokenInstruction[TokenInstruction["InitializeMultisig"] = 2] = "InitializeMultisig";
    TokenInstruction[TokenInstruction["Transfer"] = 3] = "Transfer";
    TokenInstruction[TokenInstruction["Approve"] = 4] = "Approve";
    TokenInstruction[TokenInstruction["Revoke"] = 5] = "Revoke";
    TokenInstruction[TokenInstruction["SetAuthority"] = 6] = "SetAuthority";
    TokenInstruction[TokenInstruction["MintTo"] = 7] = "MintTo";
    TokenInstruction[TokenInstruction["Burn"] = 8] = "Burn";
    TokenInstruction[TokenInstruction["CloseAccount"] = 9] = "CloseAccount";
    TokenInstruction[TokenInstruction["FreezeAccount"] = 10] = "FreezeAccount";
    TokenInstruction[TokenInstruction["ThawAccount"] = 11] = "ThawAccount";
    TokenInstruction[TokenInstruction["TransferChecked"] = 12] = "TransferChecked";
    TokenInstruction[TokenInstruction["ApproveChecked"] = 13] = "ApproveChecked";
    TokenInstruction[TokenInstruction["MintToChecked"] = 14] = "MintToChecked";
    TokenInstruction[TokenInstruction["BurnChecked"] = 15] = "BurnChecked";
    TokenInstruction[TokenInstruction["InitializeAccount2"] = 16] = "InitializeAccount2";
    TokenInstruction[TokenInstruction["SyncNative"] = 17] = "SyncNative";
    TokenInstruction[TokenInstruction["InitializeAccount3"] = 18] = "InitializeAccount3";
    TokenInstruction[TokenInstruction["InitializeMultisig2"] = 19] = "InitializeMultisig2";
    TokenInstruction[TokenInstruction["InitializeMint2"] = 20] = "InitializeMint2";
})(TokenInstruction || (TokenInstruction = {}));
/**
 * Construct a Transfer instruction
 *
 * @param source       Source account
 * @param destination  Destination account
 * @param owner        Owner of the source account
 * @param amount       Number of tokens to transfer
 * @param multiSigners Signing accounts if `owner` is a multisig
 * @param programId    SPL Token program account
 *
 * @return Instruction to add to a transaction
 */ function createTransferInstruction(source, destination, owner, amount, multiSigners = [], programId = lib_index_browser_esm.TOKEN_PROGRAM_ID) {
    const dataLayout = Layout/* struct */.n_([
        Layout.u8('instruction'),
        Layout/* blob */.Ik(8, 'amount')
    ]);
    const keys = addSigners([
        {
            pubkey: source,
            isSigner: false,
            isWritable: true
        },
        {
            pubkey: destination,
            isSigner: false,
            isWritable: true
        }
    ], owner, multiSigners);
    const data = createTransferInstructions_Buffer.alloc(dataLayout.span);
    dataLayout.encode({
        instruction: TokenInstruction.Transfer,
        amount: new TokenAmount(amount).toBuffer()
    }, data);
    return new index_browser_esm.TransactionInstruction({
        keys,
        programId,
        data
    });
}
function addSigners(keys, ownerOrAuthority, multiSigners) {
    if (multiSigners.length) {
        keys.push({
            pubkey: ownerOrAuthority,
            isSigner: false,
            isWritable: false
        });
        for (const signer of multiSigners){
            keys.push({
                pubkey: signer.publicKey,
                isSigner: true,
                isWritable: false
            });
        }
    } else {
        keys.push({
            pubkey: ownerOrAuthority,
            isSigner: true,
            isWritable: false
        });
    }
    return keys;
}
class TokenAmount extends (bn_default()) {
    /**
     * Convert to Buffer representation
     */ toBuffer() {
        const a = super.toArray().reverse();
        const b = createTransferInstructions_Buffer.from(a);
        if (b.length === 8) {
            return b;
        }
        if (b.length >= 8) {
            throw new Error('TokenAmount too large');
        }
        const zeroPad = createTransferInstructions_Buffer.alloc(8);
        b.copy(zeroPad);
        return zeroPad;
    }
    /**
     * Construct a TokenAmount from Buffer representation
     */ static fromBuffer(buffer) {
        if (buffer.length !== 8) {
            throw new Error(`Invalid buffer length: ${buffer.length}`);
        }
        return new (bn_default())([
            ...buffer
        ].reverse().map((i)=>`00${i.toString(16)}`.slice(-2)).join(''), 16);
    }
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Solana/apis/TransferAPI.ts





class SolanaTransferAPI {
    options;
    constructor(options){
        this.options = options;
        this.Web3 = new SolanaWeb3API(this.options);
        this.ConnectionOptions = new ConnectionOptionsAPI/* SolanaConnectionOptionsAPI */.n(this.options);
    }
    Web3;
    ConnectionOptions;
    async attachRecentBlockHash(transaction, initial) {
        const connection = this.Web3.getWeb3Connection(initial);
        const blockHash = await connection.getRecentBlockhash();
        transaction.recentBlockhash = blockHash.blockhash;
        return transaction;
    }
    async signTransaction(transaction, initial) {
        return this.Web3.getProviderInstance(initial).signTransaction(transaction);
    }
    async sendTransaction(transaction, initial) {
        const signedTransaction = await this.signTransaction(transaction);
        return (0,index_browser_esm.sendAndConfirmRawTransaction)(this.Web3.getWeb3Connection(initial), signedTransaction.serialize());
    }
    async transferSol(recipient, amount, initial) {
        const options = this.ConnectionOptions.fill(initial);
        if (!options.account) throw new Error('No payer provides.');
        const payerPubkey = new index_browser_esm.PublicKey(options.account);
        const recipientPubkey = new index_browser_esm.PublicKey(recipient);
        const transaction = new index_browser_esm.Transaction().add(index_browser_esm.SystemProgram.transfer({
            fromPubkey: payerPubkey,
            toPubkey: recipientPubkey,
            lamports: Number.parseInt(amount, 10)
        }));
        transaction.feePayer = payerPubkey;
        await this.attachRecentBlockHash(transaction);
        return this.sendTransaction(transaction);
    }
    async transferSplToken(address, recipient, amount, initial) {
        const options = this.ConnectionOptions.fill(initial);
        if (!options.account) throw new Error('No payer provides.');
        const payerPubkey = new index_browser_esm.PublicKey(options.account);
        const recipientPubkey = new index_browser_esm.PublicKey(recipient);
        const mintPubkey = new index_browser_esm.PublicKey(address);
        const signTransaction = this.signTransaction.bind(this);
        const connection = this.Web3.getWeb3Connection(options);
        const formatTokenAccount = await getOrCreateAssociatedTokenAccount(connection, payerPubkey, mintPubkey, payerPubkey, signTransaction);
        const toTokenAccount = await getOrCreateAssociatedTokenAccount(connection, payerPubkey, mintPubkey, recipientPubkey, signTransaction);
        const transaction = new index_browser_esm.Transaction().add(createTransferInstruction(formatTokenAccount.address, toTokenAccount.address, payerPubkey, Number.parseInt(amount, 10)));
        const blockHash = await connection.getLatestBlockhash();
        transaction.feePayer = payerPubkey;
        transaction.recentBlockhash = blockHash.blockhash;
        return this.sendTransaction(transaction);
    }
}

// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Solana/apis/ResolverAPI.ts
var ResolverAPI = __webpack_require__(46034);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Solana/apis/Web3StateAPI.ts
var Web3StateAPI = __webpack_require__(21984);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Solana/apis/FungibleTokenAPI.ts + 1 modules
var FungibleTokenAPI = __webpack_require__(45989);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Solana/apis/ConnectionAPI.ts











class SolanaConnectionAPI {
    constructor(options){
        this.Web3 = new SolanaWeb3API(options);
        this.Transfer = new SolanaTransferAPI(options);
        this.ConnectionOptions = new ConnectionOptionsAPI/* SolanaConnectionOptionsAPI */.n(options);
    }
    Web3;
    Transfer;
    ConnectionOptions;
    getAccount(initial) {
        const options = this.ConnectionOptions.fill(initial);
        return Promise.resolve(options.account);
    }
    getChainId(initial) {
        const options = this.ConnectionOptions.fill(initial);
        return Promise.resolve(options.chainId);
    }
    createAccount(initial) {
        throw new Error('Method not implemented.');
    }
    async switchChain(chainId, initial) {
        await this.Web3.getProviderInstance(initial).switchChain(chainId);
    }
    approveFungibleToken(address, recipient, amount, initial) {
        throw new Error('Method not implemented.');
    }
    approveNonFungibleToken(address, recipient, tokenId, schema, initial) {
        throw new Error('Method not implemented.');
    }
    approveAllNonFungibleTokens(address, recipient, approved, schema, initial) {
        throw new Error('Method not implemented.');
    }
    async transferFungibleToken(address, recipient, amount, memo, initial) {
        return (0,helpers_address/* isNativeTokenAddress */.qw)(address) ? this.Transfer.transferSol(recipient, amount, initial) : this.Transfer.transferSplToken(address, recipient, amount, initial);
    }
    transferNonFungibleToken(address, tokenId, recipient, amount, schema, initial) {
        return this.Transfer.transferSplToken(address, recipient, amount, initial);
    }
    async connect(initial) {
        const options = this.ConnectionOptions.fill(initial);
        return {
            account: '',
            chainId: types/* ChainId */.a_.Mainnet,
            ...await Web3StateAPI.SolanaWeb3StateRef.value.Provider?.connect(options.providerType, options.chainId)
        };
    }
    async disconnect(initial) {
        const options = this.ConnectionOptions.fill(initial);
        await Web3StateAPI.SolanaWeb3StateRef.value.Provider?.disconnect(options.providerType);
    }
    getWeb3(initial) {
        return this.Web3.getWeb3(initial);
    }
    getWeb3Provider(initial) {
        return this.Web3.getWeb3Provider(initial);
    }
    async getBalance(account, initial) {
        const balance = await this.Web3.getWeb3Connection(initial).getBalance((0,helpers_address/* decodeAddress */.mV)(account));
        return balance.toFixed();
    }
    async getNativeTokenBalance(initial) {
        const options = this.ConnectionOptions.fill(initial);
        if (!options.account) return '0';
        const balance = await this.Web3.getWeb3Connection(options).getBalance(new index_browser_esm.PublicKey(options.account));
        return balance.toString();
    }
    async getFungibleTokenBalance(address, schema, initial) {
        const options = this.ConnectionOptions.fill(initial);
        if (!options.account) return '0';
        if ((0,helpers_address/* isNativeTokenAddress */.qw)(address)) return this.getNativeTokenBalance(options);
        const { data: assets } = await FungibleTokenAPI/* SolanaFungible */.n.getAssets(options.account, options);
        const asset = assets.find((x)=>(0,isSameAddress/* isSameAddress */.W)(x.address, address));
        return asset?.balance ?? '0';
    }
    getNonFungibleTokenBalance(address, tokenId, schema, initial) {
        throw new Error('Method not implemented.');
    }
    async getFungibleTokensBalance(listOfAddress, initial) {
        const options = this.ConnectionOptions.fill(initial);
        if (!options.account) return constants/* EMPTY_OBJECT */.Nu;
        const { data: assets } = await FungibleTokenAPI/* SolanaFungible */.n.getAssets(options.account, {
            chainId: options.chainId
        });
        const records = assets.reduce((map, asset)=>({
                ...map,
                [asset.address]: asset.balance
            }), {});
        const nativeTokenAddress = (0,helpers_address/* getNativeTokenAddress */.rG)(options.chainId);
        if (listOfAddress.includes(nativeTokenAddress)) {
            records[nativeTokenAddress] = await this.getNativeTokenBalance(options);
        }
        // In the token picker UI, if balance of a token is undefined, then it
        // will keep loading. We set it 0 to walk around that, since fetching is done.
        listOfAddress.forEach((address)=>{
            records[address] = records[address] ?? '0';
        });
        return records;
    }
    getNonFungibleTokensBalance(listOfAddress, initial) {
        throw new Error('Method not implemented.');
    }
    getGasPrice(initial) {
        throw new Error('Method not implemented.');
    }
    getCode(address, initial) {
        throw new Error('Method not implemented.');
    }
    getAddressType(address, initial) {
        return Promise.resolve(types/* AddressType */.DL.Default);
    }
    getSchemaType(address, initial) {
        throw new Error('Method not implemented.');
    }
    async getBlock(no, initial) {
        return this.Web3.getWeb3Connection(initial).getBlock(no);
    }
    async getBlockNumber(initial) {
        return this.Web3.getWeb3Connection(initial).getSlot();
    }
    async getBlockTimestamp(initial) {
        const slot = await this.getBlockNumber(initial);
        const response = await this.Web3.getWeb3Connection(initial).getBlockTime(slot);
        return response ?? 0;
    }
    getTransaction(id, initial) {
        return this.Web3.getWeb3Connection(initial).getTransaction(id);
    }
    async getTransactionReceipt(id, initial) {
        return null;
    }
    async getTransactionStatus(id, initial) {
        const response = await this.Web3.getWeb3Connection(initial).getSignatureStatus(id);
        if (response.value?.err) return specs.TransactionStatusType.FAILED;
        if (response.value?.confirmations && response.value.confirmations > 0) return specs.TransactionStatusType.SUCCEED;
        return specs.TransactionStatusType.NOT_DEPEND;
    }
    async getTransactionNonce(account, initial) {
        const response = await this.Web3.getWeb3Connection(initial).getNonce((0,helpers_address/* decodeAddress */.mV)(account));
        return response?.nonce ? Number.parseInt(response.nonce, 10) : 0;
    }
    async getNativeToken(initial) {
        const options = this.ConnectionOptions.fill(initial);
        return ResolverAPI/* SolanaChainResolver */.ZC.nativeCurrency(options.chainId);
    }
    async getFungibleToken(address, initial) {
        const options = this.ConnectionOptions.fill(initial);
        if (!address || (0,helpers_address/* isNativeTokenAddress */.qw)(address)) return this.getNativeToken(options);
        const tokens = await FungibleTokenAPI/* SolanaFungible */.n.getFungibleTokenList(options.chainId, []);
        const token = tokens.find((x)=>(0,isSameAddress/* isSameAddress */.W)(x.address, address));
        return token ?? {
            address,
            chainId: options.chainId
        };
    }
    async getNonFungibleToken(address, tokenId, schema, initial) {
        const options = this.ConnectionOptions.fill(initial);
        const asset = await MagicEden/* MagicEden */.I.getAsset(address, tokenId, {
            chainId: options.chainId
        });
        return (0,token/* createNonFungibleToken */.RV)(options.chainId, address, types/* SchemaType */.XQ.NonFungible, tokenId, asset?.ownerId, asset?.metadata, asset?.contract, asset?.collection);
    }
    getNonFungibleTokenOwner(address, tokenId, schema, initial) {
        throw new Error('Method not implemented.');
    }
    getNonFungibleTokenOwnership(address, tokenId, owner, schema, initial) {
        throw new Error('Method not implemented.');
    }
    getNonFungibleTokenMetadata(address, tokenId, schema, initial) {
        throw new Error('Method not implemented.');
    }
    getNonFungibleTokenContract(address, schema, initial) {
        throw new Error('Method not implemented.');
    }
    getNonFungibleTokenCollection(address, schema, initial) {
        throw new Error('Method not implemented.');
    }
    callTransaction(transaction, initial) {
        throw new Error('Method not implemented.');
    }
    confirmTransaction(id, initial) {
        throw new Error('Method not implemented.');
    }
    estimateTransaction(transaction, fallback, initial) {
        throw new Error('Method not implemented.');
    }
    async sendTransaction(transaction, initial) {
        const signedTransaction = await this.signTransaction(transaction);
        return (0,index_browser_esm.sendAndConfirmRawTransaction)(this.Web3.getWeb3Connection(initial), signedTransaction.serialize());
    }
    sendSignedTransaction(signature, initial) {
        return (0,index_browser_esm.sendAndConfirmRawTransaction)(this.Web3.getWeb3Connection(initial), signature.serialize());
    }
    replaceTransaction(hash, config, options) {
        throw new Error('Method not implemented.');
    }
    cancelTransaction(hash, config, options) {
        throw new Error('Method not implemented.');
    }
    async signMessage(type, message, initial) {
        return this.Web3.getProviderInstance(initial).signMessage(message);
    }
    async verifyMessage(type, message, signature, initial) {
        return this.Web3.getProviderInstance(initial).verifyMessage(message, signature);
    }
    async signTransaction(transaction, initial) {
        return this.Web3.getProviderInstance(initial).signTransaction(transaction);
    }
    signTransactions(transactions, initial) {
        return Promise.all(transactions.map((x)=>this.signTransaction(x, initial)));
    }
}


/***/ }),

/***/ 12550:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   n: () => (/* binding */ SolanaConnectionOptionsAPI)
/* harmony export */ });
/* harmony import */ var _Base_apis_ConnectionOptionsAPI_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21871);
/* harmony import */ var _OthersAPI_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8363);
/* harmony import */ var _Web3StateAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(21984);



class SolanaConnectionOptionsAPI extends _Base_apis_ConnectionOptionsAPI_js__WEBPACK_IMPORTED_MODULE_0__/* .ConnectionOptionsAPI_Base */ .G {
    get Web3StateRef() {
        return _Web3StateAPI_js__WEBPACK_IMPORTED_MODULE_1__.SolanaWeb3StateRef;
    }
    get Web3Others() {
        return new _OthersAPI_js__WEBPACK_IMPORTED_MODULE_2__/* .SolanaOthersAPI */ .r();
    }
}


/***/ }),

/***/ 45989:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  n: () => (/* binding */ SolanaFungible)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/memoize.js
var memoize = __webpack_require__(43434);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/uniqBy.js
var uniqBy = __webpack_require__(72601);
// EXTERNAL MODULE: ./node_modules/.pnpm/@masknet+kit@0.1.2/node_modules/@masknet/kit/esm/index.js + 1 modules
var esm = __webpack_require__(30898);
// EXTERNAL MODULE: ./packages/shared-base/src/Pageable/index.ts
var Pageable = __webpack_require__(38645);
// EXTERNAL MODULE: ./packages/shared-base/src/constants.ts
var constants = __webpack_require__(52033);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/isSameAddress.ts
var isSameAddress = __webpack_require__(74765);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/specs/index.ts
var specs = __webpack_require__(62649);
// EXTERNAL MODULE: ./packages/web3-shared/solana/src/types.ts
var types = __webpack_require__(97834);
// EXTERNAL MODULE: ./packages/web3-shared/solana/src/constants/constants.ts + 4 modules
var constants_constants = __webpack_require__(45118);
// EXTERNAL MODULE: ./packages/web3-shared/solana/src/helpers/address.ts + 2 modules
var helpers_address = __webpack_require__(97470);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Solana/apis/ResolverAPI.ts
var ResolverAPI = __webpack_require__(46034);
// EXTERNAL MODULE: ./packages/web3-providers/src/CoinGecko/apis/PriceAPI_Solana.ts
var PriceAPI_Solana = __webpack_require__(40482);
// EXTERNAL MODULE: ./node_modules/.pnpm/@solana+spl-token@0.1.8/node_modules/@solana/spl-token/lib/index.browser.esm.js
var index_browser_esm = __webpack_require__(21303);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Solana/constants/index.ts

const RAYDIUM_TOKEN_LIST = 'https://api.raydium.io/v2/sdk/token/raydium.mainnet.json';
const SPL_TOKEN_PROGRAM_ID = index_browser_esm.TOKEN_PROGRAM_ID.toBase58();

// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Solana/helpers/index.ts
var helpers = __webpack_require__(7938);
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/fetchJSON.ts
var fetchJSON = __webpack_require__(11834);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Solana/apis/FungibleTokenAPI.ts










const fetchRayDiumTokenList = (0,esm/* memoizePromise */.J3)(memoize/* default */.Z, async (url)=>{
    const tokenList = await (0,fetchJSON/* fetchJSON */.ZV)(url, {
        cache: 'force-cache'
    });
    const tokens = [
        ...tokenList.official,
        ...tokenList.unOfficial
    ].map((token)=>{
        if ((0,isSameAddress/* isSameAddress */.W)(token.mint, '11111111111111111111111111111111')) return ResolverAPI/* SolanaChainResolver */.ZC.nativeCurrency(types/* ChainId */.a_.Mainnet);
        return {
            id: token.mint,
            chainId: types/* ChainId */.a_.Mainnet,
            type: specs/* TokenType */.iv.Fungible,
            schema: types/* SchemaType */.XQ.Fungible,
            address: token.mint,
            name: token.name,
            symbol: token.symbol,
            decimals: token.decimals,
            logoURL: token.icon
        };
    });
    return tokens;
}, (url)=>url);
const fetchMaskTokenList = (0,esm/* memoizePromise */.J3)(memoize/* default */.Z, async (url)=>{
    const res = await (0,fetchJSON/* fetchJSON */.ZV)(url, {
        cache: 'force-cache'
    });
    const nativeAddress = (0,constants_constants/* getTokenConstant */._x)(types/* ChainId */.a_.Mainnet, 'SOL_ADDRESS', '');
    const tokens = res.tokens.map((token)=>{
        if ((0,isSameAddress/* isSameAddress */.W)(token.address, nativeAddress)) return ResolverAPI/* SolanaChainResolver */.ZC.nativeCurrency(types/* ChainId */.a_.Mainnet);
        return {
            id: token.address,
            chainId: types/* ChainId */.a_.Mainnet,
            type: specs/* TokenType */.iv.Fungible,
            schema: types/* SchemaType */.XQ.Fungible,
            address: token.address,
            name: token.name,
            symbol: token.symbol,
            decimals: token.decimals,
            logoURL: token.originLogoURI || token.logoURI
        };
    });
    return tokens;
}, (url)=>url);
class SolanaFungibleTokenAPI {
    async getSplTokenList(chainId, account) {
        if (!(0,helpers_address/* isValidChainId */.JW)(chainId)) return [];
        const data = await (0,helpers/* requestRPC */.ZN)(chainId, {
            method: 'getProgramAccounts',
            params: [
                SPL_TOKEN_PROGRAM_ID,
                {
                    encoding: 'jsonParsed',
                    filters: [
                        {
                            dataSize: 165
                        },
                        {
                            memcmp: {
                                offset: 32,
                                bytes: account
                            }
                        }
                    ]
                }
            ]
        });
        if (!data.result?.length) return [];
        const tokenList = await this.getFungibleTokenList(chainId, []);
        const splTokens = [];
        data.result.forEach((x)=>{
            const info = x.account.data.parsed.info;
            const token = tokenList.find((y)=>y.address === info.mint);
            const isSafe = info.tokenAmount.decimals !== 0 && token !== undefined;
            if (!isSafe) return;
            const name = token.name || 'Unknown Token';
            const symbol = token.symbol || 'Unknown Token';
            const splToken = (0,helpers/* createFungibleAsset */.kI)((0,helpers/* createFungibleToken */.mn)(chainId, info.mint, name, symbol, info.tokenAmount.decimals, token.logoURL), info.tokenAmount.amount);
            splTokens.push(splToken);
        });
        return splTokens;
    }
    async getAsset(account, { chainId = types/* ChainId */.a_.Mainnet } = {}) {
        const price = await PriceAPI_Solana/* CoinGeckoPriceSolana */.I.getFungibleTokenPrice(chainId, (0,helpers_address/* getNativeTokenAddress */.rG)(), {
            currencyType: specs/* CurrencyType */.V2.USD
        });
        const data = await (0,helpers/* requestRPC */.ZN)(chainId, {
            method: 'getBalance',
            params: [
                account
            ]
        });
        const balance = data.result?.value.toString() ?? '0';
        return (0,helpers/* createFungibleAsset */.kI)(ResolverAPI/* SolanaChainResolver */.ZC.nativeCurrency(chainId), balance, {
            [specs/* CurrencyType */.V2.USD]: price?.toString()
        });
    }
    async getAssets(address, { chainId = types/* ChainId */.a_.Mainnet, indicator } = {}) {
        if (!(0,helpers_address/* isValidChainId */.JW)(chainId)) {
            return (0,Pageable/* createPageable */.LI)([], (0,Pageable/* createIndicator */.sz)(indicator));
        }
        const allSettled = await Promise.allSettled([
            this.getAsset(address, {
                chainId
            }).then((x)=>[
                    x
                ]),
            this.getSplTokenList(chainId, address)
        ]);
        const assets = allSettled.map((x)=>x.status === 'fulfilled' ? x.value : null).flat().filter(Boolean);
        return (0,Pageable/* createPageable */.LI)(assets, (0,Pageable/* createIndicator */.sz)(indicator));
    }
    async getFungibleTokenList(chainId, urls) {
        if (chainId !== types/* ChainId */.a_.Mainnet) return constants/* EMPTY_LIST */.rP;
        const { FUNGIBLE_TOKEN_LISTS = constants/* EMPTY_LIST */.rP } = (0,constants_constants/* getTokenListConstants */.Hi)(chainId);
        const maskTokenList = await fetchMaskTokenList(FUNGIBLE_TOKEN_LISTS[0]);
        const rayDiumTokenList = await fetchRayDiumTokenList(RAYDIUM_TOKEN_LIST);
        return (0,uniqBy/* default */.Z)([
            ...maskTokenList,
            ...rayDiumTokenList
        ], (x)=>x.address).filter((x)=>x.name && x.symbol);
    }
    async getNonFungibleTokenList(chainId, urls) {
        return constants/* EMPTY_LIST */.rP;
    }
}
const SolanaFungible = new SolanaFungibleTokenAPI();


/***/ }),

/***/ 8363:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  r: () => (/* binding */ SolanaOthersAPI)
});

// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/formatter.ts
var formatter = __webpack_require__(41487);
// EXTERNAL MODULE: ./packages/web3-shared/solana/src/helpers/domain.ts
var domain = __webpack_require__(43500);
// EXTERNAL MODULE: ./packages/web3-shared/solana/src/helpers/address.ts + 2 modules
var address = __webpack_require__(97470);
// EXTERNAL MODULE: ./packages/web3-shared/solana/src/types.ts
var types = __webpack_require__(97834);
;// CONCATENATED MODULE: ./packages/web3-shared/solana/src/helpers/token.ts

function isNativeTokenSchemaType(schemaType) {
    // there is no native token schema on solana network
    return false;
}
function isFungibleTokenSchemaType(schemaType) {
    return schemaType === types/* SchemaType */.XQ.Fungible;
}
function isNonFungibleTokenSchemaType(schemaType) {
    return schemaType === types/* SchemaType */.XQ.NonFungible;
}

// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/token.ts
var token = __webpack_require__(77199);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Base/apis/OthersAPI.ts
var OthersAPI = __webpack_require__(57429);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/Solana/apis/ResolverAPI.ts
var ResolverAPI = __webpack_require__(46034);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Solana/apis/OthersAPI.ts





class SolanaOthersAPI extends OthersAPI/* OthersAPI_Base */.a {
    chainResolver = ResolverAPI/* SolanaChainResolver */.ZC;
    explorerResolver = ResolverAPI/* SolanaExplorerResolver */.Po;
    providerResolver = ResolverAPI/* SolanaProviderResolver */.MY;
    networkResolver = ResolverAPI/* SolanaNetworkResolver */.fl;
    isValidDomain = domain/* isValidDomain */.h;
    isValidChainId = address/* isValidChainId */.JW;
    isValidAddress = address/* isValidAddress */.At;
    isZeroAddress = address/* isZeroAddress */.uO;
    isNativeTokenAddress = address/* isNativeTokenAddress */.qw;
    isNativeTokenSchemaType = isNativeTokenSchemaType;
    isFungibleTokenSchemaType = isFungibleTokenSchemaType;
    isNonFungibleTokenSchemaType = isNonFungibleTokenSchemaType;
    getNetworkPluginID = address/* getNetworkPluginID */.yg;
    getDefaultChainId = address/* getDefaultChainId */.tA;
    getInvalidChainId = address/* getInvalidChainId */.p6;
    getDefaultNetworkType = address/* getDefaultNetworkType */.H2;
    getDefaultProviderType = address/* getDefaultProviderType */.Xo;
    getZeroAddress = address/* getZeroAddress */.R6;
    getMaskTokenAddress = address/* getMaskTokenAddress */.vY;
    getNativeTokenAddress = address/* getNativeTokenAddress */.rG;
    formatAddress = address/* formatAddress */.Tg;
    formatDomainName = formatter/* formatDomainName */.bc;
    formatTokenId = address/* formatTokenId */.Xy;
    formatSchemaType = address/* formatSchemaType */.sB;
    createNativeToken = (chainId)=>this.chainResolver.nativeCurrency(chainId);
    createFungibleToken = token/* createFungibleToken */.mn;
    createNonFungibleToken = token/* createNonFungibleToken */.RV;
}


/***/ }),

/***/ 46034:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MY: () => (/* binding */ SolanaProviderResolver),
/* harmony export */   Po: () => (/* binding */ SolanaExplorerResolver),
/* harmony export */   ZC: () => (/* binding */ SolanaChainResolver),
/* harmony export */   fl: () => (/* binding */ SolanaNetworkResolver)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_solana__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(93221);
/* harmony import */ var _Base_apis_ChainResolverAPI_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26197);
/* harmony import */ var _Base_apis_ExplorerResolverAPI_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12030);
/* harmony import */ var _Base_apis_ProviderResolverAPI_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(31710);
/* harmony import */ var _Base_apis_NetworkExplorerAPI_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(92845);





class SolanaChainResolverAPI extends _Base_apis_ChainResolverAPI_js__WEBPACK_IMPORTED_MODULE_0__/* .ChainResolverAPI_Base */ .p {
    descriptors = _masknet_web3_shared_solana__WEBPACK_IMPORTED_MODULE_1__/* .CHAIN_DESCRIPTORS */ .Q_;
}
class SolanaExplorerResolverAPI extends _Base_apis_ExplorerResolverAPI_js__WEBPACK_IMPORTED_MODULE_2__/* .ExplorerResolverAPI_Base */ .I {
    descriptors = _masknet_web3_shared_solana__WEBPACK_IMPORTED_MODULE_1__/* .CHAIN_DESCRIPTORS */ .Q_;
    initial = undefined;
}
class SolanaProviderResolverAPI extends _Base_apis_ProviderResolverAPI_js__WEBPACK_IMPORTED_MODULE_3__/* .ProviderResolverAPI_Base */ .P {
    descriptors = _masknet_web3_shared_solana__WEBPACK_IMPORTED_MODULE_1__/* .PROVIDER_DESCRIPTORS */ .zM;
}
class SolanaNetworkResolverAPI extends _Base_apis_NetworkExplorerAPI_js__WEBPACK_IMPORTED_MODULE_4__/* .NetworkResolverAPI_Base */ .n {
    descriptors = _masknet_web3_shared_solana__WEBPACK_IMPORTED_MODULE_1__/* .NETWORK_DESCRIPTORS */ .qQ;
}
const SolanaChainResolver = new SolanaChainResolverAPI();
const SolanaExplorerResolver = new SolanaExplorerResolverAPI();
const SolanaProviderResolver = new SolanaProviderResolverAPI();
const SolanaNetworkResolver = new SolanaNetworkResolverAPI();


/***/ }),

/***/ 7938:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ZN: () => (/* binding */ requestRPC),
/* harmony export */   kI: () => (/* binding */ createFungibleAsset),
/* harmony export */   mn: () => (/* binding */ createFungibleToken)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(62649);
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(29763);
/* harmony import */ var _masknet_web3_shared_solana__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5986);
/* harmony import */ var _masknet_web3_shared_solana__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(97834);


async function requestRPC(chainId, options) {
    const response = await globalThis.fetch((0,_masknet_web3_shared_solana__WEBPACK_IMPORTED_MODULE_0__/* .createClientEndpoint */ .V)(_masknet_web3_shared_solana__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet), {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        mode: 'cors',
        body: JSON.stringify({
            ...options,
            jsonrpc: '2.0',
            id: 0
        })
    });
    const json = await response.json();
    if (json.error) throw new Error(json.message || 'Fails in requesting RPC');
    return json;
}
function createFungibleToken(chainId, address, name, symbol, decimals, logoURL) {
    return {
        id: address,
        chainId,
        type: _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .TokenType */ .iv.Fungible,
        schema: _masknet_web3_shared_solana__WEBPACK_IMPORTED_MODULE_1__/* .SchemaType */ .XQ.Fungible,
        address,
        name,
        symbol,
        decimals,
        logoURL
    };
}
function createFungibleAsset(token, balance, price) {
    return {
        ...token,
        balance,
        price,
        value: {
            [_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .CurrencyType */ .V2.USD]: (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_3__/* .multipliedBy */ .$q)(price?.usd ?? 0, (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_3__/* .leftShift */ .w5)(balance, token.decimals)).toFixed()
        }
    };
}


/***/ }),

/***/ 65899:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  F: () => (/* binding */ SolanaProviders)
});

// EXTERNAL MODULE: ./packages/web3-shared/solana/src/types.ts
var types = __webpack_require__(97834);
// EXTERNAL MODULE: ./node_modules/.pnpm/@servie+events@3.0.0/node_modules/@servie/events/dist/index.js
var dist = __webpack_require__(93441);
// EXTERNAL MODULE: ./packages/shared-base/src/helpers/subscription.ts
var subscription = __webpack_require__(28129);
// EXTERNAL MODULE: ./packages/shared-base/src/constants.ts
var constants = __webpack_require__(52033);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Solana/providers/Base.ts



class BaseProvider {
    web3 = null;
    provider = null;
    emitter = new dist/* Emitter */.Q5();
    get subscription() {
        return {
            account: (0,subscription/* createConstantSubscription */.qY)(''),
            chainId: (0,subscription/* createConstantSubscription */.qY)(types/* ChainId */.a_.Mainnet),
            wallets: (0,subscription/* createConstantSubscription */.qY)(constants/* EMPTY_LIST */.rP)
        };
    }
    get connected() {
        return false;
    }
    // No need to wait by default
    get ready() {
        return true;
    }
    // No need to wait by default
    get readyPromise() {
        return Promise.resolve();
    }
    setup() {
        throw new Error('Method not implemented.');
    }
    addWallet(wallet) {
        throw new Error('Method not implemented.');
    }
    updateWallet(address, wallet) {
        throw new Error('Method not implemented.');
    }
    renameWallet(address, name) {
        throw new Error('Method not implemented.');
    }
    removeWallet(address, password) {
        throw new Error('Method not implemented.');
    }
    updateWallets(wallets) {
        throw new Error('Method not implemented.');
    }
    removeWallets(wallets) {
        throw new Error('Method not implemented.');
    }
    resetAllWallets() {
        throw new Error('Method not implemented.');
    }
    switchAccount(account) {
        throw new Error('Method not implemented.');
    }
    switchChain(chainId) {
        throw new Error('Method not implemented.');
    }
    signMessage(message) {
        throw new Error('Method not implemented.');
    }
    verifyMessage(message, signature) {
        throw new Error('Method not implemented.');
    }
    signTransaction(transaction) {
        throw new Error('Method not implemented.');
    }
    signTransactions(transactions) {
        return Promise.all(transactions.map((x)=>this.signTransaction(x)));
    }
    createWeb3(options) {
        throw new Error('Method not implemented.');
    }
    createWeb3Provider(options) {
        throw new Error('Method not implemented.');
    }
    connect(chainId) {
        throw new Error('Method not implemented.');
    }
    disconnect() {
        throw new Error('Method not implemented.');
    }
}

// EXTERNAL MODULE: ./node_modules/.pnpm/bs58@5.0.0/node_modules/bs58/index.js
var bs58 = __webpack_require__(18705);
var bs58_default = /*#__PURE__*/__webpack_require__.n(bs58);
// EXTERNAL MODULE: ./node_modules/.pnpm/@solana+web3.js@1.75.0/node_modules/@solana/web3.js/lib/index.browser.esm.js
var index_browser_esm = __webpack_require__(20374);
// EXTERNAL MODULE: ./packages/injected-script/sdk/index.ts
var sdk = __webpack_require__(46110);
// EXTERNAL MODULE: ./packages/shared-base/src/Site/index.ts
var Site = __webpack_require__(68422);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Solana/providers/BaseInjected.ts



class BaseInjectedProvider extends BaseProvider {
    providerType;
    bridge;
    constructor(providerType, bridge){
        super();
        this.providerType = providerType;
        this.bridge = bridge;
    }
    get ready() {
        return this.bridge.isReady;
    }
    get readyPromise() {
        if (!(0,Site/* isExtensionSiteType */.Po)()) return this.bridge.untilAvailable();
        return Promise.reject(new Error('Not available on extension site.'));
    }
    async setup() {
        this.bridge.on('accountChanged', this.onAccountChanged.bind(this));
        this.bridge.on('chainChanged', this.onChainChanged.bind(this));
        this.bridge.on('connect', this.onConnect.bind(this));
        this.bridge.on('disconnect', this.onDisconnect.bind(this));
    }
    onAccountChanged(account) {
        this.emitter.emit('accounts', [
            account
        ]);
    }
    onChainChanged(chainId) {
        this.emitter.emit('chainId', chainId);
    }
    onConnect(account) {
        this.emitter.emit('connect', {
            account,
            chainId: types/* ChainId */.a_.Mainnet
        });
    }
    onDisconnect() {
        this.emitter.emit('disconnect', this.providerType);
    }
    createWeb3Provider(options) {
        if (!this.bridge) throw new Error('Failed to detect in-page provider.');
        return this.bridge;
    }
    async connect(chainId) {
        await this.readyPromise;
        const provider = this.createWeb3Provider();
        const { publicKey } = await provider.connect();
        return {
            chainId,
            account: publicKey
        };
    }
    async disconnect() {
        await this.readyPromise;
        const provider = this.createWeb3Provider();
        await provider.disconnect();
    }
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Solana/providers/Phantom.ts
/* provided dependency */ var Buffer = __webpack_require__(7661)["Buffer"];





class PhantomProvider extends BaseInjectedProvider {
    constructor(){
        super(types/* ProviderType */.lP.Phantom, sdk/* injectedPhantomProvider */.ju);
    }
    async validateSession() {
        if (this.bridge.isConnected) return;
        await this.bridge.connect();
    }
    async setup() {
        if (!sdk/* injectedPhantomProvider */.ju.isReady) return;
        await sdk/* injectedPhantomProvider */.ju.untilAvailable();
        await super.setup();
    }
    async signMessage(message) {
        await this.validateSession();
        const { signature } = await this.bridge.request({
            method: types/* PhantomMethodType */.dK.SIGN_MESSAGE,
            params: {
                message: new TextEncoder().encode(message),
                display: 'hex'
            }
        });
        return signature;
    }
    async signTransaction(transaction) {
        await this.validateSession();
        const { publicKey, signature } = await this.bridge.request({
            method: types/* PhantomMethodType */.dK.SIGN_TRANSACTION,
            params: {
                message: bs58_default().encode(transaction.serializeMessage())
            }
        });
        transaction.addSignature(new index_browser_esm.PublicKey(publicKey), Buffer.from(bs58_default().decode(signature)));
        return transaction;
    }
    async signTransactions(transactions) {
        await this.validateSession();
        return this.bridge.request({
            method: 'signAllTransactions',
            params: {
                message: transactions.map((transaction)=>{
                    return bs58_default().encode(transaction.serializeMessage());
                })
            }
        });
    }
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Solana/providers/SolflareProvider.ts



class SolflareProvider extends BaseInjectedProvider {
    constructor(){
        super(types/* ProviderType */.lP.Solflare, sdk/* injectedSolflareProvider */.yR);
    }
    async signMessage(message) {
        const { signature } = await this.bridge.request({
            method: types/* PhantomMethodType */.dK.SIGN_MESSAGE,
            params: [
                new TextEncoder().encode(message)
            ]
        });
        return signature;
    }
    async signTransaction(transaction) {
        const { signature, publicKey } = await this.bridge.request({
            method: types/* PhantomMethodType */.dK.SIGN_TRANSACTION,
            params: [
                transaction
            ]
        });
        transaction.addSignature(publicKey, signature);
        return transaction;
    }
}

// EXTERNAL MODULE: ./node_modules/.pnpm/eventemitter3@4.0.7/node_modules/eventemitter3/index.js
var eventemitter3 = __webpack_require__(90630);
// EXTERNAL MODULE: ./node_modules/.pnpm/bs58@4.0.1/node_modules/bs58/index.js
var node_modules_bs58 = __webpack_require__(30721);
;// CONCATENATED MODULE: ./node_modules/.pnpm/@project-serum+sol-wallet-adapter@0.2.6_patch_hash=dl5wqnnaxjm7biesxtvdpr7gpe_@solana+web3.js@1.75.0/node_modules/@project-serum/sol-wallet-adapter/dist/esm/index.js
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



class Wallet extends eventemitter3 {
    constructor(provider, _network) {
        super();
        this._network = _network;
        this._publicKey = null;
        this._popup = null;
        this._handlerAdded = false;
        this._nextRequestId = 1;
        this._autoApprove = false;
        this._responsePromises = new Map();
        this.handleMessage = (e) => {
            var _a;
            if ((this._injectedProvider && e.source === window) ||
                (e.origin === ((_a = this._providerUrl) === null || _a === void 0 ? void 0 : _a.origin) && e.source === this._popup)) {
                if (e.data.method === 'connected') {
                    const newPublicKey = new index_browser_esm.PublicKey(e.data.params.publicKey);
                    if (!this._publicKey || !this._publicKey.equals(newPublicKey)) {
                        if (this._publicKey && !this._publicKey.equals(newPublicKey)) {
                            this.handleDisconnect();
                        }
                        this._publicKey = newPublicKey;
                        this._autoApprove = !!e.data.params.autoApprove;
                        this.emit('connect', this._publicKey);
                    }
                }
                else if (e.data.method === 'disconnected') {
                    this.handleDisconnect();
                }
                else if (e.data.result || e.data.error) {
                    const promises = this._responsePromises.get(e.data.id);
                    if (promises) {
                        const [resolve, reject] = promises;
                        if (e.data.result) {
                            resolve(e.data.result);
                        }
                        else {
                            reject(new Error(e.data.error));
                        }
                    }
                }
            }
        };
        this._beforeUnload = () => {
            void this.disconnect();
        };
        if (isInjectedProvider(provider)) {
            this._injectedProvider = provider;
        }
        else if (isString(provider)) {
            this._providerUrl = new URL(provider);
            this._providerUrl.hash = new URLSearchParams({
                origin: window.location.origin,
                network: this._network,
            }).toString();
        }
        else {
            throw new Error('provider parameter must be an injected provider or a URL string.');
        }
    }
    handleConnect() {
        var _a;
        if (!this._handlerAdded) {
            this._handlerAdded = true;
            window.addEventListener('message', this.handleMessage);
            window.addEventListener('beforeunload', this._beforeUnload);
        }
        if (this._injectedProvider) {
            return new Promise((resolve) => {
                void this.sendRequest('connect', {});
                resolve();
            });
        }
        else {
            window.name = 'parent';
            this._popup = window.open((_a = this._providerUrl) === null || _a === void 0 ? void 0 : _a.toString(), '_blank', 'location,resizable,width=460,height=675');
            return new Promise((resolve) => {
                this.once('connect', resolve);
            });
        }
    }
    handleDisconnect() {
        if (this._handlerAdded) {
            this._handlerAdded = false;
            window.removeEventListener('message', this.handleMessage);
            window.removeEventListener('beforeunload', this._beforeUnload);
        }
        if (this._publicKey) {
            this._publicKey = null;
            this.emit('disconnect');
        }
        this._responsePromises.forEach(([, reject], id) => {
            this._responsePromises.delete(id);
            reject(new Error('Wallet disconnected'));
        });
    }
    sendRequest(method, params) {
        return __awaiter(this, void 0, void 0, function* () {
            if (method !== 'connect' && !this.connected) {
                throw new Error('Wallet not connected');
            }
            const requestId = this._nextRequestId;
            ++this._nextRequestId;
            return new Promise((resolve, reject) => {
                var _a, _b, _c, _d;
                this._responsePromises.set(requestId, [resolve, reject]);
                if (this._injectedProvider) {
                    this._injectedProvider.postMessage({
                        jsonrpc: '2.0',
                        id: requestId,
                        method,
                        params: Object.assign({ network: this._network }, params),
                    });
                }
                else {
                    (_a = this._popup) === null || _a === void 0 ? void 0 : _a.postMessage({
                        jsonrpc: '2.0',
                        id: requestId,
                        method,
                        params,
                    }, (_c = (_b = this._providerUrl) === null || _b === void 0 ? void 0 : _b.origin) !== null && _c !== void 0 ? _c : '');
                    if (!this.autoApprove) {
                        (_d = this._popup) === null || _d === void 0 ? void 0 : _d.focus();
                    }
                }
            });
        });
    }
    get publicKey() {
        return this._publicKey;
    }
    get connected() {
        return this._publicKey !== null;
    }
    get autoApprove() {
        return this._autoApprove;
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._popup) {
                this._popup.close();
            }
            yield this.handleConnect();
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._injectedProvider) {
                yield this.sendRequest('disconnect', {});
            }
            if (this._popup) {
                this._popup.close();
            }
            this.handleDisconnect();
        });
    }
    sign(data, display) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(data instanceof Uint8Array)) {
                throw new Error('Data must be an instance of Uint8Array');
            }
            const response = (yield this.sendRequest('sign', {
                data,
                display,
            }));
            const signature = node_modules_bs58.decode(response.signature);
            const publicKey = new index_browser_esm.PublicKey(response.publicKey);
            return {
                signature,
                publicKey,
            };
        });
    }
    signTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = (yield this.sendRequest('signTransaction', {
                message: node_modules_bs58.encode(transaction.serializeMessage()),
            }));
            const signature = node_modules_bs58.decode(response.signature);
            const publicKey = new index_browser_esm.PublicKey(response.publicKey);
            transaction.addSignature(publicKey, signature);
            return transaction;
        });
    }
    signAllTransactions(transactions) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = (yield this.sendRequest('signAllTransactions', {
                messages: transactions.map((tx) => node_modules_bs58.encode(tx.serializeMessage())),
            }));
            const signatures = response.signatures.map((s) => node_modules_bs58.decode(s));
            const publicKey = new index_browser_esm.PublicKey(response.publicKey);
            transactions = transactions.map((tx, idx) => {
                tx.addSignature(publicKey, signatures[idx]);
                return tx;
            });
            return transactions;
        });
    }
    diffieHellman(publicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(publicKey instanceof Uint8Array)) {
                throw new Error('Data must be an instance of Uint8Array');
            }
            const response = (yield this.sendRequest('diffieHellman', {
                publicKey,
            }));
            return response;
        });
    }
}
function isString(a) {
    return typeof a === 'string';
}
function isInjectedProvider(a) {
    return (isObject(a) && 'postMessage' in a && typeof a.postMessage === 'function');
}
function isObject(a) {
    return typeof a === 'object' && a !== null;
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Solana/providers/Sollet.ts




class SolletProvider extends BaseProvider {
    providerURL;
    wallet;
    get solanaProvider() {
        if (!this.wallet) throw new Error('No sollet connection.');
        return this.wallet;
    }
    set solanaProvider(newWallet) {
        this.wallet = newWallet;
    }
    constructor(providerURL = 'https://www.sollet.io'){
        super();
        this.providerURL = providerURL;
        this.wallet = null;
    }
    async signMessage(message) {
        const data = new TextEncoder().encode(message);
        const { signature } = await this.solanaProvider.sign(data, 'uft8');
        return bs58_default().encode(signature);
    }
    signTransaction(transaction) {
        return this.solanaProvider.signTransaction(transaction);
    }
    signTransactions(transactions) {
        return this.solanaProvider.signAllTransactions(transactions);
    }
    async connect(chainId) {
        this.solanaProvider = new Wallet(this.providerURL, '');
        await this.solanaProvider.connect();
        return {
            chainId,
            account: this.solanaProvider.publicKey?.toBase58() ?? ''
        };
    }
    async disconnect() {
        this.solanaProvider = new Wallet(this.providerURL, '');
        await this.solanaProvider.disconnect();
        this.emitter.emit('disconnect', types/* ProviderType */.lP.Sollet);
        // clean the internal wallet
        this.wallet = null;
    }
}

// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/head.js
var head = __webpack_require__(81755);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Solana/providers/Coin98.ts




class SolanaCoin98Provider extends BaseInjectedProvider {
    constructor(){
        super(types/* ProviderType */.lP.Coin98, sdk/* injectedCoin98SolanaProvider */.pb);
    }
    async signMessage(message) {
        const { signature } = await this.bridge.request({
            method: types/* Coin98MethodType */.aK.SOL_SIGN,
            params: [
                new TextEncoder().encode(message)
            ]
        });
        return signature;
    }
    async signTransaction(transaction) {
        const { signature, publicKey } = await this.bridge.request({
            method: types/* Coin98MethodType */.aK.SOL_SIGN,
            params: [
                transaction
            ]
        });
        transaction.addSignature(publicKey, signature);
        return transaction;
    }
    async connect(chainId) {
        await this.readyPromise;
        const accounts = await this.bridge.request({
            method: types/* Coin98MethodType */.aK.SOL_ACCOUNTS,
            params: []
        });
        return {
            chainId,
            account: (0,head/* default */.Z)(accounts) ?? ''
        };
    }
    async disconnect() {}
} // do nothing

;// CONCATENATED MODULE: ./packages/web3-providers/src/Web3/Solana/providers/index.ts






/** Sign message */ /** Verify signature */ /** Sign a transaction */ /** Sign multiple transactions */ const SolanaProviders = {
    [types/* ProviderType */.lP.None]: new BaseProvider(),
    [types/* ProviderType */.lP.Phantom]: new PhantomProvider(),
    [types/* ProviderType */.lP.Solflare]: new SolflareProvider(),
    [types/* ProviderType */.lP.Sollet]: new SolletProvider(),
    [types/* ProviderType */.lP.Coin98]: new SolanaCoin98Provider()
};


/***/ }),

/***/ 1599:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  KN: () => (/* binding */ Zerion),
  mF: () => (/* binding */ ZerionNonFungibleToken)
});

// UNUSED EXPORTS: ZerionGas, ZerionTrending

// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/unionWith.js
var unionWith = __webpack_require__(48740);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/head.js
var head = __webpack_require__(81755);
// EXTERNAL MODULE: ./packages/shared-base/src/Pageable/index.ts
var Pageable = __webpack_require__(38645);
// EXTERNAL MODULE: ./packages/shared-base/src/constants.ts
var constants = __webpack_require__(52033);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/isSameAddress.ts
var isSameAddress = __webpack_require__(74765);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/specs/index.ts
var specs = __webpack_require__(62649);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/number.ts
var number = __webpack_require__(29763);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/constants/constants.ts
var constants_constants = __webpack_require__(33026);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/types/index.ts
var types = __webpack_require__(24770);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/resolveImageURL.ts
var resolveImageURL = __webpack_require__(81438);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/isValidChainId.ts
var isValidChainId = __webpack_require__(37049);
// EXTERNAL MODULE: ./packages/web3-providers/src/Web3/EVM/apis/ResolverAPI.ts
var ResolverAPI = __webpack_require__(66979);
// EXTERNAL MODULE: ./node_modules/.pnpm/bignumber.js@9.1.2/node_modules/bignumber.js/bignumber.mjs
var bignumber = __webpack_require__(10149);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/address.ts
var helpers_address = __webpack_require__(65327);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/formatter.ts
var formatter = __webpack_require__(41487);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Zerion/types.ts
var SocketRequestNameSpace;
(function(SocketRequestNameSpace) {
    SocketRequestNameSpace["Address"] = 'address';
    SocketRequestNameSpace["Assets"] = 'assets';
    SocketRequestNameSpace["Gas"] = 'gas';
})(SocketRequestNameSpace || (SocketRequestNameSpace = {}));
var SocketRequestType;
(function(SocketRequestType) {
    SocketRequestType["SUBSCRIBE"] = 'subscribe';
    SocketRequestType["GET"] = 'get';
})(SocketRequestType || (SocketRequestType = {}));
var ZerionRBDTransactionType;
(function(ZerionRBDTransactionType) {
    ZerionRBDTransactionType["SEND"] = 'send';
    ZerionRBDTransactionType["RECEIVE"] = 'receive';
    ZerionRBDTransactionType["TRADE"] = 'trade';
    ZerionRBDTransactionType["AUTHORIZE"] = 'authorize';
    ZerionRBDTransactionType["EXECUTION"] = 'execution';
    ZerionRBDTransactionType["DEPLOYMENT"] = 'deployment';
    ZerionRBDTransactionType["CANCEL"] = 'cancel';
    ZerionRBDTransactionType["DEPOSIT"] = 'deposit';
    ZerionRBDTransactionType["WITHDRAW"] = 'withdraw';
    ZerionRBDTransactionType["BORROW"] = 'borrow';
    ZerionRBDTransactionType["REPAY"] = 'repay';
    ZerionRBDTransactionType["STAKE"] = 'stake';
    ZerionRBDTransactionType["UNSTAKE"] = 'unstake';
    ZerionRBDTransactionType["CLAIM"] = 'claim';
})(ZerionRBDTransactionType || (ZerionRBDTransactionType = {}));
var ZerionTransactionStatus;
(function(ZerionTransactionStatus) {
    ZerionTransactionStatus["CONFIRMED"] = 'confirmed';
    ZerionTransactionStatus["FAILED"] = 'failed';
    ZerionTransactionStatus["PENDING"] = 'pending';
})(ZerionTransactionStatus || (ZerionTransactionStatus = {}));
var ZerionTransactionDirection;
(function(ZerionTransactionDirection) {
    ZerionTransactionDirection["IN"] = 'in';
    ZerionTransactionDirection["OUT"] = 'out';
    ZerionTransactionDirection["SELF"] = 'self';
})(ZerionTransactionDirection || (ZerionTransactionDirection = {}));

;// CONCATENATED MODULE: ./packages/web3-providers/src/Zerion/helpers.ts




function isValidAsset(data) {
    const { asset, chain } = data;
    const { address } = asset.implementations[chain];
    return (0,helpers_address/* isValidAddress */.At)(address);
}
function isNativeToken(symbol) {
    return [
        'ETH',
        'BNB',
        'MATIC',
        'ARETH',
        'AETH',
        'ONE',
        'ASTR',
        'XDAI'
    ].includes(symbol);
}
function formatAsset(chainId, data) {
    const { asset, chain, quantity } = data;
    const { address: address_, decimals } = asset.implementations[chain];
    const balance = (0,number/* leftShift */.w5)(quantity, decimals).toNumber();
    const price = asset.price?.value ?? 0;
    const address = isNativeToken(asset.symbol) ? (0,constants_constants/* getTokenConstant */._x)(chainId, 'NATIVE_TOKEN_ADDRESS', '') : address_;
    return {
        id: address,
        chainId,
        type: specs/* TokenType */.iv.Fungible,
        schema: types/* SchemaType */.XQ.ERC20,
        name: asset.name ?? 'Unknown Token',
        symbol: asset.symbol,
        decimals,
        address: (0,formatter/* formatEthereumAddress */.j8)(address),
        logoURL: asset.icon_url,
        balance: quantity,
        price: {
            usd: new bignumber/* BigNumber */.O(price).toString()
        },
        value: {
            usd: (0,number/* multipliedBy */.$q)(balance, price).toString()
        }
    };
}
function normalizeTxStatus(status) {
    const map = {
        [ZerionTransactionStatus.FAILED]: specs.TransactionStatusType.FAILED,
        [ZerionTransactionStatus.CONFIRMED]: specs.TransactionStatusType.SUCCEED,
        [ZerionTransactionStatus.PENDING]: specs.TransactionStatusType.NOT_DEPEND
    };
    return map[status];
}
function formatTransactions(chainId, data) {
    return data.filter(({ type })=>type !== ZerionRBDTransactionType.AUTHORIZE).map((transaction)=>{
        const ethGasFee = (0,number/* leftShift */.w5)(transaction.fee?.value ?? 0, 18).toString();
        const usdGasFee = (0,number/* multipliedBy */.$q)(ethGasFee, transaction.fee?.price ?? 0).toString();
        return {
            id: transaction.hash,
            chainId: types/* ChainId */.a_.Mainnet,
            type: transaction.type,
            cateType: transaction.type,
            from: transaction.address_from ?? '',
            to: transaction.address_to ?? '',
            timestamp: transaction.mined_at,
            status: normalizeTxStatus(transaction.status),
            assets: transaction.changes?.map(({ asset, direction, value })=>{
                return {
                    id: asset.asset_code,
                    // TODO: distinguish NFT
                    type: specs/* TokenType */.iv.Fungible,
                    schema: types/* SchemaType */.XQ.ERC20,
                    chainId,
                    name: asset.name,
                    symbol: asset.symbol,
                    address: asset.asset_code,
                    direction,
                    amount: (0,number/* leftShift */.w5)(value, asset.decimals).toString(),
                    logoURI: asset.icon_url
                };
            }) ?? [],
            fee: {
                eth: ethGasFee,
                usd: usdGasFee
            }
        };
    });
}

// EXTERNAL MODULE: ./packages/shared-base/src/helpers/createLookupTableResolver.ts
var createLookupTableResolver = __webpack_require__(74170);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/mapKeys.js
var mapKeys = __webpack_require__(37350);
// EXTERNAL MODULE: ./node_modules/.pnpm/socket.io-client@2.4.0/node_modules/socket.io-client/lib/index.js
var lib = __webpack_require__(1816);
var lib_default = /*#__PURE__*/__webpack_require__.n(lib);
// EXTERNAL MODULE: ./node_modules/.pnpm/@masknet+kit@0.1.2/node_modules/@masknet/kit/esm/index.js + 1 modules
var esm = __webpack_require__(30898);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Zerion/base-api.ts






const ZERION_API = 'wss://api-v4.zerion.io';
// cspell:disable-next-line
const ZERION_TOKEN = 'Mask.yEUEfDnoxgLBwNEcYPVussxxjdrGwapj';
let socket = null;
const zerionChainIdResolver = (0,createLookupTableResolver/* createLookupTableResolver */.F)({
    ethereum: types/* ChainId */.a_.Mainnet,
    optimism: types/* ChainId */.a_.Optimism,
    fantom: types/* ChainId */.a_.Fantom,
    avalanche: types/* ChainId */.a_.Avalanche,
    arbitrum: types/* ChainId */.a_.Arbitrum,
    aurora: types/* ChainId */.a_.Aurora,
    'binance-smart-chain': types/* ChainId */.a_.BSC,
    xdai: types/* ChainId */.a_.xDai,
    polygon: types/* ChainId */.a_.Matic
}, ()=>undefined);
function createSocket(namespace = SocketRequestNameSpace.Address) {
    if (socket?.connected) return socket;
    if (socket) socket.removeAllListeners();
    return socket = lib_default()(`${ZERION_API}/${namespace}`, {
        transports: [
            'websocket'
        ],
        query: {
            api_token: ZERION_TOKEN
        },
        // disable the auto reconnection
        reconnection: false
    });
}
function verify(request, response) {
    // each value in request payload must be found in response meta
    return Object.keys(request.payload).every((key)=>{
        const requestValue = request.payload[key];
        const responseMetaValue = response.meta[key];
        if (typeof requestValue === 'object') {
            return JSON.stringify(requestValue) === JSON.stringify(responseMetaValue);
        }
        if (typeof requestValue === 'string') {
            return responseMetaValue?.toLowerCase() === requestValue?.toLowerCase();
        }
        return responseMetaValue === requestValue;
    });
}
function subscribeFromZerion(socketNamespace, requestBody, type = SocketRequestType.SUBSCRIBE) {
    return new Promise((resolve)=>{
        const { socket, namespace } = socketNamespace;
        const model = requestBody.scope[0];
        socket.emit(type, requestBody);
        socket.on(`received ${namespace} ${model}`, (data)=>{
            if (verify(requestBody, data)) {
                resolve(data);
            }
        });
    });
}
async function getAssetsList(address, scope) {
    return await subscribeFromZerion({
        namespace: SocketRequestNameSpace.Address,
        socket: createSocket()
    }, {
        scope: [
            scope
        ],
        payload: {
            address,
            currency: 'usd'
        }
    });
}
async function getCoinsByKeyword(keyword) {
    return await subscribeFromZerion({
        namespace: SocketRequestNameSpace.Assets,
        socket: createSocket(SocketRequestNameSpace.Assets)
    }, {
        scope: [
            'info'
        ],
        payload: {
            search_query: keyword,
            offset: 0,
            limit: 100
        }
    });
}
async function getTransactionList(address, scope, page, size = 30) {
    return await subscribeFromZerion({
        namespace: SocketRequestNameSpace.Address,
        socket: createSocket()
    }, {
        scope: [
            scope
        ],
        payload: {
            address,
            currency: 'usd',
            transactions_limit: size,
            transactions_offset: (page ?? 0) * size,
            transactions_search_query: ''
        }
    });
}
async function getNonFungibleAsset(account, address, tokenId) {
    return Promise.race([
        subscribeFromZerion({
            namespace: SocketRequestNameSpace.Address,
            socket: createSocket()
        }, {
            scope: [
                'nft'
            ],
            payload: {
                address: account,
                nft_asset_code: `${address}:${tokenId}`
            }
        }),
        (0,esm/* delay */.gw)(5_000)
    ]);
}
async function getNonFungibleAssets(address, page, size = 20, contract_address) {
    return Promise.race([
        subscribeFromZerion({
            namespace: SocketRequestNameSpace.Address,
            socket: createSocket()
        }, {
            scope: [
                'nft'
            ],
            payload: {
                address,
                contract_addresses: contract_address ? [
                    contract_address
                ] : [],
                mode: 'nft',
                nft_limit: size,
                nft_offset: (page ?? 0) * size
            }
        }, SocketRequestType.GET),
        (0,esm/* delay */.gw)(5_000)
    ]);
}
async function getNonFungibleInfo(address, tokenId) {
    return await subscribeFromZerion({
        namespace: SocketRequestNameSpace.Assets,
        socket: createSocket(SocketRequestNameSpace.Assets)
    }, {
        scope: [
            'nft-info'
        ],
        payload: {
            asset_code: `${address}:${tokenId}`,
            currency: 'eth'
        }
    });
}
async function getGasOptions(chainId) {
    const response = await subscribeFromZerion({
        namespace: SocketRequestNameSpace.Gas,
        socket: createSocket(SocketRequestNameSpace.Gas)
    }, {
        scope: [
            'chain-prices'
        ],
        payload: {}
    }, SocketRequestType.GET);
    if (!response.payload['chain-prices']) return;
    const gasOptionsCollection = (0,mapKeys/* default */.Z)(response.payload['chain-prices'], (_, key)=>zerionChainIdResolver(key));
    return gasOptionsCollection[chainId]?.info.classic;
}

// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/getAssetFullName.ts
var getAssetFullName = __webpack_require__(28289);
// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/getNativeAssets.ts
var getNativeAssets = __webpack_require__(89178);
;// CONCATENATED MODULE: ./packages/web3-providers/src/Zerion/index.ts









const ZERION_NFT_DETAIL_URL = 'https://app.zerion.io/nfts/';
const filterAssetType = [
    'compound',
    'trash',
    'uniswap',
    'uniswap-v2',
    'nft'
];
class ZerionAPI {
    async getAssets(address, options) {
        const { meta, payload } = await getAssetsList(address, 'positions');
        if (meta.status !== 'ok') return (0,Pageable/* createPageable */.LI)(constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(options?.indicator));
        const assets = payload.positions?.positions.filter((x)=>x.type === 'asset' && x.asset.icon_url && x.asset.is_displayable && !filterAssetType.includes(x.asset.type) && isValidAsset(x) && zerionChainIdResolver(x.chain))?.map((x)=>{
            return formatAsset(zerionChainIdResolver(x.chain), x);
        }) ?? constants/* EMPTY_LIST */.rP;
        return (0,Pageable/* createPageable */.LI)((0,unionWith/* default */.Z)(assets, (0,getNativeAssets/* getNativeAssets */.s)(), (a, z)=>(0,isSameAddress/* isSameAddress */.W)(a.address, z.address) && a.chainId === z.chainId), (0,Pageable/* createIndicator */.sz)(options?.indicator));
    }
    async getTransactions(address, { indicator, chainId } = {}) {
        const pairs = constants_constants/* ChainIdList */.rY.filter((x)=>x === chainId).map((x)=>[
                x,
                'transactions'
            ]);
        const allSettled = await Promise.allSettled(pairs.map(async ([chainId, scope])=>{
            if (!scope) return constants/* EMPTY_LIST */.rP;
            const { meta, payload } = await getTransactionList(address, scope);
            if (meta.status !== 'ok') return constants/* EMPTY_LIST */.rP;
            return formatTransactions(chainId, payload.transactions);
        }));
        const transactions = allSettled.flatMap((x)=>x.status === 'fulfilled' ? x.value : []);
        return (0,Pageable/* createPageable */.LI)(transactions, (0,Pageable/* createIndicator */.sz)(indicator));
    }
}
class ZerionNonFungibleTokenAPI {
    createNonFungibleCollectionFromCollectionData(chainId, collection) {
        return {
            chainId,
            scheme: types/* SchemaType */.XQ.ERC721,
            name: collection.name,
            slug: collection.collection_id,
            description: collection.description,
            iconURL: collection.icon_url,
            source: specs/* SourceType */.PO.Zerion
        };
    }
    createNonFungibleTokenPermalink(address, tokenId) {
        if (!address || !tokenId) return;
        return ZERION_NFT_DETAIL_URL + `${address}:${tokenId}`;
    }
    createNonFungibleTokenAssetFromNFT(chainId, nft) {
        const name = (0,getAssetFullName/* getAssetFullName */.q)(nft.asset.contract_address, nft.asset.collection.name, nft.asset.name, nft.asset.token_id);
        return {
            chainId,
            id: `${chainId}_${nft.asset.contract_address}_${nft.asset.token_id}`,
            type: specs/* TokenType */.iv.NonFungible,
            schema: nft.standard === 'ERC1155' ? types/* SchemaType */.XQ.ERC1155 : types/* SchemaType */.XQ.ERC721,
            address: nft.asset.contract_address,
            tokenId: nft.asset.token_id,
            contract: {
                chainId,
                schema: nft.standard === 'ERC1155' ? types/* SchemaType */.XQ.ERC1155 : types/* SchemaType */.XQ.ERC721,
                address: nft.asset.contract_address,
                name: nft.asset.collection.name,
                symbol: nft.asset.symbol
            },
            metadata: {
                chainId,
                name,
                symbol: nft.asset.symbol,
                imageURL: (0,resolveImageURL/* resolveImageURL */.y)(nft.asset.preview.url, name, nft.asset.contract_address),
                mediaURL: nft.asset.detail.url,
                mediaType: nft.asset.detail.meta.type,
                source: specs/* SourceType */.PO.Zerion
            },
            collection: {
                chainId,
                name: nft.asset.collection_info.name,
                slug: nft.asset.collection_info.slug,
                description: nft.asset.collection_info.description,
                address: nft.asset.contract_address,
                iconURL: nft.asset.collection_info.icon_url ?? nft.asset.collection.icon_url,
                verified: nft.asset.is_verified
            },
            source: specs/* SourceType */.PO.Zerion,
            link: this.createNonFungibleTokenPermalink(nft.asset.contract_address, nft.asset.token_id)
        };
    }
    async getAsset(address, tokenId, { chainId = types/* ChainId */.a_.Mainnet, account } = {}) {
        if (!account || !(0,isValidChainId/* isValidChainId */.J)(chainId)) return;
        const response = await getNonFungibleAsset(account, address, tokenId);
        if (!response?.payload.nft.length) return;
        const payload = (0,head/* default */.Z)(response.payload.nft);
        if (!payload) return;
        return this.createNonFungibleTokenAssetFromNFT(chainId, payload);
    }
    async getAssets(account, { chainId = types/* ChainId */.a_.Mainnet, indicator, size } = {}) {
        if (!(0,isValidChainId/* isValidChainId */.J)(chainId)) return (0,Pageable/* createPageable */.LI)(constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        const response = await getNonFungibleAssets(account, indicator?.index, size);
        if (!response?.payload.nft.length) return (0,Pageable/* createPageable */.LI)(constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        const assets = response.payload.nft.map((x)=>this.createNonFungibleTokenAssetFromNFT(chainId, x));
        return (0,Pageable/* createPageable */.LI)(assets, (0,Pageable/* createIndicator */.sz)(indicator), assets.length ? (0,Pageable/* createNextIndicator */.gT)(indicator) : undefined);
    }
    async getAssetsByCollection(address, { chainId = types/* ChainId */.a_.Mainnet, indicator, size, account } = {}) {
        if (!account || !(0,isValidChainId/* isValidChainId */.J)(chainId)) return (0,Pageable/* createPageable */.LI)(constants/* EMPTY_LIST */.rP, (0,Pageable/* createIndicator */.sz)(indicator));
        const response = await getNonFungibleAssets(account, indicator?.index, size, address);
        if (!response) return;
        const assets = response.payload.nft.map((x)=>this.createNonFungibleTokenAssetFromNFT(chainId, x));
        return (0,Pageable/* createPageable */.LI)(assets, (0,Pageable/* createIndicator */.sz)(indicator), assets.length ? (0,Pageable/* createNextIndicator */.gT)(indicator) : undefined);
    }
    async getFloorPrice(address, tokenId, { chainId = types/* ChainId */.a_.Mainnet } = {}) {
        if (!(0,isValidChainId/* isValidChainId */.J)(chainId)) return;
        const response = await getNonFungibleInfo(address, tokenId);
        if (!response.payload['nft-info'].asset.floor_price) return;
        const nativeToken = ResolverAPI/* ChainResolver */.iv.nativeCurrency(chainId);
        return {
            amount: (0,number/* scale10 */.SI)(response.payload['nft-info'].asset.floor_price, nativeToken.decimals).toFixed(0),
            token: nativeToken
        };
    }
}
class ZerionTrendingAPI {
    createCoinFromData(data) {
        return {
            id: data.asset.id,
            name: data.asset.name,
            symbol: data.asset.symbol,
            type: specs/* TokenType */.iv.Fungible,
            decimals: data.asset.decimals
        };
    }
    async getAllCoins(keyword) {
        if (!keyword) return constants/* EMPTY_LIST */.rP;
        const response = await getCoinsByKeyword(keyword);
        if (!response?.payload?.info?.length) return constants/* EMPTY_LIST */.rP;
        return response.payload.info.filter((x)=>!x.asset.type).map(this.createCoinFromData);
    }
    getCoinsByKeyword() {
        throw new Error('Method not implemented.');
    }
    getCoinInfoByAddress() {
        throw new Error('To be implemented.');
    }
    getCoinTrending() {
        throw new Error('Method not implemented.');
    }
    getCoinPriceStats() {
        throw new Error('Method not implemented.');
    }
    getCoinMarketInfo() {
        throw new Error('Method not implemented.');
    }
}
class ZerionGasAPI {
    async getGasOptions(chainId) {
        if (!(0,isValidChainId/* isValidChainId */.J)(chainId)) return;
        const result = await getGasOptions(chainId);
        return {
            [specs/* GasOptionType */.Qd.FAST]: {
                estimatedSeconds: 15,
                suggestedMaxFeePerGas: (0,number/* toFixed */.FH)(result?.fast),
                suggestedMaxPriorityFeePerGas: '0'
            },
            [specs/* GasOptionType */.Qd.NORMAL]: {
                estimatedSeconds: 30,
                suggestedMaxFeePerGas: (0,number/* toFixed */.FH)(result?.standard),
                suggestedMaxPriorityFeePerGas: '0'
            },
            [specs/* GasOptionType */.Qd.SLOW]: {
                estimatedSeconds: 60,
                suggestedMaxFeePerGas: (0,number/* toFixed */.FH)(result?.slow),
                suggestedMaxPriorityFeePerGas: '0'
            },
            [specs/* GasOptionType */.Qd.CUSTOM]: {
                estimatedSeconds: 0,
                suggestedMaxFeePerGas: '',
                suggestedMaxPriorityFeePerGas: ''
            }
        };
    }
}
const Zerion = new ZerionAPI();
const ZerionNonFungibleToken = new ZerionNonFungibleTokenAPI();
const ZerionTrending = new ZerionTrendingAPI();
const ZerionGas = new ZerionGasAPI();


/***/ }),

/***/ 77383:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   B: () => (/* binding */ createWeb3FromProvider)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(54644);

function createWeb3FromProvider(provider) {
    const web3 = new _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .Web3 */ .B(provider);
    web3.eth.transactionBlockTimeout = 10 * 1000;
    web3.eth.transactionPollingTimeout = 10 * 1000;
    // @ts-expect-error private or untyped API?
    // disable the default polling strategy
    web3.eth.transactionPollingInterval = Number.MAX_SAFE_INTEGER;
    return web3;
}


/***/ }),

/***/ 23877:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   x: () => (/* binding */ createWeb3FromURL)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(43434);
/* harmony import */ var _createWeb3FromProvider_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(77383);
/* harmony import */ var _createWeb3ProviderFromURL_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(18734);



function __create__(url) {
    return (0,_createWeb3FromProvider_js__WEBPACK_IMPORTED_MODULE_0__/* .createWeb3FromProvider */ .B)((0,_createWeb3ProviderFromURL_js__WEBPACK_IMPORTED_MODULE_1__/* .createWeb3ProviderFromURL */ .K)(url));
}
const createWeb3FromURL = (0,lodash_es__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(__create__, (url)=>url.toLowerCase());


/***/ }),

/***/ 14899:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   k: () => (/* binding */ createWeb3ProviderFromRequest)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48221);

function createWeb3ProviderFromRequest(request) {
    const provider = {
        on () {
            return provider;
        },
        removeListener () {
            return provider;
        },
        request,
        send (payload, callback) {
            return this.sendAsync(payload, callback);
        },
        // some pkg (eth-rpc) needs this method
        sendAsync: async (payload, callback)=>{
            try {
                const result = await request({
                    method: payload.method,
                    params: payload.params ?? []
                });
                callback(null, (0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .createJsonRpcResponse */ .T)(payload.id, result));
                return (0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .createJsonRpcResponse */ .T)(payload.id, result);
            } catch (error) {
                if (error instanceof Error) callback(error);
                return (0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .createJsonRpcResponse */ .T)(payload.id, undefined, error);
            }
        }
    };
    return provider;
}


/***/ }),

/***/ 18734:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   K: () => (/* binding */ createWeb3ProviderFromURL)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(43434);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(83135);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(40225);
/* harmony import */ var _createWeb3ProviderFromRequest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14899);
/* harmony import */ var _fetchJsonRpcResponse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6923);




function __create__(url) {
    return (0,_createWeb3ProviderFromRequest_js__WEBPACK_IMPORTED_MODULE_0__/* .createWeb3ProviderFromRequest */ .k)(async (requestArguments)=>{
        const response = await (0,_fetchJsonRpcResponse_js__WEBPACK_IMPORTED_MODULE_1__/* .fetchJsonRpcResponse */ .A)(url, (0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .createJsonRpcPayload */ .B)(0, requestArguments));
        const editor = _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_3__/* .ErrorEditor */ .Q.from(null, response);
        if (editor.presence) throw editor.error;
        return response.result;
    });
}
const createWeb3ProviderFromURL = (0,lodash_es__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(__create__, (url)=>url.toLowerCase());


/***/ }),

/***/ 62622:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  h: () => (/* binding */ fetch)
});

// EXTERNAL MODULE: ./packages/flags/src/index.ts
var src = __webpack_require__(51573);
;// CONCATENATED MODULE: ./packages/web3-telemetry/src/helpers/captureFetchTransaction.ts

function isIgnoredRequest(request) {
    return [
        // Twitter Identity API
        'mr8asf7i4h',
        // NextID
        'https://proof-service.next.id/v1/proof',
        // Twitter Assets
        'https://t.co',
        'https://pbs.twimg.com',
        'https://abs.twimg.com',
        'https://twitter.com',
        // source code
        'https://maskbook.pages.dev',
        // KV
        'https://kv.r2d2.to/api/com.maskbook.pets',
        'https://kv.r2d2.to/api/com.maskbook.user',
        // ScamDB
        'https://scam.mask.r2d2.to',
        // CDN
        /* cspell:disable-next-line */ 'cdninstagram.com',
        /* cspell:disable-next-line */ 'fbcdn.net',
        'imgix.net'
    ].some((x)=>request.url.includes(x));
}
function getHeaders(requestOrResponse) {
    try {
        if (!requestOrResponse) return 'N/A';
        return JSON.stringify(Object.fromEntries(requestOrResponse.headers.entries()));
    } catch  {
        return 'N/A';
    }
}
async function getBody(requestOrResponse) {
    try {
        const text = await requestOrResponse?.text();
        return text ?? 'N/A';
    } catch  {
        return 'N/A';
    }
}
async function captureFetchTransaction(request, response, options) {
    if (false) {}
    if (!src/* Flags */.v.sentry_enabled) return;
    if (!src/* Flags */.v.sentry_fetch_transaction_enabled) return;
    if (isIgnoredRequest(request)) return;
    const requestHeaders = getHeaders(request.clone());
    const responseHeaders = getHeaders(response?.clone());
    const requestBody = await getBody(request.clone());
    const responseBody = await getBody(response?.clone());
    const transaction = Sentry.startTransaction({
        name: request.url
    });
    const span = transaction.startChild({
        op: 'task',
        tags: {
            source: new URL(request.url).host,
            method: request.method.toUpperCase(),
            url: request.url,
            response_type: response?.type,
            response_redirected: response?.redirected,
            status_code: response?.status,
            status_text: response?.statusText
        },
        data: {
            request_headers: requestHeaders,
            request_body: requestBody,
            response_headers: responseHeaders,
            response_body: responseBody,
            response_type: response?.type,
            response_code: response?.status,
            response_status: response?.statusText,
            response_redirected: response?.redirected
        },
        status: options?.status,
        startTimestamp: options?.startAt,
        endTimestamp: options?.endAt,
        description: [
            `Failed to fetch: ${request.url}`,
            `  with Request Headers: ${requestHeaders}`,
            `  with Request Body: ${requestBody}`,
            `  with Response Headers: ${responseHeaders}`,
            `  with Response Body: ${responseBody}`
        ].join('\n')
    });
    span.finish();
    transaction.finish();
}

;// CONCATENATED MODULE: ./packages/web3-providers/src/helpers/fetch.ts

const { fetch: originalFetch } = globalThis;
async function fetch(input, init, fetchers = []) {
    const fetcher = fetchers.reduceRight((ff, f)=>(r, i)=>f(r, i, ff), (input, init)=>{
        return originalFetch(input, {
            signal: AbortSignal.timeout(3 * 60 * 1000),
            /* 3 mins */ ...init
        });
    });
    // capture exception if bad response or any error occurs
    let hasError = false;
    let response;
    // log span if request error
    const startAt = Date.now();
    try {
        response = await fetcher(input, init);
        if (!response.ok) hasError = true;
        return response;
    } catch (error) {
        hasError = true;
        throw error;
    } finally{
        if (hasError) {
            await captureFetchTransaction(new Request(input, init), response, {
                status: 'failed',
                startAt,
                endAt: Date.now()
            });
        }
    }
}


/***/ }),

/***/ 22674:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Op: () => (/* binding */ fetchCached),
/* harmony export */   be: () => (/* binding */ staleCached),
/* harmony export */   nL: () => (/* binding */ Duration)
/* harmony export */ });
/* unused harmony export createFetchCached */
const { fetch: originalFetch } = globalThis;
var Duration;
(function(Duration) {
    Duration[Duration["ONE_SECOND"] = 1000] = "ONE_SECOND";
    Duration[Duration["TEN_SECONDS"] = 10000] = "TEN_SECONDS";
    Duration[Duration["ONE_MINUTE"] = 60000] = "ONE_MINUTE";
    Duration[Duration["THIRTY_MINUTES"] = 1800000] = "THIRTY_MINUTES";
    Duration[Duration["TWELVE_HOURS"] = 43200000] = "TWELVE_HOURS";
    Duration[Duration["ONE_DAY"] = 86400000] = "ONE_DAY";
})(Duration || (Duration = {}));
function __open__(url) {
    if ('caches' in globalThis) {
        try {
            return caches.open(new URL(url).host);
        } catch  {
            return;
        }
    }
    return;
}
async function __fetch__(duration, request, init, next = originalFetch) {
    // hit a cached request
    const cache = await __open__(request.url);
    const hit = await cache?.match(request);
    const date = hit?.headers.get('x-cache-date');
    if (hit && date) {
        const expired = new Date(date).getTime() + duration < Date.now();
        if (!expired) return hit;
    }
    // send the request & cache the response
    const response = await next(request.clone(), init);
    const { ok, status, statusText, body, headers } = response.clone();
    if (ok && status === 200 && body) {
        await cache?.put(request.clone(), new Response(body, {
            status,
            statusText,
            headers: {
                ...Object.fromEntries(headers.entries()),
                // store the cached date as a UTC string
                'x-cache-date': new Date().toUTCString()
            }
        }));
    }
    return response;
}
async function fetchCached(input, init, next = originalFetch, duration = Duration.ONE_MINUTE) {
    // why: the caches doesn't define in test env
    if (false) {}
    // skip all side effect requests
    const request = new Request(input, init);
    if (request.method !== 'GET') return next(request, init);
    // skip all non-http requests
    const url = request.url;
    if (!url.startsWith('http')) return next(request, init);
    return __fetch__(duration, request, init, next);
}
async function staleCached(info, init) {
    const request = new Request(info, init);
    if (request.method !== 'GET') return;
    const url = request.url;
    if (!url.startsWith('http')) return;
    const cache = await __open__(url);
    const hit = await cache?.match(request);
    if (!hit) return;
    await cache?.delete(request);
    return hit;
}
function createFetchCached({ next = originalFetch, duration = Duration.ONE_MINUTE } = {}) {
    return async function createFetchCached(input, init, _next = next) {
        // why: the caches doesn't define in test env
        if (false) {}
        // skip all side effect requests
        const request = new Request(input, init);
        if (request.method !== 'GET') return _next(request, init);
        // skip all non-http requests
        const url = request.url;
        if (!url.startsWith('http')) return _next(request, init);
        return __fetch__(duration, request, init, _next);
    };
}


/***/ }),

/***/ 49850:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   d: () => (/* binding */ fetchGlobal)
/* harmony export */ });
/* harmony import */ var _fetch_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62622);
/* harmony import */ var _getNextFetchers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(72358);


async function fetchGlobal(input, init, options) {
    return (0,_fetch_js__WEBPACK_IMPORTED_MODULE_0__/* .fetch */ .h)(input, init, (0,_getNextFetchers_js__WEBPACK_IMPORTED_MODULE_1__/* .getNextFetchers */ .l)(options));
}


/***/ }),

/***/ 11834:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MP: () => (/* binding */ fetchCachedJSON),
/* harmony export */   Vn: () => (/* binding */ fetchSquashedJSON),
/* harmony export */   ZV: () => (/* binding */ fetchJSON)
/* harmony export */ });
/* harmony import */ var _fetch_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62622);
/* harmony import */ var _fetchCached_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(22674);
/* harmony import */ var _fetchSquashed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(64883);
/* harmony import */ var _getNextFetchers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(72358);




async function fetchJSON(input, init, options) {
    const response = await (0,_fetch_js__WEBPACK_IMPORTED_MODULE_0__/* .fetch */ .h)(input, init, (0,_getNextFetchers_js__WEBPACK_IMPORTED_MODULE_1__/* .getNextFetchers */ .l)(options));
    if (!response.ok) throw new Error('Failed to fetch as JSON.');
    return response.json();
}
async function fetchSquashedJSON(input, init, options) {
    return fetchJSON(input, init, {
        squashExpiration: _fetchSquashed_js__WEBPACK_IMPORTED_MODULE_2__/* .Expiration */ .XP.ONE_SECOND,
        ...options
    });
}
async function fetchCachedJSON(input, init, options) {
    return fetchJSON(input, init, {
        squashExpiration: _fetchSquashed_js__WEBPACK_IMPORTED_MODULE_2__/* .Expiration */ .XP.ONE_SECOND,
        cacheDuration: _fetchCached_js__WEBPACK_IMPORTED_MODULE_3__/* .Duration */ .nL.ONE_MINUTE,
        ...options
    });
}


/***/ }),

/***/ 6923:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ fetchJsonRpcResponse)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/web3-utils@1.10.2/node_modules/web3-utils/lib/index.js
var lib = __webpack_require__(84976);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/types/index.ts
var types = __webpack_require__(24770);
;// CONCATENATED MODULE: ./packages/web3-shared/evm/src/libs/RequestID.ts


class RequestID {
    url;
    requestArguments;
    /**
     * @deprecated Don't new RequestID()
     * Use RequestID.from(requestArguments) stead.
     */ constructor(url, requestArguments){
        this.url = url;
        this.requestArguments = requestArguments;
    }
    get ID() {
        const { method, params } = this.requestArguments;
        switch(method){
            case types/* EthereumMethodType */.W8.ETH_GET_CODE:
                {
                    const [address, tag = 'latest'] = params;
                    return (0,lib.sha3)([
                        this.url,
                        method,
                        address,
                        tag
                    ].join(','));
                }
            case types/* EthereumMethodType */.W8.ETH_BLOCK_NUMBER:
                {
                    return (0,lib.sha3)([
                        this.url,
                        method
                    ].join(','));
                }
            case types/* EthereumMethodType */.W8.ETH_GET_BLOCK_BY_NUMBER:
                {
                    const [number, full] = params;
                    return (0,lib.sha3)([
                        this.url,
                        method,
                        number,
                        full
                    ].join(','));
                }
            case types/* EthereumMethodType */.W8.ETH_GET_BLOCK_BY_HASH:
                {
                    const [hash] = params;
                    return (0,lib.sha3)([
                        this.url,
                        method,
                        hash
                    ].join(','));
                }
            case types/* EthereumMethodType */.W8.ETH_GAS_PRICE:
                {
                    return (0,lib.sha3)([
                        this.url,
                        method
                    ].join(','));
                }
            case types/* EthereumMethodType */.W8.ETH_GET_BALANCE:
                {
                    const [account, tag = 'latest'] = params;
                    return (0,lib.sha3)([
                        this.url,
                        method,
                        account,
                        tag
                    ].join(','));
                }
            case types/* EthereumMethodType */.W8.ETH_GET_TRANSACTION_COUNT:
                {
                    const [account, tag = 'latest'] = params;
                    return (0,lib.sha3)([
                        this.url,
                        method,
                        account,
                        tag
                    ].join(','));
                }
            case types/* EthereumMethodType */.W8.ETH_CALL:
                {
                    const [config, tag = 'latest'] = params;
                    return (0,lib.sha3)([
                        this.url,
                        method,
                        JSON.stringify(config),
                        tag
                    ].join(','));
                }
            case types/* EthereumMethodType */.W8.ETH_ESTIMATE_GAS:
                {
                    const [config, tag = 'latest'] = params;
                    return (0,lib.sha3)([
                        this.url,
                        method,
                        JSON.stringify(config),
                        tag
                    ].join(','));
                }
            case types/* EthereumMethodType */.W8.ETH_GET_TRANSACTION_RECEIPT:
                {
                    const [hash] = params;
                    return (0,lib.sha3)([
                        this.url,
                        method,
                        hash
                    ].join(','));
                }
            case types/* EthereumMethodType */.W8.ETH_GET_TRANSACTION_BY_HASH:
                const [hash] = params;
                return (0,lib.sha3)([
                    this.url,
                    method,
                    hash
                ].join(','));
            default:
                return;
        }
    }
    static from(url, requestArguments) {
        return new RequestID(url, requestArguments);
    }
    static fromPayload(url, payload) {
        return new RequestID(url, {
            method: payload.method,
            params: payload.params ?? []
        });
    }
}

// EXTERNAL MODULE: ./packages/web3-providers/src/helpers/fetchJSON.ts
var fetchJSON = __webpack_require__(11834);
;// CONCATENATED MODULE: ./packages/web3-providers/src/helpers/fetchJsonRpcResponse.ts


async function resolveRequestKey(request) {
    try {
        const body = await request.json();
        return RequestID.fromPayload(request.url, body).ID ?? '';
    } catch  {
        return '';
    }
}
async function fetchJsonRpcResponse(url, payload, init) {
    return (0,fetchJSON/* fetchSquashedJSON */.Vn)(url, {
        ...init,
        method: 'POST',
        headers: init?.headers ?? {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
    }, {
        resolver: resolveRequestKey
    });
}


/***/ }),

/***/ 64883:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   O8: () => (/* binding */ fetchSquashed),
/* harmony export */   XP: () => (/* binding */ Expiration),
/* harmony export */   ob: () => (/* binding */ stableSquashedCached)
/* harmony export */ });
const { fetch: originalFetch } = globalThis;
var Expiration;
(function(Expiration) {
    Expiration[Expiration["ONE_SECOND"] = 1000] = "ONE_SECOND";
    Expiration[Expiration["ONE_MINUTE"] = 60000] = "ONE_MINUTE";
    Expiration[Expiration["THIRTY_MINUTES"] = 1800000] = "THIRTY_MINUTES";
    Expiration[Expiration["ONE_HOUR"] = 3600000] = "ONE_HOUR";
})(Expiration || (Expiration = {}));
const CACHE = new Map();
function __fetch__(key, expiration, request, init, next = originalFetch) {
    const hit = CACHE.get(key);
    try {
        if (hit && hit.timestamp + expiration > Date.now()) return hit.response.then((x)=>x.clone());
    } catch  {
        CACHE.delete(key);
    }
    const responsePromise = next(request, init);
    // setup cache for merging subsequent requests
    if (key) {
        CACHE.set(key, {
            timestamp: Date.now(),
            response: responsePromise
        });
    }
    return responsePromise.then((x)=>x.clone());
}
async function defaultResolver(request) {
    return `${request.method} ${request.url} ${request.method === 'POST' ? await request.text() : 'NULL'}`;
}
async function stableSquashedCached(info, init, resolver = defaultResolver) {
    const request = new Request(info, init);
    // skip not cacheable requests
    if (request.method !== 'GET' && request.method !== 'POST') return;
    // skip all non-http requests
    const url = request.url;
    if (!url.startsWith('http')) return;
    const key = await resolver(request);
    if (!key) return;
    CACHE.delete(key);
}
async function fetchSquashed(input, init, next = originalFetch, resolver = defaultResolver, expiration = Expiration.ONE_SECOND) {
    // why: the caches doesn't define in test env
    if (false) {}
    const request = new Request(input, init);
    // skip not cacheable requests
    if (request.method !== 'GET' && request.method !== 'POST') return next(request, init);
    // skip all non-http requests
    const url = request.url;
    if (!url.startsWith('http')) return next(request, init);
    const key = await resolver(request);
    return __fetch__(key, expiration, request, init, next);
}


/***/ }),

/***/ 85944:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   i: () => (/* binding */ getAllMaskDappContractInfo)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(49603);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33026);
/* harmony import */ var _masknet_icons__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8311);



function getAllMaskDappContractInfo(chainId, type) {
    const HAPPY_RED_PACKET_ADDRESS_V1 = (0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .getRedPacketConstant */ .z8)(chainId, 'HAPPY_RED_PACKET_ADDRESS_V1');
    const HAPPY_RED_PACKET_ADDRESS_V2 = (0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .getRedPacketConstant */ .z8)(chainId, 'HAPPY_RED_PACKET_ADDRESS_V2');
    const HAPPY_RED_PACKET_ADDRESS_V3 = (0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .getRedPacketConstant */ .z8)(chainId, 'HAPPY_RED_PACKET_ADDRESS_V3');
    const HAPPY_RED_PACKET_ADDRESS_V4 = (0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .getRedPacketConstant */ .z8)(chainId, 'HAPPY_RED_PACKET_ADDRESS_V4');
    const MASK_BOX_CONTRACT_ADDRESS = (0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .getMaskBoxConstant */ .yj)(chainId, 'MASK_BOX_CONTRACT_ADDRESS');
    const RED_PACKET_NFT_ADDRESS = (0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .getNftRedPacketConstant */ .IJ)(chainId, 'RED_PACKET_NFT_ADDRESS');
    return type === 'token' ? [
        {
            address: HAPPY_RED_PACKET_ADDRESS_V1,
            name: 'Lucky Drop V1',
            logo: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_masknet_icons__WEBPACK_IMPORTED_MODULE_2__.RedPacket, {})
        },
        {
            address: HAPPY_RED_PACKET_ADDRESS_V2,
            name: 'Lucky Drop V2',
            logo: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_masknet_icons__WEBPACK_IMPORTED_MODULE_2__.RedPacket, {})
        },
        {
            address: HAPPY_RED_PACKET_ADDRESS_V3,
            name: 'Lucky Drop V3',
            logo: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_masknet_icons__WEBPACK_IMPORTED_MODULE_2__.RedPacket, {})
        },
        {
            address: HAPPY_RED_PACKET_ADDRESS_V4,
            name: 'Lucky Drop V4',
            logo: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_masknet_icons__WEBPACK_IMPORTED_MODULE_2__.RedPacket, {})
        }
    ] : [
        {
            address: MASK_BOX_CONTRACT_ADDRESS,
            name: 'Mask Box',
            logo: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_masknet_icons__WEBPACK_IMPORTED_MODULE_2__.MaskBox, {})
        },
        {
            address: RED_PACKET_NFT_ADDRESS,
            name: 'NFT Lucky Drop',
            logo: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_masknet_icons__WEBPACK_IMPORTED_MODULE_2__.RedPacket, {})
        }
    ];
}


/***/ }),

/***/ 28289:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   q: () => (/* binding */ getAssetFullName)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(65327);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40346);

function getAssetFullName(contract_address, contractName, name, tokenId) {
    if (!name) return tokenId && contractName ? `${contractName} #${tokenId}` : !contractName && tokenId ? `#${tokenId}` : contractName;
    if ((0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .isENSContractAddress */ .o2)(contract_address)) return `ENS #${name}`;
    if ((0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .isLens */ .s)(name)) return name;
    const [first, next] = name.split('#').map((x)=>x.trim());
    if (first && next) return `${first} #${next}`;
    if (!first && next) return contractName ? `${contractName} #${next}` : `#${next}`;
    if (contractName && tokenId) return contractName.toLowerCase() === first.toLowerCase() ? `${contractName} #${tokenId}` : `${contractName} #${first}`;
    if (!contractName && !tokenId) return first;
    if (!contractName && tokenId) return `${first} #${tokenId}`;
    return `${contractName} #${first}`;
}


/***/ }),

/***/ 95794:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   l: () => (/* binding */ getContractSymbol)
/* harmony export */ });
/* harmony import */ var _Web3_EVM_apis_ContractReadonlyAPI_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61871);

async function getContractSymbol(chainId, address) {
    try {
        const symbol = await new _Web3_EVM_apis_ContractReadonlyAPI_js__WEBPACK_IMPORTED_MODULE_0__/* .ContractReadonlyAPI */ .M().getERC721Contract(address, {
            chainId
        })?.methods.symbol().call({});
        return symbol ?? '';
    } catch  {
        return '';
    }
}


/***/ }),

/***/ 89178:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   s: () => (/* binding */ getNativeAssets)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(65327);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3187);
/* harmony import */ var _Web3_EVM_apis_Web3StateAPI_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(39850);


function getNativeAssets() {
    const networks = _Web3_EVM_apis_Web3StateAPI_js__WEBPACK_IMPORTED_MODULE_0__.Web3StateRef.value.Network?.networks?.getCurrentValue();
    if (networks) return networks.map((x)=>({
            ...x.nativeCurrency,
            address: (0,_masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .getNativeTokenAddress */ .rG)(x.chainId),
            balance: '0'
        }));
    return _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_2__/* .CHAIN_DESCRIPTORS */ .Q_.filter((x)=>x.network === 'mainnet').map((x)=>({
            ...x.nativeCurrency,
            balance: '0'
        }));
}


/***/ }),

/***/ 72358:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   l: () => (/* binding */ getNextFetchers)
/* harmony export */ });
/* harmony import */ var _fetchSquashed_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(64883);
/* harmony import */ var _fetchCached_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(22674);


/** Assigns 0 to disable squash. */ /** Assigns 0 to disable cache */ /** Generates an unequal request key. Requests that share the same key will be squashed into a single one. */ function getNextFetchers({ squashExpiration = 0, cacheDuration = 0, resolver } = {}) {
    const fetchers = [];
    if (squashExpiration > 0) fetchers.push((...args)=>(0,_fetchSquashed_js__WEBPACK_IMPORTED_MODULE_0__/* .fetchSquashed */ .O8)(...args, resolver, squashExpiration));
    if (cacheDuration > 0) fetchers.push((...args)=>(0,_fetchCached_js__WEBPACK_IMPORTED_MODULE_1__/* .fetchCached */ .Op)(...args, cacheDuration));
    return fetchers;
}


/***/ }),

/***/ 34936:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   W: () => (/* binding */ getPaymentToken)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46854);
/* harmony import */ var _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3187);
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(74765);


/* cspell:disable-next-line */ const tokens = [
    _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .APE */ .Dn,
    _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDC */ .gn,
    _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .USDT */ .AA,
    _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .DAI */ .h1,
    _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .HUSD */ .ik,
    _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .BUSD */ .lz,
    _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WBTC */ .ML,
    _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .WNATIVE */ .FX,
    _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .TATR */ .eJ,
    _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_0__/* .RARI */ .YX
];
function getPaymentToken(chainId, token) {
    if (!token) return;
    return [
        _masknet_web3_shared_evm__WEBPACK_IMPORTED_MODULE_1__/* .CHAIN_DESCRIPTORS */ .Q_.find((x)=>x.chainId === chainId)?.nativeCurrency,
        ...tokens.map((x)=>x[chainId])
    ].find((x)=>x?.name.toLowerCase() === token.name?.toLowerCase() || x?.symbol.toLowerCase() === token.symbol?.toLowerCase() || (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .isSameAddress */ .W)(x?.address, token.address));
}


/***/ }),

/***/ 73389:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   R: () => (/* binding */ parseJSON)
/* harmony export */ });
function parseJSON(json) {
    if (!json) return;
    try {
        return JSON.parse(json);
    } catch  {
        return;
    }
}


/***/ }),

/***/ 15219:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   G: () => (/* binding */ resolveActivityType)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62649);

function resolveActivityType(type) {
    if (!type) return _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_0__/* .ActivityType */ .T8.Transfer;
    const type_ = type.toLowerCase();
    if ([
        'created',
        'mint'
    ].includes(type_)) return _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_0__/* .ActivityType */ .T8.Mint;
    if ([
        'successful'
    ].includes(type_)) return _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_0__/* .ActivityType */ .T8.Sale;
    if ([
        'offer',
        'offer_entered',
        'bid_withdrawn',
        'bid_entered'
    ].includes(type_)) return _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_0__/* .ActivityType */ .T8.Offer;
    if ([
        'cancel_offer'
    ].includes(type_)) return _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_0__/* .ActivityType */ .T8.CancelOffer;
    if ([
        'list'
    ].includes(type_)) return _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_0__/* .ActivityType */ .T8.List;
    if ([
        'sale'
    ].includes(type_)) return _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_0__/* .ActivityType */ .T8.Sale;
    return _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_0__/* .ActivityType */ .T8.Transfer;
}


/***/ }),

/***/ 83838:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RSS3BaseAPI: () => (/* binding */ RSS3BaseAPI)
/* harmony export */ });
/**
 * Conform to the RFC3339 Datetime format.
 * @example "2022-08-23T07:15:00Z"
 */ /** URL */ /**
 * 2023-01-31 03:32:59 +0000 GMT
 */ var RSS3BaseAPI; /**
         * The identifier of the transaction. A unique identifier will be returned when a transaction hash is not available
         */  /**
         * The on-chain log index.
         */  /**
         * The transaction initiator.
         */  /**
         * The transaction recipient.
         */  /**
         * The owner of this note in a bidirectional feed.
         */  /**
         * The fees paid for the transaction.
         */  /**
         * There are many platforms supported by PreGod, see the full list. When platform is unknown, the transaction's network is used.
         * TODO declare a platform map
         */  /**
         *An array of actions generated by the transaction.
         */  /** For feed cards */ 
(function(RSS3BaseAPI) {
    let // contractAddress-id or admin_address
    // TODO remove
    /** Only exists for collectible tag */ /** URL */ /** Numberish string */ /**
         * UI value
         * value_display is the value formatted with the correct number of decimals
         * */ /**
         * @example "Uniswap V2"
         */ // Uniswap like actions: add, collect, remove
    // Aave like actions: supply, withdraw, borrow, repay
    /**
         * @example "Uniswap V2"
         */ /**
     * `bridge` indicates an action of bridging assets from blockchain A to blockchain B.
     * action `deposit` refers to depositing tokens into blockchain A's bridge
     * action `withdraw` refers to withdrawing tokens from blockchain B's bridge
     */ /** URL */ /** URL */ /** NFT or Token symbol */ /** approve amount */ /** TODO */ /** Not all platforms provide summary */ /** URL or IPFS */ /** @example 'vitalik.eth' */ /** @example 'vitalik.eth' */ /** unknown type, it could possibly be profile avatar url */ // TODO No official documentation
    // here we have the donation value in detail
    /** option index, start from 1, could be multiple in format like `[1, 2, 3]` */ /** It's different from transaction.address_from, the token payer */ /** It's different from transaction.address_from, the token receiver */ // Discard
    // | 'ethereum_classic'
    // Ignore this, since it's now supported runtime network
    // | 'arweave'
    Tag;
    (function(Tag) {
        Tag["Collectible"] = 'collectible';
        Tag["Donation"] = 'donation';
        Tag["Exchange"] = 'exchange';
        Tag["Governance"] = 'governance';
        Tag["Social"] = 'social';
        Tag["Transaction"] = 'transaction';
    })(Tag = RSS3BaseAPI.Tag || (RSS3BaseAPI.Tag = {}));
    let Type;
    (function(Type) {
        Type["Approval"] = 'approval';
        Type["Transfer"] = 'transfer';
        Type["Mint"] = 'mint';
        Type["Burn"] = 'burn';
        Type["Withdraw"] = 'withdraw';
        Type["Deposit"] = 'deposit';
        Type["Swap"] = 'swap';
        Type["Liquidity"] = 'liquidity';
        Type["Bridge"] = 'bridge';
        Type["Trade"] = 'trade';
        Type["Poap"] = 'poap';
        Type["Post"] = 'post';
        Type["Revise"] = 'revise';
        Type["Comment"] = 'comment';
        Type["Share"] = 'share';
        Type["Proxy"] = 'proxy';
        Type["Profile"] = 'profile';
        Type["Follow"] = 'follow';
        Type["Unfollow"] = 'unfollow';
        Type["Like"] = 'like';
        Type["Propose"] = 'propose';
        Type["Vote"] = 'vote';
        Type["Launch"] = 'launch';
        Type["Donate"] = 'donate';
        Type["Staking"] = 'staking';
        Type["Edit"] = 'edit';
    })(Type = RSS3BaseAPI.Type || (RSS3BaseAPI.Type = {}));
    let AssetType;
    (function(AssetType) {
        AssetType["GitcoinDonation"] = 'Gitcoin-Donation';
        AssetType["POAP"] = "POAP";
        AssetType["NFT"] = "NFT";
    })(AssetType = RSS3BaseAPI.AssetType || (RSS3BaseAPI.AssetType = {}));
})(RSS3BaseAPI || (RSS3BaseAPI = {}));


/***/ }),

/***/ 40838:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ SimpleHash)
/* harmony export */ });
var SimpleHash;
(function(SimpleHash) {
    let // TODO: Contract address will be added in SimpleHash v1 release.
    // TODO: Asking SimpleHash to add schema in SimpleHash v1 release.
    // TODO: the collection id key name may change in SimpleHash v1 release.
    /**
         * The score is a numeric value from 0 to 100, with 0 being deemed not spam, and 100 being deemed likely spam.
         * null means undetermined
         */ /** e.g ["ethereum.0x18487d2cac946c7fe800855c4039aac210f68baa"] */ /** twitter handler */ // ethereum
    // EOA
    // ERC721
    // "2022-04-04T20:15:02"
    // ethereum.0x18487d2cac946c7fe800855c4039aac210f68baa.1597
    // tx hash
    // "2022-04-04T20:15:02"
    // e.g. ethereum.native
    ActivityType;
    (function(ActivityType) {
        ActivityType["Transfer"] = 'transfer';
        ActivityType["Mint"] = 'mint';
        ActivityType["Sale"] = 'sale';
        ActivityType["Burn"] = 'burn';
    })(ActivityType = SimpleHash.ActivityType || (SimpleHash.ActivityType = {}));
})(SimpleHash || (SimpleHash = {}));


/***/ }),

/***/ 68419:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   J: () => (/* binding */ TwitterBaseAPI)
/* harmony export */ });
/* cspell:disable */ var TwitterBaseAPI; /* cspell:disable-next-line */  /** Only web API provides */  /** ISODateTime */  /** unused data, declare details when you need */  /** unused data, declare details when you need */  /** t.co url */  // If user doesn't exist, instead of 404 response, user field will miss
 /** post id */  // e.g., Thu Aug 04 06:28:33 +0000 2011
 // e.g., 'Tue Sep 19 08:19:39 +0000 2023'
 // handle
(function(TwitterBaseAPI) {
    let /** @example 42 */ /** t.co url */ /** bio */ /** @example Mon May 15 06:29:53 +0000 2017 */ /** @example Mon May 15 06:29:53 +0000 2017 */ /* cspell:disable-next-line */ /** Error constructor */ Scale;
    (function(Scale) {
        Scale["X_Small"] = 'xSmall';
        Scale["Small"] = 'small';
        Scale["Normal"] = 'normal';
        Scale["Large"] = 'large';
        Scale["X_Large"] = 'xLarge';
    })(Scale = TwitterBaseAPI.Scale || (TwitterBaseAPI.Scale = {}));
    let ThemeMode;
    (function(ThemeMode) {
        ThemeMode["Dark"] = 'darker';
        ThemeMode["Dim"] = 'dark';
        ThemeMode["Light"] = 'light';
    })(ThemeMode = TwitterBaseAPI.ThemeMode || (TwitterBaseAPI.ThemeMode = {}));
    let ThemeColor;
    (function(ThemeColor) {
        ThemeColor["Blue"] = 'blue500';
        ThemeColor["Yellow"] = 'yellow500';
        ThemeColor["Purple"] = 'purple500';
        ThemeColor["Magenta"] = 'magenta500';
        ThemeColor["Orange"] = 'orange500';
        ThemeColor["Green"] = 'green500';
    })(ThemeColor = TwitterBaseAPI.ThemeColor || (TwitterBaseAPI.ThemeColor = {}));
})(TwitterBaseAPI || (TwitterBaseAPI = {}));


/***/ }),

/***/ 92358:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ attemptUntil),
/* harmony export */   K: () => (/* binding */ createPredicate)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81770);

function createPredicate(candidates) {
    return (candidate)=>!!candidate && candidates.includes(candidate);
}
async function attemptUntil(funcs, fallback, predicator = lodash_es__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z) {
    const errors = [];
    for (const func of funcs){
        try {
            const result = await func();
            if (predicator?.(result)) {
                continue;
            }
            return result ?? fallback;
        } catch (error) {
            errors.push(error);
            continue;
        }
    }
    if (errors.length) throw new AggregateError(errors, 'At least one of the attempts fails.');
    return fallback;
}


/***/ }),

/***/ 22563:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   H$: () => (/* binding */ transformAllHook),
/* harmony export */   YV: () => (/* binding */ transformAll),
/* harmony export */   __: () => (/* binding */ transformHook),
/* harmony export */   rm: () => (/* binding */ transformFromJSON),
/* harmony export */   t: () => (/* binding */ transformAllFromJSON),
/* harmony export */   vs: () => (/* binding */ transform)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78996);

function replaceAll(input, values) {
    if (!input.includes('${')) return input;
    return input.replaceAll(/\${([^}]+)}/g, (match, p1)=>values[p1] ?? match);
}
function transformAll(chainIdEnum, constants, environment = {}) {
    return (chainId = 1)=>{
        const chainName = chainIdEnum[chainId];
        // unknown chain id
        if (!chainName) return {};
        const entries = Object.keys(constants).map((name)=>{
            let value = constants[name][chainName];
            if (Array.isArray(value)) {
                value = value.map((item)=>{
                    if (typeof item === 'string') {
                        return replaceAll(item, environment);
                    }
                    return item;
                });
            } else if (typeof value === 'string') {
                value = replaceAll(value, environment);
            }
            return [
                name,
                value
            ];
        });
        return Object.fromEntries(entries);
    };
}
function transform(chainIdEnum, constants, environment = {}) {
    const getAllConstants = transformAll(chainIdEnum, constants, environment);
    return (chainId, key, fallback)=>getAllConstants(chainId)[key] ?? fallback;
}
function transformAllFromJSON(chainIdEnum, json, fallbackConstants, environment = {}) {
    if (!json) return transformAll(chainIdEnum, fallbackConstants, environment);
    try {
        const constants = JSON.parse(json);
        return transformAll(chainIdEnum, constants, environment);
    } catch  {
        return transformAll(chainIdEnum, fallbackConstants, environment);
    }
}
function transformFromJSON(chainIdEnum, json, fallbackConstants, environment = {}) {
    if (!json) return transform(chainIdEnum, fallbackConstants, environment);
    try {
        const constants = JSON.parse(json);
        return transform(chainIdEnum, constants, environment);
    } catch  {
        return transform(chainIdEnum, fallbackConstants, environment);
    }
}
function transformAllHook(getConstants) {
    return function useConstants(chainId = 1) {
        return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>getConstants(chainId), [
            chainId
        ]);
    };
}
function transformHook(getConstant) {
    return function useConstant(chainId = 1, key, fallback) {
        return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{
            if (!key) return fallback;
            return getConstant(chainId)[key] ?? fallback;
        }, [
            chainId
        ]);
    };
}


/***/ }),

/***/ 95325:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ formatBalance)
/* harmony export */ });
/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10149);
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29763);


function formatBalance(rawValue = '0', decimals = 0, significant = decimals, isPrecise = false, isFixed = false, fixedDecimals = 4, hasSeparators = true) {
    let balance = new bignumber_js__WEBPACK_IMPORTED_MODULE_0__/* .BigNumber */ .O(rawValue);
    if (!balance.isInteger()) {
        const message = `Expected an integer but got ${balance.toFixed()}`;
        if (false) {} else {
            console.error(message);
        }
    }
    balance = balance.integerValue();
    if (isFixed) {
        const value = (0,_number_js__WEBPACK_IMPORTED_MODULE_1__/* .leftShift */ .w5)(balance, decimals);
        const minimum = (0,_number_js__WEBPACK_IMPORTED_MODULE_1__/* .scale10 */ .SI)(1, -fixedDecimals);
        if (value.eq(0)) return '0';
        if ((0,_number_js__WEBPACK_IMPORTED_MODULE_1__/* .isLessThan */ .FI)(value, minimum)) return '<' + minimum.toFixed();
        const result = (0,_number_js__WEBPACK_IMPORTED_MODULE_1__/* .trimZero */ .vr)(value.toFixed(fixedDecimals));
        return hasSeparators ? (0,_number_js__WEBPACK_IMPORTED_MODULE_1__/* .addThousandSeparators */ .OI)(result) : result;
    }
    const base = (0,_number_js__WEBPACK_IMPORTED_MODULE_1__/* .pow10 */ .wA)(decimals);
    // 10n ** decimals
    if (balance.div(base).lt((0,_number_js__WEBPACK_IMPORTED_MODULE_1__/* .pow10 */ .wA)(-8)) && balance.isGreaterThan(0) && !isPrecise) return '<0.000001';
    const negative = balance.isNegative();
    // balance < 0n
    if (negative) balance = balance.absoluteValue();
    // balance * -1n
    let fraction = balance.modulo(base).toString(10);
    // (balance % base).toString(10)
    // add leading zeros
    fraction = fraction.padStart(decimals, '0');
    // keep up to 6 decimal places
    fraction = fraction.slice(0, balance.div(base).gt((0,_number_js__WEBPACK_IMPORTED_MODULE_1__/* .pow10 */ .wA)(-6)) ? 6 : 8);
    // match significant digits
    const matchSignificantDigits = new RegExp(`^0*[1-9]\\d{0,${significant > 0 ? significant - 1 : 0}}`);
    fraction = fraction.match(matchSignificantDigits)?.[0] ?? '';
    // trim tailing zeros
    fraction = fraction.replaceAll(/0+$/g, '');
    const whole = balance.dividedToIntegerBy(base).toString(10);
    // (balance / base).toString(10)
    const value = `${whole}${fraction === '' ? '' : `.${fraction}`}`;
    const raw = negative ? `-${value}` : value;
    const result = raw.includes('.') ? raw.replace(/0+$/, '').replace(/\.$/, '') : raw;
    return hasSeparators ? (0,_number_js__WEBPACK_IMPORTED_MODULE_1__/* .addThousandSeparators */ .OI)(result) : result;
}


/***/ }),

/***/ 84847:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   r: () => (/* binding */ formatPercentage)
/* harmony export */ });
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29763);

function formatPercentage(value) {
    const percentage = (0,_number_js__WEBPACK_IMPORTED_MODULE_0__/* .multipliedBy */ .$q)(value, 100).toFixed(2).replace(/\.?0+$/, '');
    return `${percentage}%`;
}


/***/ }),

/***/ 74765:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D: () => (/* binding */ currySameAddress),
/* harmony export */   W: () => (/* binding */ isSameAddress)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(72845);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(405);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17541);

function isSameAddress(address, otherAddress) {
    if (!address || !otherAddress) return false;
    return address.toLowerCase() === otherAddress.toLowerCase();
}
function currySameAddress(addresses = []) {
    addresses = (0,lodash_es__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)((0,lodash_es__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)((0,lodash_es__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(addresses))).map((address)=>address.toLowerCase());
    return (target)=>{
        if (addresses.length === 0 || !target) return false;
        if (typeof target === 'string') {
            return addresses.includes(target.toLowerCase());
        } else if (typeof target === 'object' && typeof target.address === 'string') {
            return addresses.includes(target.address.toLowerCase());
        }
        throw new Error('Unsupported `target` address format');
    };
}


/***/ }),

/***/ 76423:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   U: () => (/* binding */ isSameURL)
/* harmony export */ });
function isSameURL(a, b) {
    if (!a || !b) return false;
    // If either URL is invalid, return false
    if (typeof a === 'string' && !URL.canParse(a)) return false;
    if (typeof b === 'string' && !URL.canParse(b)) return false;
    // Parse the input URLs if they are strings
    const urlA = typeof a === 'string' ? new URL(a) : a;
    const urlB = typeof b === 'string' ? new URL(b) : b;
    // Compare the important parts of the URLs
    if (urlA.protocol !== urlB.protocol || urlA.hostname !== urlB.hostname || urlA.pathname !== urlB.pathname) {
        return false;
    }
    // Compare the search parameters in a case-insensitive way
    const paramsA = new URLSearchParams(urlA.search);
    const paramsB = new URLSearchParams(urlB.search);
    // Compare the search parameters, allowing different sequence but same values
    for (const [paramA, valueA] of paramsA.entries()){
        const valueB = paramsB.get(paramA);
        if (valueA !== valueB) {
            return false;
        }
    }
    // Check if all the parameters in B are also in A
    for (const [paramB] of paramsB.entries()){
        if (!paramsA.has(paramB)) {
            return false;
        }
    }
    return true;
}


/***/ }),

/***/ 77199:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BD: () => (/* binding */ createNonFungibleTokenMetadata),
/* harmony export */   GN: () => (/* binding */ createNonFungibleTokenCollection),
/* harmony export */   RV: () => (/* binding */ createNonFungibleToken),
/* harmony export */   Xi: () => (/* binding */ createNonFungibleTokenContract),
/* harmony export */   iI: () => (/* binding */ createFungibleTokensFromConstants),
/* harmony export */   mn: () => (/* binding */ createFungibleToken)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(86147);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4474);
/* harmony import */ var _specs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62649);


function createFungibleToken(chainId, schema, address, name, symbol, decimals, logoURL) {
    return {
        chainId,
        type: _specs_index_js__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .iv.Fungible,
        schema,
        id: address,
        address,
        name,
        symbol,
        decimals,
        logoURL
    };
}
function createNonFungibleTokenMetadata(chainId, name, tokenId, symbol, description, mediaType, mediaURL, imageURL) {
    return {
        chainId,
        name,
        tokenId,
        symbol,
        description,
        mediaURL,
        mediaType,
        imageURL
    };
}
function createNonFungibleTokenContract(chainId, schema, address, name, symbol) {
    return {
        chainId,
        schema,
        name,
        symbol,
        address
    };
}
function createNonFungibleTokenCollection(chainId, address, name, slug, description, iconURL, verified, createdAt) {
    return {
        id: address,
        chainId,
        name,
        slug,
        description,
        iconURL,
        verified,
        createdAt
    };
}
function createNonFungibleToken(chainId, address, schema, tokenId, ownerId, metadata, contract, collection) {
    return {
        chainId,
        id: address,
        type: _specs_index_js__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .iv.NonFungible,
        schema,
        address,
        tokenId,
        ownerId,
        metadata,
        contract,
        collection
    };
}
function createFungibleTokensFromConstants(chainIds, schema, constants) {
    return (key, name, symbol, decimals)=>{
        const chainIdGroup = (0,lodash_es__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(chainIds, 'value');
        return (0,lodash_es__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(chainIdGroup, ({ key: chainName, value: chainId })=>{
            function evaluator(f) {
                return typeof f === 'function' ? f(chainId) : f;
            }
            return createFungibleToken(chainId, schema, constants[key][chainName] ?? '', evaluator(name), evaluator(symbol), evaluator(decimals));
        });
    };
}


/***/ }),

/***/ 3187:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Q_: () => (/* binding */ CHAIN_DESCRIPTORS),
  qQ: () => (/* binding */ NETWORK_DESCRIPTORS),
  zM: () => (/* binding */ PROVIDER_DESCRIPTORS)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/difference.js
var difference = __webpack_require__(12313);
// EXTERNAL MODULE: ./packages/flags/src/index.ts
var src = __webpack_require__(51573);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/specs/index.ts
var specs = __webpack_require__(62649);
// EXTERNAL MODULE: ./packages/shared-base/src/types/PluginID.ts
var PluginID = __webpack_require__(24835);
// EXTERNAL MODULE: ./packages/shared-base/src/Site/index.ts
var Site = __webpack_require__(68422);
// EXTERNAL MODULE: ./packages/shared-base/src/Site/types.ts
var types = __webpack_require__(77953);
// EXTERNAL MODULE: ./packages/shared-base/src/Sniffings/index.ts
var Sniffings = __webpack_require__(66584);
;// CONCATENATED MODULE: ./packages/web3-shared/evm/src/constants/chains.json
const chains_namespaceObject = JSON.parse('[{"chainId":1,"type":"Ethereum","name":"ETH","color":"rgb(28, 104, 243)","network":"mainnet","fullName":"Ethereum","shortName":"eth","features":["EIP1559"],"nativeCurrency":{"chainId":1,"name":"Ether","symbol":"ETH","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/ethereum/info/logo.png/quality=85"},"infoURL":"https://ethereum.org","explorers":[{"name":"etherscan","url":"https://etherscan.io","standard":"EIP3091"}]},{"chainId":3,"type":"Ethereum","name":"Ropsten","color":"rgb(255, 65, 130)","network":"ropsten","fullName":"Ropsten Test Network","shortName":"rop","features":["EIP1559"],"nativeCurrency":{"chainId":3,"name":"Ropsten Ether","symbol":"ETH","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/ethereum/info/logo.png/quality=85"},"infoURL":"https://github.com/ethereum/ropsten","explorers":[{"name":"etherscan","url":"https://ropsten.etherscan.io","standard":"EIP3091"}]},{"chainId":4,"type":"Ethereum","name":"Rinkeby","color":"rgb(133, 89, 255)","network":"rinkeby","fullName":"Rinkeby","shortName":"rin","features":[],"nativeCurrency":{"chainId":4,"name":"Rinkeby Ether","symbol":"ETH","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/ethereum/info/logo.png/quality=85"},"infoURL":"https://www.rinkeby.io","explorers":[{"name":"etherscan","url":"https://rinkeby.etherscan.io","standard":"EIP3091"}]},{"chainId":5,"type":"Ethereum","name":"Görli","color":"rgb(48, 153, 242)","network":"goerli","fullName":"Görli","shortName":"gor","features":[],"nativeCurrency":{"chainId":5,"name":"Görli Ether","symbol":"ETH","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/ethereum/info/logo.png/quality=85"},"infoURL":"https://goerli.net/#about","explorers":[{"name":"etherscan","url":"https://goerli.etherscan.io","standard":"EIP3091"}]},{"chainId":42,"type":"Ethereum","name":"Kovan","color":"rgb(133, 89,255)","network":"kovan","fullName":"Kovan","shortName":"kov","features":[],"nativeCurrency":{"chainId":42,"name":"Kovan Ether","symbol":"ETH","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/ethereum/info/logo.png/quality=85"},"infoURL":"https://kovan-testnet.github.io/website","explorers":[{"name":"etherscan","url":"https://kovan.etherscan.io","standard":"EIP3091"}]},{"chainId":8453,"type":"Base","name":"Base","color":"rgb(0, 82, 255)","network":"mainnet","fullName":"Base Mainnet","shortName":"base","features":[],"nativeCurrency":{"chainId":8453,"name":"Ether","symbol":"ETH","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/ethereum/info/logo.png/quality=85"},"infoURL":"https://base.org/","explorers":[{"name":"basescan","url":"https://basescan.org","standard":"EIP3091"}]},{"chainId":84531,"type":"Base","name":"Base Goerli","color":"rgb(0, 82, 255)","network":"testnet","fullName":"Base Goerli","shortName":"base","features":[],"nativeCurrency":{"chainId":84531,"name":"Ether","symbol":"ETH","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/ethereum/info/logo.png/quality=85"},"infoURL":"https://base.org","explorers":[{"name":"basescan","url":"https://goerli.basescan.org","standard":"EIP3091"}]},{"chainId":56,"type":"Binance","name":"BNB","color":"rgb(240, 185, 10)","network":"mainnet","fullName":"Binance Smart Chain Mainnet","shortName":"bnb","features":[],"nativeCurrency":{"chainId":56,"name":"Binance Chain Native Token","symbol":"BNB","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/smartchain/info/logo.png/quality=85"},"infoURL":"https://www.binance.org","explorers":[{"name":"bscscan","url":"https://bscscan.com","standard":"EIP3091"}]},{"chainId":97,"type":"Binance","name":"BNB","color":"rgb(240, 185, 10)","network":"chapel","fullName":"Binance Smart Chain Testnet","shortName":"bnbt","features":[],"nativeCurrency":{"chainId":97,"name":"Binance Chain Native Token","symbol":"tBNB","decimals":18},"infoURL":"https://testnet.binance.org/","explorers":[{"name":"bscscan-testnet","url":"https://testnet.bscscan.com","standard":"EIP3091"}]},{"chainId":137,"type":"Polygon","name":"Polygon","color":"rgb(119, 62, 225)","network":"mainnet","fullName":"Polygon Mainnet","shortName":"matic","features":["EIP1559"],"nativeCurrency":{"chainId":137,"name":"MATIC","symbol":"MATIC","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/polygon/info/logo.png/quality=85"},"infoURL":"https://matic.network/","explorers":[{"name":"matic","url":"https://polygonscan.com","standard":"EIP3091"}]},{"chainId":80001,"type":"Polygon","name":"Polygon","color":"rgb(130, 71, 229)","network":"testnet","fullName":"Polygon","shortName":"maticmum","features":["EIP1559"],"nativeCurrency":{"chainId":80001,"name":"MATIC","symbol":"MATIC","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/polygon/info/logo.png/quality=85"},"infoURL":"https://matic.network/","explorers":[{"name":"matic","url":"https://explorer-mumbai.maticvigil.com","standard":"EIP3091"}]},{"chainId":42161,"type":"Arbitrum","name":"Arbitrum","color":"rgb(36, 150, 238)","network":"mainnet","fullName":"Arbitrum One","shortName":"arb","features":[],"nativeCurrency":{"chainId":42161,"name":"Ether","symbol":"ETH","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/ethereum/info/logo.png/quality=85"},"infoURL":"https://arbitrum.io","explorers":[{"name":"arbitrum","url":"https://arbiscan.io","standard":"EIP3091"}]},{"chainId":421611,"type":"Arbitrum","name":"Arbitrum","color":"rgb(36, 150, 238)","network":"rinkeby","fullName":"Arbitrum Rinkeby","shortName":"arb-rinkeby","features":[],"nativeCurrency":{"chainId":421611,"name":"Arbitrum Rinkeby Ether","symbol":"ETH","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/ethereum/info/logo.png/quality=85"},"infoURL":"https://arbitrum.io","explorers":[{"name":"arbitrum-rinkeby","url":"https://rinkeby-explorer.arbitrum.io","standard":"EIP3091"}]},{"chainId":10,"name":"Optimism","type":"Optimism","network":"mainnet","features":[],"nativeCurrency":{"chainId":10,"name":"Ether","symbol":"ETH","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/ethereum/info/logo.png/quality=85"},"infoURL":"https://optimistic.etherscan.io/","fullName":"Optimism","shortName":"op","explorers":[{"name":"optimisc","url":"https://optimistic.etherscan.io/"}]},{"chainId":69,"name":"Optimism Testnet Kovan","type":"Optimism","network":"testnet","rpc":["https://kovan.optimism.io/"],"fullName":"Optimism Kovan","faucets":[],"features":[],"nativeCurrency":{"chainId":69,"name":"Ether","symbol":"ETH","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/ethereum/info/logo.png/quality=85"},"infoURL":"https://optimism.io","shortName":"kor","explorers":[{"name":"Optimism Kovan","url":"https://optimistic.etherscan.io/"}]},{"chainId":420,"name":"Optimism Goerli Testnet","type":"Optimism","network":"testnet","rpc":["https://goerli.optimism.io/"],"faucets":[],"features":[],"nativeCurrency":{"chainId":420,"name":"Ether","symbol":"ETH","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/ethereum/info/logo.png/quality=85"},"infoURL":"https://optimism.io","shortName":"gor"},{"chainId":100,"type":"xDai","name":"Gnosis","fullName":"Gnosis","color":"rgb(73, 169, 166)","network":"mainnet","shortName":"xDai","features":[],"nativeCurrency":{"chainId":100,"name":"xDAI","symbol":"xDAI","decimals":18},"infoURL":"https://blockscout.com/xdai/mainnet","explorers":[{"name":"Gnosis","url":"https://blockscout.com/xdai/mainnet/"}]},{"chainId":534352,"type":"Scroll","name":"Scroll","network":"mainnet","fullName":"Scroll","shortName":"Scroll","rpc":["https://rpc.scroll.io"],"faucets":[],"features":[],"nativeCurrency":{"chainId":534352,"name":"Ether","symbol":"ETH","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/ethereum/info/logo.png/quality=85"},"infoURL":"https://scrollscan.com/","explorers":[{"name":"blockscout","url":"https://scrollscan.com/","standard":"EIP3091"}]},{"chainId":42220,"type":"Celo","name":"CELO","network":"mainnet","shortName":"CELO","features":[],"nativeCurrency":{"chainId":42220,"name":"CELO","symbol":"CELO","decimals":18,"address":"0x471ece3750da237f93b8e339c536989b8978a438"},"infoURL":"https://explorer.celo.org/","explorers":[{"name":"Celo","url":"https://celoscan.io/"}]},{"chainId":43114,"type":"Avalanche","name":"Avalanche","color":"rgb(232, 65, 66)","network":"mainnet","shortName":"AVAX","fullName":"Avalanche C-Chain","features":[],"nativeCurrency":{"chainId":43114,"name":"Avalanche","symbol":"AVAX","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/avalanchec/info/logo.png/quality=85"},"infoURL":"https://snowtrace.dev/","explorers":[{"name":"snowtrace","url":"https://snowtrace.dev/","standard":"EIP3091"}]},{"chainId":43113,"type":"Avalanche","name":"AVAX","color":"rgb(232, 65, 66)","network":"testnet","fullName":"Avalanche Fuji Testnet","shortName":"Fuji","features":[],"nativeCurrency":{"chainId":43113,"name":"Avalanche","symbol":"AVAX","decimals":18},"infoURL":"https://cchain.explorer.avax-test.network","explorers":[{"name":"Avalanche","url":"https://testnet.snowtrace.io/"}]},{"chainId":1313161554,"type":"Aurora","name":"Aurora","color":"rgb(112, 212, 74)","network":"mainnet","fullName":"Aurora Mainnet","shortName":"aurora","features":[],"nativeCurrency":{"chainId":1313161554,"name":"Ether","symbol":"ETH","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/ethereum/info/logo.png/quality=85"},"infoURL":"https://aurora.dev","explorers":[{"name":"Blockscout","url":"https://explorer.mainnet.aurora.dev/","standard":"EIP3091"}]},{"chainId":1313161555,"type":"Aurora","name":"Aurora","color":"rgb(112, 212, 74)","network":"testnet","fullName":"Aurora Testnet","shortName":"aurora-testnet","features":[],"nativeCurrency":{"chainId":1313161555,"name":"Ether","symbol":"ETH","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/ethereum/info/logo.png/quality=85"},"infoURL":"https://aurora.dev","explorers":[{"name":"Aurora","url":"https://aurorascan.dev/"}]},{"chainId":1313161556,"type":"Aurora","name":"Aurora","color":"rgb(112, 212, 74)","network":"betanet","fullName":"Aurora Betanet","shortName":"aurora-betanet","features":[],"nativeCurrency":{"chainId":1313161556,"name":"Ether","symbol":"ETH","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/ethereum/info/logo.png/quality=85"},"infoURL":"https://aurora.dev","explorers":[{"name":"Aurora","url":"https://aurorascan.dev/"}]},{"chainId":1030,"type":"Conflux","name":"Conflux","network":"mainnet","fullName":"Conflux eSpace","shortName":"Conflux","features":[],"nativeCurrency":{"chainId":1030,"name":"CFX","symbol":"CFX","decimals":18},"infoURL":"https://evm.confluxscan.net","explorers":[{"name":"Confluxs","url":"https://evm.confluxscan.net/"}]},{"chainId":71,"type":"Conflux","name":"Conflux","network":"testnet","shortName":"Conflux","features":[],"nativeCurrency":{"chainId":71,"name":"CFX","symbol":"CFX","decimals":18},"infoURL":"https://confluxnetwork.org","explorers":[{"name":"Conflux","url":"https://evmtestnet.confluxscan.net/"}]},{"chainId":592,"type":"Astar","name":"Astar","network":"mainnet","fullName":"Astar","shortName":"Astar","rpc":["https://evm.astar.network"],"faucets":[],"features":["EIP1559"],"nativeCurrency":{"chainId":592,"name":"ASTAR","symbol":"ASTR","decimals":18,"logoURL":"https://static.debank.com/image/chain/logo_url/astar/398c7e0014bdada3d818367a7273fabe.png"},"infoURL":"https://blockscout.com/astar/","explorers":[{"name":"blockscout","url":"https://blockscout.com/astar/","standard":"EIP3091"}]},{"chainId":250,"type":"Fantom","name":"Fantom","fullName":"Fantom Opera","network":"mainnet","shortName":"ftm","features":[],"nativeCurrency":{"chainId":250,"name":"Fantom","symbol":"FTM","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/fantom/info/logo.png/quality=85"},"infoURL":"https://fantom.foundation","explorers":[{"name":"ftmscan","url":"https://ftmscan.com","standard":"EIP3091"}]},{"chainId":25,"name":"Cronos","type":"Cronos Mainnet Beta","network":"mainnet","features":[],"nativeCurrency":{"chainId":25,"name":"Cronos","symbol":"CRO","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/cronos/info/logo.png/quality=85"},"infoURL":"https://cronos.org/","shortName":"cro"},{"chainId":50,"name":"XDC Network","type":"XDC Network","network":"mainnet","features":[],"nativeCurrency":{"chainId":50,"name":"XinFin","symbol":"XDC","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/xdc/info/logo.png/quality=85"},"infoURL":"https://xinfin.org/","shortName":"xdc xinfin","explorers":[{"name":"XDC Network","url":"https://xdcscan.io/"}]},{"chainId":52,"name":"CoinEx Smart Chain Mainnet","type":"CoinEx Smart Chain Mainnet","network":"mainnet","features":[],"nativeCurrency":{"chainId":52,"name":"CoinEx Chain Native Token","symbol":"cet","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/xdc/cet/logo.png/quality=85"},"infoURL":"https://www.coinex.org/","shortName":"cet","explorers":[{"name":"CoinEx Smart Chain Mainnet","url":"https://www.coinex.net/"}]},{"chainId":57,"name":"Syscoin Mainnet","type":"Syscoin Mainnet","network":"mainnet","features":[],"nativeCurrency":{"chainId":57,"name":"Syscoin","symbol":"SYS","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/syscoin/info/logo.png/quality=85"},"infoURL":"https://www.syscoin.org","shortName":"sys","explorers":[{"name":"Syscoin Mainnet","url":"https://explorer.syscoin.org/"}]},{"chainId":66,"name":"OKX","type":"OKX","network":"mainnet","features":[],"nativeCurrency":{"chainId":66,"name":"OKT","symbol":"OKT","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/okt/info/logo.png/quality=85"},"infoURL":"https://www.okex.com/okc","shortName":"okt"},{"chainId":82,"name":"Meter Mainnet","type":"Meter Mainnet","network":"mainnet","features":[],"nativeCurrency":{"chainId":82,"name":"Meter","symbol":"MTR","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/meter/info/logo.png/quality=85"},"infoURL":"https://www.meter.io","shortName":"Meter","explorers":[{"name":"Meter Mainnet","url":"https://scan.meter.io/"}]},{"chainId":88,"name":"TomoChain","type":"TomoChain","network":"mainnet","features":[],"nativeCurrency":{"chainId":88,"name":"TomoChain","symbol":"TOMO","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/tomochain/info/logo.png/quality=85"},"infoURL":"https://tomochain.com","shortName":"tomo"},{"chainId":96,"name":"NEXT Smart Chain","type":"NEXT Smart Chain","network":"mainnet","features":[],"nativeCurrency":{"chainId":96,"name":"NEXT","symbol":"NEXT","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/nsc/info/logo.png/quality=85"},"infoURL":"https://www.nextsmartchain.com/","shortName":"nsc","explorers":[{"name":"NEXT Smart Chain","url":"https://explorer.nextsmartchain.com/"}]},{"chainId":106,"name":"Velas EVM Mainnet","type":"Velas EVM Mainnet","network":"mainnet","features":[],"nativeCurrency":{"chainId":106,"name":"Velas","symbol":"VLX","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/vlx/info/logo.png/quality=85"},"infoURL":"https://velas.com","shortName":"vlx","explorers":[{"name":"Velas EVM Mainnet","url":"https://evmexplorer.velas.com/"}]},{"chainId":108,"name":"ThunderCore Mainnet","type":"ThunderCore Mainnet","network":"mainnet","features":[],"nativeCurrency":{"chainId":108,"name":"ThunderCore Token","symbol":"TT","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/tt/info/logo.png/quality=85"},"infoURL":"https://thundercore.com","shortName":"TT","explorers":[{"name":"ThunderCore Mainnet","url":"https://viewblock.io/thundercore/"}]},{"chainId":122,"name":"Fuse Mainnet","type":"Fuse Mainnet","network":"mainnet","features":[],"nativeCurrency":{"chainId":122,"name":"Fuse","symbol":"FUSE","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/fuse/info/logo.png/quality=85"},"infoURL":"https://fuse.io/","shortName":"fuse"},{"chainId":128,"name":"HECO","type":"HECO","network":"mainnet","features":[],"nativeCurrency":{"chainId":128,"name":"HECO","symbol":"HT","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/heco/info/logo.png/quality=85"},"infoURL":"https://www.hecochain.com","shortName":"heco","explorers":[{"name":"HECO","url":"https://www.hecoinfo.com/en-us/"}]},{"chainId":199,"name":"BitTorrent Chain Mainnet","type":"BitTorrent Chain Mainnet","network":"mainnet","features":[],"nativeCurrency":{"chainId":199,"name":"BitTorrent","symbol":"BTT","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/btt/info/logo.png/quality=85"},"infoURL":"https://bittorrentchain.io/","shortName":"BTT"},{"chainId":288,"name":"Boba Network","type":"Boba Network","network":"mainnet","features":[],"nativeCurrency":{"chainId":288,"name":"Ether","symbol":"ETH","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/ethereum/info/logo.png/quality=85"},"infoURL":"https://boba.network","shortName":"Boba","explorers":[{"name":"Boba Network","url":"https://bobascan.com/"}]},{"chainId":321,"name":"KCC Mainnet","type":"KCC Mainnet","network":"mainnet","features":[],"nativeCurrency":{"chainId":321,"name":"KuCoin Token","symbol":"KCS","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/kcc/info/logo.png/quality=85"},"infoURL":"https://kcc.io","shortName":"kcs","explorers":[{"name":"KCC Mainnet","url":"https://explorer.kcc.io/en/"}]},{"chainId":361,"name":"Theta Mainnet","type":"Theta Mainnet","network":"mainnet","features":[],"nativeCurrency":{"chainId":361,"name":"Theta Fuel","symbol":"TFUEL","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/theta/info/logo.png/quality=85"},"infoURL":"https://www.thetatoken.org/","shortName":"theta-mainnet","explorers":[{"name":"Theta Mainnet","url":"https://explorer.thetatoken.org/"}]},{"chainId":530,"name":"Function X","type":"Function X","network":"mainnet","features":[],"nativeCurrency":{"chainId":57,"name":"FX","symbol":"FX","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/fx/info/logo.png/quality=85"},"infoURL":"https://functionx.io/","shortName":"Function X","explorers":[{"name":"Function X","url":"https://explorer.functionx.io/"}]},{"chainId":1088,"name":"Metis Andromeda Mainnet","type":"Metis Andromeda Mainnet","network":"mainnet","features":[],"nativeCurrency":{"chainId":1088,"name":"Metis","symbol":"METIS","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/metis/info/logo.png/quality=85"},"infoURL":"https://www.metis.io","shortName":"metis-andromeda","explorers":[{"name":"Metis Andromeda Mainnet","url":"https://andromeda-explorer.metis.io/"}]},{"chainId":1284,"name":"Moonbeam","type":"Moonbeam","network":"mainnet","features":[],"nativeCurrency":{"chainId":1284,"name":"Glimmer","symbol":"GLMR","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/moonbeam/info/logo.png/quality=85"},"infoURL":"https://moonbeam.network/networks/moonbeam/","shortName":"mbeam","explorers":[{"name":"Moonbeam","url":"https://moonbeam.moonscan.io/"}]},{"chainId":1285,"name":"Moonriver","type":"Moonriver","network":"mainnet","features":[],"nativeCurrency":{"chainId":1285,"name":"Moonriver","symbol":"MOVR","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/moonriver/info/logo.png/quality=85"},"infoURL":"https://moonbeam.network/networks/moonriver/","shortName":"mriver","explorers":[{"name":"Moonriver","url":"https://moonriver.moonscan.io/"}]},{"chainId":7700,"name":"Canto","type":"Canto","network":"mainnet","features":[],"nativeCurrency":{"chainId":7700,"name":"Canto","symbol":"CANTO","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/canto/info/logo.png/quality=85"},"infoURL":"https://canto.io","shortName":"canto","explorers":[{"name":"Canto","url":"https://evm.explorer.canto.io/"}]},{"chainId":9001,"name":"Evmos","type":"Evmos","network":"mainnet","features":[],"nativeCurrency":{"chainId":9001,"name":"Evmos","symbol":"EVMOS","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/evmos/info/logo.png/quality=85"},"infoURL":"https://evmos.org","shortName":"evmos","explorers":[{"name":"Evmos","url":"https://escan.live/"}]},{"chainId":42170,"name":"Arbitrum Nova","type":"Arbitrum Nova","shortName":"arb-nova","network":"mainnet","features":[],"nativeCurrency":{"chainId":42170,"name":"Ether","symbol":"ETH","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/ethereum/info/logo.png/quality=85"},"infoURL":"https://arbitrum.io","explorers":[{"name":"Arbitrum Nova","url":"https://nova-explorer.arbitrum.io/"}]},{"chainId":42262,"name":"Oasis","type":"Oasis","network":"mainnet","features":[],"nativeCurrency":{"chainId":42262,"name":"Emerald Rose","symbol":"ROSE","decimals":18,"logoURL":"https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/oasis/info/logo.png/quality=85"},"infoURL":"https://docs.oasis.dev/general/developer-resources/overview","shortName":"emerald","explorers":[{"name":"Oasis","url":"https://explorer.emerald.oasis.dev/"}]}]');
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/types/index.ts
var src_types = __webpack_require__(24770);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/constants/constants.ts
var constants = __webpack_require__(33026);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/constants/primitives.ts
var primitives = __webpack_require__(47469);
;// CONCATENATED MODULE: ./packages/web3-shared/evm/src/constants/descriptors.ts








const PLUGIN_ID = PluginID/* NetworkPluginID */.F.PLUGIN_EVM;
const NETWORK_DESCRIPTORS = [
    {
        ID: `${PLUGIN_ID}_ethereum`,
        networkSupporterPluginID: PLUGIN_ID,
        chainId: src_types/* ChainId */.a_.Mainnet,
        type: src_types/* NetworkType */.td.Ethereum,
        name: 'Ethereum',
        shortName: 'ETH',
        icon: new URL(/* asset import */ __webpack_require__(91055), __webpack_require__.b).href,
        iconColor: 'rgb(28, 104, 243)',
        averageBlockDelay: 10,
        backgroundGradient: 'linear-gradient(180deg, rgba(98, 126, 234, 0.15) 0%, rgba(98, 126, 234, 0.05) 100%), rgba(255, 255, 255, 0.2)',
        isMainnet: true
    },
    {
        ID: `${PLUGIN_ID}_ropsten`,
        networkSupporterPluginID: PLUGIN_ID,
        chainId: src_types/* ChainId */.a_.Ropsten,
        type: src_types/* NetworkType */.td.Ethereum,
        name: 'Ropsten',
        icon: new URL(/* asset import */ __webpack_require__(91055), __webpack_require__.b).href,
        iconColor: 'rgb(255, 65, 130)',
        averageBlockDelay: 10,
        isMainnet: false
    },
    {
        ID: `${PLUGIN_ID}_kovan`,
        networkSupporterPluginID: PLUGIN_ID,
        chainId: src_types/* ChainId */.a_.Kovan,
        type: src_types/* NetworkType */.td.Ethereum,
        name: 'Kovan',
        icon: new URL(/* asset import */ __webpack_require__(91055), __webpack_require__.b).href,
        iconColor: 'rgb(133, 89, 255)',
        averageBlockDelay: 10,
        isMainnet: false
    },
    {
        ID: `${PLUGIN_ID}_rinkeby`,
        networkSupporterPluginID: PLUGIN_ID,
        chainId: src_types/* ChainId */.a_.Rinkeby,
        type: src_types/* NetworkType */.td.Ethereum,
        name: 'Rinkeby',
        icon: new URL(/* asset import */ __webpack_require__(91055), __webpack_require__.b).href,
        iconColor: 'rgb(133, 89, 255)',
        averageBlockDelay: 10,
        isMainnet: false
    },
    {
        ID: `${PLUGIN_ID}_gorli`,
        networkSupporterPluginID: PLUGIN_ID,
        chainId: src_types/* ChainId */.a_.Gorli,
        type: src_types/* NetworkType */.td.Ethereum,
        name: 'G\u00F6rli',
        icon: new URL(/* asset import */ __webpack_require__(91055), __webpack_require__.b).href,
        iconColor: 'rgb(48, 153, 242)',
        averageBlockDelay: 10,
        isMainnet: false
    },
    {
        ID: `${PLUGIN_ID}_bsc`,
        networkSupporterPluginID: PLUGIN_ID,
        chainId: src_types/* ChainId */.a_.BSC,
        type: src_types/* NetworkType */.td.Binance,
        name: 'BNB Chain',
        icon: new URL(/* asset import */ __webpack_require__(80130), __webpack_require__.b).href,
        iconColor: 'rgb(240, 185, 10)',
        averageBlockDelay: 10,
        backgroundGradient: 'linear-gradient(180deg, rgba(243, 186, 47, 0.15) 0%, rgba(243, 186, 47, 0.05) 100%)',
        isMainnet: true
    },
    {
        ID: `${PLUGIN_ID}_bsct`,
        networkSupporterPluginID: PLUGIN_ID,
        chainId: src_types/* ChainId */.a_.BSCT,
        type: src_types/* NetworkType */.td.Binance,
        name: 'BSCT',
        icon: new URL(/* asset import */ __webpack_require__(80130), __webpack_require__.b).href,
        iconColor: 'rgb(240, 185, 10)',
        averageBlockDelay: 10,
        isMainnet: false
    },
    {
        ID: `${PLUGIN_ID}_base`,
        networkSupporterPluginID: PLUGIN_ID,
        chainId: src_types/* ChainId */.a_.Base,
        type: src_types/* NetworkType */.td.Base,
        name: 'Base',
        icon: new URL(/* asset import */ __webpack_require__(46141), __webpack_require__.b).href,
        iconColor: 'rgb(0, 82, 255)',
        averageBlockDelay: 10,
        isMainnet: true
    },
    {
        ID: `${PLUGIN_ID}_base_gorli`,
        networkSupporterPluginID: PLUGIN_ID,
        chainId: src_types/* ChainId */.a_.Base_Goerli,
        type: src_types/* NetworkType */.td.Base,
        name: 'Base Gorli',
        icon: new URL(/* asset import */ __webpack_require__(46141), __webpack_require__.b).href,
        iconColor: 'rgb(0, 82, 255)',
        averageBlockDelay: 10,
        isMainnet: false
    },
    {
        ID: `${PLUGIN_ID}_polygon`,
        networkSupporterPluginID: PLUGIN_ID,
        chainId: src_types/* ChainId */.a_.Matic,
        type: src_types/* NetworkType */.td.Polygon,
        name: 'Polygon',
        icon: new URL(/* asset import */ __webpack_require__(42642), __webpack_require__.b).href,
        iconColor: 'rgb(119, 62, 225)',
        averageBlockDelay: 10,
        backgroundGradient: 'linear-gradient(180deg, rgba(130, 71, 229, 0.15) 0%, rgba(130, 71, 229, 0.05) 100%)',
        isMainnet: true
    },
    {
        ID: `${PLUGIN_ID}_mumbai`,
        networkSupporterPluginID: PLUGIN_ID,
        chainId: src_types/* ChainId */.a_.Mumbai,
        type: src_types/* NetworkType */.td.Polygon,
        name: 'Mumbai',
        icon: new URL(/* asset import */ __webpack_require__(42642), __webpack_require__.b).href,
        iconColor: 'rgb(119, 62, 225)',
        averageBlockDelay: 10,
        isMainnet: false
    },
    {
        ID: `${PLUGIN_ID}_arbitrum`,
        networkSupporterPluginID: PLUGIN_ID,
        chainId: src_types/* ChainId */.a_.Arbitrum,
        type: src_types/* NetworkType */.td.Arbitrum,
        name: 'Arbitrum One',
        shortName: 'Arbitrum',
        icon: new URL(/* asset import */ __webpack_require__(69553), __webpack_require__.b).href,
        iconColor: 'rgb(36, 150, 238)',
        averageBlockDelay: 10,
        backgroundGradient: 'linear-gradient(180deg, rgba(40, 160, 240, 0.15) 0%, rgba(40, 160, 240, 0.05) 100%)',
        isMainnet: true
    },
    {
        ID: `${PLUGIN_ID}_arbitrum_rinkeby`,
        networkSupporterPluginID: PLUGIN_ID,
        chainId: src_types/* ChainId */.a_.Arbitrum_Rinkeby,
        type: src_types/* NetworkType */.td.Arbitrum,
        name: 'Arbitrum Rinkeby',
        icon: new URL(/* asset import */ __webpack_require__(69553), __webpack_require__.b).href,
        iconColor: 'rgb(36, 150, 238)',
        averageBlockDelay: 10,
        backgroundGradient: 'linear-gradient(180deg, rgba(40, 160, 240, 0.15) 0%, rgba(40, 160, 240, 0.05) 100%)',
        isMainnet: false
    },
    {
        ID: `${PLUGIN_ID}_xdai`,
        networkSupporterPluginID: PLUGIN_ID,
        chainId: src_types/* ChainId */.a_.xDai,
        type: src_types/* NetworkType */.td.xDai,
        name: 'Gnosis',
        icon: new URL(/* asset import */ __webpack_require__(21740), __webpack_require__.b).href,
        iconColor: 'rgb(73, 169, 166)',
        averageBlockDelay: 10,
        backgroundGradient: 'linear-gradient(180deg, rgba(72, 168, 166, 0.15) 0%, rgba(72, 168, 166, 0.05) 100%)',
        isMainnet: true
    },
    {
        ID: `${PLUGIN_ID}_celo`,
        networkSupporterPluginID: PLUGIN_ID,
        chainId: src_types/* ChainId */.a_.Celo,
        type: src_types/* NetworkType */.td.Celo,
        name: 'Celo',
        icon: new URL(/* asset import */ __webpack_require__(49683), __webpack_require__.b).href,
        iconColor: 'rgb(53, 208, 127)',
        averageBlockDelay: 10,
        backgroundGradient: 'linear-gradient(180deg, rgba(251, 204, 92, 0.15) 0%, rgba(251, 204, 92, 0.05) 100%)',
        isMainnet: false
    },
    {
        ID: `${PLUGIN_ID}_scroll`,
        networkSupporterPluginID: PLUGIN_ID,
        chainId: src_types/* ChainId */.a_.Scroll,
        type: src_types/* NetworkType */.td.Scroll,
        name: 'Scroll',
        icon: new URL(/* asset import */ __webpack_require__(2107), __webpack_require__.b).href,
        backgroundGradient: 'linear-gradient(180deg, rgba(98, 126, 234, 0.15) 0%, rgba(98, 126, 234, 0.05) 100%), rgba(255, 255, 255, 0.2)',
        iconColor: 'rgb(255, 248, 243)',
        averageBlockDelay: 9,
        isMainnet: true
    },
    {
        ID: `${PLUGIN_ID}_avalanche`,
        networkSupporterPluginID: PLUGIN_ID,
        chainId: src_types/* ChainId */.a_.Avalanche,
        type: src_types/* NetworkType */.td.Avalanche,
        name: 'Avalanche',
        shortName: 'AVAX',
        icon: new URL(/* asset import */ __webpack_require__(18502), __webpack_require__.b).href,
        backgroundGradient: 'linear-gradient(180deg, rgba(232, 65, 66, 0.15) 0%, rgba(232, 65, 66, 0.05) 100%)',
        iconColor: 'rgb(232, 65, 66)',
        averageBlockDelay: 10,
        isMainnet: true
    },
    {
        ID: `${PLUGIN_ID}_aurora`,
        networkSupporterPluginID: PLUGIN_ID,
        chainId: src_types/* ChainId */.a_.Aurora,
        type: src_types/* NetworkType */.td.Aurora,
        name: 'Aurora',
        icon: new URL(/* asset import */ __webpack_require__(58439), __webpack_require__.b).href,
        iconColor: 'rgb(112, 212, 74)',
        averageBlockDelay: 10,
        backgroundGradient: 'linear-gradient(180deg, rgba(112, 212, 75, 0.15) 0%, rgba(112, 212, 75, 0.05) 100%)',
        isMainnet: true
    },
    {
        ID: `${PLUGIN_ID}_conflux`,
        networkSupporterPluginID: PLUGIN_ID,
        chainId: src_types/* ChainId */.a_.Conflux,
        type: src_types/* NetworkType */.td.Conflux,
        name: 'Conflux',
        icon: new URL(/* asset import */ __webpack_require__(10206), __webpack_require__.b).href,
        iconColor: 'rgb(112, 212, 74)',
        averageBlockDelay: 10,
        isMainnet: true
    },
    {
        ID: `${PLUGIN_ID}_astar`,
        networkSupporterPluginID: PLUGIN_ID,
        chainId: src_types/* ChainId */.a_.Astar,
        type: src_types/* NetworkType */.td.Astar,
        name: 'Astar',
        icon: new URL(/* asset import */ __webpack_require__(62939), __webpack_require__.b).href,
        iconColor: 'rgb(36, 150, 238)',
        averageBlockDelay: 10,
        isMainnet: true
    },
    {
        ID: `${PLUGIN_ID}_fantom`,
        networkSupporterPluginID: PLUGIN_ID,
        chainId: src_types/* ChainId */.a_.Fantom,
        type: src_types/* NetworkType */.td.Fantom,
        name: 'Fantom',
        icon: new URL(/* asset import */ __webpack_require__(61800), __webpack_require__.b).href,
        iconColor: 'rgb(73, 169, 166)',
        averageBlockDelay: 10,
        backgroundGradient: 'linear-gradient(180deg, rgba(24, 94, 255, 0.15) 0%, rgba(24, 94, 255, 0.05) 100%)',
        isMainnet: true
    },
    {
        ID: `${PLUGIN_ID}_optimism`,
        networkSupporterPluginID: PLUGIN_ID,
        chainId: src_types/* ChainId */.a_.Optimism,
        type: src_types/* NetworkType */.td.Optimism,
        name: 'Optimism',
        icon: new URL(/* asset import */ __webpack_require__(66222), __webpack_require__.b).href,
        iconColor: 'rgb(232, 65, 66)',
        backgroundGradient: 'linear-gradient(180deg, rgba(232, 65, 66, 0.15) 0%, rgba(232, 65, 66, 0.05) 100%)',
        isMainnet: true,
        averageBlockDelay: 10
    },
    {
        ID: `${PLUGIN_ID}_moonbeam`,
        networkSupporterPluginID: PLUGIN_ID,
        chainId: src_types/* ChainId */.a_.Moonbeam,
        type: src_types/* NetworkType */.td.Moonbeam,
        icon: new URL(/* asset import */ __webpack_require__(90178), __webpack_require__.b).href,
        iconColor: 'rgb(36, 150, 238)',
        name: 'Moonbeam',
        isMainnet: false,
        averageBlockDelay: 10
    }
];
const CHAIN_DESCRIPTORS = chains_namespaceObject.map((x)=>{
    const network = NETWORK_DESCRIPTORS.find((y)=>y.chainId === x.chainId);
    return {
        ...x,
        ID: `${x.chainId}_${x.name}`,
        coinMarketCapChainId: '',
        coinGeckoChainId: '',
        coinGeckoPlatformId: '',
        type: x.type || src_types/* NetworkType */.td.Ethereum,
        color: network?.iconColor || x.color || 'rgb(138, 138, 138)',
        nativeCurrency: {
            id: (0,constants/* getTokenConstant */._x)(x.chainId, 'NATIVE_TOKEN_ADDRESS', primitives/* ZERO_ADDRESS */.r),
            address: (0,constants/* getTokenConstant */._x)(x.chainId, 'NATIVE_TOKEN_ADDRESS', primitives/* ZERO_ADDRESS */.r),
            type: specs/* TokenType */.iv.Fungible,
            schema: src_types/* SchemaType */.XQ.Native,
            ...x.nativeCurrency
        },
        // not accessible
        rpcUrl: '',
        iconUrl: network?.icon || x.nativeCurrency.logoURL,
        explorerUrl: {
            url: x.explorers?.[0]?.url || x.infoURL
        },
        isCustomized: false
    };
});
const PROVIDER_DESCRIPTORS = [
    {
        ID: `${PLUGIN_ID}_maskwallet`,
        providerAdaptorPluginID: PLUGIN_ID,
        type: src_types/* ProviderType */.lP.MaskWallet,
        name: 'Mask Network',
        icon: new URL(/* asset import */ __webpack_require__(95945), __webpack_require__.b).href,
        enableRequirements: {
            supportedChainIds: constants/* ChainIdList */.rY,
            supportedEnhanceableSites: (0,difference/* default */.Z)(Site/* EnhanceableSiteList */.LP, [
                types/* EnhanceableSite */.J.Localhost,
                types/* EnhanceableSite */.J.App
            ]),
            supportedExtensionSites: Site/* ExtensionSiteList */.gD
        },
        homeLink: 'https://mask.io',
        shortenLink: 'mask.io',
        downloadLink: 'https://mask.io/download-links',
        iconFilterColor: 'rgba(28, 104, 243, 0.2)',
        backgroundGradient: 'linear-gradient(90deg, rgba(98, 152, 234, 0.2) 1.03%, rgba(98, 152, 234, 0.2) 1.04%, rgba(98, 126, 234, 0.2) 100%), linear-gradient(0deg, #FFFFFF, #FFFFFF)'
    },
    {
        ID: `${PLUGIN_ID}_browser`,
        providerAdaptorPluginID: PLUGIN_ID,
        type: src_types/* ProviderType */.lP.Browser,
        name: 'Browser Wallet',
        icon: new URL(/* asset import */ __webpack_require__(92259), __webpack_require__.b).href,
        enableRequirements:  false ? 0 : undefined,
        homeLink: '',
        shortenLink: '',
        downloadLink: '',
        iconFilterColor: 'rgba(216, 124, 48, 0.3)',
        backgroundGradient: 'linear-gradient(90deg, rgba(248, 156, 53, 0.2) 0%, rgba(98, 126, 234, 0.2) 100%), linear-gradient(0deg, #FFFFFF, #FFFFFF)'
    },
    {
        ID: `${PLUGIN_ID}_metamask`,
        providerAdaptorPluginID: PLUGIN_ID,
        type: src_types/* ProviderType */.lP.MetaMask,
        name: 'MetaMask',
        icon: new URL(/* asset import */ __webpack_require__(92259), __webpack_require__.b).href,
        enableRequirements: {
            supportedChainIds: constants/* ChainIdList */.rY,
            supportedEnhanceableSites: Site/* EnhanceableSiteList */.LP,
            supportedExtensionSites: Site/* ExtensionSiteList */.gD
        },
        homeLink: 'https://metamask.io',
        shortenLink: 'metamask.io',
        downloadLink: 'https://metamask.io/download/',
        iconFilterColor: 'rgba(216, 124, 48, 0.3)',
        backgroundGradient: 'linear-gradient(90deg, rgba(248, 156, 53, 0.2) 0%, rgba(98, 126, 234, 0.2) 100%), linear-gradient(0deg, #FFFFFF, #FFFFFF)'
    },
    {
        ID: `${PLUGIN_ID}_walletconnect`,
        providerAdaptorPluginID: PLUGIN_ID,
        type: src_types/* ProviderType */.lP.WalletConnect,
        name: 'WalletConnect',
        icon: new URL(/* asset import */ __webpack_require__(18095), __webpack_require__.b).href,
        enableRequirements: src/* Flags */.v.wc_enabled ? {
            supportedChainIds: constants/* ChainIdList */.rY,
            supportedEnhanceableSites: (0,difference/* default */.Z)(Site/* EnhanceableSiteList */.LP, [
                types/* EnhanceableSite */.J.Localhost,
                types/* EnhanceableSite */.J.App
            ]),
            supportedExtensionSites: src/* Flags */.v.wc_enabled ? Site/* ExtensionSiteList */.gD : []
        } : undefined,
        homeLink: 'https://walletconnect.com',
        shortenLink: 'walletconnect.com',
        downloadLink: 'https://walletconnect.com',
        iconFilterColor: 'rgba(59, 153, 252, 0.2)',
        backgroundGradient: 'linear-gradient(90deg, rgba(59, 153, 252, 0.2) 0%, rgba(98, 126, 234, 0.2) 100%), linear-gradient(0deg, #FFFFFF, #FFFFFF)'
    },
    {
        ID: `${PLUGIN_ID}_coin98`,
        providerAdaptorPluginID: PLUGIN_ID,
        type: src_types/* ProviderType */.lP.Coin98,
        name: 'Coin98',
        icon: new URL(/* asset import */ __webpack_require__(34180), __webpack_require__.b).href,
        enableRequirements: {
            supportedChainIds: constants/* ChainIdList */.rY,
            supportedEnhanceableSites: []
        },
        homeLink: 'https://coin98.com',
        shortenLink: 'coin98.com',
        downloadLink: 'https://coin98insights.com/introduction-to-coin98-wallet-extension'
    },
    {
        ID: `${PLUGIN_ID}_coinbase`,
        providerAdaptorPluginID: PLUGIN_ID,
        type: src_types/* ProviderType */.lP.Coinbase,
        name: 'Coinbase',
        icon: new URL(/* asset import */ __webpack_require__(21532), __webpack_require__.b).href,
        enableRequirements: {
            supportedChainIds: [
                src_types/* ChainId */.a_.Mainnet,
                src_types/* ChainId */.a_.Arbitrum,
                src_types/* ChainId */.a_.Avalanche,
                src_types/* ChainId */.a_.Optimism,
                src_types/* ChainId */.a_.Matic
            ],
            supportedEnhanceableSites: [],
            supportedExtensionSites: []
        },
        homeLink: 'https://www.coinbase.com/wallet',
        shortenLink: 'coinbase.com',
        downloadLink: 'https://www.coinbase.com/wallet/downloads'
    },
    {
        ID: `${PLUGIN_ID}_okx`,
        providerAdaptorPluginID: PLUGIN_ID,
        type: src_types/* ProviderType */.lP.OKX,
        name: 'OKX Wallet',
        icon: new URL(/* asset import */ __webpack_require__(8177), __webpack_require__.b).href,
        enableRequirements: {
            supportedChainIds: [
                src_types/* ChainId */.a_.Mainnet,
                src_types/* ChainId */.a_.Arbitrum,
                src_types/* ChainId */.a_.Avalanche,
                src_types/* ChainId */.a_.Optimism,
                src_types/* ChainId */.a_.Matic
            ],
            supportedEnhanceableSites: [],
            supportedExtensionSites: []
        },
        homeLink: 'https://www.okx.com/web3',
        shortenLink: 'okx.com',
        downloadLink: 'https://www.okx.com/web3'
    },
    {
        ID: `${PLUGIN_ID}_opera`,
        providerAdaptorPluginID: PLUGIN_ID,
        type: src_types/* ProviderType */.lP.Opera,
        name: 'Opera',
        icon: new URL(/* asset import */ __webpack_require__(79615), __webpack_require__.b).href,
        enableRequirements: {
            supportedChainIds: [
                src_types/* ChainId */.a_.Mainnet,
                src_types/* ChainId */.a_.BSC,
                src_types/* ChainId */.a_.Matic
            ],
            supportedEnhanceableSites: Sniffings/* Sniffings */.Y.is_opera ? Site/* EnhanceableSiteList */.LP : [],
            supportedExtensionSites: []
        },
        homeLink: 'https://www.opera.com/crypto/next',
        shortenLink: 'opera.com',
        downloadLink: 'https://www.opera.com/crypto/next',
        backgroundGradient: 'linear-gradient(90deg, rgba(98, 152, 234, 0.2) 1.03%, rgba(98, 152, 234, 0.2) 1.04%, rgba(98, 126, 234, 0.2) 100%), linear-gradient(0deg, #FFFFFF, #FFFFFF)'
    },
    {
        ID: `${PLUGIN_ID}_clover`,
        providerAdaptorPluginID: PLUGIN_ID,
        type: src_types/* ProviderType */.lP.Clover,
        name: 'Clover',
        icon: new URL(/* asset import */ __webpack_require__(16012), __webpack_require__.b).href,
        backgroundGradient: 'linear-gradient(90deg, rgba(52, 133, 196, 0.2) 0%, rgba(0, 239, 139, 0.2) 100%), linear-gradient(0deg, #FFFFFF, #FFFFFF)',
        enableRequirements: {
            supportedChainIds: Sniffings/* Sniffings */.Y.is_firefox ? [] : constants/* ChainIdList */.rY,
            supportedEnhanceableSites: Sniffings/* Sniffings */.Y.is_firefox ? [] : Site/* EnhanceableSiteList */.LP,
            supportedExtensionSites: []
        },
        homeLink: 'https://clv.org',
        shortenLink: 'clv.org',
        downloadLink: 'https://clv.org/?type=wallet'
    },
    {
        ID: `${PLUGIN_ID}_fortmatic`,
        providerAdaptorPluginID: PLUGIN_ID,
        type: src_types/* ProviderType */.lP.Fortmatic,
        name: 'Fortmatic',
        icon: new URL(/* asset import */ __webpack_require__(81334), __webpack_require__.b).href,
        enableRequirements: {
            supportedChainIds: Sniffings/* Sniffings */.Y.is_firefox ? [] : [
                src_types/* ChainId */.a_.Mainnet,
                src_types/* ChainId */.a_.BSC
            ],
            supportedEnhanceableSites: Sniffings/* Sniffings */.Y.is_firefox ? [] : Site/* EnhanceableSiteList */.LP,
            supportedExtensionSites: Sniffings/* Sniffings */.Y.is_firefox ? [] : Site/* ExtensionSiteList */.gD
        },
        homeLink: 'https://fortmatic.com',
        shortenLink: 'fortmatic.com',
        downloadLink: 'https://fortmatic.com',
        iconFilterColor: 'rgba(104, 81, 255, 0.2)',
        backgroundGradient: 'linear-gradient(90deg, rgba(104, 81, 255, 0.2) 0%, rgba(98, 126, 234, 0.2) 100%), linear-gradient(0deg, #FFFFFF, #FFFFFF)'
    }
];


/***/ }),

/***/ 47469:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   r: () => (/* binding */ ZERO_ADDRESS)
/* harmony export */ });
/* unused harmony export FAKE_SIGN_PASSWORD */
const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';
// for estimate gas
const FAKE_SIGN_PASSWORD = '0x75466cc969717b172b14253aaeebdc958f2b5037a852c1337650ed4978242dd9';


/***/ }),

/***/ 1853:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   r: () => (/* binding */ abiCoder)
/* harmony export */ });
/* harmony import */ var web3_eth_abi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(65797);
/* harmony import */ var web3_eth_abi__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(web3_eth_abi__WEBPACK_IMPORTED_MODULE_0__);

const abiCoder = web3_eth_abi__WEBPACK_IMPORTED_MODULE_0__;


/***/ }),

/***/ 65327:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   At: () => (/* binding */ isValidAddress),
/* harmony export */   FY: () => (/* binding */ isENSNameWrapperContractAddress),
/* harmony export */   R6: () => (/* binding */ getZeroAddress),
/* harmony export */   _u: () => (/* binding */ isLensProfileAddress),
/* harmony export */   cy: () => (/* binding */ isZeroString),
/* harmony export */   o2: () => (/* binding */ isENSContractAddress),
/* harmony export */   ob: () => (/* binding */ isXnsContractAddress),
/* harmony export */   qw: () => (/* binding */ isNativeTokenAddress),
/* harmony export */   rG: () => (/* binding */ getNativeTokenAddress),
/* harmony export */   uO: () => (/* binding */ isZeroAddress),
/* harmony export */   vY: () => (/* binding */ getMaskTokenAddress),
/* harmony export */   w2: () => (/* binding */ isEmptyHex),
/* harmony export */   xs: () => (/* binding */ checksumAddress),
/* harmony export */   yi: () => (/* binding */ isCryptoPunksContractAddress)
/* harmony export */ });
/* unused harmony exports isRedPacketAddress, isArbContractAddress, isSpaceIdContractAddress */
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(43434);
/* harmony import */ var web3_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(84976);
/* harmony import */ var web3_utils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(web3_utils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(74765);
/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(47469);
/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(33026);
/* harmony import */ var _types_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(24770);





function checksumAddress(address) {
    return (0,web3_utils__WEBPACK_IMPORTED_MODULE_0__.toChecksumAddress)(address);
}
function isEmptyHex(hex) {
    return !hex || [
        '0x',
        '0x0'
    ].includes(hex);
}
function isZeroString(str) {
    return !str || str === '0';
}
const isValidAddress = (0,lodash_es__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(function isValidAddress(address) {
    if (!address) return false;
    return (0,web3_utils__WEBPACK_IMPORTED_MODULE_0__.isAddress)(address);
});
function isZeroAddress(address) {
    return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .isSameAddress */ .W)(address, _constants_index_js__WEBPACK_IMPORTED_MODULE_3__/* .ZERO_ADDRESS */ .r);
}
const nativeTokenSet = new Set(_constants_index_js__WEBPACK_IMPORTED_MODULE_4__/* .ChainIdList */ .rY.map((chainId)=>(0,_constants_index_js__WEBPACK_IMPORTED_MODULE_4__/* .getTokenConstant */ ._x)(chainId, 'NATIVE_TOKEN_ADDRESS')));
function isNativeTokenAddress(address) {
    return !!(address && nativeTokenSet.has(address));
}
const { HAPPY_RED_PACKET_ADDRESS_V1, HAPPY_RED_PACKET_ADDRESS_V2, HAPPY_RED_PACKET_ADDRESS_V3, HAPPY_RED_PACKET_ADDRESS_V4 } = (0,_constants_index_js__WEBPACK_IMPORTED_MODULE_4__/* .getRedPacketConstants */ .GV)();
function isRedPacketAddress(address, version) {
    switch(version){
        case 1:
            return isSameAddress(HAPPY_RED_PACKET_ADDRESS_V1, address);
        case 2:
            return isSameAddress(HAPPY_RED_PACKET_ADDRESS_V2, address);
        case 3:
            return isSameAddress(HAPPY_RED_PACKET_ADDRESS_V3, address);
        case 4:
            return isSameAddress(HAPPY_RED_PACKET_ADDRESS_V4, address);
        default:
            return isSameAddress(HAPPY_RED_PACKET_ADDRESS_V1, address) || isSameAddress(HAPPY_RED_PACKET_ADDRESS_V2, address) || isSameAddress(HAPPY_RED_PACKET_ADDRESS_V3, address) || isSameAddress(HAPPY_RED_PACKET_ADDRESS_V4, address);
    }
}
function getZeroAddress() {
    return _constants_index_js__WEBPACK_IMPORTED_MODULE_3__/* .ZERO_ADDRESS */ .r;
}
const getNativeTokenAddress = (0,lodash_es__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)((chainId = _types_index_js__WEBPACK_IMPORTED_MODULE_5__/* .ChainId */ .a_.Mainnet)=>{
    return (0,_constants_index_js__WEBPACK_IMPORTED_MODULE_4__/* .getTokenConstant */ ._x)(chainId, 'NATIVE_TOKEN_ADDRESS') ?? _constants_index_js__WEBPACK_IMPORTED_MODULE_3__/* .ZERO_ADDRESS */ .r;
});
const getMaskTokenAddress = (0,lodash_es__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)((chainId = _types_index_js__WEBPACK_IMPORTED_MODULE_5__/* .ChainId */ .a_.Mainnet)=>{
    return (0,_constants_index_js__WEBPACK_IMPORTED_MODULE_4__/* .getTokenConstant */ ._x)(chainId, 'MASK_ADDRESS') ?? '';
});
const { ENS_CONTRACT_ADDRESS } = (0,_constants_index_js__WEBPACK_IMPORTED_MODULE_4__/* .getENSConstants */ .$F)();
function isENSContractAddress(contract_address) {
    return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .isSameAddress */ .W)(contract_address, ENS_CONTRACT_ADDRESS);
}
const { ENS_NAME_WRAPPER_CONTRACT_ADDRESS } = (0,_constants_index_js__WEBPACK_IMPORTED_MODULE_4__/* .getENSConstants */ .$F)();
function isENSNameWrapperContractAddress(contract_address) {
    return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .isSameAddress */ .W)(contract_address, ENS_NAME_WRAPPER_CONTRACT_ADDRESS);
}
function isLensProfileAddress(address) {
    const { LENS_PROFILE_CONTRACT_ADDRESS } = (0,_constants_index_js__WEBPACK_IMPORTED_MODULE_4__/* .getLensProfileConstants */ .FF)(_types_index_js__WEBPACK_IMPORTED_MODULE_5__/* .ChainId */ .a_.Matic);
    return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .isSameAddress */ .W)(address, LENS_PROFILE_CONTRACT_ADDRESS);
}
const { ARB_CONTRACT_ADDRESS } = (0,_constants_index_js__WEBPACK_IMPORTED_MODULE_4__/* .getArbConstants */ .fj)(_types_index_js__WEBPACK_IMPORTED_MODULE_5__/* .ChainId */ .a_.Arbitrum);
function isArbContractAddress(contract_address) {
    return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .isSameAddress */ .W)(contract_address, ARB_CONTRACT_ADDRESS);
}
const { SID_CONTRACT_ADDRESS } = (0,_constants_index_js__WEBPACK_IMPORTED_MODULE_4__/* .getSpaceIdConstants */ .rH)(_types_index_js__WEBPACK_IMPORTED_MODULE_5__/* .ChainId */ .a_.BSC);
function isSpaceIdContractAddress(contract_address) {
    return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .isSameAddress */ .W)(contract_address, SID_CONTRACT_ADDRESS);
}
function isXnsContractAddress(address) {
    return isENSContractAddress(address) || isArbContractAddress(address) || isSpaceIdContractAddress(address);
}
function isCryptoPunksContractAddress(contract_address) {
    const { CRYPTOPUNKS_CONTRACT_ADDRESS } = (0,_constants_index_js__WEBPACK_IMPORTED_MODULE_4__/* .getCryptoPunksConstants */ .CW)();
    return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .isSameAddress */ .W)(contract_address, CRYPTOPUNKS_CONTRACT_ADDRESS);
}


/***/ }),

/***/ 95739:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   O: () => (/* binding */ createContract)
/* harmony export */ });
/* harmony import */ var _address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(65327);

function createContract(web3, address, ABI, options) {
    if (!address || !(0,_address_js__WEBPACK_IMPORTED_MODULE_0__/* .isValidAddress */ .At)(address) || !web3) return null;
    return new web3.eth.Contract(ABI, address, options);
}


/***/ }),

/***/ 83135:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   B: () => (/* binding */ createJsonRpcPayload)
/* harmony export */ });
function createJsonRpcPayload(id, requestArguments) {
    return {
        jsonrpc: '2.0',
        id,
        method: requestArguments.method,
        params: requestArguments.params
    };
}


/***/ }),

/***/ 48221:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   T: () => (/* binding */ createJsonRpcResponse)
/* harmony export */ });
function createJsonRpcResponse(id, result, error) {
    return {
        jsonrpc: '2.0',
        id,
        result,
        error
    };
}


/***/ }),

/***/ 35640:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   p: () => (/* binding */ decodeFunctionData)
/* harmony export */ });
/* harmony import */ var _abiCoder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1853);

function decodeFunctionData(abis, input, methodName) {
    const item = abis.find((x)=>x.type === 'function' && x.name === methodName);
    if (!item) throw new Error(`Failed to locate abi with name: ${methodName}.`);
    if (!item.inputs) throw new Error('Invalid ABI type.');
    // Decode the input using web3.eth.abi.decodeParameters
    return _abiCoder_js__WEBPACK_IMPORTED_MODULE_0__/* .abiCoder */ .r.decodeParameters(item.inputs, `0x${input.slice(10)}`);
}


/***/ }),

/***/ 35138:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   H2: () => (/* binding */ getDefaultNetworkType),
/* harmony export */   Xo: () => (/* binding */ getDefaultProviderType),
/* harmony export */   p6: () => (/* binding */ getInvalidChainId),
/* harmony export */   tA: () => (/* binding */ getDefaultChainId),
/* harmony export */   yg: () => (/* binding */ getNetworkPluginID)
/* harmony export */ });
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24835);
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(66584);
/* harmony import */ var _types_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24770);


function getNetworkPluginID() {
    return _masknet_shared_base__WEBPACK_IMPORTED_MODULE_0__/* .NetworkPluginID */ .F.PLUGIN_EVM;
}
function getDefaultChainId() {
    return _types_index_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet;
}
function getInvalidChainId() {
    return _types_index_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Invalid;
}
function getDefaultNetworkType() {
    return _types_index_js__WEBPACK_IMPORTED_MODULE_1__/* .NetworkType */ .td.Ethereum;
}
function getDefaultProviderType() {
    return _masknet_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .Sniffings */ .Y.is_popup_page ? _types_index_js__WEBPACK_IMPORTED_MODULE_1__/* .ProviderType */ .lP.MaskWallet : _types_index_js__WEBPACK_IMPORTED_MODULE_1__/* .ProviderType */ .lP.None;
}


/***/ }),

/***/ 40068:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   g: () => (/* binding */ getAverageBlockDelay)
/* harmony export */ });
/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3187);

function getAverageBlockDelay(chainId, scale = 1) {
    const delay = _constants_index_js__WEBPACK_IMPORTED_MODULE_0__/* .NETWORK_DESCRIPTORS */ .qQ.find((x)=>x.chainId === chainId)?.averageBlockDelay ?? 10;
    return delay * scale * 1000;
}


/***/ }),

/***/ 29530:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   j: () => (/* binding */ getTransactionStatusType)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62649);

function getTransactionStatusType(receipt) {
    if (!receipt) return _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_0__.TransactionStatusType.NOT_DEPEND;
    const status = receipt.status;
    if (receipt.status === false || [
        '0',
        '0x',
        '0x0'
    ].includes(status)) return _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_0__.TransactionStatusType.FAILED;
    if (receipt.status === true || [
        '1',
        '0x1'
    ].includes(status)) return _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_0__.TransactionStatusType.SUCCEED;
    return _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_0__.TransactionStatusType.NOT_DEPEND;
}


/***/ }),

/***/ 40346:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   s: () => (/* binding */ isLens)
/* harmony export */ });
function isLens(name) {
    if (!name) return false;
    name = name.toLowerCase();
    return name.endsWith('.lens') || name === 'lensprotocol' || name === '@lensprotocol';
}


/***/ }),

/***/ 42097:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ isLensCollect)
/* harmony export */ });
const NORMAL_COLLECT_RE = /\.lens-Collect-\d+$/;
const ADMIN_COLLECT_RE = /^lensprotocol-Collect-\d+$/;
function isLensCollect(name) {
    return NORMAL_COLLECT_RE.test(name) || ADMIN_COLLECT_RE.test(name);
}


/***/ }),

/***/ 7092:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   B: () => (/* binding */ isLensComment)
/* harmony export */ });
const NORMAL_COMMENT_RE = /^Comment by @.*\.lens$/;
const ADMIN_COMMENT_RE = /^Comment by @lensprotocol$/;
// May be not `quoted` comment but something else
const QUOTED_COMMENT_RE = /^Comment by @\w+$/;
function isLensComment(name) {
    return NORMAL_COMMENT_RE.test(name) || ADMIN_COMMENT_RE.test(name) || QUOTED_COMMENT_RE.test(name);
}


/***/ }),

/***/ 63623:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ isLensFollower)
/* harmony export */ });
function isLensFollower(name) {
    // vitalik.lens-Follower, lensprotocol-Follower V2
    return name.includes('.lens-Follower') || name.includes('lensprotocol-Follower') || name.endsWith("'s follower NFT");
}


/***/ }),

/***/ 56205:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   h: () => (/* binding */ isLensPost)
/* harmony export */ });
const NORMAL_POST_RE = /^Post by @.*\.lens$/;
const ADMIN_POST_RE = /^Post by @lensprotocol$/;
const GENESIS_POST_RE = /Genesis post - \w+.lens/;
// May be not `quoted` post but something else
const QUOTED_POST_RE = /^Post by @\w+$/;
function isLensPost(name) {
    return NORMAL_POST_RE.test(name) || ADMIN_POST_RE.test(name) || GENESIS_POST_RE.test(name) || QUOTED_POST_RE.test(name);
}


/***/ }),

/***/ 37049:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   J: () => (/* binding */ isValidChainId)
/* harmony export */ });
/* harmony import */ var _constants_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33026);

function isValidChainId(chainId) {
    // TODO custom networks
    return _constants_constants_js__WEBPACK_IMPORTED_MODULE_0__/* .ChainIdList */ .rY.some((x)=>x === chainId);
}


/***/ }),

/***/ 89019:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   h: () => (/* binding */ isValidDomain),
/* harmony export */   t: () => (/* binding */ isEnsSubdomain)
/* harmony export */ });
/* harmony import */ var punycode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5379);

const NAME_SERVICE_RE = /\.(eth|bnb|arb|lens)$/;
const DOMAIN_RE = /^(?:[a-z0-9](?:[-a-z0-9]*[a-z0-9])?\.)+[a-z0-9][-a-z0-9]*[a-z0-9]$/u;
const ENS_SUBDOMAIN_RE = /\[.{64}?\]\.(?:[a-z0-9](?:[-a-z0-9]*[a-z0-9])?\.)+[a-z0-9][-a-z0-9]*[a-z0-9]$/u;
function isValidDomain(domain) {
    if (!domain) return false;
    domain = domain.toLowerCase();
    if (!NAME_SERVICE_RE.test(domain)) return false;
    const ascii = punycode__WEBPACK_IMPORTED_MODULE_0__/* ["default"].toASCII */ .ZP.toASCII(domain);
    const result = DOMAIN_RE.test(ascii);
    if (!result) return isEnsSubdomain(domain);
    return result;
}
function isEnsSubdomain(domain) {
    if (!domain) return false;
    domain = domain.toLowerCase();
    if (!domain.endsWith('.eth')) return false;
    const ascii = punycode__WEBPACK_IMPORTED_MODULE_0__/* ["default"].toASCII */ .ZP.toASCII(domain);
    const result = ENS_SUBDOMAIN_RE.test(ascii);
    return result;
}


/***/ }),

/***/ 64371:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D: () => (/* binding */ parseChainId)
/* harmony export */ });
/* harmony import */ var _isValidChainId_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37049);

function parseChainId(chainId) {
    if (typeof chainId === 'string') return parseChainId(Number.parseInt(chainId, 16));
    if (typeof chainId === 'number' && (0,_isValidChainId_js__WEBPACK_IMPORTED_MODULE_0__/* .isValidChainId */ .J)(chainId)) return chainId;
    return;
}


/***/ }),

/***/ 81438:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   y: () => (/* binding */ resolveImageURL)
/* harmony export */ });
/* harmony import */ var _isLens_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(40346);
/* harmony import */ var _isLensFollower_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(63623);
/* harmony import */ var _isLensPost_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(56205);
/* harmony import */ var _isLensComment_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7092);
/* harmony import */ var _isLensCollect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(42097);
/* harmony import */ var _address_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(65327);






const LENS_FOLLOWER_IMAGE = new URL(/* asset import */ __webpack_require__(7952), __webpack_require__.b).href;
const LENS_COMMENT_IMAGE = new URL(/* asset import */ __webpack_require__(56041), __webpack_require__.b).href;
const LENS_POST_IMAGE = new URL(/* asset import */ __webpack_require__(29604), __webpack_require__.b).href;
const LENS_COLLECT_IMAGE = new URL(/* asset import */ __webpack_require__(46925), __webpack_require__.b).href;
const LENS_IMAGE = new URL(/* asset import */ __webpack_require__(94377), __webpack_require__.b).href;
const ENS_IMAGE = new URL(/* asset import */ __webpack_require__(11322), __webpack_require__.b).href;
function resolveImageURL(image, name, collectionName, address) {
    if (image) return image;
    if (name) {
        if ((0,_isLensFollower_js__WEBPACK_IMPORTED_MODULE_0__/* .isLensFollower */ .a)(name)) return LENS_FOLLOWER_IMAGE;
        if ((0,_isLensComment_js__WEBPACK_IMPORTED_MODULE_1__/* .isLensComment */ .B)(name)) return LENS_COMMENT_IMAGE;
        if ((0,_isLensPost_js__WEBPACK_IMPORTED_MODULE_2__/* .isLensPost */ .h)(name)) return LENS_POST_IMAGE;
        // Check collect after comment and post
        if ((0,_isLensCollect_js__WEBPACK_IMPORTED_MODULE_3__/* .isLensCollect */ .C)(name)) return LENS_COLLECT_IMAGE;
        if ((0,_isLens_js__WEBPACK_IMPORTED_MODULE_4__/* .isLens */ .s)(name)) return LENS_IMAGE;
    }
    if (collectionName && (0,_isLensCollect_js__WEBPACK_IMPORTED_MODULE_3__/* .isLensCollect */ .C)(collectionName)) {
        return LENS_COLLECT_IMAGE;
    }
    if (address && ((0,_address_js__WEBPACK_IMPORTED_MODULE_5__/* .isENSContractAddress */ .o2)(address) || (0,_address_js__WEBPACK_IMPORTED_MODULE_5__/* .isENSNameWrapperContractAddress */ .FY)(address))) return ENS_IMAGE;
    return;
}


/***/ }),

/***/ 48289:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SC: () => (/* binding */ isNativeTokenSchemaType),
/* harmony export */   V2: () => (/* binding */ isNonFungibleTokenSchemaType),
/* harmony export */   VD: () => (/* binding */ isNativeTokenSymbol),
/* harmony export */   kL: () => (/* binding */ isFungibleTokenSchemaType),
/* harmony export */   vs: () => (/* binding */ createERC20Tokens),
/* harmony export */   wY: () => (/* binding */ createERC20Token)
/* harmony export */ });
/* harmony import */ var _masknet_kit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30898);
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(77199);
/* harmony import */ var _masknet_web3_constants_evm_token_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(42482);
/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3187);
/* harmony import */ var _types_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(24770);





function isNativeTokenSymbol(symbol) {
    return _constants_index_js__WEBPACK_IMPORTED_MODULE_1__/* .CHAIN_DESCRIPTORS */ .Q_.filter((x)=>x.network === 'mainnet' && x.nativeCurrency).map((x)=>x.nativeCurrency.symbol.toLowerCase()).includes(symbol.toLowerCase());
}
function createERC20Token(chainId, address, name = 'Unknown Token', symbol = '', decimals = 0, logoURI) {
    return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .createFungibleToken */ .mn)(chainId, _types_index_js__WEBPACK_IMPORTED_MODULE_3__/* .SchemaType */ .XQ.ERC20, address, name, symbol, decimals, logoURI);
}
const createERC20Tokens = (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .createFungibleTokensFromConstants */ .iI)((0,_masknet_kit__WEBPACK_IMPORTED_MODULE_0__/* .getEnumAsArray */ .Yl)(_types_index_js__WEBPACK_IMPORTED_MODULE_3__/* .ChainId */ .a_), _types_index_js__WEBPACK_IMPORTED_MODULE_3__/* .SchemaType */ .XQ.ERC20, _masknet_web3_constants_evm_token_json__WEBPACK_IMPORTED_MODULE_4__);
function isNativeTokenSchemaType(schemaType) {
    return schemaType === _types_index_js__WEBPACK_IMPORTED_MODULE_3__/* .SchemaType */ .XQ.Native;
}
function isFungibleTokenSchemaType(schemaType) {
    return schemaType === _types_index_js__WEBPACK_IMPORTED_MODULE_3__/* .SchemaType */ .XQ.Native || schemaType === _types_index_js__WEBPACK_IMPORTED_MODULE_3__/* .SchemaType */ .XQ.ERC20;
}
function isNonFungibleTokenSchemaType(schemaType) {
    return schemaType === _types_index_js__WEBPACK_IMPORTED_MODULE_3__/* .SchemaType */ .XQ.ERC721 || schemaType === _types_index_js__WEBPACK_IMPORTED_MODULE_3__/* .SchemaType */ .XQ.ERC1155;
}


/***/ }),

/***/ 17448:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   K: () => (/* binding */ AccountTransaction)
/* harmony export */ });
/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10149);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(43434);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(73307);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(45911);
/* harmony import */ var web3_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(84976);
/* harmony import */ var web3_utils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(web3_utils__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(47469);
/* harmony import */ var _helpers_address_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(65327);
/* harmony import */ var _types_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(24770);






const normalizeHex = (0,lodash_es__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)((value)=>{
    // fix an abnormal hex value like: 0x02c68af0bb140000
    if (typeof value === 'string' && value.length > 3 && value.startsWith('0x0')) return (0,web3_utils__WEBPACK_IMPORTED_MODULE_1__.toHex)(new bignumber_js__WEBPACK_IMPORTED_MODULE_0__/* .BigNumber */ .O(value).toFixed());
    return (0,web3_utils__WEBPACK_IMPORTED_MODULE_1__.toHex)(value);
});
class AccountTransaction {
    transaction;
    constructor(transaction){
        this.transaction = transaction;
    }
    get from() {
        return this.transaction?.from ?? '';
    }
    get to() {
        const to = this.transaction?.to;
        if (!to) return _constants_index_js__WEBPACK_IMPORTED_MODULE_3__/* .ZERO_ADDRESS */ .r;
        if ((0,_helpers_address_js__WEBPACK_IMPORTED_MODULE_4__/* .isEmptyHex */ .w2)(to)) return _constants_index_js__WEBPACK_IMPORTED_MODULE_3__/* .ZERO_ADDRESS */ .r;
        return to;
    }
    get value() {
        return this.transaction?.value ?? '0x0';
    }
    get data() {
        const data = this.transaction?.data;
        if ((0,_helpers_address_js__WEBPACK_IMPORTED_MODULE_4__/* .isEmptyHex */ .w2)(data)) return;
        if (!data.startsWith('0x')) return `0x${data}`;
        return data;
    }
    get functionSignature() {
        return this.data?.slice(0, 10);
    }
    get functionParameters() {
        return this.data?.slice(10);
    }
    fill(overrides) {
        const { chainId, from, to, value, gas, gasPrice, maxPriorityFeePerGas, maxFeePerGas, data, nonce } = {
            ...this.transaction,
            ...(0,lodash_es__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(overrides, lodash_es__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)
        };
        return (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)({
            from,
            to,
            data,
            value: value ? normalizeHex(value) : undefined,
            chainId: chainId && chainId !== _types_index_js__WEBPACK_IMPORTED_MODULE_7__/* .ChainId */ .a_.Astar ? normalizeHex(chainId) : undefined,
            gas: gas ? normalizeHex(gas) : undefined,
            gasPrice: gasPrice ? normalizeHex(gasPrice) : undefined,
            maxPriorityFeePerGas: maxPriorityFeePerGas ? normalizeHex(maxPriorityFeePerGas) : undefined,
            maxFeePerGas: maxFeePerGas ? normalizeHex(maxFeePerGas) : undefined,
            nonce
        }, lodash_es__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z);
    }
}


/***/ }),

/***/ 21704:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D: () => (/* binding */ ContractTransaction)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(73307);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45911);
/* harmony import */ var web3_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(84976);
/* harmony import */ var web3_utils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(web3_utils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28110);



class ContractTransaction {
    contract;
    constructor(contract){
        this.contract = contract;
    }
    /**
     * Fill the transaction without gas (for calling a readonly transaction)
     * @param transactionResolver
     * @param overrides
     * @returns
     */ fill(transactionResolver, overrides) {
        const transaction = (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_1__/* .resolve */ .D)(transactionResolver, this.contract);
        return (0,lodash_es__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)({
            from: overrides?.from ?? this.contract?.defaultAccount ?? this.contract?.options.from ?? '',
            to: this.contract?.options.address,
            data: transaction?.encodeABI(),
            value: overrides?.value ? (0,web3_utils__WEBPACK_IMPORTED_MODULE_0__.toHex)(overrides.value) : undefined,
            gas: overrides?.gas ? (0,web3_utils__WEBPACK_IMPORTED_MODULE_0__.toHex)(overrides.gas) : undefined,
            gasPrice: overrides?.gasPrice ? (0,web3_utils__WEBPACK_IMPORTED_MODULE_0__.toHex)(overrides.gasPrice) : undefined,
            maxPriorityFeePerGas: overrides?.maxPriorityFeePerGas ? (0,web3_utils__WEBPACK_IMPORTED_MODULE_0__.toHex)(overrides.maxPriorityFeePerGas) : undefined,
            maxFeePerGas: overrides?.maxFeePerGas ? (0,web3_utils__WEBPACK_IMPORTED_MODULE_0__.toHex)(overrides.maxFeePerGas) : undefined,
            nonce: overrides?.nonce ? (0,web3_utils__WEBPACK_IMPORTED_MODULE_0__.toHex)(overrides.nonce) : undefined,
            chainId: overrides?.chainId ? (0,web3_utils__WEBPACK_IMPORTED_MODULE_0__.toHex)(overrides.chainId) : undefined
        }, lodash_es__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z);
    }
    /**
     * Fill the transaction include gas (for sending a payable transaction)
     * @param transactionResolver
     * @param overrides
     * @returns
     */ async fillAll(transactionResolver, overrides) {
        const transaction = (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_1__/* .resolve */ .D)(transactionResolver, this.contract);
        const transactionEncoded = this.fill(transactionResolver, overrides);
        // estimate gas
        if (!transactionEncoded.gas) {
            const gas = await transaction?.estimateGas({
                from: transactionEncoded.from,
                to: transactionEncoded.to,
                data: transactionEncoded.data,
                value: transactionEncoded.value
            });
            if (!gas) throw new Error('Estimate gas failed');
            transactionEncoded.gas = (0,web3_utils__WEBPACK_IMPORTED_MODULE_0__.toHex)(gas);
        }
        return transactionEncoded;
    }
    async send(transactionResolver, overrides) {
        const transaction = (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_1__/* .resolve */ .D)(transactionResolver, this.contract);
        const transactionEncoded = await this.fillAll(transactionResolver, overrides);
        const receipt = await transaction?.send(transactionEncoded);
        return receipt?.transactionHash ?? '';
    }
}


/***/ }),

/***/ 40225:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Q: () => (/* binding */ ErrorEditor)
/* harmony export */ });
/* unused harmony export JSON_RPC_ERROR_CODE */
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70358);

var // https://www.jsonrpc.org/specification#error_object
JSON_RPC_ERROR_CODE;
(function(JSON_RPC_ERROR_CODE) {
    JSON_RPC_ERROR_CODE[JSON_RPC_ERROR_CODE["INVALID_REQUEST"] = -32600] = "INVALID_REQUEST";
    JSON_RPC_ERROR_CODE[JSON_RPC_ERROR_CODE["METHOD_NOT_FOUND"] = 32601] = "METHOD_NOT_FOUND";
    JSON_RPC_ERROR_CODE[JSON_RPC_ERROR_CODE["INVALID_PARAMS"] = -32602] = "INVALID_PARAMS";
    JSON_RPC_ERROR_CODE[JSON_RPC_ERROR_CODE["INTERNAL_ERROR"] = -32603] = "INTERNAL_ERROR";
    JSON_RPC_ERROR_CODE[JSON_RPC_ERROR_CODE["SERVER_ERROR_RANGE_START"] = -32000] = "SERVER_ERROR_RANGE_START";
    JSON_RPC_ERROR_CODE[JSON_RPC_ERROR_CODE["SERVER_ERROR_RANGE_END"] = -32099] = "SERVER_ERROR_RANGE_END";
})(JSON_RPC_ERROR_CODE || (JSON_RPC_ERROR_CODE = {}));
/**
 * JSON RPC Error Editor
 */ class ErrorEditor {
    unknownError;
    response;
    fallback;
    constructor(unknownError, response, fallback){
        this.unknownError = unknownError;
        this.response = response;
        this.fallback = fallback;
    }
    get internalError() {
        {
            const rpcError = this.unknownError;
            if (rpcError instanceof Error && rpcError.message) return rpcError;
            if (rpcError && typeof rpcError.message === 'string') return new Error(rpcError.message);
            if (rpcError && typeof rpcError === 'string') return new Error(rpcError);
        }
        {
            const responseError = this.response?.error;
            if (responseError instanceof Error) return responseError;
            if (responseError && typeof responseError.message === 'string') return new Error(responseError.message);
            if (responseError && typeof responseError === 'string') return new Error(responseError);
        }
        if (this.fallback) return new Error(this.fallback);
        return new Error('Unknown Error.');
    }
    /**
     * At least an error exists.
     */ get presence() {
        return !(0,lodash_es__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this.unknownError) || !(0,lodash_es__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this.response?.error);
    }
    /**
     * Preprocess and normalize the error.
     */ get error() {
        const RecognizableErrorMessage = (()=>{
            const { code, message } = this.internalError;
            if (message.includes(`"code":${JSON_RPC_ERROR_CODE.INTERNAL_ERROR}`)) return 'Transaction was failed due to an internal JSON-RPC server error.';
            if (message.includes('User denied message signature.')) return 'Signature canceled.';
            if (message.includes('User denied transaction signature.')) return 'Transaction was rejected!';
            if (message.includes('transaction underpriced')) return 'Transaction underpriced.';
            if (message.includes('The NFT is bounded to your soul, you cannot transfer it!') || message.match(/Please go to .* for mint/)) {
                return 'This NFT can not be transferred.';
            }
            if (typeof code === 'number' && (code === JSON_RPC_ERROR_CODE.INTERNAL_ERROR || code <= JSON_RPC_ERROR_CODE.SERVER_ERROR_RANGE_START && code >= JSON_RPC_ERROR_CODE.SERVER_ERROR_RANGE_END)) {
                return 'Transaction was failed due to an internal JSON-RPC server error.';
            }
            return undefined;
        })();
        if (RecognizableErrorMessage) {
            const error = new Error(RecognizableErrorMessage);
            error.isRecognized = true;
            return error;
        }
        return new Error(this.internalError.message);
    }
    static fromError(error, fallback) {
        return new ErrorEditor(error, null, fallback);
    }
    static from(error, response, fallback) {
        return new ErrorEditor(error, response, fallback);
    }
}


/***/ }),

/***/ 4070:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ EtherscanURL)
/* harmony export */ });
/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33026);

class EtherscanURL {
    static from(chainId) {
        const { ETHERSCAN_URL = '' } = (0,_constants_index_js__WEBPACK_IMPORTED_MODULE_0__/* .getEtherscanConstants */ .gA)(chainId);
        return ETHERSCAN_URL;
    }
}


/***/ }),

/***/ 61227:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  _: () => (/* binding */ PayloadEditor)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/head.js
var head = __webpack_require__(81755);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/omitBy.js + 1 modules
var omitBy = __webpack_require__(72802);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isUndefined.js
var isUndefined = __webpack_require__(81770);
// EXTERNAL MODULE: ./node_modules/.pnpm/web3-utils@1.10.2/node_modules/web3-utils/lib/index.js
var lib = __webpack_require__(84976);
// EXTERNAL MODULE: ./packages/web3-contracts/abis/Create2Factory.json
var Create2Factory = __webpack_require__(91976);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/isValidChainId.ts
var isValidChainId = __webpack_require__(37049);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/formatter.ts
var formatter = __webpack_require__(41487);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/parseChainId.ts
var parseChainId = __webpack_require__(64371);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/createJsonRpcPayload.ts
var createJsonRpcPayload = __webpack_require__(83135);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/constants/constants.ts
var constants = __webpack_require__(33026);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/constants/primitives.ts
var primitives = __webpack_require__(47469);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/types/index.ts
var types = __webpack_require__(24770);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/abiCoder.ts
var abiCoder = __webpack_require__(1853);
// EXTERNAL MODULE: ./packages/web3-shared/evm/src/helpers/isReadonlyMethodType.ts
var isReadonlyMethodType = __webpack_require__(37911);
;// CONCATENATED MODULE: ./packages/web3-shared/evm/src/helpers/isRiskyMethodType.ts

function isRiskyMethodType(type) {
    return [
        types/* EthereumMethodType */.W8.ETH_SIGN,
        types/* EthereumMethodType */.W8.PERSONAL_SIGN,
        types/* EthereumMethodType */.W8.ETH_SIGN_TYPED_DATA,
        types/* EthereumMethodType */.W8.ETH_DECRYPT,
        types/* EthereumMethodType */.W8.ETH_GET_ENCRYPTION_PUBLIC_KEY,
        types/* EthereumMethodType */.W8.ETH_SEND_TRANSACTION,
        types/* EthereumMethodType */.W8.ETH_SIGN_TRANSACTION,
        types/* EthereumMethodType */.W8.MASK_REPLACE_TRANSACTION
    ].includes(type);
}

;// CONCATENATED MODULE: ./packages/web3-shared/evm/src/libs/PayloadEditor.ts












class PayloadEditor {
    payload;
    options;
    constructor(payload, options){
        this.payload = payload;
        this.options = options;
    }
    get pid() {
        const { id } = this.payload;
        return typeof id === 'string' ? Number.parseInt(id, 10) : id;
    }
    get method() {
        return this.payload.method;
    }
    get params() {
        return this.payload.params ?? [];
    }
    get from() {
        const { method, params } = this.payload;
        switch(method){
            case types/* EthereumMethodType */.W8.ETH_SIGN:
                return (0,head/* default */.Z)(params);
            case types/* EthereumMethodType */.W8.PERSONAL_SIGN:
                return params?.[1];
            case types/* EthereumMethodType */.W8.ETH_SIGN_TYPED_DATA:
                return (0,head/* default */.Z)(params);
            default:
                const config = this.config;
                return config?.from;
        }
    }
    get owner() {
        const { method, params } = this.payload;
        switch(method){
            case types/* EthereumMethodType */.W8.MASK_FUND:
                const [proof] = params;
                const { ownerAddress } = JSON.parse(proof.payload);
                return ownerAddress;
            case types/* EthereumMethodType */.W8.MASK_DEPLOY:
                const [owner] = params;
                return owner;
            default:
                return;
        }
    }
    get identifier() {
        const { method, params } = this.payload;
        switch(method){
            case types/* EthereumMethodType */.W8.MASK_DEPLOY:
                const [_, identifier] = params;
                return identifier;
            default:
                return;
        }
    }
    get chainId() {
        return this.config.chainId ?? this.options?.chainId;
    }
    get chainDescriptor() {
        const { method, params } = this.payload;
        switch(method){
            case types/* EthereumMethodType */.W8.WALLET_ADD_ETHEREUM_CHAIN:
                const [descriptor] = params;
                return descriptor;
            default:
                return null;
        }
    }
    getRawConfig() {
        const { method, params } = this.payload;
        switch(method){
            case types/* EthereumMethodType */.W8.ETH_CALL:
            case types/* EthereumMethodType */.W8.ETH_ESTIMATE_GAS:
            case types/* EthereumMethodType */.W8.ETH_SIGN_TRANSACTION:
            case types/* EthereumMethodType */.W8.ETH_SEND_TRANSACTION:
                return params[0];
            case types/* EthereumMethodType */.W8.MASK_REPLACE_TRANSACTION:
                return params[1];
            case types/* EthereumMethodType */.W8.MASK_DEPLOY:
                {
                    const chainId = this.options?.chainId;
                    if (!(0,isValidChainId/* isValidChainId */.J)(chainId)) throw new Error('Unknown chain id.');
                    const [owner] = params;
                    // compose a fake transaction to be accepted by Transaction Watcher
                    return {
                        from: owner,
                        to: (0,constants/* getSmartPayConstant */.p8)(chainId, 'CREATE2_FACTORY_CONTRACT_ADDRESS'),
                        chainId,
                        data: abiCoder/* abiCoder */.r.encodeFunctionCall(Create2Factory.find((x)=>x.name === 'deploy'), [
                            '0x',
                            (0,lib.toHex)(0)
                        ])
                    };
                }
            case types/* EthereumMethodType */.W8.MASK_FUND:
                {
                    const chainId = this.options?.chainId;
                    if (!(0,isValidChainId/* isValidChainId */.J)(chainId)) throw new Error('Unknown chain id.');
                    const [proof] = params;
                    const { ownerAddress, nonce = 0 } = JSON.parse(proof.payload);
                    // compose a fake transaction to be accepted by Transaction Watcher
                    return {
                        from: ownerAddress,
                        // it's a not-exist address, use the zero address as a placeholder
                        to: primitives/* ZERO_ADDRESS */.r,
                        chainId,
                        data: abiCoder/* abiCoder */.r.encodeFunctionCall(Create2Factory.find((x)=>x.name === 'fund'), [
                            ownerAddress,
                            (0,lib.toHex)(nonce)
                        ])
                    };
                }
            default:
                return;
        }
    }
    get config() {
        const raw = this.getRawConfig();
        return (0,omitBy/* default */.Z)({
            ...raw,
            nonce: parseHexNumber(raw?.nonce),
            from: raw?.from ?? this.options?.account,
            chainId: (0,parseChainId/* parseChainId */.D)(raw?.chainId) ?? this.options?.chainId
        }, isUndefined/* default */.Z);
    }
    get wallet() {
        const { method, params } = this.payload;
        switch(method){
            case types/* EthereumMethodType */.W8.MASK_ADD_WALLET:
                const [wallet] = params;
                return wallet;
            default:
                return;
        }
    }
    get userOperation() {
        const { method, params } = this.payload;
        switch(method){
            case types/* EthereumMethodType */.W8.ETH_CALL_USER_OPERATION:
            case types/* EthereumMethodType */.W8.ETH_SEND_USER_OPERATION:
                const [_, userOperation] = params;
                return userOperation;
            default:
                return;
        }
    }
    get proof() {
        const { method, params } = this.payload;
        switch(method){
            case types/* EthereumMethodType */.W8.MASK_FUND:
                return params[0];
            default:
                return;
        }
    }
    get signableMessage() {
        const { method, params } = this.payload;
        switch(method){
            case types/* EthereumMethodType */.W8.ETH_SIGN:
                return params[1];
            case types/* EthereumMethodType */.W8.PERSONAL_SIGN:
                return params[0];
            case types/* EthereumMethodType */.W8.ETH_SIGN_TYPED_DATA:
                return params[1];
            default:
                return;
        }
    }
    get signableConfig() {
        if (!this.config) return;
        return (0,omitBy/* default */.Z)({
            ...this.config,
            from: this.config.from ? (0,formatter/* formatEthereumAddress */.j8)(this.config.from) : '',
            value: parseHexNumberString(this.config.value),
            gas: parseHexNumberString(this.config.gas),
            gasPrice: parseHexNumberString(this.config.gasPrice),
            maxFeePerGas: parseHexNumberString(this.config.maxFeePerGas),
            maxPriorityFeePerGas: parseHexNumberString(this.config.maxPriorityFeePerGas),
            // TODO: revert to parseHexNumberString after updating MaskCore
            chainId: parseHexNumber(this.config.chainId),
            nonce: parseHexNumberString(this.config.nonce)
        }, isUndefined/* default */.Z);
    }
    get risky() {
        return isRiskyMethodType(this.payload.method);
    }
    get readonly() {
        return (0,isReadonlyMethodType/* isReadonlyMethodType */.q)(this.payload.method);
    }
    fill() {
        return this.payload;
    }
    static from(id, method, params = [], options) {
        return new PayloadEditor((0,createJsonRpcPayload/* createJsonRpcPayload */.B)(id, {
            method,
            params
        }), options);
    }
    static fromMethod(method, params = [], options) {
        return PayloadEditor.from(0, method, params, options);
    }
    static fromPayload(payload, options) {
        return new PayloadEditor(payload, options);
    }
}
function parseHexNumberString(hex) {
    return typeof hex !== 'undefined' ? (0,lib.hexToNumberString)(hex ?? '0x0') : undefined;
}
function parseHexNumber(hex) {
    return typeof hex !== 'undefined' ? (0,lib.hexToNumber)(hex) : undefined;
}


/***/ }),

/***/ 23865:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ ProviderURL)
/* harmony export */ });
/* harmony import */ var _masknet_web3_telemetry_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10666);
/* harmony import */ var _constants_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33026);


class ProviderURL {
    static from(chainId) {
        const { RPC_URLS, RPC_WEIGHTS } = (0,_constants_constants_js__WEBPACK_IMPORTED_MODULE_0__/* .getRPCConstants */ .t0)(chainId);
        if (!RPC_URLS || !RPC_WEIGHTS) throw new Error(`No RPC presets at chainId: ${chainId}.`);
        return RPC_URLS[RPC_WEIGHTS[(0,_masknet_web3_telemetry_helpers__WEBPACK_IMPORTED_MODULE_1__/* .getABTestSeed */ .j)() % RPC_URLS.length]];
    }
    static fromOfficial(chainId) {
        const { RPC_URLS_OFFICIAL } = (0,_constants_constants_js__WEBPACK_IMPORTED_MODULE_0__/* .getRPCConstants */ .t0)(chainId);
        if (!RPC_URLS_OFFICIAL?.length) throw new Error(`No RPC presets at chainId: ${chainId}.`);
        return RPC_URLS_OFFICIAL[0];
    }
}


/***/ }),

/***/ 28775:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E: () => (/* binding */ Signer)
/* harmony export */ });
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(60541);

class Signer {
    identifier;
    sign;
    constructor(identifier, sign){
        this.identifier = identifier;
        this.sign = sign;
    }
    signMessage(message) {
        return this.sign(_masknet_shared_base__WEBPACK_IMPORTED_MODULE_0__/* .SignType */ .A.Message, message, this.identifier);
    }
    signTypedData(data) {
        return this.sign(_masknet_shared_base__WEBPACK_IMPORTED_MODULE_0__/* .SignType */ .A.TypedData, data, this.identifier);
    }
    signTransaction(transaction) {
        return this.sign(_masknet_shared_base__WEBPACK_IMPORTED_MODULE_0__/* .SignType */ .A.Transaction, transaction, this.identifier);
    }
}


/***/ }),

/***/ 54644:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   B: () => (/* binding */ Web3)
/* harmony export */ });
/* harmony import */ var web3_eth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46594);
/* harmony import */ var web3_eth__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(web3_eth__WEBPACK_IMPORTED_MODULE_0__);

/**
 * A Web3 class that is much simpler than the original web3js one.
 */ class Web3 {
    eth = null;
    constructor(provider){
        const Eth_ = (web3_eth__WEBPACK_IMPORTED_MODULE_0___default());
        this.eth = provider ? new Eth_(provider) : new Eth_();
    }
    setProvider(provider) {
        this.eth.setProvider(provider);
    }
}


/***/ }),

/***/ 22905:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  rY: () => (/* binding */ ChainIdList),
  $9: () => (/* binding */ getAuthConstants),
  _x: () => (/* binding */ getTokenConstant),
  aV: () => (/* binding */ getTokenConstants)
});

// UNUSED EXPORTS: getAuthConstant, getChainConstant, getChainConstants, useAuthConstant, useAuthConstants, useChainConstant, useChainConstants, useTokenConstant, useTokenConstants

// EXTERNAL MODULE: ./node_modules/.pnpm/@masknet+kit@0.1.2/node_modules/@masknet/kit/esm/index.js + 1 modules
var esm = __webpack_require__(30898);
;// CONCATENATED MODULE: ./packages/web3-constants/flow/auth.json
const auth_namespaceObject = JSON.parse('{"ACCESS_NODE_API":{"Mainnet":"https://rest-mainnet.onflow.org","Testnet":"https://rest-testnet.onflow.org"},"DISCOVERY_WALLET":{"Mainnet":"https://wallet-v2.blocto.app/5b2f59b4-3f87-471a-a784-0023725bc535/flow/authn","Testnet":"https://wallet-v2.blocto.app/5b2f59b4-3f87-471a-a784-0023725bc535/flow/authn"},"MASK_APP_ID":{"Mainnet":"5b2f59b4-3f87-471a-a784-0023725bc535","Testnet":"5b2f59b4-3f87-471a-a784-0023725bc535"},"MASK_APP_TITLE":{"Mainnet":"Mask Network","Testnet":"Mask Network (Dev)"},"MASK_APP_ICON":{"Mainnet":"https://dimensiondev.github.io/Mask-VI/assets/Logo/MB--Logo--Geo--ForceCircle--Blue.svg","Testnet":"https://dimensiondev.github.io/Mask-VI/assets/Logo/MB--Logo--Geo--ForceCircle--Blue.svg"}}');
;// CONCATENATED MODULE: ./packages/web3-constants/flow/chain.json
const chain_namespaceObject = JSON.parse('{"NAME":{"Mainnet":"Flow","Testnet":"Flow Testnet"},"FULL_NAME":{"Mainnet":"Flow","Testnet":"Flow Testnet"},"SHORT_NAME":{"Mainnet":"FCL","Testnet":"FCL"},"COLOR":{"Mainnet":"#34d399","Testnet":"#34d399"}}');
;// CONCATENATED MODULE: ./packages/web3-constants/flow/token.json
const token_namespaceObject = JSON.parse('{"FLOW_ADDRESS":{"Mainnet":"A.1654653399040a61.FlowToken"},"FUSD_ADDRESS":{"Mainnet":"A.3c5959b568896393.FUSD","Testnet":"A.e223d8a629e49c68.FUSD"},"TETHER_ADDRESS":{"Mainnet":"A.cfdd90d4a00f7b5b.TeleportedTetherToken"},"FUNGIBLE_TOKEN_ADDRESS":{"Mainnet":"A.f233dcee88fe0abe.FungibleToken","Testnet":"0x9a0766d93b6608b7"}}');
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/constant.ts
var constant = __webpack_require__(22563);
// EXTERNAL MODULE: ./packages/web3-shared/flow/src/types.ts
var types = __webpack_require__(59190);
;// CONCATENATED MODULE: ./packages/web3-shared/flow/src/constants/constants.ts






const ChainIdList = (0,esm/* getEnumAsArray */.Yl)(types/* ChainId */.a_).map((x)=>x.value);
const getAuthConstants = (0,constant/* transformAll */.YV)(types/* ChainId */.a_, auth_namespaceObject);
const getAuthConstant = (0,constant/* transform */.vs)(types/* ChainId */.a_, auth_namespaceObject);
const useAuthConstants = (0,constant/* transformAllHook */.H$)(getAuthConstants);
const useAuthConstant = (0,constant/* transformHook */.__)(getAuthConstants);
const getChainConstants = (0,constant/* transformAll */.YV)(types/* ChainId */.a_, chain_namespaceObject);
const getChainConstant = (0,constant/* transform */.vs)(types/* ChainId */.a_, chain_namespaceObject);
const useChainConstants = (0,constant/* transformAllHook */.H$)(getChainConstants);
const useChainConstant = (0,constant/* transformHook */.__)(getChainConstants);
const getTokenConstants = (0,constant/* transformAll */.YV)(types/* ChainId */.a_, token_namespaceObject);
const getTokenConstant = (0,constant/* transform */.vs)(types/* ChainId */.a_, token_namespaceObject);
const useTokenConstants = (0,constant/* transformAllHook */.H$)(getTokenConstants);
const useTokenConstant = (0,constant/* transformHook */.__)(getTokenConstants);


/***/ }),

/***/ 81545:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Q_: () => (/* binding */ CHAIN_DESCRIPTORS),
/* harmony export */   qQ: () => (/* binding */ NETWORK_DESCRIPTORS),
/* harmony export */   zM: () => (/* binding */ PROVIDER_DESCRIPTORS)
/* harmony export */ });
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24835);
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(68422);
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(77199);
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(59190);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(22905);




const PLUGIN_ID = _masknet_shared_base__WEBPACK_IMPORTED_MODULE_0__/* .NetworkPluginID */ .F.PLUGIN_FLOW;
const CHAIN_DESCRIPTORS = [
    {
        ID: `${_types_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet}_Flow`,
        type: _types_js__WEBPACK_IMPORTED_MODULE_1__/* .NetworkType */ .td.Flow,
        chainId: _types_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet,
        coinMarketCapChainId: '',
        coinGeckoChainId: '',
        coinGeckoPlatformId: '',
        name: 'Flow',
        color: '#16ff99',
        fullName: 'Flow',
        shortName: 'Flow',
        network: 'mainnet',
        nativeCurrency: (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .createFungibleToken */ .mn)(_types_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet, _types_js__WEBPACK_IMPORTED_MODULE_1__/* .SchemaType */ .XQ.Fungible, '0x1654653399040a61', 'Flow', 'FLOW', 8, 'https://static.flowscan.org/mainnet/icons/A.1654653399040a61.FlowToken.png'),
        explorerUrl: {
            url: 'https://flowscan.org/'
        },
        rpcUrl: '',
        isCustomized: false
    },
    {
        ID: `${_types_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Testnet}_Flow`,
        type: _types_js__WEBPACK_IMPORTED_MODULE_1__/* .NetworkType */ .td.Flow,
        chainId: _types_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Testnet,
        coinMarketCapChainId: '',
        coinGeckoChainId: '',
        coinGeckoPlatformId: '',
        name: 'Flow',
        color: '#16ff99',
        fullName: 'Flow',
        shortName: 'Flow',
        network: 'testnet',
        nativeCurrency: (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .createFungibleToken */ .mn)(_types_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet, _types_js__WEBPACK_IMPORTED_MODULE_1__/* .SchemaType */ .XQ.Fungible, '0x7e60df042a9c0868', 'Flow', 'FLOW', 8, 'https://static.flowscan.org/mainnet/icons/A.1654653399040a61.FlowToken.png'),
        explorerUrl: {
            url: 'https://testnet.flowscan.org/'
        },
        rpcUrl: '',
        isCustomized: false
    }
];
const NETWORK_DESCRIPTORS = [
    {
        ID: `${PLUGIN_ID}_flow`,
        networkSupporterPluginID: PLUGIN_ID,
        chainId: _types_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet,
        type: _types_js__WEBPACK_IMPORTED_MODULE_1__/* .NetworkType */ .td.Flow,
        name: 'Flow',
        icon: new URL(/* asset import */ __webpack_require__(78546), __webpack_require__.b).href,
        iconColor: 'rgb(54, 173, 104)',
        averageBlockDelay: 15,
        isMainnet: true
    },
    {
        ID: `${PLUGIN_ID}_flow_testnet`,
        networkSupporterPluginID: PLUGIN_ID,
        chainId: _types_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Testnet,
        type: _types_js__WEBPACK_IMPORTED_MODULE_1__/* .NetworkType */ .td.Flow,
        name: 'Flow Testnet',
        icon: new URL(/* asset import */ __webpack_require__(78546), __webpack_require__.b).href,
        iconColor: 'rgb(54, 173, 104)',
        averageBlockDelay: 15,
        isMainnet: false
    }
];
const PROVIDER_DESCRIPTORS = [
    {
        ID: `${PLUGIN_ID}_blocto`,
        providerAdaptorPluginID: PLUGIN_ID,
        type: _types_js__WEBPACK_IMPORTED_MODULE_1__/* .ProviderType */ .lP.Blocto,
        name: 'Blocto',
        icon: new URL(/* asset import */ __webpack_require__(83409), __webpack_require__.b).href,
        iconFilterColor: 'rgba(52, 133, 196, 0.2)',
        backgroundGradient: 'linear-gradient(90deg, rgba(52, 133, 196, 0.2) 0%, rgba(0, 239, 139, 0.2) 100%), linear-gradient(0deg, #FFFFFF, #FFFFFF)',
        homeLink: 'https://portto.com/',
        shortenLink: 'portto.com',
        enableRequirements: {
            supportedChainIds: _constants_js__WEBPACK_IMPORTED_MODULE_3__/* .ChainIdList */ .rY,
            supportedEnhanceableSites: _masknet_shared_base__WEBPACK_IMPORTED_MODULE_4__/* .EnhanceableSiteList */ .LP,
            supportedExtensionSites: _masknet_shared_base__WEBPACK_IMPORTED_MODULE_4__/* .ExtensionSiteList */ .gD
        }
    }
];


/***/ }),

/***/ 44050:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Tg: () => (/* binding */ formatAddress),
  Xy: () => (/* binding */ formatTokenId),
  CR: () => (/* binding */ getContractAddress),
  tA: () => (/* binding */ getDefaultChainId),
  H2: () => (/* binding */ getDefaultNetworkType),
  Xo: () => (/* binding */ getDefaultProviderType),
  p6: () => (/* binding */ getInvalidChainId),
  vY: () => (/* binding */ getMaskTokenAddress),
  rG: () => (/* binding */ getNativeTokenAddress),
  yg: () => (/* binding */ getNetworkPluginID),
  R6: () => (/* binding */ getZeroAddress),
  qw: () => (/* binding */ isNativeTokenAddress),
  At: () => (/* binding */ isValidAddress),
  JW: () => (/* binding */ isValidChainId),
  uO: () => (/* binding */ isZeroAddress)
});

// UNUSED EXPORTS: isValidAccountAddress, isValidContractAddress

// EXTERNAL MODULE: ./node_modules/.pnpm/@masknet+kit@0.1.2/node_modules/@masknet/kit/esm/index.js + 1 modules
var esm = __webpack_require__(30898);
// EXTERNAL MODULE: ./packages/shared-base/src/types/PluginID.ts
var PluginID = __webpack_require__(24835);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/isSameAddress.ts
var isSameAddress = __webpack_require__(74765);
// EXTERNAL MODULE: ./packages/web3-shared/flow/src/constants/constants.ts + 3 modules
var constants = __webpack_require__(22905);
;// CONCATENATED MODULE: ./packages/web3-shared/flow/src/constants/primitives.ts
const ZERO_ADDRESS = '0x0000000000000000';

// EXTERNAL MODULE: ./packages/web3-shared/flow/src/types.ts
var types = __webpack_require__(59190);
;// CONCATENATED MODULE: ./packages/web3-shared/flow/src/helpers/address.ts






function formatAddress(address, size = 0) {
    const format = (partial)=>{
        if (size === 0 || size >= 8) return partial;
        return `${partial.slice(0, Math.max(0, 2 + size))}...${partial.slice(-size)}`;
    };
    if (isValidAccountAddress(address)) return format(address);
    if (isValidContractAddress(address)) return format(`0x${address.split(/\./g)[1]}`);
    return address;
}
function formatTokenId(id) {
    return `#${id}`;
}
function isValidAccountAddress(address) {
    return /0x\w{16}/.test(address);
}
function isValidContractAddress(address) {
    return /A\.\w{16}\.\w+/.test(address);
}
function isValidAddress(address) {
    if (!address) return false;
    return isValidAccountAddress(address) || isValidContractAddress(address);
}
function isValidChainId(chainId) {
    return (0,esm/* getEnumAsArray */.Yl)(types/* ChainId */.a_).some((x)=>x.value === chainId);
}
function getNetworkPluginID() {
    return PluginID/* NetworkPluginID */.F.PLUGIN_FLOW;
}
function getDefaultChainId() {
    return types/* ChainId */.a_.Mainnet;
}
function getInvalidChainId() {
    return types/* ChainId */.a_.Invalid;
}
function getDefaultNetworkType() {
    return types/* NetworkType */.td.Flow;
}
function getDefaultProviderType() {
    return types/* ProviderType */.lP.None;
}
function getZeroAddress() {
    return ZERO_ADDRESS;
}
function getContractAddress(address) {
    if (isValidContractAddress(address)) {
        const [_, contractAddress, ...identifierFragments] = address.split(/\./g);
        return {
            address: `0x${contractAddress}`,
            identifier: identifierFragments.join('.')
        };
    }
    return;
}
function getNativeTokenAddress(chainId = types/* ChainId */.a_.Mainnet) {
    return (0,constants/* getTokenConstant */._x)(chainId, 'FLOW_ADDRESS');
}
function getMaskTokenAddress(chainId = types/* ChainId */.a_.Mainnet) {
    return '';
}
function isZeroAddress(address) {
    return (0,isSameAddress/* isSameAddress */.W)(address, ZERO_ADDRESS);
}
function isNativeTokenAddress(address) {
    const set = new Set((0,esm/* getEnumAsArray */.Yl)(types/* ChainId */.a_).map((x)=>(0,constants/* getTokenConstant */._x)(x.value, 'FLOW_ADDRESS')));
    return !!(address && set.has(address));
}


/***/ }),

/***/ 68169:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bc: () => (/* binding */ formatDomainName),
/* harmony export */   hS: () => (/* binding */ isValidDomain),
/* harmony export */   sB: () => (/* binding */ formatSchemaType)
/* harmony export */ });
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74170);
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(59190);


function formatDomainName(domain, size) {
    return domain ?? '';
}
const formatSchemaType = (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_0__/* .createLookupTableResolver */ .F)({
    [_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SchemaType */ .XQ.Fungible]: 'Fungible',
    [_types_js__WEBPACK_IMPORTED_MODULE_1__/* .SchemaType */ .XQ.NonFungible]: 'NonFungible'
}, '');
function isValidDomain(domain) {
    return false;
}


/***/ }),

/***/ 5799:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SC: () => (/* binding */ isNativeTokenSchemaType),
/* harmony export */   V2: () => (/* binding */ isNonFungibleTokenSchemaType),
/* harmony export */   kI: () => (/* binding */ createFungibleAsset),
/* harmony export */   kL: () => (/* binding */ isFungibleTokenSchemaType),
/* harmony export */   mn: () => (/* binding */ createFungibleToken)
/* harmony export */ });
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(77199);
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29763);
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(62649);
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(59190);


function createFungibleToken(chainId, address, name, symbol, decimals, logoURL) {
    return (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_0__/* .createFungibleToken */ .mn)(chainId, _types_js__WEBPACK_IMPORTED_MODULE_1__/* .SchemaType */ .XQ.Fungible, address, name, symbol, decimals, logoURL);
}
function createFungibleAsset(token, balance, price) {
    return {
        ...token,
        balance: (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .leftShift */ .w5)(balance, 8).toFixed(),
        price,
        value: {
            [_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_3__/* .CurrencyType */ .V2.USD]: (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .multipliedBy */ .$q)(price?.usd ?? 0, (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .leftShift */ .w5)(balance, 8)).toFixed()
        }
    };
}
function isNativeTokenSchemaType(schemaType) {
    // there is no native token schema on flow network
    return false;
}
function isFungibleTokenSchemaType(schemaType) {
    return schemaType === _types_js__WEBPACK_IMPORTED_MODULE_1__/* .SchemaType */ .XQ.Fungible;
}
function isNonFungibleTokenSchemaType(schemaType) {
    return schemaType === _types_js__WEBPACK_IMPORTED_MODULE_1__/* .SchemaType */ .XQ.NonFungible;
}


/***/ }),

/***/ 35401:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var _blocto_fcl__WEBPACK_IMPORTED_MODULE_0___deferred_namespace_cache;
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   e: () => (/* binding */ createClient)
/* harmony export */ });
/* deferred harmony import */ var _blocto_fcl__WEBPACK_IMPORTED_MODULE_0__ = {
	/* namespace */ get a() {
		var exports = __webpack_require__(11513);
		Object.defineProperty(this, "a", { value: exports });
		return exports;
	}

};
/* harmony import */ var _constants_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(22905);


function createClient(chainId) {
    const authConstants = (0,_constants_constants_js__WEBPACK_IMPORTED_MODULE_1__/* .getAuthConstants */ .$9)(chainId);
    _blocto_fcl__WEBPACK_IMPORTED_MODULE_0__.a.config({
        'flow.network': 'mainnet',
        'accessNode.api': authConstants.ACCESS_NODE_API,
        'discovery.wallet': authConstants.DISCOVERY_WALLET,
        'app.detail.title': authConstants.MASK_APP_TITLE,
        'app.detail.icon': authConstants.MASK_APP_ICON
    });
    return /*#__PURE__*/ (_blocto_fcl__WEBPACK_IMPORTED_MODULE_0___deferred_namespace_cache || (_blocto_fcl__WEBPACK_IMPORTED_MODULE_0___deferred_namespace_cache = __webpack_require__.z(11513, /* namespace */ 0)));
}


/***/ }),

/***/ 59190:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DL: () => (/* binding */ AddressType),
/* harmony export */   GB: () => (/* binding */ TransactionStatusCode),
/* harmony export */   XQ: () => (/* binding */ SchemaType),
/* harmony export */   a_: () => (/* binding */ ChainId),
/* harmony export */   lP: () => (/* binding */ ProviderType),
/* harmony export */   td: () => (/* binding */ NetworkType)
/* harmony export */ });
/* unused harmony export AssetProviderType */
var /// <reference path="./blocto-fcl.d.ts" />
/// <reference types="@masknet/global-types/webpack" />
ChainId;
(function(ChainId) {
    ChainId[ChainId[// For any chains not supported yet.
    "Invalid"] = 0] = "Invalid";
    ChainId[ChainId["Mainnet"] = 1] = "Mainnet";
    ChainId[ChainId["Testnet"] = 2] = "Testnet";
})(ChainId || (ChainId = {}));
var AddressType;
(function(AddressType) {
    AddressType[AddressType["Default"] = 1] = "Default";
})(AddressType || (AddressType = {}));
var SchemaType;
(function(SchemaType) {
    SchemaType[SchemaType["Fungible"] = 1] = "Fungible";
    SchemaType[SchemaType["NonFungible"] = 2] = "NonFungible";
})(SchemaType || (SchemaType = {}));
var NetworkType;
(function(NetworkType) {
    NetworkType["Flow"] = "Flow";
})(NetworkType || (NetworkType = {}));
var ProviderType;
(function(ProviderType) {
    ProviderType["None"] = "None";
    ProviderType["Blocto"] = "Blocto";
    ProviderType["Dapper"] = "Dapper";
    ProviderType["Ledger"] = "Ledger";
})(ProviderType || (ProviderType = {}));
var AssetProviderType;
(function(AssetProviderType) {
    AssetProviderType["Default"] = "Default";
})(AssetProviderType || (AssetProviderType = {}));
var TransactionStatusCode;
(function(TransactionStatusCode) {
    TransactionStatusCode[TransactionStatusCode["UNKNOWN"] = 0] = "UNKNOWN";
    TransactionStatusCode[TransactionStatusCode[/** Transaction Pending - Awaiting Finalization */ "PENDING"] = 1] = "PENDING";
    TransactionStatusCode[TransactionStatusCode[/** Transaction Finalized - Awaiting Execution */ "FINALIZED"] = 2] = "FINALIZED";
    TransactionStatusCode[TransactionStatusCode[/** Transaction Executed - Awaiting Sealing */ "EXECUTED"] = 3] = "EXECUTED";
    TransactionStatusCode[TransactionStatusCode[/** Transaction Sealed - Transaction Complete. At this point the transaction * result has been committed to the blockchain. */ "SEALED"] = 4] = "SEALED";
    TransactionStatusCode[TransactionStatusCode[/** Transaction Expired */ "EXPIRED"] = 5] = "EXPIRED";
})(TransactionStatusCode || (TransactionStatusCode = {}));


/***/ }),

/***/ 45118:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  rY: () => (/* binding */ ChainIdList),
  V6: () => (/* binding */ getCoinGeckoConstants),
  _x: () => (/* binding */ getTokenConstant),
  Hi: () => (/* binding */ getTokenListConstants)
});

// UNUSED EXPORTS: getChainConstant, getChainConstants, getCoinGeckoConstant, getTokenConstants, getTokenListConstant, useChainConstant, useChainConstants, useCoinGeckoConstant, useCoinGeckoConstants, useTokenConstant, useTokenConstants

// EXTERNAL MODULE: ./node_modules/.pnpm/@masknet+kit@0.1.2/node_modules/@masknet/kit/esm/index.js + 1 modules
var esm = __webpack_require__(30898);
;// CONCATENATED MODULE: ./packages/web3-constants/solana/chain.json
const chain_namespaceObject = JSON.parse('{"NAME":{"Mainnet":"Solana","Testnet":"Solana Testnet","Devnet":"Solana Devnet"},"FULL_NAME":{"Mainnet":"Solana","Testnet":"Solana Testnet","Devnet":"Solana Devnet"},"SHORT_NAME":{"Mainnet":"SOL","Testnet":"SOL","Devnet":"SOL"},"COLOR":{"Mainnet":"#25c2a0","Testnet":"#25c2a0","Devnet":"#25c2a0"}}');
;// CONCATENATED MODULE: ./packages/web3-constants/solana/coingecko.json
const coingecko_namespaceObject = JSON.parse('{"PLATFORM_ID":{"Mainnet":"solana"},"COIN_ID":{"Mainnet":"solana"}}');
;// CONCATENATED MODULE: ./packages/web3-constants/solana/token-list.json
const token_list_namespaceObject = JSON.parse('{"FUNGIBLE_TOKEN_LISTS":{"Mainnet":["https://tokens.r2d2.to/latest/solana/tokens.json"],"Testnet":[],"Devnet":[]}}');
;// CONCATENATED MODULE: ./packages/web3-constants/solana/token.json
const token_namespaceObject = JSON.parse('{"USDC_ADDRESS":{"Mainnet":"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v","Testnet":"CpMah17kQEL2wqyMKt3mZBdTnZbkbfx4nqmQMFDP5vwp"},"SOL_ADDRESS":{"Mainnet":"So11111111111111111111111111111111111111112","Testnet":"So11111111111111111111111111111111111111112","Devnet":"So11111111111111111111111111111111111111112"}}');
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/constant.ts
var constant = __webpack_require__(22563);
// EXTERNAL MODULE: ./packages/web3-shared/solana/src/types.ts
var types = __webpack_require__(97834);
;// CONCATENATED MODULE: ./packages/web3-shared/solana/src/constants/constants.ts







const ChainIdList = (0,esm/* getEnumAsArray */.Yl)(types/* ChainId */.a_).map((x)=>x.value);
const getTokenConstant = (0,constant/* transform */.vs)(types/* ChainId */.a_, token_namespaceObject);
const getTokenConstants = (0,constant/* transformAll */.YV)(types/* ChainId */.a_, token_namespaceObject);
const useTokenConstants = (0,constant/* transformAllHook */.H$)(getTokenConstants);
const useTokenConstant = (0,constant/* transformHook */.__)(getTokenConstants);
const getTokenListConstant = (0,constant/* transform */.vs)(types/* ChainId */.a_, token_list_namespaceObject);
const getTokenListConstants = (0,constant/* transformAll */.YV)(types/* ChainId */.a_, token_list_namespaceObject);
const getChainConstant = (0,constant/* transform */.vs)(types/* ChainId */.a_, chain_namespaceObject);
const getChainConstants = (0,constant/* transformAll */.YV)(types/* ChainId */.a_, chain_namespaceObject);
const useChainConstants = (0,constant/* transformAllHook */.H$)(getChainConstants);
const useChainConstant = (0,constant/* transformHook */.__)(getChainConstants);
const getCoinGeckoConstant = (0,constant/* transform */.vs)(types/* ChainId */.a_, coingecko_namespaceObject);
const getCoinGeckoConstants = (0,constant/* transformAll */.YV)(types/* ChainId */.a_, coingecko_namespaceObject);
const useCoinGeckoConstants = (0,constant/* transformAllHook */.H$)(getCoinGeckoConstants);
const useCoinGeckoConstant = (0,constant/* transformHook */.__)(getCoinGeckoConstants);


/***/ }),

/***/ 93221:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Q_: () => (/* binding */ CHAIN_DESCRIPTORS),
/* harmony export */   qQ: () => (/* binding */ NETWORK_DESCRIPTORS),
/* harmony export */   zM: () => (/* binding */ PROVIDER_DESCRIPTORS)
/* harmony export */ });
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24835);
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(68422);
/* harmony import */ var _masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(77199);
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(97834);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45118);




const PLUGIN_ID = _masknet_shared_base__WEBPACK_IMPORTED_MODULE_0__/* .NetworkPluginID */ .F.PLUGIN_SOLANA;
const CHAIN_DESCRIPTORS = [
    {
        ID: `${_types_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet}_Solana`,
        type: _types_js__WEBPACK_IMPORTED_MODULE_1__/* .NetworkType */ .td.Solana,
        chainId: _types_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet,
        coinMarketCapChainId: '',
        coinGeckoChainId: '',
        coinGeckoPlatformId: '',
        name: 'Solana',
        color: '#17ac7c',
        fullName: 'Solana',
        shortName: 'Solana',
        network: 'mainnet',
        nativeCurrency: (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .createFungibleToken */ .mn)(_types_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet, _types_js__WEBPACK_IMPORTED_MODULE_1__/* .SchemaType */ .XQ.Fungible, (0,_constants_js__WEBPACK_IMPORTED_MODULE_3__/* .getTokenConstant */ ._x)(_types_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet, 'SOL_ADDRESS', ''), 'Solana', 'SOL', 9, 'https://assets.coingecko.com/coins/images/4128/small/solana.png'),
        explorerUrl: {
            url: 'https://explorer.solana.com/'
        },
        rpcUrl: '',
        iconUrl: new URL(/* asset import */ __webpack_require__(8277), __webpack_require__.b).href,
        isCustomized: false
    },
    {
        ID: `${_types_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Devnet}_Solana`,
        type: _types_js__WEBPACK_IMPORTED_MODULE_1__/* .NetworkType */ .td.Solana,
        chainId: _types_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Devnet,
        coinMarketCapChainId: '',
        coinGeckoChainId: '',
        coinGeckoPlatformId: '',
        name: 'Solana',
        color: '#17ac7c',
        fullName: 'Solana',
        shortName: 'Solana',
        network: 'devnet',
        nativeCurrency: (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .createFungibleToken */ .mn)(_types_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Devnet, _types_js__WEBPACK_IMPORTED_MODULE_1__/* .SchemaType */ .XQ.Fungible, (0,_constants_js__WEBPACK_IMPORTED_MODULE_3__/* .getTokenConstant */ ._x)(_types_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Devnet, 'SOL_ADDRESS', ''), 'Solana', 'SOL', 9, 'https://assets.coingecko.com/coins/images/4128/small/solana.png'),
        explorerUrl: {
            url: 'https://explorer.solana.com/',
            parameters: {
                cluster: 'devnet'
            }
        },
        rpcUrl: '',
        iconUrl: new URL(/* asset import */ __webpack_require__(8277), __webpack_require__.b).href,
        isCustomized: false
    },
    {
        ID: `${_types_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Testnet}_Solana`,
        type: _types_js__WEBPACK_IMPORTED_MODULE_1__/* .NetworkType */ .td.Solana,
        chainId: _types_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Testnet,
        coinMarketCapChainId: '',
        coinGeckoChainId: '',
        coinGeckoPlatformId: '',
        name: 'Solana',
        color: '#17ac7c',
        fullName: 'Solana',
        shortName: 'Solana',
        network: 'testnet',
        nativeCurrency: (0,_masknet_web3_shared_base__WEBPACK_IMPORTED_MODULE_2__/* .createFungibleToken */ .mn)(_types_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Testnet, _types_js__WEBPACK_IMPORTED_MODULE_1__/* .SchemaType */ .XQ.Fungible, (0,_constants_js__WEBPACK_IMPORTED_MODULE_3__/* .getTokenConstant */ ._x)(_types_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Testnet, 'SOL_ADDRESS', ''), 'Solana', 'SOL', 9, 'https://assets.coingecko.com/coins/images/4128/small/solana.png'),
        explorerUrl: {
            url: 'https://explorer.solana.com/',
            parameters: {
                cluster: 'testnet'
            }
        },
        rpcUrl: '',
        iconUrl: new URL(/* asset import */ __webpack_require__(8277), __webpack_require__.b).href,
        isCustomized: false
    }
];
const NETWORK_DESCRIPTORS = [
    {
        ID: `${PLUGIN_ID}_solana`,
        networkSupporterPluginID: PLUGIN_ID,
        chainId: _types_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet,
        type: _types_js__WEBPACK_IMPORTED_MODULE_1__/* .NetworkType */ .td.Solana,
        name: 'Solana',
        icon: new URL(/* asset import */ __webpack_require__(8277), __webpack_require__.b).href,
        iconColor: '#5d6fc0',
        averageBlockDelay: 15,
        isMainnet: true
    },
    {
        ID: `${PLUGIN_ID}_solana_testnet`,
        networkSupporterPluginID: PLUGIN_ID,
        chainId: _types_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Testnet,
        type: _types_js__WEBPACK_IMPORTED_MODULE_1__/* .NetworkType */ .td.Solana,
        name: 'Solana Testnet',
        icon: new URL(/* asset import */ __webpack_require__(8277), __webpack_require__.b).href,
        iconColor: '#5d6fc0',
        averageBlockDelay: 15,
        isMainnet: false
    }
];
const PROVIDER_DESCRIPTORS = [
    {
        ID: `${PLUGIN_ID}_phantom`,
        providerAdaptorPluginID: PLUGIN_ID,
        type: _types_js__WEBPACK_IMPORTED_MODULE_1__/* .ProviderType */ .lP.Phantom,
        name: 'Phantom',
        icon: new URL(/* asset import */ __webpack_require__(16474), __webpack_require__.b).href,
        homeLink: 'https://phantom.app/',
        shortenLink: 'phantom.app',
        downloadLink: 'https://phantom.app/download',
        enableRequirements: {
            supportedChainIds: _constants_js__WEBPACK_IMPORTED_MODULE_3__/* .ChainIdList */ .rY,
            supportedEnhanceableSites: _masknet_shared_base__WEBPACK_IMPORTED_MODULE_4__/* .EnhanceableSiteList */ .LP,
            supportedExtensionSites: []
        },
        iconFilterColor: 'rgba(85, 27, 249, 0.2)',
        backgroundGradient: 'linear-gradient(90deg, rgba(84, 63, 196, 0.2) 0%, rgba(98, 126, 234, 0.2) 100%), linear-gradient(0deg, #FFFFFF, #FFFFFF)'
    },
    {
        ID: `${PLUGIN_ID}_solflare`,
        providerAdaptorPluginID: PLUGIN_ID,
        type: _types_js__WEBPACK_IMPORTED_MODULE_1__/* .ProviderType */ .lP.Solflare,
        name: 'Solflare',
        icon: new URL(/* asset import */ __webpack_require__(52201), __webpack_require__.b).href,
        homeLink: 'https://solflare.com/',
        shortenLink: 'solflare.com',
        downloadLink: 'https://solflare.com/download',
        enableRequirements: {
            supportedChainIds: _constants_js__WEBPACK_IMPORTED_MODULE_3__/* .ChainIdList */ .rY,
            supportedEnhanceableSites: [],
            supportedExtensionSites: []
        }
    },
    {
        ID: `${PLUGIN_ID}_coin98`,
        providerAdaptorPluginID: PLUGIN_ID,
        type: _types_js__WEBPACK_IMPORTED_MODULE_1__/* .ProviderType */ .lP.Coin98,
        name: 'Coin98',
        icon: new URL(/* asset import */ __webpack_require__(13292), __webpack_require__.b).href,
        homeLink: 'https://coin98.com/',
        shortenLink: 'solflare.com',
        downloadLink: 'https://coin98.com/wallet',
        enableRequirements: {
            supportedChainIds: _constants_js__WEBPACK_IMPORTED_MODULE_3__/* .ChainIdList */ .rY,
            supportedEnhanceableSites: [],
            supportedExtensionSites: []
        }
    },
    {
        ID: `${PLUGIN_ID}_sollet`,
        providerAdaptorPluginID: PLUGIN_ID,
        type: _types_js__WEBPACK_IMPORTED_MODULE_1__/* .ProviderType */ .lP.Sollet,
        name: 'Sollet',
        icon: new URL(/* asset import */ __webpack_require__(25170), __webpack_require__.b).href,
        homeLink: 'https://www.sollet.io/',
        shortenLink: 'sollet.io',
        downloadLink: 'https://www.sollet.io/',
        enableRequirements: {
            supportedChainIds: _constants_js__WEBPACK_IMPORTED_MODULE_3__/* .ChainIdList */ .rY,
            supportedEnhanceableSites: [],
            supportedExtensionSites: _masknet_shared_base__WEBPACK_IMPORTED_MODULE_4__/* .ExtensionSiteList */ .gD
        }
    }
];


/***/ }),

/***/ 97470:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  mV: () => (/* binding */ decodeAddress),
  Tg: () => (/* binding */ formatAddress),
  sB: () => (/* binding */ formatSchemaType),
  Xy: () => (/* binding */ formatTokenId),
  tA: () => (/* binding */ getDefaultChainId),
  H2: () => (/* binding */ getDefaultNetworkType),
  Xo: () => (/* binding */ getDefaultProviderType),
  p6: () => (/* binding */ getInvalidChainId),
  vY: () => (/* binding */ getMaskTokenAddress),
  rG: () => (/* binding */ getNativeTokenAddress),
  yg: () => (/* binding */ getNetworkPluginID),
  R6: () => (/* binding */ getZeroAddress),
  qw: () => (/* binding */ isNativeTokenAddress),
  At: () => (/* binding */ isValidAddress),
  JW: () => (/* binding */ isValidChainId),
  uO: () => (/* binding */ isZeroAddress)
});

// UNUSED EXPORTS: encodePublicKey

// EXTERNAL MODULE: ./node_modules/.pnpm/bs58@5.0.0/node_modules/bs58/index.js
var bs58 = __webpack_require__(18705);
var bs58_default = /*#__PURE__*/__webpack_require__.n(bs58);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/memoize.js
var memoize = __webpack_require__(43434);
// EXTERNAL MODULE: ./node_modules/.pnpm/@solana+web3.js@1.75.0/node_modules/@solana/web3.js/lib/index.browser.esm.js
var index_browser_esm = __webpack_require__(20374);
// EXTERNAL MODULE: ./node_modules/.pnpm/@masknet+kit@0.1.2/node_modules/@masknet/kit/esm/index.js + 1 modules
var esm = __webpack_require__(30898);
// EXTERNAL MODULE: ./packages/web3-shared/base/src/helpers/isSameAddress.ts
var isSameAddress = __webpack_require__(74765);
// EXTERNAL MODULE: ./packages/shared-base/src/helpers/createLookupTableResolver.ts
var createLookupTableResolver = __webpack_require__(74170);
// EXTERNAL MODULE: ./packages/shared-base/src/types/PluginID.ts
var PluginID = __webpack_require__(24835);
// EXTERNAL MODULE: ./packages/web3-shared/solana/src/types.ts
var types = __webpack_require__(97834);
// EXTERNAL MODULE: ./packages/web3-shared/solana/src/constants/constants.ts + 4 modules
var constants = __webpack_require__(45118);
;// CONCATENATED MODULE: ./packages/web3-shared/solana/src/constants/primitives.ts
const ZERO_ADDRESS = '';

;// CONCATENATED MODULE: ./packages/web3-shared/solana/src/helpers/isTronAddress.ts
function isTronAddress(address) {
    return /^T[1-9A-HJ-NP-Za-km-z]{32,42}$|^T9[1-9A-HJ-NP-Za-km-z]{32,41}$/.test(address);
}

;// CONCATENATED MODULE: ./packages/web3-shared/solana/src/helpers/address.ts










function encodePublicKey(key) {
    return key.toBase58();
}
function decodeAddress(initData) {
    const data = typeof initData === 'string' ? bs58_default().decode(initData) : initData;
    if (!index_browser_esm.PublicKey.isOnCurve(data)) throw new Error(`Failed to create public key from ${bs58_default().encode(data)}.`);
    return new index_browser_esm.PublicKey(data);
}
function formatAddress(address, size = 0) {
    if (!isValidAddress(address, false)) return address;
    if (size === 0 || size >= 22) return address;
    return `${address.slice(0, Math.max(0, size))}...${address.slice(-size)}`;
}
const formatSchemaType = (0,createLookupTableResolver/* createLookupTableResolver */.F)({
    [types/* SchemaType */.XQ.Native]: 'Native',
    [types/* SchemaType */.XQ.Fungible]: 'Fungible',
    [types/* SchemaType */.XQ.NonFungible]: 'NonFungible'
}, '');
function formatTokenId(tokenId = '', size_ = 4) {
    const size = Math.max(2, size_);
    if (tokenId.length < size * 2) return `#${tokenId}`;
    const head = tokenId.slice(0, size);
    const tail = tokenId.slice(-size);
    return `#${head}...${tail}`;
}
function isValidAddress(address, strict) {
    const length = address?.length;
    if (!length || length < 32 || length > 44) return false;
    try {
        const buffer = bs58_default().decode(address);
        return strict === false ? true : index_browser_esm.PublicKey.isOnCurve(buffer) && !isTronAddress(address);
    } catch  {
        return false;
    }
}
const isValidChainId = (0,memoize/* default */.Z)((chainId)=>{
    return (0,esm/* getEnumAsArray */.Yl)(types/* ChainId */.a_).some((x)=>x.value === chainId);
});
function isZeroAddress(address) {
    return (0,isSameAddress/* isSameAddress */.W)(address, ZERO_ADDRESS);
}
const nativeTokenSet = new Set((0,esm/* getEnumAsArray */.Yl)(types/* ChainId */.a_).map((x)=>(0,constants/* getTokenConstant */._x)(x.value, 'SOL_ADDRESS')));
function isNativeTokenAddress(address) {
    return !!(address && nativeTokenSet.has(address));
}
function getNetworkPluginID() {
    return PluginID/* NetworkPluginID */.F.PLUGIN_SOLANA;
}
function getDefaultChainId() {
    return types/* ChainId */.a_.Mainnet;
}
function getInvalidChainId() {
    return types/* ChainId */.a_.Invalid;
}
function getDefaultNetworkType() {
    return types/* NetworkType */.td.Solana;
}
function getDefaultProviderType() {
    return types/* ProviderType */.lP.None;
}
function getZeroAddress() {
    return ZERO_ADDRESS;
}
function getMaskTokenAddress(chainId = types/* ChainId */.a_.Mainnet) {
    return '';
}
function getNativeTokenAddress(chainId = types/* ChainId */.a_.Mainnet) {
    return (0,constants/* getTokenConstant */._x)(chainId, 'SOL_ADDRESS') ?? '';
}


/***/ }),

/***/ 43500:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   h: () => (/* binding */ isValidDomain)
/* harmony export */ });
function isValidDomain(domain) {
    return /.+\.sol/i.test(domain ?? '');
}


/***/ }),

/***/ 5986:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   V: () => (/* binding */ createClientEndpoint),
/* harmony export */   e: () => (/* binding */ createClient)
/* harmony export */ });
/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20374);
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(97834);


const Endpoints = {
    [_types_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet]: 'https://solana-mainnet.phantom.app/YBPpkkN4g91xDiAnTE9r0RcMkjg0sKUIWvAfoFVJ',
    [_types_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Testnet]: 'https://api.testnet.solana.com',
    [_types_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Devnet]: 'https://api.devnet.solana.com',
    [_types_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Invalid]: ''
};
function createClientEndpoint(chainId = _types_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet) {
    return Endpoints[chainId];
}
function createClient(chainId = _types_js__WEBPACK_IMPORTED_MODULE_1__/* .ChainId */ .a_.Mainnet) {
    return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Connection(createClientEndpoint(chainId));
}


/***/ }),

/***/ 97834:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DL: () => (/* binding */ AddressType),
/* harmony export */   XQ: () => (/* binding */ SchemaType),
/* harmony export */   aK: () => (/* binding */ Coin98MethodType),
/* harmony export */   a_: () => (/* binding */ ChainId),
/* harmony export */   dK: () => (/* binding */ PhantomMethodType),
/* harmony export */   lP: () => (/* binding */ ProviderType),
/* harmony export */   td: () => (/* binding */ NetworkType)
/* harmony export */ });
var ChainId;
(function(ChainId) {
    ChainId[ChainId["Mainnet"] = 101] = "Mainnet";
    ChainId[ChainId["Testnet"] = 102] = "Testnet";
    ChainId[ChainId["Devnet"] = 103] = "Devnet";
    ChainId[ChainId[// For any chains not supported yet.
    "Invalid"] = 0] = "Invalid";
})(ChainId || (ChainId = {}));
var AddressType;
(function(AddressType) {
    AddressType[AddressType["Default"] = 1] = "Default";
    AddressType[AddressType["Program"] = 2] = "Program";
})(AddressType || (AddressType = {}));
var SchemaType;
(function(SchemaType) {
    SchemaType[SchemaType["Native"] = 1] = "Native";
    SchemaType[SchemaType["Fungible"] = 2] = "Fungible";
    SchemaType[SchemaType["NonFungible"] = 3] = "NonFungible";
})(SchemaType || (SchemaType = {}));
var NetworkType;
(function(NetworkType) {
    NetworkType["Solana"] = "Solana";
})(NetworkType || (NetworkType = {}));
var ProviderType;
(function(ProviderType) {
    ProviderType["None"] = "None";
    ProviderType["Phantom"] = "Phantom";
    ProviderType["Solflare"] = "Solflare";
    ProviderType["Sollet"] = "Sollet";
    ProviderType["Coin98"] = "Coin98";
})(ProviderType || (ProviderType = {}));
var // Learn more at https://docs.phantom.app/integrating/extension-and-mobile-browser/detecting-the-provider
PhantomMethodType;
(function(PhantomMethodType) {
    PhantomMethodType["CONNECT"] = 'connect';
    PhantomMethodType["SIGN_MESSAGE"] = 'signMessage';
    PhantomMethodType["SIGN_TRANSACTION"] = 'signTransaction';
    PhantomMethodType["SIGN_TRANSACTIONS"] = 'signAllTransactions';
    PhantomMethodType["SIGN_AND_SEND_TRANSACTION"] = 'signAndSendTransaction';
})(PhantomMethodType || (PhantomMethodType = {}));
var // Learn more at https://docs.coin98.com/developer-guide/solana-dapps-integration
Coin98MethodType;
(function(Coin98MethodType) {
    Coin98MethodType["SOL_ACCOUNTS"] = 'sol_accounts';
    Coin98MethodType["SOL_REQUEST_ACCOUNTS"] = 'sol_requestAccounts';
    Coin98MethodType["HAS_WALLET"] = 'has_wallet';
    Coin98MethodType["SOL_SIGN"] = 'sol_sign';
    Coin98MethodType["SOL_VERIFY"] = 'sol_verify';
})(Coin98MethodType || (Coin98MethodType = {}));


/***/ }),

/***/ 10666:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   j: () => (/* binding */ getABTestSeed)
/* harmony export */ });
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(60530);

/**
 * Return a seed (0~maximum) based on the TelemetryID.
 * @param maximum The maximum seed expected (default 2 ** 32, which is 0~4294967296)
 */ function getABTestSeed(maximum = 2 ** 32) {
    const number = Number.parseInt(_masknet_shared_base__WEBPACK_IMPORTED_MODULE_0__/* .TelemetryID */ .w.value.slice(0, 16), 16);
    if (Number.isNaN(number)) return 0;
    return number % maximum;
}


/***/ }),

/***/ 56802:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   G: () => (/* binding */ joinsABTest)
/* harmony export */ });
/* harmony import */ var _getABTestSeed_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10666);

/**
 * Returns true if the install joins the a/b test.
 * @param percent 0 - 100
 */ function joinsABTest(percent = 50) {
    if (percent === 0) return false;
    if (percent === 100) return true;
    if (percent < 0 || percent > 100) throw new RangeError();
    return (0,_getABTestSeed_js__WEBPACK_IMPORTED_MODULE_0__/* .getABTestSeed */ .j)(100) <= percent;
}


/***/ }),

/***/ 17788:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  M: () => (/* binding */ providers_Telemetry)
});

// EXTERNAL MODULE: ./packages/flags/src/index.ts
var src = __webpack_require__(51573);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/omitBy.js + 1 modules
var omitBy = __webpack_require__(72802);
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isUndefined.js
var isUndefined = __webpack_require__(81770);
// EXTERNAL MODULE: ./node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-browser/v4.js + 3 modules
var v4 = __webpack_require__(60307);
// EXTERNAL MODULE: ./packages/shared-base/src/Telemetry/index.ts
var Telemetry = __webpack_require__(60530);
// EXTERNAL MODULE: ./node_modules/.pnpm/@sentry-internal+tracing@7.66.0/node_modules/@sentry-internal/tracing/esm/browser/browsertracing.js + 17 modules
var browsertracing = __webpack_require__(68568);
// EXTERNAL MODULE: ./node_modules/.pnpm/@sentry-internal+tracing@7.66.0/node_modules/@sentry-internal/tracing/esm/node/integrations/apollo.js
var apollo = __webpack_require__(9058);
// EXTERNAL MODULE: ./node_modules/.pnpm/@sentry-internal+tracing@7.66.0/node_modules/@sentry-internal/tracing/esm/node/integrations/express.js
var express = __webpack_require__(33655);
// EXTERNAL MODULE: ./node_modules/.pnpm/@sentry-internal+tracing@7.66.0/node_modules/@sentry-internal/tracing/esm/node/integrations/graphql.js
var graphql = __webpack_require__(86219);
// EXTERNAL MODULE: ./node_modules/.pnpm/@sentry-internal+tracing@7.66.0/node_modules/@sentry-internal/tracing/esm/node/integrations/mongo.js
var mongo = __webpack_require__(62600);
// EXTERNAL MODULE: ./node_modules/.pnpm/@sentry-internal+tracing@7.66.0/node_modules/@sentry-internal/tracing/esm/node/integrations/mysql.js
var mysql = __webpack_require__(97402);
// EXTERNAL MODULE: ./node_modules/.pnpm/@sentry-internal+tracing@7.66.0/node_modules/@sentry-internal/tracing/esm/node/integrations/postgres.js
var postgres = __webpack_require__(4314);
// EXTERNAL MODULE: ./node_modules/.pnpm/@sentry-internal+tracing@7.66.0/node_modules/@sentry-internal/tracing/esm/node/integrations/prisma.js
var prisma = __webpack_require__(92371);
// EXTERNAL MODULE: ./node_modules/.pnpm/@sentry-internal+tracing@7.66.0/node_modules/@sentry-internal/tracing/esm/extensions.js
var extensions = __webpack_require__(58773);
;// CONCATENATED MODULE: ./node_modules/.pnpm/@sentry+tracing@7.66.0/node_modules/@sentry/tracing/esm/index.js


// BrowserTracing is already exported as part of `Integrations` below (and for the moment will remain so for
// backwards compatibility), but that interferes with treeshaking, so we also export it separately
// here.
/**
 * @deprecated `@sentry/tracing` has been deprecated and will be moved to to `@sentry/node`, `@sentry/browser`, or your framework SDK in the next major version.
 * `BrowserTracing` can be imported from `@sentry/browser` or your framework SDK
 *
 * import { BrowserTracing } from '@sentry/browser';
 * new BrowserTracing()
 */
const BrowserTracing = browsertracing/* BrowserTracing */.gE;

// BrowserTracing is already exported as part of `Integrations` below (and for the moment will remain so for
// backwards compatibility), but that interferes with treeshaking, so we also export it separately
// here.
/**
 * @deprecated `@sentry/tracing` has been deprecated and will be moved to to `@sentry/node`, `@sentry/browser`, or your framework SDK in the next major version.
 * `BrowserTracing` can be imported from `@sentry/browser` or your framework SDK
 *
 * import { BrowserTracing } from '@sentry/browser';
 * new BrowserTracing()
 */

/**
 * @deprecated `@sentry/tracing` has been deprecated and will be moved to to `@sentry/node`, `@sentry/browser`, or your framework SDK in the next major version.
 */
const addExtensionMethods = (/* unused pure expression or super */ null && (addExtensionMethods$1));

/**
 * @deprecated `@sentry/tracing` has been deprecated and will be moved to to `@sentry/node`, `@sentry/browser`, or your framework SDK in the next major version.
 *
 * `getActiveTransaction` can be imported from `@sentry/node`, `@sentry/browser`, or your framework SDK
 */
const getActiveTransaction = (/* unused pure expression or super */ null && (getActiveTransaction$1));

/**
 * @deprecated `@sentry/tracing` has been deprecated and will be moved to to `@sentry/node`, `@sentry/browser`, or your framework SDK in the next major version.
 *
 * `extractTraceparentData` can be imported from `@sentry/node`, `@sentry/browser`, or your framework SDK
 */
const extractTraceparentData = (/* unused pure expression or super */ null && (extractTraceparentData$1));

/**
 * @deprecated `@sentry/tracing` has been deprecated and will be moved to to `@sentry/node`, `@sentry/browser`, or your framework SDK in the next major version.
 *
 * `spanStatusfromHttpCode` can be imported from `@sentry/node`, `@sentry/browser`, or your framework SDK
 */
const spanStatusfromHttpCode = (/* unused pure expression or super */ null && (spanStatusfromHttpCode$1));

/**
 * @deprecated `@sentry/tracing` has been deprecated and will be moved to to `@sentry/node`, `@sentry/browser`, or your framework SDK in the next major version.
 *
 * `SpanStatusType` can be imported from `@sentry/node`, `@sentry/browser`, or your framework SDK
 */

/**
 * @deprecated `@sentry/tracing` has been deprecated and will be moved to to `@sentry/node`, `@sentry/browser`, or your framework SDK in the next major version.
 *
 * `Transaction` can be imported from `@sentry/node`, `@sentry/browser`, or your framework SDK
 */
const Transaction = (/* unused pure expression or super */ null && (Transaction$1));

/**
 * @deprecated `@sentry/tracing` has been deprecated and will be moved to to `@sentry/node`, `@sentry/browser`, or your framework SDK in the next major version.
 *
 * `Transaction` can be imported from `@sentry/node`, `@sentry/browser`, or your framework SDK
 */

/**
 * @deprecated `@sentry/tracing` has been deprecated and will be moved to to `@sentry/node`, `@sentry/browser`, or your framework SDK in the next major version.
 *
 * `Span` can be imported from `@sentry/node`, `@sentry/browser`, or your framework SDK
 */
const Span = (/* unused pure expression or super */ null && (Span$1));

/**
 * @deprecated `@sentry/tracing` has been deprecated and will be moved to to `@sentry/node`, `@sentry/browser`, or your framework SDK in the next major version.
 *
 * `Span` can be imported from `@sentry/node`, `@sentry/browser`, or your framework SDK
 */

/**
 * @deprecated `@sentry/tracing` has been deprecated and will be moved to to `@sentry/node`, `@sentry/browser`, or your framework SDK in the next major version.
 */
const BROWSER_TRACING_INTEGRATION_ID = (/* unused pure expression or super */ null && (BROWSER_TRACING_INTEGRATION_ID$1));

/**
 * @deprecated `@sentry/tracing` has been deprecated and will be moved to to `@sentry/node`, `@sentry/browser`, or your framework SDK in the next major version.
 *
 * `defaultRequestInstrumentationOptions` can be imported from `@sentry/browser`, or your framework SDK
 */
const defaultRequestInstrumentationOptions = (/* unused pure expression or super */ null && (defaultRequestInstrumentationOptions$1));

/**
 * @deprecated `@sentry/tracing` has been deprecated and will be moved to to `@sentry/node`, `@sentry/browser`, or your framework SDK in the next major version.
 *
 * `hasTracingEnabled` can be imported from `@sentry/utils`
 */
const hasTracingEnabled = (/* unused pure expression or super */ null && (hasTracingEnabled$1));

/**
 * @deprecated `@sentry/tracing` has been deprecated and will be moved to to `@sentry/node`, `@sentry/browser`, or your framework SDK in the next major version.
 *
 * `stripUrlQueryAndFragment` can be imported from `@sentry/utils`
 */
const stripUrlQueryAndFragment = (/* unused pure expression or super */ null && (stripUrlQueryAndFragment$1));

/**
 * @deprecated `@sentry/tracing` has been deprecated and will be moved to to `@sentry/node`, `@sentry/browser`, or your framework SDK in the next major version.
 *
 * `TRACEPARENT_REGEXP` can be imported from `@sentry/utils`
 */
const TRACEPARENT_REGEXP = (/* unused pure expression or super */ null && (TRACEPARENT_REGEXP$1));

/**
 * @deprecated `@sentry/tracing` has been deprecated and will be moved to to `@sentry/node`, `@sentry/browser`, or your framework SDK in the next major version.
 */
const IdleTransaction = (/* unused pure expression or super */ null && (IdleTransaction$1));

/**
 * @deprecated `@sentry/tracing` has been deprecated and will be moved to to `@sentry/node`, `@sentry/browser`, or your framework SDK in the next major version.
 */

/**
 * @deprecated `@sentry/tracing` has been deprecated and will be moved to to `@sentry/node`, `@sentry/browser`, or your framework SDK in the next major version.
 */
const instrumentOutgoingRequests = (/* unused pure expression or super */ null && (instrumentOutgoingRequests$1));

/**
 * @deprecated `@sentry/tracing` has been deprecated and will be moved to to `@sentry/node`, `@sentry/browser`, or your framework SDK in the next major version.
 */
const startIdleTransaction = (/* unused pure expression or super */ null && (startIdleTransaction$1));

/**
 * @deprecated `@sentry/tracing` has been deprecated and will be moved to to `@sentry/node`, `@sentry/browser`, or your framework SDK in the next major version.
 */
// eslint-disable-next-line deprecation/deprecation
const SpanStatus = (/* unused pure expression or super */ null && (SpanStatus$1));

/**
 * @deprecated `@sentry/tracing` has been deprecated and will be moved to to `@sentry/node`, `@sentry/browser`, or your framework SDK in the next major version.
 */
// eslint-disable-next-line deprecation/deprecation

const Integrations = {
  /**
   * @deprecated `@sentry/tracing` has been deprecated and will be moved to to `@sentry/node`, `@sentry/browser`, or your framework SDK in the next major version.
   * `BrowserTracing` can be imported from `@sentry/browser` or your framework SDK
   *
   * import { BrowserTracing } from '@sentry/browser';
   * new BrowserTracing()
   */
  // eslint-disable-next-line deprecation/deprecation
  BrowserTracing: BrowserTracing,
  /**
   * @deprecated `@sentry/tracing` has been deprecated and will be moved to to `@sentry/node`, `@sentry/browser`, or your framework SDK in the next major version.
   * `Apollo` can be imported from `@sentry/node`
   *
   * import { Integrations } from '@sentry/node';
   * new Integrations.Apollo({ ... })
   */
  // eslint-disable-next-line deprecation/deprecation
  Apollo: apollo/* Apollo */._,
  /**
   * @deprecated `@sentry/tracing` has been deprecated and will be moved to to `@sentry/node`, `@sentry/browser`, or your framework SDK in the next major version.
   * `Express` can be imported from `@sentry/node`
   *
   * import { Integrations } from '@sentry/node';
   * new Integrations.Express({ ... })
   */
  // eslint-disable-next-line deprecation/deprecation
  Express: express/* Express */.N,
  /**
   * @deprecated `@sentry/tracing` has been deprecated and will be moved to to `@sentry/node`, `@sentry/browser`, or your framework SDK in the next major version.
   * `GraphQL` can be imported from `@sentry/node`
   *
   * import { Integrations } from '@sentry/node';
   * new Integrations.GraphQL({ ... })
   */
  // eslint-disable-next-line deprecation/deprecation
  GraphQL: graphql/* GraphQL */.k,
  /**
   * @deprecated `@sentry/tracing` has been deprecated and will be moved to to `@sentry/node`, `@sentry/browser`, or your framework SDK in the next major version.
   * `Mongo` can be imported from `@sentry/node`
   *
   * import { Integrations } from '@sentry/node';
   * new Integrations.Mongo({ ... })
   */
  // eslint-disable-next-line deprecation/deprecation
  Mongo: mongo/* Mongo */._,
  /**
   * @deprecated `@sentry/tracing` has been deprecated and will be moved to to `@sentry/node`, `@sentry/browser`, or your framework SDK in the next major version.
   * `Mysql` can be imported from `@sentry/node`
   *
   * import { Integrations } from '@sentry/node';
   * new Integrations.Mysql({ ... })
   */
  // eslint-disable-next-line deprecation/deprecation
  Mysql: mysql/* Mysql */.m,
  /**
   * @deprecated `@sentry/tracing` has been deprecated and will be moved to to `@sentry/node`, `@sentry/browser`, or your framework SDK in the next major version.
   * `Postgres` can be imported from `@sentry/node`
   *
   * import { Integrations } from '@sentry/node';
   * new Integrations.Postgres({ ... })
   */
  // eslint-disable-next-line deprecation/deprecation
  Postgres: postgres/* Postgres */.E,
  /**
   * @deprecated `@sentry/tracing` has been deprecated and will be moved to to `@sentry/node`, `@sentry/browser`, or your framework SDK in the next major version.
   * `Prisma` can be imported from `@sentry/node`
   *
   * import { Integrations } from '@sentry/node';
   * new Integrations.Prisma({ ... })
   */
  // eslint-disable-next-line deprecation/deprecation
  Prisma: prisma/* Prisma */.g,
};

// Treeshakable guard to remove all code related to tracing

// Guard for tree
if (typeof __SENTRY_TRACING__ === 'undefined' || __SENTRY_TRACING__) {
  // We are patching the global object with our hub extension methods
  (0,extensions/* addExtensionMethods */.r)();
}



// EXTERNAL MODULE: ./packages/web3-telemetry/src/settings/index.ts
var settings = __webpack_require__(28668);
;// CONCATENATED MODULE: ./packages/web3-telemetry/src/providers/Base.ts
/// <reference types="@masknet/global-types/env" />


class BaseAPI {
    sampleRate;
    constructor(sampleRate = 1){
        this.sampleRate = sampleRate;
        this.status = 'off';
        // register listener
        settings/* telemetrySettings */.T.addListener((x)=>x ? this.enable() : this.disable());
    }
    // The sentry needs to be opened at the runtime.
    status;
    userOptions;
    deviceOptions;
    networkOptions;
    get user() {
        return {
            ...this.userOptions
        };
    }
    set user(options) {
        this.userOptions = {
            ...this.userOptions,
            ...options
        };
    }
    get device() {
        return {
            ...this.deviceOptions
        };
    }
    set device(options) {
        this.deviceOptions = {
            ...this.deviceOptions,
            ...options
        };
    }
    get network() {
        return {
            ...this.networkOptions
        };
    }
    set network(options) {
        this.networkOptions = {
            ...this.networkOptions,
            ...options
        };
    }
    getOptions(initials) {
        return {
            user: {
                ...this.userOptions,
                ...initials?.user
            },
            device: {
                ...this.deviceOptions,
                ...initials?.device
            },
            network: {
                ...this.networkOptions,
                ...initials?.network
            }
        };
    }
    shouldRecord() {
        if (this.status === 'off') return false;
        const rate = this.sampleRate % 1;
        if (rate >= 1 || rate < 0) return true;
        return crypto.getRandomValues(new Uint8Array(1))[0] > 255 - Math.floor(255 * this.sampleRate);
    }
    enable() {
        this.status = 'on';
    }
    disable() {
        this.status = 'off';
    }
    captureEvent(options) {
        throw new Error('Method not implemented');
    }
    captureException(options) {
        throw new Error('Method not implemented');
    }
}

// EXTERNAL MODULE: ./node_modules/.pnpm/urlcat@3.1.0_patch_hash=5r5xyq4zgcnqugwsrx4lxq2i4e/node_modules/urlcat/dist/index.mjs
var dist = __webpack_require__(78757);
// EXTERNAL MODULE: ./packages/shared-base/src/Site/index.ts
var Site = __webpack_require__(68422);
// EXTERNAL MODULE: ./packages/web3-telemetry/src/helpers/joinsABTest.ts
var joinsABTest = __webpack_require__(56802);
// EXTERNAL MODULE: ./packages/web3-telemetry/src/helpers/getABTestSeed.ts
var getABTestSeed = __webpack_require__(10666);
;// CONCATENATED MODULE: ./packages/web3-telemetry/src/apis/Mixpanel.ts




// the previous event name
// the previous event ID
// ip address
// timestamp like Date.now()
// a unique id to make distinguish of users
// a unique id to make distinguish of events (uuid)
// screen height
// screen width
// a unique user id
// os name
// browser name
// browser version
// name of device
// a unique device id
// the city of the event sender parsed from the IP property or the Latitude and Longitude properties.
// the region (state or province) of the event sender parsed from the IP property or the Latitude and Longitude properties.
// timezone of the event sender, parsed from IP.
// network metadata
// browser env
// build env
// ab-testing
class MixpanelEventAPI {
    token;
    env;
    lastEvent;
    constructor(token, env){
        this.token = token;
        this.env = env;
    }
    attachEvent(event) {
        return this.lastEvent = {
            event: event.event,
            properties: (0,omitBy/* default */.Z)({
                previous_event: this.lastEvent?.event,
                previous_event_id: this.lastEvent?.properties.$insert_id,
                $user_id: Telemetry/* TelemetryID */.w.value,
                $device_id: Telemetry/* TelemetryID */.w.value,
                $screen_height: screen.height,
                $screen_width: screen.width,
                $browser: navigator.appName,
                $browser_version: navigator.appVersion,
                agent: (0,Site/* getAgentType */.ub)(),
                site: (0,Site/* getSiteType */.sv)(),
                ua: navigator.userAgent,
                extension_id: (0,Site/* getExtensionId */.Me)(),
                channel: this.env.channel,
                version: this.env.VERSION,
                branch_name: this.env.BRANCH_NAME,
                device_ab: (0,joinsABTest/* joinsABTest */.G)(),
                device_seed: (0,getABTestSeed/* getABTestSeed */.j)(),
                device_id: Telemetry/* TelemetryID */.w.value,
                ...event.properties
            }, isUndefined/* default */.Z)
        };
    }
    // for collecting data on the server-slide
    // learn more at: https://developer.mixpanel.com/reference/import-events
    async importEvent(_) {
        const event = this.attachEvent(_);
        const response = await fetch((0,dist/* default */.ZP)('https://mixpanel.r2d2.to/import', {
            strict: 1,
            project_id: this.token
        }), {
            method: 'POST',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify([
                event
            ])
        });
        const json = await response.json();
        if (json.error) throw new Error(json.error);
    }
    // for collecting data on the client-slide
    // Learn more at: https://developer.mixpanel.com/reference/track-event
    async trackEvent(_) {
        const event = this.attachEvent(_);
        const response = await fetch((0,dist/* default */.ZP)('https://mixpanel.r2d2.to/track', {
            // in the debug mode the API returns more information
            verbose:  false ? 0 : 0
        }), {
            method: 'POST',
            headers: {
                // Accept: 'application/json',
                Accept: 'text/plain',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify([
                {
                    event: event.event,
                    properties: {
                        ...event.properties,
                        token: this.token
                    }
                }
            ])
        });
        const json = await response.json();
        if (json === 0) throw new Error('No data objects in the body are invalid.');
        if (typeof json === 'object' && json.error) throw new Error(json.error);
        return;
    }
}

;// CONCATENATED MODULE: ./packages/web3-telemetry/src/providers/Mixpanel.ts






class MixpanelAPI extends BaseAPI {
    constructor(env){
        super(src/* Flags */.v.mixpanel_sample_rate);
        this.eventAPI = new MixpanelEventAPI(src/* Flags */.v.mixpanel_project_token, env);
    }
    eventAPI;
    createEvent(options) {
        return (0,omitBy/* default */.Z)({
            event: options.eventID,
            properties: {
                type: options.eventType,
                time: Date.now(),
                distinct_id: Telemetry/* TelemetryID */.w.value,
                $insert_id: (0,v4/* default */.Z)(),
                chain_id: options.network?.chainId,
                plugin_id: options.network?.pluginID,
                network_id: options.network?.networkID,
                network: options.network?.networkType,
                provider: options.network?.providerType
            }
        }, isUndefined/* default */.Z);
    }
    captureEvent(options) {
        if (this.status === 'off') return;
        if (!src/* Flags */.v.sentry_enabled) return;
        if (!src/* Flags */.v.sentry_event_enabled) return;
        if (!this.shouldRecord()) return;
        if (false) {} else {
            const event = this.createEvent(options);
            this.eventAPI.trackEvent(event);
        }
    }
    captureException(options) {
        // mixpanel is for events only
        return;
    }
}

// EXTERNAL MODULE: ./node_modules/.pnpm/@sentry+browser@7.66.0/node_modules/@sentry/browser/esm/integrations/globalhandlers.js + 1 modules
var globalhandlers = __webpack_require__(57880);
// EXTERNAL MODULE: ./node_modules/.pnpm/@sentry+browser@7.66.0/node_modules/@sentry/browser/esm/integrations/breadcrumbs.js
var breadcrumbs = __webpack_require__(94470);
;// CONCATENATED MODULE: ./packages/web3-telemetry/src/helpers/parseVersion.ts
function parseVersion(version) {
    return version.split('.').map((n)=>Number.parseInt(n, 10) || 0);
}

;// CONCATENATED MODULE: ./packages/web3-telemetry/src/helpers/isNewerThan.ts

function isNewerThan(version, otherVersion) {
    const versionParsed = parseVersion(version);
    const otherVersionParsed = parseVersion(otherVersion);
    return versionParsed.reduce((newer, n, i)=>{
        if (newer) return newer;
        return n > otherVersionParsed[i];
    }, false);
}

;// CONCATENATED MODULE: ./packages/web3-telemetry/src/helpers/isSameVersion.ts

function isSameVersion(version, otherVersion) {
    const versionParsed = parseVersion(version);
    const otherVersionParsed = parseVersion(otherVersion);
    return versionParsed.length === otherVersionParsed.length && versionParsed.every((n, i)=>n === otherVersionParsed[i]);
}

;// CONCATENATED MODULE: ./packages/web3-telemetry/src/helpers/removeSensitiveTelemetryInfo.ts
function removeSensitiveTelemetryInfo(text) {
    if (!text) return text;
    return text.replaceAll(/\b0x[\da-f]{40}\b/gi, '[ethereum address]').replaceAll(/\b0x[\da-f]{16}\b/gi, '[flow address]').replaceAll(/\b0x[\da-f]{32,}\b/gi, '[key]').replaceAll(/\b[\da-f]{32,}\b/gi, '[key]').replaceAll(/\b[1-9A-HJ-NP-Za-km-z]{32,44}\b/g, '[solana address]');
}

// EXTERNAL MODULE: ./packages/web3-telemetry/src/types/index.ts
var types = __webpack_require__(91451);
;// CONCATENATED MODULE: ./packages/web3-telemetry/src/providers/Sentry.ts
/// <reference types="@masknet/global-types/env" />












const IGNORE_ERRORS = [
    // FIXME
    'timeout in mutex storage.',
    // ignore
    "Cannot perform 'getPrototypeOf' on a proxy that has been revoked",
    'UnknownError: The databases() promise was rejected.',
    'DataError: Failed to read large IndexedDB value',
    'Unexpected internal error',
    'UnknownError: Internal error',
    'TimeoutError: Transaction timed out due to inactivity.',
    'execution reverted',
    'Failed to fetch',
    'At least one of the attempts fails.',
    'Extension context invalidated.',
    '[object Promise]',
    'ResizeObserver',
    'User rejected the request.',
    'Non-Error promise rejection captured with keys: message',
    'Object captured as promise rejection with keys: message',
    'An attempt was made to break through the security policy of the user agent.'
];
class SentryAPI extends BaseAPI {
    constructor(env){
        super(src/* Flags */.v.sentry_sample_rate);
        const release = env.channel === 'stable' && "production" === 'production' ? env.COMMIT_HASH ? `mask-${env.COMMIT_HASH}` : `mask-${env.VERSION}-reproducible` : undefined;
        if (typeof Sentry === 'undefined') {
            return;
        }
        Sentry.init({
            dsn: "",
            release,
            defaultIntegrations: false,
            integrations: [
                // global error and unhandledrejection event
                new globalhandlers/* GlobalHandlers */.d(),
                // global fetch error
                new breadcrumbs/* Breadcrumbs */.O({
                    console: false,
                    dom: false,
                    xhr: false,
                    fetch: true,
                    history: false
                })
            ],
            environment: "production",
            beforeSend: (event)=>{
                // version control
                if (env.VERSION && src/* Flags */.v.sentry_earliest_version && !isSameVersion(env.VERSION, src/* Flags */.v.sentry_earliest_version) && !isNewerThan(env.VERSION, src/* Flags */.v.sentry_earliest_version)) return null;
                // ignored errors
                if (event.exception?.values?.some((x)=>IGNORE_ERRORS.some((y)=>x.value?.includes(y)))) return null;
                if (event.message && IGNORE_ERRORS.some((x)=>event.message?.includes(x))) return null;
                // send automatically by sentry tracker
                if (!event.tags?.group_id) {
                    // ignored in the development mode
                    if (false) {}
                    // throttle
                    if (!this.shouldRecord()) return null;
                }
                event.exception?.values?.forEach((error)=>{
                    error.value = removeSensitiveTelemetryInfo(error.value);
                });
                if (event.message) {
                    event.message = removeSensitiveTelemetryInfo(event.message);
                }
                return event;
            }
        });
        // set global tags
        Sentry.setTag('agent', (0,Site/* getAgentType */.ub)());
        Sentry.setTag('site', (0,Site/* getSiteType */.sv)());
        Sentry.setTag('extension_id', (0,Site/* getExtensionId */.Me)());
        Sentry.setTag('channel', env.channel);
        Sentry.setTag('version', env.VERSION);
        Sentry.setTag('ua', navigator.userAgent);
        Sentry.setTag('device_ab', (0,joinsABTest/* joinsABTest */.G)());
        Sentry.setTag('device_seed', (0,getABTestSeed/* getABTestSeed */.j)());
        Sentry.setTag('device_id', Telemetry/* TelemetryID */.w.value);
        Sentry.setTag('branch_name', env.BRANCH_NAME);
        Telemetry/* TelemetryID */.w.addListener((trackID)=>{
            Sentry.setTag('device_ab', (0,joinsABTest/* joinsABTest */.G)());
            Sentry.setTag('device_seed', (0,getABTestSeed/* getABTestSeed */.j)());
            Sentry.setTag('track_id', trackID);
        });
        // register listener
        settings/* telemetrySettings */.T.addListener((x)=>x ? this.enable() : this.disable());
    }
    createCommonEvent(groupID, type, ID, initials) {
        const options = this.getOptions(initials);
        return {
            level: groupID === types/* GroupID */.Ym.Event ? 'info' : 'error',
            message: ID,
            tags: {
                group_id: types/* GroupID */.Ym.Event,
                track_id: ID,
                track_type: type,
                chain_id: options.network?.chainId,
                plugin_id: options.network?.pluginID,
                network_id: options.network?.networkID,
                network: options.network?.networkType,
                provider: options.network?.providerType
            },
            exception: {},
            breadcrumbs: []
        };
    }
    createException(options) {
        return this.createCommonEvent(types/* GroupID */.Ym.Exception, options.exceptionType, options.exceptionID, options);
    }
    captureEvent(options) {
        // we don't trace event by sentry after mixpanel introduced
        return;
    }
    captureException(options) {
        if (this.status === 'off') return;
        if (!src/* Flags */.v.sentry_enabled) return;
        if (!src/* Flags */.v.sentry_exception_enabled) return;
        if (!this.shouldRecord()) return;
        if (false) {} else {
            Sentry.captureException(options.error, this.createException(options));
        }
    }
}

;// CONCATENATED MODULE: ./packages/web3-telemetry/src/providers/Telemetry.ts



/**
 * A proxy class for all telemetry providers.
 */ class TelemetryAPI {
    Sentry = new SentryAPI(src/* env */.O);
    Mixpanel = new MixpanelAPI(src/* env */.O);
    captureEvent(eventType, eventID, options) {
        this.Mixpanel.captureEvent({
            eventType,
            eventID,
            ...options
        });
    }
    captureException(exceptionType, exceptionID, error, options) {
        this.Sentry.captureException({
            exceptionType,
            exceptionID,
            error,
            ...options
        });
    }
}

;// CONCATENATED MODULE: ./packages/web3-telemetry/src/providers/index.ts

const providers_Telemetry = new TelemetryAPI();


/***/ }),

/***/ 28668:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   T: () => (/* binding */ telemetrySettings)
/* harmony export */ });
/* harmony import */ var _masknet_shared_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6938);

const telemetrySettings = (0,_masknet_shared_base__WEBPACK_IMPORTED_MODULE_0__/* .createGlobalSettings */ .TI)('log', false);


/***/ }),

/***/ 91451:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HS: () => (/* binding */ EventID),
/* harmony export */   T$: () => (/* binding */ ExceptionID),
/* harmony export */   Ym: () => (/* binding */ GroupID),
/* harmony export */   tw: () => (/* binding */ EventType),
/* harmony export */   wz: () => (/* binding */ ExceptionType)
/* harmony export */ });
var GroupID;
(function(GroupID) {
    GroupID["Event"] = 'event';
    GroupID["Exception"] = 'exception';
})(GroupID || (GroupID = {}));
var EventType;
(function(EventType) {
    EventType["Debug"] = 'debug';
    EventType["Access"] = 'access';
    EventType["Exit"] = 'exit';
    EventType["Interact"] = 'interact';
})(EventType || (EventType = {}));
var ExceptionType;
(function(ExceptionType) {
    ExceptionType["Error"] = "Error";
})(ExceptionType || (ExceptionType = {}));
var EventID;
(function(EventID) {
    EventID["EntryAppLuckOpen"] = 'entry_app_luck_open';
    EventID["EntryAppLuckCreate"] = 'entry_app_luck_create';
    EventID["EntryAppLuckSend"] = 'entry_app_luck_send';
    EventID["EntryAppNFT_PFP_Open"] = 'entry_app_nft_pfp_open';
    EventID["EntryAppNFT_PFP_Setting"] = 'entry_app_nft_pfp_setting';
    EventID["EntryAppSwapOpen"] = 'entry_app_swap_open';
    EventID["EntryAppApprovalOpen"] = 'entry_app_approval_open';
    EventID["EntryAppCheckOpen"] = 'entry_app_check_open';
    EventID["EntryAppFileOpen"] = 'entry_app_file_open';
    EventID["EntryTimelineDsearchToken"] = 'entry_timeline_dsearch_token';
    EventID["EntryTimelineDsearchNft"] = 'entry_timeline_dsearch_nft';
    EventID["EntryTimelineDsearchAddress"] = 'entry_timeline_dsearch_address';
    EventID["EntryTimelineDsearchEns"] = 'entry_timeline_dsearch_ens';
    EventID["EntryTimelineDsearchName"] = 'entry_timeline_dsearch_name';
    EventID["EntryTimelineTipsOpen"] = 'entry_timeline_tips_open';
    EventID["EntryTimelineTipsSend"] = 'entry_timeline_tips_send';
    EventID["EntryTimelineHoverTokenDuration"] = 'entry_timeline_hover_token_duration';
    EventID["EntryTimelineHoverNftDuration"] = 'entry_timeline_hover_nft_duration';
    EventID["EntryTimelineHoverUserNftClickNft"] = 'entry_timeline_hover_user_nft_click_nft';
    EventID["EntryTimelineHoverUserNftSwitchChain"] = 'entry_timeline_hover_user_nft_switch_chain';
    EventID["EntryTimelineHoverUserActivitiesSwitchTo"] = 'entry_timeline_hover_user_activities_switch_to';
    EventID["EntryTimelineHoverUserDonationsSwitchTo"] = 'entry_timeline_hover_user_donations_switch_to';
    EventID["EntryTimelineHoverUserSocialSwitchTo"] = 'entry_timeline_hover_user_social_switch_to';
    EventID["EntryPopupSocialAccountConnectTwitter"] = 'entry_popup_social_account_connect_twitter';
    EventID["EntryPopupSocialAccountConnectFb"] = 'entry_popup_social_account_connect_fb';
    EventID["EntryPopupSocialAccountConnectMinds"] = 'entry_popup_social_account_connect_minds';
    EventID["EntryPopupSocialAccountConnectIns"] = 'entry_popup_social_account_connect_ins';
    EventID["EntryPopupSocialAccountVerifyTwitter"] = 'entry_popup_social_account_verify_twitter';
    EventID["EntryPopupSocialAccountDisconnectTwitter"] = 'entry_popup_social_account_disconnect_twitter';
    EventID["EntryPopupSocialAccountDisconnectFb"] = 'entry_popup_social_account_disconnect_fb';
    EventID["EntryPopupSocialAccountDisconnectMinds"] = 'entry_popup_social_account_disconnect_minds';
    EventID["EntryPopupSocialAccountDisconnectIns"] = 'entry_popup_social_account_disconnect_ins';
    EventID["EntryPopupWalletCreate"] = 'entry_popup_wallet_create';
    EventID["EntryPopupWalletImport"] = 'entry_popup_wallet_import';
    EventID["EntryProfileTokenSwitchTrend"] = 'entry_profile_token_switch_trend';
    EventID["EntryProfileTokenSwitchMarket"] = 'entry_profile_token_switch_market';
    EventID["EntryProfileNFT_ItemsSwitchTo"] = 'entry_profile_nft_items_switch_to';
    EventID["EntryProfileNFT_TrendSwitchTo"] = 'entry_profile_nft_trend_switch_to';
    EventID["EntryProfileNFT_ActivitiesSwitchTo"] = 'entry_profile_nft_activities_switch_to';
    EventID["EntrySwitchLogoSave"] = 'entry_switch_logo_save';
    EventID["EntryMaskComposeOpen"] = 'entry_mask_compose_open';
    EventID["EntryMaskComposeVisibleAll"] = 'entry_mask_compose_visible_all';
    EventID["EntryMaskComposeVisiblePrivate"] = 'entry_mask_compose_visible_private';
    EventID["EntryMaskComposeVisibleSelected"] = 'entry_mask_compose_visible_selected';
    EventID["EntryMaskComposeEncrypt"] = 'entry_mask_compose_encrypt';
    EventID["EntryProfileUserNftsClickNft"] = 'entry_profile_user_nfts_click_nft';
    EventID["EntryProfileUserNftsSwitchChain"] = 'entry_profile_user_nfts_switch_chain';
    EventID["EntryProfileUserActivitiesSwitchTo"] = 'entry_profile_user_activities_switch_to';
    EventID["EntryProfileUserDonationsSwitchTo"] = 'entry_profile_user_donations_switch_to';
    EventID["EntryProfileUserSocialSwitchTo"] = 'entry_profile_user_social_switch_to';
    EventID["EntryProfileConnectTwitter"] = 'entry_profile_connect_twitter';
    EventID["EntryProfileConnectVerify"] = 'entry_profile_connect_verify';
    EventID["EntryMaskComposeConnectTwitter"] = 'entry_mask_compose_connect_twitter';
    EventID["EntryMaskComposeVerifyTwitter"] = 'entry_mask_compose_verify_twitter';
    EventID[// For debug only
    "Debug"] = "Debug";
})(EventID || (EventID = {}));
var ExceptionID// default to 1 (100%)
;
(function(ExceptionID) {
    ExceptionID["FetchError"] = "FetchError";
    ExceptionID["Debug"] = 'DebugError';
})(ExceptionID || (ExceptionID = {}));


/***/ }),

/***/ 92984:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: () => (/* binding */ createCache)
});

;// CONCATENATED MODULE: ./node_modules/.pnpm/@emotion+sheet@1.2.2/node_modules/@emotion/sheet/dist/emotion-sheet.browser.esm.js
/*

Based off glamor's StyleSheet, thanks Sunil ❤️

high performance StyleSheet for css-in-js systems

- uses multiple style tags behind the scenes for millions of rules
- uses `insertRule` for appending in production for *much* faster performance

// usage

import { StyleSheet } from '@emotion/sheet'

let styleSheet = new StyleSheet({ key: '', container: document.head })

styleSheet.insert('#box { border: 1px solid red; }')
- appends a css rule into the stylesheet

styleSheet.flush()
- empties the stylesheet of all its contents

*/
// $FlowFixMe
function sheetForTag(tag) {
  if (tag.sheet) {
    // $FlowFixMe
    return tag.sheet;
  } // this weirdness brought to you by firefox

  /* istanbul ignore next */


  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      // $FlowFixMe
      return document.styleSheets[i];
    }
  }
}

function createStyleElement(options) {
  var tag = document.createElement('style');
  tag.setAttribute('data-emotion', options.key);

  if (options.nonce !== undefined) {
    tag.setAttribute('nonce', options.nonce);
  }

  tag.appendChild(document.createTextNode(''));
  tag.setAttribute('data-s', '');
  return tag;
}

var StyleSheet = /*#__PURE__*/function () {
  // Using Node instead of HTMLElement since container may be a ShadowRoot
  function StyleSheet(options) {
    var _this = this;

    this._insertTag = function (tag) {
      var before;

      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }

      _this.container.insertBefore(tag, before);

      _this.tags.push(tag);
    };

    this.isSpeedy = options.speedy === undefined ? "production" === 'production' : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce; // key is the value of the data-emotion attribute, it's used to identify different sheets

    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }

  var _proto = StyleSheet.prototype;

  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };

  _proto.insert = function insert(rule) {
    // the max length is how many rules we have per style tag, it's 65000 in speedy mode
    // it's 1 in dev because we insert source maps that map a single rule to a location
    // and you can only have one source map per style tag
    if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }

    var tag = this.tags[this.tags.length - 1];

    if (false) { var isImportRule; }

    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);

      try {
        // this is the ultrafast version, works across browsers
        // the big drawback is that the css won't be editable in devtools
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e) {
        if (false) {}
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }

    this.ctr++;
  };

  _proto.flush = function flush() {
    // $FlowFixMe
    this.tags.forEach(function (tag) {
      return tag.parentNode && tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;

    if (false) {}
  };

  return StyleSheet;
}();



;// CONCATENATED MODULE: ./node_modules/.pnpm/stylis@4.2.0/node_modules/stylis/src/Utility.js
/**
 * @param {number}
 * @return {number}
 */
var abs = Math.abs

/**
 * @param {number}
 * @return {string}
 */
var Utility_from = String.fromCharCode

/**
 * @param {object}
 * @return {object}
 */
var Utility_assign = Object.assign

/**
 * @param {string} value
 * @param {number} length
 * @return {number}
 */
function hash (value, length) {
	return Utility_charat(value, 0) ^ 45 ? (((((((length << 2) ^ Utility_charat(value, 0)) << 2) ^ Utility_charat(value, 1)) << 2) ^ Utility_charat(value, 2)) << 2) ^ Utility_charat(value, 3) : 0
}

/**
 * @param {string} value
 * @return {string}
 */
function trim (value) {
	return value.trim()
}

/**
 * @param {string} value
 * @param {RegExp} pattern
 * @return {string?}
 */
function Utility_match (value, pattern) {
	return (value = pattern.exec(value)) ? value[0] : value
}

/**
 * @param {string} value
 * @param {(string|RegExp)} pattern
 * @param {string} replacement
 * @return {string}
 */
function Utility_replace (value, pattern, replacement) {
	return value.replace(pattern, replacement)
}

/**
 * @param {string} value
 * @param {string} search
 * @return {number}
 */
function indexof (value, search) {
	return value.indexOf(search)
}

/**
 * @param {string} value
 * @param {number} index
 * @return {number}
 */
function Utility_charat (value, index) {
	return value.charCodeAt(index) | 0
}

/**
 * @param {string} value
 * @param {number} begin
 * @param {number} end
 * @return {string}
 */
function Utility_substr (value, begin, end) {
	return value.slice(begin, end)
}

/**
 * @param {string} value
 * @return {number}
 */
function Utility_strlen (value) {
	return value.length
}

/**
 * @param {any[]} value
 * @return {number}
 */
function Utility_sizeof (value) {
	return value.length
}

/**
 * @param {any} value
 * @param {any[]} array
 * @return {any}
 */
function Utility_append (value, array) {
	return array.push(value), value
}

/**
 * @param {string[]} array
 * @param {function} callback
 * @return {string}
 */
function Utility_combine (array, callback) {
	return array.map(callback).join('')
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/stylis@4.2.0/node_modules/stylis/src/Tokenizer.js


var line = 1
var column = 1
var Tokenizer_length = 0
var position = 0
var character = 0
var characters = ''

/**
 * @param {string} value
 * @param {object | null} root
 * @param {object | null} parent
 * @param {string} type
 * @param {string[] | string} props
 * @param {object[] | string} children
 * @param {number} length
 */
function node (value, root, parent, type, props, children, length) {
	return {value: value, root: root, parent: parent, type: type, props: props, children: children, line: line, column: column, length: length, return: ''}
}

/**
 * @param {object} root
 * @param {object} props
 * @return {object}
 */
function Tokenizer_copy (root, props) {
	return Utility_assign(node('', null, null, '', null, null, 0), root, {length: -root.length}, props)
}

/**
 * @return {number}
 */
function Tokenizer_char () {
	return character
}

/**
 * @return {number}
 */
function prev () {
	character = position > 0 ? Utility_charat(characters, --position) : 0

	if (column--, character === 10)
		column = 1, line--

	return character
}

/**
 * @return {number}
 */
function next () {
	character = position < Tokenizer_length ? Utility_charat(characters, position++) : 0

	if (column++, character === 10)
		column = 1, line++

	return character
}

/**
 * @return {number}
 */
function peek () {
	return Utility_charat(characters, position)
}

/**
 * @return {number}
 */
function caret () {
	return position
}

/**
 * @param {number} begin
 * @param {number} end
 * @return {string}
 */
function slice (begin, end) {
	return Utility_substr(characters, begin, end)
}

/**
 * @param {number} type
 * @return {number}
 */
function token (type) {
	switch (type) {
		// \0 \t \n \r \s whitespace token
		case 0: case 9: case 10: case 13: case 32:
			return 5
		// ! + , / > @ ~ isolate token
		case 33: case 43: case 44: case 47: case 62: case 64: case 126:
		// ; { } breakpoint token
		case 59: case 123: case 125:
			return 4
		// : accompanied token
		case 58:
			return 3
		// " ' ( [ opening delimit token
		case 34: case 39: case 40: case 91:
			return 2
		// ) ] closing delimit token
		case 41: case 93:
			return 1
	}

	return 0
}

/**
 * @param {string} value
 * @return {any[]}
 */
function alloc (value) {
	return line = column = 1, Tokenizer_length = Utility_strlen(characters = value), position = 0, []
}

/**
 * @param {any} value
 * @return {any}
 */
function dealloc (value) {
	return characters = '', value
}

/**
 * @param {number} type
 * @return {string}
 */
function delimit (type) {
	return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)))
}

/**
 * @param {string} value
 * @return {string[]}
 */
function Tokenizer_tokenize (value) {
	return dealloc(tokenizer(alloc(value)))
}

/**
 * @param {number} type
 * @return {string}
 */
function whitespace (type) {
	while (character = peek())
		if (character < 33)
			next()
		else
			break

	return token(type) > 2 || token(character) > 3 ? '' : ' '
}

/**
 * @param {string[]} children
 * @return {string[]}
 */
function tokenizer (children) {
	while (next())
		switch (token(character)) {
			case 0: append(identifier(position - 1), children)
				break
			case 2: append(delimit(character), children)
				break
			default: append(from(character), children)
		}

	return children
}

/**
 * @param {number} index
 * @param {number} count
 * @return {string}
 */
function escaping (index, count) {
	while (--count && next())
		// not 0-9 A-F a-f
		if (character < 48 || character > 102 || (character > 57 && character < 65) || (character > 70 && character < 97))
			break

	return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32))
}

/**
 * @param {number} type
 * @return {number}
 */
function delimiter (type) {
	while (next())
		switch (character) {
			// ] ) " '
			case type:
				return position
			// " '
			case 34: case 39:
				if (type !== 34 && type !== 39)
					delimiter(character)
				break
			// (
			case 40:
				if (type === 41)
					delimiter(type)
				break
			// \
			case 92:
				next()
				break
		}

	return position
}

/**
 * @param {number} type
 * @param {number} index
 * @return {number}
 */
function commenter (type, index) {
	while (next())
		// //
		if (type + character === 47 + 10)
			break
		// /*
		else if (type + character === 42 + 42 && peek() === 47)
			break

	return '/*' + slice(index, position - 1) + '*' + Utility_from(type === 47 ? type : next())
}

/**
 * @param {number} index
 * @return {string}
 */
function identifier (index) {
	while (!token(peek()))
		next()

	return slice(index, position)
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/stylis@4.2.0/node_modules/stylis/src/Enum.js
var Enum_MS = '-ms-'
var Enum_MOZ = '-moz-'
var Enum_WEBKIT = '-webkit-'

var COMMENT = 'comm'
var Enum_RULESET = 'rule'
var Enum_DECLARATION = 'decl'

var PAGE = '@page'
var MEDIA = '@media'
var IMPORT = '@import'
var CHARSET = '@charset'
var VIEWPORT = '@viewport'
var SUPPORTS = '@supports'
var DOCUMENT = '@document'
var NAMESPACE = '@namespace'
var Enum_KEYFRAMES = '@keyframes'
var FONT_FACE = '@font-face'
var COUNTER_STYLE = '@counter-style'
var FONT_FEATURE_VALUES = '@font-feature-values'
var LAYER = '@layer'

;// CONCATENATED MODULE: ./node_modules/.pnpm/stylis@4.2.0/node_modules/stylis/src/Serializer.js



/**
 * @param {object[]} children
 * @param {function} callback
 * @return {string}
 */
function Serializer_serialize (children, callback) {
	var output = ''
	var length = Utility_sizeof(children)

	for (var i = 0; i < length; i++)
		output += callback(children[i], i, children, callback) || ''

	return output
}

/**
 * @param {object} element
 * @param {number} index
 * @param {object[]} children
 * @param {function} callback
 * @return {string}
 */
function stringify (element, index, children, callback) {
	switch (element.type) {
		case LAYER: if (element.children.length) break
		case IMPORT: case Enum_DECLARATION: return element.return = element.return || element.value
		case COMMENT: return ''
		case Enum_KEYFRAMES: return element.return = element.value + '{' + Serializer_serialize(element.children, callback) + '}'
		case Enum_RULESET: element.value = element.props.join(',')
	}

	return Utility_strlen(children = Serializer_serialize(element.children, callback)) ? element.return = element.value + '{' + children + '}' : ''
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/stylis@4.2.0/node_modules/stylis/src/Middleware.js






/**
 * @param {function[]} collection
 * @return {function}
 */
function middleware (collection) {
	var length = Utility_sizeof(collection)

	return function (element, index, children, callback) {
		var output = ''

		for (var i = 0; i < length; i++)
			output += collection[i](element, index, children, callback) || ''

		return output
	}
}

/**
 * @param {function} callback
 * @return {function}
 */
function rulesheet (callback) {
	return function (element) {
		if (!element.root)
			if (element = element.return)
				callback(element)
	}
}

/**
 * @param {object} element
 * @param {number} index
 * @param {object[]} children
 * @param {function} callback
 */
function prefixer (element, index, children, callback) {
	if (element.length > -1)
		if (!element.return)
			switch (element.type) {
				case DECLARATION: element.return = prefix(element.value, element.length, children)
					return
				case KEYFRAMES:
					return serialize([copy(element, {value: replace(element.value, '@', '@' + WEBKIT)})], callback)
				case RULESET:
					if (element.length)
						return combine(element.props, function (value) {
							switch (match(value, /(::plac\w+|:read-\w+)/)) {
								// :read-(only|write)
								case ':read-only': case ':read-write':
									return serialize([copy(element, {props: [replace(value, /:(read-\w+)/, ':' + MOZ + '$1')]})], callback)
								// :placeholder
								case '::placeholder':
									return serialize([
										copy(element, {props: [replace(value, /:(plac\w+)/, ':' + WEBKIT + 'input-$1')]}),
										copy(element, {props: [replace(value, /:(plac\w+)/, ':' + MOZ + '$1')]}),
										copy(element, {props: [replace(value, /:(plac\w+)/, MS + 'input-$1')]})
									], callback)
							}

							return ''
						})
			}
}

/**
 * @param {object} element
 * @param {number} index
 * @param {object[]} children
 */
function namespace (element) {
	switch (element.type) {
		case RULESET:
			element.props = element.props.map(function (value) {
				return combine(tokenize(value), function (value, index, children) {
					switch (charat(value, 0)) {
						// \f
						case 12:
							return substr(value, 1, strlen(value))
						// \0 ( + > ~
						case 0: case 40: case 43: case 62: case 126:
							return value
						// :
						case 58:
							if (children[++index] === 'global')
								children[index] = '', children[++index] = '\f' + substr(children[index], index = 1, -1)
						// \s
						case 32:
							return index === 1 ? '' : value
						default:
							switch (index) {
								case 0: element = value
									return sizeof(children) > 1 ? '' : value
								case index = sizeof(children) - 1: case 2:
									return index === 2 ? value + element + element : value + element
								default:
									return value
							}
					}
				})
			})
	}
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/stylis@4.2.0/node_modules/stylis/src/Parser.js




/**
 * @param {string} value
 * @return {object[]}
 */
function compile (value) {
	return dealloc(parse('', null, null, null, [''], value = alloc(value), 0, [0], value))
}

/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {string[]} rule
 * @param {string[]} rules
 * @param {string[]} rulesets
 * @param {number[]} pseudo
 * @param {number[]} points
 * @param {string[]} declarations
 * @return {object}
 */
function parse (value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
	var index = 0
	var offset = 0
	var length = pseudo
	var atrule = 0
	var property = 0
	var previous = 0
	var variable = 1
	var scanning = 1
	var ampersand = 1
	var character = 0
	var type = ''
	var props = rules
	var children = rulesets
	var reference = rule
	var characters = type

	while (scanning)
		switch (previous = character, character = next()) {
			// (
			case 40:
				if (previous != 108 && Utility_charat(characters, length - 1) == 58) {
					if (indexof(characters += Utility_replace(delimit(character), '&', '&\f'), '&\f') != -1)
						ampersand = -1
					break
				}
			// " ' [
			case 34: case 39: case 91:
				characters += delimit(character)
				break
			// \t \n \r \s
			case 9: case 10: case 13: case 32:
				characters += whitespace(previous)
				break
			// \
			case 92:
				characters += escaping(caret() - 1, 7)
				continue
			// /
			case 47:
				switch (peek()) {
					case 42: case 47:
						Utility_append(comment(commenter(next(), caret()), root, parent), declarations)
						break
					default:
						characters += '/'
				}
				break
			// {
			case 123 * variable:
				points[index++] = Utility_strlen(characters) * ampersand
			// } ; \0
			case 125 * variable: case 59: case 0:
				switch (character) {
					// \0 }
					case 0: case 125: scanning = 0
					// ;
					case 59 + offset: if (ampersand == -1) characters = Utility_replace(characters, /\f/g, '')
						if (property > 0 && (Utility_strlen(characters) - length))
							Utility_append(property > 32 ? declaration(characters + ';', rule, parent, length - 1) : declaration(Utility_replace(characters, ' ', '') + ';', rule, parent, length - 2), declarations)
						break
					// @ ;
					case 59: characters += ';'
					// { rule/at-rule
					default:
						Utility_append(reference = ruleset(characters, root, parent, index, offset, rules, points, type, props = [], children = [], length), rulesets)

						if (character === 123)
							if (offset === 0)
								parse(characters, root, reference, reference, props, rulesets, length, points, children)
							else
								switch (atrule === 99 && Utility_charat(characters, 3) === 110 ? 100 : atrule) {
									// d l m s
									case 100: case 108: case 109: case 115:
										parse(value, reference, reference, rule && Utility_append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length), children), rules, children, length, points, rule ? props : children)
										break
									default:
										parse(characters, reference, reference, reference, [''], children, 0, points, children)
								}
				}

				index = offset = property = 0, variable = ampersand = 1, type = characters = '', length = pseudo
				break
			// :
			case 58:
				length = 1 + Utility_strlen(characters), property = previous
			default:
				if (variable < 1)
					if (character == 123)
						--variable
					else if (character == 125 && variable++ == 0 && prev() == 125)
						continue

				switch (characters += Utility_from(character), character * variable) {
					// &
					case 38:
						ampersand = offset > 0 ? 1 : (characters += '\f', -1)
						break
					// ,
					case 44:
						points[index++] = (Utility_strlen(characters) - 1) * ampersand, ampersand = 1
						break
					// @
					case 64:
						// -
						if (peek() === 45)
							characters += delimit(next())

						atrule = peek(), offset = length = Utility_strlen(type = characters += identifier(caret())), character++
						break
					// -
					case 45:
						if (previous === 45 && Utility_strlen(characters) == 2)
							variable = 0
				}
		}

	return rulesets
}

/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {number} index
 * @param {number} offset
 * @param {string[]} rules
 * @param {number[]} points
 * @param {string} type
 * @param {string[]} props
 * @param {string[]} children
 * @param {number} length
 * @return {object}
 */
function ruleset (value, root, parent, index, offset, rules, points, type, props, children, length) {
	var post = offset - 1
	var rule = offset === 0 ? rules : ['']
	var size = Utility_sizeof(rule)

	for (var i = 0, j = 0, k = 0; i < index; ++i)
		for (var x = 0, y = Utility_substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x)
			if (z = trim(j > 0 ? rule[x] + ' ' + y : Utility_replace(y, /&\f/g, rule[x])))
				props[k++] = z

	return node(value, root, parent, offset === 0 ? Enum_RULESET : type, props, children, length)
}

/**
 * @param {number} value
 * @param {object} root
 * @param {object?} parent
 * @return {object}
 */
function comment (value, root, parent) {
	return node(value, root, parent, COMMENT, Utility_from(Tokenizer_char()), Utility_substr(value, 2, -2), 0)
}

/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {number} length
 * @return {object}
 */
function declaration (value, root, parent, length) {
	return node(value, root, parent, Enum_DECLARATION, Utility_substr(value, 0, length), Utility_substr(value, length + 1, -1), length)
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/@emotion+cache@11.11.0/node_modules/@emotion/cache/dist/emotion-cache.browser.esm.js





var identifierWithPointTracking = function identifierWithPointTracking(begin, points, index) {
  var previous = 0;
  var character = 0;

  while (true) {
    previous = character;
    character = peek(); // &\f

    if (previous === 38 && character === 12) {
      points[index] = 1;
    }

    if (token(character)) {
      break;
    }

    next();
  }

  return slice(begin, position);
};

var toRules = function toRules(parsed, points) {
  // pretend we've started with a comma
  var index = -1;
  var character = 44;

  do {
    switch (token(character)) {
      case 0:
        // &\f
        if (character === 38 && peek() === 12) {
          // this is not 100% correct, we don't account for literal sequences here - like for example quoted strings
          // stylis inserts \f after & to know when & where it should replace this sequence with the context selector
          // and when it should just concatenate the outer and inner selectors
          // it's very unlikely for this sequence to actually appear in a different context, so we just leverage this fact here
          points[index] = 1;
        }

        parsed[index] += identifierWithPointTracking(position - 1, points, index);
        break;

      case 2:
        parsed[index] += delimit(character);
        break;

      case 4:
        // comma
        if (character === 44) {
          // colon
          parsed[++index] = peek() === 58 ? '&\f' : '';
          points[index] = parsed[index].length;
          break;
        }

      // fallthrough

      default:
        parsed[index] += Utility_from(character);
    }
  } while (character = next());

  return parsed;
};

var getRules = function getRules(value, points) {
  return dealloc(toRules(alloc(value), points));
}; // WeakSet would be more appropriate, but only WeakMap is supported in IE11


var fixedElements = /* #__PURE__ */new WeakMap();
var compat = function compat(element) {
  if (element.type !== 'rule' || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }

  var value = element.value,
      parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;

  while (parent.type !== 'rule') {
    parent = parent.parent;
    if (!parent) return;
  } // short-circuit for the simplest case


  if (element.props.length === 1 && value.charCodeAt(0) !== 58
  /* colon */
  && !fixedElements.get(parent)) {
    return;
  } // if this is an implicitly inserted rule (the one eagerly inserted at the each new nested level)
  // then the props has already been manipulated beforehand as they that array is shared between it and its "rule parent"


  if (isImplicitRule) {
    return;
  }

  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;

  for (var i = 0, k = 0; i < rules.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k++) {
      element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel(element) {
  if (element.type === 'decl') {
    var value = element.value;

    if ( // charcode for l
    value.charCodeAt(0) === 108 && // charcode for b
    value.charCodeAt(2) === 98) {
      // this ignores label
      element["return"] = '';
      element.value = '';
    }
  }
};
var ignoreFlag = 'emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason';

var isIgnoringComment = function isIgnoringComment(element) {
  return element.type === 'comm' && element.children.indexOf(ignoreFlag) > -1;
};

var createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm(cache) {
  return function (element, index, children) {
    if (element.type !== 'rule' || cache.compat) return;
    var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);

    if (unsafePseudoClasses) {
      var isNested = !!element.parent; // in nested rules comments become children of the "auto-inserted" rule and that's always the `element.parent`
      //
      // considering this input:
      // .a {
      //   .b /* comm */ {}
      //   color: hotpink;
      // }
      // we get output corresponding to this:
      // .a {
      //   & {
      //     /* comm */
      //     color: hotpink;
      //   }
      //   .b {}
      // }

      var commentContainer = isNested ? element.parent.children : // global rule at the root level
      children;

      for (var i = commentContainer.length - 1; i >= 0; i--) {
        var node = commentContainer[i];

        if (node.line < element.line) {
          break;
        } // it is quite weird but comments are *usually* put at `column: element.column - 1`
        // so we seek *from the end* for the node that is earlier than the rule's `element` and check that
        // this will also match inputs like this:
        // .a {
        //   /* comm */
        //   .b {}
        // }
        //
        // but that is fine
        //
        // it would be the easiest to change the placement of the comment to be the first child of the rule:
        // .a {
        //   .b { /* comm */ }
        // }
        // with such inputs we wouldn't have to search for the comment at all
        // TODO: consider changing this comment placement in the next major version


        if (node.column < element.column) {
          if (isIgnoringComment(node)) {
            return;
          }

          break;
        }
      }

      unsafePseudoClasses.forEach(function (unsafePseudoClass) {
        console.error("The pseudo class \"" + unsafePseudoClass + "\" is potentially unsafe when doing server-side rendering. Try changing it to \"" + unsafePseudoClass.split('-child')[0] + "-of-type\".");
      });
    }
  };
};

var isImportRule = function isImportRule(element) {
  return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;
};

var isPrependedWithRegularRules = function isPrependedWithRegularRules(index, children) {
  for (var i = index - 1; i >= 0; i--) {
    if (!isImportRule(children[i])) {
      return true;
    }
  }

  return false;
}; // use this to remove incorrect elements from further processing
// so they don't get handed to the `sheet` (or anything else)
// as that could potentially lead to additional logs which in turn could be overhelming to the user


var nullifyElement = function nullifyElement(element) {
  element.type = '';
  element.value = '';
  element["return"] = '';
  element.children = '';
  element.props = '';
};

var incorrectImportAlarm = function incorrectImportAlarm(element, index, children) {
  if (!isImportRule(element)) {
    return;
  }

  if (element.parent) {
    console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
    nullifyElement(element);
  } else if (isPrependedWithRegularRules(index, children)) {
    console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
    nullifyElement(element);
  }
};

/* eslint-disable no-fallthrough */

function emotion_cache_browser_esm_prefix(value, length) {
  switch (hash(value, length)) {
    // color-adjust
    case 5103:
      return Enum_WEBKIT + 'print-' + value + value;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)

    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921: // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break

    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005: // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,

    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855: // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)

    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return Enum_WEBKIT + value + value;
    // appearance, user-select, transform, hyphens, text-size-adjust

    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return Enum_WEBKIT + value + Enum_MOZ + value + Enum_MS + value + value;
    // flex, flex-direction

    case 6828:
    case 4268:
      return Enum_WEBKIT + value + Enum_MS + value + value;
    // order

    case 6165:
      return Enum_WEBKIT + value + Enum_MS + 'flex-' + value + value;
    // align-items

    case 5187:
      return Enum_WEBKIT + value + Utility_replace(value, /(\w+).+(:[^]+)/, Enum_WEBKIT + 'box-$1$2' + Enum_MS + 'flex-$1$2') + value;
    // align-self

    case 5443:
      return Enum_WEBKIT + value + Enum_MS + 'flex-item-' + Utility_replace(value, /flex-|-self/, '') + value;
    // align-content

    case 4675:
      return Enum_WEBKIT + value + Enum_MS + 'flex-line-pack' + Utility_replace(value, /align-content|flex-|-self/, '') + value;
    // flex-shrink

    case 5548:
      return Enum_WEBKIT + value + Enum_MS + Utility_replace(value, 'shrink', 'negative') + value;
    // flex-basis

    case 5292:
      return Enum_WEBKIT + value + Enum_MS + Utility_replace(value, 'basis', 'preferred-size') + value;
    // flex-grow

    case 6060:
      return Enum_WEBKIT + 'box-' + Utility_replace(value, '-grow', '') + Enum_WEBKIT + value + Enum_MS + Utility_replace(value, 'grow', 'positive') + value;
    // transition

    case 4554:
      return Enum_WEBKIT + Utility_replace(value, /([^-])(transform)/g, '$1' + Enum_WEBKIT + '$2') + value;
    // cursor

    case 6187:
      return Utility_replace(Utility_replace(Utility_replace(value, /(zoom-|grab)/, Enum_WEBKIT + '$1'), /(image-set)/, Enum_WEBKIT + '$1'), value, '') + value;
    // background, background-image

    case 5495:
    case 3959:
      return Utility_replace(value, /(image-set\([^]*)/, Enum_WEBKIT + '$1' + '$`$1');
    // justify-content

    case 4968:
      return Utility_replace(Utility_replace(value, /(.+:)(flex-)?(.*)/, Enum_WEBKIT + 'box-pack:$3' + Enum_MS + 'flex-pack:$3'), /s.+-b[^;]+/, 'justify') + Enum_WEBKIT + value + value;
    // (margin|padding)-inline-(start|end)

    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return Utility_replace(value, /(.+)-inline(.+)/, Enum_WEBKIT + '$1$2') + value;
    // (min|max)?(width|height|inline-size|block-size)

    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      // stretch, max-content, min-content, fill-available
      if (Utility_strlen(value) - 1 - length > 6) switch (Utility_charat(value, length + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          // -
          if (Utility_charat(value, length + 4) !== 45) break;
        // (f)ill-available, (f)it-content

        case 102:
          return Utility_replace(value, /(.+:)(.+)-([^]+)/, '$1' + Enum_WEBKIT + '$2-$3' + '$1' + Enum_MOZ + (Utility_charat(value, length + 3) == 108 ? '$3' : '$2-$3')) + value;
        // (s)tretch

        case 115:
          return ~indexof(value, 'stretch') ? emotion_cache_browser_esm_prefix(Utility_replace(value, 'stretch', 'fill-available'), length) + value : value;
      }
      break;
    // position: sticky

    case 4949:
      // (s)ticky?
      if (Utility_charat(value, length + 1) !== 115) break;
    // display: (flex|inline-flex)

    case 6444:
      switch (Utility_charat(value, Utility_strlen(value) - 3 - (~indexof(value, '!important') && 10))) {
        // stic(k)y
        case 107:
          return Utility_replace(value, ':', ':' + Enum_WEBKIT) + value;
        // (inline-)?fl(e)x

        case 101:
          return Utility_replace(value, /(.+:)([^;!]+)(;|!.+)?/, '$1' + Enum_WEBKIT + (Utility_charat(value, 14) === 45 ? 'inline-' : '') + 'box$3' + '$1' + Enum_WEBKIT + '$2$3' + '$1' + Enum_MS + '$2box$3') + value;
      }

      break;
    // writing-mode

    case 5936:
      switch (Utility_charat(value, length + 11)) {
        // vertical-l(r)
        case 114:
          return Enum_WEBKIT + value + Enum_MS + Utility_replace(value, /[svh]\w+-[tblr]{2}/, 'tb') + value;
        // vertical-r(l)

        case 108:
          return Enum_WEBKIT + value + Enum_MS + Utility_replace(value, /[svh]\w+-[tblr]{2}/, 'tb-rl') + value;
        // horizontal(-)tb

        case 45:
          return Enum_WEBKIT + value + Enum_MS + Utility_replace(value, /[svh]\w+-[tblr]{2}/, 'lr') + value;
      }

      return Enum_WEBKIT + value + Enum_MS + value + value;
  }

  return value;
}

var emotion_cache_browser_esm_prefixer = function prefixer(element, index, children, callback) {
  if (element.length > -1) if (!element["return"]) switch (element.type) {
    case Enum_DECLARATION:
      element["return"] = emotion_cache_browser_esm_prefix(element.value, element.length);
      break;

    case Enum_KEYFRAMES:
      return Serializer_serialize([Tokenizer_copy(element, {
        value: Utility_replace(element.value, '@', '@' + Enum_WEBKIT)
      })], callback);

    case Enum_RULESET:
      if (element.length) return Utility_combine(element.props, function (value) {
        switch (Utility_match(value, /(::plac\w+|:read-\w+)/)) {
          // :read-(only|write)
          case ':read-only':
          case ':read-write':
            return Serializer_serialize([Tokenizer_copy(element, {
              props: [Utility_replace(value, /:(read-\w+)/, ':' + Enum_MOZ + '$1')]
            })], callback);
          // :placeholder

          case '::placeholder':
            return Serializer_serialize([Tokenizer_copy(element, {
              props: [Utility_replace(value, /:(plac\w+)/, ':' + Enum_WEBKIT + 'input-$1')]
            }), Tokenizer_copy(element, {
              props: [Utility_replace(value, /:(plac\w+)/, ':' + Enum_MOZ + '$1')]
            }), Tokenizer_copy(element, {
              props: [Utility_replace(value, /:(plac\w+)/, Enum_MS + 'input-$1')]
            })], callback);
        }

        return '';
      });
  }
};

var defaultStylisPlugins = [emotion_cache_browser_esm_prefixer];

var createCache = function createCache(options) {
  var key = options.key;

  if (false) {}

  if (key === 'css') {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])"); // get SSRed styles out of the way of React's hydration
    // document.head is a safe place to move them to(though note document.head is not necessarily the last place they will be)
    // note this very very intentionally targets all style elements regardless of the key to ensure
    // that creating a cache works inside of render of a React component

    Array.prototype.forEach.call(ssrStyles, function (node) {
      // we want to only move elements which have a space in the data-emotion attribute value
      // because that indicates that it is an Emotion 11 server-side rendered style elements
      // while we will already ignore Emotion 11 client-side inserted styles because of the :not([data-s]) part in the selector
      // Emotion 10 client-side inserted styles did not have data-s (but importantly did not have a space in their data-emotion attributes)
      // so checking for the space ensures that loading Emotion 11 after Emotion 10 has inserted some styles
      // will not result in the Emotion 10 styles being destroyed
      var dataEmotionAttribute = node.getAttribute('data-emotion');

      if (dataEmotionAttribute.indexOf(' ') === -1) {
        return;
      }
      document.head.appendChild(node);
      node.setAttribute('data-s', '');
    });
  }

  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;

  if (false) {}

  var inserted = {};
  var container;
  var nodesToHydrate = [];

  {
    container = options.container || document.head;
    Array.prototype.forEach.call( // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll("style[data-emotion^=\"" + key + " \"]"), function (node) {
      var attrib = node.getAttribute("data-emotion").split(' '); // $FlowFixMe

      for (var i = 1; i < attrib.length; i++) {
        inserted[attrib[i]] = true;
      }

      nodesToHydrate.push(node);
    });
  }

  var _insert;

  var omnipresentPlugins = [compat, removeLabel];

  if (false) {}

  {
    var currentSheet;
    var finalizingPlugins = [stringify,  false ? 0 : rulesheet(function (rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));

    var stylis = function stylis(styles) {
      return Serializer_serialize(compile(styles), serializer);
    };

    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;

      if (false) {}

      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);

      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }

  var cache = {
    key: key,
    sheet: new StyleSheet({
      key: key,
      container: container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted: inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};




/***/ }),

/***/ 29343:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (/* binding */ murmur2)
/* harmony export */ });
/* eslint-disable */
// Inspired by https://github.com/garycourt/murmurhash-js
// Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86
function murmur2(str) {
  // 'm' and 'r' are mixing constants generated offline.
  // They're not really 'magic', they just happen to work well.
  // const m = 0x5bd1e995;
  // const r = 24;
  // Initialize the hash
  var h = 0; // Mix 4 bytes at a time into the hash

  var k,
      i = 0,
      len = str.length;

  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
    k =
    /* Math.imul(k, m): */
    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);
    k ^=
    /* k >>> r: */
    k >>> 24;
    h =
    /* Math.imul(k, m): */
    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^
    /* Math.imul(h, m): */
    (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  } // Handle the last few bytes of the input array


  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 0xff) << 16;

    case 2:
      h ^= (str.charCodeAt(i + 1) & 0xff) << 8;

    case 1:
      h ^= str.charCodeAt(i) & 0xff;
      h =
      /* Math.imul(h, m): */
      (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  } // Do a few final mixes of the hash to ensure the last few
  // bytes are well-incorporated.


  h ^= h >>> 13;
  h =
  /* Math.imul(h, m): */
  (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}




/***/ }),

/***/ 91852:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (/* binding */ memoize)
/* harmony export */ });
function memoize(fn) {
  var cache = Object.create(null);
  return function (arg) {
    if (cache[arg] === undefined) cache[arg] = fn(arg);
    return cache[arg];
  };
}




/***/ }),

/***/ 20033:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (/* binding */ unitlessKeys)
/* harmony export */ });
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};




/***/ }),

/***/ 59336:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   L: () => (/* binding */ useInsertionEffectAlwaysWithSyncFallback),
/* harmony export */   j: () => (/* binding */ useInsertionEffectWithLayoutFallback)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78996);


var syncFallback = function syncFallback(create) {
  return create();
};

var useInsertionEffect = /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)))['useInsertion' + 'Effect'] ? /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)))['useInsertion' + 'Effect'] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect || react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect;




/***/ }),

/***/ 54742:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   My: () => (/* binding */ insertStyles),
/* harmony export */   fp: () => (/* binding */ getRegisteredStyles),
/* harmony export */   hC: () => (/* binding */ registerStyles)
/* harmony export */ });
var isBrowser = "object" !== 'undefined';
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = '';
  classNames.split(' ').forEach(function (className) {
    if (registered[className] !== undefined) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles(cache, serialized, isStringTag) {
  var className = cache.key + "-" + serialized.name;

  if ( // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (isStringTag === false || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  isBrowser === false ) && cache.registered[className] === undefined) {
    cache.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles(cache, serialized, isStringTag) {
  registerStyles(cache, serialized, isStringTag);
  var className = cache.key + "-" + serialized.name;

  if (cache.inserted[serialized.name] === undefined) {
    var current = serialized;

    do {
      cache.insert(serialized === current ? "." + className : '', current, cache.sheet, true);

      current = current.next;
    } while (current !== undefined);
  }
};




/***/ }),

/***/ 59561:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RLP = exports.utils = exports.decode = exports.encode = void 0;
/**
 * RLP Encoding based on https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/
 * This function takes in data, converts it to Uint8Array if not,
 * and adds a length for recursion.
 * @param input Will be converted to Uint8Array
 * @returns Uint8Array of encoded data
 **/
function encode(input) {
    if (Array.isArray(input)) {
        const output = [];
        let outputLength = 0;
        for (let i = 0; i < input.length; i++) {
            const encoded = encode(input[i]);
            output.push(encoded);
            outputLength += encoded.length;
        }
        return concatBytes(encodeLength(outputLength, 192), ...output);
    }
    const inputBuf = toBytes(input);
    if (inputBuf.length === 1 && inputBuf[0] < 128) {
        return inputBuf;
    }
    return concatBytes(encodeLength(inputBuf.length, 128), inputBuf);
}
exports.encode = encode;
/**
 * Slices a Uint8Array, throws if the slice goes out-of-bounds of the Uint8Array.
 * E.g. `safeSlice(hexToBytes('aa'), 1, 2)` will throw.
 * @param input
 * @param start
 * @param end
 */
function safeSlice(input, start, end) {
    if (end > input.length) {
        throw new Error('invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds');
    }
    return input.slice(start, end);
}
/**
 * Parse integers. Check if there is no leading zeros
 * @param v The value to parse
 */
function decodeLength(v) {
    if (v[0] === 0) {
        throw new Error('invalid RLP: extra zeros');
    }
    return parseHexByte(bytesToHex(v));
}
function encodeLength(len, offset) {
    if (len < 56) {
        return Uint8Array.from([len + offset]);
    }
    const hexLength = numberToHex(len);
    const lLength = hexLength.length / 2;
    const firstByte = numberToHex(offset + 55 + lLength);
    return Uint8Array.from(hexToBytes(firstByte + hexLength));
}
function decode(input, stream = false) {
    if (typeof input === 'undefined' || input === null || input.length === 0) {
        return Uint8Array.from([]);
    }
    const inputBytes = toBytes(input);
    const decoded = _decode(inputBytes);
    if (stream) {
        return decoded;
    }
    if (decoded.remainder.length !== 0) {
        throw new Error('invalid RLP: remainder must be zero');
    }
    return decoded.data;
}
exports.decode = decode;
/** Decode an input with RLP */
function _decode(input) {
    let length, llength, data, innerRemainder, d;
    const decoded = [];
    const firstByte = input[0];
    if (firstByte <= 0x7f) {
        // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.
        return {
            data: input.slice(0, 1),
            remainder: input.slice(1),
        };
    }
    else if (firstByte <= 0xb7) {
        // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string
        // The range of the first byte is [0x80, 0xb7]
        length = firstByte - 0x7f;
        // set 0x80 null to 0
        if (firstByte === 0x80) {
            data = Uint8Array.from([]);
        }
        else {
            data = safeSlice(input, 1, length);
        }
        if (length === 2 && data[0] < 0x80) {
            throw new Error('invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed');
        }
        return {
            data,
            remainder: input.slice(length),
        };
    }
    else if (firstByte <= 0xbf) {
        // string is greater than 55 bytes long. A single byte with the value (0xb7 plus the length of the length),
        // followed by the length, followed by the string
        llength = firstByte - 0xb6;
        if (input.length - 1 < llength) {
            throw new Error('invalid RLP: not enough bytes for string length');
        }
        length = decodeLength(safeSlice(input, 1, llength));
        if (length <= 55) {
            throw new Error('invalid RLP: expected string length to be greater than 55');
        }
        data = safeSlice(input, llength, length + llength);
        return {
            data,
            remainder: input.slice(length + llength),
        };
    }
    else if (firstByte <= 0xf7) {
        // a list between 0-55 bytes long
        length = firstByte - 0xbf;
        innerRemainder = safeSlice(input, 1, length);
        while (innerRemainder.length) {
            d = _decode(innerRemainder);
            decoded.push(d.data);
            innerRemainder = d.remainder;
        }
        return {
            data: decoded,
            remainder: input.slice(length),
        };
    }
    else {
        // a list over 55 bytes long
        llength = firstByte - 0xf6;
        length = decodeLength(safeSlice(input, 1, llength));
        if (length < 56) {
            throw new Error('invalid RLP: encoded list too short');
        }
        const totalLength = llength + length;
        if (totalLength > input.length) {
            throw new Error('invalid RLP: total length is larger than the data');
        }
        innerRemainder = safeSlice(input, llength, totalLength);
        while (innerRemainder.length) {
            d = _decode(innerRemainder);
            decoded.push(d.data);
            innerRemainder = d.remainder;
        }
        return {
            data: decoded,
            remainder: input.slice(totalLength),
        };
    }
}
const cachedHexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));
function bytesToHex(uint8a) {
    // Pre-caching chars with `cachedHexes` speeds this up 6x
    let hex = '';
    for (let i = 0; i < uint8a.length; i++) {
        hex += cachedHexes[uint8a[i]];
    }
    return hex;
}
function parseHexByte(hexByte) {
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte))
        throw new Error('Invalid byte sequence');
    return byte;
}
// Caching slows it down 2-3x
function hexToBytes(hex) {
    if (typeof hex !== 'string') {
        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);
    }
    if (hex.length % 2)
        throw new Error('hexToBytes: received invalid unpadded hex');
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        array[i] = parseHexByte(hex.slice(j, j + 2));
    }
    return array;
}
/** Concatenates two Uint8Arrays into one. */
function concatBytes(...arrays) {
    if (arrays.length === 1)
        return arrays[0];
    const length = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
    }
    return result;
}
function utf8ToBytes(utf) {
    return new TextEncoder().encode(utf);
}
/** Transform an integer into its hexadecimal value */
function numberToHex(integer) {
    if (integer < 0) {
        throw new Error('Invalid integer as argument, must be unsigned!');
    }
    const hex = integer.toString(16);
    return hex.length % 2 ? `0${hex}` : hex;
}
/** Pad a string to be even */
function padToEven(a) {
    return a.length % 2 ? `0${a}` : a;
}
/** Check if a string is prefixed by 0x */
function isHexPrefixed(str) {
    return str.length >= 2 && str[0] === '0' && str[1] === 'x';
}
/** Removes 0x from a given String */
function stripHexPrefix(str) {
    if (typeof str !== 'string') {
        return str;
    }
    return isHexPrefixed(str) ? str.slice(2) : str;
}
/** Transform anything into a Uint8Array */
function toBytes(v) {
    if (v instanceof Uint8Array) {
        return v;
    }
    if (typeof v === 'string') {
        if (isHexPrefixed(v)) {
            return hexToBytes(padToEven(stripHexPrefix(v)));
        }
        return utf8ToBytes(v);
    }
    if (typeof v === 'number' || typeof v === 'bigint') {
        if (!v) {
            return Uint8Array.from([]);
        }
        return hexToBytes(numberToHex(v));
    }
    if (v === null || v === undefined) {
        return Uint8Array.from([]);
    }
    throw new Error('toBytes: received unsupported type ' + typeof v);
}
exports.utils = {
    bytesToHex,
    concatBytes,
    hexToBytes,
    utf8ToBytes,
};
exports.RLP = { encode, decode };


/***/ }),

/***/ 76851:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   i: () => (/* binding */ version)
/* harmony export */ });
const version = "address/5.7.0";


/***/ }),

/***/ 79771:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  O$: () => (/* binding */ BigNumber),
  g$: () => (/* binding */ _base36To16)
});

// UNUSED EXPORTS: _base16To36, isBigNumberish

// EXTERNAL MODULE: ./node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js
var bn = __webpack_require__(73182);
var bn_default = /*#__PURE__*/__webpack_require__.n(bn);
// EXTERNAL MODULE: ./node_modules/.pnpm/@ethersproject+bytes@5.7.0/node_modules/@ethersproject/bytes/lib.esm/index.js
var lib_esm = __webpack_require__(87737);
// EXTERNAL MODULE: ./node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js + 1 modules
var logger_lib_esm = __webpack_require__(43288);
;// CONCATENATED MODULE: ./node_modules/.pnpm/@ethersproject+bignumber@5.7.0/node_modules/@ethersproject/bignumber/lib.esm/_version.js
const version = "bignumber/5.7.0";

;// CONCATENATED MODULE: ./node_modules/.pnpm/@ethersproject+bignumber@5.7.0/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js

/**
 *  BigNumber
 *
 *  A wrapper around the BN.js object. We use the BN.js library
 *  because it is used by elliptic, so it is required regardless.
 *
 */

var BN = (bn_default()).BN;



const logger = new logger_lib_esm/* Logger */.Yd(version);
const _constructorGuard = {};
const MAX_SAFE = 0x1fffffffffffff;
function isBigNumberish(value) {
    return (value != null) && (BigNumber.isBigNumber(value) ||
        (typeof (value) === "number" && (value % 1) === 0) ||
        (typeof (value) === "string" && !!value.match(/^-?[0-9]+$/)) ||
        isHexString(value) ||
        (typeof (value) === "bigint") ||
        isBytes(value));
}
// Only warn about passing 10 into radix once
let _warnedToStringRadix = false;
class BigNumber {
    constructor(constructorGuard, hex) {
        if (constructorGuard !== _constructorGuard) {
            logger.throwError("cannot call constructor directly; use BigNumber.from", logger_lib_esm/* Logger */.Yd.errors.UNSUPPORTED_OPERATION, {
                operation: "new (BigNumber)"
            });
        }
        this._hex = hex;
        this._isBigNumber = true;
        Object.freeze(this);
    }
    fromTwos(value) {
        return toBigNumber(toBN(this).fromTwos(value));
    }
    toTwos(value) {
        return toBigNumber(toBN(this).toTwos(value));
    }
    abs() {
        if (this._hex[0] === "-") {
            return BigNumber.from(this._hex.substring(1));
        }
        return this;
    }
    add(other) {
        return toBigNumber(toBN(this).add(toBN(other)));
    }
    sub(other) {
        return toBigNumber(toBN(this).sub(toBN(other)));
    }
    div(other) {
        const o = BigNumber.from(other);
        if (o.isZero()) {
            throwFault("division-by-zero", "div");
        }
        return toBigNumber(toBN(this).div(toBN(other)));
    }
    mul(other) {
        return toBigNumber(toBN(this).mul(toBN(other)));
    }
    mod(other) {
        const value = toBN(other);
        if (value.isNeg()) {
            throwFault("division-by-zero", "mod");
        }
        return toBigNumber(toBN(this).umod(value));
    }
    pow(other) {
        const value = toBN(other);
        if (value.isNeg()) {
            throwFault("negative-power", "pow");
        }
        return toBigNumber(toBN(this).pow(value));
    }
    and(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
            throwFault("unbound-bitwise-result", "and");
        }
        return toBigNumber(toBN(this).and(value));
    }
    or(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
            throwFault("unbound-bitwise-result", "or");
        }
        return toBigNumber(toBN(this).or(value));
    }
    xor(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
            throwFault("unbound-bitwise-result", "xor");
        }
        return toBigNumber(toBN(this).xor(value));
    }
    mask(value) {
        if (this.isNegative() || value < 0) {
            throwFault("negative-width", "mask");
        }
        return toBigNumber(toBN(this).maskn(value));
    }
    shl(value) {
        if (this.isNegative() || value < 0) {
            throwFault("negative-width", "shl");
        }
        return toBigNumber(toBN(this).shln(value));
    }
    shr(value) {
        if (this.isNegative() || value < 0) {
            throwFault("negative-width", "shr");
        }
        return toBigNumber(toBN(this).shrn(value));
    }
    eq(other) {
        return toBN(this).eq(toBN(other));
    }
    lt(other) {
        return toBN(this).lt(toBN(other));
    }
    lte(other) {
        return toBN(this).lte(toBN(other));
    }
    gt(other) {
        return toBN(this).gt(toBN(other));
    }
    gte(other) {
        return toBN(this).gte(toBN(other));
    }
    isNegative() {
        return (this._hex[0] === "-");
    }
    isZero() {
        return toBN(this).isZero();
    }
    toNumber() {
        try {
            return toBN(this).toNumber();
        }
        catch (error) {
            throwFault("overflow", "toNumber", this.toString());
        }
        return null;
    }
    toBigInt() {
        try {
            return BigInt(this.toString());
        }
        catch (e) { }
        return logger.throwError("this platform does not support BigInt", logger_lib_esm/* Logger */.Yd.errors.UNSUPPORTED_OPERATION, {
            value: this.toString()
        });
    }
    toString() {
        // Lots of people expect this, which we do not support, so check (See: #889)
        if (arguments.length > 0) {
            if (arguments[0] === 10) {
                if (!_warnedToStringRadix) {
                    _warnedToStringRadix = true;
                    logger.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
                }
            }
            else if (arguments[0] === 16) {
                logger.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", logger_lib_esm/* Logger */.Yd.errors.UNEXPECTED_ARGUMENT, {});
            }
            else {
                logger.throwError("BigNumber.toString does not accept parameters", logger_lib_esm/* Logger */.Yd.errors.UNEXPECTED_ARGUMENT, {});
            }
        }
        return toBN(this).toString(10);
    }
    toHexString() {
        return this._hex;
    }
    toJSON(key) {
        return { type: "BigNumber", hex: this.toHexString() };
    }
    static from(value) {
        if (value instanceof BigNumber) {
            return value;
        }
        if (typeof (value) === "string") {
            if (value.match(/^-?0x[0-9a-f]+$/i)) {
                return new BigNumber(_constructorGuard, toHex(value));
            }
            if (value.match(/^-?[0-9]+$/)) {
                return new BigNumber(_constructorGuard, toHex(new BN(value)));
            }
            return logger.throwArgumentError("invalid BigNumber string", "value", value);
        }
        if (typeof (value) === "number") {
            if (value % 1) {
                throwFault("underflow", "BigNumber.from", value);
            }
            if (value >= MAX_SAFE || value <= -MAX_SAFE) {
                throwFault("overflow", "BigNumber.from", value);
            }
            return BigNumber.from(String(value));
        }
        const anyValue = value;
        if (typeof (anyValue) === "bigint") {
            return BigNumber.from(anyValue.toString());
        }
        if ((0,lib_esm/* isBytes */._t)(anyValue)) {
            return BigNumber.from((0,lib_esm/* hexlify */.Dv)(anyValue));
        }
        if (anyValue) {
            // Hexable interface (takes priority)
            if (anyValue.toHexString) {
                const hex = anyValue.toHexString();
                if (typeof (hex) === "string") {
                    return BigNumber.from(hex);
                }
            }
            else {
                // For now, handle legacy JSON-ified values (goes away in v6)
                let hex = anyValue._hex;
                // New-form JSON
                if (hex == null && anyValue.type === "BigNumber") {
                    hex = anyValue.hex;
                }
                if (typeof (hex) === "string") {
                    if ((0,lib_esm/* isHexString */.A7)(hex) || (hex[0] === "-" && (0,lib_esm/* isHexString */.A7)(hex.substring(1)))) {
                        return BigNumber.from(hex);
                    }
                }
            }
        }
        return logger.throwArgumentError("invalid BigNumber value", "value", value);
    }
    static isBigNumber(value) {
        return !!(value && value._isBigNumber);
    }
}
// Normalize the hex string
function toHex(value) {
    // For BN, call on the hex string
    if (typeof (value) !== "string") {
        return toHex(value.toString(16));
    }
    // If negative, prepend the negative sign to the normalized positive value
    if (value[0] === "-") {
        // Strip off the negative sign
        value = value.substring(1);
        // Cannot have multiple negative signs (e.g. "--0x04")
        if (value[0] === "-") {
            logger.throwArgumentError("invalid hex", "value", value);
        }
        // Call toHex on the positive component
        value = toHex(value);
        // Do not allow "-0x00"
        if (value === "0x00") {
            return value;
        }
        // Negate the value
        return "-" + value;
    }
    // Add a "0x" prefix if missing
    if (value.substring(0, 2) !== "0x") {
        value = "0x" + value;
    }
    // Normalize zero
    if (value === "0x") {
        return "0x00";
    }
    // Make the string even length
    if (value.length % 2) {
        value = "0x0" + value.substring(2);
    }
    // Trim to smallest even-length string
    while (value.length > 4 && value.substring(0, 4) === "0x00") {
        value = "0x" + value.substring(4);
    }
    return value;
}
function toBigNumber(value) {
    return BigNumber.from(toHex(value));
}
function toBN(value) {
    const hex = BigNumber.from(value).toHexString();
    if (hex[0] === "-") {
        return (new BN("-" + hex.substring(3), 16));
    }
    return new BN(hex.substring(2), 16);
}
function throwFault(fault, operation, value) {
    const params = { fault: fault, operation: operation };
    if (value != null) {
        params.value = value;
    }
    return logger.throwError(fault, logger_lib_esm/* Logger */.Yd.errors.NUMERIC_FAULT, params);
}
// value should have no prefix
function _base36To16(value) {
    return (new BN(value, 36)).toString(16);
}
// value should have no prefix
function _base16To36(value) {
    return (new BN(value, 16)).toString(36);
}


/***/ }),

/***/ 15271:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   i: () => (/* binding */ version)
/* harmony export */ });
const version = "bytes/5.7.0";


/***/ }),

/***/ 80586:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Bz: () => (/* binding */ MaxUint256),
/* harmony export */   _Y: () => (/* binding */ Zero),
/* harmony export */   fh: () => (/* binding */ One),
/* harmony export */   tL: () => (/* binding */ NegativeOne)
/* harmony export */ });
/* unused harmony exports Two, WeiPerEther, MinInt256, MaxInt256 */
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(79771);

const NegativeOne = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__/* .BigNumber */ .O$.from(-1));
const Zero = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__/* .BigNumber */ .O$.from(0));
const One = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__/* .BigNumber */ .O$.from(1));
const Two = ( /*#__PURE__*/(/* unused pure expression or super */ null && (BigNumber.from(2))));
const WeiPerEther = ( /*#__PURE__*/(/* unused pure expression or super */ null && (BigNumber.from("1000000000000000000"))));
const MaxUint256 = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__/* .BigNumber */ .O$.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
const MinInt256 = ( /*#__PURE__*/(/* unused pure expression or super */ null && (BigNumber.from("-0x8000000000000000000000000000000000000000000000000000000000000000"))));
const MaxInt256 = ( /*#__PURE__*/(/* unused pure expression or super */ null && (BigNumber.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"))));



/***/ }),

/***/ 76950:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   w: () => (/* binding */ keccak256)
/* harmony export */ });
/* harmony import */ var js_sha3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50986);
/* harmony import */ var js_sha3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(js_sha3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(87737);



function keccak256(data) {
    return '0x' + js_sha3__WEBPACK_IMPORTED_MODULE_0___default().keccak_256((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__/* .arrayify */ .lE)(data));
}


/***/ }),

/***/ 43288:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Yd: () => (/* binding */ Logger)
});

// UNUSED EXPORTS: ErrorCode, LogLevel

;// CONCATENATED MODULE: ./node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/_version.js
const version = "logger/5.7.0";

;// CONCATENATED MODULE: ./node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js

let _permanentCensorErrors = false;
let _censorErrors = false;
const LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
let _logLevel = LogLevels["default"];

let _globalLogger = null;
function _checkNormalize() {
    try {
        const missing = [];
        // Make sure all forms of normalization are supported
        ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
            try {
                if ("test".normalize(form) !== "test") {
                    throw new Error("bad normalize");
                }
                ;
            }
            catch (error) {
                missing.push(form);
            }
        });
        if (missing.length) {
            throw new Error("missing " + missing.join(", "));
        }
        if (String.fromCharCode(0xe9).normalize("NFD") !== String.fromCharCode(0x65, 0x0301)) {
            throw new Error("broken implementation");
        }
    }
    catch (error) {
        return error.message;
    }
    return null;
}
const _normalizeError = _checkNormalize();
var LogLevel;
(function (LogLevel) {
    LogLevel["DEBUG"] = "DEBUG";
    LogLevel["INFO"] = "INFO";
    LogLevel["WARNING"] = "WARNING";
    LogLevel["ERROR"] = "ERROR";
    LogLevel["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function (ErrorCode) {
    ///////////////////
    // Generic Errors
    // Unknown Error
    ErrorCode["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
    // Not Implemented
    ErrorCode["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
    // Unsupported Operation
    //   - operation
    ErrorCode["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)
    //   - event ("noNetwork" is not re-thrown in provider.ready; otherwise thrown)
    ErrorCode["NETWORK_ERROR"] = "NETWORK_ERROR";
    // Some sort of bad response from the server
    ErrorCode["SERVER_ERROR"] = "SERVER_ERROR";
    // Timeout
    ErrorCode["TIMEOUT"] = "TIMEOUT";
    ///////////////////
    // Operational  Errors
    // Buffer Overrun
    ErrorCode["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
    // Numeric Fault
    //   - operation: the operation being executed
    //   - fault: the reason this faulted
    ErrorCode["NUMERIC_FAULT"] = "NUMERIC_FAULT";
    ///////////////////
    // Argument Errors
    // Missing new operator to an object
    //  - name: The name of the class
    ErrorCode["MISSING_NEW"] = "MISSING_NEW";
    // Invalid argument (e.g. value is incompatible with type) to a function:
    //   - argument: The argument name that was invalid
    //   - value: The value of the argument
    ErrorCode["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
    // Missing argument to a function:
    //   - count: The number of arguments received
    //   - expectedCount: The number of arguments expected
    ErrorCode["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
    // Too many arguments
    //   - count: The number of arguments received
    //   - expectedCount: The number of arguments expected
    ErrorCode["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
    ///////////////////
    // Blockchain Errors
    // Call exception
    //  - transaction: the transaction
    //  - address?: the contract address
    //  - args?: The arguments passed into the function
    //  - method?: The Solidity method signature
    //  - errorSignature?: The EIP848 error signature
    //  - errorArgs?: The EIP848 error parameters
    //  - reason: The reason (only for EIP848 "Error(string)")
    ErrorCode["CALL_EXCEPTION"] = "CALL_EXCEPTION";
    // Insufficient funds (< value + gasLimit * gasPrice)
    //   - transaction: the transaction attempted
    ErrorCode["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
    // Nonce has already been used
    //   - transaction: the transaction attempted
    ErrorCode["NONCE_EXPIRED"] = "NONCE_EXPIRED";
    // The replacement fee for the transaction is too low
    //   - transaction: the transaction attempted
    ErrorCode["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
    // The gas limit could not be estimated
    //   - transaction: the transaction passed to estimateGas
    ErrorCode["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
    // The transaction was replaced by one with a higher gas price
    //   - reason: "cancelled", "replaced" or "repriced"
    //   - cancelled: true if reason == "cancelled" or reason == "replaced")
    //   - hash: original transaction hash
    //   - replacement: the full TransactionsResponse for the replacement
    //   - receipt: the receipt of the replacement
    ErrorCode["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
    ///////////////////
    // Interaction Errors
    // The user rejected the action, such as signing a message or sending
    // a transaction
    ErrorCode["ACTION_REJECTED"] = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
;
const HEX = "0123456789abcdef";
class Logger {
    constructor(version) {
        Object.defineProperty(this, "version", {
            enumerable: true,
            value: version,
            writable: false
        });
    }
    _log(logLevel, args) {
        const level = logLevel.toLowerCase();
        if (LogLevels[level] == null) {
            this.throwArgumentError("invalid log level name", "logLevel", logLevel);
        }
        if (_logLevel > LogLevels[level]) {
            return;
        }
        console.log.apply(console, args);
    }
    debug(...args) {
        this._log(Logger.levels.DEBUG, args);
    }
    info(...args) {
        this._log(Logger.levels.INFO, args);
    }
    warn(...args) {
        this._log(Logger.levels.WARNING, args);
    }
    makeError(message, code, params) {
        // Errors are being censored
        if (_censorErrors) {
            return this.makeError("censored error", code, {});
        }
        if (!code) {
            code = Logger.errors.UNKNOWN_ERROR;
        }
        if (!params) {
            params = {};
        }
        const messageDetails = [];
        Object.keys(params).forEach((key) => {
            const value = params[key];
            try {
                if (value instanceof Uint8Array) {
                    let hex = "";
                    for (let i = 0; i < value.length; i++) {
                        hex += HEX[value[i] >> 4];
                        hex += HEX[value[i] & 0x0f];
                    }
                    messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
                }
                else {
                    messageDetails.push(key + "=" + JSON.stringify(value));
                }
            }
            catch (error) {
                messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
            }
        });
        messageDetails.push(`code=${code}`);
        messageDetails.push(`version=${this.version}`);
        const reason = message;
        let url = "";
        switch (code) {
            case ErrorCode.NUMERIC_FAULT: {
                url = "NUMERIC_FAULT";
                const fault = message;
                switch (fault) {
                    case "overflow":
                    case "underflow":
                    case "division-by-zero":
                        url += "-" + fault;
                        break;
                    case "negative-power":
                    case "negative-width":
                        url += "-unsupported";
                        break;
                    case "unbound-bitwise-result":
                        url += "-unbound-result";
                        break;
                }
                break;
            }
            case ErrorCode.CALL_EXCEPTION:
            case ErrorCode.INSUFFICIENT_FUNDS:
            case ErrorCode.MISSING_NEW:
            case ErrorCode.NONCE_EXPIRED:
            case ErrorCode.REPLACEMENT_UNDERPRICED:
            case ErrorCode.TRANSACTION_REPLACED:
            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
                url = code;
                break;
        }
        if (url) {
            message += " [ See: https:/\/links.ethers.org/v5-errors-" + url + " ]";
        }
        if (messageDetails.length) {
            message += " (" + messageDetails.join(", ") + ")";
        }
        // @TODO: Any??
        const error = new Error(message);
        error.reason = reason;
        error.code = code;
        Object.keys(params).forEach(function (key) {
            error[key] = params[key];
        });
        return error;
    }
    throwError(message, code, params) {
        throw this.makeError(message, code, params);
    }
    throwArgumentError(message, name, value) {
        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
            argument: name,
            value: value
        });
    }
    assert(condition, message, code, params) {
        if (!!condition) {
            return;
        }
        this.throwError(message, code, params);
    }
    assertArgument(condition, message, name, value) {
        if (!!condition) {
            return;
        }
        this.throwArgumentError(message, name, value);
    }
    checkNormalize(message) {
        if (message == null) {
            message = "platform missing String.prototype.normalize";
        }
        if (_normalizeError) {
            this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "String.prototype.normalize", form: _normalizeError
            });
        }
    }
    checkSafeUint53(value, message) {
        if (typeof (value) !== "number") {
            return;
        }
        if (message == null) {
            message = "value not safe";
        }
        if (value < 0 || value >= 0x1fffffffffffff) {
            this.throwError(message, Logger.errors.NUMERIC_FAULT, {
                operation: "checkSafeInteger",
                fault: "out-of-safe-range",
                value: value
            });
        }
        if (value % 1) {
            this.throwError(message, Logger.errors.NUMERIC_FAULT, {
                operation: "checkSafeInteger",
                fault: "non-integer",
                value: value
            });
        }
    }
    checkArgumentCount(count, expectedCount, message) {
        if (message) {
            message = ": " + message;
        }
        else {
            message = "";
        }
        if (count < expectedCount) {
            this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
                count: count,
                expectedCount: expectedCount
            });
        }
        if (count > expectedCount) {
            this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
                count: count,
                expectedCount: expectedCount
            });
        }
    }
    checkNew(target, kind) {
        if (target === Object || target == null) {
            this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
        }
    }
    checkAbstract(target, kind) {
        if (target === kind) {
            this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
        }
        else if (target === Object || target == null) {
            this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
        }
    }
    static globalLogger() {
        if (!_globalLogger) {
            _globalLogger = new Logger(version);
        }
        return _globalLogger;
    }
    static setCensorship(censorship, permanent) {
        if (!censorship && permanent) {
            this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            });
        }
        if (_permanentCensorErrors) {
            if (!censorship) {
                return;
            }
            this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            });
        }
        _censorErrors = !!censorship;
        _permanentCensorErrors = !!permanent;
    }
    static setLogLevel(logLevel) {
        const level = LogLevels[logLevel.toLowerCase()];
        if (level == null) {
            Logger.globalLogger().warn("invalid log level - " + logLevel);
            return;
        }
        _logLevel = level;
    }
    static from(version) {
        return new Logger(version);
    }
}
Logger.errors = ErrorCode;
Logger.levels = LogLevel;


/***/ }),

/***/ 35426:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   i: () => (/* binding */ version)
/* harmony export */ });
const version = "properties/5.7.0";


/***/ }),

/***/ 60468:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Y0: () => (/* binding */ toUtf8Bytes),
  ZN: () => (/* binding */ toUtf8String)
});

// UNUSED EXPORTS: UnicodeNormalizationForm, Utf8ErrorFuncs, Utf8ErrorReason, _toEscapedUtf8String, _toUtf8String, toUtf8CodePoints

// EXTERNAL MODULE: ./node_modules/.pnpm/@ethersproject+bytes@5.7.0/node_modules/@ethersproject/bytes/lib.esm/index.js
var lib_esm = __webpack_require__(87737);
// EXTERNAL MODULE: ./node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js + 1 modules
var logger_lib_esm = __webpack_require__(43288);
;// CONCATENATED MODULE: ./node_modules/.pnpm/@ethersproject+strings@5.7.0/node_modules/@ethersproject/strings/lib.esm/_version.js
const version = "strings/5.7.0";

;// CONCATENATED MODULE: ./node_modules/.pnpm/@ethersproject+strings@5.7.0/node_modules/@ethersproject/strings/lib.esm/utf8.js




const logger = new logger_lib_esm/* Logger */.Yd(version);
///////////////////////////////
var UnicodeNormalizationForm;
(function (UnicodeNormalizationForm) {
    UnicodeNormalizationForm["current"] = "";
    UnicodeNormalizationForm["NFC"] = "NFC";
    UnicodeNormalizationForm["NFD"] = "NFD";
    UnicodeNormalizationForm["NFKC"] = "NFKC";
    UnicodeNormalizationForm["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
;
var Utf8ErrorReason;
(function (Utf8ErrorReason) {
    // A continuation byte was present where there was nothing to continue
    // - offset = the index the codepoint began in
    Utf8ErrorReason["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found
    // - offset = the index the codepoint began in
    Utf8ErrorReason["BAD_PREFIX"] = "bad codepoint prefix";
    // The string is too short to process the expected codepoint
    // - offset = the index the codepoint began in
    Utf8ErrorReason["OVERRUN"] = "string overrun";
    // A missing continuation byte was expected but not found
    // - offset = the index the continuation byte was expected at
    Utf8ErrorReason["MISSING_CONTINUE"] = "missing continuation byte";
    // The computed code point is outside the range for UTF-8
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; outside the UTF-8 range
    Utf8ErrorReason["OUT_OF_RANGE"] = "out of UTF-8 range";
    // UTF-8 strings may not contain UTF-16 surrogate pairs
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range
    Utf8ErrorReason["UTF16_SURROGATE"] = "UTF-16 surrogate";
    // The string is an overlong representation
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; already bounds checked
    Utf8ErrorReason["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
;
function errorFunc(reason, offset, bytes, output, badCodepoint) {
    return logger.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes
    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
        let i = 0;
        for (let o = offset + 1; o < bytes.length; o++) {
            if (bytes[o] >> 6 !== 0x02) {
                break;
            }
            i++;
        }
        return i;
    }
    // This byte runs us past the end of the string, so just jump to the end
    // (but the first byte was read already read and therefore skipped)
    if (reason === Utf8ErrorReason.OVERRUN) {
        return bytes.length - offset - 1;
    }
    // Nothing to skip
    return 0;
}
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
    // Overlong representations are otherwise "valid" code points; just non-deistingtished
    if (reason === Utf8ErrorReason.OVERLONG) {
        output.push(badCodepoint);
        return 0;
    }
    // Put the replacement character into the output
    output.push(0xfffd);
    // Otherwise, process as if ignoring errors
    return ignoreFunc(reason, offset, bytes, output, badCodepoint);
}
// Common error handing strategies
const Utf8ErrorFuncs = Object.freeze({
    error: errorFunc,
    ignore: ignoreFunc,
    replace: replaceFunc
});
// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499
function getUtf8CodePoints(bytes, onError) {
    if (onError == null) {
        onError = Utf8ErrorFuncs.error;
    }
    bytes = (0,lib_esm/* arrayify */.lE)(bytes);
    const result = [];
    let i = 0;
    // Invalid bytes are ignored
    while (i < bytes.length) {
        const c = bytes[i++];
        // 0xxx xxxx
        if (c >> 7 === 0) {
            result.push(c);
            continue;
        }
        // Multibyte; how many bytes left for this character?
        let extraLength = null;
        let overlongMask = null;
        // 110x xxxx 10xx xxxx
        if ((c & 0xe0) === 0xc0) {
            extraLength = 1;
            overlongMask = 0x7f;
            // 1110 xxxx 10xx xxxx 10xx xxxx
        }
        else if ((c & 0xf0) === 0xe0) {
            extraLength = 2;
            overlongMask = 0x7ff;
            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx
        }
        else if ((c & 0xf8) === 0xf0) {
            extraLength = 3;
            overlongMask = 0xffff;
        }
        else {
            if ((c & 0xc0) === 0x80) {
                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);
            }
            else {
                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);
            }
            continue;
        }
        // Do we have enough bytes in our data?
        if (i - 1 + extraLength >= bytes.length) {
            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);
            continue;
        }
        // Remove the length prefix from the char
        let res = c & ((1 << (8 - extraLength - 1)) - 1);
        for (let j = 0; j < extraLength; j++) {
            let nextChar = bytes[i];
            // Invalid continuation byte
            if ((nextChar & 0xc0) != 0x80) {
                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);
                res = null;
                break;
            }
            ;
            res = (res << 6) | (nextChar & 0x3f);
            i++;
        }
        // See above loop for invalid continuation byte
        if (res === null) {
            continue;
        }
        // Maximum code point
        if (res > 0x10ffff) {
            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        // Reserved for UTF-16 surrogate halves
        if (res >= 0xd800 && res <= 0xdfff) {
            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        // Check for overlong sequences (more bytes than needed)
        if (res <= overlongMask) {
            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        result.push(res);
    }
    return result;
}
// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
    if (form != UnicodeNormalizationForm.current) {
        logger.checkNormalize();
        str = str.normalize(form);
    }
    let result = [];
    for (let i = 0; i < str.length; i++) {
        const c = str.charCodeAt(i);
        if (c < 0x80) {
            result.push(c);
        }
        else if (c < 0x800) {
            result.push((c >> 6) | 0xc0);
            result.push((c & 0x3f) | 0x80);
        }
        else if ((c & 0xfc00) == 0xd800) {
            i++;
            const c2 = str.charCodeAt(i);
            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {
                throw new Error("invalid utf-8 string");
            }
            // Surrogate Pair
            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
            result.push((pair >> 18) | 0xf0);
            result.push(((pair >> 12) & 0x3f) | 0x80);
            result.push(((pair >> 6) & 0x3f) | 0x80);
            result.push((pair & 0x3f) | 0x80);
        }
        else {
            result.push((c >> 12) | 0xe0);
            result.push(((c >> 6) & 0x3f) | 0x80);
            result.push((c & 0x3f) | 0x80);
        }
    }
    return (0,lib_esm/* arrayify */.lE)(result);
}
;
function escapeChar(value) {
    const hex = ("0000" + value.toString(16));
    return "\\u" + hex.substring(hex.length - 4);
}
function _toEscapedUtf8String(bytes, onError) {
    return '"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {
        if (codePoint < 256) {
            switch (codePoint) {
                case 8: return "\\b";
                case 9: return "\\t";
                case 10: return "\\n";
                case 13: return "\\r";
                case 34: return "\\\"";
                case 92: return "\\\\";
            }
            if (codePoint >= 32 && codePoint < 127) {
                return String.fromCharCode(codePoint);
            }
        }
        if (codePoint <= 0xffff) {
            return escapeChar(codePoint);
        }
        codePoint -= 0x10000;
        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);
    }).join("") + '"';
}
function _toUtf8String(codePoints) {
    return codePoints.map((codePoint) => {
        if (codePoint <= 0xffff) {
            return String.fromCharCode(codePoint);
        }
        codePoint -= 0x10000;
        return String.fromCharCode((((codePoint >> 10) & 0x3ff) + 0xd800), ((codePoint & 0x3ff) + 0xdc00));
    }).join("");
}
function toUtf8String(bytes, onError) {
    return _toUtf8String(getUtf8CodePoints(bytes, onError));
}
function toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {
    return getUtf8CodePoints(toUtf8Bytes(str, form));
}


/***/ }),

/***/ 57949:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  TransactionTypes: () => (/* binding */ TransactionTypes),
  accessListify: () => (/* binding */ accessListify),
  computeAddress: () => (/* binding */ computeAddress),
  parse: () => (/* binding */ parse),
  recoverAddress: () => (/* binding */ recoverAddress),
  serialize: () => (/* binding */ serialize)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/@ethersproject+address@5.7.0/node_modules/@ethersproject/address/lib.esm/index.js
var lib_esm = __webpack_require__(32329);
// EXTERNAL MODULE: ./node_modules/.pnpm/@ethersproject+bignumber@5.7.0/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js + 1 modules
var bignumber = __webpack_require__(79771);
// EXTERNAL MODULE: ./node_modules/.pnpm/@ethersproject+bytes@5.7.0/node_modules/@ethersproject/bytes/lib.esm/index.js
var bytes_lib_esm = __webpack_require__(87737);
// EXTERNAL MODULE: ./node_modules/.pnpm/@ethersproject+constants@5.7.0/node_modules/@ethersproject/constants/lib.esm/bignumbers.js
var bignumbers = __webpack_require__(80586);
// EXTERNAL MODULE: ./node_modules/.pnpm/@ethersproject+keccak256@5.7.0/node_modules/@ethersproject/keccak256/lib.esm/index.js
var keccak256_lib_esm = __webpack_require__(76950);
// EXTERNAL MODULE: ./node_modules/.pnpm/@ethersproject+properties@5.7.0/node_modules/@ethersproject/properties/lib.esm/index.js
var properties_lib_esm = __webpack_require__(67745);
// EXTERNAL MODULE: ./node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js + 1 modules
var logger_lib_esm = __webpack_require__(43288);
;// CONCATENATED MODULE: ./node_modules/.pnpm/@ethersproject+rlp@5.7.0/node_modules/@ethersproject/rlp/lib.esm/_version.js
const version = "rlp/5.7.0";

;// CONCATENATED MODULE: ./node_modules/.pnpm/@ethersproject+rlp@5.7.0/node_modules/@ethersproject/rlp/lib.esm/index.js

//See: https://github.com/ethereum/wiki/wiki/RLP



const logger = new logger_lib_esm/* Logger */.Yd(version);
function arrayifyInteger(value) {
    const result = [];
    while (value) {
        result.unshift(value & 0xff);
        value >>= 8;
    }
    return result;
}
function unarrayifyInteger(data, offset, length) {
    let result = 0;
    for (let i = 0; i < length; i++) {
        result = (result * 256) + data[offset + i];
    }
    return result;
}
function _encode(object) {
    if (Array.isArray(object)) {
        let payload = [];
        object.forEach(function (child) {
            payload = payload.concat(_encode(child));
        });
        if (payload.length <= 55) {
            payload.unshift(0xc0 + payload.length);
            return payload;
        }
        const length = arrayifyInteger(payload.length);
        length.unshift(0xf7 + length.length);
        return length.concat(payload);
    }
    if (!(0,bytes_lib_esm/* isBytesLike */.Zq)(object)) {
        logger.throwArgumentError("RLP object must be BytesLike", "object", object);
    }
    const data = Array.prototype.slice.call((0,bytes_lib_esm/* arrayify */.lE)(object));
    if (data.length === 1 && data[0] <= 0x7f) {
        return data;
    }
    else if (data.length <= 55) {
        data.unshift(0x80 + data.length);
        return data;
    }
    const length = arrayifyInteger(data.length);
    length.unshift(0xb7 + length.length);
    return length.concat(data);
}
function encode(object) {
    return (0,bytes_lib_esm/* hexlify */.Dv)(_encode(object));
}
function _decodeChildren(data, offset, childOffset, length) {
    const result = [];
    while (childOffset < offset + 1 + length) {
        const decoded = _decode(data, childOffset);
        result.push(decoded.result);
        childOffset += decoded.consumed;
        if (childOffset > offset + 1 + length) {
            logger.throwError("child data too short", logger_lib_esm/* Logger */.Yd.errors.BUFFER_OVERRUN, {});
        }
    }
    return { consumed: (1 + length), result: result };
}
// returns { consumed: number, result: Object }
function _decode(data, offset) {
    if (data.length === 0) {
        logger.throwError("data too short", logger_lib_esm/* Logger */.Yd.errors.BUFFER_OVERRUN, {});
    }
    // Array with extra length prefix
    if (data[offset] >= 0xf8) {
        const lengthLength = data[offset] - 0xf7;
        if (offset + 1 + lengthLength > data.length) {
            logger.throwError("data short segment too short", logger_lib_esm/* Logger */.Yd.errors.BUFFER_OVERRUN, {});
        }
        const length = unarrayifyInteger(data, offset + 1, lengthLength);
        if (offset + 1 + lengthLength + length > data.length) {
            logger.throwError("data long segment too short", logger_lib_esm/* Logger */.Yd.errors.BUFFER_OVERRUN, {});
        }
        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
    }
    else if (data[offset] >= 0xc0) {
        const length = data[offset] - 0xc0;
        if (offset + 1 + length > data.length) {
            logger.throwError("data array too short", logger_lib_esm/* Logger */.Yd.errors.BUFFER_OVERRUN, {});
        }
        return _decodeChildren(data, offset, offset + 1, length);
    }
    else if (data[offset] >= 0xb8) {
        const lengthLength = data[offset] - 0xb7;
        if (offset + 1 + lengthLength > data.length) {
            logger.throwError("data array too short", logger_lib_esm/* Logger */.Yd.errors.BUFFER_OVERRUN, {});
        }
        const length = unarrayifyInteger(data, offset + 1, lengthLength);
        if (offset + 1 + lengthLength + length > data.length) {
            logger.throwError("data array too short", logger_lib_esm/* Logger */.Yd.errors.BUFFER_OVERRUN, {});
        }
        const result = (0,bytes_lib_esm/* hexlify */.Dv)(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
        return { consumed: (1 + lengthLength + length), result: result };
    }
    else if (data[offset] >= 0x80) {
        const length = data[offset] - 0x80;
        if (offset + 1 + length > data.length) {
            logger.throwError("data too short", logger_lib_esm/* Logger */.Yd.errors.BUFFER_OVERRUN, {});
        }
        const result = (0,bytes_lib_esm/* hexlify */.Dv)(data.slice(offset + 1, offset + 1 + length));
        return { consumed: (1 + length), result: result };
    }
    return { consumed: 1, result: (0,bytes_lib_esm/* hexlify */.Dv)(data[offset]) };
}
function decode(data) {
    const bytes = (0,bytes_lib_esm/* arrayify */.lE)(data);
    const decoded = _decode(bytes, 0);
    if (decoded.consumed !== bytes.length) {
        logger.throwArgumentError("invalid rlp data", "data", data);
    }
    return decoded.result;
}

// EXTERNAL MODULE: ./node_modules/.pnpm/@ethersproject+signing-key@5.7.0/node_modules/@ethersproject/signing-key/lib.esm/index.js + 2 modules
var signing_key_lib_esm = __webpack_require__(53890);
;// CONCATENATED MODULE: ./node_modules/.pnpm/@ethersproject+transactions@5.7.0/node_modules/@ethersproject/transactions/lib.esm/_version.js
const _version_version = "transactions/5.7.0";

;// CONCATENATED MODULE: ./node_modules/.pnpm/@ethersproject+transactions@5.7.0/node_modules/@ethersproject/transactions/lib.esm/index.js











const lib_esm_logger = new logger_lib_esm/* Logger */.Yd(_version_version);
var TransactionTypes;
(function (TransactionTypes) {
    TransactionTypes[TransactionTypes["legacy"] = 0] = "legacy";
    TransactionTypes[TransactionTypes["eip2930"] = 1] = "eip2930";
    TransactionTypes[TransactionTypes["eip1559"] = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));
;
///////////////////////////////
function handleAddress(value) {
    if (value === "0x") {
        return null;
    }
    return (0,lib_esm/* getAddress */.Kn)(value);
}
function handleNumber(value) {
    if (value === "0x") {
        return bignumbers/* Zero */._Y;
    }
    return bignumber/* BigNumber */.O$.from(value);
}
// Legacy Transaction Fields
const transactionFields = [
    { name: "nonce", maxLength: 32, numeric: true },
    { name: "gasPrice", maxLength: 32, numeric: true },
    { name: "gasLimit", maxLength: 32, numeric: true },
    { name: "to", length: 20 },
    { name: "value", maxLength: 32, numeric: true },
    { name: "data" },
];
const allowedTransactionKeys = {
    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, type: true, value: true
};
function computeAddress(key) {
    const publicKey = (0,signing_key_lib_esm/* computePublicKey */.VW)(key);
    return (0,lib_esm/* getAddress */.Kn)((0,bytes_lib_esm/* hexDataSlice */.p3)((0,keccak256_lib_esm/* keccak256 */.w)((0,bytes_lib_esm/* hexDataSlice */.p3)(publicKey, 1)), 12));
}
function recoverAddress(digest, signature) {
    return computeAddress((0,signing_key_lib_esm/* recoverPublicKey */.LO)((0,bytes_lib_esm/* arrayify */.lE)(digest), signature));
}
function formatNumber(value, name) {
    const result = (0,bytes_lib_esm/* stripZeros */.G1)(bignumber/* BigNumber */.O$.from(value).toHexString());
    if (result.length > 32) {
        lib_esm_logger.throwArgumentError("invalid length for " + name, ("transaction:" + name), value);
    }
    return result;
}
function accessSetify(addr, storageKeys) {
    return {
        address: (0,lib_esm/* getAddress */.Kn)(addr),
        storageKeys: (storageKeys || []).map((storageKey, index) => {
            if ((0,bytes_lib_esm/* hexDataLength */.E1)(storageKey) !== 32) {
                lib_esm_logger.throwArgumentError("invalid access list storageKey", `accessList[${addr}:${index}]`, storageKey);
            }
            return storageKey.toLowerCase();
        })
    };
}
function accessListify(value) {
    if (Array.isArray(value)) {
        return value.map((set, index) => {
            if (Array.isArray(set)) {
                if (set.length > 2) {
                    lib_esm_logger.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${index}]`, set);
                }
                return accessSetify(set[0], set[1]);
            }
            return accessSetify(set.address, set.storageKeys);
        });
    }
    const result = Object.keys(value).map((addr) => {
        const storageKeys = value[addr].reduce((accum, storageKey) => {
            accum[storageKey] = true;
            return accum;
        }, {});
        return accessSetify(addr, Object.keys(storageKeys).sort());
    });
    result.sort((a, b) => (a.address.localeCompare(b.address)));
    return result;
}
function formatAccessList(value) {
    return accessListify(value).map((set) => [set.address, set.storageKeys]);
}
function _serializeEip1559(transaction, signature) {
    // If there is an explicit gasPrice, make sure it matches the
    // EIP-1559 fees; otherwise they may not understand what they
    // think they are setting in terms of fee.
    if (transaction.gasPrice != null) {
        const gasPrice = bignumber/* BigNumber */.O$.from(transaction.gasPrice);
        const maxFeePerGas = bignumber/* BigNumber */.O$.from(transaction.maxFeePerGas || 0);
        if (!gasPrice.eq(maxFeePerGas)) {
            lib_esm_logger.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
                gasPrice, maxFeePerGas
            });
        }
    }
    const fields = [
        formatNumber(transaction.chainId || 0, "chainId"),
        formatNumber(transaction.nonce || 0, "nonce"),
        formatNumber(transaction.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
        formatNumber(transaction.maxFeePerGas || 0, "maxFeePerGas"),
        formatNumber(transaction.gasLimit || 0, "gasLimit"),
        ((transaction.to != null) ? (0,lib_esm/* getAddress */.Kn)(transaction.to) : "0x"),
        formatNumber(transaction.value || 0, "value"),
        (transaction.data || "0x"),
        (formatAccessList(transaction.accessList || []))
    ];
    if (signature) {
        const sig = (0,bytes_lib_esm/* splitSignature */.N)(signature);
        fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
        fields.push((0,bytes_lib_esm/* stripZeros */.G1)(sig.r));
        fields.push((0,bytes_lib_esm/* stripZeros */.G1)(sig.s));
    }
    return (0,bytes_lib_esm/* hexConcat */.xs)(["0x02", encode(fields)]);
}
function _serializeEip2930(transaction, signature) {
    const fields = [
        formatNumber(transaction.chainId || 0, "chainId"),
        formatNumber(transaction.nonce || 0, "nonce"),
        formatNumber(transaction.gasPrice || 0, "gasPrice"),
        formatNumber(transaction.gasLimit || 0, "gasLimit"),
        ((transaction.to != null) ? (0,lib_esm/* getAddress */.Kn)(transaction.to) : "0x"),
        formatNumber(transaction.value || 0, "value"),
        (transaction.data || "0x"),
        (formatAccessList(transaction.accessList || []))
    ];
    if (signature) {
        const sig = (0,bytes_lib_esm/* splitSignature */.N)(signature);
        fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
        fields.push((0,bytes_lib_esm/* stripZeros */.G1)(sig.r));
        fields.push((0,bytes_lib_esm/* stripZeros */.G1)(sig.s));
    }
    return (0,bytes_lib_esm/* hexConcat */.xs)(["0x01", encode(fields)]);
}
// Legacy Transactions and EIP-155
function _serialize(transaction, signature) {
    (0,properties_lib_esm/* checkProperties */.uj)(transaction, allowedTransactionKeys);
    const raw = [];
    transactionFields.forEach(function (fieldInfo) {
        let value = transaction[fieldInfo.name] || ([]);
        const options = {};
        if (fieldInfo.numeric) {
            options.hexPad = "left";
        }
        value = (0,bytes_lib_esm/* arrayify */.lE)((0,bytes_lib_esm/* hexlify */.Dv)(value, options));
        // Fixed-width field
        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {
            lib_esm_logger.throwArgumentError("invalid length for " + fieldInfo.name, ("transaction:" + fieldInfo.name), value);
        }
        // Variable-width (with a maximum)
        if (fieldInfo.maxLength) {
            value = (0,bytes_lib_esm/* stripZeros */.G1)(value);
            if (value.length > fieldInfo.maxLength) {
                lib_esm_logger.throwArgumentError("invalid length for " + fieldInfo.name, ("transaction:" + fieldInfo.name), value);
            }
        }
        raw.push((0,bytes_lib_esm/* hexlify */.Dv)(value));
    });
    let chainId = 0;
    if (transaction.chainId != null) {
        // A chainId was provided; if non-zero we'll use EIP-155
        chainId = transaction.chainId;
        if (typeof (chainId) !== "number") {
            lib_esm_logger.throwArgumentError("invalid transaction.chainId", "transaction", transaction);
        }
    }
    else if (signature && !(0,bytes_lib_esm/* isBytesLike */.Zq)(signature) && signature.v > 28) {
        // No chainId provided, but the signature is signing with EIP-155; derive chainId
        chainId = Math.floor((signature.v - 35) / 2);
    }
    // We have an EIP-155 transaction (chainId was specified and non-zero)
    if (chainId !== 0) {
        raw.push((0,bytes_lib_esm/* hexlify */.Dv)(chainId)); // @TODO: hexValue?
        raw.push("0x");
        raw.push("0x");
    }
    // Requesting an unsigned transaction
    if (!signature) {
        return encode(raw);
    }
    // The splitSignature will ensure the transaction has a recoveryParam in the
    // case that the signTransaction function only adds a v.
    const sig = (0,bytes_lib_esm/* splitSignature */.N)(signature);
    // We pushed a chainId and null r, s on for hashing only; remove those
    let v = 27 + sig.recoveryParam;
    if (chainId !== 0) {
        raw.pop();
        raw.pop();
        raw.pop();
        v += chainId * 2 + 8;
        // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!
        if (sig.v > 28 && sig.v !== v) {
            lib_esm_logger.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature);
        }
    }
    else if (sig.v !== v) {
        lib_esm_logger.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature);
    }
    raw.push((0,bytes_lib_esm/* hexlify */.Dv)(v));
    raw.push((0,bytes_lib_esm/* stripZeros */.G1)((0,bytes_lib_esm/* arrayify */.lE)(sig.r)));
    raw.push((0,bytes_lib_esm/* stripZeros */.G1)((0,bytes_lib_esm/* arrayify */.lE)(sig.s)));
    return encode(raw);
}
function serialize(transaction, signature) {
    // Legacy and EIP-155 Transactions
    if (transaction.type == null || transaction.type === 0) {
        if (transaction.accessList != null) {
            lib_esm_logger.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", transaction);
        }
        return _serialize(transaction, signature);
    }
    // Typed Transactions (EIP-2718)
    switch (transaction.type) {
        case 1:
            return _serializeEip2930(transaction, signature);
        case 2:
            return _serializeEip1559(transaction, signature);
        default:
            break;
    }
    return lib_esm_logger.throwError(`unsupported transaction type: ${transaction.type}`, logger_lib_esm/* Logger */.Yd.errors.UNSUPPORTED_OPERATION, {
        operation: "serializeTransaction",
        transactionType: transaction.type
    });
}
function _parseEipSignature(tx, fields, serialize) {
    try {
        const recid = handleNumber(fields[0]).toNumber();
        if (recid !== 0 && recid !== 1) {
            throw new Error("bad recid");
        }
        tx.v = recid;
    }
    catch (error) {
        lib_esm_logger.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
    }
    tx.r = (0,bytes_lib_esm/* hexZeroPad */.$m)(fields[1], 32);
    tx.s = (0,bytes_lib_esm/* hexZeroPad */.$m)(fields[2], 32);
    try {
        const digest = (0,keccak256_lib_esm/* keccak256 */.w)(serialize(tx));
        tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });
    }
    catch (error) { }
}
function _parseEip1559(payload) {
    const transaction = decode(payload.slice(1));
    if (transaction.length !== 9 && transaction.length !== 12) {
        lib_esm_logger.throwArgumentError("invalid component count for transaction type: 2", "payload", (0,bytes_lib_esm/* hexlify */.Dv)(payload));
    }
    const maxPriorityFeePerGas = handleNumber(transaction[2]);
    const maxFeePerGas = handleNumber(transaction[3]);
    const tx = {
        type: 2,
        chainId: handleNumber(transaction[0]).toNumber(),
        nonce: handleNumber(transaction[1]).toNumber(),
        maxPriorityFeePerGas: maxPriorityFeePerGas,
        maxFeePerGas: maxFeePerGas,
        gasPrice: null,
        gasLimit: handleNumber(transaction[4]),
        to: handleAddress(transaction[5]),
        value: handleNumber(transaction[6]),
        data: transaction[7],
        accessList: accessListify(transaction[8]),
    };
    // Unsigned EIP-1559 Transaction
    if (transaction.length === 9) {
        return tx;
    }
    tx.hash = (0,keccak256_lib_esm/* keccak256 */.w)(payload);
    _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);
    return tx;
}
function _parseEip2930(payload) {
    const transaction = decode(payload.slice(1));
    if (transaction.length !== 8 && transaction.length !== 11) {
        lib_esm_logger.throwArgumentError("invalid component count for transaction type: 1", "payload", (0,bytes_lib_esm/* hexlify */.Dv)(payload));
    }
    const tx = {
        type: 1,
        chainId: handleNumber(transaction[0]).toNumber(),
        nonce: handleNumber(transaction[1]).toNumber(),
        gasPrice: handleNumber(transaction[2]),
        gasLimit: handleNumber(transaction[3]),
        to: handleAddress(transaction[4]),
        value: handleNumber(transaction[5]),
        data: transaction[6],
        accessList: accessListify(transaction[7])
    };
    // Unsigned EIP-2930 Transaction
    if (transaction.length === 8) {
        return tx;
    }
    tx.hash = (0,keccak256_lib_esm/* keccak256 */.w)(payload);
    _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);
    return tx;
}
// Legacy Transactions and EIP-155
function _parse(rawTransaction) {
    const transaction = decode(rawTransaction);
    if (transaction.length !== 9 && transaction.length !== 6) {
        lib_esm_logger.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
    }
    const tx = {
        nonce: handleNumber(transaction[0]).toNumber(),
        gasPrice: handleNumber(transaction[1]),
        gasLimit: handleNumber(transaction[2]),
        to: handleAddress(transaction[3]),
        value: handleNumber(transaction[4]),
        data: transaction[5],
        chainId: 0
    };
    // Legacy unsigned transaction
    if (transaction.length === 6) {
        return tx;
    }
    try {
        tx.v = bignumber/* BigNumber */.O$.from(transaction[6]).toNumber();
    }
    catch (error) {
        // @TODO: What makes snese to do? The v is too big
        return tx;
    }
    tx.r = (0,bytes_lib_esm/* hexZeroPad */.$m)(transaction[7], 32);
    tx.s = (0,bytes_lib_esm/* hexZeroPad */.$m)(transaction[8], 32);
    if (bignumber/* BigNumber */.O$.from(tx.r).isZero() && bignumber/* BigNumber */.O$.from(tx.s).isZero()) {
        // EIP-155 unsigned transaction
        tx.chainId = tx.v;
        tx.v = 0;
    }
    else {
        // Signed Transaction
        tx.chainId = Math.floor((tx.v - 35) / 2);
        if (tx.chainId < 0) {
            tx.chainId = 0;
        }
        let recoveryParam = tx.v - 27;
        const raw = transaction.slice(0, 6);
        if (tx.chainId !== 0) {
            raw.push((0,bytes_lib_esm/* hexlify */.Dv)(tx.chainId));
            raw.push("0x");
            raw.push("0x");
            recoveryParam -= tx.chainId * 2 + 8;
        }
        const digest = (0,keccak256_lib_esm/* keccak256 */.w)(encode(raw));
        try {
            tx.from = recoverAddress(digest, { r: (0,bytes_lib_esm/* hexlify */.Dv)(tx.r), s: (0,bytes_lib_esm/* hexlify */.Dv)(tx.s), recoveryParam: recoveryParam });
        }
        catch (error) { }
        tx.hash = (0,keccak256_lib_esm/* keccak256 */.w)(rawTransaction);
    }
    tx.type = null;
    return tx;
}
function parse(rawTransaction) {
    const payload = (0,bytes_lib_esm/* arrayify */.lE)(rawTransaction);
    // Legacy and EIP-155 Transactions
    if (payload[0] > 0x7f) {
        return _parse(payload);
    }
    // Typed Transaction (EIP-2718)
    switch (payload[0]) {
        case 1:
            return _parseEip2930(payload);
        case 2:
            return _parseEip1559(payload);
        default:
            break;
    }
    return lib_esm_logger.throwError(`unsupported transaction type: ${payload[0]}`, logger_lib_esm/* Logger */.Yd.errors.UNSUPPORTED_OPERATION, {
        operation: "parseTransaction",
        transactionType: payload[0]
    });
}


/***/ }),

/***/ 77726:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ObjectMultiplex = void 0;
const readable_stream_1 = __webpack_require__(80116);
const end_of_stream_1 = __importDefault(__webpack_require__(93978));
const once_1 = __importDefault(__webpack_require__(71578));
const Substream_1 = __webpack_require__(59431);
const IGNORE_SUBSTREAM = Symbol('IGNORE_SUBSTREAM');
class ObjectMultiplex extends readable_stream_1.Duplex {
    constructor(opts = {}) {
        super(Object.assign(Object.assign({}, opts), { objectMode: true }));
        this._substreams = {};
    }
    createStream(name) {
        // guard stream against destroyed already
        if (this.destroyed) {
            throw new Error(`ObjectMultiplex - parent stream for name "${name}" already destroyed`);
        }
        // guard stream against ended already
        if (this._readableState.ended || this._writableState.ended) {
            throw new Error(`ObjectMultiplex - parent stream for name "${name}" already ended`);
        }
        // validate name
        if (!name) {
            throw new Error('ObjectMultiplex - name must not be empty');
        }
        if (this._substreams[name]) {
            throw new Error(`ObjectMultiplex - Substream for name "${name}" already exists`);
        }
        // create substream
        const substream = new Substream_1.Substream({ parent: this, name });
        this._substreams[name] = substream;
        // listen for parent stream to end
        anyStreamEnd(this, (_error) => {
            return substream.destroy(_error || undefined);
        });
        return substream;
    }
    // ignore streams (dont display orphaned data warning)
    ignoreStream(name) {
        // validate name
        if (!name) {
            throw new Error('ObjectMultiplex - name must not be empty');
        }
        if (this._substreams[name]) {
            throw new Error(`ObjectMultiplex - Substream for name "${name}" already exists`);
        }
        // set
        this._substreams[name] = IGNORE_SUBSTREAM;
    }
    _read() {
        return undefined;
    }
    _write(chunk, _encoding, callback) {
        const { name, data } = chunk;
        if (!name) {
            console.warn(`ObjectMultiplex - malformed chunk without name "${chunk}"`);
            return callback();
        }
        // get corresponding substream
        const substream = this._substreams[name];
        if (!substream) {
            console.warn(`ObjectMultiplex - orphaned data for stream "${name}"`);
            return callback();
        }
        // push data into substream
        if (substream !== IGNORE_SUBSTREAM) {
            substream.push(data);
        }
        return callback();
    }
}
exports.ObjectMultiplex = ObjectMultiplex;
// util
function anyStreamEnd(stream, _cb) {
    const cb = once_1.default(_cb);
    end_of_stream_1.default(stream, { readable: false }, cb);
    end_of_stream_1.default(stream, { writable: false }, cb);
}


/***/ }),

/***/ 59431:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Substream = void 0;
const readable_stream_1 = __webpack_require__(80116);
class Substream extends readable_stream_1.Duplex {
    constructor({ parent, name }) {
        super({ objectMode: true });
        this._parent = parent;
        this._name = name;
    }
    /**
     * Explicitly sets read operations to a no-op.
     */
    _read() {
        return undefined;
    }
    /**
     * Called when data should be written to this writable stream.
     *
     * @param chunk - Arbitrary object to write
     * @param encoding - Encoding to use when writing payload
     * @param callback - Called when writing is complete or an error occurs
     */
    _write(chunk, _encoding, callback) {
        this._parent.push({
            name: this._name,
            data: chunk,
        });
        callback();
    }
}
exports.Substream = Substream;


/***/ }),

/***/ 37556:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const ObjectMultiplex_1 = __webpack_require__(77726);
module.exports = ObjectMultiplex_1.ObjectMultiplex;


/***/ }),

/***/ 27010:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const events_1 = __webpack_require__(58470);
function safeApply(handler, context, args) {
    try {
        Reflect.apply(handler, context, args);
    }
    catch (err) {
        // Throw error after timeout so as not to interrupt the stack
        setTimeout(() => {
            throw err;
        });
    }
}
function arrayClone(arr) {
    const n = arr.length;
    const copy = new Array(n);
    for (let i = 0; i < n; i += 1) {
        copy[i] = arr[i];
    }
    return copy;
}
class SafeEventEmitter extends events_1.EventEmitter {
    emit(type, ...args) {
        let doError = type === 'error';
        const events = this._events;
        if (events !== undefined) {
            doError = doError && events.error === undefined;
        }
        else if (!doError) {
            return false;
        }
        // If there is no 'error' event listener then throw.
        if (doError) {
            let er;
            if (args.length > 0) {
                [er] = args;
            }
            if (er instanceof Error) {
                // Note: The comments on the `throw` lines are intentional, they show
                // up in Node's output if this results in an unhandled exception.
                throw er; // Unhandled 'error' event
            }
            // At least give some kind of context to the user
            const err = new Error(`Unhandled error.${er ? ` (${er.message})` : ''}`);
            err.context = er;
            throw err; // Unhandled 'error' event
        }
        const handler = events[type];
        if (handler === undefined) {
            return false;
        }
        if (typeof handler === 'function') {
            safeApply(handler, this, args);
        }
        else {
            const len = handler.length;
            const listeners = arrayClone(handler);
            for (let i = 0; i < len; i += 1) {
                safeApply(listeners[i], this, args);
            }
        }
        return true;
    }
}
exports["default"] = SafeEventEmitter;


/***/ }),

/***/ 47398:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Program = void 0;
const web3_js_1 = __webpack_require__(20374);
const accounts_1 = __webpack_require__(5337);
const buffer_1 = __webpack_require__(7661);
class Program {
    static findProgramAddress(seeds) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield web3_js_1.PublicKey.findProgramAddress(seeds, this.PUBKEY))[0];
        });
    }
    static getProgramAccounts(connection, configOrCommitment) {
        return __awaiter(this, void 0, void 0, function* () {
            const extra = {};
            let commitment;
            if (configOrCommitment) {
                if (typeof configOrCommitment === 'string') {
                    commitment = configOrCommitment;
                }
                else {
                    commitment = configOrCommitment.commitment;
                    if (configOrCommitment.dataSlice) {
                        extra.dataSlice = configOrCommitment.dataSlice;
                    }
                    if (configOrCommitment.filters) {
                        extra.filters = configOrCommitment.filters;
                    }
                }
            }
            const args = connection._buildArgs([this.PUBKEY.toBase58()], commitment, 'base64', extra);
            const unsafeRes = yield connection._rpcRequest('getProgramAccounts', args);
            return unsafeRes.result
                .map(({ account: { data, executable, lamports, owner }, pubkey }) => ({
                account: {
                    data: buffer_1.Buffer.from(data[0], 'base64'),
                    executable,
                    lamports,
                    owner: new web3_js_1.PublicKey(owner),
                },
                pubkey: new web3_js_1.PublicKey(pubkey),
            }))
                .map(({ pubkey, account }) => new accounts_1.Account(pubkey, account));
        });
    }
}
exports.Program = Program;


/***/ }),

/***/ 55153:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Transaction = void 0;
const web3_js_1 = __webpack_require__(20374);
class Transaction extends web3_js_1.Transaction {
    constructor(options) {
        super(options);
    }
    static fromCombined(transactions, options = {}) {
        const combinedTransaction = new Transaction(options);
        transactions.forEach((transaction) => transaction.instructions.forEach((instruction) => {
            combinedTransaction.add(instruction);
        }));
        return combinedTransaction;
    }
}
exports.Transaction = Transaction;


/***/ }),

/***/ 76017:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Account = void 0;
const web3_js_1 = __webpack_require__(20374);
const buffer_1 = __webpack_require__(7661);
const errors_1 = __webpack_require__(68576);
class Account {
    constructor(pubkey, info) {
        this.pubkey = new web3_js_1.PublicKey(pubkey);
        this.info = info;
    }
    static from(account) {
        return new this(account.pubkey, account.info);
    }
    static load(connection, pubkey) {
        return __awaiter(this, void 0, void 0, function* () {
            const info = yield Account.getInfo(connection, pubkey);
            return new this(pubkey, info);
        });
    }
    static isCompatible(_data) {
        throw new Error(`method 'isCompatible' is not implemented`);
    }
    static getInfo(connection, pubkey) {
        return __awaiter(this, void 0, void 0, function* () {
            const info = yield connection.getAccountInfo(new web3_js_1.PublicKey(pubkey));
            if (!info) {
                throw (0, errors_1.ERROR_ACCOUNT_NOT_FOUND)(pubkey);
            }
            return Object.assign(Object.assign({}, info), { data: buffer_1.Buffer.from(info === null || info === void 0 ? void 0 : info.data) });
        });
    }
    static getInfos(connection, pubkeys, commitment = 'recent') {
        return __awaiter(this, void 0, void 0, function* () {
            const BATCH_SIZE = 99;
            const promises = [];
            for (let i = 0; i < pubkeys.length; i += BATCH_SIZE) {
                promises.push(Account.getMultipleAccounts(connection, pubkeys.slice(i, Math.min(pubkeys.length, i + BATCH_SIZE)), commitment));
            }
            const results = new Map();
            (yield Promise.all(promises)).forEach((result) => { var _a; return [...((_a = result === null || result === void 0 ? void 0 : result.entries()) !== null && _a !== void 0 ? _a : [])].forEach(([k, v]) => results.set(k, v)); });
            return results;
        });
    }
    static getMultipleAccounts(connection, pubkeys, commitment) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = connection._buildArgs([pubkeys.map((k) => k.toString())], commitment, 'base64');
            const unsafeRes = yield connection._rpcRequest('getMultipleAccounts', args);
            if (unsafeRes.error) {
                throw new Error('failed to get info about accounts ' + unsafeRes.error.message);
            }
            if (!unsafeRes.result.value)
                return;
            const infos = unsafeRes.result.value
                .filter(Boolean)
                .map((info) => (Object.assign(Object.assign({}, info), { data: buffer_1.Buffer.from(info.data[0], 'base64') })));
            return infos.reduce((acc, info, index) => {
                acc.set(pubkeys[index], info);
                return acc;
            }, new Map());
        });
    }
    assertOwner(pubkey) {
        var _a;
        return (_a = this.info) === null || _a === void 0 ? void 0 : _a.owner.equals(new web3_js_1.PublicKey(pubkey));
    }
    toJSON() {
        var _a, _b, _c, _d, _e;
        return {
            pubkey: this.pubkey.toString(),
            info: {
                executable: !!((_a = this.info) === null || _a === void 0 ? void 0 : _a.executable),
                owner: ((_b = this.info) === null || _b === void 0 ? void 0 : _b.owner) ? new web3_js_1.PublicKey((_c = this.info) === null || _c === void 0 ? void 0 : _c.owner) : null,
                lamports: (_d = this.info) === null || _d === void 0 ? void 0 : _d.lamports,
                data: (_e = this.info) === null || _e === void 0 ? void 0 : _e.data.toJSON(),
            },
            data: this.data,
        };
    }
    toString() {
        return JSON.stringify(this.toJSON());
    }
}
exports.Account = Account;


/***/ }),

/***/ 96527:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deserialize = exports.TokenAccount = void 0;
const errors_1 = __webpack_require__(68576);
const Account_1 = __webpack_require__(76017);
const spl_token_1 = __webpack_require__(21303);
const web3_js_1 = __webpack_require__(20374);
class TokenAccount extends Account_1.Account {
    constructor(pubkey, info) {
        super(pubkey, info);
        if (!this.assertOwner(spl_token_1.TOKEN_PROGRAM_ID)) {
            throw (0, errors_1.ERROR_INVALID_OWNER)();
        }
        if (!TokenAccount.isCompatible(this.info.data)) {
            throw (0, errors_1.ERROR_INVALID_ACCOUNT_DATA)();
        }
        this.data = (0, exports.deserialize)(this.info.data);
    }
    static isCompatible(data) {
        return data.length === spl_token_1.AccountLayout.span;
    }
    static getTokenAccountsByOwner(connection, owner) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield connection.getTokenAccountsByOwner(new web3_js_1.PublicKey(owner), {
                programId: spl_token_1.TOKEN_PROGRAM_ID,
            })).value.map(({ pubkey, account }) => new TokenAccount(pubkey, account));
        });
    }
}
exports.TokenAccount = TokenAccount;
const deserialize = (data) => {
    const accountInfo = spl_token_1.AccountLayout.decode(data);
    accountInfo.mint = new web3_js_1.PublicKey(accountInfo.mint);
    accountInfo.owner = new web3_js_1.PublicKey(accountInfo.owner);
    accountInfo.amount = spl_token_1.u64.fromBuffer(accountInfo.amount);
    if (accountInfo.delegateOption === 0) {
        accountInfo.delegate = null;
        accountInfo.delegatedAmount = new spl_token_1.u64(0);
    }
    else {
        accountInfo.delegate = new web3_js_1.PublicKey(accountInfo.delegate);
        accountInfo.delegatedAmount = spl_token_1.u64.fromBuffer(accountInfo.delegatedAmount);
    }
    accountInfo.isInitialized = accountInfo.state !== 0;
    accountInfo.isFrozen = accountInfo.state === 2;
    if (accountInfo.isNativeOption === 1) {
        accountInfo.rentExemptReserve = spl_token_1.u64.fromBuffer(accountInfo.isNative);
        accountInfo.isNative = true;
    }
    else {
        accountInfo.rentExemptReserve = null;
        accountInfo.isNative = false;
    }
    if (accountInfo.closeAuthorityOption === 0) {
        accountInfo.closeAuthority = null;
    }
    else {
        accountInfo.closeAuthority = new web3_js_1.PublicKey(accountInfo.closeAuthority);
    }
    return accountInfo;
};
exports.deserialize = deserialize;


/***/ }),

/***/ 5337:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(76017), exports);
__exportStar(__webpack_require__(96527), exports);


/***/ }),

/***/ 44516:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.config = void 0;
exports.config = {
    arweaveWallet: 'HvwC9QSAzvGXhhVrgPmauVwFWcYZhne3hVot9EbHuFTm',
    programs: {
        auction: 'auctxRXPeJoc4817jDhf4HbjnhEcr1cCXenosMhK5R8',
        metadata: 'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s',
        metaplex: 'p1exdMJcjVao65QdewkaZRUnU6VPSXhus9n2GzWfh98',
        vault: 'vau1zxA2LbssAUEF7Gpw91zMM1LvXrvpzJtmZ58rPsn',
        packs: 'BNRmGgciUJuyznkYHnmitA9an1BcDDiU9JmjEQwvBYVR',
        memo: 'MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr',
        token: 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',
    },
    maxCreatorLimit: 5,
};


/***/ }),

/***/ 68576:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ERROR_ACCOUNT_NOT_FOUND = exports.ERROR_DEPRECATED_ACCOUNT_DATA = exports.ERROR_INVALID_ACCOUNT_DATA = exports.ERROR_INVALID_OWNER = exports.MetaplexError = exports.ErrorCode = void 0;
var ErrorCode;
(function (ErrorCode) {
    ErrorCode[ErrorCode["ERROR_INVALID_OWNER"] = 0] = "ERROR_INVALID_OWNER";
    ErrorCode[ErrorCode["ERROR_INVALID_ACCOUNT_DATA"] = 1] = "ERROR_INVALID_ACCOUNT_DATA";
    ErrorCode[ErrorCode["ERROR_DEPRECATED_ACCOUNT_DATA"] = 2] = "ERROR_DEPRECATED_ACCOUNT_DATA";
    ErrorCode[ErrorCode["ERROR_ACCOUNT_NOT_FOUND"] = 3] = "ERROR_ACCOUNT_NOT_FOUND";
})(ErrorCode = exports.ErrorCode || (exports.ErrorCode = {}));
class MetaplexError extends Error {
    constructor(errorCode, message) {
        super(message);
        this.errorCode = errorCode;
    }
}
exports.MetaplexError = MetaplexError;
const ERROR_INVALID_OWNER = () => {
    return new MetaplexError(ErrorCode.ERROR_INVALID_OWNER, 'Invalid owner');
};
exports.ERROR_INVALID_OWNER = ERROR_INVALID_OWNER;
const ERROR_INVALID_ACCOUNT_DATA = () => {
    return new MetaplexError(ErrorCode.ERROR_INVALID_ACCOUNT_DATA, 'Invalid data');
};
exports.ERROR_INVALID_ACCOUNT_DATA = ERROR_INVALID_ACCOUNT_DATA;
const ERROR_DEPRECATED_ACCOUNT_DATA = () => {
    return new MetaplexError(ErrorCode.ERROR_DEPRECATED_ACCOUNT_DATA, 'Account data is deprecated');
};
exports.ERROR_DEPRECATED_ACCOUNT_DATA = ERROR_DEPRECATED_ACCOUNT_DATA;
const ERROR_ACCOUNT_NOT_FOUND = (pubkey) => {
    return new MetaplexError(ErrorCode.ERROR_ACCOUNT_NOT_FOUND, `Unable to find account: ${pubkey}`);
};
exports.ERROR_ACCOUNT_NOT_FOUND = ERROR_ACCOUNT_NOT_FOUND;


/***/ }),

/***/ 68592:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(5337), exports);
__exportStar(__webpack_require__(44516), exports);
__exportStar(__webpack_require__(68576), exports);
__exportStar(__webpack_require__(47398), exports);
__exportStar(__webpack_require__(55153), exports);
__exportStar(__webpack_require__(18344), exports);
__exportStar(__webpack_require__(48668), exports);


/***/ }),

/***/ 18344:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 3167:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(7661)["Buffer"];

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.serialize = exports.deserializeUnchecked = exports.deserialize = exports.struct = exports.Data = exports.extendBorsh = void 0;
const web3_js_1 = __webpack_require__(20374);
const borsh_1 = __webpack_require__(71433);
Object.defineProperty(exports, "deserializeUnchecked", ({ enumerable: true, get: function () { return borsh_1.deserializeUnchecked; } }));
Object.defineProperty(exports, "serialize", ({ enumerable: true, get: function () { return borsh_1.serialize; } }));
Object.defineProperty(exports, "deserialize", ({ enumerable: true, get: function () { return borsh_1.deserialize; } }));
const bs58_1 = __importDefault(__webpack_require__(30721));
const extendBorsh = () => {
    borsh_1.BinaryReader.prototype.readPubkey = function () {
        const array = this.readFixedArray(32);
        return new web3_js_1.PublicKey(array);
    };
    borsh_1.BinaryWriter.prototype.writePubkey = function (value) {
        this.writeFixedArray(value.toBuffer());
    };
    borsh_1.BinaryReader.prototype.readPubkeyAsString = function () {
        const array = this.readFixedArray(32);
        return bs58_1.default.encode(array);
    };
    borsh_1.BinaryWriter.prototype.writePubkeyAsString = function (value) {
        this.writeFixedArray(bs58_1.default.decode(value));
    };
};
exports.extendBorsh = extendBorsh;
(0, exports.extendBorsh)();
class Data {
    constructor(args = {}) {
        Object.assign(this, args);
    }
    static struct(fields) {
        return (0, exports.struct)(this, fields);
    }
    static serialize(args = {}) {
        return Buffer.from((0, borsh_1.serialize)(this.SCHEMA, new this(args)));
    }
    static deserialize(data) {
        return (0, borsh_1.deserializeUnchecked)(this.SCHEMA, this, data);
    }
}
exports.Data = Data;
const struct = (type, fields) => {
    return new Map([[type, { kind: 'struct', fields }]]);
};
exports.struct = struct;


/***/ }),

/***/ 48668:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Borsh = void 0;
exports.Borsh = __importStar(__webpack_require__(3167));
__exportStar(__webpack_require__(21764), exports);


/***/ }),

/***/ 21764:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getBNFromData = exports.TupleNumericType = void 0;
const bn_js_1 = __importDefault(__webpack_require__(73117));
var TupleNumericType;
(function (TupleNumericType) {
    TupleNumericType[TupleNumericType["U8"] = 1] = "U8";
    TupleNumericType[TupleNumericType["U16"] = 2] = "U16";
    TupleNumericType[TupleNumericType["U32"] = 4] = "U32";
    TupleNumericType[TupleNumericType["U64"] = 8] = "U64";
})(TupleNumericType = exports.TupleNumericType || (exports.TupleNumericType = {}));
const getBNFromData = (data, offset, dataType) => {
    switch (dataType) {
        case TupleNumericType.U8:
            return new bn_js_1.default(data[offset], 'le');
        case TupleNumericType.U16:
            return new bn_js_1.default(data.slice(offset, offset + 2), 'le');
        case TupleNumericType.U32:
            return new bn_js_1.default(data.slice(offset, offset + 4), 'le');
        case TupleNumericType.U64:
            return new bn_js_1.default(data.slice(offset, offset + 8), 'le');
    }
};
exports.getBNFromData = getBNFromData;


/***/ }),

/***/ 68450:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78996);

const ThemeContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);

if (false) {}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ThemeContext);

/***/ }),

/***/ 56362:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (/* binding */ useTheme)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78996);
/* harmony import */ var _ThemeContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(68450);


function useTheme() {
  const theme = react__WEBPACK_IMPORTED_MODULE_0__.useContext(_ThemeContext__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z);

  if (false) {}

  return theme;
}

/***/ }),

/***/ 4664:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ZP: () => (/* binding */ styled),
  Co: () => (/* binding */ internal_processStyles)
});

// UNUSED EXPORTS: GlobalStyles, StyledEngineProvider, ThemeContext, css, keyframes

// EXTERNAL MODULE: ./node_modules/.pnpm/@babel+runtime@7.22.6/node_modules/@babel/runtime/helpers/esm/extends.js
var esm_extends = __webpack_require__(3386);
// EXTERNAL MODULE: ./node_modules/.pnpm/react@0.0.0-experimental-0a360642d-20230711/node_modules/react/index.js
var react = __webpack_require__(78996);
// EXTERNAL MODULE: ./node_modules/.pnpm/@emotion+memoize@0.8.1/node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
var emotion_memoize_esm = __webpack_require__(91852);
;// CONCATENATED MODULE: ./node_modules/.pnpm/@emotion+is-prop-valid@1.2.1/node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js


var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23

var isPropValid = /* #__PURE__ */(0,emotion_memoize_esm/* default */.Z)(function (prop) {
  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111
  /* o */
  && prop.charCodeAt(1) === 110
  /* n */
  && prop.charCodeAt(2) < 91;
}
/* Z+1 */
);



// EXTERNAL MODULE: ./node_modules/.pnpm/@emotion+react@11.11.1_@types+react@18.2.21_react@0.0.0-experimental-0a360642d-20230711/node_modules/@emotion/react/dist/emotion-element-c39617d8.browser.esm.js
var emotion_element_c39617d8_browser_esm = __webpack_require__(11020);
// EXTERNAL MODULE: ./node_modules/.pnpm/@emotion+utils@1.2.1/node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js
var emotion_utils_browser_esm = __webpack_require__(54742);
// EXTERNAL MODULE: ./node_modules/.pnpm/@emotion+serialize@1.1.2/node_modules/@emotion/serialize/dist/emotion-serialize.browser.esm.js
var emotion_serialize_browser_esm = __webpack_require__(84583);
// EXTERNAL MODULE: ./node_modules/.pnpm/@emotion+use-insertion-effect-with-fallbacks@1.0.1_react@0.0.0-experimental-0a360642d-20230711/node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.browser.esm.js
var emotion_use_insertion_effect_with_fallbacks_browser_esm = __webpack_require__(59336);
;// CONCATENATED MODULE: ./node_modules/.pnpm/@emotion+styled@11.11.0_@emotion+react@11.11.1_@types+react@18.2.21_react@0.0.0-experimental-0a360642d-20230711/node_modules/@emotion/styled/base/dist/emotion-styled-base.browser.esm.js








var testOmitPropsOnStringTag = isPropValid;

var testOmitPropsOnComponent = function testOmitPropsOnComponent(key) {
  return key !== 'theme';
};

var getDefaultShouldForwardProp = function getDefaultShouldForwardProp(tag) {
  return typeof tag === 'string' && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps(tag, options, isReal) {
  var shouldForwardProp;

  if (options) {
    var optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? function (propName) {
      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
    } : optionsShouldForwardProp;
  }

  if (typeof shouldForwardProp !== 'function' && isReal) {
    shouldForwardProp = tag.__emotion_forwardProp;
  }

  return shouldForwardProp;
};

var ILLEGAL_ESCAPE_SEQUENCE_ERROR = "You have illegal escape sequence in your template literal, most likely inside content's property value.\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \"content: '\\00d7';\" should become \"content: '\\\\00d7';\".\nYou can read more about this here:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences";

var Insertion = function Insertion(_ref) {
  var cache = _ref.cache,
      serialized = _ref.serialized,
      isStringTag = _ref.isStringTag;
  (0,emotion_utils_browser_esm/* registerStyles */.hC)(cache, serialized, isStringTag);
  (0,emotion_use_insertion_effect_with_fallbacks_browser_esm/* useInsertionEffectAlwaysWithSyncFallback */.L)(function () {
    return (0,emotion_utils_browser_esm/* insertStyles */.My)(cache, serialized, isStringTag);
  });

  return null;
};

var createStyled = function createStyled(tag, options) {
  if (false) {}

  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;

  if (options !== undefined) {
    identifierName = options.label;
    targetClassName = options.target;
  }

  var shouldForwardProp = composeShouldForwardProps(tag, options, isReal);
  var defaultShouldForwardProp = shouldForwardProp || getDefaultShouldForwardProp(baseTag);
  var shouldUseAs = !defaultShouldForwardProp('as');
  return function () {
    var args = arguments;
    var styles = isReal && tag.__emotion_styles !== undefined ? tag.__emotion_styles.slice(0) : [];

    if (identifierName !== undefined) {
      styles.push("label:" + identifierName + ";");
    }

    if (args[0] == null || args[0].raw === undefined) {
      styles.push.apply(styles, args);
    } else {
      if (false) {}

      styles.push(args[0][0]);
      var len = args.length;
      var i = 1;

      for (; i < len; i++) {
        if (false) {}

        styles.push(args[i], args[0][i]);
      }
    } // $FlowFixMe: we need to cast StatelessFunctionalComponent to our PrivateStyledComponent class


    var Styled = (0,emotion_element_c39617d8_browser_esm.w)(function (props, cache, ref) {
      var FinalTag = shouldUseAs && props.as || baseTag;
      var className = '';
      var classInterpolations = [];
      var mergedProps = props;

      if (props.theme == null) {
        mergedProps = {};

        for (var key in props) {
          mergedProps[key] = props[key];
        }

        mergedProps.theme = react.useContext(emotion_element_c39617d8_browser_esm.T);
      }

      if (typeof props.className === 'string') {
        className = (0,emotion_utils_browser_esm/* getRegisteredStyles */.fp)(cache.registered, classInterpolations, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }

      var serialized = (0,emotion_serialize_browser_esm/* serializeStyles */.O)(styles.concat(classInterpolations), cache.registered, mergedProps);
      className += cache.key + "-" + serialized.name;

      if (targetClassName !== undefined) {
        className += " " + targetClassName;
      }

      var finalShouldForwardProp = shouldUseAs && shouldForwardProp === undefined ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
      var newProps = {};

      for (var _key in props) {
        if (shouldUseAs && _key === 'as') continue;

        if ( // $FlowFixMe
        finalShouldForwardProp(_key)) {
          newProps[_key] = props[_key];
        }
      }

      newProps.className = className;
      newProps.ref = ref;
      return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Insertion, {
        cache: cache,
        serialized: serialized,
        isStringTag: typeof FinalTag === 'string'
      }), /*#__PURE__*/react.createElement(FinalTag, newProps));
    });
    Styled.displayName = identifierName !== undefined ? identifierName : "Styled(" + (typeof baseTag === 'string' ? baseTag : baseTag.displayName || baseTag.name || 'Component') + ")";
    Styled.defaultProps = tag.defaultProps;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_styles = styles;
    Styled.__emotion_forwardProp = shouldForwardProp;
    Object.defineProperty(Styled, 'toString', {
      value: function value() {
        if (targetClassName === undefined && "production" !== 'production') {} // $FlowFixMe: coerce undefined to string


        return "." + targetClassName;
      }
    });

    Styled.withComponent = function (nextTag, nextOptions) {
      return createStyled(nextTag, (0,esm_extends/* default */.Z)({}, options, nextOptions, {
        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
      })).apply(void 0, styles);
    };

    return Styled;
  };
};



;// CONCATENATED MODULE: ./node_modules/.pnpm/@emotion+styled@11.11.0_@emotion+react@11.11.1_@types+react@18.2.21_react@0.0.0-experimental-0a360642d-20230711/node_modules/@emotion/styled/dist/emotion-styled.browser.esm.js









var tags = ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr', // SVG
'circle', 'clipPath', 'defs', 'ellipse', 'foreignObject', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'text', 'tspan'];

var newStyled = createStyled.bind();
tags.forEach(function (tagName) {
  // $FlowFixMe: we can ignore this because its exposed type is defined by the CreateStyled type
  newStyled[tagName] = newStyled(tagName);
});



;// CONCATENATED MODULE: ./node_modules/.pnpm/@mui+styled-engine@5.10.8_@emotion+react@11.11.1_@emotion+styled@11.11.0_react@0.0.0-experimental-0a360642d-20230711/node_modules/@mui/styled-engine/index.js
/** @license MUI v5.10.8
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/* eslint-disable no-underscore-dangle */

function styled(tag, options) {
  const stylesFactory = newStyled(tag, options);

  if (false) {}

  return stylesFactory;
} // eslint-disable-next-line @typescript-eslint/naming-convention

const internal_processStyles = (tag, processor) => {
  // Emotion attaches all the styles as `__emotion_styles`.
  // Ref: https://github.com/emotion-js/emotion/blob/16d971d0da229596d6bcc39d282ba9753c9ee7cf/packages/styled/src/base.js#L186
  if (Array.isArray(tag.__emotion_styles)) {
    tag.__emotion_styles = processor(tag.__emotion_styles);
  }
};




/***/ }),

/***/ 77346:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cv: () => (/* binding */ encode),
/* harmony export */   lW: () => (/* reexport safe */ buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer)
/* harmony export */ });
/* unused harmony exports decode, getLength, toBuffer */
/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7661);



/**
 * Built on top of rlp library, removing the BN dependency for the flow.
 * Package : https://github.com/ethereumjs/rlp
 * RLP License : https://github.com/ethereumjs/rlp/blob/master/LICENSE
 *
 * ethereumjs/rlp is licensed under the
 * Mozilla Public License 2.0
 * Permissions of this weak copyleft license are conditioned on making available source code of licensed files and modifications of those files under the same license (or in certain cases, one of the GNU licenses). Copyright and license notices must be preserved. Contributors provide an express grant of patent rights. However, a larger work using the licensed work may be distributed under different terms and without source code for files added in the larger work.
 **/

/**
 * @param input - will be converted to buffer
 * @returns returns buffer of encoded data
 **/
function encode(input) {
  if (Array.isArray(input)) {
    var output = [];
    for (var i = 0; i < input.length; i++) {
      output.push(encode(input[i]));
    }
    var buf = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat(output);
    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([encodeLength(buf.length, 192), buf]);
  } else {
    var inputBuf = toBuffer(input);
    return inputBuf.length === 1 && inputBuf[0] < 128 ? inputBuf : buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([encodeLength(inputBuf.length, 128), inputBuf]);
  }
}

/**
 * Parse integers. Check if there is no leading zeros
 * @param v The value to parse
 * @param base The base to parse the integer into
 */
function safeParseInt(v, base) {
  if (v.slice(0, 2) === "00") {
    throw new Error("invalid RLP: extra zeros");
  }
  return parseInt(v, base);
}
function encodeLength(len, offset) {
  if (len < 56) {
    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([len + offset]);
  } else {
    var hexLength = intToHex(len);
    var lLength = hexLength.length / 2;
    var firstByte = intToHex(offset + 55 + lLength);
    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(firstByte + hexLength, "hex");
  }
}

/**
 * Built on top of rlp library, removing the BN dependency for the flow.
 * Package : https://github.com/ethereumjs/rlp
 * RLP License : https://github.com/ethereumjs/rlp/blob/master/LICENSE
 *
 * ethereumjs/rlp is licensed under the
 * Mozilla Public License 2.0
 * Permissions of this weak copyleft license are conditioned on making available source code of licensed files and modifications of those files under the same license (or in certain cases, one of the GNU licenses). Copyright and license notices must be preserved. Contributors provide an express grant of patent rights. However, a larger work using the licensed work may be distributed under different terms and without source code for files added in the larger work.
 **/

/**
 * @param input - will be converted to buffer
 * @param stream Is the input a stream (false by default)
 * @returns returns buffer of encoded data
 **/
function decode(input, stream) {
  if (stream === void 0) {
    stream = false;
  }
  if (!input || input.length === 0) {
    return Buffer.from([]);
  }
  var inputBuffer = toBuffer(input);
  var decoded = _decode(inputBuffer);
  if (stream) {
    return decoded;
  }
  if (decoded.remainder.length !== 0) {
    throw new Error("invalid remainder");
  }
  return decoded.data;
}

/**
 * Get the length of the RLP input
 * @param input
 * @returns The length of the input or an empty Buffer if no input
 */
function getLength(input) {
  if (!input || input.length === 0) {
    return Buffer.from([]);
  }
  var inputBuffer = toBuffer(input);
  var firstByte = inputBuffer[0];
  if (firstByte <= 0x7f) {
    return inputBuffer.length;
  } else if (firstByte <= 0xb7) {
    return firstByte - 0x7f;
  } else if (firstByte <= 0xbf) {
    return firstByte - 0xb6;
  } else if (firstByte <= 0xf7) {
    // a list between  0-55 bytes long
    return firstByte - 0xbf;
  } else {
    // a list  over 55 bytes long
    var llength = firstByte - 0xf6;
    var length = safeParseInt(inputBuffer.slice(1, llength).toString("hex"), 16);
    return llength + length;
  }
}

/** Decode an input with RLP */
function _decode(input) {
  var length, llength, data, innerRemainder, d;
  var decoded = [];
  var firstByte = input[0];
  if (firstByte <= 0x7f) {
    // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.
    return {
      data: input.slice(0, 1),
      remainder: input.slice(1)
    };
  } else if (firstByte <= 0xb7) {
    // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string
    // The range of the first byte is [0x80, 0xb7]
    length = firstByte - 0x7f;
    // set 0x80 null to 0
    if (firstByte === 0x80) {
      data = Buffer.from([]);
    } else {
      data = input.slice(1, length);
    }
    if (length === 2 && data[0] < 0x80) {
      throw new Error("invalid rlp encoding: byte must be less 0x80");
    }
    return {
      data: data,
      remainder: input.slice(length)
    };
  } else if (firstByte <= 0xbf) {
    llength = firstByte - 0xb6;
    length = safeParseInt(input.slice(1, llength).toString("hex"), 16);
    data = input.slice(llength, length + llength);
    if (data.length < length) {
      throw new Error("invalid RLP");
    }
    return {
      data: data,
      remainder: input.slice(length + llength)
    };
  } else if (firstByte <= 0xf7) {
    // a list between  0-55 bytes long
    length = firstByte - 0xbf;
    innerRemainder = input.slice(1, length);
    while (innerRemainder.length) {
      d = _decode(innerRemainder);
      decoded.push(d.data);
      innerRemainder = d.remainder;
    }
    return {
      data: decoded,
      remainder: input.slice(length)
    };
  } else {
    // a list  over 55 bytes long
    llength = firstByte - 0xf6;
    length = safeParseInt(input.slice(1, llength).toString("hex"), 16);
    var totalLength = llength + length;
    if (totalLength > input.length) {
      throw new Error("invalid rlp: total length is larger than the data");
    }
    innerRemainder = input.slice(llength, totalLength);
    if (innerRemainder.length === 0) {
      throw new Error("invalid rlp, List has a invalid length");
    }
    while (innerRemainder.length) {
      d = _decode(innerRemainder);
      decoded.push(d.data);
      innerRemainder = d.remainder;
    }
    return {
      data: decoded,
      remainder: input.slice(totalLength)
    };
  }
}
/** Check if a string is prefixed by 0x */
function isHexPrefixed(str) {
  return str.slice(0, 2) === "0x";
}
/** Removes 0x from a given String */
function stripHexPrefix(str) {
  if (typeof str !== "string") {
    return str;
  }
  return isHexPrefixed(str) ? str.slice(2) : str;
}
/** Transform an integer into its hexadecimal value */
function intToHex(integer) {
  if (integer < 0) {
    throw new Error("Invalid integer as argument, must be unsigned!");
  }
  var hex = integer.toString(16);
  return hex.length % 2 ? "0" + hex : hex;
}
/** Pad a string to be even */
function padToEven(a) {
  return a.length % 2 ? "0" + a : a;
}
/** Transform an integer into a Buffer */
function intToBuffer(integer) {
  var hex = intToHex(integer);
  return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(hex, "hex");
}

/** Transform anything into a Buffer */
function toBuffer(v) {
  if (!buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.isBuffer(v)) {
    if (typeof v === "string") {
      if (isHexPrefixed(v)) {
        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(padToEven(stripHexPrefix(v)), "hex");
      } else {
        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(v);
      }
    } else if (typeof v === "number") {
      if (!v) {
        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([]);
      } else {
        return intToBuffer(v);
      }
    } else if (v === null || v === undefined) {
      return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([]);
    } else if (v instanceof Uint8Array) {
      return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(v);
    } else {
      throw new Error("invalid type");
    }
  }
  return v;
}




/***/ }),

/***/ 48083:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   By: () => (/* binding */ UNSUBSCRIBE),
/* harmony export */   Cs: () => (/* binding */ spawn),
/* harmony export */   L6: () => (/* binding */ snapshoter),
/* harmony export */   SH: () => (/* binding */ UPDATED),
/* harmony export */   kD: () => (/* binding */ SUBSCRIBE),
/* harmony export */   kT: () => (/* binding */ SNAPSHOT),
/* harmony export */   lW: () => (/* binding */ send),
/* harmony export */   qP: () => (/* binding */ subscriber),
/* harmony export */   qg: () => (/* binding */ INIT)
/* harmony export */ });
/* unused harmony exports EXIT, TERMINATE, kill */
/* harmony import */ var queue_microtask__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(79660);
/* harmony import */ var queue_microtask__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(queue_microtask__WEBPACK_IMPORTED_MODULE_0__);


const mailbox = () => {
  const queue = [];
  var next;
  return {
    async deliver(msg) {
      queue.push(msg);
      if (next) {
        next(queue.shift());
        next = undefined;
      }
    },
    receive() {
      return new Promise(function innerReceive(resolve) {
        const msg = queue.shift();
        if (msg) return resolve(msg);
        next = resolve;
      });
    }
  };
};

const INIT = "INIT";
const SUBSCRIBE = "SUBSCRIBE";
const UNSUBSCRIBE = "UNSUBSCRIBE";
const UPDATED = "UPDATED";
const SNAPSHOT = "SNAPSHOT";
const EXIT = "EXIT";
const TERMINATE = "TERMINATE";
const root = typeof self === "object" && self.self === self && self || typeof __webpack_require__.g === "object" && __webpack_require__.g.global === __webpack_require__.g && __webpack_require__.g || typeof window === "object" && window.window === window && window;
root.FCL_REGISTRY = root.FCL_REGISTRY == null ? {} : root.FCL_REGISTRY;
var pid = 0b0;
const DEFAULT_TIMEOUT = 5000;
const send = function (addr, tag, data) {
  let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return new Promise((reply, reject) => {
    const expectReply = opts.expectReply || false;
    const timeout = opts.timeout != null ? opts.timeout : DEFAULT_TIMEOUT;
    if (expectReply && timeout) {
      setTimeout(() => reject(new Error(`Timeout: ${timeout}ms passed without a response.`)), timeout);
    }
    const payload = {
      to: addr,
      from: opts.from,
      tag,
      data,
      timeout,
      reply,
      reject
    };
    try {
      root.FCL_REGISTRY[addr] && root.FCL_REGISTRY[addr].mailbox.deliver(payload);
      if (!expectReply) reply(true);
    } catch (error) {
      console.error("FCL.Actor -- Could Not Deliver Message", payload, root.FCL_REGISTRY[addr], error);
    }
  });
};
const kill = addr => {
  delete root.FCL_REGISTRY[addr];
};
const fromHandlers = function () {
  let handlers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return async ctx => {
    if (typeof handlers[INIT] === "function") await handlers[INIT](ctx);
    __loop: while (1) {
      const letter = await ctx.receive();
      try {
        if (letter.tag === EXIT) {
          if (typeof handlers[TERMINATE] === "function") {
            await handlers[TERMINATE](ctx, letter, letter.data || {});
          }
          break __loop;
        }
        await handlers[letter.tag](ctx, letter, letter.data || {});
      } catch (error) {
        console.error(`${ctx.self()} Error`, letter, error);
      } finally {
        continue __loop;
      }
    }
  };
};
const spawn = function (fn) {
  let addr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  if (addr == null) addr = ++pid;
  if (root.FCL_REGISTRY[addr] != null) return addr;
  root.FCL_REGISTRY[addr] = {
    addr,
    mailbox: mailbox(),
    subs: new Set(),
    kvs: {},
    error: null
  };
  const ctx = {
    self: () => addr,
    receive: () => root.FCL_REGISTRY[addr].mailbox.receive(),
    send: function (to, tag, data) {
      let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      opts.from = addr;
      return send(to, tag, data, opts);
    },
    sendSelf: (tag, data, opts) => {
      if (root.FCL_REGISTRY[addr]) send(addr, tag, data, opts);
    },
    broadcast: function (tag, data) {
      let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      opts.from = addr;
      for (let to of root.FCL_REGISTRY[addr].subs) send(to, tag, data, opts);
    },
    subscribe: sub => sub != null && root.FCL_REGISTRY[addr].subs.add(sub),
    unsubscribe: sub => sub != null && root.FCL_REGISTRY[addr].subs.delete(sub),
    subscriberCount: () => root.FCL_REGISTRY[addr].subs.size,
    hasSubs: () => !!root.FCL_REGISTRY[addr].subs.size,
    put: (key, value) => {
      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = value;
    },
    get: (key, fallback) => {
      const value = root.FCL_REGISTRY[addr].kvs[key];
      return value == null ? fallback : value;
    },
    delete: key => {
      delete root.FCL_REGISTRY[addr].kvs[key];
    },
    update: (key, fn) => {
      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = fn(root.FCL_REGISTRY[addr].kvs[key]);
    },
    keys: () => {
      return Object.keys(root.FCL_REGISTRY[addr].kvs);
    },
    all: () => {
      return root.FCL_REGISTRY[addr].kvs;
    },
    where: pattern => {
      return Object.keys(root.FCL_REGISTRY[addr].kvs).reduce((acc, key) => {
        return pattern.test(key) ? {
          ...acc,
          [key]: root.FCL_REGISTRY[addr].kvs[key]
        } : acc;
      }, {});
    },
    merge: function () {
      let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      Object.keys(data).forEach(key => root.FCL_REGISTRY[addr].kvs[key] = data[key]);
    },
    fatalError: error => {
      root.FCL_REGISTRY[addr].error = error;
      for (let to of root.FCL_REGISTRY[addr].subs) send(to, UPDATED);
    }
  };
  if (typeof fn === "object") fn = fromHandlers(fn);
  queue_microtask__WEBPACK_IMPORTED_MODULE_0___default()(async () => {
    await fn(ctx);
    kill(addr);
  });
  return addr;
};

// Returns an unsubscribe function
// A SUBSCRIBE handler will need to be created to handle the subscription event
//
//  [SUBSCRIBE]: (ctx, letter) => {
//    ctx.subscribe(letter.from)
//    ctx.send(letter.from, UPDATED, ctx.all())
//  }
//
function subscriber(address, spawnFn, callback) {
  spawnFn(address);
  const EXIT = "@EXIT";
  const self = spawn(async ctx => {
    ctx.send(address, SUBSCRIBE);
    while (1) {
      const letter = await ctx.receive();
      const error = root.FCL_REGISTRY[address].error;
      if (letter.tag === EXIT) {
        ctx.send(address, UNSUBSCRIBE);
        return;
      }
      if (error) {
        callback(null, error);
        ctx.send(address, UNSUBSCRIBE);
        return;
      }
      callback(letter.data, null);
    }
  });
  return () => send(self, EXIT);
}

// Returns a promise that returns a result
// A SNAPSHOT handler will need to be created to handle the snapshot event
//
//  [SNAPSHOT]: (ctx, letter) => {
//    letter.reply(ctx.all())
//  }
//
function snapshoter(address, spawnFn) {
  spawnFn(address);
  return send(address, SNAPSHOT, null, {
    expectReply: true,
    timeout: 0
  });
}




/***/ }),

/***/ 28114:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CH: () => (/* binding */ sansPrefix),
/* harmony export */   dq: () => (/* binding */ withPrefix),
/* harmony export */   jf: () => (/* binding */ display)
/* harmony export */ });
/**
 * @description Removes 0x from address if present
 * @param {string} address - Flow address
 * @returns {string} - Flow address without 0x prefix
 */
function sansPrefix(address) {
  if (address == null) return null;
  return address.replace(/^0x/, "").replace(/^Fx/, "");
}

/**
 * @description Adds 0x to address if not already present
 * @param {string} address - Flow address
 * @returns {string} - Flow address with 0x prefix
 */
function withPrefix(address) {
  if (address == null) return null;
  return "0x" + sansPrefix(address);
}

/**
 * @description Adds 0x to address if not already present
 * @param {string} address - Flow address
 * @returns {string} - Flow address with 0x prefix
 */
function display(address) {
  return withPrefix(address);
}




/***/ }),

/***/ 93644:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   k: () => (/* binding */ invariant)
/* harmony export */ });
/**
 * Asserts fact is true, otherwise throw an error with invariant message
 * @param {boolean} fact
 * @param {string} msg
 * @param {Array} rest
 * @returns {void}
 */
function invariant(fact, msg) {
  if (!fact) {
    const error = new Error(`INVARIANT ${msg}`);
    error.stack = error.stack.split("\n").filter(d => !/at invariant/.test(d)).join("\n");
    for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      rest[_key - 2] = arguments[_key];
    }
    console.error("\n\n---\n\n", error, "\n\n", ...rest, "\n\n---\n\n");
    throw error;
  }
}




/***/ }),

/***/ 21874:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ log),
/* harmony export */   z: () => (/* binding */ LEVELS)
/* harmony export */ });
/* harmony import */ var _onflow_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(92316);


/**
 * The levels of the logger
 * 
 * @typedef {Object} LEVELS
 * @property {number} debug - The debug level
 * @property {number} info - The info level
 * @property {number} log - The log level
 * @property {number} warn - The warn level
 * @property {number} error - The error level
 * 
 */
const LEVELS = Object.freeze({
  debug: 5,
  info: 4,
  log: 3,
  warn: 2,
  error: 1
});

/**
 * Builds a message formatted for the logger
 * 
 * @param {Object} options - The options for the log
 * @param {string} options.title - The title of the log
 * @param {string} options.message - The message of the log
 * @returns {Array<string>} - The message formatted for the logger
 * 
 * @example
 * buildLoggerMessageArgs({ title: "My Title", message: "My Message" })
 */
const buildLoggerMessageArgs = _ref => {
  let {
    title,
    message
  } = _ref;
  return [`
    %c${title}
    ============================

    ${message}

    ============================
    `.replace(/\n[^\S\r\n]+/g, "\n").trim(),, "font-weight:bold;font-family:monospace;"];
};

/**
 * Logs messages based on the level of the message and the level set in the config
 * 
 * @param {Object} options - The options for the log
 * @param {string} options.title - The title of the log
 * @param {string} options.message - The message of the log
 * @param {number} options.level - The level of the log
 * @param {boolean} options.always - Whether to always show the log
 * @returns {Promise<void>}
 * 
 * @example
 * log({ title: "My Title", message: "My Message", level: LEVELS.warn, always: false })
 * 
 */
const log = async _ref2 => {
  let {
    title,
    message,
    level,
    always = false
  } = _ref2;
  const configLoggerLevel = await _onflow_config__WEBPACK_IMPORTED_MODULE_0__/* .config */ .v.get("logger.level", LEVELS.warn);

  // If config level is below message level then don't show it
  if (!always && configLoggerLevel < level) return;
  const loggerMessageArgs = buildLoggerMessageArgs({
    title,
    message
  });
  switch (level) {
    case LEVELS.debug:
      console.debug(...loggerMessageArgs);
      break;
    case LEVELS.info:
      console.info(...loggerMessageArgs);
      break;
    case LEVELS.warn:
      console.warn(...loggerMessageArgs);
      break;
    case LEVELS.error:
      console.error(...loggerMessageArgs);
      break;
    default:
      console.log(...loggerMessageArgs);
  }
};

/**
 * Logs a deprecation notice
 * 
 * @param {Object} options - The options for the log
 * @param {string} options.pkg - The package that is being deprecated
 * @param {string} options.subject - The subject of the deprecation
 * @param {string} options.transition - The transition path for the deprecation
 * @param {number} options.level - The level of the log
 * @param {string} options.message - The message of the log
 * @param {Function} options.callback - A callback to run after the log
 * @returns {Promise<void>}
 * 
 * @example
 * log.deprecate({ pkg: "@onflow/fcl", subject: "Some item", transition: "https://github.com/onflow/flow-js-sdk", message: "Descriptive message", level: LEVELS.warn, callback: () => {} })
 * 
 */
log.deprecate = _ref3 => {
  let {
    pkg,
    subject,
    transition,
    level = LEVELS.warn,
    message = "",
    callback = null
  } = _ref3;
  const capitalizeFirstLetter = string => {
    return string.charAt(0).toUpperCase() + string.slice(1);
  };
  const logMessage = () => log({
    title: `${pkg ? pkg + " " : ""}Deprecation Notice`,
    message: `
      ${subject ? `${capitalizeFirstLetter(subject)} is deprecated and will cease to work in future releases${pkg ? " of " + pkg : ""}.` : ""}${message ? "\n" + message : ""}${transition ? `\nYou can learn more (including a guide on common transition paths) here: ${transition}` : ""}
    `.trim(),
    level
  });
  if (typeof callback === "function") {
    return async function () {
      await logMessage();
      return await callback(...arguments);
    };
  }
  return logMessage();
};




/***/ }),

/***/ 17957:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   h: () => (/* binding */ uid)
/* harmony export */ });
/**
 * Generates a unique identifier
 * @returns {string}
 */
var HEX = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
var T = HEX.length;
function uid() {
  var str = "",
    num = 32;
  while (num--) str += HEX[Math.random() * T | 0];
  return str;
}




/***/ }),

/***/ 93441:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
exports.IH = exports.Q5 = exports.Ko = void 0;
/**
 * All events are emitted using this key.
 */
exports.Ko = Symbol("ALL_EVENTS");
/**
 * Create an `off` function given an input.
 */
function add(stack, value) {
    stack.add(value);
    return function off() {
        return stack.delete(value);
    };
}
/**
 * Emit an event.
 */
function emit(stack, ...args) {
    if (stack)
        for (const { fn } of stack)
            fn(...args);
}
/**
 * Type-safe event emitter.
 */
class Emitter {
    constructor() {
        this.$ = Object.create(null);
    }
    on(type, fn) {
        const stack = (this.$[type] = this.$[type] || new Set());
        return add(stack, { fn });
    }
    emit(type, ...args) {
        emit(this.$[type], ...args);
        emit(this.$[exports.Ko], { type, args });
    }
}
exports.Q5 = Emitter;
/**
 * Helper to listen to an event once only.
 */
function once(events, type, callback) {
    const off = events.on(type, function once(...args) {
        off();
        return callback(...args);
    });
    return off;
}
exports.IH = once;


/***/ }),

/***/ 10546:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Package binary provides functions for encoding and decoding numbers in byte arrays.
 */
var int_1 = __webpack_require__(15251);
// TODO(dchest): add asserts for correct value ranges and array offsets.
/**
 * Reads 2 bytes from array starting at offset as big-endian
 * signed 16-bit integer and returns it.
 */
function readInt16BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return (((array[offset + 0] << 8) | array[offset + 1]) << 16) >> 16;
}
exports.readInt16BE = readInt16BE;
/**
 * Reads 2 bytes from array starting at offset as big-endian
 * unsigned 16-bit integer and returns it.
 */
function readUint16BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return ((array[offset + 0] << 8) | array[offset + 1]) >>> 0;
}
exports.readUint16BE = readUint16BE;
/**
 * Reads 2 bytes from array starting at offset as little-endian
 * signed 16-bit integer and returns it.
 */
function readInt16LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return (((array[offset + 1] << 8) | array[offset]) << 16) >> 16;
}
exports.readInt16LE = readInt16LE;
/**
 * Reads 2 bytes from array starting at offset as little-endian
 * unsigned 16-bit integer and returns it.
 */
function readUint16LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return ((array[offset + 1] << 8) | array[offset]) >>> 0;
}
exports.readUint16LE = readUint16LE;
/**
 * Writes 2-byte big-endian representation of 16-bit unsigned
 * value to byte array starting at offset.
 *
 * If byte array is not given, creates a new 2-byte one.
 *
 * Returns the output byte array.
 */
function writeUint16BE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(2); }
    if (offset === void 0) { offset = 0; }
    out[offset + 0] = value >>> 8;
    out[offset + 1] = value >>> 0;
    return out;
}
exports.writeUint16BE = writeUint16BE;
exports.writeInt16BE = writeUint16BE;
/**
 * Writes 2-byte little-endian representation of 16-bit unsigned
 * value to array starting at offset.
 *
 * If byte array is not given, creates a new 2-byte one.
 *
 * Returns the output byte array.
 */
function writeUint16LE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(2); }
    if (offset === void 0) { offset = 0; }
    out[offset + 0] = value >>> 0;
    out[offset + 1] = value >>> 8;
    return out;
}
exports.writeUint16LE = writeUint16LE;
exports.writeInt16LE = writeUint16LE;
/**
 * Reads 4 bytes from array starting at offset as big-endian
 * signed 32-bit integer and returns it.
 */
function readInt32BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return (array[offset] << 24) |
        (array[offset + 1] << 16) |
        (array[offset + 2] << 8) |
        array[offset + 3];
}
exports.readInt32BE = readInt32BE;
/**
 * Reads 4 bytes from array starting at offset as big-endian
 * unsigned 32-bit integer and returns it.
 */
function readUint32BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return ((array[offset] << 24) |
        (array[offset + 1] << 16) |
        (array[offset + 2] << 8) |
        array[offset + 3]) >>> 0;
}
exports.readUint32BE = readUint32BE;
/**
 * Reads 4 bytes from array starting at offset as little-endian
 * signed 32-bit integer and returns it.
 */
function readInt32LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return (array[offset + 3] << 24) |
        (array[offset + 2] << 16) |
        (array[offset + 1] << 8) |
        array[offset];
}
exports.readInt32LE = readInt32LE;
/**
 * Reads 4 bytes from array starting at offset as little-endian
 * unsigned 32-bit integer and returns it.
 */
function readUint32LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    return ((array[offset + 3] << 24) |
        (array[offset + 2] << 16) |
        (array[offset + 1] << 8) |
        array[offset]) >>> 0;
}
exports.readUint32LE = readUint32LE;
/**
 * Writes 4-byte big-endian representation of 32-bit unsigned
 * value to byte array starting at offset.
 *
 * If byte array is not given, creates a new 4-byte one.
 *
 * Returns the output byte array.
 */
function writeUint32BE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(4); }
    if (offset === void 0) { offset = 0; }
    out[offset + 0] = value >>> 24;
    out[offset + 1] = value >>> 16;
    out[offset + 2] = value >>> 8;
    out[offset + 3] = value >>> 0;
    return out;
}
exports.writeUint32BE = writeUint32BE;
exports.writeInt32BE = writeUint32BE;
/**
 * Writes 4-byte little-endian representation of 32-bit unsigned
 * value to array starting at offset.
 *
 * If byte array is not given, creates a new 4-byte one.
 *
 * Returns the output byte array.
 */
function writeUint32LE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(4); }
    if (offset === void 0) { offset = 0; }
    out[offset + 0] = value >>> 0;
    out[offset + 1] = value >>> 8;
    out[offset + 2] = value >>> 16;
    out[offset + 3] = value >>> 24;
    return out;
}
exports.writeUint32LE = writeUint32LE;
exports.writeInt32LE = writeUint32LE;
/**
 * Reads 8 bytes from array starting at offset as big-endian
 * signed 64-bit integer and returns it.
 *
 * IMPORTANT: due to JavaScript limitation, supports exact
 * numbers in range -9007199254740991 to 9007199254740991.
 * If the number stored in the byte array is outside this range,
 * the result is not exact.
 */
function readInt64BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var hi = readInt32BE(array, offset);
    var lo = readInt32BE(array, offset + 4);
    return hi * 0x100000000 + lo - ((lo >> 31) * 0x100000000);
}
exports.readInt64BE = readInt64BE;
/**
 * Reads 8 bytes from array starting at offset as big-endian
 * unsigned 64-bit integer and returns it.
 *
 * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.
 */
function readUint64BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var hi = readUint32BE(array, offset);
    var lo = readUint32BE(array, offset + 4);
    return hi * 0x100000000 + lo;
}
exports.readUint64BE = readUint64BE;
/**
 * Reads 8 bytes from array starting at offset as little-endian
 * signed 64-bit integer and returns it.
 *
 * IMPORTANT: due to JavaScript limitation, supports exact
 * numbers in range -9007199254740991 to 9007199254740991.
 * If the number stored in the byte array is outside this range,
 * the result is not exact.
 */
function readInt64LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var lo = readInt32LE(array, offset);
    var hi = readInt32LE(array, offset + 4);
    return hi * 0x100000000 + lo - ((lo >> 31) * 0x100000000);
}
exports.readInt64LE = readInt64LE;
/**
 * Reads 8 bytes from array starting at offset as little-endian
 * unsigned 64-bit integer and returns it.
 *
 * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.
 */
function readUint64LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var lo = readUint32LE(array, offset);
    var hi = readUint32LE(array, offset + 4);
    return hi * 0x100000000 + lo;
}
exports.readUint64LE = readUint64LE;
/**
 * Writes 8-byte big-endian representation of 64-bit unsigned
 * value to byte array starting at offset.
 *
 * Due to JavaScript limitation, supports values up to 2^53-1.
 *
 * If byte array is not given, creates a new 8-byte one.
 *
 * Returns the output byte array.
 */
function writeUint64BE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(8); }
    if (offset === void 0) { offset = 0; }
    writeUint32BE(value / 0x100000000 >>> 0, out, offset);
    writeUint32BE(value >>> 0, out, offset + 4);
    return out;
}
exports.writeUint64BE = writeUint64BE;
exports.writeInt64BE = writeUint64BE;
/**
 * Writes 8-byte little-endian representation of 64-bit unsigned
 * value to byte array starting at offset.
 *
 * Due to JavaScript limitation, supports values up to 2^53-1.
 *
 * If byte array is not given, creates a new 8-byte one.
 *
 * Returns the output byte array.
 */
function writeUint64LE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(8); }
    if (offset === void 0) { offset = 0; }
    writeUint32LE(value >>> 0, out, offset);
    writeUint32LE(value / 0x100000000 >>> 0, out, offset + 4);
    return out;
}
exports.writeUint64LE = writeUint64LE;
exports.writeInt64LE = writeUint64LE;
/**
 * Reads bytes from array starting at offset as big-endian
 * unsigned bitLen-bit integer and returns it.
 *
 * Supports bit lengths divisible by 8, up to 48.
 */
function readUintBE(bitLength, array, offset) {
    if (offset === void 0) { offset = 0; }
    // TODO(dchest): implement support for bitLengths non-divisible by 8
    if (bitLength % 8 !== 0) {
        throw new Error("readUintBE supports only bitLengths divisible by 8");
    }
    if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintBE: array is too short for the given bitLength");
    }
    var result = 0;
    var mul = 1;
    for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
        result += array[i] * mul;
        mul *= 256;
    }
    return result;
}
exports.readUintBE = readUintBE;
/**
 * Reads bytes from array starting at offset as little-endian
 * unsigned bitLen-bit integer and returns it.
 *
 * Supports bit lengths divisible by 8, up to 48.
 */
function readUintLE(bitLength, array, offset) {
    if (offset === void 0) { offset = 0; }
    // TODO(dchest): implement support for bitLengths non-divisible by 8
    if (bitLength % 8 !== 0) {
        throw new Error("readUintLE supports only bitLengths divisible by 8");
    }
    if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintLE: array is too short for the given bitLength");
    }
    var result = 0;
    var mul = 1;
    for (var i = offset; i < offset + bitLength / 8; i++) {
        result += array[i] * mul;
        mul *= 256;
    }
    return result;
}
exports.readUintLE = readUintLE;
/**
 * Writes a big-endian representation of bitLen-bit unsigned
 * value to array starting at offset.
 *
 * Supports bit lengths divisible by 8, up to 48.
 *
 * If byte array is not given, creates a new one.
 *
 * Returns the output byte array.
 */
function writeUintBE(bitLength, value, out, offset) {
    if (out === void 0) { out = new Uint8Array(bitLength / 8); }
    if (offset === void 0) { offset = 0; }
    // TODO(dchest): implement support for bitLengths non-divisible by 8
    if (bitLength % 8 !== 0) {
        throw new Error("writeUintBE supports only bitLengths divisible by 8");
    }
    if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintBE value must be an integer");
    }
    var div = 1;
    for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
        out[i] = (value / div) & 0xff;
        div *= 256;
    }
    return out;
}
exports.writeUintBE = writeUintBE;
/**
 * Writes a little-endian representation of bitLen-bit unsigned
 * value to array starting at offset.
 *
 * Supports bit lengths divisible by 8, up to 48.
 *
 * If byte array is not given, creates a new one.
 *
 * Returns the output byte array.
 */
function writeUintLE(bitLength, value, out, offset) {
    if (out === void 0) { out = new Uint8Array(bitLength / 8); }
    if (offset === void 0) { offset = 0; }
    // TODO(dchest): implement support for bitLengths non-divisible by 8
    if (bitLength % 8 !== 0) {
        throw new Error("writeUintLE supports only bitLengths divisible by 8");
    }
    if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintLE value must be an integer");
    }
    var div = 1;
    for (var i = offset; i < offset + bitLength / 8; i++) {
        out[i] = (value / div) & 0xff;
        div *= 256;
    }
    return out;
}
exports.writeUintLE = writeUintLE;
/**
 * Reads 4 bytes from array starting at offset as big-endian
 * 32-bit floating-point number and returns it.
 */
function readFloat32BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    return view.getFloat32(offset);
}
exports.readFloat32BE = readFloat32BE;
/**
 * Reads 4 bytes from array starting at offset as little-endian
 * 32-bit floating-point number and returns it.
 */
function readFloat32LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    return view.getFloat32(offset, true);
}
exports.readFloat32LE = readFloat32LE;
/**
 * Reads 8 bytes from array starting at offset as big-endian
 * 64-bit floating-point number ("double") and returns it.
 */
function readFloat64BE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    return view.getFloat64(offset);
}
exports.readFloat64BE = readFloat64BE;
/**
 * Reads 8 bytes from array starting at offset as little-endian
 * 64-bit floating-point number ("double") and returns it.
 */
function readFloat64LE(array, offset) {
    if (offset === void 0) { offset = 0; }
    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    return view.getFloat64(offset, true);
}
exports.readFloat64LE = readFloat64LE;
/**
 * Writes 4-byte big-endian floating-point representation of value
 * to byte array starting at offset.
 *
 * If byte array is not given, creates a new 4-byte one.
 *
 * Returns the output byte array.
 */
function writeFloat32BE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(4); }
    if (offset === void 0) { offset = 0; }
    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    view.setFloat32(offset, value);
    return out;
}
exports.writeFloat32BE = writeFloat32BE;
/**
 * Writes 4-byte little-endian floating-point representation of value
 * to byte array starting at offset.
 *
 * If byte array is not given, creates a new 4-byte one.
 *
 * Returns the output byte array.
 */
function writeFloat32LE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(4); }
    if (offset === void 0) { offset = 0; }
    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    view.setFloat32(offset, value, true);
    return out;
}
exports.writeFloat32LE = writeFloat32LE;
/**
 * Writes 8-byte big-endian floating-point representation of value
 * to byte array starting at offset.
 *
 * If byte array is not given, creates a new 8-byte one.
 *
 * Returns the output byte array.
 */
function writeFloat64BE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(8); }
    if (offset === void 0) { offset = 0; }
    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    view.setFloat64(offset, value);
    return out;
}
exports.writeFloat64BE = writeFloat64BE;
/**
 * Writes 8-byte little-endian floating-point representation of value
 * to byte array starting at offset.
 *
 * If byte array is not given, creates a new 8-byte one.
 *
 * Returns the output byte array.
 */
function writeFloat64LE(value, out, offset) {
    if (out === void 0) { out = new Uint8Array(8); }
    if (offset === void 0) { offset = 0; }
    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    view.setFloat64(offset, value, true);
    return out;
}
exports.writeFloat64LE = writeFloat64LE;


/***/ }),

/***/ 53516:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
__webpack_unused_export__ = ({ value: true });
var chacha_1 = __webpack_require__(12401);
var poly1305_1 = __webpack_require__(15167);
var wipe_1 = __webpack_require__(22059);
var binary_1 = __webpack_require__(10546);
var constant_time_1 = __webpack_require__(97065);
exports.Cv = 32;
exports.WH = 12;
exports.pg = 16;
var ZEROS = new Uint8Array(16);
/**
 * ChaCha20-Poly1305 Authenticated Encryption with Associated Data.
 *
 * Defined in RFC7539.
 */
var ChaCha20Poly1305 = /** @class */ (function () {
    /**
     * Creates a new instance with the given 32-byte key.
     */
    function ChaCha20Poly1305(key) {
        this.nonceLength = exports.WH;
        this.tagLength = exports.pg;
        if (key.length !== exports.Cv) {
            throw new Error("ChaCha20Poly1305 needs 32-byte key");
        }
        // Copy key.
        this._key = new Uint8Array(key);
    }
    /**
     * Encrypts and authenticates plaintext, authenticates associated data,
     * and returns sealed ciphertext, which includes authentication tag.
     *
     * RFC7539 specifies 12 bytes for nonce. It may be this 12-byte nonce
     * ("IV"), or full 16-byte counter (called "32-bit fixed-common part")
     * and nonce.
     *
     * If dst is given (it must be the size of plaintext + the size of tag
     * length) the result will be put into it. Dst and plaintext must not
     * overlap.
     */
    ChaCha20Poly1305.prototype.seal = function (nonce, plaintext, associatedData, dst) {
        if (nonce.length > 16) {
            throw new Error("ChaCha20Poly1305: incorrect nonce length");
        }
        // Allocate space for counter, and set nonce as last bytes of it.
        var counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length);
        // Generate authentication key by taking first 32-bytes of stream.
        // We pass full counter, which has 12-byte nonce and 4-byte block counter,
        // and it will get incremented after generating the block, which is
        // exactly what we need: we only use the first 32 bytes of 64-byte
        // ChaCha block and discard the next 32 bytes.
        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter, authKey, 4);
        // Allocate space for sealed ciphertext.
        var resultLength = plaintext.length + this.tagLength;
        var result;
        if (dst) {
            if (dst.length !== resultLength) {
                throw new Error("ChaCha20Poly1305: incorrect destination length");
            }
            result = dst;
        }
        else {
            result = new Uint8Array(resultLength);
        }
        // Encrypt plaintext.
        chacha_1.streamXOR(this._key, counter, plaintext, result, 4);
        // Authenticate.
        // XXX: can "simplify" here: pass full result (which is already padded
        // due to zeroes prepared for tag), and ciphertext length instead of
        // subarray of result.
        this._authenticate(result.subarray(result.length - this.tagLength, result.length), authKey, result.subarray(0, result.length - this.tagLength), associatedData);
        // Cleanup.
        wipe_1.wipe(counter);
        return result;
    };
    /**
     * Authenticates sealed ciphertext (which includes authentication tag) and
     * associated data, decrypts ciphertext and returns decrypted plaintext.
     *
     * RFC7539 specifies 12 bytes for nonce. It may be this 12-byte nonce
     * ("IV"), or full 16-byte counter (called "32-bit fixed-common part")
     * and nonce.
     *
     * If authentication fails, it returns null.
     *
     * If dst is given (it must be of ciphertext length minus tag length),
     * the result will be put into it. Dst and plaintext must not overlap.
     */
    ChaCha20Poly1305.prototype.open = function (nonce, sealed, associatedData, dst) {
        if (nonce.length > 16) {
            throw new Error("ChaCha20Poly1305: incorrect nonce length");
        }
        // Sealed ciphertext should at least contain tag.
        if (sealed.length < this.tagLength) {
            // TODO(dchest): should we throw here instead?
            return null;
        }
        // Allocate space for counter, and set nonce as last bytes of it.
        var counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length);
        // Generate authentication key by taking first 32-bytes of stream.
        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter, authKey, 4);
        // Authenticate.
        // XXX: can simplify and avoid allocation: since authenticate()
        // already allocates tag (from Poly1305.digest(), it can return)
        // it instead of copying to calculatedTag. But then in seal()
        // we'll need to copy it.
        var calculatedTag = new Uint8Array(this.tagLength);
        this._authenticate(calculatedTag, authKey, sealed.subarray(0, sealed.length - this.tagLength), associatedData);
        // Constant-time compare tags and return null if they differ.
        if (!constant_time_1.equal(calculatedTag, sealed.subarray(sealed.length - this.tagLength, sealed.length))) {
            return null;
        }
        // Allocate space for decrypted plaintext.
        var resultLength = sealed.length - this.tagLength;
        var result;
        if (dst) {
            if (dst.length !== resultLength) {
                throw new Error("ChaCha20Poly1305: incorrect destination length");
            }
            result = dst;
        }
        else {
            result = new Uint8Array(resultLength);
        }
        // Decrypt.
        chacha_1.streamXOR(this._key, counter, sealed.subarray(0, sealed.length - this.tagLength), result, 4);
        // Cleanup.
        wipe_1.wipe(counter);
        return result;
    };
    ChaCha20Poly1305.prototype.clean = function () {
        wipe_1.wipe(this._key);
        return this;
    };
    ChaCha20Poly1305.prototype._authenticate = function (tagOut, authKey, ciphertext, associatedData) {
        // Initialize Poly1305 with authKey.
        var h = new poly1305_1.Poly1305(authKey);
        // Authenticate padded associated data.
        if (associatedData) {
            h.update(associatedData);
            if (associatedData.length % 16 > 0) {
                h.update(ZEROS.subarray(associatedData.length % 16));
            }
        }
        // Authenticate padded ciphertext.
        h.update(ciphertext);
        if (ciphertext.length % 16 > 0) {
            h.update(ZEROS.subarray(ciphertext.length % 16));
        }
        // Authenticate length of associated data.
        // XXX: can avoid allocation here?
        var length = new Uint8Array(8);
        if (associatedData) {
            binary_1.writeUint64LE(associatedData.length, length);
        }
        h.update(length);
        // Authenticate length of ciphertext.
        binary_1.writeUint64LE(ciphertext.length, length);
        h.update(length);
        // Get tag and copy it into tagOut.
        var tag = h.digest();
        for (var i = 0; i < tag.length; i++) {
            tagOut[i] = tag[i];
        }
        // Cleanup.
        h.clean();
        wipe_1.wipe(tag);
        wipe_1.wipe(length);
    };
    return ChaCha20Poly1305;
}());
exports.OK = ChaCha20Poly1305;


/***/ }),

/***/ 12401:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Package chacha implements ChaCha stream cipher.
 */
var binary_1 = __webpack_require__(10546);
var wipe_1 = __webpack_require__(22059);
// Number of ChaCha rounds (ChaCha20).
var ROUNDS = 20;
// Applies the ChaCha core function to 16-byte input,
// 32-byte key key, and puts the result into 64-byte array out.
function core(out, input, key) {
    var j0 = 0x61707865; // "expa"  -- ChaCha's "sigma" constant
    var j1 = 0x3320646E; // "nd 3"     for 32-byte keys
    var j2 = 0x79622D32; // "2-by"
    var j3 = 0x6B206574; // "te k"
    var j4 = (key[3] << 24) | (key[2] << 16) | (key[1] << 8) | key[0];
    var j5 = (key[7] << 24) | (key[6] << 16) | (key[5] << 8) | key[4];
    var j6 = (key[11] << 24) | (key[10] << 16) | (key[9] << 8) | key[8];
    var j7 = (key[15] << 24) | (key[14] << 16) | (key[13] << 8) | key[12];
    var j8 = (key[19] << 24) | (key[18] << 16) | (key[17] << 8) | key[16];
    var j9 = (key[23] << 24) | (key[22] << 16) | (key[21] << 8) | key[20];
    var j10 = (key[27] << 24) | (key[26] << 16) | (key[25] << 8) | key[24];
    var j11 = (key[31] << 24) | (key[30] << 16) | (key[29] << 8) | key[28];
    var j12 = (input[3] << 24) | (input[2] << 16) | (input[1] << 8) | input[0];
    var j13 = (input[7] << 24) | (input[6] << 16) | (input[5] << 8) | input[4];
    var j14 = (input[11] << 24) | (input[10] << 16) | (input[9] << 8) | input[8];
    var j15 = (input[15] << 24) | (input[14] << 16) | (input[13] << 8) | input[12];
    var x0 = j0;
    var x1 = j1;
    var x2 = j2;
    var x3 = j3;
    var x4 = j4;
    var x5 = j5;
    var x6 = j6;
    var x7 = j7;
    var x8 = j8;
    var x9 = j9;
    var x10 = j10;
    var x11 = j11;
    var x12 = j12;
    var x13 = j13;
    var x14 = j14;
    var x15 = j15;
    for (var i = 0; i < ROUNDS; i += 2) {
        x0 = x0 + x4 | 0;
        x12 ^= x0;
        x12 = x12 >>> (32 - 16) | x12 << 16;
        x8 = x8 + x12 | 0;
        x4 ^= x8;
        x4 = x4 >>> (32 - 12) | x4 << 12;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> (32 - 16) | x13 << 16;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> (32 - 12) | x5 << 12;
        x2 = x2 + x6 | 0;
        x14 ^= x2;
        x14 = x14 >>> (32 - 16) | x14 << 16;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> (32 - 12) | x6 << 12;
        x3 = x3 + x7 | 0;
        x15 ^= x3;
        x15 = x15 >>> (32 - 16) | x15 << 16;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> (32 - 12) | x7 << 12;
        x2 = x2 + x6 | 0;
        x14 ^= x2;
        x14 = x14 >>> (32 - 8) | x14 << 8;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> (32 - 7) | x6 << 7;
        x3 = x3 + x7 | 0;
        x15 ^= x3;
        x15 = x15 >>> (32 - 8) | x15 << 8;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> (32 - 7) | x7 << 7;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> (32 - 8) | x13 << 8;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> (32 - 7) | x5 << 7;
        x0 = x0 + x4 | 0;
        x12 ^= x0;
        x12 = x12 >>> (32 - 8) | x12 << 8;
        x8 = x8 + x12 | 0;
        x4 ^= x8;
        x4 = x4 >>> (32 - 7) | x4 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> (32 - 16) | x15 << 16;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> (32 - 12) | x5 << 12;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> (32 - 16) | x12 << 16;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> (32 - 12) | x6 << 12;
        x2 = x2 + x7 | 0;
        x13 ^= x2;
        x13 = x13 >>> (32 - 16) | x13 << 16;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> (32 - 12) | x7 << 12;
        x3 = x3 + x4 | 0;
        x14 ^= x3;
        x14 = x14 >>> (32 - 16) | x14 << 16;
        x9 = x9 + x14 | 0;
        x4 ^= x9;
        x4 = x4 >>> (32 - 12) | x4 << 12;
        x2 = x2 + x7 | 0;
        x13 ^= x2;
        x13 = x13 >>> (32 - 8) | x13 << 8;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> (32 - 7) | x7 << 7;
        x3 = x3 + x4 | 0;
        x14 ^= x3;
        x14 = x14 >>> (32 - 8) | x14 << 8;
        x9 = x9 + x14 | 0;
        x4 ^= x9;
        x4 = x4 >>> (32 - 7) | x4 << 7;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> (32 - 8) | x12 << 8;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> (32 - 7) | x6 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> (32 - 8) | x15 << 8;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> (32 - 7) | x5 << 7;
    }
    binary_1.writeUint32LE(x0 + j0 | 0, out, 0);
    binary_1.writeUint32LE(x1 + j1 | 0, out, 4);
    binary_1.writeUint32LE(x2 + j2 | 0, out, 8);
    binary_1.writeUint32LE(x3 + j3 | 0, out, 12);
    binary_1.writeUint32LE(x4 + j4 | 0, out, 16);
    binary_1.writeUint32LE(x5 + j5 | 0, out, 20);
    binary_1.writeUint32LE(x6 + j6 | 0, out, 24);
    binary_1.writeUint32LE(x7 + j7 | 0, out, 28);
    binary_1.writeUint32LE(x8 + j8 | 0, out, 32);
    binary_1.writeUint32LE(x9 + j9 | 0, out, 36);
    binary_1.writeUint32LE(x10 + j10 | 0, out, 40);
    binary_1.writeUint32LE(x11 + j11 | 0, out, 44);
    binary_1.writeUint32LE(x12 + j12 | 0, out, 48);
    binary_1.writeUint32LE(x13 + j13 | 0, out, 52);
    binary_1.writeUint32LE(x14 + j14 | 0, out, 56);
    binary_1.writeUint32LE(x15 + j15 | 0, out, 60);
}
/**
 * Encrypt src with ChaCha20 stream generated for the given 32-byte key and
 * 8-byte (as in original implementation) or 12-byte (as in RFC7539) nonce and
 * write the result into dst and return it.
 *
 * dst and src may be the same, but otherwise must not overlap.
 *
 * If nonce is 12 bytes, users should not encrypt more than 256 GiB with the
 * same key and nonce, otherwise the stream will repeat. The function will
 * throw error if counter overflows to prevent this.
 *
 * If nonce is 8 bytes, the output is practically unlimited (2^70 bytes, which
 * is more than a million petabytes). However, it is not recommended to
 * generate 8-byte nonces randomly, as the chance of collision is high.
 *
 * Never use the same key and nonce to encrypt more than one message.
 *
 * If nonceInplaceCounterLength is not 0, the nonce is assumed to be a 16-byte
 * array with stream counter in first nonceInplaceCounterLength bytes and nonce
 * in the last remaining bytes. The counter will be incremented inplace for
 * each ChaCha block. This is useful if you need to encrypt one stream of data
 * in chunks.
 */
function streamXOR(key, nonce, src, dst, nonceInplaceCounterLength) {
    if (nonceInplaceCounterLength === void 0) { nonceInplaceCounterLength = 0; }
    // We only support 256-bit keys.
    if (key.length !== 32) {
        throw new Error("ChaCha: key size must be 32 bytes");
    }
    if (dst.length < src.length) {
        throw new Error("ChaCha: destination is shorter than source");
    }
    var nc;
    var counterLength;
    if (nonceInplaceCounterLength === 0) {
        if (nonce.length !== 8 && nonce.length !== 12) {
            throw new Error("ChaCha nonce must be 8 or 12 bytes");
        }
        nc = new Uint8Array(16);
        // First counterLength bytes of nc are counter, starting with zero.
        counterLength = nc.length - nonce.length;
        // Last bytes of nc after counterLength are nonce, set them.
        nc.set(nonce, counterLength);
    }
    else {
        if (nonce.length !== 16) {
            throw new Error("ChaCha nonce with counter must be 16 bytes");
        }
        // This will update passed nonce with counter inplace.
        nc = nonce;
        counterLength = nonceInplaceCounterLength;
    }
    // Allocate temporary space for ChaCha block.
    var block = new Uint8Array(64);
    for (var i = 0; i < src.length; i += 64) {
        // Generate a block.
        core(block, nc, key);
        // XOR block bytes with src into dst.
        for (var j = i; j < i + 64 && j < src.length; j++) {
            dst[j] = src[j] ^ block[j - i];
        }
        // Increment counter.
        incrementCounter(nc, 0, counterLength);
    }
    // Cleanup temporary space.
    wipe_1.wipe(block);
    if (nonceInplaceCounterLength === 0) {
        // Cleanup counter.
        wipe_1.wipe(nc);
    }
    return dst;
}
exports.streamXOR = streamXOR;
/**
 * Generate ChaCha20 stream for the given 32-byte key and 8-byte or 12-byte
 * nonce and write it into dst and return it.
 *
 * Never use the same key and nonce to generate more than one stream.
 *
 * If nonceInplaceCounterLength is not 0, it behaves the same with respect to
 * the nonce as described in the streamXOR documentation.
 *
 * stream is like streamXOR with all-zero src.
 */
function stream(key, nonce, dst, nonceInplaceCounterLength) {
    if (nonceInplaceCounterLength === void 0) { nonceInplaceCounterLength = 0; }
    wipe_1.wipe(dst);
    return streamXOR(key, nonce, dst, dst, nonceInplaceCounterLength);
}
exports.stream = stream;
function incrementCounter(counter, pos, len) {
    var carry = 1;
    while (len--) {
        carry = carry + (counter[pos] & 0xff) | 0;
        counter[pos] = carry & 0xff;
        carry >>>= 8;
        pos++;
    }
    if (carry > 0) {
        throw new Error("ChaCha: counter overflow");
    }
}


/***/ }),

/***/ 97065:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Package constant-time provides functions for performing algorithmically constant-time operations.
 */
/**
 * NOTE! Due to the inability to guarantee real constant time evaluation of
 * anything in JavaScript VM, this is module is the best effort.
 */
/**
 * Returns resultIfOne if subject is 1, or resultIfZero if subject is 0.
 *
 * Supports only 32-bit integers, so resultIfOne or resultIfZero are not
 * integers, they'll be converted to them with bitwise operations.
 */
function select(subject, resultIfOne, resultIfZero) {
    return (~(subject - 1) & resultIfOne) | ((subject - 1) & resultIfZero);
}
exports.select = select;
/**
 * Returns 1 if a <= b, or 0 if not.
 * Arguments must be positive 32-bit integers less than or equal to 2^31 - 1.
 */
function lessOrEqual(a, b) {
    return (((a | 0) - (b | 0) - 1) >>> 31) & 1;
}
exports.lessOrEqual = lessOrEqual;
/**
 * Returns 1 if a and b are of equal length and their contents
 * are equal, or 0 otherwise.
 *
 * Note that unlike in equal(), zero-length inputs are considered
 * the same, so this function will return 1.
 */
function compare(a, b) {
    if (a.length !== b.length) {
        return 0;
    }
    var result = 0;
    for (var i = 0; i < a.length; i++) {
        result |= a[i] ^ b[i];
    }
    return (1 & ((result - 1) >>> 8));
}
exports.compare = compare;
/**
 * Returns true if a and b are of equal non-zero length,
 * and their contents are equal, or false otherwise.
 *
 * Note that unlike in compare() zero-length inputs are considered
 * _not_ equal, so this function will return false.
 */
function equal(a, b) {
    if (a.length === 0 || b.length === 0) {
        return false;
    }
    return compare(a, b) !== 0;
}
exports.equal = equal;


/***/ }),

/***/ 65952:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", ({ value: true }));
function isSerializableHash(h) {
    return (typeof h.saveState !== "undefined" &&
        typeof h.restoreState !== "undefined" &&
        typeof h.cleanSavedState !== "undefined");
}
exports.isSerializableHash = isSerializableHash;
// TODO(dchest): figure out the standardized interface for XOF such as
// SHAKE and BLAKE2X.


/***/ }),

/***/ 18542:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
__webpack_unused_export__ = ({ value: true });
var hmac_1 = __webpack_require__(75138);
var wipe_1 = __webpack_require__(22059);
/**
 * HMAC-based Extract-and-Expand Key Derivation Function.
 *
 * Implements HKDF from RFC5869.
 *
 * Expands the given master key with salt and info into
 * a limited stream of key material.
 */
var HKDF = /** @class */ (function () {
    /**
     * Create a new HKDF instance for the given hash function
     * with the master key, optional salt, and info.
     *
     * - Master key is a high-entropy secret key (not a password).
     * - Salt is a non-secret random value.
     * - Info is application- and/or context-specific information.
     */
    function HKDF(hash, key, salt, info) {
        if (salt === void 0) { salt = new Uint8Array(0); }
        this._counter = new Uint8Array(1); // starts with zero
        this._hash = hash;
        this._info = info;
        // HKDF-Extract uses salt as HMAC key, and key as data.
        var okm = hmac_1.hmac(this._hash, salt, key);
        // Initialize HMAC for expanding with extracted key.
        this._hmac = new hmac_1.HMAC(hash, okm);
        // Allocate buffer.
        this._buffer = new Uint8Array(this._hmac.digestLength);
        this._bufpos = this._buffer.length;
    }
    // Fill buffer with new block of HKDF-Extract output.
    HKDF.prototype._fillBuffer = function () {
        // Increment counter.
        this._counter[0]++;
        var ctr = this._counter[0];
        // Check if counter overflowed.
        if (ctr === 0) {
            throw new Error("hkdf: cannot expand more");
        }
        // Prepare HMAC instance for new data with old key.
        this._hmac.reset();
        // Hash in previous output if it was generated
        // (i.e. counter is greater than 1).
        if (ctr > 1) {
            this._hmac.update(this._buffer);
        }
        // Hash in info if it exists.
        if (this._info) {
            this._hmac.update(this._info);
        }
        // Hash in the counter.
        this._hmac.update(this._counter);
        // Output result to buffer and clean HMAC instance.
        this._hmac.finish(this._buffer);
        // Reset buffer position.
        this._bufpos = 0;
    };
    /**
     * Expand returns next key material of the given length.
     *
     * It throws if expansion limit is reached (which is
     * 254 digests of the underlying HMAC function).
     */
    HKDF.prototype.expand = function (length) {
        var out = new Uint8Array(length);
        for (var i = 0; i < out.length; i++) {
            if (this._bufpos === this._buffer.length) {
                this._fillBuffer();
            }
            out[i] = this._buffer[this._bufpos++];
        }
        return out;
    };
    HKDF.prototype.clean = function () {
        this._hmac.clean();
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._counter);
        this._bufpos = 0;
    };
    return HKDF;
}());
exports.t = HKDF;
// TODO(dchest): maybe implement deriveKey?


/***/ }),

/***/ 75138:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Package hmac implements HMAC algorithm.
 */
var hash_1 = __webpack_require__(65952);
var constant_time_1 = __webpack_require__(97065);
var wipe_1 = __webpack_require__(22059);
/**
 *  HMAC implements hash-based message authentication algorithm.
 */
var HMAC = /** @class */ (function () {
    /**
     * Constructs a new HMAC with the given Hash and secret key.
     */
    function HMAC(hash, key) {
        this._finished = false; // true if HMAC was finalized
        // Initialize inner and outer hashes.
        this._inner = new hash();
        this._outer = new hash();
        // Set block and digest sizes for this HMAC
        // instance to values from the hash.
        this.blockSize = this._outer.blockSize;
        this.digestLength = this._outer.digestLength;
        // Pad temporary stores a key (or its hash) padded with zeroes.
        var pad = new Uint8Array(this.blockSize);
        if (key.length > this.blockSize) {
            // If key is bigger than hash block size, it must be
            // hashed and this hash is used as a key instead.
            this._inner.update(key).finish(pad).clean();
        }
        else {
            // Otherwise, copy the key into pad.
            pad.set(key);
        }
        // Now two different keys are derived from padded key
        // by xoring a different byte value to each.
        // To make inner hash key, xor byte 0x36 into pad.
        for (var i = 0; i < pad.length; i++) {
            pad[i] ^= 0x36;
        }
        // Update inner hash with the result.
        this._inner.update(pad);
        // To make outer hash key, xor byte 0x5c into pad.
        // But since we already xored 0x36 there, we must
        // first undo this by xoring it again.
        for (var i = 0; i < pad.length; i++) {
            pad[i] ^= 0x36 ^ 0x5c;
        }
        // Update outer hash with the result.
        this._outer.update(pad);
        // Save states of both hashes, so that we can quickly restore
        // them later in reset() without the need to remember the actual
        // key and perform this initialization again.
        if (hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer)) {
            this._innerKeyedState = this._inner.saveState();
            this._outerKeyedState = this._outer.saveState();
        }
        // Clean pad.
        wipe_1.wipe(pad);
    }
    /**
     * Returns HMAC state to the state initialized with key
     * to make it possible to run HMAC over the other data with the same
     * key without creating a new instance.
     */
    HMAC.prototype.reset = function () {
        if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
            throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
        }
        // Restore keyed states of inner and outer hashes.
        this._inner.restoreState(this._innerKeyedState);
        this._outer.restoreState(this._outerKeyedState);
        this._finished = false;
        return this;
    };
    /**
     * Cleans HMAC state.
     */
    HMAC.prototype.clean = function () {
        if (hash_1.isSerializableHash(this._inner)) {
            this._inner.cleanSavedState(this._innerKeyedState);
        }
        if (hash_1.isSerializableHash(this._outer)) {
            this._outer.cleanSavedState(this._outerKeyedState);
        }
        this._inner.clean();
        this._outer.clean();
    };
    /**
     * Updates state with provided data.
     */
    HMAC.prototype.update = function (data) {
        this._inner.update(data);
        return this;
    };
    /**
     * Finalizes HMAC and puts the result in out.
     */
    HMAC.prototype.finish = function (out) {
        if (this._finished) {
            // If HMAC was finalized, outer hash is also finalized,
            // so it produces the same digest it produced when it
            // was finalized.
            this._outer.finish(out);
            return this;
        }
        // Finalize inner hash and store the result temporarily.
        this._inner.finish(out);
        // Update outer hash with digest of inner hash and and finalize it.
        this._outer.update(out.subarray(0, this.digestLength)).finish(out);
        this._finished = true;
        return this;
    };
    /**
     * Returns the computed message authentication code.
     */
    HMAC.prototype.digest = function () {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
    };
    /**
     * Saves HMAC state.
     * This function is needed for PBKDF2 optimization.
     */
    HMAC.prototype.saveState = function () {
        if (!hash_1.isSerializableHash(this._inner)) {
            throw new Error("hmac: can't saveState() because hash doesn't implement it");
        }
        return this._inner.saveState();
    };
    HMAC.prototype.restoreState = function (savedState) {
        if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
            throw new Error("hmac: can't restoreState() because hash doesn't implement it");
        }
        this._inner.restoreState(savedState);
        this._outer.restoreState(this._outerKeyedState);
        this._finished = false;
        return this;
    };
    HMAC.prototype.cleanSavedState = function (savedState) {
        if (!hash_1.isSerializableHash(this._inner)) {
            throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
        }
        this._inner.cleanSavedState(savedState);
    };
    return HMAC;
}());
exports.HMAC = HMAC;
/**
 * Returns HMAC using the given hash constructor for the key over data.
 */
function hmac(hash, key, data) {
    var h = new HMAC(hash, key);
    h.update(data);
    var digest = h.digest();
    h.clean();
    return digest;
}
exports.hmac = hmac;
/**
 * Returns true if two HMAC digests are equal.
 * Uses constant-time comparison to avoid leaking timing information.
 *
 * Example:
 *
 *    const receivedDigest = ...
 *    const realDigest = hmac(SHA256, key, data);
 *    if (!equal(receivedDigest, realDigest)) {
 *        throw new Error("Authentication error");
 *    }
 */
exports.equal = constant_time_1.equal;


/***/ }),

/***/ 15251:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Package int provides helper functions for integerss.
 */
// Shim using 16-bit pieces.
function imulShim(a, b) {
    var ah = (a >>> 16) & 0xffff, al = a & 0xffff;
    var bh = (b >>> 16) & 0xffff, bl = b & 0xffff;
    return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0);
}
/** 32-bit integer multiplication.  */
// Use system Math.imul if available, otherwise use our shim.
exports.mul = Math.imul || imulShim;
/** 32-bit integer addition.  */
function add(a, b) {
    return (a + b) | 0;
}
exports.add = add;
/**  32-bit integer subtraction.  */
function sub(a, b) {
    return (a - b) | 0;
}
exports.sub = sub;
/** 32-bit integer left rotation */
function rotl(x, n) {
    return x << n | x >>> (32 - n);
}
exports.rotl = rotl;
/** 32-bit integer left rotation */
function rotr(x, n) {
    return x << (32 - n) | x >>> n;
}
exports.rotr = rotr;
function isIntegerShim(n) {
    return typeof n === "number" && isFinite(n) && Math.floor(n) === n;
}
/**
 * Returns true if the argument is an integer number.
 *
 * In ES2015, Number.isInteger.
 */
exports.isInteger = Number.isInteger || isIntegerShim;
/**
 *  Math.pow(2, 53) - 1
 *
 *  In ES2015 Number.MAX_SAFE_INTEGER.
 */
exports.MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Returns true if the argument is a safe integer number
 * (-MIN_SAFE_INTEGER < number <= MAX_SAFE_INTEGER)
 *
 * In ES2015, Number.isSafeInteger.
 */
exports.isSafeInteger = function (n) {
    return exports.isInteger(n) && (n >= -exports.MAX_SAFE_INTEGER && n <= exports.MAX_SAFE_INTEGER);
};


/***/ }),

/***/ 15167:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Package poly1305 implements Poly1305 one-time message authentication algorithm.
 */
var constant_time_1 = __webpack_require__(97065);
var wipe_1 = __webpack_require__(22059);
exports.DIGEST_LENGTH = 16;
// Port of Andrew Moon's Poly1305-donna-16. Public domain.
// https://github.com/floodyberry/poly1305-donna
/**
 * Poly1305 computes 16-byte authenticator of message using
 * a one-time 32-byte key.
 *
 * Important: key should be used for only one message,
 * it should never repeat.
 */
var Poly1305 = /** @class */ (function () {
    function Poly1305(key) {
        this.digestLength = exports.DIGEST_LENGTH;
        this._buffer = new Uint8Array(16);
        this._r = new Uint16Array(10);
        this._h = new Uint16Array(10);
        this._pad = new Uint16Array(8);
        this._leftover = 0;
        this._fin = 0;
        this._finished = false;
        var t0 = key[0] | key[1] << 8;
        this._r[0] = (t0) & 0x1fff;
        var t1 = key[2] | key[3] << 8;
        this._r[1] = ((t0 >>> 13) | (t1 << 3)) & 0x1fff;
        var t2 = key[4] | key[5] << 8;
        this._r[2] = ((t1 >>> 10) | (t2 << 6)) & 0x1f03;
        var t3 = key[6] | key[7] << 8;
        this._r[3] = ((t2 >>> 7) | (t3 << 9)) & 0x1fff;
        var t4 = key[8] | key[9] << 8;
        this._r[4] = ((t3 >>> 4) | (t4 << 12)) & 0x00ff;
        this._r[5] = ((t4 >>> 1)) & 0x1ffe;
        var t5 = key[10] | key[11] << 8;
        this._r[6] = ((t4 >>> 14) | (t5 << 2)) & 0x1fff;
        var t6 = key[12] | key[13] << 8;
        this._r[7] = ((t5 >>> 11) | (t6 << 5)) & 0x1f81;
        var t7 = key[14] | key[15] << 8;
        this._r[8] = ((t6 >>> 8) | (t7 << 8)) & 0x1fff;
        this._r[9] = ((t7 >>> 5)) & 0x007f;
        this._pad[0] = key[16] | key[17] << 8;
        this._pad[1] = key[18] | key[19] << 8;
        this._pad[2] = key[20] | key[21] << 8;
        this._pad[3] = key[22] | key[23] << 8;
        this._pad[4] = key[24] | key[25] << 8;
        this._pad[5] = key[26] | key[27] << 8;
        this._pad[6] = key[28] | key[29] << 8;
        this._pad[7] = key[30] | key[31] << 8;
    }
    Poly1305.prototype._blocks = function (m, mpos, bytes) {
        var hibit = this._fin ? 0 : 1 << 11;
        var h0 = this._h[0], h1 = this._h[1], h2 = this._h[2], h3 = this._h[3], h4 = this._h[4], h5 = this._h[5], h6 = this._h[6], h7 = this._h[7], h8 = this._h[8], h9 = this._h[9];
        var r0 = this._r[0], r1 = this._r[1], r2 = this._r[2], r3 = this._r[3], r4 = this._r[4], r5 = this._r[5], r6 = this._r[6], r7 = this._r[7], r8 = this._r[8], r9 = this._r[9];
        while (bytes >= 16) {
            var t0 = m[mpos + 0] | m[mpos + 1] << 8;
            h0 += (t0) & 0x1fff;
            var t1 = m[mpos + 2] | m[mpos + 3] << 8;
            h1 += ((t0 >>> 13) | (t1 << 3)) & 0x1fff;
            var t2 = m[mpos + 4] | m[mpos + 5] << 8;
            h2 += ((t1 >>> 10) | (t2 << 6)) & 0x1fff;
            var t3 = m[mpos + 6] | m[mpos + 7] << 8;
            h3 += ((t2 >>> 7) | (t3 << 9)) & 0x1fff;
            var t4 = m[mpos + 8] | m[mpos + 9] << 8;
            h4 += ((t3 >>> 4) | (t4 << 12)) & 0x1fff;
            h5 += ((t4 >>> 1)) & 0x1fff;
            var t5 = m[mpos + 10] | m[mpos + 11] << 8;
            h6 += ((t4 >>> 14) | (t5 << 2)) & 0x1fff;
            var t6 = m[mpos + 12] | m[mpos + 13] << 8;
            h7 += ((t5 >>> 11) | (t6 << 5)) & 0x1fff;
            var t7 = m[mpos + 14] | m[mpos + 15] << 8;
            h8 += ((t6 >>> 8) | (t7 << 8)) & 0x1fff;
            h9 += ((t7 >>> 5)) | hibit;
            var c = 0;
            var d0 = c;
            d0 += h0 * r0;
            d0 += h1 * (5 * r9);
            d0 += h2 * (5 * r8);
            d0 += h3 * (5 * r7);
            d0 += h4 * (5 * r6);
            c = (d0 >>> 13);
            d0 &= 0x1fff;
            d0 += h5 * (5 * r5);
            d0 += h6 * (5 * r4);
            d0 += h7 * (5 * r3);
            d0 += h8 * (5 * r2);
            d0 += h9 * (5 * r1);
            c += (d0 >>> 13);
            d0 &= 0x1fff;
            var d1 = c;
            d1 += h0 * r1;
            d1 += h1 * r0;
            d1 += h2 * (5 * r9);
            d1 += h3 * (5 * r8);
            d1 += h4 * (5 * r7);
            c = (d1 >>> 13);
            d1 &= 0x1fff;
            d1 += h5 * (5 * r6);
            d1 += h6 * (5 * r5);
            d1 += h7 * (5 * r4);
            d1 += h8 * (5 * r3);
            d1 += h9 * (5 * r2);
            c += (d1 >>> 13);
            d1 &= 0x1fff;
            var d2 = c;
            d2 += h0 * r2;
            d2 += h1 * r1;
            d2 += h2 * r0;
            d2 += h3 * (5 * r9);
            d2 += h4 * (5 * r8);
            c = (d2 >>> 13);
            d2 &= 0x1fff;
            d2 += h5 * (5 * r7);
            d2 += h6 * (5 * r6);
            d2 += h7 * (5 * r5);
            d2 += h8 * (5 * r4);
            d2 += h9 * (5 * r3);
            c += (d2 >>> 13);
            d2 &= 0x1fff;
            var d3 = c;
            d3 += h0 * r3;
            d3 += h1 * r2;
            d3 += h2 * r1;
            d3 += h3 * r0;
            d3 += h4 * (5 * r9);
            c = (d3 >>> 13);
            d3 &= 0x1fff;
            d3 += h5 * (5 * r8);
            d3 += h6 * (5 * r7);
            d3 += h7 * (5 * r6);
            d3 += h8 * (5 * r5);
            d3 += h9 * (5 * r4);
            c += (d3 >>> 13);
            d3 &= 0x1fff;
            var d4 = c;
            d4 += h0 * r4;
            d4 += h1 * r3;
            d4 += h2 * r2;
            d4 += h3 * r1;
            d4 += h4 * r0;
            c = (d4 >>> 13);
            d4 &= 0x1fff;
            d4 += h5 * (5 * r9);
            d4 += h6 * (5 * r8);
            d4 += h7 * (5 * r7);
            d4 += h8 * (5 * r6);
            d4 += h9 * (5 * r5);
            c += (d4 >>> 13);
            d4 &= 0x1fff;
            var d5 = c;
            d5 += h0 * r5;
            d5 += h1 * r4;
            d5 += h2 * r3;
            d5 += h3 * r2;
            d5 += h4 * r1;
            c = (d5 >>> 13);
            d5 &= 0x1fff;
            d5 += h5 * r0;
            d5 += h6 * (5 * r9);
            d5 += h7 * (5 * r8);
            d5 += h8 * (5 * r7);
            d5 += h9 * (5 * r6);
            c += (d5 >>> 13);
            d5 &= 0x1fff;
            var d6 = c;
            d6 += h0 * r6;
            d6 += h1 * r5;
            d6 += h2 * r4;
            d6 += h3 * r3;
            d6 += h4 * r2;
            c = (d6 >>> 13);
            d6 &= 0x1fff;
            d6 += h5 * r1;
            d6 += h6 * r0;
            d6 += h7 * (5 * r9);
            d6 += h8 * (5 * r8);
            d6 += h9 * (5 * r7);
            c += (d6 >>> 13);
            d6 &= 0x1fff;
            var d7 = c;
            d7 += h0 * r7;
            d7 += h1 * r6;
            d7 += h2 * r5;
            d7 += h3 * r4;
            d7 += h4 * r3;
            c = (d7 >>> 13);
            d7 &= 0x1fff;
            d7 += h5 * r2;
            d7 += h6 * r1;
            d7 += h7 * r0;
            d7 += h8 * (5 * r9);
            d7 += h9 * (5 * r8);
            c += (d7 >>> 13);
            d7 &= 0x1fff;
            var d8 = c;
            d8 += h0 * r8;
            d8 += h1 * r7;
            d8 += h2 * r6;
            d8 += h3 * r5;
            d8 += h4 * r4;
            c = (d8 >>> 13);
            d8 &= 0x1fff;
            d8 += h5 * r3;
            d8 += h6 * r2;
            d8 += h7 * r1;
            d8 += h8 * r0;
            d8 += h9 * (5 * r9);
            c += (d8 >>> 13);
            d8 &= 0x1fff;
            var d9 = c;
            d9 += h0 * r9;
            d9 += h1 * r8;
            d9 += h2 * r7;
            d9 += h3 * r6;
            d9 += h4 * r5;
            c = (d9 >>> 13);
            d9 &= 0x1fff;
            d9 += h5 * r4;
            d9 += h6 * r3;
            d9 += h7 * r2;
            d9 += h8 * r1;
            d9 += h9 * r0;
            c += (d9 >>> 13);
            d9 &= 0x1fff;
            c = (((c << 2) + c)) | 0;
            c = (c + d0) | 0;
            d0 = c & 0x1fff;
            c = (c >>> 13);
            d1 += c;
            h0 = d0;
            h1 = d1;
            h2 = d2;
            h3 = d3;
            h4 = d4;
            h5 = d5;
            h6 = d6;
            h7 = d7;
            h8 = d8;
            h9 = d9;
            mpos += 16;
            bytes -= 16;
        }
        this._h[0] = h0;
        this._h[1] = h1;
        this._h[2] = h2;
        this._h[3] = h3;
        this._h[4] = h4;
        this._h[5] = h5;
        this._h[6] = h6;
        this._h[7] = h7;
        this._h[8] = h8;
        this._h[9] = h9;
    };
    Poly1305.prototype.finish = function (mac, macpos) {
        if (macpos === void 0) { macpos = 0; }
        var g = new Uint16Array(10);
        var c;
        var mask;
        var f;
        var i;
        if (this._leftover) {
            i = this._leftover;
            this._buffer[i++] = 1;
            for (; i < 16; i++) {
                this._buffer[i] = 0;
            }
            this._fin = 1;
            this._blocks(this._buffer, 0, 16);
        }
        c = this._h[1] >>> 13;
        this._h[1] &= 0x1fff;
        for (i = 2; i < 10; i++) {
            this._h[i] += c;
            c = this._h[i] >>> 13;
            this._h[i] &= 0x1fff;
        }
        this._h[0] += (c * 5);
        c = this._h[0] >>> 13;
        this._h[0] &= 0x1fff;
        this._h[1] += c;
        c = this._h[1] >>> 13;
        this._h[1] &= 0x1fff;
        this._h[2] += c;
        g[0] = this._h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 0x1fff;
        for (i = 1; i < 10; i++) {
            g[i] = this._h[i] + c;
            c = g[i] >>> 13;
            g[i] &= 0x1fff;
        }
        g[9] -= (1 << 13);
        mask = (c ^ 1) - 1;
        for (i = 0; i < 10; i++) {
            g[i] &= mask;
        }
        mask = ~mask;
        for (i = 0; i < 10; i++) {
            this._h[i] = (this._h[i] & mask) | g[i];
        }
        this._h[0] = ((this._h[0]) | (this._h[1] << 13)) & 0xffff;
        this._h[1] = ((this._h[1] >>> 3) | (this._h[2] << 10)) & 0xffff;
        this._h[2] = ((this._h[2] >>> 6) | (this._h[3] << 7)) & 0xffff;
        this._h[3] = ((this._h[3] >>> 9) | (this._h[4] << 4)) & 0xffff;
        this._h[4] = ((this._h[4] >>> 12) | (this._h[5] << 1) | (this._h[6] << 14)) & 0xffff;
        this._h[5] = ((this._h[6] >>> 2) | (this._h[7] << 11)) & 0xffff;
        this._h[6] = ((this._h[7] >>> 5) | (this._h[8] << 8)) & 0xffff;
        this._h[7] = ((this._h[8] >>> 8) | (this._h[9] << 5)) & 0xffff;
        f = this._h[0] + this._pad[0];
        this._h[0] = f & 0xffff;
        for (i = 1; i < 8; i++) {
            f = (((this._h[i] + this._pad[i]) | 0) + (f >>> 16)) | 0;
            this._h[i] = f & 0xffff;
        }
        mac[macpos + 0] = this._h[0] >>> 0;
        mac[macpos + 1] = this._h[0] >>> 8;
        mac[macpos + 2] = this._h[1] >>> 0;
        mac[macpos + 3] = this._h[1] >>> 8;
        mac[macpos + 4] = this._h[2] >>> 0;
        mac[macpos + 5] = this._h[2] >>> 8;
        mac[macpos + 6] = this._h[3] >>> 0;
        mac[macpos + 7] = this._h[3] >>> 8;
        mac[macpos + 8] = this._h[4] >>> 0;
        mac[macpos + 9] = this._h[4] >>> 8;
        mac[macpos + 10] = this._h[5] >>> 0;
        mac[macpos + 11] = this._h[5] >>> 8;
        mac[macpos + 12] = this._h[6] >>> 0;
        mac[macpos + 13] = this._h[6] >>> 8;
        mac[macpos + 14] = this._h[7] >>> 0;
        mac[macpos + 15] = this._h[7] >>> 8;
        this._finished = true;
        return this;
    };
    Poly1305.prototype.update = function (m) {
        var mpos = 0;
        var bytes = m.length;
        var want;
        if (this._leftover) {
            want = (16 - this._leftover);
            if (want > bytes) {
                want = bytes;
            }
            for (var i = 0; i < want; i++) {
                this._buffer[this._leftover + i] = m[mpos + i];
            }
            bytes -= want;
            mpos += want;
            this._leftover += want;
            if (this._leftover < 16) {
                return this;
            }
            this._blocks(this._buffer, 0, 16);
            this._leftover = 0;
        }
        if (bytes >= 16) {
            want = bytes - (bytes % 16);
            this._blocks(m, mpos, want);
            mpos += want;
            bytes -= want;
        }
        if (bytes) {
            for (var i = 0; i < bytes; i++) {
                this._buffer[this._leftover + i] = m[mpos + i];
            }
            this._leftover += bytes;
        }
        return this;
    };
    Poly1305.prototype.digest = function () {
        // TODO(dchest): it behaves differently than other hashes/HMAC,
        // because it throws when finished — others just return saved result.
        if (this._finished) {
            throw new Error("Poly1305 was finished");
        }
        var mac = new Uint8Array(16);
        this.finish(mac);
        return mac;
    };
    Poly1305.prototype.clean = function () {
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._r);
        wipe_1.wipe(this._h);
        wipe_1.wipe(this._pad);
        this._leftover = 0;
        this._fin = 0;
        this._finished = true; // mark as finished even if not
        return this;
    };
    return Poly1305;
}());
exports.Poly1305 = Poly1305;
/**
 * Returns 16-byte authenticator of data using a one-time 32-byte key.
 *
 * Important: key should be used for only one message, it should never repeat.
 */
function oneTimeAuth(key, data) {
    var h = new Poly1305(key);
    h.update(data);
    var digest = h.digest();
    h.clean();
    return digest;
}
exports.oneTimeAuth = oneTimeAuth;
/**
 * Returns true if two authenticators are 16-byte long and equal.
 * Uses contant-time comparison to avoid leaking timing information.
 */
function equal(a, b) {
    if (a.length !== exports.DIGEST_LENGTH || b.length !== exports.DIGEST_LENGTH) {
        return false;
    }
    return constant_time_1.equal(a, b);
}
exports.equal = equal;


/***/ }),

/***/ 68437:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.randomStringForEntropy = exports.randomString = exports.randomUint32 = exports.randomBytes = exports.defaultRandomSource = void 0;
const system_1 = __webpack_require__(95191);
const binary_1 = __webpack_require__(10546);
const wipe_1 = __webpack_require__(22059);
exports.defaultRandomSource = new system_1.SystemRandomSource();
function randomBytes(length, prng = exports.defaultRandomSource) {
    return prng.randomBytes(length);
}
exports.randomBytes = randomBytes;
/**
 * Returns a uniformly random unsigned 32-bit integer.
 */
function randomUint32(prng = exports.defaultRandomSource) {
    // Generate 4-byte random buffer.
    const buf = randomBytes(4, prng);
    // Convert bytes from buffer into a 32-bit integer.
    // It's not important which byte order to use, since
    // the result is random.
    const result = (0, binary_1.readUint32LE)(buf);
    // Clean the buffer.
    (0, wipe_1.wipe)(buf);
    return result;
}
exports.randomUint32 = randomUint32;
/** 62 alphanumeric characters for default charset of randomString() */
const ALPHANUMERIC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
/**
 * Returns a uniform random string of the given length
 * with characters from the given charset.
 *
 * Charset must not have more than 256 characters.
 *
 * Default charset generates case-sensitive alphanumeric
 * strings (0-9, A-Z, a-z).
 */
function randomString(length, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
    if (charset.length < 2) {
        throw new Error("randomString charset is too short");
    }
    if (charset.length > 256) {
        throw new Error("randomString charset is too long");
    }
    let out = '';
    const charsLen = charset.length;
    const maxByte = 256 - (256 % charsLen);
    while (length > 0) {
        const buf = randomBytes(Math.ceil(length * 256 / maxByte), prng);
        for (let i = 0; i < buf.length && length > 0; i++) {
            const randomByte = buf[i];
            if (randomByte < maxByte) {
                out += charset.charAt(randomByte % charsLen);
                length--;
            }
        }
        (0, wipe_1.wipe)(buf);
    }
    return out;
}
exports.randomString = randomString;
/**
 * Returns uniform random string containing at least the given
 * number of bits of entropy.
 *
 * For example, randomStringForEntropy(128) will return a 22-character
 * alphanumeric string, while randomStringForEntropy(128, "0123456789")
 * will return a 39-character numeric string, both will contain at
 * least 128 bits of entropy.
 *
 * Default charset generates case-sensitive alphanumeric
 * strings (0-9, A-Z, a-z).
 */
function randomStringForEntropy(bits, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
    const length = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));
    return randomString(length, charset, prng);
}
exports.randomStringForEntropy = randomStringForEntropy;


/***/ }),

/***/ 17654:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BrowserRandomSource = void 0;
const QUOTA = 65536;
class BrowserRandomSource {
    constructor() {
        this.isAvailable = false;
        this.isInstantiated = false;
        const browserCrypto = typeof self !== 'undefined'
            ? (self.crypto || self.msCrypto) // IE11 has msCrypto
            : null;
        if (browserCrypto && browserCrypto.getRandomValues !== undefined) {
            this._crypto = browserCrypto;
            this.isAvailable = true;
            this.isInstantiated = true;
        }
    }
    randomBytes(length) {
        if (!this.isAvailable || !this._crypto) {
            throw new Error("Browser random byte generator is not available.");
        }
        const out = new Uint8Array(length);
        for (let i = 0; i < out.length; i += QUOTA) {
            this._crypto.getRandomValues(out.subarray(i, i + Math.min(out.length - i, QUOTA)));
        }
        return out;
    }
}
exports.BrowserRandomSource = BrowserRandomSource;


/***/ }),

/***/ 8666:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NodeRandomSource = void 0;
const wipe_1 = __webpack_require__(22059);
class NodeRandomSource {
    constructor() {
        this.isAvailable = false;
        this.isInstantiated = false;
        if (true) {
            const nodeCrypto = __webpack_require__(10985);
            if (nodeCrypto && nodeCrypto.randomBytes) {
                this._crypto = nodeCrypto;
                this.isAvailable = true;
                this.isInstantiated = true;
            }
        }
    }
    randomBytes(length) {
        if (!this.isAvailable || !this._crypto) {
            throw new Error("Node.js random byte generator is not available.");
        }
        // Get random bytes (result is Buffer).
        let buffer = this._crypto.randomBytes(length);
        // Make sure we got the length that we requested.
        if (buffer.length !== length) {
            throw new Error("NodeRandomSource: got fewer bytes than requested");
        }
        // Allocate output array.
        const out = new Uint8Array(length);
        // Copy bytes from buffer to output.
        for (let i = 0; i < out.length; i++) {
            out[i] = buffer[i];
        }
        // Cleanup.
        (0, wipe_1.wipe)(buffer);
        return out;
    }
}
exports.NodeRandomSource = NodeRandomSource;


/***/ }),

/***/ 95191:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SystemRandomSource = void 0;
const browser_1 = __webpack_require__(17654);
const node_1 = __webpack_require__(8666);
class SystemRandomSource {
    constructor() {
        this.isAvailable = false;
        this.name = "";
        // Try browser.
        this._source = new browser_1.BrowserRandomSource();
        if (this._source.isAvailable) {
            this.isAvailable = true;
            this.name = "Browser";
            return;
        }
        // If no browser source, try Node.
        this._source = new node_1.NodeRandomSource();
        if (this._source.isAvailable) {
            this.isAvailable = true;
            this.name = "Node";
            return;
        }
        // No sources, we're out of options.
    }
    randomBytes(length) {
        if (!this.isAvailable) {
            throw new Error("System random byte generator is not available.");
        }
        return this._source.randomBytes(length);
    }
}
exports.SystemRandomSource = SystemRandomSource;


/***/ }),

/***/ 16802:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
__webpack_unused_export__ = ({ value: true });
var binary_1 = __webpack_require__(10546);
var wipe_1 = __webpack_require__(22059);
exports.k = 32;
exports.cn = 64;
/**
 * SHA2-256 cryptographic hash algorithm.
 */
var SHA256 = /** @class */ (function () {
    function SHA256() {
        /** Length of hash output */
        this.digestLength = exports.k;
        /** Block size */
        this.blockSize = exports.cn;
        // Note: Int32Array is used instead of Uint32Array for performance reasons.
        this._state = new Int32Array(8); // hash state
        this._temp = new Int32Array(64); // temporary state
        this._buffer = new Uint8Array(128); // buffer for data to hash
        this._bufferLength = 0; // number of bytes in buffer
        this._bytesHashed = 0; // number of total bytes hashed
        this._finished = false; // indicates whether the hash was finalized
        this.reset();
    }
    SHA256.prototype._initState = function () {
        this._state[0] = 0x6a09e667;
        this._state[1] = 0xbb67ae85;
        this._state[2] = 0x3c6ef372;
        this._state[3] = 0xa54ff53a;
        this._state[4] = 0x510e527f;
        this._state[5] = 0x9b05688c;
        this._state[6] = 0x1f83d9ab;
        this._state[7] = 0x5be0cd19;
    };
    /**
     * Resets hash state making it possible
     * to re-use this instance to hash other data.
     */
    SHA256.prototype.reset = function () {
        this._initState();
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        return this;
    };
    /**
     * Cleans internal buffers and resets hash state.
     */
    SHA256.prototype.clean = function () {
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._temp);
        this.reset();
    };
    /**
     * Updates hash state with the given data.
     *
     * Throws error when trying to update already finalized hash:
     * instance must be reset to update it again.
     */
    SHA256.prototype.update = function (data, dataLength) {
        if (dataLength === void 0) { dataLength = data.length; }
        if (this._finished) {
            throw new Error("SHA256: can't update because hash was finished.");
        }
        var dataPos = 0;
        this._bytesHashed += dataLength;
        if (this._bufferLength > 0) {
            while (this._bufferLength < this.blockSize && dataLength > 0) {
                this._buffer[this._bufferLength++] = data[dataPos++];
                dataLength--;
            }
            if (this._bufferLength === this.blockSize) {
                hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize);
                this._bufferLength = 0;
            }
        }
        if (dataLength >= this.blockSize) {
            dataPos = hashBlocks(this._temp, this._state, data, dataPos, dataLength);
            dataLength %= this.blockSize;
        }
        while (dataLength > 0) {
            this._buffer[this._bufferLength++] = data[dataPos++];
            dataLength--;
        }
        return this;
    };
    /**
     * Finalizes hash state and puts hash into out.
     * If hash was already finalized, puts the same value.
     */
    SHA256.prototype.finish = function (out) {
        if (!this._finished) {
            var bytesHashed = this._bytesHashed;
            var left = this._bufferLength;
            var bitLenHi = (bytesHashed / 0x20000000) | 0;
            var bitLenLo = bytesHashed << 3;
            var padLength = (bytesHashed % 64 < 56) ? 64 : 128;
            this._buffer[left] = 0x80;
            for (var i = left + 1; i < padLength - 8; i++) {
                this._buffer[i] = 0;
            }
            binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
            binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
            hashBlocks(this._temp, this._state, this._buffer, 0, padLength);
            this._finished = true;
        }
        for (var i = 0; i < this.digestLength / 4; i++) {
            binary_1.writeUint32BE(this._state[i], out, i * 4);
        }
        return this;
    };
    /**
     * Returns the final hash digest.
     */
    SHA256.prototype.digest = function () {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
    };
    /**
     * Function useful for HMAC/PBKDF2 optimization.
     * Returns hash state to be used with restoreState().
     * Only chain value is saved, not buffers or other
     * state variables.
     */
    SHA256.prototype.saveState = function () {
        if (this._finished) {
            throw new Error("SHA256: cannot save finished state");
        }
        return {
            state: new Int32Array(this._state),
            buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : undefined,
            bufferLength: this._bufferLength,
            bytesHashed: this._bytesHashed
        };
    };
    /**
     * Function useful for HMAC/PBKDF2 optimization.
     * Restores state saved by saveState() and sets bytesHashed
     * to the given value.
     */
    SHA256.prototype.restoreState = function (savedState) {
        this._state.set(savedState.state);
        this._bufferLength = savedState.bufferLength;
        if (savedState.buffer) {
            this._buffer.set(savedState.buffer);
        }
        this._bytesHashed = savedState.bytesHashed;
        this._finished = false;
        return this;
    };
    /**
     * Cleans state returned by saveState().
     */
    SHA256.prototype.cleanSavedState = function (savedState) {
        wipe_1.wipe(savedState.state);
        if (savedState.buffer) {
            wipe_1.wipe(savedState.buffer);
        }
        savedState.bufferLength = 0;
        savedState.bytesHashed = 0;
    };
    return SHA256;
}());
exports.mE = SHA256;
// Constants
var K = new Int32Array([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,
    0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,
    0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,
    0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152,
    0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,
    0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,
    0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,
    0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08,
    0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f,
    0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
function hashBlocks(w, v, p, pos, len) {
    while (len >= 64) {
        var a = v[0];
        var b = v[1];
        var c = v[2];
        var d = v[3];
        var e = v[4];
        var f = v[5];
        var g = v[6];
        var h = v[7];
        for (var i = 0; i < 16; i++) {
            var j = pos + i * 4;
            w[i] = binary_1.readUint32BE(p, j);
        }
        for (var i = 16; i < 64; i++) {
            var u = w[i - 2];
            var t1 = (u >>> 17 | u << (32 - 17)) ^ (u >>> 19 | u << (32 - 19)) ^ (u >>> 10);
            u = w[i - 15];
            var t2 = (u >>> 7 | u << (32 - 7)) ^ (u >>> 18 | u << (32 - 18)) ^ (u >>> 3);
            w[i] = (t1 + w[i - 7] | 0) + (t2 + w[i - 16] | 0);
        }
        for (var i = 0; i < 64; i++) {
            var t1 = (((((e >>> 6 | e << (32 - 6)) ^ (e >>> 11 | e << (32 - 11)) ^
                (e >>> 25 | e << (32 - 25))) + ((e & f) ^ (~e & g))) | 0) +
                ((h + ((K[i] + w[i]) | 0)) | 0)) | 0;
            var t2 = (((a >>> 2 | a << (32 - 2)) ^ (a >>> 13 | a << (32 - 13)) ^
                (a >>> 22 | a << (32 - 22))) + ((a & b) ^ (a & c) ^ (b & c))) | 0;
            h = g;
            g = f;
            f = e;
            e = (d + t1) | 0;
            d = c;
            c = b;
            b = a;
            a = (t1 + t2) | 0;
        }
        v[0] += a;
        v[1] += b;
        v[2] += c;
        v[3] += d;
        v[4] += e;
        v[5] += f;
        v[6] += g;
        v[7] += h;
        pos += 64;
        len -= 64;
    }
    return pos;
}
function hash(data) {
    var h = new SHA256();
    h.update(data);
    var digest = h.digest();
    h.clean();
    return digest;
}
exports.vp = hash;


/***/ }),

/***/ 12202:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", ({ value: true }));
var binary_1 = __webpack_require__(10546);
var wipe_1 = __webpack_require__(22059);
exports.DIGEST_LENGTH = 64;
exports.BLOCK_SIZE = 128;
/**
 * SHA-2-512 cryptographic hash algorithm.
 */
var SHA512 = /** @class */ (function () {
    function SHA512() {
        /** Length of hash output */
        this.digestLength = exports.DIGEST_LENGTH;
        /** Block size */
        this.blockSize = exports.BLOCK_SIZE;
        // Note: Int32Array is used instead of Uint32Array for performance reasons.
        this._stateHi = new Int32Array(8); // hash state, high bytes
        this._stateLo = new Int32Array(8); // hash state, low bytes
        this._tempHi = new Int32Array(16); // temporary state, high bytes
        this._tempLo = new Int32Array(16); // temporary state, low bytes
        this._buffer = new Uint8Array(256); // buffer for data to hash
        this._bufferLength = 0; // number of bytes in buffer
        this._bytesHashed = 0; // number of total bytes hashed
        this._finished = false; // indicates whether the hash was finalized
        this.reset();
    }
    SHA512.prototype._initState = function () {
        this._stateHi[0] = 0x6a09e667;
        this._stateHi[1] = 0xbb67ae85;
        this._stateHi[2] = 0x3c6ef372;
        this._stateHi[3] = 0xa54ff53a;
        this._stateHi[4] = 0x510e527f;
        this._stateHi[5] = 0x9b05688c;
        this._stateHi[6] = 0x1f83d9ab;
        this._stateHi[7] = 0x5be0cd19;
        this._stateLo[0] = 0xf3bcc908;
        this._stateLo[1] = 0x84caa73b;
        this._stateLo[2] = 0xfe94f82b;
        this._stateLo[3] = 0x5f1d36f1;
        this._stateLo[4] = 0xade682d1;
        this._stateLo[5] = 0x2b3e6c1f;
        this._stateLo[6] = 0xfb41bd6b;
        this._stateLo[7] = 0x137e2179;
    };
    /**
     * Resets hash state making it possible
     * to re-use this instance to hash other data.
     */
    SHA512.prototype.reset = function () {
        this._initState();
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        return this;
    };
    /**
     * Cleans internal buffers and resets hash state.
     */
    SHA512.prototype.clean = function () {
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._tempHi);
        wipe_1.wipe(this._tempLo);
        this.reset();
    };
    /**
     * Updates hash state with the given data.
     *
     * Throws error when trying to update already finalized hash:
     * instance must be reset to update it again.
     */
    SHA512.prototype.update = function (data, dataLength) {
        if (dataLength === void 0) { dataLength = data.length; }
        if (this._finished) {
            throw new Error("SHA512: can't update because hash was finished.");
        }
        var dataPos = 0;
        this._bytesHashed += dataLength;
        if (this._bufferLength > 0) {
            while (this._bufferLength < exports.BLOCK_SIZE && dataLength > 0) {
                this._buffer[this._bufferLength++] = data[dataPos++];
                dataLength--;
            }
            if (this._bufferLength === this.blockSize) {
                hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize);
                this._bufferLength = 0;
            }
        }
        if (dataLength >= this.blockSize) {
            dataPos = hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, data, dataPos, dataLength);
            dataLength %= this.blockSize;
        }
        while (dataLength > 0) {
            this._buffer[this._bufferLength++] = data[dataPos++];
            dataLength--;
        }
        return this;
    };
    /**
     * Finalizes hash state and puts hash into out.
     * If hash was already finalized, puts the same value.
     */
    SHA512.prototype.finish = function (out) {
        if (!this._finished) {
            var bytesHashed = this._bytesHashed;
            var left = this._bufferLength;
            var bitLenHi = (bytesHashed / 0x20000000) | 0;
            var bitLenLo = bytesHashed << 3;
            var padLength = (bytesHashed % 128 < 112) ? 128 : 256;
            this._buffer[left] = 0x80;
            for (var i = left + 1; i < padLength - 8; i++) {
                this._buffer[i] = 0;
            }
            binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
            binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
            hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, padLength);
            this._finished = true;
        }
        for (var i = 0; i < this.digestLength / 8; i++) {
            binary_1.writeUint32BE(this._stateHi[i], out, i * 8);
            binary_1.writeUint32BE(this._stateLo[i], out, i * 8 + 4);
        }
        return this;
    };
    /**
     * Returns the final hash digest.
     */
    SHA512.prototype.digest = function () {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
    };
    /**
     * Function useful for HMAC/PBKDF2 optimization. Returns hash state to be
     * used with restoreState(). Only chain value is saved, not buffers or
     * other state variables.
     */
    SHA512.prototype.saveState = function () {
        if (this._finished) {
            throw new Error("SHA256: cannot save finished state");
        }
        return {
            stateHi: new Int32Array(this._stateHi),
            stateLo: new Int32Array(this._stateLo),
            buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : undefined,
            bufferLength: this._bufferLength,
            bytesHashed: this._bytesHashed
        };
    };
    /**
     * Function useful for HMAC/PBKDF2 optimization. Restores state saved by
     * saveState() and sets bytesHashed to the given value.
     */
    SHA512.prototype.restoreState = function (savedState) {
        this._stateHi.set(savedState.stateHi);
        this._stateLo.set(savedState.stateLo);
        this._bufferLength = savedState.bufferLength;
        if (savedState.buffer) {
            this._buffer.set(savedState.buffer);
        }
        this._bytesHashed = savedState.bytesHashed;
        this._finished = false;
        return this;
    };
    /**
     * Cleans state returned by saveState().
     */
    SHA512.prototype.cleanSavedState = function (savedState) {
        wipe_1.wipe(savedState.stateHi);
        wipe_1.wipe(savedState.stateLo);
        if (savedState.buffer) {
            wipe_1.wipe(savedState.buffer);
        }
        savedState.bufferLength = 0;
        savedState.bytesHashed = 0;
    };
    return SHA512;
}());
exports.SHA512 = SHA512;
// Constants
var K = new Int32Array([
    0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
    0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
    0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
    0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
    0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
    0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
    0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
    0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
    0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
    0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
    0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
    0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
    0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
    0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
    0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
    0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
    0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
    0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
    0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
    0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
    0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
    0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
    0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
    0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
    0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
    0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
    0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
    0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
    0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
    0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
    0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
    0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
    0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
    0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
    0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
    0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
    0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
    0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
    0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
    0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]);
function hashBlocks(wh, wl, hh, hl, m, pos, len) {
    var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
    var h, l;
    var th, tl;
    var a, b, c, d;
    while (len >= 128) {
        for (var i = 0; i < 16; i++) {
            var j = 8 * i + pos;
            wh[i] = binary_1.readUint32BE(m, j);
            wl[i] = binary_1.readUint32BE(m, j + 4);
        }
        for (var i = 0; i < 80; i++) {
            var bh0 = ah0;
            var bh1 = ah1;
            var bh2 = ah2;
            var bh3 = ah3;
            var bh4 = ah4;
            var bh5 = ah5;
            var bh6 = ah6;
            var bh7 = ah7;
            var bl0 = al0;
            var bl1 = al1;
            var bl2 = al2;
            var bl3 = al3;
            var bl4 = al4;
            var bl5 = al5;
            var bl6 = al6;
            var bl7 = al7;
            // add
            h = ah7;
            l = al7;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            // Sigma1
            h = ((ah4 >>> 14) | (al4 << (32 - 14))) ^ ((ah4 >>> 18) |
                (al4 << (32 - 18))) ^ ((al4 >>> (41 - 32)) | (ah4 << (32 - (41 - 32))));
            l = ((al4 >>> 14) | (ah4 << (32 - 14))) ^ ((al4 >>> 18) |
                (ah4 << (32 - 18))) ^ ((ah4 >>> (41 - 32)) | (al4 << (32 - (41 - 32))));
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            // Ch
            h = (ah4 & ah5) ^ (~ah4 & ah6);
            l = (al4 & al5) ^ (~al4 & al6);
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            // K
            h = K[i * 2];
            l = K[i * 2 + 1];
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            // w
            h = wh[i % 16];
            l = wl[i % 16];
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            th = c & 0xffff | d << 16;
            tl = a & 0xffff | b << 16;
            // add
            h = th;
            l = tl;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            // Sigma0
            h = ((ah0 >>> 28) | (al0 << (32 - 28))) ^ ((al0 >>> (34 - 32)) |
                (ah0 << (32 - (34 - 32)))) ^ ((al0 >>> (39 - 32)) | (ah0 << (32 - (39 - 32))));
            l = ((al0 >>> 28) | (ah0 << (32 - 28))) ^ ((ah0 >>> (34 - 32)) |
                (al0 << (32 - (34 - 32)))) ^ ((ah0 >>> (39 - 32)) | (al0 << (32 - (39 - 32))));
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            // Maj
            h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
            l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh7 = (c & 0xffff) | (d << 16);
            bl7 = (a & 0xffff) | (b << 16);
            // add
            h = bh3;
            l = bl3;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            h = th;
            l = tl;
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh3 = (c & 0xffff) | (d << 16);
            bl3 = (a & 0xffff) | (b << 16);
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i % 16 === 15) {
                for (var j = 0; j < 16; j++) {
                    // add
                    h = wh[j];
                    l = wl[j];
                    a = l & 0xffff;
                    b = l >>> 16;
                    c = h & 0xffff;
                    d = h >>> 16;
                    h = wh[(j + 9) % 16];
                    l = wl[(j + 9) % 16];
                    a += l & 0xffff;
                    b += l >>> 16;
                    c += h & 0xffff;
                    d += h >>> 16;
                    // sigma0
                    th = wh[(j + 1) % 16];
                    tl = wl[(j + 1) % 16];
                    h = ((th >>> 1) | (tl << (32 - 1))) ^ ((th >>> 8) |
                        (tl << (32 - 8))) ^ (th >>> 7);
                    l = ((tl >>> 1) | (th << (32 - 1))) ^ ((tl >>> 8) |
                        (th << (32 - 8))) ^ ((tl >>> 7) | (th << (32 - 7)));
                    a += l & 0xffff;
                    b += l >>> 16;
                    c += h & 0xffff;
                    d += h >>> 16;
                    // sigma1
                    th = wh[(j + 14) % 16];
                    tl = wl[(j + 14) % 16];
                    h = ((th >>> 19) | (tl << (32 - 19))) ^ ((tl >>> (61 - 32)) |
                        (th << (32 - (61 - 32)))) ^ (th >>> 6);
                    l = ((tl >>> 19) | (th << (32 - 19))) ^ ((th >>> (61 - 32)) |
                        (tl << (32 - (61 - 32)))) ^ ((tl >>> 6) | (th << (32 - 6)));
                    a += l & 0xffff;
                    b += l >>> 16;
                    c += h & 0xffff;
                    d += h >>> 16;
                    b += a >>> 16;
                    c += b >>> 16;
                    d += c >>> 16;
                    wh[j] = (c & 0xffff) | (d << 16);
                    wl[j] = (a & 0xffff) | (b << 16);
                }
            }
        }
        // add
        h = ah0;
        l = al0;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[0];
        l = hl[0];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[0] = ah0 = (c & 0xffff) | (d << 16);
        hl[0] = al0 = (a & 0xffff) | (b << 16);
        h = ah1;
        l = al1;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[1];
        l = hl[1];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[1] = ah1 = (c & 0xffff) | (d << 16);
        hl[1] = al1 = (a & 0xffff) | (b << 16);
        h = ah2;
        l = al2;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[2];
        l = hl[2];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[2] = ah2 = (c & 0xffff) | (d << 16);
        hl[2] = al2 = (a & 0xffff) | (b << 16);
        h = ah3;
        l = al3;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[3];
        l = hl[3];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[3] = ah3 = (c & 0xffff) | (d << 16);
        hl[3] = al3 = (a & 0xffff) | (b << 16);
        h = ah4;
        l = al4;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[4];
        l = hl[4];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[4] = ah4 = (c & 0xffff) | (d << 16);
        hl[4] = al4 = (a & 0xffff) | (b << 16);
        h = ah5;
        l = al5;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[5];
        l = hl[5];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[5] = ah5 = (c & 0xffff) | (d << 16);
        hl[5] = al5 = (a & 0xffff) | (b << 16);
        h = ah6;
        l = al6;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[6];
        l = hl[6];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[6] = ah6 = (c & 0xffff) | (d << 16);
        hl[6] = al6 = (a & 0xffff) | (b << 16);
        h = ah7;
        l = al7;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[7];
        l = hl[7];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[7] = ah7 = (c & 0xffff) | (d << 16);
        hl[7] = al7 = (a & 0xffff) | (b << 16);
        pos += 128;
        len -= 128;
    }
    return pos;
}
function hash(data) {
    var h = new SHA512();
    h.update(data);
    var digest = h.digest();
    h.clean();
    return digest;
}
exports.hash = hash;


/***/ }),

/***/ 22059:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Sets all values in the given array to zero and returns it.
 *
 * The fact that it sets bytes to zero can be relied on.
 *
 * There is no guarantee that this function makes data disappear from memory,
 * as runtime implementation can, for example, have copying garbage collector
 * that will make copies of sensitive data before we wipe it. Or that an
 * operating system will write our data to swap or sleep image. Another thing
 * is that an optimizing compiler can remove calls to this function or make it
 * no-op. There's nothing we can do with it, so we just do our best and hope
 * that everything will be okay and good will triumph over evil.
 */
function wipe(array) {
    // Right now it's similar to array.fill(0). If it turns
    // out that runtimes optimize this call away, maybe
    // we can try something else.
    for (var i = 0; i < array.length; i++) {
        array[i] = 0;
    }
    return array;
}
exports.wipe = wipe;


/***/ }),

/***/ 95200:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
__webpack_unused_export__ = ({ value: true });
exports.gi = exports.Au = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = exports.KS = exports.kz = void 0;
/**
 * Package x25519 implements X25519 key agreement.
 */
const random_1 = __webpack_require__(68437);
const wipe_1 = __webpack_require__(22059);
exports.kz = 32;
exports.KS = 32;
__webpack_unused_export__ = 32;
// Returns new zero-filled 16-element GF (Float64Array).
// If passed an array of numbers, prefills the returned
// array with them.
//
// We use Float64Array, because we need 48-bit numbers
// for this implementation.
function gf(init) {
    const r = new Float64Array(16);
    if (init) {
        for (let i = 0; i < init.length; i++) {
            r[i] = init[i];
        }
    }
    return r;
}
// Base point.
const _9 = new Uint8Array(32);
_9[0] = 9;
const _121665 = gf([0xdb41, 1]);
function car25519(o) {
    let c = 1;
    for (let i = 0; i < 16; i++) {
        let v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
    }
    o[0] += c - 1 + 37 * (c - 1);
}
function sel25519(p, q, b) {
    const c = ~(b - 1);
    for (let i = 0; i < 16; i++) {
        const t = c & (p[i] ^ q[i]);
        p[i] ^= t;
        q[i] ^= t;
    }
}
function pack25519(o, n) {
    const m = gf();
    const t = gf();
    for (let i = 0; i < 16; i++) {
        t[i] = n[i];
    }
    car25519(t);
    car25519(t);
    car25519(t);
    for (let j = 0; j < 2; j++) {
        m[0] = t[0] - 0xffed;
        for (let i = 1; i < 15; i++) {
            m[i] = t[i] - 0xffff - ((m[i - 1] >> 16) & 1);
            m[i - 1] &= 0xffff;
        }
        m[15] = t[15] - 0x7fff - ((m[14] >> 16) & 1);
        const b = (m[15] >> 16) & 1;
        m[14] &= 0xffff;
        sel25519(t, m, 1 - b);
    }
    for (let i = 0; i < 16; i++) {
        o[2 * i] = t[i] & 0xff;
        o[2 * i + 1] = t[i] >> 8;
    }
}
function unpack25519(o, n) {
    for (let i = 0; i < 16; i++) {
        o[i] = n[2 * i] + (n[2 * i + 1] << 8);
    }
    o[15] &= 0x7fff;
}
function add(o, a, b) {
    for (let i = 0; i < 16; i++) {
        o[i] = a[i] + b[i];
    }
}
function sub(o, a, b) {
    for (let i = 0; i < 16; i++) {
        o[i] = a[i] - b[i];
    }
}
function mul(o, a, b) {
    let v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
    v = a[0];
    t0 += v * b0;
    t1 += v * b1;
    t2 += v * b2;
    t3 += v * b3;
    t4 += v * b4;
    t5 += v * b5;
    t6 += v * b6;
    t7 += v * b7;
    t8 += v * b8;
    t9 += v * b9;
    t10 += v * b10;
    t11 += v * b11;
    t12 += v * b12;
    t13 += v * b13;
    t14 += v * b14;
    t15 += v * b15;
    v = a[1];
    t1 += v * b0;
    t2 += v * b1;
    t3 += v * b2;
    t4 += v * b3;
    t5 += v * b4;
    t6 += v * b5;
    t7 += v * b6;
    t8 += v * b7;
    t9 += v * b8;
    t10 += v * b9;
    t11 += v * b10;
    t12 += v * b11;
    t13 += v * b12;
    t14 += v * b13;
    t15 += v * b14;
    t16 += v * b15;
    v = a[2];
    t2 += v * b0;
    t3 += v * b1;
    t4 += v * b2;
    t5 += v * b3;
    t6 += v * b4;
    t7 += v * b5;
    t8 += v * b6;
    t9 += v * b7;
    t10 += v * b8;
    t11 += v * b9;
    t12 += v * b10;
    t13 += v * b11;
    t14 += v * b12;
    t15 += v * b13;
    t16 += v * b14;
    t17 += v * b15;
    v = a[3];
    t3 += v * b0;
    t4 += v * b1;
    t5 += v * b2;
    t6 += v * b3;
    t7 += v * b4;
    t8 += v * b5;
    t9 += v * b6;
    t10 += v * b7;
    t11 += v * b8;
    t12 += v * b9;
    t13 += v * b10;
    t14 += v * b11;
    t15 += v * b12;
    t16 += v * b13;
    t17 += v * b14;
    t18 += v * b15;
    v = a[4];
    t4 += v * b0;
    t5 += v * b1;
    t6 += v * b2;
    t7 += v * b3;
    t8 += v * b4;
    t9 += v * b5;
    t10 += v * b6;
    t11 += v * b7;
    t12 += v * b8;
    t13 += v * b9;
    t14 += v * b10;
    t15 += v * b11;
    t16 += v * b12;
    t17 += v * b13;
    t18 += v * b14;
    t19 += v * b15;
    v = a[5];
    t5 += v * b0;
    t6 += v * b1;
    t7 += v * b2;
    t8 += v * b3;
    t9 += v * b4;
    t10 += v * b5;
    t11 += v * b6;
    t12 += v * b7;
    t13 += v * b8;
    t14 += v * b9;
    t15 += v * b10;
    t16 += v * b11;
    t17 += v * b12;
    t18 += v * b13;
    t19 += v * b14;
    t20 += v * b15;
    v = a[6];
    t6 += v * b0;
    t7 += v * b1;
    t8 += v * b2;
    t9 += v * b3;
    t10 += v * b4;
    t11 += v * b5;
    t12 += v * b6;
    t13 += v * b7;
    t14 += v * b8;
    t15 += v * b9;
    t16 += v * b10;
    t17 += v * b11;
    t18 += v * b12;
    t19 += v * b13;
    t20 += v * b14;
    t21 += v * b15;
    v = a[7];
    t7 += v * b0;
    t8 += v * b1;
    t9 += v * b2;
    t10 += v * b3;
    t11 += v * b4;
    t12 += v * b5;
    t13 += v * b6;
    t14 += v * b7;
    t15 += v * b8;
    t16 += v * b9;
    t17 += v * b10;
    t18 += v * b11;
    t19 += v * b12;
    t20 += v * b13;
    t21 += v * b14;
    t22 += v * b15;
    v = a[8];
    t8 += v * b0;
    t9 += v * b1;
    t10 += v * b2;
    t11 += v * b3;
    t12 += v * b4;
    t13 += v * b5;
    t14 += v * b6;
    t15 += v * b7;
    t16 += v * b8;
    t17 += v * b9;
    t18 += v * b10;
    t19 += v * b11;
    t20 += v * b12;
    t21 += v * b13;
    t22 += v * b14;
    t23 += v * b15;
    v = a[9];
    t9 += v * b0;
    t10 += v * b1;
    t11 += v * b2;
    t12 += v * b3;
    t13 += v * b4;
    t14 += v * b5;
    t15 += v * b6;
    t16 += v * b7;
    t17 += v * b8;
    t18 += v * b9;
    t19 += v * b10;
    t20 += v * b11;
    t21 += v * b12;
    t22 += v * b13;
    t23 += v * b14;
    t24 += v * b15;
    v = a[10];
    t10 += v * b0;
    t11 += v * b1;
    t12 += v * b2;
    t13 += v * b3;
    t14 += v * b4;
    t15 += v * b5;
    t16 += v * b6;
    t17 += v * b7;
    t18 += v * b8;
    t19 += v * b9;
    t20 += v * b10;
    t21 += v * b11;
    t22 += v * b12;
    t23 += v * b13;
    t24 += v * b14;
    t25 += v * b15;
    v = a[11];
    t11 += v * b0;
    t12 += v * b1;
    t13 += v * b2;
    t14 += v * b3;
    t15 += v * b4;
    t16 += v * b5;
    t17 += v * b6;
    t18 += v * b7;
    t19 += v * b8;
    t20 += v * b9;
    t21 += v * b10;
    t22 += v * b11;
    t23 += v * b12;
    t24 += v * b13;
    t25 += v * b14;
    t26 += v * b15;
    v = a[12];
    t12 += v * b0;
    t13 += v * b1;
    t14 += v * b2;
    t15 += v * b3;
    t16 += v * b4;
    t17 += v * b5;
    t18 += v * b6;
    t19 += v * b7;
    t20 += v * b8;
    t21 += v * b9;
    t22 += v * b10;
    t23 += v * b11;
    t24 += v * b12;
    t25 += v * b13;
    t26 += v * b14;
    t27 += v * b15;
    v = a[13];
    t13 += v * b0;
    t14 += v * b1;
    t15 += v * b2;
    t16 += v * b3;
    t17 += v * b4;
    t18 += v * b5;
    t19 += v * b6;
    t20 += v * b7;
    t21 += v * b8;
    t22 += v * b9;
    t23 += v * b10;
    t24 += v * b11;
    t25 += v * b12;
    t26 += v * b13;
    t27 += v * b14;
    t28 += v * b15;
    v = a[14];
    t14 += v * b0;
    t15 += v * b1;
    t16 += v * b2;
    t17 += v * b3;
    t18 += v * b4;
    t19 += v * b5;
    t20 += v * b6;
    t21 += v * b7;
    t22 += v * b8;
    t23 += v * b9;
    t24 += v * b10;
    t25 += v * b11;
    t26 += v * b12;
    t27 += v * b13;
    t28 += v * b14;
    t29 += v * b15;
    v = a[15];
    t15 += v * b0;
    t16 += v * b1;
    t17 += v * b2;
    t18 += v * b3;
    t19 += v * b4;
    t20 += v * b5;
    t21 += v * b6;
    t22 += v * b7;
    t23 += v * b8;
    t24 += v * b9;
    t25 += v * b10;
    t26 += v * b11;
    t27 += v * b12;
    t28 += v * b13;
    t29 += v * b14;
    t30 += v * b15;
    t0 += 38 * t16;
    t1 += 38 * t17;
    t2 += 38 * t18;
    t3 += 38 * t19;
    t4 += 38 * t20;
    t5 += 38 * t21;
    t6 += 38 * t22;
    t7 += 38 * t23;
    t8 += 38 * t24;
    t9 += 38 * t25;
    t10 += 38 * t26;
    t11 += 38 * t27;
    t12 += 38 * t28;
    t13 += 38 * t29;
    t14 += 38 * t30;
    // t15 left as is
    // first car
    c = 1;
    v = t0 + c + 65535;
    c = Math.floor(v / 65536);
    t0 = v - c * 65536;
    v = t1 + c + 65535;
    c = Math.floor(v / 65536);
    t1 = v - c * 65536;
    v = t2 + c + 65535;
    c = Math.floor(v / 65536);
    t2 = v - c * 65536;
    v = t3 + c + 65535;
    c = Math.floor(v / 65536);
    t3 = v - c * 65536;
    v = t4 + c + 65535;
    c = Math.floor(v / 65536);
    t4 = v - c * 65536;
    v = t5 + c + 65535;
    c = Math.floor(v / 65536);
    t5 = v - c * 65536;
    v = t6 + c + 65535;
    c = Math.floor(v / 65536);
    t6 = v - c * 65536;
    v = t7 + c + 65535;
    c = Math.floor(v / 65536);
    t7 = v - c * 65536;
    v = t8 + c + 65535;
    c = Math.floor(v / 65536);
    t8 = v - c * 65536;
    v = t9 + c + 65535;
    c = Math.floor(v / 65536);
    t9 = v - c * 65536;
    v = t10 + c + 65535;
    c = Math.floor(v / 65536);
    t10 = v - c * 65536;
    v = t11 + c + 65535;
    c = Math.floor(v / 65536);
    t11 = v - c * 65536;
    v = t12 + c + 65535;
    c = Math.floor(v / 65536);
    t12 = v - c * 65536;
    v = t13 + c + 65535;
    c = Math.floor(v / 65536);
    t13 = v - c * 65536;
    v = t14 + c + 65535;
    c = Math.floor(v / 65536);
    t14 = v - c * 65536;
    v = t15 + c + 65535;
    c = Math.floor(v / 65536);
    t15 = v - c * 65536;
    t0 += c - 1 + 37 * (c - 1);
    // second car
    c = 1;
    v = t0 + c + 65535;
    c = Math.floor(v / 65536);
    t0 = v - c * 65536;
    v = t1 + c + 65535;
    c = Math.floor(v / 65536);
    t1 = v - c * 65536;
    v = t2 + c + 65535;
    c = Math.floor(v / 65536);
    t2 = v - c * 65536;
    v = t3 + c + 65535;
    c = Math.floor(v / 65536);
    t3 = v - c * 65536;
    v = t4 + c + 65535;
    c = Math.floor(v / 65536);
    t4 = v - c * 65536;
    v = t5 + c + 65535;
    c = Math.floor(v / 65536);
    t5 = v - c * 65536;
    v = t6 + c + 65535;
    c = Math.floor(v / 65536);
    t6 = v - c * 65536;
    v = t7 + c + 65535;
    c = Math.floor(v / 65536);
    t7 = v - c * 65536;
    v = t8 + c + 65535;
    c = Math.floor(v / 65536);
    t8 = v - c * 65536;
    v = t9 + c + 65535;
    c = Math.floor(v / 65536);
    t9 = v - c * 65536;
    v = t10 + c + 65535;
    c = Math.floor(v / 65536);
    t10 = v - c * 65536;
    v = t11 + c + 65535;
    c = Math.floor(v / 65536);
    t11 = v - c * 65536;
    v = t12 + c + 65535;
    c = Math.floor(v / 65536);
    t12 = v - c * 65536;
    v = t13 + c + 65535;
    c = Math.floor(v / 65536);
    t13 = v - c * 65536;
    v = t14 + c + 65535;
    c = Math.floor(v / 65536);
    t14 = v - c * 65536;
    v = t15 + c + 65535;
    c = Math.floor(v / 65536);
    t15 = v - c * 65536;
    t0 += c - 1 + 37 * (c - 1);
    o[0] = t0;
    o[1] = t1;
    o[2] = t2;
    o[3] = t3;
    o[4] = t4;
    o[5] = t5;
    o[6] = t6;
    o[7] = t7;
    o[8] = t8;
    o[9] = t9;
    o[10] = t10;
    o[11] = t11;
    o[12] = t12;
    o[13] = t13;
    o[14] = t14;
    o[15] = t15;
}
function square(o, a) {
    mul(o, a, a);
}
function inv25519(o, inp) {
    const c = gf();
    for (let i = 0; i < 16; i++) {
        c[i] = inp[i];
    }
    for (let i = 253; i >= 0; i--) {
        square(c, c);
        if (i !== 2 && i !== 4) {
            mul(c, c, inp);
        }
    }
    for (let i = 0; i < 16; i++) {
        o[i] = c[i];
    }
}
function scalarMult(n, p) {
    const z = new Uint8Array(32);
    const x = new Float64Array(80);
    const a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
    for (let i = 0; i < 31; i++) {
        z[i] = n[i];
    }
    z[31] = (n[31] & 127) | 64;
    z[0] &= 248;
    unpack25519(x, p);
    for (let i = 0; i < 16; i++) {
        b[i] = x[i];
    }
    a[0] = d[0] = 1;
    for (let i = 254; i >= 0; --i) {
        const r = (z[i >>> 3] >>> (i & 7)) & 1;
        sel25519(a, b, r);
        sel25519(c, d, r);
        add(e, a, c);
        sub(a, a, c);
        add(c, b, d);
        sub(b, b, d);
        square(d, e);
        square(f, a);
        mul(a, c, a);
        mul(c, b, e);
        add(e, a, c);
        sub(a, a, c);
        square(b, a);
        sub(c, d, f);
        mul(a, c, _121665);
        add(a, a, d);
        mul(c, c, a);
        mul(a, d, f);
        mul(d, b, x);
        square(b, e);
        sel25519(a, b, r);
        sel25519(c, d, r);
    }
    for (let i = 0; i < 16; i++) {
        x[i + 16] = a[i];
        x[i + 32] = c[i];
        x[i + 48] = b[i];
        x[i + 64] = d[i];
    }
    const x32 = x.subarray(32);
    const x16 = x.subarray(16);
    inv25519(x32, x32);
    mul(x16, x16, x32);
    const q = new Uint8Array(32);
    pack25519(q, x16);
    return q;
}
__webpack_unused_export__ = scalarMult;
function scalarMultBase(n) {
    return scalarMult(n, _9);
}
__webpack_unused_export__ = scalarMultBase;
function generateKeyPairFromSeed(seed) {
    if (seed.length !== exports.KS) {
        throw new Error(`x25519: seed must be ${exports.KS} bytes`);
    }
    const secretKey = new Uint8Array(seed);
    const publicKey = scalarMultBase(secretKey);
    return {
        publicKey,
        secretKey
    };
}
__webpack_unused_export__ = generateKeyPairFromSeed;
function generateKeyPair(prng) {
    const seed = (0, random_1.randomBytes)(32, prng);
    const result = generateKeyPairFromSeed(seed);
    (0, wipe_1.wipe)(seed);
    return result;
}
exports.Au = generateKeyPair;
/**
 * Returns a shared key between our secret key and a peer's public key.
 *
 * Throws an error if the given keys are of wrong length.
 *
 * If rejectZero is true throws if the calculated shared key is all-zero.
 * From RFC 7748:
 *
 * > Protocol designers using Diffie-Hellman over the curves defined in
 * > this document must not assume "contributory behavior".  Specially,
 * > contributory behavior means that both parties' private keys
 * > contribute to the resulting shared key.  Since curve25519 and
 * > curve448 have cofactors of 8 and 4 (respectively), an input point of
 * > small order will eliminate any contribution from the other party's
 * > private key.  This situation can be detected by checking for the all-
 * > zero output, which implementations MAY do, as specified in Section 6.
 * > However, a large number of existing implementations do not do this.
 *
 * IMPORTANT: the returned key is a raw result of scalar multiplication.
 * To use it as a key material, hash it with a cryptographic hash function.
 */
function sharedKey(mySecretKey, theirPublicKey, rejectZero = false) {
    if (mySecretKey.length !== exports.kz) {
        throw new Error("X25519: incorrect secret key length");
    }
    if (theirPublicKey.length !== exports.kz) {
        throw new Error("X25519: incorrect public key length");
    }
    const result = scalarMult(mySecretKey, theirPublicKey);
    if (rejectZero) {
        let zeros = 0;
        for (let i = 0; i < result.length; i++) {
            zeros |= result[i];
        }
        if (zeros === 0) {
            throw new Error("X25519: invalid shared key");
        }
    }
    return result;
}
exports.gi = sharedKey;


/***/ }),

/***/ 21945:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isBrowserCryptoAvailable = exports.getSubtleCrypto = exports.getBrowerCrypto = void 0;
function getBrowerCrypto() {
    return (__webpack_require__.g === null || __webpack_require__.g === void 0 ? void 0 : __webpack_require__.g.crypto) || (__webpack_require__.g === null || __webpack_require__.g === void 0 ? void 0 : __webpack_require__.g.msCrypto) || {};
}
exports.getBrowerCrypto = getBrowerCrypto;
function getSubtleCrypto() {
    const browserCrypto = getBrowerCrypto();
    return browserCrypto.subtle || browserCrypto.webkitSubtle;
}
exports.getSubtleCrypto = getSubtleCrypto;
function isBrowserCryptoAvailable() {
    return !!getBrowerCrypto() && !!getSubtleCrypto();
}
exports.isBrowserCryptoAvailable = isBrowserCryptoAvailable;


/***/ }),

/***/ 81513:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isBrowser = exports.isNode = exports.isReactNative = void 0;
function isReactNative() {
    return (typeof document === "undefined" &&
        typeof navigator !== "undefined" &&
        navigator.product === "ReactNative");
}
exports.isReactNative = isReactNative;
function isNode() {
    return (typeof process !== "undefined" &&
        typeof process.versions !== "undefined" &&
        typeof process.versions.node !== "undefined");
}
exports.isNode = isNode;
function isBrowser() {
    return !isReactNative() && !isNode();
}
exports.isBrowser = isBrowser;


/***/ }),

/***/ 82812:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(69915);
tslib_1.__exportStar(__webpack_require__(21945), exports);
tslib_1.__exportStar(__webpack_require__(81513), exports);


/***/ }),

/***/ 58032:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   q: () => (/* binding */ IEvents)
/* harmony export */ });
class IEvents {
}


/***/ }),

/***/ 61123:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IEvents: () => (/* reexport safe */ _events__WEBPACK_IMPORTED_MODULE_0__.q)
/* harmony export */ });
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58032);



/***/ }),

/***/ 59694:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HEARTBEAT_EVENTS = exports.HEARTBEAT_INTERVAL = void 0;
const time_1 = __webpack_require__(24041);
exports.HEARTBEAT_INTERVAL = time_1.FIVE_SECONDS;
exports.HEARTBEAT_EVENTS = {
    pulse: "heartbeat_pulse",
};


/***/ }),

/***/ 4602:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(69915);
tslib_1.__exportStar(__webpack_require__(59694), exports);


/***/ }),

/***/ 55761:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HeartBeat = void 0;
const tslib_1 = __webpack_require__(69915);
const events_1 = __webpack_require__(58470);
const time_1 = __webpack_require__(24041);
const types_1 = __webpack_require__(97821);
const constants_1 = __webpack_require__(4602);
class HeartBeat extends types_1.IHeartBeat {
    constructor(opts) {
        super(opts);
        this.events = new events_1.EventEmitter();
        this.interval = constants_1.HEARTBEAT_INTERVAL;
        this.interval = (opts === null || opts === void 0 ? void 0 : opts.interval) || constants_1.HEARTBEAT_INTERVAL;
    }
    static init(opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const heartbeat = new HeartBeat(opts);
            yield heartbeat.init();
            return heartbeat;
        });
    }
    init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.initialize();
        });
    }
    stop() {
        clearInterval(this.intervalRef);
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    initialize() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.intervalRef = setInterval(() => this.pulse(), time_1.toMiliseconds(this.interval));
        });
    }
    pulse() {
        this.events.emit(constants_1.HEARTBEAT_EVENTS.pulse);
    }
}
exports.HeartBeat = HeartBeat;


/***/ }),

/***/ 67754:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(69915);
tslib_1.__exportStar(__webpack_require__(55761), exports);
tslib_1.__exportStar(__webpack_require__(97821), exports);
tslib_1.__exportStar(__webpack_require__(4602), exports);


/***/ }),

/***/ 67999:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IHeartBeat = void 0;
const events_1 = __webpack_require__(61123);
class IHeartBeat extends events_1.IEvents {
    constructor(opts) {
        super();
    }
}
exports.IHeartBeat = IHeartBeat;


/***/ }),

/***/ 97821:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(69915);
tslib_1.__exportStar(__webpack_require__(67999), exports);


/***/ }),

/***/ 95031:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  r: () => (/* reexport */ JsonRpcProvider)
});

// UNUSED EXPORTS: default

// EXTERNAL MODULE: ./node_modules/.pnpm/events@3.3.0/node_modules/events/events.js
var events = __webpack_require__(58470);
// EXTERNAL MODULE: ./node_modules/.pnpm/@walletconnect+jsonrpc-utils@1.0.8/node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
var esm = __webpack_require__(35673);
;// CONCATENATED MODULE: ./node_modules/.pnpm/@walletconnect+jsonrpc-provider@1.0.13/node_modules/@walletconnect/jsonrpc-provider/dist/esm/provider.js


class JsonRpcProvider extends esm.IJsonRpcProvider {
    constructor(connection) {
        super(connection);
        this.events = new events.EventEmitter();
        this.hasRegisteredEventListeners = false;
        this.connection = this.setConnection(connection);
        if (this.connection.connected) {
            this.registerEventListeners();
        }
    }
    async connect(connection = this.connection) {
        await this.open(connection);
    }
    async disconnect() {
        await this.close();
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    async request(request, context) {
        return this.requestStrict((0,esm.formatJsonRpcRequest)(request.method, request.params || [], request.id || (0,esm.getBigIntRpcId)().toString()), context);
    }
    async requestStrict(request, context) {
        return new Promise(async (resolve, reject) => {
            if (!this.connection.connected) {
                try {
                    await this.open();
                }
                catch (e) {
                    reject(e);
                }
            }
            this.events.on(`${request.id}`, response => {
                if ((0,esm.isJsonRpcError)(response)) {
                    reject(response.error);
                }
                else {
                    resolve(response.result);
                }
            });
            try {
                await this.connection.send(request, context);
            }
            catch (e) {
                reject(e);
            }
        });
    }
    setConnection(connection = this.connection) {
        return connection;
    }
    onPayload(payload) {
        this.events.emit("payload", payload);
        if ((0,esm.isJsonRpcResponse)(payload)) {
            this.events.emit(`${payload.id}`, payload);
        }
        else {
            this.events.emit("message", {
                type: payload.method,
                data: payload.params,
            });
        }
    }
    onClose(event) {
        if (event && event.code === 3000) {
            this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${event.code} ${event.reason ? `(${event.reason})` : ""}`));
        }
        this.events.emit("disconnect");
    }
    async open(connection = this.connection) {
        if (this.connection === connection && this.connection.connected)
            return;
        if (this.connection.connected)
            this.close();
        if (typeof connection === "string") {
            await this.connection.open(connection);
            connection = this.connection;
        }
        this.connection = this.setConnection(connection);
        await this.connection.open();
        this.registerEventListeners();
        this.events.emit("connect");
    }
    async close() {
        await this.connection.close();
    }
    registerEventListeners() {
        if (this.hasRegisteredEventListeners)
            return;
        this.connection.on("payload", (payload) => this.onPayload(payload));
        this.connection.on("close", (event) => this.onClose(event));
        this.connection.on("error", (error) => this.events.emit("error", error));
        this.connection.on("register_error", (error) => this.onClose());
        this.hasRegisteredEventListeners = true;
    }
}
/* harmony default export */ const provider = ((/* unused pure expression or super */ null && (JsonRpcProvider)));

;// CONCATENATED MODULE: ./node_modules/.pnpm/@walletconnect+jsonrpc-provider@1.0.13/node_modules/@walletconnect/jsonrpc-provider/dist/esm/index.js


/* harmony default export */ const dist_esm = ((/* unused pure expression or super */ null && (Provider)));


/***/ }),

/***/ 99865:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CA: () => (/* binding */ SERVER_ERROR),
/* harmony export */   JV: () => (/* binding */ DEFAULT_ERROR),
/* harmony export */   O4: () => (/* binding */ INTERNAL_ERROR),
/* harmony export */   dQ: () => (/* binding */ RESERVED_ERROR_CODES),
/* harmony export */   xK: () => (/* binding */ STANDARD_ERROR_MAP)
/* harmony export */ });
/* unused harmony exports PARSE_ERROR, INVALID_REQUEST, METHOD_NOT_FOUND, INVALID_PARAMS, SERVER_ERROR_CODE_RANGE */
const PARSE_ERROR = "PARSE_ERROR";
const INVALID_REQUEST = "INVALID_REQUEST";
const METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
const INVALID_PARAMS = "INVALID_PARAMS";
const INTERNAL_ERROR = "INTERNAL_ERROR";
const SERVER_ERROR = "SERVER_ERROR";
const RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603];
const SERVER_ERROR_CODE_RANGE = (/* unused pure expression or super */ null && ([-32000, -32099]));
const STANDARD_ERROR_MAP = {
    [PARSE_ERROR]: { code: -32700, message: "Parse error" },
    [INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
    [METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
    [INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
    [INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
    [SERVER_ERROR]: { code: -32000, message: "Server error" },
};
const DEFAULT_ERROR = SERVER_ERROR;


/***/ }),

/***/ 78736:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export isNodeJs */
/* harmony import */ var _walletconnect_environment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82812);
/* harmony import */ var _walletconnect_environment__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_walletconnect_environment__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (checked) */ if(__webpack_require__.o(_walletconnect_environment__WEBPACK_IMPORTED_MODULE_0__, "IJsonRpcProvider")) __webpack_require__.d(__webpack_exports__, { IJsonRpcProvider: function() { return _walletconnect_environment__WEBPACK_IMPORTED_MODULE_0__.IJsonRpcProvider; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_walletconnect_environment__WEBPACK_IMPORTED_MODULE_0__, "formatJsonRpcError")) __webpack_require__.d(__webpack_exports__, { formatJsonRpcError: function() { return _walletconnect_environment__WEBPACK_IMPORTED_MODULE_0__.formatJsonRpcError; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_walletconnect_environment__WEBPACK_IMPORTED_MODULE_0__, "formatJsonRpcRequest")) __webpack_require__.d(__webpack_exports__, { formatJsonRpcRequest: function() { return _walletconnect_environment__WEBPACK_IMPORTED_MODULE_0__.formatJsonRpcRequest; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_walletconnect_environment__WEBPACK_IMPORTED_MODULE_0__, "formatJsonRpcResult")) __webpack_require__.d(__webpack_exports__, { formatJsonRpcResult: function() { return _walletconnect_environment__WEBPACK_IMPORTED_MODULE_0__.formatJsonRpcResult; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_walletconnect_environment__WEBPACK_IMPORTED_MODULE_0__, "getBigIntRpcId")) __webpack_require__.d(__webpack_exports__, { getBigIntRpcId: function() { return _walletconnect_environment__WEBPACK_IMPORTED_MODULE_0__.getBigIntRpcId; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_walletconnect_environment__WEBPACK_IMPORTED_MODULE_0__, "isJsonRpcError")) __webpack_require__.d(__webpack_exports__, { isJsonRpcError: function() { return _walletconnect_environment__WEBPACK_IMPORTED_MODULE_0__.isJsonRpcError; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_walletconnect_environment__WEBPACK_IMPORTED_MODULE_0__, "isJsonRpcRequest")) __webpack_require__.d(__webpack_exports__, { isJsonRpcRequest: function() { return _walletconnect_environment__WEBPACK_IMPORTED_MODULE_0__.isJsonRpcRequest; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_walletconnect_environment__WEBPACK_IMPORTED_MODULE_0__, "isJsonRpcResponse")) __webpack_require__.d(__webpack_exports__, { isJsonRpcResponse: function() { return _walletconnect_environment__WEBPACK_IMPORTED_MODULE_0__.isJsonRpcResponse; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_walletconnect_environment__WEBPACK_IMPORTED_MODULE_0__, "isJsonRpcResult")) __webpack_require__.d(__webpack_exports__, { isJsonRpcResult: function() { return _walletconnect_environment__WEBPACK_IMPORTED_MODULE_0__.isJsonRpcResult; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_walletconnect_environment__WEBPACK_IMPORTED_MODULE_0__, "isLocalhostUrl")) __webpack_require__.d(__webpack_exports__, { isLocalhostUrl: function() { return _walletconnect_environment__WEBPACK_IMPORTED_MODULE_0__.isLocalhostUrl; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_walletconnect_environment__WEBPACK_IMPORTED_MODULE_0__, "isReactNative")) __webpack_require__.d(__webpack_exports__, { isReactNative: function() { return _walletconnect_environment__WEBPACK_IMPORTED_MODULE_0__.isReactNative; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_walletconnect_environment__WEBPACK_IMPORTED_MODULE_0__, "isWsUrl")) __webpack_require__.d(__webpack_exports__, { isWsUrl: function() { return _walletconnect_environment__WEBPACK_IMPORTED_MODULE_0__.isWsUrl; } });

const isNodeJs = (/* unused pure expression or super */ null && (isNode));



/***/ }),

/***/ 2953:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CX: () => (/* binding */ parseConnectionError),
/* harmony export */   L2: () => (/* binding */ getErrorByCode),
/* harmony export */   by: () => (/* binding */ getError),
/* harmony export */   i5: () => (/* binding */ isReservedErrorCode)
/* harmony export */ });
/* unused harmony exports isServerErrorCode, isValidErrorCode, validateJsonRpcError */
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(99865);

function isServerErrorCode(code) {
    return code <= SERVER_ERROR_CODE_RANGE[0] && code >= SERVER_ERROR_CODE_RANGE[1];
}
function isReservedErrorCode(code) {
    return _constants__WEBPACK_IMPORTED_MODULE_0__/* .RESERVED_ERROR_CODES */ .dQ.includes(code);
}
function isValidErrorCode(code) {
    return typeof code === "number";
}
function getError(type) {
    if (!Object.keys(_constants__WEBPACK_IMPORTED_MODULE_0__/* .STANDARD_ERROR_MAP */ .xK).includes(type)) {
        return _constants__WEBPACK_IMPORTED_MODULE_0__/* .STANDARD_ERROR_MAP */ .xK[_constants__WEBPACK_IMPORTED_MODULE_0__/* .DEFAULT_ERROR */ .JV];
    }
    return _constants__WEBPACK_IMPORTED_MODULE_0__/* .STANDARD_ERROR_MAP */ .xK[type];
}
function getErrorByCode(code) {
    const match = Object.values(_constants__WEBPACK_IMPORTED_MODULE_0__/* .STANDARD_ERROR_MAP */ .xK).find(e => e.code === code);
    if (!match) {
        return _constants__WEBPACK_IMPORTED_MODULE_0__/* .STANDARD_ERROR_MAP */ .xK[_constants__WEBPACK_IMPORTED_MODULE_0__/* .DEFAULT_ERROR */ .JV];
    }
    return match;
}
function validateJsonRpcError(response) {
    if (typeof response.error.code === "undefined") {
        return { valid: false, error: "Missing code for JSON-RPC error" };
    }
    if (typeof response.error.message === "undefined") {
        return { valid: false, error: "Missing message for JSON-RPC error" };
    }
    if (!isValidErrorCode(response.error.code)) {
        return {
            valid: false,
            error: `Invalid error code type for JSON-RPC: ${response.error.code}`,
        };
    }
    if (isReservedErrorCode(response.error.code)) {
        const error = getErrorByCode(response.error.code);
        if (error.message !== STANDARD_ERROR_MAP[DEFAULT_ERROR].message &&
            response.error.message === error.message) {
            return {
                valid: false,
                error: `Invalid error code message for JSON-RPC: ${response.error.code}`,
            };
        }
    }
    return { valid: true };
}
function parseConnectionError(e, url, type) {
    return e.message.includes("getaddrinfo ENOTFOUND") || e.message.includes("connect ECONNREFUSED")
        ? new Error(`Unavailable ${type} RPC url at ${url}`)
        : e;
}


/***/ }),

/***/ 41068:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CS: () => (/* binding */ getBigIntRpcId),
/* harmony export */   RI: () => (/* binding */ formatJsonRpcError),
/* harmony export */   sT: () => (/* binding */ formatJsonRpcRequest),
/* harmony export */   tm: () => (/* binding */ formatJsonRpcResult)
/* harmony export */ });
/* unused harmony exports payloadId, formatErrorMessage */
/* harmony import */ var _error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2953);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99865);


function payloadId(entropy = 3) {
    const date = Date.now() * Math.pow(10, entropy);
    const extra = Math.floor(Math.random() * Math.pow(10, entropy));
    return date + extra;
}
function getBigIntRpcId(entropy = 6) {
    return BigInt(payloadId(entropy));
}
function formatJsonRpcRequest(method, params, id) {
    return {
        id: id || payloadId(),
        jsonrpc: "2.0",
        method,
        params,
    };
}
function formatJsonRpcResult(id, result) {
    return {
        id,
        jsonrpc: "2.0",
        result,
    };
}
function formatJsonRpcError(id, error, data) {
    return {
        id,
        jsonrpc: "2.0",
        error: formatErrorMessage(error, data),
    };
}
function formatErrorMessage(error, data) {
    if (typeof error === "undefined") {
        return (0,_error__WEBPACK_IMPORTED_MODULE_0__/* .getError */ .by)(_constants__WEBPACK_IMPORTED_MODULE_1__/* .INTERNAL_ERROR */ .O4);
    }
    if (typeof error === "string") {
        error = Object.assign(Object.assign({}, (0,_error__WEBPACK_IMPORTED_MODULE_0__/* .getError */ .by)(_constants__WEBPACK_IMPORTED_MODULE_1__/* .SERVER_ERROR */ .CA)), { message: error });
    }
    if (typeof data !== "undefined") {
        error.data = data;
    }
    if ((0,_error__WEBPACK_IMPORTED_MODULE_0__/* .isReservedErrorCode */ .i5)(error.code)) {
        error = (0,_error__WEBPACK_IMPORTED_MODULE_0__/* .getErrorByCode */ .L2)(error.code);
    }
    return error;
}


/***/ }),

/***/ 35673:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IJsonRpcProvider: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_4__.x0),
/* harmony export */   formatJsonRpcError: () => (/* reexport safe */ _format__WEBPACK_IMPORTED_MODULE_3__.RI),
/* harmony export */   formatJsonRpcRequest: () => (/* reexport safe */ _format__WEBPACK_IMPORTED_MODULE_3__.sT),
/* harmony export */   formatJsonRpcResult: () => (/* reexport safe */ _format__WEBPACK_IMPORTED_MODULE_3__.tm),
/* harmony export */   getBigIntRpcId: () => (/* reexport safe */ _format__WEBPACK_IMPORTED_MODULE_3__.CS),
/* harmony export */   isJsonRpcError: () => (/* reexport safe */ _validators__WEBPACK_IMPORTED_MODULE_6__.jg),
/* harmony export */   isJsonRpcRequest: () => (/* reexport safe */ _validators__WEBPACK_IMPORTED_MODULE_6__.DW),
/* harmony export */   isJsonRpcResponse: () => (/* reexport safe */ _validators__WEBPACK_IMPORTED_MODULE_6__.u),
/* harmony export */   isJsonRpcResult: () => (/* reexport safe */ _validators__WEBPACK_IMPORTED_MODULE_6__.k4),
/* harmony export */   isLocalhostUrl: () => (/* reexport safe */ _url__WEBPACK_IMPORTED_MODULE_5__.JF),
/* harmony export */   isWsUrl: () => (/* reexport safe */ _url__WEBPACK_IMPORTED_MODULE_5__.UZ),
/* harmony export */   parseConnectionError: () => (/* reexport safe */ _error__WEBPACK_IMPORTED_MODULE_1__.CX)
/* harmony export */ });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(99865);
/* harmony import */ var _error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2953);
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(78736);
/* harmony reexport (checked) */ if(__webpack_require__.o(_env__WEBPACK_IMPORTED_MODULE_2__, "IJsonRpcProvider")) __webpack_require__.d(__webpack_exports__, { IJsonRpcProvider: function() { return _env__WEBPACK_IMPORTED_MODULE_2__.IJsonRpcProvider; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_env__WEBPACK_IMPORTED_MODULE_2__, "formatJsonRpcError")) __webpack_require__.d(__webpack_exports__, { formatJsonRpcError: function() { return _env__WEBPACK_IMPORTED_MODULE_2__.formatJsonRpcError; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_env__WEBPACK_IMPORTED_MODULE_2__, "formatJsonRpcRequest")) __webpack_require__.d(__webpack_exports__, { formatJsonRpcRequest: function() { return _env__WEBPACK_IMPORTED_MODULE_2__.formatJsonRpcRequest; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_env__WEBPACK_IMPORTED_MODULE_2__, "formatJsonRpcResult")) __webpack_require__.d(__webpack_exports__, { formatJsonRpcResult: function() { return _env__WEBPACK_IMPORTED_MODULE_2__.formatJsonRpcResult; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_env__WEBPACK_IMPORTED_MODULE_2__, "getBigIntRpcId")) __webpack_require__.d(__webpack_exports__, { getBigIntRpcId: function() { return _env__WEBPACK_IMPORTED_MODULE_2__.getBigIntRpcId; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_env__WEBPACK_IMPORTED_MODULE_2__, "isJsonRpcError")) __webpack_require__.d(__webpack_exports__, { isJsonRpcError: function() { return _env__WEBPACK_IMPORTED_MODULE_2__.isJsonRpcError; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_env__WEBPACK_IMPORTED_MODULE_2__, "isJsonRpcRequest")) __webpack_require__.d(__webpack_exports__, { isJsonRpcRequest: function() { return _env__WEBPACK_IMPORTED_MODULE_2__.isJsonRpcRequest; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_env__WEBPACK_IMPORTED_MODULE_2__, "isJsonRpcResponse")) __webpack_require__.d(__webpack_exports__, { isJsonRpcResponse: function() { return _env__WEBPACK_IMPORTED_MODULE_2__.isJsonRpcResponse; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_env__WEBPACK_IMPORTED_MODULE_2__, "isJsonRpcResult")) __webpack_require__.d(__webpack_exports__, { isJsonRpcResult: function() { return _env__WEBPACK_IMPORTED_MODULE_2__.isJsonRpcResult; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_env__WEBPACK_IMPORTED_MODULE_2__, "isLocalhostUrl")) __webpack_require__.d(__webpack_exports__, { isLocalhostUrl: function() { return _env__WEBPACK_IMPORTED_MODULE_2__.isLocalhostUrl; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_env__WEBPACK_IMPORTED_MODULE_2__, "isReactNative")) __webpack_require__.d(__webpack_exports__, { isReactNative: function() { return _env__WEBPACK_IMPORTED_MODULE_2__.isReactNative; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_env__WEBPACK_IMPORTED_MODULE_2__, "isWsUrl")) __webpack_require__.d(__webpack_exports__, { isWsUrl: function() { return _env__WEBPACK_IMPORTED_MODULE_2__.isWsUrl; } });
/* harmony import */ var _format__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(41068);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(20800);
/* harmony import */ var _url__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(61914);
/* harmony import */ var _validators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(95790);










/***/ }),

/***/ 20800:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  x0: () => (/* reexport */ IJsonRpcProvider)
});

// UNUSED EXPORTS: IBaseJsonRpcProvider, IEvents, IJsonRpcConnection

;// CONCATENATED MODULE: ./node_modules/.pnpm/@walletconnect+jsonrpc-types@1.0.3/node_modules/@walletconnect/jsonrpc-types/dist/esm/misc.js
class misc_IEvents {
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/@walletconnect+jsonrpc-types@1.0.3/node_modules/@walletconnect/jsonrpc-types/dist/esm/provider.js

class IJsonRpcConnection extends (/* unused pure expression or super */ null && (IEvents)) {
    constructor(opts) {
        super();
    }
}
class IBaseJsonRpcProvider extends misc_IEvents {
    constructor() {
        super();
    }
}
class IJsonRpcProvider extends IBaseJsonRpcProvider {
    constructor(connection) {
        super();
    }
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/@walletconnect+jsonrpc-types@1.0.3/node_modules/@walletconnect/jsonrpc-types/dist/esm/index.js





;// CONCATENATED MODULE: ./node_modules/.pnpm/@walletconnect+jsonrpc-utils@1.0.8/node_modules/@walletconnect/jsonrpc-utils/dist/esm/types.js



/***/ }),

/***/ 61914:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JF: () => (/* binding */ isLocalhostUrl),
/* harmony export */   UZ: () => (/* binding */ isWsUrl)
/* harmony export */ });
/* unused harmony export isHttpUrl */
const HTTP_REGEX = "^https?:";
const WS_REGEX = "^wss?:";
function getUrlProtocol(url) {
    const matches = url.match(new RegExp(/^\w+:/, "gi"));
    if (!matches || !matches.length)
        return;
    return matches[0];
}
function matchRegexProtocol(url, regex) {
    const protocol = getUrlProtocol(url);
    if (typeof protocol === "undefined")
        return false;
    return new RegExp(regex).test(protocol);
}
function isHttpUrl(url) {
    return matchRegexProtocol(url, HTTP_REGEX);
}
function isWsUrl(url) {
    return matchRegexProtocol(url, WS_REGEX);
}
function isLocalhostUrl(url) {
    return new RegExp("wss?://localhost(:d{2,5})?").test(url);
}


/***/ }),

/***/ 95790:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DW: () => (/* binding */ isJsonRpcRequest),
/* harmony export */   jg: () => (/* binding */ isJsonRpcError),
/* harmony export */   k4: () => (/* binding */ isJsonRpcResult),
/* harmony export */   u: () => (/* binding */ isJsonRpcResponse)
/* harmony export */ });
/* unused harmony exports isJsonRpcPayload, isJsonRpcValidationInvalid */
function isJsonRpcPayload(payload) {
    return (typeof payload === "object" &&
        "id" in payload &&
        "jsonrpc" in payload &&
        payload.jsonrpc === "2.0");
}
function isJsonRpcRequest(payload) {
    return isJsonRpcPayload(payload) && "method" in payload;
}
function isJsonRpcResponse(payload) {
    return isJsonRpcPayload(payload) && (isJsonRpcResult(payload) || isJsonRpcError(payload));
}
function isJsonRpcResult(payload) {
    return "result" in payload;
}
function isJsonRpcError(payload) {
    return "error" in payload;
}
function isJsonRpcValidationInvalid(validation) {
    return "error" in validation && validation.valid === false;
}


/***/ }),

/***/ 68134:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: () => (/* binding */ jsonrpc_ws_connection_dist_esm)
});

// UNUSED EXPORTS: WsConnection

// EXTERNAL MODULE: ./node_modules/.pnpm/events@3.3.0/node_modules/events/events.js
var events = __webpack_require__(58470);
// EXTERNAL MODULE: ./node_modules/.pnpm/@walletconnect+safe-json@1.0.2/node_modules/@walletconnect/safe-json/dist/esm/index.js
var esm = __webpack_require__(20927);
// EXTERNAL MODULE: ./node_modules/.pnpm/@walletconnect+jsonrpc-utils@1.0.8/node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
var dist_esm = __webpack_require__(35673);
;// CONCATENATED MODULE: ./node_modules/.pnpm/@walletconnect+jsonrpc-ws-connection@1.0.11/node_modules/@walletconnect/jsonrpc-ws-connection/dist/esm/ws.js



const EVENT_EMITTER_MAX_LISTENERS_DEFAULT = 10;
const resolveWebSocketImplementation = () => {
    if (typeof __webpack_require__.g !== "undefined" && typeof __webpack_require__.g.WebSocket !== "undefined") {
        return __webpack_require__.g.WebSocket;
    }
    if (typeof window !== "undefined" && typeof window.WebSocket !== "undefined") {
        return window.WebSocket;
    }
    return __webpack_require__(72675);
};
const isBrowser = () => typeof window !== "undefined";
const WS = resolveWebSocketImplementation();
class WsConnection {
    constructor(url) {
        this.url = url;
        this.events = new events.EventEmitter();
        this.registering = false;
        if (!(0,dist_esm.isWsUrl)(url)) {
            throw new Error(`Provided URL is not compatible with WebSocket connection: ${url}`);
        }
        this.url = url;
    }
    get connected() {
        return typeof this.socket !== "undefined";
    }
    get connecting() {
        return this.registering;
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    async open(url = this.url) {
        await this.register(url);
    }
    async close() {
        return new Promise((resolve, reject) => {
            if (typeof this.socket === "undefined") {
                reject(new Error("Connection already closed"));
                return;
            }
            this.socket.onclose = event => {
                this.onClose(event);
                resolve();
            };
            this.socket.close();
        });
    }
    async send(payload, context) {
        if (typeof this.socket === "undefined") {
            this.socket = await this.register();
        }
        try {
            this.socket.send((0,esm/* safeJsonStringify */.u)(payload));
        }
        catch (e) {
            this.onError(payload.id, e);
        }
    }
    register(url = this.url) {
        if (!(0,dist_esm.isWsUrl)(url)) {
            throw new Error(`Provided URL is not compatible with WebSocket connection: ${url}`);
        }
        if (this.registering) {
            const currentMaxListeners = this.events.getMaxListeners();
            if (this.events.listenerCount("register_error") >= currentMaxListeners ||
                this.events.listenerCount("open") >= currentMaxListeners) {
                this.events.setMaxListeners(currentMaxListeners + 1);
            }
            return new Promise((resolve, reject) => {
                this.events.once("register_error", error => {
                    this.resetMaxListeners();
                    reject(error);
                });
                this.events.once("open", () => {
                    this.resetMaxListeners();
                    if (typeof this.socket === "undefined") {
                        return reject(new Error("WebSocket connection is missing or invalid"));
                    }
                    resolve(this.socket);
                });
            });
        }
        this.url = url;
        this.registering = true;
        return new Promise((resolve, reject) => {
            const opts = !(0,dist_esm.isReactNative)() ? { rejectUnauthorized: !(0,dist_esm.isLocalhostUrl)(url) } : undefined;
            const socket = new WS(url, [], opts);
            if (isBrowser()) {
                socket.onerror = (event) => {
                    const errorEvent = event;
                    reject(this.emitError(errorEvent.error));
                };
            }
            else {
                socket.on("error", (errorEvent) => {
                    reject(this.emitError(errorEvent));
                });
            }
            socket.onopen = () => {
                this.onOpen(socket);
                resolve(socket);
            };
        });
    }
    onOpen(socket) {
        socket.onmessage = (event) => this.onPayload(event);
        socket.onclose = event => this.onClose(event);
        this.socket = socket;
        this.registering = false;
        this.events.emit("open");
    }
    onClose(event) {
        this.socket = undefined;
        this.registering = false;
        this.events.emit("close", event);
    }
    onPayload(e) {
        if (typeof e.data === "undefined")
            return;
        const payload = typeof e.data === "string" ? (0,esm/* safeJsonParse */.D)(e.data) : e.data;
        this.events.emit("payload", payload);
    }
    onError(id, e) {
        const error = this.parseError(e);
        const message = error.message || error.toString();
        const payload = (0,dist_esm.formatJsonRpcError)(id, message);
        this.events.emit("payload", payload);
    }
    parseError(e, url = this.url) {
        return (0,dist_esm.parseConnectionError)(e, url, "WS");
    }
    resetMaxListeners() {
        if (this.events.getMaxListeners() > EVENT_EMITTER_MAX_LISTENERS_DEFAULT) {
            this.events.setMaxListeners(EVENT_EMITTER_MAX_LISTENERS_DEFAULT);
        }
    }
    emitError(errorEvent) {
        const error = this.parseError(new Error((errorEvent === null || errorEvent === void 0 ? void 0 : errorEvent.message) || `WebSocket connection failed for URL: ${this.url}`));
        this.events.emit("register_error", error);
        return error;
    }
}
/* harmony default export */ const ws = (WsConnection);

;// CONCATENATED MODULE: ./node_modules/.pnpm/@walletconnect+jsonrpc-ws-connection@1.0.11/node_modules/@walletconnect/jsonrpc-ws-connection/dist/esm/index.js


/* harmony default export */ const jsonrpc_ws_connection_dist_esm = (ws);


/***/ }),

/***/ 3039:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
__webpack_unused_export__ = void 0;
const tslib_1 = __webpack_require__(69915);
const safe_json_utils_1 = __webpack_require__(77423);
const localStorage_1 = tslib_1.__importDefault(__webpack_require__(27322));
const shared_1 = __webpack_require__(7062);
class KeyValueStorage {
    constructor() {
        this.localStorage = localStorage_1.default;
    }
    getKeys() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return Object.keys(this.localStorage);
        });
    }
    getEntries() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return Object.entries(this.localStorage).map(shared_1.parseEntry);
        });
    }
    getItem(key) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const item = this.localStorage.getItem(key);
            if (item === null) {
                return undefined;
            }
            return safe_json_utils_1.safeJsonParse(item);
        });
    }
    setItem(key, value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.localStorage.setItem(key, safe_json_utils_1.safeJsonStringify(value));
        });
    }
    removeItem(key) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.localStorage.removeItem(key);
        });
    }
}
__webpack_unused_export__ = KeyValueStorage;
exports.ZP = KeyValueStorage;


/***/ }),

/***/ 27322:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

(function () {
    "use strict";
    let db;
    function LocalStorage() { }
    db = LocalStorage;
    db.prototype.getItem = function (key) {
        if (this.hasOwnProperty(key)) {
            return String(this[key]);
        }
        return null;
    };
    db.prototype.setItem = function (key, val) {
        this[key] = String(val);
    };
    db.prototype.removeItem = function (key) {
        delete this[key];
    };
    db.prototype.clear = function () {
        const self = this;
        Object.keys(self).forEach(function (key) {
            self[key] = undefined;
            delete self[key];
        });
    };
    db.prototype.key = function (i) {
        i = i || 0;
        return Object.keys(this)[i];
    };
    db.prototype.__defineGetter__("length", function () {
        return Object.keys(this).length;
    });
    if (typeof __webpack_require__.g !== "undefined" && __webpack_require__.g.localStorage) {
        module.exports = __webpack_require__.g.localStorage;
    }
    else if (typeof window !== "undefined" && window.localStorage) {
        module.exports = window.localStorage;
    }
    else {
        module.exports = new LocalStorage();
    }
})();


/***/ }),

/***/ 7062:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(69915);
tslib_1.__exportStar(__webpack_require__(56904), exports);
tslib_1.__exportStar(__webpack_require__(47360), exports);


/***/ }),

/***/ 56904:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IKeyValueStorage = void 0;
class IKeyValueStorage {
}
exports.IKeyValueStorage = IKeyValueStorage;


/***/ }),

/***/ 47360:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseEntry = void 0;
const safe_json_utils_1 = __webpack_require__(77423);
function parseEntry(entry) {
    var _a;
    return [entry[0], safe_json_utils_1.safeJsonParse((_a = entry[1]) !== null && _a !== void 0 ? _a : "")];
}
exports.parseEntry = parseEntry;


/***/ }),

/***/ 83487:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PINO_CUSTOM_CONTEXT_KEY = exports.PINO_LOGGER_DEFAULTS = void 0;
exports.PINO_LOGGER_DEFAULTS = {
    level: "info",
};
exports.PINO_CUSTOM_CONTEXT_KEY = "custom_context";


/***/ }),

/***/ 28803:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.pino = void 0;
const tslib_1 = __webpack_require__(69915);
const pino_1 = tslib_1.__importDefault(__webpack_require__(80839));
Object.defineProperty(exports, "pino", ({ enumerable: true, get: function () { return pino_1.default; } }));
tslib_1.__exportStar(__webpack_require__(83487), exports);
tslib_1.__exportStar(__webpack_require__(71776), exports);


/***/ }),

/***/ 71776:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateChildLogger = exports.formatChildLoggerContext = exports.getLoggerContext = exports.setBrowserLoggerContext = exports.getBrowserLoggerContext = exports.getDefaultLoggerOptions = void 0;
const constants_1 = __webpack_require__(83487);
function getDefaultLoggerOptions(opts) {
    return Object.assign(Object.assign({}, opts), { level: (opts === null || opts === void 0 ? void 0 : opts.level) || constants_1.PINO_LOGGER_DEFAULTS.level });
}
exports.getDefaultLoggerOptions = getDefaultLoggerOptions;
function getBrowserLoggerContext(logger, customContextKey = constants_1.PINO_CUSTOM_CONTEXT_KEY) {
    return logger[customContextKey] || "";
}
exports.getBrowserLoggerContext = getBrowserLoggerContext;
function setBrowserLoggerContext(logger, context, customContextKey = constants_1.PINO_CUSTOM_CONTEXT_KEY) {
    logger[customContextKey] = context;
    return logger;
}
exports.setBrowserLoggerContext = setBrowserLoggerContext;
function getLoggerContext(logger, customContextKey = constants_1.PINO_CUSTOM_CONTEXT_KEY) {
    let context = "";
    if (typeof logger.bindings === "undefined") {
        context = getBrowserLoggerContext(logger, customContextKey);
    }
    else {
        context = logger.bindings().context || "";
    }
    return context;
}
exports.getLoggerContext = getLoggerContext;
function formatChildLoggerContext(logger, childContext, customContextKey = constants_1.PINO_CUSTOM_CONTEXT_KEY) {
    const parentContext = getLoggerContext(logger, customContextKey);
    const context = parentContext.trim()
        ? `${parentContext}/${childContext}`
        : childContext;
    return context;
}
exports.formatChildLoggerContext = formatChildLoggerContext;
function generateChildLogger(logger, childContext, customContextKey = constants_1.PINO_CUSTOM_CONTEXT_KEY) {
    const context = formatChildLoggerContext(logger, childContext, customContextKey);
    const child = logger.child({ context });
    return setBrowserLoggerContext(child, context, customContextKey);
}
exports.generateChildLogger = generateChildLogger;


/***/ }),

/***/ 67287:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  RELAY_JSONRPC: () => (/* reexport */ RELAY_JSONRPC)
});

// UNUSED EXPORTS: isPublishMethod, isPublishParams, isPublishRequest, isSubscribeMethod, isSubscribeParams, isSubscribeRequest, isSubscriptionMethod, isSubscriptionParams, isSubscriptionRequest, isUnsubscribeMethod, isUnsubscribeParams, isUnsubscribeRequest, parsePublishRequest, parseSubscribeRequest, parseSubscriptionRequest, parseUnsubscribeRequest

// EXTERNAL MODULE: ./node_modules/.pnpm/@walletconnect+relay-api@1.0.9/node_modules/@walletconnect/relay-api/dist/esm/types.js
var types = __webpack_require__(60880);
;// CONCATENATED MODULE: ./node_modules/.pnpm/@walletconnect+relay-api@1.0.9/node_modules/@walletconnect/relay-api/dist/esm/jsonrpc.js
const RELAY_JSONRPC = {
    waku: {
        publish: "waku_publish",
        batchPublish: "waku_batchPublish",
        subscribe: "waku_subscribe",
        batchSubscribe: "waku_batchSubscribe",
        subscription: "waku_subscription",
        unsubscribe: "waku_unsubscribe",
        batchUnsubscribe: "waku_batchUnsubscribe",
    },
    irn: {
        publish: "irn_publish",
        batchPublish: "irn_batchPublish",
        subscribe: "irn_subscribe",
        batchSubscribe: "irn_batchSubscribe",
        subscription: "irn_subscription",
        unsubscribe: "irn_unsubscribe",
        batchUnsubscribe: "irn_batchUnsubscribe",
    },
    iridium: {
        publish: "iridium_publish",
        batchPublish: "iridium_batchPublish",
        subscribe: "iridium_subscribe",
        batchSubscribe: "iridium_batchSubscribe",
        subscription: "iridium_subscription",
        unsubscribe: "iridium_unsubscribe",
        batchUnsubscribe: "iridium_batchUnsubscribe",
    },
};

;// CONCATENATED MODULE: ./node_modules/.pnpm/@walletconnect+relay-api@1.0.9/node_modules/@walletconnect/relay-api/dist/esm/index.js






/***/ }),

/***/ 60880:
/***/ (() => {



/***/ }),

/***/ 3400:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  encodeIss: () => (/* reexport */ encodeIss),
  generateKeyPair: () => (/* reexport */ generateKeyPair),
  signJWT: () => (/* reexport */ signJWT)
});

// UNUSED EXPORTS: DATA_ENCODING, DID_DELIMITER, DID_METHOD, DID_PREFIX, JSON_ENCODING, JWT_DELIMITER, JWT_ENCODING, JWT_IRIDIUM_ALG, JWT_IRIDIUM_TYP, KEY_PAIR_SEED_LENGTH, MULTICODEC_ED25519_BASE, MULTICODEC_ED25519_ENCODING, MULTICODEC_ED25519_HEADER, MULTICODEC_ED25519_LENGTH, decodeData, decodeIss, decodeJSON, decodeJWT, decodeSig, encodeData, encodeJSON, encodeJWT, encodeSig, verifyJWT

// EXTERNAL MODULE: ./node_modules/.pnpm/@stablelib+ed25519@1.0.2/node_modules/@stablelib/ed25519/lib/ed25519.js
var lib_ed25519 = __webpack_require__(27662);
// EXTERNAL MODULE: ./node_modules/.pnpm/@stablelib+random@1.0.2/node_modules/@stablelib/random/lib/random.js
var random = __webpack_require__(68437);
// EXTERNAL MODULE: ./node_modules/.pnpm/@walletconnect+time@1.0.2/node_modules/@walletconnect/time/dist/cjs/index.js
var cjs = __webpack_require__(24041);
;// CONCATENATED MODULE: ./node_modules/.pnpm/@walletconnect+relay-auth@1.0.4/node_modules/@walletconnect/relay-auth/dist/esm/constants.js
const constants_JWT_IRIDIUM_ALG = "EdDSA";
const constants_JWT_IRIDIUM_TYP = "JWT";
const constants_JWT_DELIMITER = ".";
const constants_JWT_ENCODING = "base64url";
const constants_JSON_ENCODING = "utf8";
const constants_DATA_ENCODING = "utf8";
const constants_DID_DELIMITER = ":";
const constants_DID_PREFIX = "did";
const constants_DID_METHOD = "key";
const constants_MULTICODEC_ED25519_ENCODING = "base58btc";
const constants_MULTICODEC_ED25519_BASE = "z";
const constants_MULTICODEC_ED25519_HEADER = "K36";
const constants_MULTICODEC_ED25519_LENGTH = 32;
const KEY_PAIR_SEED_LENGTH = 32;

// EXTERNAL MODULE: ./node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/concat.js
var concat = __webpack_require__(67698);
// EXTERNAL MODULE: ./node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/to-string.js
var to_string = __webpack_require__(76109);
// EXTERNAL MODULE: ./node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/from-string.js
var from_string = __webpack_require__(88138);
// EXTERNAL MODULE: ./node_modules/.pnpm/@walletconnect+safe-json@1.0.2/node_modules/@walletconnect/safe-json/dist/esm/index.js
var esm = __webpack_require__(20927);
;// CONCATENATED MODULE: ./node_modules/.pnpm/@walletconnect+relay-auth@1.0.4/node_modules/@walletconnect/relay-auth/dist/esm/utils.js





function decodeJSON(str) {
    return safeJsonParse(toString(fromString(str, JWT_ENCODING), JSON_ENCODING));
}
function encodeJSON(val) {
    return (0,to_string/* toString */.B)((0,from_string/* fromString */.m)((0,esm/* safeJsonStringify */.u)(val), constants_JSON_ENCODING), constants_JWT_ENCODING);
}
function encodeIss(publicKey) {
    const header = (0,from_string/* fromString */.m)(constants_MULTICODEC_ED25519_HEADER, constants_MULTICODEC_ED25519_ENCODING);
    const multicodec = constants_MULTICODEC_ED25519_BASE +
        (0,to_string/* toString */.B)((0,concat/* concat */.z)([header, publicKey]), constants_MULTICODEC_ED25519_ENCODING);
    return [constants_DID_PREFIX, constants_DID_METHOD, multicodec].join(constants_DID_DELIMITER);
}
function utils_decodeIss(issuer) {
    const [prefix, method, multicodec] = issuer.split(DID_DELIMITER);
    if (prefix !== DID_PREFIX || method !== DID_METHOD) {
        throw new Error(`Issuer must be a DID with method "key"`);
    }
    const base = multicodec.slice(0, 1);
    if (base !== MULTICODEC_ED25519_BASE) {
        throw new Error(`Issuer must be a key in mulicodec format`);
    }
    const bytes = fromString(multicodec.slice(1), MULTICODEC_ED25519_ENCODING);
    const type = toString(bytes.slice(0, 2), MULTICODEC_ED25519_ENCODING);
    if (type !== MULTICODEC_ED25519_HEADER) {
        throw new Error(`Issuer must be a public key with type "Ed25519"`);
    }
    const publicKey = bytes.slice(2);
    if (publicKey.length !== MULTICODEC_ED25519_LENGTH) {
        throw new Error(`Issuer must be a public key with length 32 bytes`);
    }
    return publicKey;
}
function encodeSig(bytes) {
    return (0,to_string/* toString */.B)(bytes, constants_JWT_ENCODING);
}
function decodeSig(encoded) {
    return fromString(encoded, JWT_ENCODING);
}
function encodeData(params) {
    return (0,from_string/* fromString */.m)([encodeJSON(params.header), encodeJSON(params.payload)].join(constants_JWT_DELIMITER), constants_DATA_ENCODING);
}
function decodeData(data) {
    const params = toString(data, DATA_ENCODING).split(JWT_DELIMITER);
    const header = decodeJSON(params[0]);
    const payload = decodeJSON(params[1]);
    return { header, payload };
}
function encodeJWT(params) {
    return [
        encodeJSON(params.header),
        encodeJSON(params.payload),
        encodeSig(params.signature),
    ].join(constants_JWT_DELIMITER);
}
function utils_decodeJWT(jwt) {
    const params = jwt.split(JWT_DELIMITER);
    const header = decodeJSON(params[0]);
    const payload = decodeJSON(params[1]);
    const signature = decodeSig(params[2]);
    const data = fromString(params.slice(0, 2).join(JWT_DELIMITER), DATA_ENCODING);
    return { header, payload, signature, data };
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/@walletconnect+relay-auth@1.0.4/node_modules/@walletconnect/relay-auth/dist/esm/api.js





function generateKeyPair(seed = (0,random.randomBytes)(KEY_PAIR_SEED_LENGTH)) {
    return lib_ed25519/* generateKeyPairFromSeed */._w(seed);
}
async function signJWT(sub, aud, ttl, keyPair, iat = (0,cjs.fromMiliseconds)(Date.now())) {
    const header = { alg: constants_JWT_IRIDIUM_ALG, typ: constants_JWT_IRIDIUM_TYP };
    const iss = encodeIss(keyPair.publicKey);
    const exp = iat + ttl;
    const payload = { iss, sub, aud, iat, exp };
    const data = encodeData({ header, payload });
    const signature = lib_ed25519/* sign */.Xx(keyPair.secretKey, data);
    return encodeJWT({ header, payload, signature });
}
async function verifyJWT(jwt) {
    const { header, payload, data, signature } = decodeJWT(jwt);
    if (header.alg !== JWT_IRIDIUM_ALG || header.typ !== JWT_IRIDIUM_TYP) {
        throw new Error("JWT must use EdDSA algorithm");
    }
    const publicKey = decodeIss(payload.iss);
    return ed25519.verify(publicKey, data, signature);
}

// EXTERNAL MODULE: ./node_modules/.pnpm/@walletconnect+relay-auth@1.0.4/node_modules/@walletconnect/relay-auth/dist/esm/types.js
var types = __webpack_require__(79815);
;// CONCATENATED MODULE: ./node_modules/.pnpm/@walletconnect+relay-auth@1.0.4/node_modules/@walletconnect/relay-auth/dist/esm/index.js






/***/ }),

/***/ 79815:
/***/ (() => {



/***/ }),

/***/ 20927:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D: () => (/* binding */ safeJsonParse),
/* harmony export */   u: () => (/* binding */ safeJsonStringify)
/* harmony export */ });
const JSONStringify = data => JSON.stringify(data, (_, value) => typeof value === "bigint" ? value.toString() + "n" : value);
const JSONParse = json => {
    const numbersBiggerThanMaxInt = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g;
    const serializedData = json.replace(numbersBiggerThanMaxInt, "$1\"$2n\"$3");
    return JSON.parse(serializedData, (_, value) => {
        const isCustomFormatBigInt = typeof value === "string" && value.match(/^\d+n$/);
        if (isCustomFormatBigInt)
            return BigInt(value.substring(0, value.length - 1));
        return value;
    });
};
function safeJsonParse(value) {
    if (typeof value !== "string") {
        throw new Error(`Cannot safe json parse value of type ${typeof value}`);
    }
    try {
        return JSONParse(value);
    }
    catch (_a) {
        return value;
    }
}
function safeJsonStringify(value) {
    return typeof value === "string" ? value : JSONStringify(value) || "";
}


/***/ }),

/***/ 82480:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(69915);
tslib_1.__exportStar(__webpack_require__(61519), exports);
tslib_1.__exportStar(__webpack_require__(42903), exports);


/***/ }),

/***/ 61519:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ONE_THOUSAND = exports.ONE_HUNDRED = void 0;
exports.ONE_HUNDRED = 100;
exports.ONE_THOUSAND = 1000;


/***/ }),

/***/ 42903:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ONE_YEAR = exports.FOUR_WEEKS = exports.THREE_WEEKS = exports.TWO_WEEKS = exports.ONE_WEEK = exports.THIRTY_DAYS = exports.SEVEN_DAYS = exports.FIVE_DAYS = exports.THREE_DAYS = exports.ONE_DAY = exports.TWENTY_FOUR_HOURS = exports.TWELVE_HOURS = exports.SIX_HOURS = exports.THREE_HOURS = exports.ONE_HOUR = exports.SIXTY_MINUTES = exports.THIRTY_MINUTES = exports.TEN_MINUTES = exports.FIVE_MINUTES = exports.ONE_MINUTE = exports.SIXTY_SECONDS = exports.THIRTY_SECONDS = exports.TEN_SECONDS = exports.FIVE_SECONDS = exports.ONE_SECOND = void 0;
exports.ONE_SECOND = 1;
exports.FIVE_SECONDS = 5;
exports.TEN_SECONDS = 10;
exports.THIRTY_SECONDS = 30;
exports.SIXTY_SECONDS = 60;
exports.ONE_MINUTE = exports.SIXTY_SECONDS;
exports.FIVE_MINUTES = exports.ONE_MINUTE * 5;
exports.TEN_MINUTES = exports.ONE_MINUTE * 10;
exports.THIRTY_MINUTES = exports.ONE_MINUTE * 30;
exports.SIXTY_MINUTES = exports.ONE_MINUTE * 60;
exports.ONE_HOUR = exports.SIXTY_MINUTES;
exports.THREE_HOURS = exports.ONE_HOUR * 3;
exports.SIX_HOURS = exports.ONE_HOUR * 6;
exports.TWELVE_HOURS = exports.ONE_HOUR * 12;
exports.TWENTY_FOUR_HOURS = exports.ONE_HOUR * 24;
exports.ONE_DAY = exports.TWENTY_FOUR_HOURS;
exports.THREE_DAYS = exports.ONE_DAY * 3;
exports.FIVE_DAYS = exports.ONE_DAY * 5;
exports.SEVEN_DAYS = exports.ONE_DAY * 7;
exports.THIRTY_DAYS = exports.ONE_DAY * 30;
exports.ONE_WEEK = exports.SEVEN_DAYS;
exports.TWO_WEEKS = exports.ONE_WEEK * 2;
exports.THREE_WEEKS = exports.ONE_WEEK * 3;
exports.FOUR_WEEKS = exports.ONE_WEEK * 4;
exports.ONE_YEAR = exports.ONE_DAY * 365;


/***/ }),

/***/ 24041:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(69915);
tslib_1.__exportStar(__webpack_require__(86723), exports);
tslib_1.__exportStar(__webpack_require__(14214), exports);
tslib_1.__exportStar(__webpack_require__(52108), exports);
tslib_1.__exportStar(__webpack_require__(82480), exports);


/***/ }),

/***/ 52108:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(69915);
tslib_1.__exportStar(__webpack_require__(67136), exports);


/***/ }),

/***/ 67136:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IWatch = void 0;
class IWatch {
}
exports.IWatch = IWatch;


/***/ }),

/***/ 83662:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromMiliseconds = exports.toMiliseconds = void 0;
const constants_1 = __webpack_require__(82480);
function toMiliseconds(seconds) {
    return seconds * constants_1.ONE_THOUSAND;
}
exports.toMiliseconds = toMiliseconds;
function fromMiliseconds(miliseconds) {
    return Math.floor(miliseconds / constants_1.ONE_THOUSAND);
}
exports.fromMiliseconds = fromMiliseconds;


/***/ }),

/***/ 29794:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.delay = void 0;
function delay(timeout) {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve(true);
        }, timeout);
    });
}
exports.delay = delay;


/***/ }),

/***/ 86723:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(69915);
tslib_1.__exportStar(__webpack_require__(29794), exports);
tslib_1.__exportStar(__webpack_require__(83662), exports);


/***/ }),

/***/ 14214:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Watch = void 0;
class Watch {
    constructor() {
        this.timestamps = new Map();
    }
    start(label) {
        if (this.timestamps.has(label)) {
            throw new Error(`Watch already started for label: ${label}`);
        }
        this.timestamps.set(label, { started: Date.now() });
    }
    stop(label) {
        const timestamp = this.get(label);
        if (typeof timestamp.elapsed !== "undefined") {
            throw new Error(`Watch already stopped for label: ${label}`);
        }
        const elapsed = Date.now() - timestamp.started;
        this.timestamps.set(label, { started: timestamp.started, elapsed });
    }
    get(label) {
        const timestamp = this.timestamps.get(label);
        if (typeof timestamp === "undefined") {
            throw new Error(`No timestamp found for label: ${label}`);
        }
        return timestamp;
    }
    elapsed(label) {
        const timestamp = this.get(label);
        const elapsed = timestamp.elapsed || Date.now() - timestamp.started;
        return elapsed;
    }
}
exports.Watch = Watch;
exports["default"] = Watch;


/***/ }),

/***/ 1405:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D3: () => (/* binding */ E),
/* harmony export */   N1: () => (/* binding */ n),
/* harmony export */   W3: () => (/* binding */ S),
/* harmony export */   Yo: () => (/* binding */ y),
/* harmony export */   kZ: () => (/* binding */ a),
/* harmony export */   lV: () => (/* binding */ b),
/* harmony export */   oe: () => (/* binding */ g),
/* harmony export */   pZ: () => (/* binding */ p),
/* harmony export */   sY: () => (/* binding */ d),
/* harmony export */   yy: () => (/* binding */ h),
/* harmony export */   z9: () => (/* binding */ u)
/* harmony export */ });
/* unused harmony exports ICrypto, IEngineEvents, IKeyChain, IPairing, ISignClientEvents, ISubscriberTopicMap */
/* harmony import */ var _walletconnect_events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58032);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58470);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
class n extends _walletconnect_events__WEBPACK_IMPORTED_MODULE_1__/* .IEvents */ .q{constructor(s){super(),this.opts=s,this.protocol="wc",this.version=2}}class l{constructor(s,t,o){this.core=s,this.logger=t}}class h extends _walletconnect_events__WEBPACK_IMPORTED_MODULE_1__/* .IEvents */ .q{constructor(s,t){super(),this.core=s,this.logger=t,this.records=new Map}}class a{constructor(s,t){this.logger=s,this.core=t}}class u extends _walletconnect_events__WEBPACK_IMPORTED_MODULE_1__/* .IEvents */ .q{constructor(s,t){super(),this.relayer=s,this.logger=t}}class g extends _walletconnect_events__WEBPACK_IMPORTED_MODULE_1__/* .IEvents */ .q{constructor(s){super()}}class p{constructor(s,t,o,w){this.core=s,this.logger=t,this.name=o}}class I{constructor(){this.map=new Map}}class d extends _walletconnect_events__WEBPACK_IMPORTED_MODULE_1__/* .IEvents */ .q{constructor(s,t){super(),this.relayer=s,this.logger=t}}class x{constructor(s,t){this.core=s,this.logger=t}}class E extends _walletconnect_events__WEBPACK_IMPORTED_MODULE_1__/* .IEvents */ .q{constructor(s,t){super(),this.core=s,this.logger=t}}class m{constructor(s,t){this.logger=s,this.core=t}}class y{constructor(s,t){this.projectId=s,this.logger=t}}class v extends (/* unused pure expression or super */ null && (c)){constructor(){super()}}class b{constructor(s){this.opts=s,this.protocol="wc",this.version=2}}class C extends (/* unused pure expression or super */ null && (i)){constructor(){super()}}class S{constructor(s){this.client=s}}


/***/ }),

/***/ 44012:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLocalStorage = exports.getLocalStorageOrThrow = exports.getCrypto = exports.getCryptoOrThrow = exports.getLocation = exports.getLocationOrThrow = exports.getNavigator = exports.getNavigatorOrThrow = exports.getDocument = exports.getDocumentOrThrow = exports.getFromWindowOrThrow = exports.getFromWindow = void 0;
function getFromWindow(name) {
    let res = undefined;
    if (typeof window !== "undefined" && typeof window[name] !== "undefined") {
        res = window[name];
    }
    return res;
}
exports.getFromWindow = getFromWindow;
function getFromWindowOrThrow(name) {
    const res = getFromWindow(name);
    if (!res) {
        throw new Error(`${name} is not defined in Window`);
    }
    return res;
}
exports.getFromWindowOrThrow = getFromWindowOrThrow;
function getDocumentOrThrow() {
    return getFromWindowOrThrow("document");
}
exports.getDocumentOrThrow = getDocumentOrThrow;
function getDocument() {
    return getFromWindow("document");
}
exports.getDocument = getDocument;
function getNavigatorOrThrow() {
    return getFromWindowOrThrow("navigator");
}
exports.getNavigatorOrThrow = getNavigatorOrThrow;
function getNavigator() {
    return getFromWindow("navigator");
}
exports.getNavigator = getNavigator;
function getLocationOrThrow() {
    return getFromWindowOrThrow("location");
}
exports.getLocationOrThrow = getLocationOrThrow;
function getLocation() {
    return getFromWindow("location");
}
exports.getLocation = getLocation;
function getCryptoOrThrow() {
    return getFromWindowOrThrow("crypto");
}
exports.getCryptoOrThrow = getCryptoOrThrow;
function getCrypto() {
    return getFromWindow("crypto");
}
exports.getCrypto = getCrypto;
function getLocalStorageOrThrow() {
    return getFromWindowOrThrow("localStorage");
}
exports.getLocalStorageOrThrow = getLocalStorageOrThrow;
function getLocalStorage() {
    return getFromWindow("localStorage");
}
exports.getLocalStorage = getLocalStorage;


/***/ }),

/***/ 13498:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
exports.D = void 0;
const window_getters_1 = __webpack_require__(44012);
function getWindowMetadata() {
    let doc;
    let loc;
    try {
        doc = window_getters_1.getDocumentOrThrow();
        loc = window_getters_1.getLocationOrThrow();
    }
    catch (e) {
        return null;
    }
    function getIcons() {
        const links = doc.getElementsByTagName("link");
        const icons = [];
        for (let i = 0; i < links.length; i++) {
            const link = links[i];
            const rel = link.getAttribute("rel");
            if (rel) {
                if (rel.toLowerCase().indexOf("icon") > -1) {
                    const href = link.getAttribute("href");
                    if (href) {
                        if (href.toLowerCase().indexOf("https:") === -1 &&
                            href.toLowerCase().indexOf("http:") === -1 &&
                            href.indexOf("//") !== 0) {
                            let absoluteHref = loc.protocol + "//" + loc.host;
                            if (href.indexOf("/") === 0) {
                                absoluteHref += href;
                            }
                            else {
                                const path = loc.pathname.split("/");
                                path.pop();
                                const finalPath = path.join("/");
                                absoluteHref += finalPath + "/" + href;
                            }
                            icons.push(absoluteHref);
                        }
                        else if (href.indexOf("//") === 0) {
                            const absoluteUrl = loc.protocol + href;
                            icons.push(absoluteUrl);
                        }
                        else {
                            icons.push(href);
                        }
                    }
                }
            }
        }
        return icons;
    }
    function getWindowMetadataOfAny(...args) {
        const metaTags = doc.getElementsByTagName("meta");
        for (let i = 0; i < metaTags.length; i++) {
            const tag = metaTags[i];
            const attributes = ["itemprop", "property", "name"]
                .map((target) => tag.getAttribute(target))
                .filter((attr) => {
                if (attr) {
                    return args.includes(attr);
                }
                return false;
            });
            if (attributes.length && attributes) {
                const content = tag.getAttribute("content");
                if (content) {
                    return content;
                }
            }
        }
        return "";
    }
    function getName() {
        let name = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
        if (!name) {
            name = doc.title;
        }
        return name;
    }
    function getDescription() {
        const description = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
        return description;
    }
    const name = getName();
    const description = getDescription();
    const url = loc.origin;
    const icons = getIcons();
    const meta = {
        description,
        url,
        icons,
        name,
    };
    return meta;
}
exports.D = getWindowMetadata;


/***/ }),

/***/ 235:
/***/ ((module) => {

"use strict";
/*globals self, window */


/*eslint-disable @mysticatea/prettier */
const { AbortController, AbortSignal } =
    typeof self !== "undefined" ? self :
    typeof window !== "undefined" ? window :
    /* otherwise */ undefined
/*eslint-enable @mysticatea/prettier */

module.exports = AbortController
module.exports.AbortSignal = AbortSignal
module.exports["default"] = AbortController


/***/ }),

/***/ 18875:
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {
   true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) :
  0;
})((function () { 'use strict';

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get.bind();
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }

        return desc.value;
      };
    }

    return _get.apply(this, arguments);
  }

  var Emitter = /*#__PURE__*/function () {
    function Emitter() {
      _classCallCheck(this, Emitter);

      Object.defineProperty(this, 'listeners', {
        value: {},
        writable: true,
        configurable: true
      });
    }

    _createClass(Emitter, [{
      key: "addEventListener",
      value: function addEventListener(type, callback, options) {
        if (!(type in this.listeners)) {
          this.listeners[type] = [];
        }

        this.listeners[type].push({
          callback: callback,
          options: options
        });
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, callback) {
        if (!(type in this.listeners)) {
          return;
        }

        var stack = this.listeners[type];

        for (var i = 0, l = stack.length; i < l; i++) {
          if (stack[i].callback === callback) {
            stack.splice(i, 1);
            return;
          }
        }
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(event) {
        if (!(event.type in this.listeners)) {
          return;
        }

        var stack = this.listeners[event.type];
        var stackToCall = stack.slice();

        for (var i = 0, l = stackToCall.length; i < l; i++) {
          var listener = stackToCall[i];

          try {
            listener.callback.call(this, event);
          } catch (e) {
            Promise.resolve().then(function () {
              throw e;
            });
          }

          if (listener.options && listener.options.once) {
            this.removeEventListener(event.type, listener.callback);
          }
        }

        return !event.defaultPrevented;
      }
    }]);

    return Emitter;
  }();

  var AbortSignal = /*#__PURE__*/function (_Emitter) {
    _inherits(AbortSignal, _Emitter);

    var _super = _createSuper(AbortSignal);

    function AbortSignal() {
      var _this;

      _classCallCheck(this, AbortSignal);

      _this = _super.call(this); // Some versions of babel does not transpile super() correctly for IE <= 10, if the parent
      // constructor has failed to run, then "this.listeners" will still be undefined and then we call
      // the parent constructor directly instead as a workaround. For general details, see babel bug:
      // https://github.com/babel/babel/issues/3041
      // This hack was added as a fix for the issue described here:
      // https://github.com/Financial-Times/polyfill-library/pull/59#issuecomment-477558042

      if (!_this.listeners) {
        Emitter.call(_assertThisInitialized(_this));
      } // Compared to assignment, Object.defineProperty makes properties non-enumerable by default and
      // we want Object.keys(new AbortController().signal) to be [] for compat with the native impl


      Object.defineProperty(_assertThisInitialized(_this), 'aborted', {
        value: false,
        writable: true,
        configurable: true
      });
      Object.defineProperty(_assertThisInitialized(_this), 'onabort', {
        value: null,
        writable: true,
        configurable: true
      });
      Object.defineProperty(_assertThisInitialized(_this), 'reason', {
        value: undefined,
        writable: true,
        configurable: true
      });
      return _this;
    }

    _createClass(AbortSignal, [{
      key: "toString",
      value: function toString() {
        return '[object AbortSignal]';
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(event) {
        if (event.type === 'abort') {
          this.aborted = true;

          if (typeof this.onabort === 'function') {
            this.onabort.call(this, event);
          }
        }

        _get(_getPrototypeOf(AbortSignal.prototype), "dispatchEvent", this).call(this, event);
      }
    }]);

    return AbortSignal;
  }(Emitter);
  var AbortController = /*#__PURE__*/function () {
    function AbortController() {
      _classCallCheck(this, AbortController);

      // Compared to assignment, Object.defineProperty makes properties non-enumerable by default and
      // we want Object.keys(new AbortController()) to be [] for compat with the native impl
      Object.defineProperty(this, 'signal', {
        value: new AbortSignal(),
        writable: true,
        configurable: true
      });
    }

    _createClass(AbortController, [{
      key: "abort",
      value: function abort(reason) {
        var event;

        try {
          event = new Event('abort');
        } catch (e) {
          if (typeof document !== 'undefined') {
            if (!document.createEvent) {
              // For Internet Explorer 8:
              event = document.createEventObject();
              event.type = 'abort';
            } else {
              // For Internet Explorer 11:
              event = document.createEvent('Event');
              event.initEvent('abort', false, false);
            }
          } else {
            // Fallback where document isn't available:
            event = {
              type: 'abort',
              bubbles: false,
              cancelable: false
            };
          }
        }

        var signalReason = reason;

        if (signalReason === undefined) {
          if (typeof document === 'undefined') {
            signalReason = new Error('This operation was aborted');
            signalReason.name = 'AbortError';
          } else {
            try {
              signalReason = new DOMException('signal is aborted without reason');
            } catch (err) {
              // IE 11 does not support calling the DOMException constructor, use a
              // regular error object on it instead.
              signalReason = new Error('This operation was aborted');
              signalReason.name = 'AbortError';
            }
          }
        }

        this.signal.reason = signalReason;
        this.signal.dispatchEvent(event);
      }
    }, {
      key: "toString",
      value: function toString() {
        return '[object AbortController]';
      }
    }]);

    return AbortController;
  }();

  if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
    // These are necessary to make sure that we get correct output for:
    // Object.prototype.toString.call(new AbortController())
    AbortController.prototype[Symbol.toStringTag] = 'AbortController';
    AbortSignal.prototype[Symbol.toStringTag] = 'AbortSignal';
  }

  function polyfillNeeded(self) {
    if (self.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {
      console.log('__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL=true is set, will force install polyfill');
      return true;
    } // Note that the "unfetch" minimal fetch polyfill defines fetch() without
    // defining window.Request, and this polyfill need to work on top of unfetch
    // so the below feature detection needs the !self.AbortController part.
    // The Request.prototype check is also needed because Safari versions 11.1.2
    // up to and including 12.1.x has a window.AbortController present but still
    // does NOT correctly implement abortable fetch:
    // https://bugs.webkit.org/show_bug.cgi?id=174980#c2


    return typeof self.Request === 'function' && !self.Request.prototype.hasOwnProperty('signal') || !self.AbortController;
  }

  /**
   * Note: the "fetch.Request" default value is available for fetch imported from
   * the "node-fetch" package and not in browsers. This is OK since browsers
   * will be importing umd-polyfill.js from that path "self" is passed the
   * decorator so the default value will not be used (because browsers that define
   * fetch also has Request). One quirky setup where self.fetch exists but
   * self.Request does not is when the "unfetch" minimal fetch polyfill is used
   * on top of IE11; for this case the browser will try to use the fetch.Request
   * default value which in turn will be undefined but then then "if (Request)"
   * will ensure that you get a patched fetch but still no Request (as expected).
   * @param {fetch, Request = fetch.Request}
   * @returns {fetch: abortableFetch, Request: AbortableRequest}
   */

  function abortableFetchDecorator(patchTargets) {
    if ('function' === typeof patchTargets) {
      patchTargets = {
        fetch: patchTargets
      };
    }

    var _patchTargets = patchTargets,
        fetch = _patchTargets.fetch,
        _patchTargets$Request = _patchTargets.Request,
        NativeRequest = _patchTargets$Request === void 0 ? fetch.Request : _patchTargets$Request,
        NativeAbortController = _patchTargets.AbortController,
        _patchTargets$__FORCE = _patchTargets.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL,
        __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL = _patchTargets$__FORCE === void 0 ? false : _patchTargets$__FORCE;

    if (!polyfillNeeded({
      fetch: fetch,
      Request: NativeRequest,
      AbortController: NativeAbortController,
      __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL: __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL
    })) {
      return {
        fetch: fetch,
        Request: Request
      };
    }

    var Request = NativeRequest; // Note that the "unfetch" minimal fetch polyfill defines fetch() without
    // defining window.Request, and this polyfill need to work on top of unfetch
    // hence we only patch it if it's available. Also we don't patch it if signal
    // is already available on the Request prototype because in this case support
    // is present and the patching below can cause a crash since it assigns to
    // request.signal which is technically a read-only property. This latter error
    // happens when you run the main5.js node-fetch example in the repo
    // "abortcontroller-polyfill-examples". The exact error is:
    //   request.signal = init.signal;
    //   ^
    // TypeError: Cannot set property signal of #<Request> which has only a getter

    if (Request && !Request.prototype.hasOwnProperty('signal') || __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {
      Request = function Request(input, init) {
        var signal;

        if (init && init.signal) {
          signal = init.signal; // Never pass init.signal to the native Request implementation when the polyfill has
          // been installed because if we're running on top of a browser with a
          // working native AbortController (i.e. the polyfill was installed due to
          // __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL being set), then passing our
          // fake AbortSignal to the native fetch will trigger:
          // TypeError: Failed to construct 'Request': member signal is not of type AbortSignal.

          delete init.signal;
        }

        var request = new NativeRequest(input, init);

        if (signal) {
          Object.defineProperty(request, 'signal', {
            writable: false,
            enumerable: false,
            configurable: true,
            value: signal
          });
        }

        return request;
      };

      Request.prototype = NativeRequest.prototype;
    }

    var realFetch = fetch;

    var abortableFetch = function abortableFetch(input, init) {
      var signal = Request && Request.prototype.isPrototypeOf(input) ? input.signal : init ? init.signal : undefined;

      if (signal) {
        var abortError;

        try {
          abortError = new DOMException('Aborted', 'AbortError');
        } catch (err) {
          // IE 11 does not support calling the DOMException constructor, use a
          // regular error object on it instead.
          abortError = new Error('Aborted');
          abortError.name = 'AbortError';
        } // Return early if already aborted, thus avoiding making an HTTP request


        if (signal.aborted) {
          return Promise.reject(abortError);
        } // Turn an event into a promise, reject it once `abort` is dispatched


        var cancellation = new Promise(function (_, reject) {
          signal.addEventListener('abort', function () {
            return reject(abortError);
          }, {
            once: true
          });
        });

        if (init && init.signal) {
          // Never pass .signal to the native implementation when the polyfill has
          // been installed because if we're running on top of a browser with a
          // working native AbortController (i.e. the polyfill was installed due to
          // __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL being set), then passing our
          // fake AbortSignal to the native fetch will trigger:
          // TypeError: Failed to execute 'fetch' on 'Window': member signal is not of type AbortSignal.
          delete init.signal;
        } // Return the fastest promise (don't need to wait for request to finish)


        return Promise.race([cancellation, realFetch(input, init)]);
      }

      return realFetch(input, init);
    };

    return {
      fetch: abortableFetch,
      Request: Request
    };
  }

  (function (self) {

    if (!polyfillNeeded(self)) {
      return;
    }

    if (!self.fetch) {
      console.warn('fetch() is not available, cannot install abortcontroller-polyfill');
      return;
    }

    var _abortableFetch = abortableFetchDecorator(self),
        fetch = _abortableFetch.fetch,
        Request = _abortableFetch.Request;

    self.fetch = fetch;
    self.Request = Request;
    Object.defineProperty(self, 'AbortController', {
      writable: true,
      enumerable: false,
      configurable: true,
      value: AbortController
    });
    Object.defineProperty(self, 'AbortSignal', {
      writable: true,
      enumerable: false,
      configurable: true,
      value: AbortSignal
    });
  })(typeof self !== 'undefined' ? self : __webpack_require__.g);

}));


/***/ }),

/***/ 94781:
/***/ ((module) => {

module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}


/***/ }),

/***/ 66344:
/***/ ((module) => {

/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};


/***/ }),

/***/ 21506:
/***/ ((module) => {


/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};



/***/ }),

/***/ 33206:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
// @ts-ignore
var _Buffer = (__webpack_require__(80480).Buffer)
function base (ALPHABET) {
  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
  var BASE_MAP = new Uint8Array(256)
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i)
    var xc = x.charCodeAt(0)
    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
    BASE_MAP[xc] = i
  }
  var BASE = ALPHABET.length
  var LEADER = ALPHABET.charAt(0)
  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up
  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up
  function encode (source) {
    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source) }
    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }
    if (source.length === 0) { return '' }
        // Skip & count leading zeroes.
    var zeroes = 0
    var length = 0
    var pbegin = 0
    var pend = source.length
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++
      zeroes++
    }
        // Allocate enough space in big-endian base58 representation.
    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0
    var b58 = new Uint8Array(size)
        // Process the bytes.
    while (pbegin !== pend) {
      var carry = source[pbegin]
            // Apply "b58 = b58 * 256 + ch".
      var i = 0
      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
        carry += (256 * b58[it1]) >>> 0
        b58[it1] = (carry % BASE) >>> 0
        carry = (carry / BASE) >>> 0
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i
      pbegin++
    }
        // Skip leading zeroes in base58 result.
    var it2 = size - length
    while (it2 !== size && b58[it2] === 0) {
      it2++
    }
        // Translate the result into a string.
    var str = LEADER.repeat(zeroes)
    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }
    return str
  }
  function decodeUnsafe (source) {
    if (typeof source !== 'string') { throw new TypeError('Expected String') }
    if (source.length === 0) { return _Buffer.alloc(0) }
    var psz = 0
        // Skip and count leading '1's.
    var zeroes = 0
    var length = 0
    while (source[psz] === LEADER) {
      zeroes++
      psz++
    }
        // Allocate enough space in big-endian base256 representation.
    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.
    var b256 = new Uint8Array(size)
        // Process the characters.
    while (source[psz]) {
            // Decode character
      var carry = BASE_MAP[source.charCodeAt(psz)]
            // Invalid character
      if (carry === 255) { return }
      var i = 0
      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
        carry += (BASE * b256[it3]) >>> 0
        b256[it3] = (carry % 256) >>> 0
        carry = (carry / 256) >>> 0
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i
      psz++
    }
        // Skip leading zeroes in b256.
    var it4 = size - length
    while (it4 !== size && b256[it4] === 0) {
      it4++
    }
    var vch = _Buffer.allocUnsafe(zeroes + (size - it4))
    vch.fill(0x00, 0, zeroes)
    var j = zeroes
    while (it4 !== size) {
      vch[j++] = b256[it4++]
    }
    return vch
  }
  function decode (string) {
    var buffer = decodeUnsafe(string)
    if (buffer) { return buffer }
    throw new Error('Non-base' + BASE + ' character')
  }
  return {
    encode: encode,
    decodeUnsafe: decodeUnsafe,
    decode: decode
  }
}
module.exports = base


/***/ }),

/***/ 6068:
/***/ ((module) => {

"use strict";

// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
function base (ALPHABET) {
  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
  var BASE_MAP = new Uint8Array(256)
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i)
    var xc = x.charCodeAt(0)
    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
    BASE_MAP[xc] = i
  }
  var BASE = ALPHABET.length
  var LEADER = ALPHABET.charAt(0)
  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up
  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up
  function encode (source) {
    if (source instanceof Uint8Array) {
    } else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source)
    }
    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }
    if (source.length === 0) { return '' }
        // Skip & count leading zeroes.
    var zeroes = 0
    var length = 0
    var pbegin = 0
    var pend = source.length
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++
      zeroes++
    }
        // Allocate enough space in big-endian base58 representation.
    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0
    var b58 = new Uint8Array(size)
        // Process the bytes.
    while (pbegin !== pend) {
      var carry = source[pbegin]
            // Apply "b58 = b58 * 256 + ch".
      var i = 0
      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
        carry += (256 * b58[it1]) >>> 0
        b58[it1] = (carry % BASE) >>> 0
        carry = (carry / BASE) >>> 0
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i
      pbegin++
    }
        // Skip leading zeroes in base58 result.
    var it2 = size - length
    while (it2 !== size && b58[it2] === 0) {
      it2++
    }
        // Translate the result into a string.
    var str = LEADER.repeat(zeroes)
    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }
    return str
  }
  function decodeUnsafe (source) {
    if (typeof source !== 'string') { throw new TypeError('Expected String') }
    if (source.length === 0) { return new Uint8Array() }
    var psz = 0
        // Skip and count leading '1's.
    var zeroes = 0
    var length = 0
    while (source[psz] === LEADER) {
      zeroes++
      psz++
    }
        // Allocate enough space in big-endian base256 representation.
    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.
    var b256 = new Uint8Array(size)
        // Process the characters.
    while (source[psz]) {
            // Decode character
      var carry = BASE_MAP[source.charCodeAt(psz)]
            // Invalid character
      if (carry === 255) { return }
      var i = 0
      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
        carry += (BASE * b256[it3]) >>> 0
        b256[it3] = (carry % 256) >>> 0
        carry = (carry / 256) >>> 0
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i
      psz++
    }
        // Skip leading zeroes in b256.
    var it4 = size - length
    while (it4 !== size && b256[it4] === 0) {
      it4++
    }
    var vch = new Uint8Array(zeroes + (size - it4))
    var j = zeroes
    while (it4 !== size) {
      vch[j++] = b256[it4++]
    }
    return vch
  }
  function decode (string) {
    var buffer = decodeUnsafe(string)
    if (buffer) { return buffer }
    throw new Error('Non-base' + BASE + ' character')
  }
  return {
    encode: encode,
    decodeUnsafe: decodeUnsafe,
    decode: decode
  }
}
module.exports = base


/***/ }),

/***/ 30171:
/***/ ((__unused_webpack_module, exports) => {

/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(chars){
  "use strict";

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = chars.indexOf(base64[i]);
      encoded2 = chars.indexOf(base64[i+1]);
      encoded3 = chars.indexOf(base64[i+2]);
      encoded4 = chars.indexOf(base64[i+3]);

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");


/***/ }),

/***/ 833:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ 76470:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;
/* provided dependency */ var Buffer = __webpack_require__(7661)["Buffer"];


__webpack_unused_export__ = ({ value: true });
let converter;
/**
 * Convert a little-endian buffer into a BigInt.
 * @param buf The little-endian buffer to convert
 * @returns A BigInt with the little-endian representation of buf.
 */
function toBigIntLE(buf) {
    {
        const reversed = Buffer.from(buf);
        reversed.reverse();
        const hex = reversed.toString('hex');
        if (hex.length === 0) {
            return BigInt(0);
        }
        return BigInt(`0x${hex}`);
    }
    return converter.toBigInt(buf, false);
}
exports.oU = toBigIntLE;
/**
 * Convert a big-endian buffer into a BigInt
 * @param buf The big-endian buffer to convert.
 * @returns A BigInt with the big-endian representation of buf.
 */
function toBigIntBE(buf) {
    {
        const hex = buf.toString('hex');
        if (hex.length === 0) {
            return BigInt(0);
        }
        return BigInt(`0x${hex}`);
    }
    return converter.toBigInt(buf, true);
}
__webpack_unused_export__ = toBigIntBE;
/**
 * Convert a BigInt to a little-endian buffer.
 * @param num   The BigInt to convert.
 * @param width The number of bytes that the resulting buffer should be.
 * @returns A little-endian buffer representation of num.
 */
function toBufferLE(num, width) {
    {
        const hex = num.toString(16);
        const buffer = Buffer.from(hex.padStart(width * 2, '0').slice(0, width * 2), 'hex');
        buffer.reverse();
        return buffer;
    }
    // Allocation is done here, since it is slower using napi in C
    return converter.fromBigInt(num, Buffer.allocUnsafe(width), false);
}
exports.k$ = toBufferLE;
/**
 * Convert a BigInt to a big-endian buffer.
 * @param num   The BigInt to convert.
 * @param width The number of bytes that the resulting buffer should be.
 * @returns A big-endian buffer representation of num.
 */
function toBufferBE(num, width) {
    {
        const hex = num.toString(16);
        return Buffer.from(hex.padStart(width * 2, '0').slice(0, width * 2), 'hex');
    }
    return converter.fromBigInt(num, Buffer.allocUnsafe(width), true);
}
__webpack_unused_export__ = toBufferBE;


/***/ }),

/***/ 3305:
/***/ ((module) => {

/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :
  typeof WebKitBlobBuilder !== 'undefined' ? WebKitBlobBuilder :
  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :
  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : 
  false;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var a = new Blob(['hi']);
    return a.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if Blob constructor supports ArrayBufferViews
 * Fails in Safari 6, so we need to map to ArrayBuffers there.
 */

var blobSupportsArrayBufferView = blobSupported && (function() {
  try {
    var b = new Blob([new Uint8Array([1,2])]);
    return b.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

/**
 * Helper function that maps ArrayBufferViews to ArrayBuffers
 * Used by BlobBuilder constructor and old browsers that didn't
 * support it in the Blob constructor.
 */

function mapArrayBufferViews(ary) {
  return ary.map(function(chunk) {
    if (chunk.buffer instanceof ArrayBuffer) {
      var buf = chunk.buffer;

      // if this is a subarray, make a copy so we only
      // include the subarray region from the underlying buffer
      if (chunk.byteLength !== buf.byteLength) {
        var copy = new Uint8Array(chunk.byteLength);
        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
        buf = copy.buffer;
      }

      return buf;
    }

    return chunk;
  });
}

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  mapArrayBufferViews(ary).forEach(function(part) {
    bb.append(part);
  });

  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

function BlobConstructor(ary, options) {
  return new Blob(mapArrayBufferViews(ary), options || {});
};

if (typeof Blob !== 'undefined') {
  BlobBuilderConstructor.prototype = Blob.prototype;
  BlobConstructor.prototype = Blob.prototype;
}

module.exports = (function() {
  if (blobSupported) {
    return blobSupportsArrayBufferView ? Blob : BlobConstructor;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();


/***/ }),

/***/ 89799:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var r;

module.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n);

  var res = new Uint8Array(n);
  for (var i = 0; i < res.length; i++)
    res[i] = this.rand.getByte();
  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };

  // Safari's WebWorkers do not have `crypto`
  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto = __webpack_require__(81388);
    if (typeof crypto.randomBytes !== 'function')
      throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
  }
}


/***/ }),

/***/ 90666:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var DES = __webpack_require__(25615)
var aes = __webpack_require__(79876)
var aesModes = __webpack_require__(93328)
var desModes = __webpack_require__(24201)
var ebtk = __webpack_require__(76778)

function createCipher (suite, password) {
  suite = suite.toLowerCase()

  var keyLen, ivLen
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }

  var keys = ebtk(password, false, keyLen, ivLen)
  return createCipheriv(suite, keys.key, keys.iv)
}

function createDecipher (suite, password) {
  suite = suite.toLowerCase()

  var keyLen, ivLen
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }

  var keys = ebtk(password, false, keyLen, ivLen)
  return createDecipheriv(suite, keys.key, keys.iv)
}

function createCipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) return aes.createCipheriv(suite, key, iv)
  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite })

  throw new TypeError('invalid suite type')
}

function createDecipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) return aes.createDecipheriv(suite, key, iv)
  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite, decrypt: true })

  throw new TypeError('invalid suite type')
}

function getCiphers () {
  return Object.keys(desModes).concat(aes.getCiphers())
}

exports.createCipher = exports.Cipher = createCipher
exports.createCipheriv = exports.Cipheriv = createCipheriv
exports.createDecipher = exports.Decipher = createDecipher
exports.createDecipheriv = exports.Decipheriv = createDecipheriv
exports.listCiphers = exports.getCiphers = getCiphers


/***/ }),

/***/ 25615:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var CipherBase = __webpack_require__(9186)
var des = __webpack_require__(79534)
var inherits = __webpack_require__(86778)
var Buffer = (__webpack_require__(80480).Buffer)

var modes = {
  'des-ede3-cbc': des.CBC.instantiate(des.EDE),
  'des-ede3': des.EDE,
  'des-ede-cbc': des.CBC.instantiate(des.EDE),
  'des-ede': des.EDE,
  'des-cbc': des.CBC.instantiate(des.DES),
  'des-ecb': des.DES
}
modes.des = modes['des-cbc']
modes.des3 = modes['des-ede3-cbc']
module.exports = DES
inherits(DES, CipherBase)
function DES (opts) {
  CipherBase.call(this)
  var modeName = opts.mode.toLowerCase()
  var mode = modes[modeName]
  var type
  if (opts.decrypt) {
    type = 'decrypt'
  } else {
    type = 'encrypt'
  }
  var key = opts.key
  if (!Buffer.isBuffer(key)) {
    key = Buffer.from(key)
  }
  if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {
    key = Buffer.concat([key, key.slice(0, 8)])
  }
  var iv = opts.iv
  if (!Buffer.isBuffer(iv)) {
    iv = Buffer.from(iv)
  }
  this._des = mode.create({
    key: key,
    iv: iv,
    type: type
  })
}
DES.prototype._update = function (data) {
  return Buffer.from(this._des.update(data))
}
DES.prototype._final = function () {
  return Buffer.from(this._des.final())
}


/***/ }),

/***/ 24201:
/***/ ((__unused_webpack_module, exports) => {

exports["des-ecb"] = {
  key: 8,
  iv: 0
}
exports["des-cbc"] = exports.des = {
  key: 8,
  iv: 8
}
exports["des-ede3-cbc"] = exports.des3 = {
  key: 24,
  iv: 8
}
exports["des-ede3"] = {
  key: 24,
  iv: 0
}
exports["des-ede-cbc"] = {
  key: 16,
  iv: 8
}
exports["des-ede"] = {
  key: 16,
  iv: 0
}


/***/ }),

/***/ 20208:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(7661)["Buffer"];
var BN = __webpack_require__(73182)
var randomBytes = __webpack_require__(44613)

function blind (priv) {
  var r = getr(priv)
  var blinder = r.toRed(BN.mont(priv.modulus)).redPow(new BN(priv.publicExponent)).fromRed()
  return { blinder: blinder, unblinder: r.invm(priv.modulus) }
}

function getr (priv) {
  var len = priv.modulus.byteLength()
  var r
  do {
    r = new BN(randomBytes(len))
  } while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2))
  return r
}

function crt (msg, priv) {
  var blinds = blind(priv)
  var len = priv.modulus.byteLength()
  var blinded = new BN(msg).mul(blinds.blinder).umod(priv.modulus)
  var c1 = blinded.toRed(BN.mont(priv.prime1))
  var c2 = blinded.toRed(BN.mont(priv.prime2))
  var qinv = priv.coefficient
  var p = priv.prime1
  var q = priv.prime2
  var m1 = c1.redPow(priv.exponent1).fromRed()
  var m2 = c2.redPow(priv.exponent2).fromRed()
  var h = m1.isub(m2).imul(qinv).umod(p).imul(q)
  return m2.iadd(h).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer, 'be', len)
}
crt.getr = getr

module.exports = crt


/***/ }),

/***/ 69080:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(37415)


/***/ }),

/***/ 79914:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Buffer = (__webpack_require__(80480).Buffer)
var createHash = __webpack_require__(68066)
var stream = __webpack_require__(25329)
var inherits = __webpack_require__(86778)
var sign = __webpack_require__(55454)
var verify = __webpack_require__(49867)

var algorithms = __webpack_require__(37415)
Object.keys(algorithms).forEach(function (key) {
  algorithms[key].id = Buffer.from(algorithms[key].id, 'hex')
  algorithms[key.toLowerCase()] = algorithms[key]
})

function Sign (algorithm) {
  stream.Writable.call(this)

  var data = algorithms[algorithm]
  if (!data) throw new Error('Unknown message digest')

  this._hashType = data.hash
  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Sign, stream.Writable)

Sign.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Sign.prototype.update = function update (data, enc) {
  if (typeof data === 'string') data = Buffer.from(data, enc)

  this._hash.update(data)
  return this
}

Sign.prototype.sign = function signMethod (key, enc) {
  this.end()
  var hash = this._hash.digest()
  var sig = sign(hash, key, this._hashType, this._signType, this._tag)

  return enc ? sig.toString(enc) : sig
}

function Verify (algorithm) {
  stream.Writable.call(this)

  var data = algorithms[algorithm]
  if (!data) throw new Error('Unknown message digest')

  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Verify, stream.Writable)

Verify.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Verify.prototype.update = function update (data, enc) {
  if (typeof data === 'string') data = Buffer.from(data, enc)

  this._hash.update(data)
  return this
}

Verify.prototype.verify = function verifyMethod (key, sig, enc) {
  if (typeof sig === 'string') sig = Buffer.from(sig, enc)

  this.end()
  var hash = this._hash.digest()
  return verify(sig, hash, key, this._signType, this._tag)
}

function createSign (algorithm) {
  return new Sign(algorithm)
}

function createVerify (algorithm) {
  return new Verify(algorithm)
}

module.exports = {
  Sign: createSign,
  Verify: createVerify,
  createSign: createSign,
  createVerify: createVerify
}


/***/ }),

/***/ 55454:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var Buffer = (__webpack_require__(80480).Buffer)
var createHmac = __webpack_require__(69254)
var crt = __webpack_require__(20208)
var EC = (__webpack_require__(46067).ec)
var BN = __webpack_require__(73182)
var parseKeys = __webpack_require__(62992)
var curves = __webpack_require__(35121)

function sign (hash, key, hashType, signType, tag) {
  var priv = parseKeys(key)
  if (priv.curve) {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')
    return ecSign(hash, priv)
  } else if (priv.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong private key type')
    return dsaSign(hash, priv, hashType)
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')
  }
  hash = Buffer.concat([tag, hash])
  var len = priv.modulus.byteLength()
  var pad = [0, 1]
  while (hash.length + pad.length + 1 < len) pad.push(0xff)
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) pad.push(hash[i])

  var out = crt(pad, priv)
  return out
}

function ecSign (hash, priv) {
  var curveId = curves[priv.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + priv.curve.join('.'))

  var curve = new EC(curveId)
  var key = curve.keyFromPrivate(priv.privateKey)
  var out = key.sign(hash)

  return Buffer.from(out.toDER())
}

function dsaSign (hash, priv, algo) {
  var x = priv.params.priv_key
  var p = priv.params.p
  var q = priv.params.q
  var g = priv.params.g
  var r = new BN(0)
  var k
  var H = bits2int(hash, q).mod(q)
  var s = false
  var kv = getKey(x, q, hash, algo)
  while (s === false) {
    k = makeKey(q, kv, algo)
    r = makeR(g, k, p, q)
    s = k.invm(q).imul(H.add(x.mul(r))).mod(q)
    if (s.cmpn(0) === 0) {
      s = false
      r = new BN(0)
    }
  }
  return toDER(r, s)
}

function toDER (r, s) {
  r = r.toArray()
  s = s.toArray()

  // Pad values
  if (r[0] & 0x80) r = [0].concat(r)
  if (s[0] & 0x80) s = [0].concat(s)

  var total = r.length + s.length + 4
  var res = [0x30, total, 0x02, r.length]
  res = res.concat(r, [0x02, s.length], s)
  return Buffer.from(res)
}

function getKey (x, q, hash, algo) {
  x = Buffer.from(x.toArray())
  if (x.length < q.byteLength()) {
    var zeros = Buffer.alloc(q.byteLength() - x.length)
    x = Buffer.concat([zeros, x])
  }
  var hlen = hash.length
  var hbits = bits2octets(hash, q)
  var v = Buffer.alloc(hlen)
  v.fill(1)
  var k = Buffer.alloc(hlen)
  k = createHmac(algo, k).update(v).update(Buffer.from([0])).update(x).update(hbits).digest()
  v = createHmac(algo, k).update(v).digest()
  k = createHmac(algo, k).update(v).update(Buffer.from([1])).update(x).update(hbits).digest()
  v = createHmac(algo, k).update(v).digest()
  return { k: k, v: v }
}

function bits2int (obits, q) {
  var bits = new BN(obits)
  var shift = (obits.length << 3) - q.bitLength()
  if (shift > 0) bits.ishrn(shift)
  return bits
}

function bits2octets (bits, q) {
  bits = bits2int(bits, q)
  bits = bits.mod(q)
  var out = Buffer.from(bits.toArray())
  if (out.length < q.byteLength()) {
    var zeros = Buffer.alloc(q.byteLength() - out.length)
    out = Buffer.concat([zeros, out])
  }
  return out
}

function makeKey (q, kv, algo) {
  var t
  var k

  do {
    t = Buffer.alloc(0)

    while (t.length * 8 < q.bitLength()) {
      kv.v = createHmac(algo, kv.k).update(kv.v).digest()
      t = Buffer.concat([t, kv.v])
    }

    k = bits2int(t, q)
    kv.k = createHmac(algo, kv.k).update(kv.v).update(Buffer.from([0])).digest()
    kv.v = createHmac(algo, kv.k).update(kv.v).digest()
  } while (k.cmp(q) !== -1)

  return k
}

function makeR (g, k, p, q) {
  return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q)
}

module.exports = sign
module.exports.getKey = getKey
module.exports.makeKey = makeKey


/***/ }),

/***/ 49867:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var Buffer = (__webpack_require__(80480).Buffer)
var BN = __webpack_require__(73182)
var EC = (__webpack_require__(46067).ec)
var parseKeys = __webpack_require__(62992)
var curves = __webpack_require__(35121)

function verify (sig, hash, key, signType, tag) {
  var pub = parseKeys(key)
  if (pub.type === 'ec') {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')
    return ecVerify(sig, hash, pub)
  } else if (pub.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong public key type')
    return dsaVerify(sig, hash, pub)
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')
  }
  hash = Buffer.concat([tag, hash])
  var len = pub.modulus.byteLength()
  var pad = [1]
  var padNum = 0
  while (hash.length + pad.length + 2 < len) {
    pad.push(0xff)
    padNum++
  }
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) {
    pad.push(hash[i])
  }
  pad = Buffer.from(pad)
  var red = BN.mont(pub.modulus)
  sig = new BN(sig).toRed(red)

  sig = sig.redPow(new BN(pub.publicExponent))
  sig = Buffer.from(sig.fromRed().toArray())
  var out = padNum < 8 ? 1 : 0
  len = Math.min(sig.length, pad.length)
  if (sig.length !== pad.length) out = 1

  i = -1
  while (++i < len) out |= sig[i] ^ pad[i]
  return out === 0
}

function ecVerify (sig, hash, pub) {
  var curveId = curves[pub.data.algorithm.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'))

  var curve = new EC(curveId)
  var pubkey = pub.data.subjectPrivateKey.data

  return curve.verify(hash, sig, pubkey)
}

function dsaVerify (sig, hash, pub) {
  var p = pub.data.p
  var q = pub.data.q
  var g = pub.data.g
  var y = pub.data.pub_key
  var unpacked = parseKeys.signature.decode(sig, 'der')
  var s = unpacked.s
  var r = unpacked.r
  checkValue(s, q)
  checkValue(r, q)
  var montp = BN.mont(p)
  var w = s.invm(q)
  var v = g.toRed(montp)
    .redPow(new BN(hash).mul(w).mod(q))
    .fromRed()
    .mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed())
    .mod(p)
    .mod(q)
  return v.cmp(r) === 0
}

function checkValue (b, q) {
  if (b.cmpn(0) <= 0) throw new Error('invalid sig')
  if (b.cmp(q) >= q) throw new Error('invalid sig')
}

module.exports = verify


/***/ }),

/***/ 30721:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var basex = __webpack_require__(33206)
var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'

module.exports = basex(ALPHABET)


/***/ }),

/***/ 18705:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const basex = __webpack_require__(6068)
const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'

module.exports = basex(ALPHABET)


/***/ }),

/***/ 44136:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(7661)["Buffer"];
module.exports = function xor (a, b) {
  var length = Math.min(a.length, b.length)
  var buffer = new Buffer(length)

  for (var i = 0; i < length; ++i) {
    buffer[i] = a[i] ^ b[i]
  }

  return buffer
}


/***/ }),

/***/ 37433:
/***/ ((module) => {

module.exports = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Unordered Collection",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
}


/***/ }),

/***/ 8507:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(46858);

var callBind = __webpack_require__(26210);

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};


/***/ }),

/***/ 26210:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(10243);
var GetIntrinsic = __webpack_require__(46858);

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

module.exports = function callBind(originalFunction) {
	var func = $reflectApply(bind, $call, arguments);
	if ($gOPD && $defineProperty) {
		var desc = $gOPD(func, 'length');
		if (desc.configurable) {
			// original length, plus the receiver, minus any additional arguments (after the receiver)
			$defineProperty(
				func,
				'length',
				{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
			);
		}
	}
	return func;
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}


/***/ }),

/***/ 23985:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const mh = __webpack_require__(79744)
const { Buffer } = __webpack_require__(19444)
var CIDUtil = {
  /**
   * Test if the given input is a valid CID object.
   * Returns an error message if it is not.
   * Returns undefined if it is a valid CID.
   *
   * @param {any} other
   * @returns {string}
   */
  checkCIDComponents: function (other) {
    if (other == null) {
      return 'null values are not valid CIDs'
    }

    if (!(other.version === 0 || other.version === 1)) {
      return 'Invalid version, must be a number equal to 1 or 0'
    }

    if (typeof other.codec !== 'string') {
      return 'codec must be string'
    }

    if (other.version === 0) {
      if (other.codec !== 'dag-pb') {
        return "codec must be 'dag-pb' for CIDv0"
      }
      if (other.multibaseName !== 'base58btc') {
        return "multibaseName must be 'base58btc' for CIDv0"
      }
    }

    if (!Buffer.isBuffer(other.multihash)) {
      return 'multihash must be a Buffer'
    }

    try {
      mh.validate(other.multihash)
    } catch (err) {
      let errorMsg = err.message
      if (!errorMsg) { // Just in case mh.validate() throws an error with empty error message
        errorMsg = 'Multihash validation failed'
      }
      return errorMsg
    }
  }
}

module.exports = CIDUtil


/***/ }),

/***/ 1636:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Buffer } = __webpack_require__(19444)
const mh = __webpack_require__(79744)
const multibase = __webpack_require__(34408)
const multicodec = __webpack_require__(90511)
const codecs = __webpack_require__(51887)
const CIDUtil = __webpack_require__(23985)
const withIs = __webpack_require__(21873)

/**
 * @typedef {Object} SerializedCID
 * @param {string} codec
 * @param {number} version
 * @param {Buffer} multihash
 */

/**
 * Test if the given input is a CID.
 * @function isCID
 * @memberof CID
 * @static
 * @param {any} other
 * @returns {bool}
 */

/**
 * Class representing a CID `<mbase><version><mcodec><mhash>`
 * , as defined in [ipld/cid](https://github.com/multiformats/cid).
 * @class CID
 */
class CID {
  /**
   * Create a new CID.
   *
   * The algorithm for argument input is roughly:
   * ```
   * if (cid)
   *   -> create a copy
   * else if (str)
   *   if (1st char is on multibase table) -> CID String
   *   else -> bs58 encoded multihash
   * else if (Buffer)
   *   if (1st byte is 0 or 1) -> CID
   *   else -> multihash
   * else if (Number)
   *   -> construct CID by parts
   * ```
   *
   * @param {string|Buffer|CID} version
   * @param {string} [codec]
   * @param {Buffer} [multihash]
   * @param {string} [multibaseName]
   *
   * @example
   * new CID(<version>, <codec>, <multihash>, <multibaseName>)
   * new CID(<cidStr>)
   * new CID(<cid.buffer>)
   * new CID(<multihash>)
   * new CID(<bs58 encoded multihash>)
   * new CID(<cid>)
   */
  constructor (version, codec, multihash, multibaseName) {
    if (_CID.isCID(version)) {
      // version is an exising CID instance
      const cid = version
      this.version = cid.version
      this.codec = cid.codec
      this.multihash = Buffer.from(cid.multihash)
      // Default guard for when a CID < 0.7 is passed with no multibaseName
      this.multibaseName = cid.multibaseName || (cid.version === 0 ? 'base58btc' : 'base32')
      return
    }

    if (typeof version === 'string') {
      // e.g. 'base32' or false
      const baseName = multibase.isEncoded(version)
      if (baseName) {
        // version is a CID String encoded with multibase, so v1
        const cid = multibase.decode(version)
        this.version = parseInt(cid.slice(0, 1).toString('hex'), 16)
        this.codec = multicodec.getCodec(cid.slice(1))
        this.multihash = multicodec.rmPrefix(cid.slice(1))
        this.multibaseName = baseName
      } else {
        // version is a base58btc string multihash, so v0
        this.version = 0
        this.codec = 'dag-pb'
        this.multihash = mh.fromB58String(version)
        this.multibaseName = 'base58btc'
      }
      CID.validateCID(this)
      Object.defineProperty(this, 'string', { value: version })
      return
    }

    if (Buffer.isBuffer(version)) {
      const firstByte = version.slice(0, 1)
      const v = parseInt(firstByte.toString('hex'), 16)
      if (v === 1) {
        // version is a CID buffer
        const cid = version
        this.version = v
        this.codec = multicodec.getCodec(cid.slice(1))
        this.multihash = multicodec.rmPrefix(cid.slice(1))
        this.multibaseName = 'base32'
      } else {
        // version is a raw multihash buffer, so v0
        this.version = 0
        this.codec = 'dag-pb'
        this.multihash = version
        this.multibaseName = 'base58btc'
      }
      CID.validateCID(this)
      return
    }

    // otherwise, assemble the CID from the parameters

    /**
     * @type {number}
     */
    this.version = version

    /**
     * @type {string}
     */
    this.codec = codec

    /**
     * @type {Buffer}
     */
    this.multihash = multihash

    /**
     * @type {string}
     */
    this.multibaseName = multibaseName || (version === 0 ? 'base58btc' : 'base32')

    CID.validateCID(this)
  }

  /**
   * The CID as a `Buffer`
   *
   * @return {Buffer}
   * @readonly
   *
   * @memberOf CID
   */
  get buffer () {
    let buffer = this._buffer

    if (!buffer) {
      if (this.version === 0) {
        buffer = this.multihash
      } else if (this.version === 1) {
        buffer = Buffer.concat([
          Buffer.from('01', 'hex'),
          multicodec.getCodeVarint(this.codec),
          this.multihash
        ])
      } else {
        throw new Error('unsupported version')
      }

      // Cache this buffer so it doesn't have to be recreated
      Object.defineProperty(this, '_buffer', { value: buffer })
    }

    return buffer
  }

  /**
   * Get the prefix of the CID.
   *
   * @returns {Buffer}
   * @readonly
   */
  get prefix () {
    return Buffer.concat([
      Buffer.from(`0${this.version}`, 'hex'),
      multicodec.getCodeVarint(this.codec),
      mh.prefix(this.multihash)
    ])
  }

  /**
   * Convert to a CID of version `0`.
   *
   * @returns {CID}
   */
  toV0 () {
    if (this.codec !== 'dag-pb') {
      throw new Error('Cannot convert a non dag-pb CID to CIDv0')
    }

    const { name, length } = mh.decode(this.multihash)

    if (name !== 'sha2-256') {
      throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')
    }

    if (length !== 32) {
      throw new Error('Cannot convert non 32 byte multihash CID to CIDv0')
    }

    return new _CID(0, this.codec, this.multihash)
  }

  /**
   * Convert to a CID of version `1`.
   *
   * @returns {CID}
   */
  toV1 () {
    return new _CID(1, this.codec, this.multihash)
  }

  /**
   * Encode the CID into a string.
   *
   * @param {string} [base=this.multibaseName] - Base encoding to use.
   * @returns {string}
   */
  toBaseEncodedString (base = this.multibaseName) {
    if (this.string && base === this.multibaseName) {
      return this.string
    }
    let str = null
    if (this.version === 0) {
      if (base !== 'base58btc') {
        throw new Error('not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()')
      }
      str = mh.toB58String(this.multihash)
    } else if (this.version === 1) {
      str = multibase.encode(base, this.buffer).toString()
    } else {
      throw new Error('unsupported version')
    }
    if (base === this.multibaseName) {
      // cache the string value
      Object.defineProperty(this, 'string', { value: str })
    }
    return str
  }

  /**
   * CID(QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n)
   *
   * @returns {String}
   */
  [Symbol.for('nodejs.util.inspect.custom')] () {
    return 'CID(' + this.toString() + ')'
  }

  toString (base) {
    return this.toBaseEncodedString(base)
  }

  /**
   * Serialize to a plain object.
   *
   * @returns {SerializedCID}
   */
  toJSON () {
    return {
      codec: this.codec,
      version: this.version,
      hash: this.multihash
    }
  }

  /**
   * Compare equality with another CID.
   *
   * @param {CID} other
   * @returns {bool}
   */
  equals (other) {
    return this.codec === other.codec &&
      this.version === other.version &&
      this.multihash.equals(other.multihash)
  }

  /**
   * Test if the given input is a valid CID object.
   * Throws if it is not.
   *
   * @param {any} other
   * @returns {void}
   */
  static validateCID (other) {
    const errorMsg = CIDUtil.checkCIDComponents(other)
    if (errorMsg) {
      throw new Error(errorMsg)
    }
  }
}

const _CID = withIs(CID, {
  className: 'CID',
  symbolName: '@ipld/js-cid/CID'
})

_CID.codecs = codecs

module.exports = _CID


/***/ }),

/***/ 9186:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Buffer = (__webpack_require__(80480).Buffer)
var Transform = (__webpack_require__(50190).Transform)
var StringDecoder = (__webpack_require__(56575)/* .StringDecoder */ .s)
var inherits = __webpack_require__(86778)

function CipherBase (hashMode) {
  Transform.call(this)
  this.hashMode = typeof hashMode === 'string'
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest
  } else {
    this.final = this._finalOrDigest
  }
  if (this._final) {
    this.__final = this._final
    this._final = null
  }
  this._decoder = null
  this._encoding = null
}
inherits(CipherBase, Transform)

CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = Buffer.from(data, inputEnc)
  }

  var outData = this._update(data)
  if (this.hashMode) return this

  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }

  return outData
}

CipherBase.prototype.setAutoPadding = function () {}
CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state')
}

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state')
}

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state')
}

CipherBase.prototype._transform = function (data, _, next) {
  var err
  try {
    if (this.hashMode) {
      this._update(data)
    } else {
      this.push(this._update(data))
    }
  } catch (e) {
    err = e
  } finally {
    next(err)
  }
}
CipherBase.prototype._flush = function (done) {
  var err
  try {
    this.push(this.__final())
  } catch (e) {
    err = e
  }

  done(err)
}
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this.__final() || Buffer.alloc(0)
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, fin) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc)
    this._encoding = enc
  }

  if (this._encoding !== enc) throw new Error('can\'t switch encodings')

  var out = this._decoder.write(value)
  if (fin) {
    out += this._decoder.end()
  }

  return out
}

module.exports = CipherBase


/***/ }),

/***/ 21873:
/***/ ((module) => {

"use strict";


function withIs(Class, { className, symbolName }) {
    const symbol = Symbol.for(symbolName);

    const ClassIsWrapper = {
        // The code below assigns the class wrapper to an object to trick
        // JavaScript engines to show the name of the extended class when
        // logging an instances.
        // We are assigning an anonymous class (class wrapper) to the object
        // with key `className` to keep the correct name.
        // If this is not supported it falls back to logging `ClassIsWrapper`.
        [className]: class extends Class {
            constructor(...args) {
                super(...args);
                Object.defineProperty(this, symbol, { value: true });
            }

            get [Symbol.toStringTag]() {
                return className;
            }
        },
    }[className];

    ClassIsWrapper[`is${className}`] = (obj) => !!(obj && obj[symbol]);

    return ClassIsWrapper;
}

function withIsProto(Class, { className, symbolName, withoutNew }) {
    const symbol = Symbol.for(symbolName);

    /* eslint-disable object-shorthand */
    const ClassIsWrapper = {
        [className]: function (...args) {
            if (withoutNew && !(this instanceof ClassIsWrapper)) {
                return new ClassIsWrapper(...args);
            }

            const _this = Class.call(this, ...args) || this;

            if (_this && !_this[symbol]) {
                Object.defineProperty(_this, symbol, { value: true });
            }

            return _this;
        },
    }[className];
    /* eslint-enable object-shorthand */

    ClassIsWrapper.prototype = Object.create(Class.prototype);
    ClassIsWrapper.prototype.constructor = ClassIsWrapper;

    Object.defineProperty(ClassIsWrapper.prototype, Symbol.toStringTag, {
        get() {
            return className;
        },
    });

    ClassIsWrapper[`is${className}`] = (obj) => !!(obj && obj[symbol]);

    return ClassIsWrapper;
}

module.exports = withIs;
module.exports.proto = withIsProto;


/***/ }),

/***/ 71888:
/***/ ((module) => {

/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};


/***/ }),

/***/ 43547:
/***/ ((module) => {


/**
 * Expose `Emitter`.
 */

if (true) {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.
  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};

  var args = new Array(arguments.length - 1)
    , callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};


/***/ }),

/***/ 77405:
/***/ ((module) => {


module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};

/***/ }),

/***/ 93433:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*
	ISC License

	Copyright (c) 2019, Pierre-Louis Despaigne

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted, provided that the above
	copyright notice and this permission notice appear in all copies.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
	ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

const CID = __webpack_require__(1636);

/**
 * Take any ipfsHash and convert it to a CID v1 encoded in base32.
 * @param {string} ipfsHash a regular ipfs hash either a cid v0 or v1 (v1 will remain unchanged)
 * @return {string} the resulting ipfs hash as a cid v1
 */
const cidV0ToV1Base32 = (ipfsHash) => {
	let cid = new CID(ipfsHash);
	if (cid.version === 0) {
		cid = cid.toV1();
	}
	return cid.toString('base32');
}

exports.cidV0ToV1Base32 = cidV0ToV1Base32;


/***/ }),

/***/ 80108:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
	ISC License

	Copyright (c) 2019, Pierre-Louis Despaigne

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted, provided that the above
	copyright notice and this permission notice appear in all copies.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
	ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

const multiC = __webpack_require__(4618);

const { hexStringToBuffer, profiles } = __webpack_require__(1238);
const { cidV0ToV1Base32 } = __webpack_require__(93433);

module.exports = {

	//export some helpers functions
	helpers: {
		cidV0ToV1Base32,
	},

	/**
	* Decode a Content Hash.
	* @param {string} hash an hex string containing a content hash
	* @return {string} the decoded content
	*/
	decode: function (contentHash) {
		const buffer = hexStringToBuffer(contentHash);
		const codec = multiC.getCodec(buffer);
		const value = multiC.rmPrefix(buffer);
		let profile = profiles[codec];
		if (!profile) profile = profiles['default'];
		return profile.decode(value);
	},

	/**
	* Encode an IPFS address into a content hash
	* @param {string} ipfsHash string containing an IPFS address
	* @return {string} the resulting content hash
	*/
	fromIpfs: function (ipfsHash) {
		return this.encode('ipfs-ns', ipfsHash);
	},

	/**
	* Encode a Swarm address into a content hash
	* @param {string} swarmHash string containing a Swarm address
	* @return {string} the resulting content hash
	*/
	fromSwarm: function (swarmHash) {
		return this.encode('swarm-ns', swarmHash);
	},

	/**
	* General purpose encoding function
  * @param {string} codec 
  * @param {string} value 
  */
	encode: function (codec, value) {
		let profile = profiles[codec];
		if (!profile) profile = profiles['default'];
		const encodedValue = profile.encode(value);
		return multiC.addPrefix(codec, encodedValue).toString('hex');
	},

	/**
	* Extract the codec of a content hash
	* @param {string} hash hex string containing a content hash
	* @return {string} the extracted codec
	*/
	getCodec: function (hash) {
		let buffer = hexStringToBuffer(hash);
		return multiC.getCodec(buffer);
	},
}


/***/ }),

/***/ 1238:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(7661)["Buffer"];
/*
	ISC License

	Copyright (c) 2019, Pierre-Louis Despaigne

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted, provided that the above
	copyright notice and this permission notice appear in all copies.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
	ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

const CID = __webpack_require__(1636);
const multiH = __webpack_require__(79744);

/**
 * Convert an hexadecimal string to a Buffer, the string can start with or without '0x'
 * @param {string} hex an hexadecimal value
 * @return {Buffer} the resulting Buffer
 */
const hexStringToBuffer = (hex) => {
	let prefix = hex.slice(0, 2);
	let value = hex.slice(2);
	let res = '';
	if (prefix === '0x') res = value;
	else res = hex;
	return multiH.fromHexString(res);
}

/**
* list of known encoding,
* encoding should be a function that takes a `string` input,
* and return a `Buffer` result
*/
const encodes = {
  /**
  * @param {string} value
  * @return {Buffer}
  */
  swarm: (value) => {
    const multihash = multiH.encode(hexStringToBuffer(value), 'keccak-256');
		return new CID(1, 'swarm-manifest', multihash).buffer;
  },
  /**
  * @param {string} value
  * @return {Buffer}
  */
  ipfs: (value) => {
    const multihash = multiH.fromB58String(value);
    return new CID(1, 'dag-pb', multihash).buffer;
  },
  /**
  * @param {string} value
  * @return {Buffer}
  */
  utf8: (value) => {
    return Buffer.from(value, 'utf8');
  },
};

/** 
* list of known decoding,
* decoding should be a function that takes a `Buffer` input,
* and return a `string` result
*/
const decodes = {
  /**
  * @param {Buffer} value 
  */
  hexMultiHash: (value) => {
    const cid = new CID(value);
    return multiH.decode(cid.multihash).digest.toString('hex');
  },
  /**
  * @param {Buffer} value 
  */
  b58MultiHash: (value) => {
    const cid = new CID(value);
    return multiH.toB58String(cid.multihash);
  },
  /**
  * @param {Buffer} value 
  */
  utf8: (value) => {
    return value.toString('utf8');
  },
};

/**
* list of known encoding/decoding for a given codec,
* `encode` should be chosen among the `encodes` functions
* `decode` should be chosen among the `decodes` functions
*/
const profiles = {
  'swarm-ns': {
    encode: encodes.swarm,
    decode: decodes.hexMultiHash,
  },
  'ipfs-ns': {
    encode: encodes.ipfs,
    decode: decodes.b58MultiHash,
  },
  'ipns-ns': {
    encode: encodes.ipfs,
    decode: decodes.b58MultiHash,
  },
  'default': {
    encode: encodes.utf8,
    decode: decodes.utf8,
  },
};

exports.hexStringToBuffer = hexStringToBuffer;
exports.profiles = profiles;

/***/ }),

/***/ 40945:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(7661).Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


/***/ }),

/***/ 57812:
/***/ ((__unused_webpack_module, exports) => {

/*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */
/* vim: set ts=2: */
/*exported CRC32 */
var CRC32;
(function (factory) {
	/*jshint ignore:start */
	/*eslint-disable */
	if(typeof DO_NOT_EXPORT_CRC === 'undefined') {
		if(true) {
			factory(exports);
		} else {}
	} else {
		factory(CRC32 = {});
	}
	/*eslint-enable */
	/*jshint ignore:end */
}(function(CRC32) {
CRC32.version = '1.2.2';
/*global Int32Array */
function signed_crc_table() {
	var c = 0, table = new Array(256);

	for(var n =0; n != 256; ++n){
		c = n;
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		table[n] = c;
	}

	return typeof Int32Array !== 'undefined' ? new Int32Array(table) : table;
}

var T0 = signed_crc_table();
function slice_by_16_tables(T) {
	var c = 0, v = 0, n = 0, table = typeof Int32Array !== 'undefined' ? new Int32Array(4096) : new Array(4096) ;

	for(n = 0; n != 256; ++n) table[n] = T[n];
	for(n = 0; n != 256; ++n) {
		v = T[n];
		for(c = 256 + n; c < 4096; c += 256) v = table[c] = (v >>> 8) ^ T[v & 0xFF];
	}
	var out = [];
	for(n = 1; n != 16; ++n) out[n - 1] = typeof Int32Array !== 'undefined' ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
	return out;
}
var TT = slice_by_16_tables(T0);
var T1 = TT[0],  T2 = TT[1],  T3 = TT[2],  T4 = TT[3],  T5 = TT[4];
var T6 = TT[5],  T7 = TT[6],  T8 = TT[7],  T9 = TT[8],  Ta = TT[9];
var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
function crc32_bstr(bstr, seed) {
	var C = seed ^ -1;
	for(var i = 0, L = bstr.length; i < L;) C = (C>>>8) ^ T0[(C^bstr.charCodeAt(i++))&0xFF];
	return ~C;
}

function crc32_buf(B, seed) {
	var C = seed ^ -1, L = B.length - 15, i = 0;
	for(; i < L;) C =
		Tf[B[i++] ^ (C & 255)] ^
		Te[B[i++] ^ ((C >> 8) & 255)] ^
		Td[B[i++] ^ ((C >> 16) & 255)] ^
		Tc[B[i++] ^ (C >>> 24)] ^
		Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^
		T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^
		T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
	L += 15;
	while(i < L) C = (C>>>8) ^ T0[(C^B[i++])&0xFF];
	return ~C;
}

function crc32_str(str, seed) {
	var C = seed ^ -1;
	for(var i = 0, L = str.length, c = 0, d = 0; i < L;) {
		c = str.charCodeAt(i++);
		if(c < 0x80) {
			C = (C>>>8) ^ T0[(C^c)&0xFF];
		} else if(c < 0x800) {
			C = (C>>>8) ^ T0[(C ^ (192|((c>>6)&31)))&0xFF];
			C = (C>>>8) ^ T0[(C ^ (128|(c&63)))&0xFF];
		} else if(c >= 0xD800 && c < 0xE000) {
			c = (c&1023)+64; d = str.charCodeAt(i++)&1023;
			C = (C>>>8) ^ T0[(C ^ (240|((c>>8)&7)))&0xFF];
			C = (C>>>8) ^ T0[(C ^ (128|((c>>2)&63)))&0xFF];
			C = (C>>>8) ^ T0[(C ^ (128|((d>>6)&15)|((c&3)<<4)))&0xFF];
			C = (C>>>8) ^ T0[(C ^ (128|(d&63)))&0xFF];
		} else {
			C = (C>>>8) ^ T0[(C ^ (224|((c>>12)&15)))&0xFF];
			C = (C>>>8) ^ T0[(C ^ (128|((c>>6)&63)))&0xFF];
			C = (C>>>8) ^ T0[(C ^ (128|(c&63)))&0xFF];
		}
	}
	return ~C;
}
CRC32.table = T0;
// $FlowIgnore
CRC32.bstr = crc32_bstr;
// $FlowIgnore
CRC32.buf = crc32_buf;
// $FlowIgnore
CRC32.str = crc32_str;
}));


/***/ }),

/***/ 66090:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(7661)["Buffer"];
var elliptic = __webpack_require__(46067)
var BN = __webpack_require__(73117)

module.exports = function createECDH (curve) {
  return new ECDH(curve)
}

var aliases = {
  secp256k1: {
    name: 'secp256k1',
    byteLength: 32
  },
  secp224r1: {
    name: 'p224',
    byteLength: 28
  },
  prime256v1: {
    name: 'p256',
    byteLength: 32
  },
  prime192v1: {
    name: 'p192',
    byteLength: 24
  },
  ed25519: {
    name: 'ed25519',
    byteLength: 32
  },
  secp384r1: {
    name: 'p384',
    byteLength: 48
  },
  secp521r1: {
    name: 'p521',
    byteLength: 66
  }
}

aliases.p224 = aliases.secp224r1
aliases.p256 = aliases.secp256r1 = aliases.prime256v1
aliases.p192 = aliases.secp192r1 = aliases.prime192v1
aliases.p384 = aliases.secp384r1
aliases.p521 = aliases.secp521r1

function ECDH (curve) {
  this.curveType = aliases[curve]
  if (!this.curveType) {
    this.curveType = {
      name: curve
    }
  }
  this.curve = new elliptic.ec(this.curveType.name) // eslint-disable-line new-cap
  this.keys = void 0
}

ECDH.prototype.generateKeys = function (enc, format) {
  this.keys = this.curve.genKeyPair()
  return this.getPublicKey(enc, format)
}

ECDH.prototype.computeSecret = function (other, inenc, enc) {
  inenc = inenc || 'utf8'
  if (!Buffer.isBuffer(other)) {
    other = new Buffer(other, inenc)
  }
  var otherPub = this.curve.keyFromPublic(other).getPublic()
  var out = otherPub.mul(this.keys.getPrivate()).getX()
  return formatReturnValue(out, enc, this.curveType.byteLength)
}

ECDH.prototype.getPublicKey = function (enc, format) {
  var key = this.keys.getPublic(format === 'compressed', true)
  if (format === 'hybrid') {
    if (key[key.length - 1] % 2) {
      key[0] = 7
    } else {
      key[0] = 6
    }
  }
  return formatReturnValue(key, enc)
}

ECDH.prototype.getPrivateKey = function (enc) {
  return formatReturnValue(this.keys.getPrivate(), enc)
}

ECDH.prototype.setPublicKey = function (pub, enc) {
  enc = enc || 'utf8'
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc)
  }
  this.keys._importPublic(pub)
  return this
}

ECDH.prototype.setPrivateKey = function (priv, enc) {
  enc = enc || 'utf8'
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc)
  }

  var _priv = new BN(priv)
  _priv = _priv.toString(16)
  this.keys = this.curve.genKeyPair()
  this.keys._importPrivate(_priv)
  return this
}

function formatReturnValue (bn, enc, len) {
  if (!Array.isArray(bn)) {
    bn = bn.toArray()
  }
  var buf = new Buffer(bn)
  if (len && buf.length < len) {
    var zeros = new Buffer(len - buf.length)
    zeros.fill(0)
    buf = Buffer.concat([zeros, buf])
  }
  if (!enc) {
    return buf
  } else {
    return buf.toString(enc)
  }
}


/***/ }),

/***/ 68066:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var inherits = __webpack_require__(86778)
var MD5 = __webpack_require__(51101)
var RIPEMD160 = __webpack_require__(95009)
var sha = __webpack_require__(60913)
var Base = __webpack_require__(9186)

function Hash (hash) {
  Base.call(this, 'digest')

  this._hash = hash
}

inherits(Hash, Base)

Hash.prototype._update = function (data) {
  this._hash.update(data)
}

Hash.prototype._final = function () {
  return this._hash.digest()
}

module.exports = function createHash (alg) {
  alg = alg.toLowerCase()
  if (alg === 'md5') return new MD5()
  if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160()

  return new Hash(sha(alg))
}


/***/ }),

/***/ 1610:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var MD5 = __webpack_require__(51101)

module.exports = function (buffer) {
  return new MD5().update(buffer).digest()
}


/***/ }),

/***/ 69254:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var inherits = __webpack_require__(86778)
var Legacy = __webpack_require__(25046)
var Base = __webpack_require__(9186)
var Buffer = (__webpack_require__(80480).Buffer)
var md5 = __webpack_require__(1610)
var RIPEMD160 = __webpack_require__(95009)

var sha = __webpack_require__(60913)

var ZEROS = Buffer.alloc(128)

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  this._alg = alg
  this._key = key
  if (key.length > blocksize) {
    var hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
    key = hash.update(key).digest()
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }
  this._hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
  this._hash.update(ipad)
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.update(data)
}

Hmac.prototype._final = function () {
  var h = this._hash.digest()
  var hash = this._alg === 'rmd160' ? new RIPEMD160() : sha(this._alg)
  return hash.update(this._opad).update(h).digest()
}

module.exports = function createHmac (alg, key) {
  alg = alg.toLowerCase()
  if (alg === 'rmd160' || alg === 'ripemd160') {
    return new Hmac('rmd160', key)
  }
  if (alg === 'md5') {
    return new Legacy(md5, key)
  }
  return new Hmac(alg, key)
}


/***/ }),

/***/ 25046:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var inherits = __webpack_require__(86778)
var Buffer = (__webpack_require__(80480).Buffer)

var Base = __webpack_require__(9186)

var ZEROS = Buffer.alloc(128)
var blocksize = 64

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  this._alg = alg
  this._key = key

  if (key.length > blocksize) {
    key = alg(key)
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  this._hash = [ipad]
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.push(data)
}

Hmac.prototype._final = function () {
  var h = this._alg(Buffer.concat(this._hash))
  return this._alg(Buffer.concat([this._opad, h]))
}
module.exports = Hmac


/***/ }),

/***/ 49562:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = __webpack_require__(44613)
exports.createHash = exports.Hash = __webpack_require__(68066)
exports.createHmac = exports.Hmac = __webpack_require__(69254)

var algos = __webpack_require__(69080)
var algoKeys = Object.keys(algos)
var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(algoKeys)
exports.getHashes = function () {
  return hashes
}

var p = __webpack_require__(3070)
exports.pbkdf2 = p.pbkdf2
exports.pbkdf2Sync = p.pbkdf2Sync

var aes = __webpack_require__(90666)

exports.Cipher = aes.Cipher
exports.createCipher = aes.createCipher
exports.Cipheriv = aes.Cipheriv
exports.createCipheriv = aes.createCipheriv
exports.Decipher = aes.Decipher
exports.createDecipher = aes.createDecipher
exports.Decipheriv = aes.Decipheriv
exports.createDecipheriv = aes.createDecipheriv
exports.getCiphers = aes.getCiphers
exports.listCiphers = aes.listCiphers

var dh = __webpack_require__(86973)

exports.DiffieHellmanGroup = dh.DiffieHellmanGroup
exports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup
exports.getDiffieHellman = dh.getDiffieHellman
exports.createDiffieHellman = dh.createDiffieHellman
exports.DiffieHellman = dh.DiffieHellman

var sign = __webpack_require__(79914)

exports.createSign = sign.createSign
exports.Sign = sign.Sign
exports.createVerify = sign.createVerify
exports.Verify = sign.Verify

exports.createECDH = __webpack_require__(66090)

var publicEncrypt = __webpack_require__(95796)

exports.publicEncrypt = publicEncrypt.publicEncrypt
exports.privateEncrypt = publicEncrypt.privateEncrypt
exports.publicDecrypt = publicEncrypt.publicDecrypt
exports.privateDecrypt = publicEncrypt.privateDecrypt

// the least I can do is make error messages for the rest of the node.js/crypto api.
// ;[
//   'createCredentials'
// ].forEach(function (name) {
//   exports[name] = function () {
//     throw new Error([
//       'sorry, ' + name + ' is not implemented yet',
//       'we accept pull requests',
//       'https://github.com/crypto-browserify/crypto-browserify'
//     ].join('\n'))
//   }
// })

var rf = __webpack_require__(32693)

exports.randomFill = rf.randomFill
exports.randomFillSync = rf.randomFillSync

exports.createCredentials = function () {
  throw new Error([
    'sorry, createCredentials is not implemented yet',
    'we accept pull requests',
    'https://github.com/crypto-browserify/crypto-browserify'
  ].join('\n'))
}

exports.constants = {
  'DH_CHECK_P_NOT_SAFE_PRIME': 2,
  'DH_CHECK_P_NOT_PRIME': 1,
  'DH_UNABLE_TO_CHECK_GENERATOR': 4,
  'DH_NOT_SUITABLE_GENERATOR': 8,
  'NPN_ENABLED': 1,
  'ALPN_ENABLED': 1,
  'RSA_PKCS1_PADDING': 1,
  'RSA_SSLV23_PADDING': 2,
  'RSA_NO_PADDING': 3,
  'RSA_PKCS1_OAEP_PADDING': 4,
  'RSA_X931_PADDING': 5,
  'RSA_PKCS1_PSS_PADDING': 6,
  'POINT_CONVERSION_COMPRESSED': 2,
  'POINT_CONVERSION_UNCOMPRESSED': 4,
  'POINT_CONVERSION_HYBRID': 6
}


/***/ }),

/***/ 50141:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;
/* eslint-env browser */
/* global globalThis:readonly */


// Ponyfill for `globalThis`
const _globalThis = (() => {
	if (typeof globalThis !== 'undefined') {
		return globalThis;
	}

	if (typeof self !== 'undefined') {
		return self;
	}

	/* istanbul ignore next */
	if (typeof window !== 'undefined') {
		return window;
	}

	/* istanbul ignore next */
	if (typeof __webpack_require__.g !== 'undefined') {
		return __webpack_require__.g;
	}
})();

const bufferToHex = buffer => {
	const view = new DataView(buffer);

	let hexCodes = '';
	for (let i = 0; i < view.byteLength; i += 4) {
		hexCodes += view.getUint32(i).toString(16).padStart(8, '0');
	}

	return hexCodes;
};

const create = algorithm => async (buffer, options) => {
	if (typeof buffer === 'string') {
		buffer = new _globalThis.TextEncoder().encode(buffer);
	}

	options = {
		outputFormat: 'hex',
		...options
	};

	const hash = await _globalThis.crypto.subtle.digest(algorithm, buffer);

	return options.outputFormat === 'hex' ? bufferToHex(hash) : hash;
};

__webpack_unused_export__ = create('SHA-1');
exports.JQ = create('SHA-256');
__webpack_unused_export__ = create('SHA-384');
__webpack_unused_export__ = create('SHA-512');


/***/ }),

/***/ 43976:
/***/ ((module) => {

"use strict";

var token = '%[a-f0-9]{2}';
var singleMatcher = new RegExp('(' + token + ')|([^%]+?)', 'gi');
var multiMatcher = new RegExp('(' + token + ')+', 'gi');

function decodeComponents(components, split) {
	try {
		// Try to decode the entire string first
		return [decodeURIComponent(components.join(''))];
	} catch (err) {
		// Do nothing
	}

	if (components.length === 1) {
		return components;
	}

	split = split || 1;

	// Split the array in 2 parts
	var left = components.slice(0, split);
	var right = components.slice(split);

	return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}

function decode(input) {
	try {
		return decodeURIComponent(input);
	} catch (err) {
		var tokens = input.match(singleMatcher) || [];

		for (var i = 1; i < tokens.length; i++) {
			input = decodeComponents(tokens, i).join('');

			tokens = input.match(singleMatcher) || [];
		}

		return input;
	}
}

function customDecodeURIComponent(input) {
	// Keep track of all the replacements and prefill the map with the `BOM`
	var replaceMap = {
		'%FE%FF': '\uFFFD\uFFFD',
		'%FF%FE': '\uFFFD\uFFFD'
	};

	var match = multiMatcher.exec(input);
	while (match) {
		try {
			// Decode as big chunks as possible
			replaceMap[match[0]] = decodeURIComponent(match[0]);
		} catch (err) {
			var result = decode(match[0]);

			if (result !== match[0]) {
				replaceMap[match[0]] = result;
			}
		}

		match = multiMatcher.exec(input);
	}

	// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else
	replaceMap['%C2'] = '\uFFFD';

	var entries = Object.keys(replaceMap);

	for (var i = 0; i < entries.length; i++) {
		// Replace all decoded components
		var key = entries[i];
		input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
	}

	return input;
}

module.exports = function (encodedURI) {
	if (typeof encodedURI !== 'string') {
		throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
	}

	try {
		encodedURI = encodedURI.replace(/\+/g, ' ');

		// Try the built in decoder first
		return decodeURIComponent(encodedURI);
	} catch (err) {
		// Fallback to a more advanced decoder
		return customDecodeURIComponent(encodedURI);
	}
};


/***/ }),

/***/ 34448:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var keys = __webpack_require__(98519);
var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var hasPropertyDescriptors = __webpack_require__(68936)();

var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;

var defineProperty = function (object, name, value, predicate) {
	if (name in object) {
		if (predicate === true) {
			if (object[name] === value) {
				return;
			}
		} else if (!isFunction(predicate) || !predicate()) {
			return;
		}
	}
	if (supportsDescriptors) {
		origDefineProperty(object, name, {
			configurable: true,
			enumerable: false,
			value: value,
			writable: true
		});
	} else {
		object[name] = value; // eslint-disable-line no-param-reassign
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = concat.call(props, Object.getOwnPropertySymbols(map));
	}
	for (var i = 0; i < props.length; i += 1) {
		defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
	}
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;


/***/ }),

/***/ 79534:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.utils = __webpack_require__(61766);
exports.Cipher = __webpack_require__(67509);
exports.DES = __webpack_require__(97597);
exports.CBC = __webpack_require__(83607);
exports.EDE = __webpack_require__(66897);


/***/ }),

/***/ 83607:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var assert = __webpack_require__(17118);
var inherits = __webpack_require__(86778);

var proto = {};

function CBCState(iv) {
  assert.equal(iv.length, 8, 'Invalid IV length');

  this.iv = new Array(8);
  for (var i = 0; i < this.iv.length; i++)
    this.iv[i] = iv[i];
}

function instantiate(Base) {
  function CBC(options) {
    Base.call(this, options);
    this._cbcInit();
  }
  inherits(CBC, Base);

  var keys = Object.keys(proto);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    CBC.prototype[key] = proto[key];
  }

  CBC.create = function create(options) {
    return new CBC(options);
  };

  return CBC;
}

exports.instantiate = instantiate;

proto._cbcInit = function _cbcInit() {
  var state = new CBCState(this.options.iv);
  this._cbcState = state;
};

proto._update = function _update(inp, inOff, out, outOff) {
  var state = this._cbcState;
  var superProto = this.constructor.super_.prototype;

  var iv = state.iv;
  if (this.type === 'encrypt') {
    for (var i = 0; i < this.blockSize; i++)
      iv[i] ^= inp[inOff + i];

    superProto._update.call(this, iv, 0, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = out[outOff + i];
  } else {
    superProto._update.call(this, inp, inOff, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      out[outOff + i] ^= iv[i];

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = inp[inOff + i];
  }
};


/***/ }),

/***/ 67509:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var assert = __webpack_require__(17118);

function Cipher(options) {
  this.options = options;

  this.type = this.options.type;
  this.blockSize = 8;
  this._init();

  this.buffer = new Array(this.blockSize);
  this.bufferOff = 0;
}
module.exports = Cipher;

Cipher.prototype._init = function _init() {
  // Might be overrided
};

Cipher.prototype.update = function update(data) {
  if (data.length === 0)
    return [];

  if (this.type === 'decrypt')
    return this._updateDecrypt(data);
  else
    return this._updateEncrypt(data);
};

Cipher.prototype._buffer = function _buffer(data, off) {
  // Append data to buffer
  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
  for (var i = 0; i < min; i++)
    this.buffer[this.bufferOff + i] = data[off + i];
  this.bufferOff += min;

  // Shift next
  return min;
};

Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
  this._update(this.buffer, 0, out, off);
  this.bufferOff = 0;
  return this.blockSize;
};

Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = ((this.bufferOff + data.length) / this.blockSize) | 0;
  var out = new Array(count * this.blockSize);

  if (this.bufferOff !== 0) {
    inputOff += this._buffer(data, inputOff);

    if (this.bufferOff === this.buffer.length)
      outputOff += this._flushBuffer(out, outputOff);
  }

  // Write blocks
  var max = data.length - ((data.length - inputOff) % this.blockSize);
  for (; inputOff < max; inputOff += this.blockSize) {
    this._update(data, inputOff, out, outputOff);
    outputOff += this.blockSize;
  }

  // Queue rest
  for (; inputOff < data.length; inputOff++, this.bufferOff++)
    this.buffer[this.bufferOff] = data[inputOff];

  return out;
};

Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
  var out = new Array(count * this.blockSize);

  // TODO(indutny): optimize it, this is far from optimal
  for (; count > 0; count--) {
    inputOff += this._buffer(data, inputOff);
    outputOff += this._flushBuffer(out, outputOff);
  }

  // Buffer rest of the input
  inputOff += this._buffer(data, inputOff);

  return out;
};

Cipher.prototype.final = function final(buffer) {
  var first;
  if (buffer)
    first = this.update(buffer);

  var last;
  if (this.type === 'encrypt')
    last = this._finalEncrypt();
  else
    last = this._finalDecrypt();

  if (first)
    return first.concat(last);
  else
    return last;
};

Cipher.prototype._pad = function _pad(buffer, off) {
  if (off === 0)
    return false;

  while (off < buffer.length)
    buffer[off++] = 0;

  return true;
};

Cipher.prototype._finalEncrypt = function _finalEncrypt() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];

  var out = new Array(this.blockSize);
  this._update(this.buffer, 0, out, 0);
  return out;
};

Cipher.prototype._unpad = function _unpad(buffer) {
  return buffer;
};

Cipher.prototype._finalDecrypt = function _finalDecrypt() {
  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');
  var out = new Array(this.blockSize);
  this._flushBuffer(out, 0);

  return this._unpad(out);
};


/***/ }),

/***/ 97597:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var assert = __webpack_require__(17118);
var inherits = __webpack_require__(86778);

var utils = __webpack_require__(61766);
var Cipher = __webpack_require__(67509);

function DESState() {
  this.tmp = new Array(2);
  this.keys = null;
}

function DES(options) {
  Cipher.call(this, options);

  var state = new DESState();
  this._desState = state;

  this.deriveKeys(state, options.key);
}
inherits(DES, Cipher);
module.exports = DES;

DES.create = function create(options) {
  return new DES(options);
};

var shiftTable = [
  1, 1, 2, 2, 2, 2, 2, 2,
  1, 2, 2, 2, 2, 2, 2, 1
];

DES.prototype.deriveKeys = function deriveKeys(state, key) {
  state.keys = new Array(16 * 2);

  assert.equal(key.length, this.blockSize, 'Invalid key length');

  var kL = utils.readUInt32BE(key, 0);
  var kR = utils.readUInt32BE(key, 4);

  utils.pc1(kL, kR, state.tmp, 0);
  kL = state.tmp[0];
  kR = state.tmp[1];
  for (var i = 0; i < state.keys.length; i += 2) {
    var shift = shiftTable[i >>> 1];
    kL = utils.r28shl(kL, shift);
    kR = utils.r28shl(kR, shift);
    utils.pc2(kL, kR, state.keys, i);
  }
};

DES.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._desState;

  var l = utils.readUInt32BE(inp, inOff);
  var r = utils.readUInt32BE(inp, inOff + 4);

  // Initial Permutation
  utils.ip(l, r, state.tmp, 0);
  l = state.tmp[0];
  r = state.tmp[1];

  if (this.type === 'encrypt')
    this._encrypt(state, l, r, state.tmp, 0);
  else
    this._decrypt(state, l, r, state.tmp, 0);

  l = state.tmp[0];
  r = state.tmp[1];

  utils.writeUInt32BE(out, l, outOff);
  utils.writeUInt32BE(out, r, outOff + 4);
};

DES.prototype._pad = function _pad(buffer, off) {
  var value = buffer.length - off;
  for (var i = off; i < buffer.length; i++)
    buffer[i] = value;

  return true;
};

DES.prototype._unpad = function _unpad(buffer) {
  var pad = buffer[buffer.length - 1];
  for (var i = buffer.length - pad; i < buffer.length; i++)
    assert.equal(buffer[i], pad);

  return buffer.slice(0, buffer.length - pad);
};

DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
  var l = lStart;
  var r = rStart;

  // Apply f() x16 times
  for (var i = 0; i < state.keys.length; i += 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(r, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = r;
    r = (l ^ f) >>> 0;
    l = t;
  }

  // Reverse Initial Permutation
  utils.rip(r, l, out, off);
};

DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
  var l = rStart;
  var r = lStart;

  // Apply f() x16 times
  for (var i = state.keys.length - 2; i >= 0; i -= 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(l, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = l;
    l = (r ^ f) >>> 0;
    r = t;
  }

  // Reverse Initial Permutation
  utils.rip(l, r, out, off);
};


/***/ }),

/***/ 66897:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var assert = __webpack_require__(17118);
var inherits = __webpack_require__(86778);

var Cipher = __webpack_require__(67509);
var DES = __webpack_require__(97597);

function EDEState(type, key) {
  assert.equal(key.length, 24, 'Invalid key length');

  var k1 = key.slice(0, 8);
  var k2 = key.slice(8, 16);
  var k3 = key.slice(16, 24);

  if (type === 'encrypt') {
    this.ciphers = [
      DES.create({ type: 'encrypt', key: k1 }),
      DES.create({ type: 'decrypt', key: k2 }),
      DES.create({ type: 'encrypt', key: k3 })
    ];
  } else {
    this.ciphers = [
      DES.create({ type: 'decrypt', key: k3 }),
      DES.create({ type: 'encrypt', key: k2 }),
      DES.create({ type: 'decrypt', key: k1 })
    ];
  }
}

function EDE(options) {
  Cipher.call(this, options);

  var state = new EDEState(this.type, this.options.key);
  this._edeState = state;
}
inherits(EDE, Cipher);

module.exports = EDE;

EDE.create = function create(options) {
  return new EDE(options);
};

EDE.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._edeState;

  state.ciphers[0]._update(inp, inOff, out, outOff);
  state.ciphers[1]._update(out, outOff, out, outOff);
  state.ciphers[2]._update(out, outOff, out, outOff);
};

EDE.prototype._pad = DES.prototype._pad;
EDE.prototype._unpad = DES.prototype._unpad;


/***/ }),

/***/ 61766:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.readUInt32BE = function readUInt32BE(bytes, off) {
  var res =  (bytes[0 + off] << 24) |
             (bytes[1 + off] << 16) |
             (bytes[2 + off] << 8) |
             bytes[3 + off];
  return res >>> 0;
};

exports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
  bytes[0 + off] = value >>> 24;
  bytes[1 + off] = (value >>> 16) & 0xff;
  bytes[2 + off] = (value >>> 8) & 0xff;
  bytes[3 + off] = value & 0xff;
};

exports.ip = function ip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
    }
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.rip = function rip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 0; i < 4; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }
  for (var i = 4; i < 8; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.pc1 = function pc1(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  // 7, 15, 23, 31, 39, 47, 55, 63
  // 6, 14, 22, 30, 39, 47, 55, 63
  // 5, 13, 21, 29, 39, 47, 55, 63
  // 4, 12, 20, 28
  for (var i = 7; i >= 5; i--) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outL <<= 1;
    outL |= (inR >> (j + i)) & 1;
  }

  // 1, 9, 17, 25, 33, 41, 49, 57
  // 2, 10, 18, 26, 34, 42, 50, 58
  // 3, 11, 19, 27, 35, 43, 51, 59
  // 36, 44, 52, 60
  for (var i = 1; i <= 3; i++) {
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outR <<= 1;
    outR |= (inL >> (j + i)) & 1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.r28shl = function r28shl(num, shift) {
  return ((num << shift) & 0xfffffff) | (num >>> (28 - shift));
};

var pc2table = [
  // inL => outL
  14, 11, 17, 4, 27, 23, 25, 0,
  13, 22, 7, 18, 5, 9, 16, 24,
  2, 20, 12, 21, 1, 8, 15, 26,

  // inR => outR
  15, 4, 25, 19, 9, 1, 26, 16,
  5, 11, 23, 8, 12, 7, 17, 0,
  22, 3, 10, 14, 6, 20, 27, 24
];

exports.pc2 = function pc2(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  var len = pc2table.length >>> 1;
  for (var i = 0; i < len; i++) {
    outL <<= 1;
    outL |= (inL >>> pc2table[i]) & 0x1;
  }
  for (var i = len; i < pc2table.length; i++) {
    outR <<= 1;
    outR |= (inR >>> pc2table[i]) & 0x1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.expand = function expand(r, out, off) {
  var outL = 0;
  var outR = 0;

  outL = ((r & 1) << 5) | (r >>> 27);
  for (var i = 23; i >= 15; i -= 4) {
    outL <<= 6;
    outL |= (r >>> i) & 0x3f;
  }
  for (var i = 11; i >= 3; i -= 4) {
    outR |= (r >>> i) & 0x3f;
    outR <<= 6;
  }
  outR |= ((r & 0x1f) << 1) | (r >>> 31);

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

var sTable = [
  14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1,
  3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8,
  4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7,
  15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13,

  15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14,
  9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5,
  0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2,
  5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9,

  10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10,
  1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1,
  13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7,
  11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12,

  7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3,
  1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9,
  10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8,
  15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14,

  2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1,
  8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6,
  4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13,
  15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3,

  12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5,
  0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8,
  9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10,
  7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13,

  4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10,
  3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6,
  1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7,
  10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12,

  13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4,
  10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2,
  7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13,
  0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11
];

exports.substitute = function substitute(inL, inR) {
  var out = 0;
  for (var i = 0; i < 4; i++) {
    var b = (inL >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  for (var i = 0; i < 4; i++) {
    var b = (inR >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[4 * 0x40 + i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  return out >>> 0;
};

var permuteTable = [
  16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22,
  30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7
];

exports.permute = function permute(num) {
  var out = 0;
  for (var i = 0; i < permuteTable.length; i++) {
    out <<= 1;
    out |= (num >>> permuteTable[i]) & 0x1;
  }
  return out >>> 0;
};

exports.padSplit = function padSplit(num, size, group) {
  var str = num.toString(2);
  while (str.length < size)
    str = '0' + str;

  var out = [];
  for (var i = 0; i < size; i += group)
    out.push(str.slice(i, i + group));
  return out.join(' ');
};


/***/ }),

/***/ 26874:
/***/ ((module) => {

function detect() {
  if (typeof navigator !== 'undefined') {
    return parseUserAgent(navigator.userAgent);
  }

  return getNodeVersion();
}

function detectOS(userAgentString) {
  var rules = getOperatingSystemRules();
  var detected = rules.filter(function (os) {
    return os.rule && os.rule.test(userAgentString);
  })[0];

  return detected ? detected.name : null;
}

function getNodeVersion() {
  var isNode = typeof process !== 'undefined' && "v20.0.0";
  return isNode && {
    name: 'node',
    version: "v20.0.0".slice(1),
    os: process.platform
  };
}

function parseUserAgent(userAgentString) {
  var browsers = getBrowserRules();
  if (!userAgentString) {
    return null;
  }

  var detected = browsers.map(function(browser) {
    var match = browser.rule.exec(userAgentString);
    var version = match && match[1].split(/[._]/).slice(0,3);

    if (version && version.length < 3) {
      version = version.concat(version.length == 1 ? [0, 0] : [0]);
    }

    return match && {
      name: browser.name,
      version: version.join('.')
    };
  }).filter(Boolean)[0] || null;

  if (detected) {
    detected.os = detectOS(userAgentString);
  }

  if (/alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/i.test(userAgentString)) {
    detected = detected || {};
    detected.bot = true;
  }

  return detected;
}

function getBrowserRules() {
  return buildRules([
    [ 'aol', /AOLShield\/([0-9\._]+)/ ],
    [ 'edge', /Edge\/([0-9\._]+)/ ],
    [ 'yandexbrowser', /YaBrowser\/([0-9\._]+)/ ],
    [ 'vivaldi', /Vivaldi\/([0-9\.]+)/ ],
    [ 'kakaotalk', /KAKAOTALK\s([0-9\.]+)/ ],
    [ 'samsung', /SamsungBrowser\/([0-9\.]+)/ ],
    [ 'chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/ ],
    [ 'phantomjs', /PhantomJS\/([0-9\.]+)(:?\s|$)/ ],
    [ 'crios', /CriOS\/([0-9\.]+)(:?\s|$)/ ],
    [ 'firefox', /Firefox\/([0-9\.]+)(?:\s|$)/ ],
    [ 'fxios', /FxiOS\/([0-9\.]+)/ ],
    [ 'opera', /Opera\/([0-9\.]+)(?:\s|$)/ ],
    [ 'opera', /OPR\/([0-9\.]+)(:?\s|$)$/ ],
    [ 'ie', /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/ ],
    [ 'ie', /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/ ],
    [ 'ie', /MSIE\s(7\.0)/ ],
    [ 'bb10', /BB10;\sTouch.*Version\/([0-9\.]+)/ ],
    [ 'android', /Android\s([0-9\.]+)/ ],
    [ 'ios', /Version\/([0-9\._]+).*Mobile.*Safari.*/ ],
    [ 'safari', /Version\/([0-9\._]+).*Safari/ ],
    [ 'facebook', /FBAV\/([0-9\.]+)/],
    [ 'instagram', /Instagram\s([0-9\.]+)/],
    [ 'ios-webview', /AppleWebKit\/([0-9\.]+).*Mobile/]
  ]);
}

function getOperatingSystemRules() {
  return buildRules([
    [ 'iOS', /iP(hone|od|ad)/ ],
    [ 'Android OS', /Android/ ],
    [ 'BlackBerry OS', /BlackBerry|BB10/ ],
    [ 'Windows Mobile', /IEMobile/ ],
    [ 'Amazon OS', /Kindle/ ],
    [ 'Windows 3.11', /Win16/ ],
    [ 'Windows 95', /(Windows 95)|(Win95)|(Windows_95)/ ],
    [ 'Windows 98', /(Windows 98)|(Win98)/ ],
    [ 'Windows 2000', /(Windows NT 5.0)|(Windows 2000)/ ],
    [ 'Windows XP', /(Windows NT 5.1)|(Windows XP)/ ],
    [ 'Windows Server 2003', /(Windows NT 5.2)/ ],
    [ 'Windows Vista', /(Windows NT 6.0)/ ],
    [ 'Windows 7', /(Windows NT 6.1)/ ],
    [ 'Windows 8', /(Windows NT 6.2)/ ],
    [ 'Windows 8.1', /(Windows NT 6.3)/ ],
    [ 'Windows 10', /(Windows NT 10.0)/ ],
    [ 'Windows ME', /Windows ME/ ],
    [ 'Open BSD', /OpenBSD/ ],
    [ 'Sun OS', /SunOS/ ],
    [ 'Linux', /(Linux)|(X11)/ ],
    [ 'Mac OS', /(Mac_PowerPC)|(Macintosh)/ ],
    [ 'QNX', /QNX/ ],
    [ 'BeOS', /BeOS/ ],
    [ 'OS/2', /OS\/2/ ],
    [ 'Search Bot', /(nuhk)|(Googlebot)|(Yammybot)|(Openbot)|(Slurp)|(MSNBot)|(Ask Jeeves\/Teoma)|(ia_archiver)/ ]
  ]);
}

function buildRules(ruleTuples) {
  return ruleTuples.map(function(tuple) {
    return {
      name: tuple[0],
      rule: tuple[1]
    };
  });
}

module.exports = {
  detect: detect,
  detectOS: detectOS,
  getNodeVersion: getNodeVersion,
  parseUserAgent: parseUserAgent
};


/***/ }),

/***/ 48410:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BotInfo: () => (/* binding */ BotInfo),
/* harmony export */   BrowserInfo: () => (/* binding */ BrowserInfo),
/* harmony export */   NodeInfo: () => (/* binding */ NodeInfo),
/* harmony export */   ReactNativeInfo: () => (/* binding */ ReactNativeInfo),
/* harmony export */   SearchBotDeviceInfo: () => (/* binding */ SearchBotDeviceInfo),
/* harmony export */   browserName: () => (/* binding */ browserName),
/* harmony export */   detect: () => (/* binding */ detect),
/* harmony export */   detectOS: () => (/* binding */ detectOS),
/* harmony export */   getNodeVersion: () => (/* binding */ getNodeVersion),
/* harmony export */   parseUserAgent: () => (/* binding */ parseUserAgent)
/* harmony export */ });
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var BrowserInfo = /** @class */ (function () {
    function BrowserInfo(name, version, os) {
        this.name = name;
        this.version = version;
        this.os = os;
        this.type = 'browser';
    }
    return BrowserInfo;
}());

var NodeInfo = /** @class */ (function () {
    function NodeInfo(version) {
        this.version = version;
        this.type = 'node';
        this.name = 'node';
        this.os = process.platform;
    }
    return NodeInfo;
}());

var SearchBotDeviceInfo = /** @class */ (function () {
    function SearchBotDeviceInfo(name, version, os, bot) {
        this.name = name;
        this.version = version;
        this.os = os;
        this.bot = bot;
        this.type = 'bot-device';
    }
    return SearchBotDeviceInfo;
}());

var BotInfo = /** @class */ (function () {
    function BotInfo() {
        this.type = 'bot';
        this.bot = true; // NOTE: deprecated test name instead
        this.name = 'bot';
        this.version = null;
        this.os = null;
    }
    return BotInfo;
}());

var ReactNativeInfo = /** @class */ (function () {
    function ReactNativeInfo() {
        this.type = 'react-native';
        this.name = 'react-native';
        this.version = null;
        this.os = null;
    }
    return ReactNativeInfo;
}());

// tslint:disable-next-line:max-line-length
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
    ['aol', /AOLShield\/([0-9\._]+)/],
    ['edge', /Edge\/([0-9\._]+)/],
    ['edge-ios', /EdgiOS\/([0-9\._]+)/],
    ['yandexbrowser', /YaBrowser\/([0-9\._]+)/],
    ['kakaotalk', /KAKAOTALK\s([0-9\.]+)/],
    ['samsung', /SamsungBrowser\/([0-9\.]+)/],
    ['silk', /\bSilk\/([0-9._-]+)\b/],
    ['miui', /MiuiBrowser\/([0-9\.]+)$/],
    ['beaker', /BeakerBrowser\/([0-9\.]+)/],
    ['edge-chromium', /EdgA?\/([0-9\.]+)/],
    [
        'chromium-webview',
        /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/,
    ],
    ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
    ['phantomjs', /PhantomJS\/([0-9\.]+)(:?\s|$)/],
    ['crios', /CriOS\/([0-9\.]+)(:?\s|$)/],
    ['firefox', /Firefox\/([0-9\.]+)(?:\s|$)/],
    ['fxios', /FxiOS\/([0-9\.]+)/],
    ['opera-mini', /Opera Mini.*Version\/([0-9\.]+)/],
    ['opera', /Opera\/([0-9\.]+)(?:\s|$)/],
    ['opera', /OPR\/([0-9\.]+)(:?\s|$)/],
    ['pie', /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
    ['pie', /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
    ['netfront', /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
    ['ie', /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
    ['ie', /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
    ['ie', /MSIE\s(7\.0)/],
    ['bb10', /BB10;\sTouch.*Version\/([0-9\.]+)/],
    ['android', /Android\s([0-9\.]+)/],
    ['ios', /Version\/([0-9\._]+).*Mobile.*Safari.*/],
    ['safari', /Version\/([0-9\._]+).*Safari/],
    ['facebook', /FB[AS]V\/([0-9\.]+)/],
    ['instagram', /Instagram\s([0-9\.]+)/],
    ['ios-webview', /AppleWebKit\/([0-9\.]+).*Mobile/],
    ['ios-webview', /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
    ['curl', /^curl\/([0-9\.]+)$/],
    ['searchbot', SEARCHBOX_UA_REGEX],
];
var operatingSystemRules = [
    ['iOS', /iP(hone|od|ad)/],
    ['Android OS', /Android/],
    ['BlackBerry OS', /BlackBerry|BB10/],
    ['Windows Mobile', /IEMobile/],
    ['Amazon OS', /Kindle/],
    ['Windows 3.11', /Win16/],
    ['Windows 95', /(Windows 95)|(Win95)|(Windows_95)/],
    ['Windows 98', /(Windows 98)|(Win98)/],
    ['Windows 2000', /(Windows NT 5.0)|(Windows 2000)/],
    ['Windows XP', /(Windows NT 5.1)|(Windows XP)/],
    ['Windows Server 2003', /(Windows NT 5.2)/],
    ['Windows Vista', /(Windows NT 6.0)/],
    ['Windows 7', /(Windows NT 6.1)/],
    ['Windows 8', /(Windows NT 6.2)/],
    ['Windows 8.1', /(Windows NT 6.3)/],
    ['Windows 10', /(Windows NT 10.0)/],
    ['Windows ME', /Windows ME/],
    ['Windows CE', /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
    ['Open BSD', /OpenBSD/],
    ['Sun OS', /SunOS/],
    ['Chrome OS', /CrOS/],
    ['Linux', /(Linux)|(X11)/],
    ['Mac OS', /(Mac_PowerPC)|(Macintosh)/],
    ['QNX', /QNX/],
    ['BeOS', /BeOS/],
    ['OS/2', /OS\/2/],
];
function detect(userAgent) {
    if (!!userAgent) {
        return parseUserAgent(userAgent);
    }
    if (typeof document === 'undefined' &&
        typeof navigator !== 'undefined' &&
        navigator.product === 'ReactNative') {
        return new ReactNativeInfo();
    }
    if (typeof navigator !== 'undefined') {
        return parseUserAgent(navigator.userAgent);
    }
    return getNodeVersion();
}
function matchUserAgent(ua) {
    // opted for using reduce here rather than Array#first with a regex.test call
    // this is primarily because using the reduce we only perform the regex
    // execution once rather than once for the test and for the exec again below
    // probably something that needs to be benchmarked though
    return (ua !== '' &&
        userAgentRules.reduce(function (matched, _a) {
            var browser = _a[0], regex = _a[1];
            if (matched) {
                return matched;
            }
            var uaMatch = regex.exec(ua);
            return !!uaMatch && [browser, uaMatch];
        }, false));
}
function browserName(ua) {
    var data = matchUserAgent(ua);
    return data ? data[0] : null;
}
function parseUserAgent(ua) {
    var matchedRule = matchUserAgent(ua);
    if (!matchedRule) {
        return null;
    }
    var name = matchedRule[0], match = matchedRule[1];
    if (name === 'searchbot') {
        return new BotInfo();
    }
    // Do not use RegExp for split operation as some browser do not support it (See: http://blog.stevenlevithan.com/archives/cross-browser-split)
    var versionParts = match[1] && match[1].split('.').join('_').split('_').slice(0, 3);
    if (versionParts) {
        if (versionParts.length < REQUIRED_VERSION_PARTS) {
            versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
        }
    }
    else {
        versionParts = [];
    }
    var version = versionParts.join('.');
    var os = detectOS(ua);
    var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
    if (searchBotMatch && searchBotMatch[1]) {
        return new SearchBotDeviceInfo(name, version, os, searchBotMatch[1]);
    }
    return new BrowserInfo(name, version, os);
}
function detectOS(ua) {
    for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
        var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];
        var match = regex.exec(ua);
        if (match) {
            return os;
        }
    }
    return null;
}
function getNodeVersion() {
    var isNode = typeof process !== 'undefined' && "v20.0.0";
    return isNode ? new NodeInfo("v20.0.0".slice(1)) : null;
}
function createVersionParts(count) {
    var output = [];
    for (var ii = 0; ii < count; ii++) {
        output.push('0');
    }
    return output;
}


/***/ }),

/***/ 86973:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(7661)["Buffer"];
var generatePrime = __webpack_require__(80158)
var primes = __webpack_require__(57592)

var DH = __webpack_require__(16675)

function getDiffieHellman (mod) {
  var prime = new Buffer(primes[mod].prime, 'hex')
  var gen = new Buffer(primes[mod].gen, 'hex')

  return new DH(prime, gen)
}

var ENCODINGS = {
  'binary': true, 'hex': true, 'base64': true
}

function createDiffieHellman (prime, enc, generator, genc) {
  if (Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) {
    return createDiffieHellman(prime, 'binary', enc, generator)
  }

  enc = enc || 'binary'
  genc = genc || 'binary'
  generator = generator || new Buffer([2])

  if (!Buffer.isBuffer(generator)) {
    generator = new Buffer(generator, genc)
  }

  if (typeof prime === 'number') {
    return new DH(generatePrime(prime, generator), generator, true)
  }

  if (!Buffer.isBuffer(prime)) {
    prime = new Buffer(prime, enc)
  }

  return new DH(prime, generator, true)
}

exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman
exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman


/***/ }),

/***/ 16675:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(7661)["Buffer"];
var BN = __webpack_require__(73117);
var MillerRabin = __webpack_require__(40162);
var millerRabin = new MillerRabin();
var TWENTYFOUR = new BN(24);
var ELEVEN = new BN(11);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var primes = __webpack_require__(80158);
var randomBytes = __webpack_require__(44613);
module.exports = DH;

function setPublicKey(pub, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc);
  }
  this._pub = new BN(pub);
  return this;
}

function setPrivateKey(priv, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc);
  }
  this._priv = new BN(priv);
  return this;
}

var primeCache = {};
function checkPrime(prime, generator) {
  var gen = generator.toString('hex');
  var hex = [gen, prime.toString(16)].join('_');
  if (hex in primeCache) {
    return primeCache[hex];
  }
  var error = 0;

  if (prime.isEven() ||
    !primes.simpleSieve ||
    !primes.fermatTest(prime) ||
    !millerRabin.test(prime)) {
    //not a prime so +1
    error += 1;

    if (gen === '02' || gen === '05') {
      // we'd be able to check the generator
      // it would fail so +8
      error += 8;
    } else {
      //we wouldn't be able to test the generator
      // so +4
      error += 4;
    }
    primeCache[hex] = error;
    return error;
  }
  if (!millerRabin.test(prime.shrn(1))) {
    //not a safe prime
    error += 2;
  }
  var rem;
  switch (gen) {
    case '02':
      if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
        // unsuidable generator
        error += 8;
      }
      break;
    case '05':
      rem = prime.mod(TEN);
      if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
        // prime mod 10 needs to equal 3 or 7
        error += 8;
      }
      break;
    default:
      error += 4;
  }
  primeCache[hex] = error;
  return error;
}

function DH(prime, generator, malleable) {
  this.setGenerator(generator);
  this.__prime = new BN(prime);
  this._prime = BN.mont(this.__prime);
  this._primeLen = prime.length;
  this._pub = undefined;
  this._priv = undefined;
  this._primeCode = undefined;
  if (malleable) {
    this.setPublicKey = setPublicKey;
    this.setPrivateKey = setPrivateKey;
  } else {
    this._primeCode = 8;
  }
}
Object.defineProperty(DH.prototype, 'verifyError', {
  enumerable: true,
  get: function () {
    if (typeof this._primeCode !== 'number') {
      this._primeCode = checkPrime(this.__prime, this.__gen);
    }
    return this._primeCode;
  }
});
DH.prototype.generateKeys = function () {
  if (!this._priv) {
    this._priv = new BN(randomBytes(this._primeLen));
  }
  this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
  return this.getPublicKey();
};

DH.prototype.computeSecret = function (other) {
  other = new BN(other);
  other = other.toRed(this._prime);
  var secret = other.redPow(this._priv).fromRed();
  var out = new Buffer(secret.toArray());
  var prime = this.getPrime();
  if (out.length < prime.length) {
    var front = new Buffer(prime.length - out.length);
    front.fill(0);
    out = Buffer.concat([front, out]);
  }
  return out;
};

DH.prototype.getPublicKey = function getPublicKey(enc) {
  return formatReturnValue(this._pub, enc);
};

DH.prototype.getPrivateKey = function getPrivateKey(enc) {
  return formatReturnValue(this._priv, enc);
};

DH.prototype.getPrime = function (enc) {
  return formatReturnValue(this.__prime, enc);
};

DH.prototype.getGenerator = function (enc) {
  return formatReturnValue(this._gen, enc);
};

DH.prototype.setGenerator = function (gen, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(gen)) {
    gen = new Buffer(gen, enc);
  }
  this.__gen = gen;
  this._gen = new BN(gen);
  return this;
};

function formatReturnValue(bn, enc) {
  var buf = new Buffer(bn.toArray());
  if (!enc) {
    return buf;
  } else {
    return buf.toString(enc);
  }
}


/***/ }),

/***/ 80158:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var randomBytes = __webpack_require__(44613);
module.exports = findPrime;
findPrime.simpleSieve = simpleSieve;
findPrime.fermatTest = fermatTest;
var BN = __webpack_require__(73117);
var TWENTYFOUR = new BN(24);
var MillerRabin = __webpack_require__(40162);
var millerRabin = new MillerRabin();
var ONE = new BN(1);
var TWO = new BN(2);
var FIVE = new BN(5);
var SIXTEEN = new BN(16);
var EIGHT = new BN(8);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var ELEVEN = new BN(11);
var FOUR = new BN(4);
var TWELVE = new BN(12);
var primes = null;

function _getPrimes() {
  if (primes !== null)
    return primes;

  var limit = 0x100000;
  var res = [];
  res[0] = 2;
  for (var i = 1, k = 3; k < limit; k += 2) {
    var sqrt = Math.ceil(Math.sqrt(k));
    for (var j = 0; j < i && res[j] <= sqrt; j++)
      if (k % res[j] === 0)
        break;

    if (i !== j && res[j] <= sqrt)
      continue;

    res[i++] = k;
  }
  primes = res;
  return res;
}

function simpleSieve(p) {
  var primes = _getPrimes();

  for (var i = 0; i < primes.length; i++)
    if (p.modn(primes[i]) === 0) {
      if (p.cmpn(primes[i]) === 0) {
        return true;
      } else {
        return false;
      }
    }

  return true;
}

function fermatTest(p) {
  var red = BN.mont(p);
  return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
}

function findPrime(bits, gen) {
  if (bits < 16) {
    // this is what openssl does
    if (gen === 2 || gen === 5) {
      return new BN([0x8c, 0x7b]);
    } else {
      return new BN([0x8c, 0x27]);
    }
  }
  gen = new BN(gen);

  var num, n2;

  while (true) {
    num = new BN(randomBytes(Math.ceil(bits / 8)));
    while (num.bitLength() > bits) {
      num.ishrn(1);
    }
    if (num.isEven()) {
      num.iadd(ONE);
    }
    if (!num.testn(1)) {
      num.iadd(TWO);
    }
    if (!gen.cmp(TWO)) {
      while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
        num.iadd(FOUR);
      }
    } else if (!gen.cmp(FIVE)) {
      while (num.mod(TEN).cmp(THREE)) {
        num.iadd(FOUR);
      }
    }
    n2 = num.shrn(1);
    if (simpleSieve(n2) && simpleSieve(num) &&
      fermatTest(n2) && fermatTest(num) &&
      millerRabin.test(n2) && millerRabin.test(num)) {
      return num;
    }
  }

}


/***/ }),

/***/ 93978:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var __webpack_provided_process_dot_nextTick = __webpack_require__(52528);
var once = __webpack_require__(71578);

var noop = function() {};

var isRequest = function(stream) {
	return stream.setHeader && typeof stream.abort === 'function';
};

var isChildProcess = function(stream) {
	return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
};

var eos = function(stream, opts, callback) {
	if (typeof opts === 'function') return eos(stream, null, opts);
	if (!opts) opts = {};

	callback = once(callback || noop);

	var ws = stream._writableState;
	var rs = stream._readableState;
	var readable = opts.readable || (opts.readable !== false && stream.readable);
	var writable = opts.writable || (opts.writable !== false && stream.writable);
	var cancelled = false;

	var onlegacyfinish = function() {
		if (!stream.writable) onfinish();
	};

	var onfinish = function() {
		writable = false;
		if (!readable) callback.call(stream);
	};

	var onend = function() {
		readable = false;
		if (!writable) callback.call(stream);
	};

	var onexit = function(exitCode) {
		callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);
	};

	var onerror = function(err) {
		callback.call(stream, err);
	};

	var onclose = function() {
		__webpack_provided_process_dot_nextTick(onclosenexttick);
	};

	var onclosenexttick = function() {
		if (cancelled) return;
		if (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream, new Error('premature close'));
		if (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream, new Error('premature close'));
	};

	var onrequest = function() {
		stream.req.on('finish', onfinish);
	};

	if (isRequest(stream)) {
		stream.on('complete', onfinish);
		stream.on('abort', onclose);
		if (stream.req) onrequest();
		else stream.on('request', onrequest);
	} else if (writable && !ws) { // legacy streams
		stream.on('end', onlegacyfinish);
		stream.on('close', onlegacyfinish);
	}

	if (isChildProcess(stream)) stream.on('exit', onexit);

	stream.on('end', onend);
	stream.on('finish', onfinish);
	if (opts.error !== false) stream.on('error', onerror);
	stream.on('close', onclose);

	return function() {
		cancelled = true;
		stream.removeListener('complete', onfinish);
		stream.removeListener('abort', onclose);
		stream.removeListener('request', onrequest);
		if (stream.req) stream.req.removeListener('finish', onfinish);
		stream.removeListener('end', onlegacyfinish);
		stream.removeListener('close', onlegacyfinish);
		stream.removeListener('finish', onfinish);
		stream.removeListener('exit', onexit);
		stream.removeListener('end', onend);
		stream.removeListener('error', onerror);
		stream.removeListener('close', onclose);
	};
};

module.exports = eos;


/***/ }),

/***/ 79653:
/***/ ((module) => {

var naiveFallback = function () {
	if (typeof self === "object" && self) return self;
	if (typeof window === "object" && window) return window;
	throw new Error("Unable to resolve global `this`");
};

module.exports = (function () {
	if (this) return this;

	// Unexpected strict mode (may happen if e.g. bundled into ESM module)

	// Fallback to standard globalThis if available
	if (typeof globalThis === "object" && globalThis) return globalThis;

	// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis
	// In all ES5+ engines global object inherits from Object.prototype
	// (if you approached one that doesn't please report)
	try {
		Object.defineProperty(Object.prototype, "__global__", {
			get: function () { return this; },
			configurable: true
		});
	} catch (error) {
		// Unfortunate case of updates to Object.prototype being restricted
		// via preventExtensions, seal or freeze
		return naiveFallback();
	}
	try {
		// Safari case (window.__global__ works, but __global__ does not)
		if (!__global__) return naiveFallback();
		return __global__;
	} finally {
		delete Object.prototype.__global__;
	}
})();


/***/ }),

/***/ 69920:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(7661)["Buffer"];
var sha3 = (__webpack_require__(57106).keccak_256)
var uts46 = __webpack_require__(6413)

function namehash (inputName) {
  // Reject empty names:
  var node = ''
  for (var i = 0; i < 32; i++) {
    node += '00'
  }

  name = normalize(inputName)

  if (name) {
    var labels = name.split('.')

    for(var i = labels.length - 1; i >= 0; i--) {
      var labelSha = sha3(labels[i])
      node = sha3(new Buffer(node + labelSha, 'hex'))
    }
  }

  return '0x' + node
}

function normalize(name) {
  return name ? uts46.toUnicode(name, {useStd3ASCII: true, transitional: false}) : name
}

exports.hash = namehash
exports.normalize = normalize


/***/ }),

/***/ 2340:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EthereumProviderError = exports.EthereumRpcError = void 0;
const fast_safe_stringify_1 = __webpack_require__(24015);
/**
 * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors
 * per EIP-1474.
 * Permits any integer error code.
 */
class EthereumRpcError extends Error {
    constructor(code, message, data) {
        if (!Number.isInteger(code)) {
            throw new Error('"code" must be an integer.');
        }
        if (!message || typeof message !== 'string') {
            throw new Error('"message" must be a nonempty string.');
        }
        super(message);
        this.code = code;
        if (data !== undefined) {
            this.data = data;
        }
    }
    /**
     * Returns a plain object with all public class properties.
     */
    serialize() {
        const serialized = {
            code: this.code,
            message: this.message,
        };
        if (this.data !== undefined) {
            serialized.data = this.data;
        }
        if (this.stack) {
            serialized.stack = this.stack;
        }
        return serialized;
    }
    /**
     * Return a string representation of the serialized error, omitting
     * any circular references.
     */
    toString() {
        return fast_safe_stringify_1.default(this.serialize(), stringifyReplacer, 2);
    }
}
exports.EthereumRpcError = EthereumRpcError;
/**
 * Error subclass implementing Ethereum Provider errors per EIP-1193.
 * Permits integer error codes in the [ 1000 <= 4999 ] range.
 */
class EthereumProviderError extends EthereumRpcError {
    /**
     * Create an Ethereum Provider JSON-RPC error.
     * `code` must be an integer in the 1000 <= 4999 range.
     */
    constructor(code, message, data) {
        if (!isValidEthProviderCode(code)) {
            throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
        }
        super(code, message, data);
    }
}
exports.EthereumProviderError = EthereumProviderError;
// Internal
function isValidEthProviderCode(code) {
    return Number.isInteger(code) && code >= 1000 && code <= 4999;
}
function stringifyReplacer(_, value) {
    if (value === '[Circular]') {
        return undefined;
    }
    return value;
}


/***/ }),

/***/ 18203:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.errorValues = exports.errorCodes = void 0;
exports.errorCodes = {
    rpc: {
        invalidInput: -32000,
        resourceNotFound: -32001,
        resourceUnavailable: -32002,
        transactionRejected: -32003,
        methodNotSupported: -32004,
        limitExceeded: -32005,
        parse: -32700,
        invalidRequest: -32600,
        methodNotFound: -32601,
        invalidParams: -32602,
        internal: -32603,
    },
    provider: {
        userRejectedRequest: 4001,
        unauthorized: 4100,
        unsupportedMethod: 4200,
        disconnected: 4900,
        chainDisconnected: 4901,
    },
};
exports.errorValues = {
    '-32700': {
        standard: 'JSON RPC 2.0',
        message: 'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.',
    },
    '-32600': {
        standard: 'JSON RPC 2.0',
        message: 'The JSON sent is not a valid Request object.',
    },
    '-32601': {
        standard: 'JSON RPC 2.0',
        message: 'The method does not exist / is not available.',
    },
    '-32602': {
        standard: 'JSON RPC 2.0',
        message: 'Invalid method parameter(s).',
    },
    '-32603': {
        standard: 'JSON RPC 2.0',
        message: 'Internal JSON-RPC error.',
    },
    '-32000': {
        standard: 'EIP-1474',
        message: 'Invalid input.',
    },
    '-32001': {
        standard: 'EIP-1474',
        message: 'Resource not found.',
    },
    '-32002': {
        standard: 'EIP-1474',
        message: 'Resource unavailable.',
    },
    '-32003': {
        standard: 'EIP-1474',
        message: 'Transaction rejected.',
    },
    '-32004': {
        standard: 'EIP-1474',
        message: 'Method not supported.',
    },
    '-32005': {
        standard: 'EIP-1474',
        message: 'Request limit exceeded.',
    },
    '4001': {
        standard: 'EIP-1193',
        message: 'User rejected the request.',
    },
    '4100': {
        standard: 'EIP-1193',
        message: 'The requested account and/or method has not been authorized by the user.',
    },
    '4200': {
        standard: 'EIP-1193',
        message: 'The requested method is not supported by this Ethereum provider.',
    },
    '4900': {
        standard: 'EIP-1193',
        message: 'The provider is disconnected from all chains.',
    },
    '4901': {
        standard: 'EIP-1193',
        message: 'The provider is disconnected from the specified chain.',
    },
};


/***/ }),

/***/ 61526:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ethErrors = void 0;
const classes_1 = __webpack_require__(2340);
const utils_1 = __webpack_require__(87125);
const error_constants_1 = __webpack_require__(18203);
exports.ethErrors = {
    rpc: {
        /**
         * Get a JSON RPC 2.0 Parse (-32700) error.
         */
        parse: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg),
        /**
         * Get a JSON RPC 2.0 Invalid Request (-32600) error.
         */
        invalidRequest: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg),
        /**
         * Get a JSON RPC 2.0 Invalid Params (-32602) error.
         */
        invalidParams: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg),
        /**
         * Get a JSON RPC 2.0 Method Not Found (-32601) error.
         */
        methodNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg),
        /**
         * Get a JSON RPC 2.0 Internal (-32603) error.
         */
        internal: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg),
        /**
         * Get a JSON RPC 2.0 Server error.
         * Permits integer error codes in the [ -32099 <= -32005 ] range.
         * Codes -32000 through -32004 are reserved by EIP-1474.
         */
        server: (opts) => {
            if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {
                throw new Error('Ethereum RPC Server errors must provide single object argument.');
            }
            const { code } = opts;
            if (!Number.isInteger(code) || code > -32005 || code < -32099) {
                throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
            }
            return getEthJsonRpcError(code, opts);
        },
        /**
         * Get an Ethereum JSON RPC Invalid Input (-32000) error.
         */
        invalidInput: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg),
        /**
         * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
         */
        resourceNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg),
        /**
         * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
         */
        resourceUnavailable: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg),
        /**
         * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
         */
        transactionRejected: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg),
        /**
         * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
         */
        methodNotSupported: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg),
        /**
         * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
         */
        limitExceeded: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg),
    },
    provider: {
        /**
         * Get an Ethereum Provider User Rejected Request (4001) error.
         */
        userRejectedRequest: (arg) => {
            return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);
        },
        /**
         * Get an Ethereum Provider Unauthorized (4100) error.
         */
        unauthorized: (arg) => {
            return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);
        },
        /**
         * Get an Ethereum Provider Unsupported Method (4200) error.
         */
        unsupportedMethod: (arg) => {
            return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);
        },
        /**
         * Get an Ethereum Provider Not Connected (4900) error.
         */
        disconnected: (arg) => {
            return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);
        },
        /**
         * Get an Ethereum Provider Chain Not Connected (4901) error.
         */
        chainDisconnected: (arg) => {
            return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);
        },
        /**
         * Get a custom Ethereum Provider error.
         */
        custom: (opts) => {
            if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {
                throw new Error('Ethereum Provider custom errors must provide single object argument.');
            }
            const { code, message, data } = opts;
            if (!message || typeof message !== 'string') {
                throw new Error('"message" must be a nonempty string');
            }
            return new classes_1.EthereumProviderError(code, message, data);
        },
    },
};
// Internal
function getEthJsonRpcError(code, arg) {
    const [message, data] = parseOpts(arg);
    return new classes_1.EthereumRpcError(code, message || utils_1.getMessageFromCode(code), data);
}
function getEthProviderError(code, arg) {
    const [message, data] = parseOpts(arg);
    return new classes_1.EthereumProviderError(code, message || utils_1.getMessageFromCode(code), data);
}
function parseOpts(arg) {
    if (arg) {
        if (typeof arg === 'string') {
            return [arg];
        }
        else if (typeof arg === 'object' && !Array.isArray(arg)) {
            const { message, data } = arg;
            if (message && typeof message !== 'string') {
                throw new Error('Must specify string message.');
            }
            return [message || undefined, data];
        }
    }
    return [];
}


/***/ }),

/***/ 78914:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getMessageFromCode = exports.serializeError = exports.EthereumProviderError = exports.EthereumRpcError = exports.ethErrors = exports.errorCodes = void 0;
const classes_1 = __webpack_require__(2340);
Object.defineProperty(exports, "EthereumRpcError", ({ enumerable: true, get: function () { return classes_1.EthereumRpcError; } }));
Object.defineProperty(exports, "EthereumProviderError", ({ enumerable: true, get: function () { return classes_1.EthereumProviderError; } }));
const utils_1 = __webpack_require__(87125);
Object.defineProperty(exports, "serializeError", ({ enumerable: true, get: function () { return utils_1.serializeError; } }));
Object.defineProperty(exports, "getMessageFromCode", ({ enumerable: true, get: function () { return utils_1.getMessageFromCode; } }));
const errors_1 = __webpack_require__(61526);
Object.defineProperty(exports, "ethErrors", ({ enumerable: true, get: function () { return errors_1.ethErrors; } }));
const error_constants_1 = __webpack_require__(18203);
Object.defineProperty(exports, "errorCodes", ({ enumerable: true, get: function () { return error_constants_1.errorCodes; } }));


/***/ }),

/***/ 87125:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.serializeError = exports.isValidCode = exports.getMessageFromCode = exports.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
const error_constants_1 = __webpack_require__(18203);
const classes_1 = __webpack_require__(2340);
const FALLBACK_ERROR_CODE = error_constants_1.errorCodes.rpc.internal;
const FALLBACK_MESSAGE = 'Unspecified error message. This is a bug, please report it.';
const FALLBACK_ERROR = {
    code: FALLBACK_ERROR_CODE,
    message: getMessageFromCode(FALLBACK_ERROR_CODE),
};
exports.JSON_RPC_SERVER_ERROR_MESSAGE = 'Unspecified server error.';
/**
 * Gets the message for a given code, or a fallback message if the code has
 * no corresponding message.
 */
function getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {
    if (Number.isInteger(code)) {
        const codeString = code.toString();
        if (hasKey(error_constants_1.errorValues, codeString)) {
            return error_constants_1.errorValues[codeString].message;
        }
        if (isJsonRpcServerError(code)) {
            return exports.JSON_RPC_SERVER_ERROR_MESSAGE;
        }
    }
    return fallbackMessage;
}
exports.getMessageFromCode = getMessageFromCode;
/**
 * Returns whether the given code is valid.
 * A code is only valid if it has a message.
 */
function isValidCode(code) {
    if (!Number.isInteger(code)) {
        return false;
    }
    const codeString = code.toString();
    if (error_constants_1.errorValues[codeString]) {
        return true;
    }
    if (isJsonRpcServerError(code)) {
        return true;
    }
    return false;
}
exports.isValidCode = isValidCode;
/**
 * Serializes the given error to an Ethereum JSON RPC-compatible error object.
 * Merely copies the given error's values if it is already compatible.
 * If the given error is not fully compatible, it will be preserved on the
 * returned object's data.originalError property.
 */
function serializeError(error, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = false, } = {}) {
    var _a, _b;
    if (!fallbackError ||
        !Number.isInteger(fallbackError.code) ||
        typeof fallbackError.message !== 'string') {
        throw new Error('Must provide fallback error with integer number code and string message.');
    }
    if (error instanceof classes_1.EthereumRpcError) {
        return error.serialize();
    }
    const serialized = {};
    if (error &&
        typeof error === 'object' &&
        !Array.isArray(error) &&
        hasKey(error, 'code') &&
        isValidCode(error.code)) {
        const _error = error;
        serialized.code = _error.code;
        if (_error.message && typeof _error.message === 'string') {
            serialized.message = _error.message;
            if (hasKey(_error, 'data')) {
                serialized.data = _error.data;
            }
        }
        else {
            serialized.message = getMessageFromCode(serialized.code);
            serialized.data = { originalError: assignOriginalError(error) };
        }
    }
    else {
        serialized.code = fallbackError.code;
        const message = (_a = error) === null || _a === void 0 ? void 0 : _a.message;
        serialized.message = (message && typeof message === 'string'
            ? message
            : fallbackError.message);
        serialized.data = { originalError: assignOriginalError(error) };
    }
    const stack = (_b = error) === null || _b === void 0 ? void 0 : _b.stack;
    if (shouldIncludeStack && error && stack && typeof stack === 'string') {
        serialized.stack = stack;
    }
    return serialized;
}
exports.serializeError = serializeError;
// Internal
function isJsonRpcServerError(code) {
    return code >= -32099 && code <= -32000;
}
function assignOriginalError(error) {
    if (error && typeof error === 'object' && !Array.isArray(error)) {
        return Object.assign({}, error);
    }
    return error;
}
function hasKey(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}


/***/ }),

/***/ 51591:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils_1 = __webpack_require__(72882);
/**
 * Returns true if the bloom is a valid bloom
 * @param bloom The bloom
 */
function isBloom(bloom) {
    if (typeof bloom !== 'string') {
        return false;
    }
    if (!/^(0x)?[0-9a-f]{512}$/i.test(bloom)) {
        return false;
    }
    if (/^(0x)?[0-9a-f]{512}$/.test(bloom) ||
        /^(0x)?[0-9A-F]{512}$/.test(bloom)) {
        return true;
    }
    return false;
}
exports.isBloom = isBloom;
/**
 * Returns true if the value is part of the given bloom
 * note: false positives are possible.
 * @param bloom encoded bloom
 * @param value The value
 */
function isInBloom(bloom, value) {
    if (typeof value === 'object' && value.constructor === Uint8Array) {
        value = utils_1.bytesToHex(value);
    }
    const hash = utils_1.keccak256(value).replace('0x', '');
    for (let i = 0; i < 12; i += 4) {
        // calculate bit position in bloom filter that must be active
        const bitpos = ((parseInt(hash.substr(i, 2), 16) << 8) +
            parseInt(hash.substr(i + 2, 2), 16)) &
            2047;
        // test if bitpos in bloom is active
        const code = codePointToInt(bloom.charCodeAt(bloom.length - 1 - Math.floor(bitpos / 4)));
        const offset = 1 << bitpos % 4;
        if ((code & offset) !== offset) {
            return false;
        }
    }
    return true;
}
exports.isInBloom = isInBloom;
/**
 * Code points to int
 * @param codePoint The code point
 */
function codePointToInt(codePoint) {
    if (codePoint >= 48 && codePoint <= 57) {
        /* ['0'..'9'] -> [0..9] */
        return codePoint - 48;
    }
    if (codePoint >= 65 && codePoint <= 70) {
        /* ['A'..'F'] -> [10..15] */
        return codePoint - 55;
    }
    if (codePoint >= 97 && codePoint <= 102) {
        /* ['a'..'f'] -> [10..15] */
        return codePoint - 87;
    }
    throw new Error('invalid bloom');
}
/**
 * Returns true if the ethereum users address is part of the given bloom.
 * note: false positives are possible.
 * @param bloom encoded bloom
 * @param address the address to test
 */
function isUserEthereumAddressInBloom(bloom, ethereumAddress) {
    if (!isBloom(bloom)) {
        throw new Error('Invalid bloom given');
    }
    if (!isAddress(ethereumAddress)) {
        throw new Error(`Invalid ethereum address given: "${ethereumAddress}"`);
    }
    // you have to pad the ethereum address to 32 bytes
    // else the bloom filter does not work
    // this is only if your matching the USERS
    // ethereum address. Contract address do not need this
    // hence why we have 2 methods
    // (0x is not in the 2nd parameter of padleft so 64 chars is fine)
    const address = utils_1.padLeft(ethereumAddress, 64);
    return isInBloom(bloom, address);
}
exports.isUserEthereumAddressInBloom = isUserEthereumAddressInBloom;
/**
 * Returns true if the contract address is part of the given bloom.
 * note: false positives are possible.
 * @param bloom encoded bloom
 * @param contractAddress the contract address to test
 */
function isContractAddressInBloom(bloom, contractAddress) {
    if (!isBloom(bloom)) {
        throw new Error('Invalid bloom given');
    }
    if (!isAddress(contractAddress)) {
        throw new Error(`Invalid contract address given: "${contractAddress}"`);
    }
    return isInBloom(bloom, contractAddress);
}
exports.isContractAddressInBloom = isContractAddressInBloom;
/**
 * Returns true if the topic is part of the given bloom.
 * note: false positives are possible.
 * @param bloom encoded bloom
 * @param topic the topic encoded hex
 */
function isTopicInBloom(bloom, topic) {
    if (!isBloom(bloom)) {
        throw new Error('Invalid bloom given');
    }
    if (!isTopic(topic)) {
        throw new Error('Invalid topic');
    }
    return isInBloom(bloom, topic);
}
exports.isTopicInBloom = isTopicInBloom;
/**
 * Checks if its a valid topic
 * @param topic encoded hex topic
 */
function isTopic(topic) {
    if (typeof topic !== 'string') {
        return false;
    }
    if (!/^(0x)?[0-9a-f]{64}$/i.test(topic)) {
        return false;
    }
    else if (/^(0x)?[0-9a-f]{64}$/.test(topic) ||
        /^(0x)?[0-9A-F]{64}$/.test(topic)) {
        return true;
    }
    return false;
}
exports.isTopic = isTopic;
/**
 * Is valid address
 * @param address The address
 */
function isAddress(address) {
    if (typeof address !== 'string') {
        return false;
    }
    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
        return true;
    }
    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        return true;
    }
    return false;
}
exports.isAddress = isAddress;


/***/ }),

/***/ 72882:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const sha3 = __webpack_require__(50986);
/**
 * Keccak256 hash
 * @param data The data
 */
function keccak256(data) {
    return '0x' + sha3.keccak_256(toByteArray(data));
}
exports.keccak256 = keccak256;
/**
 * Adding padding to string on the left
 * @param value The value
 * @param chars The chars
 */
exports.padLeft = (value, chars) => {
    const hasPrefix = /^0x/i.test(value) || typeof value === 'number';
    value = value.toString().replace(/^0x/i, '');
    const padding = chars - value.length + 1 >= 0 ? chars - value.length + 1 : 0;
    return (hasPrefix ? '0x' : '') + new Array(padding).join('0') + value;
};
/**
 * Convert bytes to hex
 * @param bytes The bytes
 */
function bytesToHex(bytes) {
    const hex = [];
    for (let i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 0xf).toString(16));
    }
    return `0x${hex.join('').replace(/^0+/, '')}`;
}
exports.bytesToHex = bytesToHex;
/**
 * To byte array
 * @param value The value
 */
function toByteArray(value) {
    if (value == null) {
        throw new Error('cannot convert null value to array');
    }
    if (typeof value === 'string') {
        const match = value.match(/^(0x)?[0-9a-fA-F]*$/);
        if (!match) {
            throw new Error('invalid hexidecimal string');
        }
        if (match[1] !== '0x') {
            throw new Error('hex string must have 0x prefix');
        }
        value = value.substring(2);
        if (value.length % 2) {
            value = '0' + value;
        }
        const result = [];
        for (let i = 0; i < value.length; i += 2) {
            result.push(parseInt(value.substr(i, 2), 16));
        }
        return addSlice(new Uint8Array(result));
    }
    if (isByteArray(value)) {
        return addSlice(new Uint8Array(value));
    }
    throw new Error('invalid arrayify value');
}
exports.toByteArray = toByteArray;
/**
 * Is byte array
 * @param value The value
 */
function isByteArray(value) {
    if (!value ||
        // tslint:disable-next-line: radix
        parseInt(String(value.length)) != value.length ||
        typeof value === 'string') {
        return false;
    }
    for (let i = 0; i < value.length; i++) {
        const v = value[i];
        // tslint:disable-next-line: radix
        if (v < 0 || v >= 256 || parseInt(String(v)) != v) {
            return false;
        }
    }
    return true;
}
/**
 * Add slice to array
 * @param array The array
 */
function addSlice(array) {
    if (array.slice !== undefined) {
        return array;
    }
    array.slice = () => {
        const args = Array.prototype.slice.call(arguments);
        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
    };
    return array;
}


/***/ }),

/***/ 89959:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(7661)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
function createHashFunction(hashConstructor) {
    return function (msg) {
        var hash = hashConstructor();
        hash.update(msg);
        return Buffer.from(hash.digest());
    };
}
exports.createHashFunction = createHashFunction;


/***/ }),

/***/ 17649:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var hash_utils_1 = __webpack_require__(89959);
var createKeccakHash = __webpack_require__(30883);
exports.keccak224 = hash_utils_1.createHashFunction(function () {
    return createKeccakHash("keccak224");
});
exports.keccak256 = hash_utils_1.createHashFunction(function () {
    return createKeccakHash("keccak256");
});
exports.keccak384 = hash_utils_1.createHashFunction(function () {
    return createKeccakHash("keccak384");
});
exports.keccak512 = hash_utils_1.createHashFunction(function () {
    return createKeccakHash("keccak512");
});


/***/ }),

/***/ 12975:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var randombytes = __webpack_require__(44613);
function getRandomBytes(bytes) {
    return new Promise(function (resolve, reject) {
        randombytes(bytes, function (err, resp) {
            if (err) {
                reject(err);
                return;
            }
            resolve(resp);
        });
    });
}
exports.getRandomBytes = getRandomBytes;
function getRandomBytesSync(bytes) {
    return randombytes(bytes);
}
exports.getRandomBytesSync = getRandomBytesSync;


/***/ }),

/***/ 73181:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
var secp256k1_1 = __webpack_require__(10728);
var random_1 = __webpack_require__(12975);
var SECP256K1_PRIVATE_KEY_SIZE = 32;
function createPrivateKey() {
    return __awaiter(this, void 0, void 0, function () {
        var pk;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (false) {}
                    return [4 /*yield*/, random_1.getRandomBytes(SECP256K1_PRIVATE_KEY_SIZE)];
                case 1:
                    pk = _a.sent();
                    if (secp256k1_1.privateKeyVerify(pk)) {
                        return [2 /*return*/, pk];
                    }
                    return [3 /*break*/, 0];
                case 2: return [2 /*return*/];
            }
        });
    });
}
exports.createPrivateKey = createPrivateKey;
function createPrivateKeySync() {
    while (true) {
        var pk = random_1.getRandomBytesSync(SECP256K1_PRIVATE_KEY_SIZE);
        if (secp256k1_1.privateKeyVerify(pk)) {
            return pk;
        }
    }
}
exports.createPrivateKeySync = createPrivateKeySync;
__export(__webpack_require__(10728));


/***/ }),

/***/ 89375:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.keccak512 = exports.keccak384 = exports.keccak256 = exports.keccak224 = void 0;
const sha3_1 = __webpack_require__(83996);
const utils_js_1 = __webpack_require__(65873);
exports.keccak224 = (0, utils_js_1.wrapHash)(sha3_1.keccak_224);
exports.keccak256 = (() => {
    const k = (0, utils_js_1.wrapHash)(sha3_1.keccak_256);
    k.create = sha3_1.keccak_256.create;
    return k;
})();
exports.keccak384 = (0, utils_js_1.wrapHash)(sha3_1.keccak_384);
exports.keccak512 = (0, utils_js_1.wrapHash)(sha3_1.keccak_512);


/***/ }),

/***/ 29664:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.secp256k1 = void 0;
var secp256k1_1 = __webpack_require__(17412);
Object.defineProperty(exports, "secp256k1", ({ enumerable: true, get: function () { return secp256k1_1.secp256k1; } }));


/***/ }),

/***/ 65873:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.crypto = exports.wrapHash = exports.equalsBytes = exports.hexToBytes = exports.bytesToUtf8 = exports.utf8ToBytes = exports.createView = exports.concatBytes = exports.toHex = exports.bytesToHex = exports.assertBytes = exports.assertBool = void 0;
const _assert_1 = __importDefault(__webpack_require__(29528));
const utils_1 = __webpack_require__(86819);
const assertBool = _assert_1.default.bool;
exports.assertBool = assertBool;
const assertBytes = _assert_1.default.bytes;
exports.assertBytes = assertBytes;
var utils_2 = __webpack_require__(86819);
Object.defineProperty(exports, "bytesToHex", ({ enumerable: true, get: function () { return utils_2.bytesToHex; } }));
Object.defineProperty(exports, "toHex", ({ enumerable: true, get: function () { return utils_2.bytesToHex; } }));
Object.defineProperty(exports, "concatBytes", ({ enumerable: true, get: function () { return utils_2.concatBytes; } }));
Object.defineProperty(exports, "createView", ({ enumerable: true, get: function () { return utils_2.createView; } }));
Object.defineProperty(exports, "utf8ToBytes", ({ enumerable: true, get: function () { return utils_2.utf8ToBytes; } }));
// buf.toString('utf8') -> bytesToUtf8(buf)
function bytesToUtf8(data) {
    if (!(data instanceof Uint8Array)) {
        throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
    }
    return new TextDecoder().decode(data);
}
exports.bytesToUtf8 = bytesToUtf8;
function hexToBytes(data) {
    const sliced = data.startsWith("0x") ? data.substring(2) : data;
    return (0, utils_1.hexToBytes)(sliced);
}
exports.hexToBytes = hexToBytes;
// buf.equals(buf2) -> equalsBytes(buf, buf2)
function equalsBytes(a, b) {
    if (a.length !== b.length) {
        return false;
    }
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
exports.equalsBytes = equalsBytes;
// Internal utils
function wrapHash(hash) {
    return (msg) => {
        _assert_1.default.bytes(msg);
        return hash(msg);
    };
}
exports.wrapHash = wrapHash;
// TODO(v3): switch away from node crypto, remove this unnecessary variable.
exports.crypto = (() => {
    const webCrypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : undefined;
    const nodeRequire =  true &&
        typeof module.require === "function" &&
        module.require.bind(module);
    return {
        node: nodeRequire && !webCrypto ? nodeRequire("crypto") : undefined,
        web: webCrypto
    };
})();


/***/ }),

/***/ 58848:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var BN = __webpack_require__(95081);
var numberToBN = __webpack_require__(31638);

var zero = new BN(0);
var negative1 = new BN(-1);

// complete ethereum unit map
var unitMap = {
  'noether': '0', // eslint-disable-line
  'wei': '1', // eslint-disable-line
  'kwei': '1000', // eslint-disable-line
  'Kwei': '1000', // eslint-disable-line
  'babbage': '1000', // eslint-disable-line
  'femtoether': '1000', // eslint-disable-line
  'mwei': '1000000', // eslint-disable-line
  'Mwei': '1000000', // eslint-disable-line
  'lovelace': '1000000', // eslint-disable-line
  'picoether': '1000000', // eslint-disable-line
  'gwei': '1000000000', // eslint-disable-line
  'Gwei': '1000000000', // eslint-disable-line
  'shannon': '1000000000', // eslint-disable-line
  'nanoether': '1000000000', // eslint-disable-line
  'nano': '1000000000', // eslint-disable-line
  'szabo': '1000000000000', // eslint-disable-line
  'microether': '1000000000000', // eslint-disable-line
  'micro': '1000000000000', // eslint-disable-line
  'finney': '1000000000000000', // eslint-disable-line
  'milliether': '1000000000000000', // eslint-disable-line
  'milli': '1000000000000000', // eslint-disable-line
  'ether': '1000000000000000000', // eslint-disable-line
  'kether': '1000000000000000000000', // eslint-disable-line
  'grand': '1000000000000000000000', // eslint-disable-line
  'mether': '1000000000000000000000000', // eslint-disable-line
  'gether': '1000000000000000000000000000', // eslint-disable-line
  'tether': '1000000000000000000000000000000' };

/**
 * Returns value of unit in Wei
 *
 * @method getValueOfUnit
 * @param {String} unit the unit to convert to, default ether
 * @returns {BigNumber} value of the unit (in Wei)
 * @throws error if the unit is not correct:w
 */
function getValueOfUnit(unitInput) {
  var unit = unitInput ? unitInput.toLowerCase() : 'ether';
  var unitValue = unitMap[unit]; // eslint-disable-line

  if (typeof unitValue !== 'string') {
    throw new Error('[ethjs-unit] the unit provided ' + unitInput + ' doesn\'t exists, please use the one of the following units ' + JSON.stringify(unitMap, null, 2));
  }

  return new BN(unitValue, 10);
}

function numberToString(arg) {
  if (typeof arg === 'string') {
    if (!arg.match(/^-?[0-9.]+$/)) {
      throw new Error('while converting number to string, invalid number value \'' + arg + '\', should be a number matching (^-?[0-9.]+).');
    }
    return arg;
  } else if (typeof arg === 'number') {
    return String(arg);
  } else if (typeof arg === 'object' && arg.toString && (arg.toTwos || arg.dividedToIntegerBy)) {
    if (arg.toPrecision) {
      return String(arg.toPrecision());
    } else {
      // eslint-disable-line
      return arg.toString(10);
    }
  }
  throw new Error('while converting number to string, invalid number value \'' + arg + '\' type ' + typeof arg + '.');
}

function fromWei(weiInput, unit, optionsInput) {
  var wei = numberToBN(weiInput); // eslint-disable-line
  var negative = wei.lt(zero); // eslint-disable-line
  var base = getValueOfUnit(unit);
  var baseLength = unitMap[unit].length - 1 || 1;
  var options = optionsInput || {};

  if (negative) {
    wei = wei.mul(negative1);
  }

  var fraction = wei.mod(base).toString(10); // eslint-disable-line

  while (fraction.length < baseLength) {
    fraction = '0' + fraction;
  }

  if (!options.pad) {
    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  }

  var whole = wei.div(base).toString(10); // eslint-disable-line

  if (options.commify) {
    whole = whole.replace(/\B(?=(\d{3})+(?!\d))/g, ',');
  }

  var value = '' + whole + (fraction == '0' ? '' : '.' + fraction); // eslint-disable-line

  if (negative) {
    value = '-' + value;
  }

  return value;
}

function toWei(etherInput, unit) {
  var ether = numberToString(etherInput); // eslint-disable-line
  var base = getValueOfUnit(unit);
  var baseLength = unitMap[unit].length - 1 || 1;

  // Is it negative?
  var negative = ether.substring(0, 1) === '-'; // eslint-disable-line
  if (negative) {
    ether = ether.substring(1);
  }

  if (ether === '.') {
    throw new Error('[ethjs-unit] while converting number ' + etherInput + ' to wei, invalid value');
  }

  // Split it into a whole and fractional part
  var comps = ether.split('.'); // eslint-disable-line
  if (comps.length > 2) {
    throw new Error('[ethjs-unit] while converting number ' + etherInput + ' to wei,  too many decimal points');
  }

  var whole = comps[0],
      fraction = comps[1]; // eslint-disable-line

  if (!whole) {
    whole = '0';
  }
  if (!fraction) {
    fraction = '0';
  }
  if (fraction.length > baseLength) {
    throw new Error('[ethjs-unit] while converting number ' + etherInput + ' to wei, too many decimal places');
  }

  while (fraction.length < baseLength) {
    fraction += '0';
  }

  whole = new BN(whole);
  fraction = new BN(fraction);
  var wei = whole.mul(base).add(fraction); // eslint-disable-line

  if (negative) {
    wei = wei.mul(negative1);
  }

  return new BN(wei.toString(10), 10);
}

module.exports = {
  unitMap: unitMap,
  numberToString: numberToString,
  getValueOfUnit: getValueOfUnit,
  fromWei: fromWei,
  toWei: toWei
};

/***/ }),

/***/ 93214:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const event_iterator_1 = __webpack_require__(11216);
exports.zN = event_iterator_1.EventIterator;
function subscribe(event, options, evOptions) {
    return new event_iterator_1.EventIterator(({ push }) => {
        this.addEventListener(event, push, options);
        return () => this.removeEventListener(event, push, options);
    }, evOptions);
}
__webpack_unused_export__ = subscribe;
__webpack_unused_export__ = event_iterator_1.EventIterator;


/***/ }),

/***/ 11216:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class EventQueue {
    constructor() {
        this.pullQueue = [];
        this.pushQueue = [];
        this.eventHandlers = {};
        this.isPaused = false;
        this.isStopped = false;
    }
    push(value) {
        if (this.isStopped)
            return;
        const resolution = { value, done: false };
        if (this.pullQueue.length) {
            const placeholder = this.pullQueue.shift();
            if (placeholder)
                placeholder.resolve(resolution);
        }
        else {
            this.pushQueue.push(Promise.resolve(resolution));
            if (this.highWaterMark !== undefined &&
                this.pushQueue.length >= this.highWaterMark &&
                !this.isPaused) {
                this.isPaused = true;
                if (this.eventHandlers.highWater) {
                    this.eventHandlers.highWater();
                }
                else if (console) {
                    console.warn(`EventIterator queue reached ${this.pushQueue.length} items`);
                }
            }
        }
    }
    stop() {
        if (this.isStopped)
            return;
        this.isStopped = true;
        this.remove();
        for (const placeholder of this.pullQueue) {
            placeholder.resolve({ value: undefined, done: true });
        }
        this.pullQueue.length = 0;
    }
    fail(error) {
        if (this.isStopped)
            return;
        this.isStopped = true;
        this.remove();
        if (this.pullQueue.length) {
            for (const placeholder of this.pullQueue) {
                placeholder.reject(error);
            }
            this.pullQueue.length = 0;
        }
        else {
            const rejection = Promise.reject(error);
            /* Attach error handler to avoid leaking an unhandled promise rejection. */
            rejection.catch(() => { });
            this.pushQueue.push(rejection);
        }
    }
    remove() {
        Promise.resolve().then(() => {
            if (this.removeCallback)
                this.removeCallback();
        });
    }
    [Symbol.asyncIterator]() {
        return {
            next: (value) => {
                const result = this.pushQueue.shift();
                if (result) {
                    if (this.lowWaterMark !== undefined &&
                        this.pushQueue.length <= this.lowWaterMark &&
                        this.isPaused) {
                        this.isPaused = false;
                        if (this.eventHandlers.lowWater) {
                            this.eventHandlers.lowWater();
                        }
                    }
                    return result;
                }
                else if (this.isStopped) {
                    return Promise.resolve({ value: undefined, done: true });
                }
                else {
                    return new Promise((resolve, reject) => {
                        this.pullQueue.push({ resolve, reject });
                    });
                }
            },
            return: () => {
                this.isStopped = true;
                this.pushQueue.length = 0;
                this.remove();
                return Promise.resolve({ value: undefined, done: true });
            },
        };
    }
}
class EventIterator {
    constructor(listen, { highWaterMark = 100, lowWaterMark = 1 } = {}) {
        const queue = new EventQueue();
        queue.highWaterMark = highWaterMark;
        queue.lowWaterMark = lowWaterMark;
        queue.removeCallback =
            listen({
                push: value => queue.push(value),
                stop: () => queue.stop(),
                fail: error => queue.fail(error),
                on: (event, fn) => {
                    queue.eventHandlers[event] = fn;
                },
            }) || (() => { });
        this[Symbol.asyncIterator] = () => queue[Symbol.asyncIterator]();
        Object.freeze(this);
    }
}
exports.EventIterator = EventIterator;
exports["default"] = EventIterator;


/***/ }),

/***/ 7687:
/***/ ((module) => {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ 90630:
/***/ ((module) => {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ 58470:
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ 76778:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Buffer = (__webpack_require__(80480).Buffer)
var MD5 = __webpack_require__(51101)

/* eslint-disable camelcase */
function EVP_BytesToKey (password, salt, keyBits, ivLen) {
  if (!Buffer.isBuffer(password)) password = Buffer.from(password, 'binary')
  if (salt) {
    if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, 'binary')
    if (salt.length !== 8) throw new RangeError('salt should be Buffer with 8 byte length')
  }

  var keyLen = keyBits / 8
  var key = Buffer.alloc(keyLen)
  var iv = Buffer.alloc(ivLen || 0)
  var tmp = Buffer.alloc(0)

  while (keyLen > 0 || ivLen > 0) {
    var hash = new MD5()
    hash.update(tmp)
    hash.update(password)
    if (salt) hash.update(salt)
    tmp = hash.digest()

    var used = 0

    if (keyLen > 0) {
      var keyStart = key.length - keyLen
      used = Math.min(keyLen, tmp.length)
      tmp.copy(key, keyStart, 0, used)
      keyLen -= used
    }

    if (used < tmp.length && ivLen > 0) {
      var ivStart = iv.length - ivLen
      var length = Math.min(ivLen, tmp.length - used)
      tmp.copy(iv, ivStart, used, used + length)
      ivLen -= length
    }
  }

  tmp.fill(0)
  return { key: key, iv: iv }
}

module.exports = EVP_BytesToKey


/***/ }),

/***/ 18713:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(7661)["Buffer"];
const Duplex = (__webpack_require__(65746).Duplex)
const inherits = (__webpack_require__(37657).inherits)
const noop = function () {}

module.exports = PortDuplexStream

inherits(PortDuplexStream, Duplex)

/**
 * Creates a stream that's both readable and writable.
 * The stream supports arbitrary objects.
 *
 * @class
 * @param {Object} port Remote Port object
 */
function PortDuplexStream (port) {
  Duplex.call(this, {
    objectMode: true,
  })
  this._port = port
  port.onMessage.addListener(this._onMessage.bind(this))
  port.onDisconnect.addListener(this._onDisconnect.bind(this))
}

/**
 * Callback triggered when a message is received from
 * the remote Port associated with this Stream.
 *
 * @private
 * @param {Object} msg - Payload from the onMessage listener of Port
 */
PortDuplexStream.prototype._onMessage = function (msg) {
  if (Buffer.isBuffer(msg)) {
    delete msg._isBuffer
    var data = new Buffer(msg)
    this.push(data)
  } else {
    this.push(msg)
  }
}

/**
 * Callback triggered when the remote Port
 * associated with this Stream disconnects.
 *
 * @private
 */
PortDuplexStream.prototype._onDisconnect = function () {
  this.destroy()
}

/**
 * Explicitly sets read operations to a no-op
 */
PortDuplexStream.prototype._read = noop


/**
 * Called internally when data should be written to
 * this writable stream.
 *
 * @private
 * @param {*} msg Arbitrary object to write
 * @param {string} encoding Encoding to use when writing payload
 * @param {Function} cb Called when writing is complete or an error occurs
 */
PortDuplexStream.prototype._write = function (msg, encoding, cb) {
  try {
    if (Buffer.isBuffer(msg)) {
      var data = msg.toJSON()
      data._isBuffer = true
      this._port.postMessage(data)
    } else {
      this._port.postMessage(msg)
    }
  } catch (err) {
    return cb(new Error('PortDuplexStream - disconnected'))
  }
  cb()
}

/***/ }),

/***/ 18094:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(7661)["Buffer"];

const stream_1 = __webpack_require__(50190);
module.exports = class PortDuplexStream extends stream_1.Duplex {
    /**
     * @param port - An instance of WebExtensions Runtime.Port. See:
     * {@link https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/Port}
     */
    constructor(port) {
        super({ objectMode: true });
        this._port = port;
        this._port.onMessage.addListener((msg) => this._onMessage(msg));
        this._port.onDisconnect.addListener(() => this._onDisconnect());
    }
    /**
     * Callback triggered when a message is received from
     * the remote Port associated with this Stream.
     *
     * @param msg - Payload from the onMessage listener of the port
     */
    _onMessage(msg) {
        if (Buffer.isBuffer(msg)) {
            const data = Buffer.from(msg);
            this.push(data);
        }
        else {
            this.push(msg);
        }
    }
    /**
     * Callback triggered when the remote Port associated with this Stream
     * disconnects.
     */
    _onDisconnect() {
        this.destroy();
    }
    /**
     * Explicitly sets read operations to a no-op.
     */
    _read() {
        return undefined;
    }
    /**
     * Called internally when data should be written to this writable stream.
     *
     * @param msg - Arbitrary object to write
     * @param encoding - Encoding to use when writing payload
     * @param cb - Called when writing is complete or an error occurs
     */
    _write(msg, _encoding, cb) {
        try {
            if (Buffer.isBuffer(msg)) {
                const data = msg.toJSON();
                data._isBuffer = true;
                this._port.postMessage(data);
            }
            else {
                this._port.postMessage(msg);
            }
        }
        catch (error) {
            return cb(new Error('PortDuplexStream - disconnected'));
        }
        return cb();
    }
};


/***/ }),

/***/ 96645:
/***/ ((module) => {

"use strict";


var isArray = Array.isArray;
var keyList = Object.keys;
var hasProp = Object.prototype.hasOwnProperty;

module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    var arrA = isArray(a)
      , arrB = isArray(b)
      , i
      , length
      , key;

    if (arrA && arrB) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }

    if (arrA != arrB) return false;

    var dateA = a instanceof Date
      , dateB = b instanceof Date;
    if (dateA != dateB) return false;
    if (dateA && dateB) return a.getTime() == b.getTime();

    var regexpA = a instanceof RegExp
      , regexpB = b instanceof RegExp;
    if (regexpA != regexpB) return false;
    if (regexpA && regexpB) return a.toString() == b.toString();

    var keys = keyList(a);
    length = keys.length;

    if (length !== keyList(b).length)
      return false;

    for (i = length; i-- !== 0;)
      if (!hasProp.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      key = keys[i];
      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  return a!==a && b!==b;
};


/***/ }),

/***/ 24015:
/***/ ((module) => {

module.exports = stringify
stringify.default = stringify
stringify.stable = deterministicStringify
stringify.stableStringify = deterministicStringify

var LIMIT_REPLACE_NODE = '[...]'
var CIRCULAR_REPLACE_NODE = '[Circular]'

var arr = []
var replacerStack = []

function defaultOptions () {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  }
}

// Regular stringify
function stringify (obj, replacer, spacer, options) {
  if (typeof options === 'undefined') {
    options = defaultOptions()
  }

  decirc(obj, '', 0, [], undefined, 0, options)
  var res
  try {
    if (replacerStack.length === 0) {
      res = JSON.stringify(obj, replacer, spacer)
    } else {
      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer)
    }
  } catch (_) {
    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')
  } finally {
    while (arr.length !== 0) {
      var part = arr.pop()
      if (part.length === 4) {
        Object.defineProperty(part[0], part[1], part[3])
      } else {
        part[0][part[1]] = part[2]
      }
    }
  }
  return res
}

function setReplace (replace, val, k, parent) {
  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k)
  if (propertyDescriptor.get !== undefined) {
    if (propertyDescriptor.configurable) {
      Object.defineProperty(parent, k, { value: replace })
      arr.push([parent, k, val, propertyDescriptor])
    } else {
      replacerStack.push([val, k, replace])
    }
  } else {
    parent[k] = replace
    arr.push([parent, k, val])
  }
}

function decirc (val, k, edgeIndex, stack, parent, depth, options) {
  depth += 1
  var i
  if (typeof val === 'object' && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent)
        return
      }
    }

    if (
      typeof options.depthLimit !== 'undefined' &&
      depth > options.depthLimit
    ) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent)
      return
    }

    if (
      typeof options.edgesLimit !== 'undefined' &&
      edgeIndex + 1 > options.edgesLimit
    ) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent)
      return
    }

    stack.push(val)
    // Optimize for Arrays. Big arrays could kill the performance otherwise!
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        decirc(val[i], i, i, stack, val, depth, options)
      }
    } else {
      var keys = Object.keys(val)
      for (i = 0; i < keys.length; i++) {
        var key = keys[i]
        decirc(val[key], key, i, stack, val, depth, options)
      }
    }
    stack.pop()
  }
}

// Stable-stringify
function compareFunction (a, b) {
  if (a < b) {
    return -1
  }
  if (a > b) {
    return 1
  }
  return 0
}

function deterministicStringify (obj, replacer, spacer, options) {
  if (typeof options === 'undefined') {
    options = defaultOptions()
  }

  var tmp = deterministicDecirc(obj, '', 0, [], undefined, 0, options) || obj
  var res
  try {
    if (replacerStack.length === 0) {
      res = JSON.stringify(tmp, replacer, spacer)
    } else {
      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer)
    }
  } catch (_) {
    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')
  } finally {
    // Ensure that we restore the object as it was.
    while (arr.length !== 0) {
      var part = arr.pop()
      if (part.length === 4) {
        Object.defineProperty(part[0], part[1], part[3])
      } else {
        part[0][part[1]] = part[2]
      }
    }
  }
  return res
}

function deterministicDecirc (val, k, edgeIndex, stack, parent, depth, options) {
  depth += 1
  var i
  if (typeof val === 'object' && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent)
        return
      }
    }
    try {
      if (typeof val.toJSON === 'function') {
        return
      }
    } catch (_) {
      return
    }

    if (
      typeof options.depthLimit !== 'undefined' &&
      depth > options.depthLimit
    ) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent)
      return
    }

    if (
      typeof options.edgesLimit !== 'undefined' &&
      edgeIndex + 1 > options.edgesLimit
    ) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent)
      return
    }

    stack.push(val)
    // Optimize for Arrays. Big arrays could kill the performance otherwise!
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        deterministicDecirc(val[i], i, i, stack, val, depth, options)
      }
    } else {
      // Create a temporary object in the required way
      var tmp = {}
      var keys = Object.keys(val).sort(compareFunction)
      for (i = 0; i < keys.length; i++) {
        var key = keys[i]
        deterministicDecirc(val[key], key, i, stack, val, depth, options)
        tmp[key] = val[key]
      }
      if (typeof parent !== 'undefined') {
        arr.push([parent, k, val])
        parent[k] = tmp
      } else {
        return tmp
      }
    }
    stack.pop()
  }
}

// wraps replacer function to handle values we couldn't replace
// and mark them as replaced value
function replaceGetterValues (replacer) {
  replacer =
    typeof replacer !== 'undefined'
      ? replacer
      : function (k, v) {
        return v
      }
  return function (key, val) {
    if (replacerStack.length > 0) {
      for (var i = 0; i < replacerStack.length; i++) {
        var part = replacerStack[i]
        if (part[1] === key && part[0] === val) {
          val = part[2]
          replacerStack.splice(i, 1)
          break
        }
      }
    }
    return replacer.call(this, key, val)
  }
}


/***/ }),

/***/ 5786:
/***/ ((module) => {

"use strict";

module.exports = function (obj, predicate) {
	var ret = {};
	var keys = Object.keys(obj);
	var isArr = Array.isArray(predicate);

	for (var i = 0; i < keys.length; i++) {
		var key = keys[i];
		var val = obj[key];

		if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
			ret[key] = val;
		}
	}

	return ret;
};


/***/ }),

/***/ 62979:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isCallable = __webpack_require__(84112);

var toStr = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

var forEachArray = function forEachArray(array, iterator, receiver) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            if (receiver == null) {
                iterator(array[i], i, array);
            } else {
                iterator.call(receiver, array[i], i, array);
            }
        }
    }
};

var forEachString = function forEachString(string, iterator, receiver) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        if (receiver == null) {
            iterator(string.charAt(i), i, string);
        } else {
            iterator.call(receiver, string.charAt(i), i, string);
        }
    }
};

var forEachObject = function forEachObject(object, iterator, receiver) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            if (receiver == null) {
                iterator(object[k], k, object);
            } else {
                iterator.call(receiver, object[k], k, object);
            }
        }
    }
};

var forEach = function forEach(list, iterator, thisArg) {
    if (!isCallable(iterator)) {
        throw new TypeError('iterator must be a function');
    }

    var receiver;
    if (arguments.length >= 3) {
        receiver = thisArg;
    }

    if (toStr.call(list) === '[object Array]') {
        forEachArray(list, iterator, receiver);
    } else if (typeof list === 'string') {
        forEachString(list, iterator, receiver);
    } else {
        forEachObject(list, iterator, receiver);
    }
};

module.exports = forEach;


/***/ }),

/***/ 52229:
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ 10243:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(52229);

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ 46858:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var undefined;

var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(89913)();
var hasProto = __webpack_require__(89094)();

var getProto = Object.getPrototypeOf || (
	hasProto
		? function (x) { return x.__proto__; } // eslint-disable-line no-proto
		: null
);

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%ReferenceError%': ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(10243);
var hasOwn = __webpack_require__(62903);
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
var $exec = bind.call(Function.call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),

/***/ 13367:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(46858);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),

/***/ 84918:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(7661)["Buffer"];
/* global Blob File */

/*
 * Module requirements.
 */

var isArray = __webpack_require__(96746);

var toString = Object.prototype.toString;
var withNativeBlob = typeof Blob === 'function' ||
                        typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]';
var withNativeFile = typeof File === 'function' ||
                        typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]';

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Supports Buffer, ArrayBuffer, Blob and File.
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary (obj) {
  if (!obj || typeof obj !== 'object') {
    return false;
  }

  if (isArray(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }
    return false;
  }

  if ((typeof Buffer === 'function' && Buffer.isBuffer && Buffer.isBuffer(obj)) ||
    (typeof ArrayBuffer === 'function' && obj instanceof ArrayBuffer) ||
    (withNativeBlob && obj instanceof Blob) ||
    (withNativeFile && obj instanceof File)
  ) {
    return true;
  }

  // see: https://github.com/Automattic/has-binary/pull/4
  if (obj.toJSON && typeof obj.toJSON === 'function' && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }

  return false;
}


/***/ }),

/***/ 15360:
/***/ ((module) => {


/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = typeof XMLHttpRequest !== 'undefined' &&
    'withCredentials' in new XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}


/***/ }),

/***/ 68936:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(46858);

var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);

var hasPropertyDescriptors = function hasPropertyDescriptors() {
	if ($defineProperty) {
		try {
			$defineProperty({}, 'a', { value: 1 });
			return true;
		} catch (e) {
			// IE 8 has a broken defineProperty
			return false;
		}
	}
	return false;
};

hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
	// node v0.6 has a bug where array lengths can be Set but not Defined
	if (!hasPropertyDescriptors()) {
		return null;
	}
	try {
		return $defineProperty([], 'length', { value: 1 }).length !== 1;
	} catch (e) {
		// In Firefox 4-22, defining length on an array throws an exception.
		return true;
	}
};

module.exports = hasPropertyDescriptors;


/***/ }),

/***/ 89094:
/***/ ((module) => {

"use strict";


var test = {
	foo: {}
};

var $Object = Object;

module.exports = function hasProto() {
	return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
};


/***/ }),

/***/ 89913:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(72502);

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),

/***/ 72502:
/***/ ((module) => {

"use strict";


/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),

/***/ 39639:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasSymbols = __webpack_require__(72502);

module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};


/***/ }),

/***/ 62903:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(10243);

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);


/***/ }),

/***/ 39185:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Buffer = (__webpack_require__(80480).Buffer)
var Transform = (__webpack_require__(31892).Transform)
var inherits = __webpack_require__(86778)

function throwIfNotStringOrBuffer (val, prefix) {
  if (!Buffer.isBuffer(val) && typeof val !== 'string') {
    throw new TypeError(prefix + ' must be a string or a buffer')
  }
}

function HashBase (blockSize) {
  Transform.call(this)

  this._block = Buffer.allocUnsafe(blockSize)
  this._blockSize = blockSize
  this._blockOffset = 0
  this._length = [0, 0, 0, 0]

  this._finalized = false
}

inherits(HashBase, Transform)

HashBase.prototype._transform = function (chunk, encoding, callback) {
  var error = null
  try {
    this.update(chunk, encoding)
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype._flush = function (callback) {
  var error = null
  try {
    this.push(this.digest())
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype.update = function (data, encoding) {
  throwIfNotStringOrBuffer(data, 'Data')
  if (this._finalized) throw new Error('Digest already called')
  if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)

  // consume data
  var block = this._block
  var offset = 0
  while (this._blockOffset + data.length - offset >= this._blockSize) {
    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++]
    this._update()
    this._blockOffset = 0
  }
  while (offset < data.length) block[this._blockOffset++] = data[offset++]

  // update length
  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
    this._length[j] += carry
    carry = (this._length[j] / 0x0100000000) | 0
    if (carry > 0) this._length[j] -= 0x0100000000 * carry
  }

  return this
}

HashBase.prototype._update = function () {
  throw new Error('_update is not implemented')
}

HashBase.prototype.digest = function (encoding) {
  if (this._finalized) throw new Error('Digest already called')
  this._finalized = true

  var digest = this._digest()
  if (encoding !== undefined) digest = digest.toString(encoding)

  // reset state
  this._block.fill(0)
  this._blockOffset = 0
  for (var i = 0; i < 4; ++i) this._length[i] = 0

  return digest
}

HashBase.prototype._digest = function () {
  throw new Error('_digest is not implemented')
}

module.exports = HashBase


/***/ }),

/***/ 61690:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hash = __webpack_require__(81427);
var utils = __webpack_require__(79484);
var assert = __webpack_require__(17118);

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils.toArray(options.pers, options.persEnc || 'hex');
  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toArray(entropy, entropyEnc);
  add = utils.toArray(add, addEnc);

  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc || 'hex');
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils.encode(res, enc);
};


/***/ }),

/***/ 29394:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var http = __webpack_require__(1107)
var url = __webpack_require__(43580)

var https = module.exports

for (var key in http) {
  if (http.hasOwnProperty(key)) https[key] = http[key]
}

https.request = function (params, cb) {
  params = validateParams(params)
  return http.request.call(this, params, cb)
}

https.get = function (params, cb) {
  params = validateParams(params)
  return http.get.call(this, params, cb)
}

function validateParams (params) {
  if (typeof params === 'string') {
    params = url.parse(params)
  }
  if (!params.protocol) {
    params.protocol = 'https:'
  }
  if (params.protocol !== 'https:') {
    throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"')
  }
  return params
}


/***/ }),

/***/ 81866:
/***/ ((__unused_webpack_module, exports) => {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ 90564:
/***/ ((module) => {


var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};

/***/ }),

/***/ 36022:
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),

/***/ 86778:
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ 32801:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasToStringTag = __webpack_require__(39639)();
var callBound = __webpack_require__(8507);

var $toString = callBound('Object.prototype.toString');

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return $toString(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		$toString(value) !== '[object Array]' &&
		$toString(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;


/***/ }),

/***/ 84112:
/***/ ((module) => {

"use strict";


var fnToStr = Function.prototype.toString;
var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
	try {
		badArrayLike = Object.defineProperty({}, 'length', {
			get: function () {
				throw isCallableMarker;
			}
		});
		isCallableMarker = {};
		// eslint-disable-next-line no-throw-literal
		reflectApply(function () { throw 42; }, null, badArrayLike);
	} catch (_) {
		if (_ !== isCallableMarker) {
			reflectApply = null;
		}
	}
} else {
	reflectApply = null;
}

var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
	try {
		var fnStr = fnToStr.call(value);
		return constructorRegex.test(fnStr);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionToStr(value) {
	try {
		if (isES6ClassFn(value)) { return false; }
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var objectClass = '[object Object]';
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var ddaClass = '[object HTMLAllCollection]'; // IE 11
var ddaClass2 = '[object HTML document.all class]';
var ddaClass3 = '[object HTMLCollection]'; // IE 9-10
var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`

var isIE68 = !(0 in [,]); // eslint-disable-line no-sparse-arrays, comma-spacing

var isDDA = function isDocumentDotAll() { return false; };
if (typeof document === 'object') {
	// Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
	var all = document.all;
	if (toStr.call(all) === toStr.call(document.all)) {
		isDDA = function isDocumentDotAll(value) {
			/* globals document: false */
			// in IE 6-8, typeof document.all is "object" and it's truthy
			if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
				try {
					var str = toStr.call(value);
					return (
						str === ddaClass
						|| str === ddaClass2
						|| str === ddaClass3 // opera 12.16
						|| str === objectClass // IE 6-8
					) && value('') == null; // eslint-disable-line eqeqeq
				} catch (e) { /**/ }
			}
			return false;
		};
	}
}

module.exports = reflectApply
	? function isCallable(value) {
		if (isDDA(value)) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		try {
			reflectApply(value, null, badArrayLike);
		} catch (e) {
			if (e !== isCallableMarker) { return false; }
		}
		return !isES6ClassFn(value) && tryFunctionObject(value);
	}
	: function isCallable(value) {
		if (isDDA(value)) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		if (hasToStringTag) { return tryFunctionObject(value); }
		if (isES6ClassFn(value)) { return false; }
		var strClass = toStr.call(value);
		if (strClass !== fnClass && strClass !== genClass && !(/^\[object HTML/).test(strClass)) { return false; }
		return tryFunctionObject(value);
	};


/***/ }),

/***/ 44799:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag = __webpack_require__(39639)();
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function () { // eslint-disable-line consistent-return
	if (!hasToStringTag) {
		return false;
	}
	try {
		return Function('return function*() {}')();
	} catch (e) {
	}
};
var GeneratorFunction;

module.exports = function isGeneratorFunction(fn) {
	if (typeof fn !== 'function') {
		return false;
	}
	if (isFnRegex.test(fnToStr.call(fn))) {
		return true;
	}
	if (!hasToStringTag) {
		var str = toStr.call(fn);
		return str === '[object GeneratorFunction]';
	}
	if (!getProto) {
		return false;
	}
	if (typeof GeneratorFunction === 'undefined') {
		var generatorFunc = getGeneratorFunc();
		GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
	}
	return getProto(fn) === GeneratorFunction;
};


/***/ }),

/***/ 84725:
/***/ ((module) => {

/**
 * Returns a `Boolean` on whether or not the a `String` starts with '0x'
 * @param {String} str the string input value
 * @return {Boolean} a boolean if it is or is not hex prefixed
 * @throws if the str input is not a string
 */
module.exports = function isHexPrefixed(str) {
  if (typeof str !== 'string') {
    throw new Error("[is-hex-prefixed] value must be type 'string', is currently type " + (typeof str) + ", while checking isHexPrefixed.");
  }

  return str.slice(0, 2) === '0x';
}


/***/ }),

/***/ 42854:
/***/ ((module) => {

"use strict";


/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

module.exports = function isNaN(value) {
	return value !== value;
};


/***/ }),

/***/ 24638:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBind = __webpack_require__(26210);
var define = __webpack_require__(34448);

var implementation = __webpack_require__(42854);
var getPolyfill = __webpack_require__(59983);
var shim = __webpack_require__(35771);

var polyfill = callBind(getPolyfill(), Number);

/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

define(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;


/***/ }),

/***/ 59983:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(42854);

module.exports = function getPolyfill() {
	if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {
		return Number.isNaN;
	}
	return implementation;
};


/***/ }),

/***/ 35771:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(34448);
var getPolyfill = __webpack_require__(59983);

/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

module.exports = function shimNumberIsNaN() {
	var polyfill = getPolyfill();
	define(Number, { isNaN: polyfill }, {
		isNaN: function testIsNaN() {
			return Number.isNaN !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),

/***/ 4270:
/***/ ((module) => {

"use strict";


const isStream = stream =>
	stream !== null &&
	typeof stream === 'object' &&
	typeof stream.pipe === 'function';

isStream.writable = stream =>
	isStream(stream) &&
	stream.writable !== false &&
	typeof stream._write === 'function' &&
	typeof stream._writableState === 'object';

isStream.readable = stream =>
	isStream(stream) &&
	stream.readable !== false &&
	typeof stream._read === 'function' &&
	typeof stream._readableState === 'object';

isStream.duplex = stream =>
	isStream.writable(stream) &&
	isStream.readable(stream);

isStream.transform = stream =>
	isStream.duplex(stream) &&
	typeof stream._transform === 'function';

module.exports = isStream;


/***/ }),

/***/ 1592:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var whichTypedArray = __webpack_require__(91469);

module.exports = function isTypedArray(value) {
	return !!whichTypedArray(value);
};


/***/ }),

/***/ 80894:
/***/ ((module) => {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ 96746:
/***/ ((module) => {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ 97233:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const uuid = __webpack_require__(45736);
const generateRequest = __webpack_require__(88635);

/**
 * Constructor for a Jayson Browser Client that does not depend any node.js core libraries
 * @class ClientBrowser
 * @param {Function} callServer Method that calls the server, receives the stringified request and a regular node-style callback
 * @param {Object} [options]
 * @param {Function} [options.reviver] Reviver function for JSON
 * @param {Function} [options.replacer] Replacer function for JSON
 * @param {Number} [options.version=2] JSON-RPC version to use (1|2)
 * @param {Function} [options.generator] Function to use for generating request IDs
 *  @param {Boolean} [options.notificationIdNull=false] When true, version 2 requests will set id to null instead of omitting it
 * @return {ClientBrowser}
 */
const ClientBrowser = function(callServer, options) {
  if(!(this instanceof ClientBrowser)) {
    return new ClientBrowser(callServer, options);
  }

  if (!options) {
    options = {};
  }

  this.options = {
    reviver: typeof options.reviver !== 'undefined' ? options.reviver : null,
    replacer: typeof options.replacer !== 'undefined' ? options.replacer : null,
    generator: typeof options.generator !== 'undefined' ? options.generator : function() { return uuid(); },
    version: typeof options.version !== 'undefined' ? options.version : 2,
    notificationIdNull: typeof options.notificationIdNull === 'boolean' ? options.notificationIdNull : false,
  };

  this.callServer = callServer;
};

module.exports = ClientBrowser;

/**
 *  Creates a request and dispatches it if given a callback.
 *  @param {String|Array} method A batch request if passed an Array, or a method name if passed a String
 *  @param {Array|Object} [params] Parameters for the method
 *  @param {String|Number} [id] Optional id. If undefined an id will be generated. If null it creates a notification request
 *  @param {Function} [callback] Request callback. If specified, executes the request rather than only returning it.
 *  @throws {TypeError} Invalid parameters
 *  @return {Object} JSON-RPC 1.0 or 2.0 compatible request
 */
ClientBrowser.prototype.request = function(method, params, id, callback) {
  const self = this;
  let request = null;

  // is this a batch request?
  const isBatch = Array.isArray(method) && typeof params === 'function';

  if (this.options.version === 1 && isBatch) {
    throw new TypeError('JSON-RPC 1.0 does not support batching');
  }

  // is this a raw request?
  const isRaw = !isBatch && method && typeof method === 'object' && typeof params === 'function';

  if(isBatch || isRaw) {
    callback = params;
    request = method;
  } else {
    if(typeof id === 'function') {
      callback = id;
      // specifically undefined because "null" is a notification request
      id = undefined;
    }

    const hasCallback = typeof callback === 'function';

    try {
      request = generateRequest(method, params, id, {
        generator: this.options.generator,
        version: this.options.version,
        notificationIdNull: this.options.notificationIdNull,
      });
    } catch(err) {
      if(hasCallback) {
        return callback(err);
      }
      throw err;
    }

    // no callback means we should just return a raw request
    if(!hasCallback) {
      return request;
    }

  }

  let message;
  try {
    message = JSON.stringify(request, this.options.replacer);
  } catch(err) {
    return callback(err);
  }

  this.callServer(message, function(err, response) {
    self._parseResponse(err, response, callback);
  });

  // always return the raw request
  return request;
};

/**
 * Parses a response from a server
 * @param {Object} err Error to pass on that is unrelated to the actual response
 * @param {String} responseText JSON-RPC 1.0 or 2.0 response
 * @param {Function} callback Callback that will receive different arguments depending on the amount of parameters
 * @private
 */
ClientBrowser.prototype._parseResponse = function(err, responseText, callback) {
  if(err) {
    callback(err);
    return;
  }

  if(!responseText) {
    // empty response text, assume that is correct because it could be a
    // notification which jayson does not give any body for
    return callback();
  }

  let response;
  try {
    response = JSON.parse(responseText, this.options.reviver);
  } catch(err) {
    return callback(err);
  }

  if(callback.length === 3) {
    // if callback length is 3, we split callback arguments on error and response

    // is batch response?
    if(Array.isArray(response)) {

      // neccesary to split strictly on validity according to spec here
      const isError = function(res) {
        return typeof res.error !== 'undefined';
      };

      const isNotError = function (res) {
        return !isError(res);
      };

      return callback(null, response.filter(isError), response.filter(isNotError));
    
    } else {

      // split regardless of validity
      return callback(null, response.error, response.result);
    
    }
  
  }

  callback(null, response);
};


/***/ }),

/***/ 88635:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const uuid = __webpack_require__(45736);

/**
 *  Generates a JSON-RPC 1.0 or 2.0 request
 *  @param {String} method Name of method to call
 *  @param {Array|Object} params Array of parameters passed to the method as specified, or an object of parameter names and corresponding value
 *  @param {String|Number|null} [id] Request ID can be a string, number, null for explicit notification or left out for automatic generation
 *  @param {Object} [options]
 *  @param {Number} [options.version=2] JSON-RPC version to use (1 or 2)
 *  @param {Boolean} [options.notificationIdNull=false] When true, version 2 requests will set id to null instead of omitting it
 *  @param {Function} [options.generator] Passed the request, and the options object and is expected to return a request ID
 *  @throws {TypeError} If any of the parameters are invalid
 *  @return {Object} A JSON-RPC 1.0 or 2.0 request
 *  @memberOf Utils
 */
const generateRequest = function(method, params, id, options) {
  if(typeof method !== 'string') {
    throw new TypeError(method + ' must be a string');
  }

  options = options || {};

  // check valid version provided
  const version = typeof options.version === 'number' ? options.version : 2;
  if (version !== 1 && version !== 2) {
    throw new TypeError(version + ' must be 1 or 2');
  }

  const request = {
    method: method
  };

  if(version === 2) {
    request.jsonrpc = '2.0';
  }

  if(params) {
    // params given, but invalid?
    if(typeof params !== 'object' && !Array.isArray(params)) {
      throw new TypeError(params + ' must be an object, array or omitted');
    }
    request.params = params;
  }

  // if id was left out, generate one (null means explicit notification)
  if(typeof(id) === 'undefined') {
    const generator = typeof options.generator === 'function' ? options.generator : function() { return uuid(); };
    request.id = generator(request, options);
  } else if (version === 2 && id === null) {
    // we have a version 2 notification
    if (options.notificationIdNull) {
      request.id = null; // id will not be set at all unless option provided
    }
  } else {
    request.id = id;
  }

  return request;
};

module.exports = generateRequest;


/***/ }),

/***/ 69362:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const uuid = (__webpack_require__(14586).v4);
const generateRequest = __webpack_require__(75069);

/**
 * Constructor for a Jayson Browser Client that does not depend any node.js core libraries
 * @class ClientBrowser
 * @param {Function} callServer Method that calls the server, receives the stringified request and a regular node-style callback
 * @param {Object} [options]
 * @param {Function} [options.reviver] Reviver function for JSON
 * @param {Function} [options.replacer] Replacer function for JSON
 * @param {Number} [options.version=2] JSON-RPC version to use (1|2)
 * @param {Function} [options.generator] Function to use for generating request IDs
 *  @param {Boolean} [options.notificationIdNull=false] When true, version 2 requests will set id to null instead of omitting it
 * @return {ClientBrowser}
 */
const ClientBrowser = function(callServer, options) {
  if(!(this instanceof ClientBrowser)) {
    return new ClientBrowser(callServer, options);
  }

  if (!options) {
    options = {};
  }

  this.options = {
    reviver: typeof options.reviver !== 'undefined' ? options.reviver : null,
    replacer: typeof options.replacer !== 'undefined' ? options.replacer : null,
    generator: typeof options.generator !== 'undefined' ? options.generator : function() { return uuid(); },
    version: typeof options.version !== 'undefined' ? options.version : 2,
    notificationIdNull: typeof options.notificationIdNull === 'boolean' ? options.notificationIdNull : false,
  };

  this.callServer = callServer;
};

module.exports = ClientBrowser;

/**
 *  Creates a request and dispatches it if given a callback.
 *  @param {String|Array} method A batch request if passed an Array, or a method name if passed a String
 *  @param {Array|Object} [params] Parameters for the method
 *  @param {String|Number} [id] Optional id. If undefined an id will be generated. If null it creates a notification request
 *  @param {Function} [callback] Request callback. If specified, executes the request rather than only returning it.
 *  @throws {TypeError} Invalid parameters
 *  @return {Object} JSON-RPC 1.0 or 2.0 compatible request
 */
ClientBrowser.prototype.request = function(method, params, id, callback) {
  const self = this;
  let request = null;

  // is this a batch request?
  const isBatch = Array.isArray(method) && typeof params === 'function';

  if (this.options.version === 1 && isBatch) {
    throw new TypeError('JSON-RPC 1.0 does not support batching');
  }

  // is this a raw request?
  const isRaw = !isBatch && method && typeof method === 'object' && typeof params === 'function';

  if(isBatch || isRaw) {
    callback = params;
    request = method;
  } else {
    if(typeof id === 'function') {
      callback = id;
      // specifically undefined because "null" is a notification request
      id = undefined;
    }

    const hasCallback = typeof callback === 'function';

    try {
      request = generateRequest(method, params, id, {
        generator: this.options.generator,
        version: this.options.version,
        notificationIdNull: this.options.notificationIdNull,
      });
    } catch(err) {
      if(hasCallback) {
        return callback(err);
      }
      throw err;
    }

    // no callback means we should just return a raw request
    if(!hasCallback) {
      return request;
    }

  }

  let message;
  try {
    message = JSON.stringify(request, this.options.replacer);
  } catch(err) {
    return callback(err);
  }

  this.callServer(message, function(err, response) {
    self._parseResponse(err, response, callback);
  });

  // always return the raw request
  return request;
};

/**
 * Parses a response from a server
 * @param {Object} err Error to pass on that is unrelated to the actual response
 * @param {String} responseText JSON-RPC 1.0 or 2.0 response
 * @param {Function} callback Callback that will receive different arguments depending on the amount of parameters
 * @private
 */
ClientBrowser.prototype._parseResponse = function(err, responseText, callback) {
  if(err) {
    callback(err);
    return;
  }

  if(!responseText) {
    // empty response text, assume that is correct because it could be a
    // notification which jayson does not give any body for
    return callback();
  }

  let response;
  try {
    response = JSON.parse(responseText, this.options.reviver);
  } catch(err) {
    return callback(err);
  }

  if(callback.length === 3) {
    // if callback length is 3, we split callback arguments on error and response

    // is batch response?
    if(Array.isArray(response)) {

      // neccesary to split strictly on validity according to spec here
      const isError = function(res) {
        return typeof res.error !== 'undefined';
      };

      const isNotError = function (res) {
        return !isError(res);
      };

      return callback(null, response.filter(isError), response.filter(isNotError));
    
    } else {

      // split regardless of validity
      return callback(null, response.error, response.result);
    
    }
  
  }

  callback(null, response);
};


/***/ }),

/***/ 75069:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const uuid = (__webpack_require__(14586).v4);

/**
 *  Generates a JSON-RPC 1.0 or 2.0 request
 *  @param {String} method Name of method to call
 *  @param {Array|Object} params Array of parameters passed to the method as specified, or an object of parameter names and corresponding value
 *  @param {String|Number|null} [id] Request ID can be a string, number, null for explicit notification or left out for automatic generation
 *  @param {Object} [options]
 *  @param {Number} [options.version=2] JSON-RPC version to use (1 or 2)
 *  @param {Boolean} [options.notificationIdNull=false] When true, version 2 requests will set id to null instead of omitting it
 *  @param {Function} [options.generator] Passed the request, and the options object and is expected to return a request ID
 *  @throws {TypeError} If any of the parameters are invalid
 *  @return {Object} A JSON-RPC 1.0 or 2.0 request
 *  @memberOf Utils
 */
const generateRequest = function(method, params, id, options) {
  if(typeof method !== 'string') {
    throw new TypeError(method + ' must be a string');
  }

  options = options || {};

  // check valid version provided
  const version = typeof options.version === 'number' ? options.version : 2;
  if (version !== 1 && version !== 2) {
    throw new TypeError(version + ' must be 1 or 2');
  }

  const request = {
    method: method
  };

  if(version === 2) {
    request.jsonrpc = '2.0';
  }

  if(params) {
    // params given, but invalid?
    if(typeof params !== 'object' && !Array.isArray(params)) {
      throw new TypeError(params + ' must be an object, array or omitted');
    }
    request.params = params;
  }

  // if id was left out, generate one (null means explicit notification)
  if(typeof(id) === 'undefined') {
    const generator = typeof options.generator === 'function' ? options.generator : function() { return uuid(); };
    request.id = generator(request, options);
  } else if (version === 2 && id === null) {
    // we have a version 2 notification
    if (options.notificationIdNull) {
      request.id = null; // id will not be set at all unless option provided
    }
  } else {
    request.id = id;
  }

  return request;
};

module.exports = generateRequest;


/***/ }),

/***/ 35636:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonRpcEngine = void 0;
const safe_event_emitter_1 = __importDefault(__webpack_require__(27010));
const eth_rpc_errors_1 = __webpack_require__(78914);
/**
 * A JSON-RPC request and response processor.
 * Give it a stack of middleware, pass it requests, and get back responses.
 */
class JsonRpcEngine extends safe_event_emitter_1.default {
    constructor() {
        super();
        this._middleware = [];
    }
    /**
     * Add a middleware function to the engine's middleware stack.
     *
     * @param middleware - The middleware function to add.
     */
    push(middleware) {
        this._middleware.push(middleware);
    }
    handle(req, cb) {
        if (cb && typeof cb !== 'function') {
            throw new Error('"callback" must be a function if provided.');
        }
        if (Array.isArray(req)) {
            if (cb) {
                return this._handleBatch(req, cb);
            }
            return this._handleBatch(req);
        }
        if (cb) {
            return this._handle(req, cb);
        }
        return this._promiseHandle(req);
    }
    /**
     * Returns this engine as a middleware function that can be pushed to other
     * engines.
     *
     * @returns This engine as a middleware function.
     */
    asMiddleware() {
        return async (req, res, next, end) => {
            try {
                const [middlewareError, isComplete, returnHandlers,] = await JsonRpcEngine._runAllMiddleware(req, res, this._middleware);
                if (isComplete) {
                    await JsonRpcEngine._runReturnHandlers(returnHandlers);
                    return end(middlewareError);
                }
                return next(async (handlerCallback) => {
                    try {
                        await JsonRpcEngine._runReturnHandlers(returnHandlers);
                    }
                    catch (error) {
                        return handlerCallback(error);
                    }
                    return handlerCallback();
                });
            }
            catch (error) {
                return end(error);
            }
        };
    }
    async _handleBatch(reqs, cb) {
        // The order here is important
        try {
            // 2. Wait for all requests to finish, or throw on some kind of fatal
            // error
            const responses = await Promise.all(
            // 1. Begin executing each request in the order received
            reqs.map(this._promiseHandle.bind(this)));
            // 3. Return batch response
            if (cb) {
                return cb(null, responses);
            }
            return responses;
        }
        catch (error) {
            if (cb) {
                return cb(error);
            }
            throw error;
        }
    }
    /**
     * A promise-wrapped _handle.
     */
    _promiseHandle(req) {
        return new Promise((resolve) => {
            this._handle(req, (_err, res) => {
                // There will always be a response, and it will always have any error
                // that is caught and propagated.
                resolve(res);
            });
        });
    }
    /**
     * Ensures that the request object is valid, processes it, and passes any
     * error and the response object to the given callback.
     *
     * Does not reject.
     */
    async _handle(callerReq, cb) {
        if (!callerReq ||
            Array.isArray(callerReq) ||
            typeof callerReq !== 'object') {
            const error = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, `Requests must be plain objects. Received: ${typeof callerReq}`, { request: callerReq });
            return cb(error, { id: undefined, jsonrpc: '2.0', error });
        }
        if (typeof callerReq.method !== 'string') {
            const error = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, `Must specify a string method. Received: ${typeof callerReq.method}`, { request: callerReq });
            return cb(error, { id: callerReq.id, jsonrpc: '2.0', error });
        }
        const req = Object.assign({}, callerReq);
        const res = {
            id: req.id,
            jsonrpc: req.jsonrpc,
        };
        let error = null;
        try {
            await this._processRequest(req, res);
        }
        catch (_error) {
            // A request handler error, a re-thrown middleware error, or something
            // unexpected.
            error = _error;
        }
        if (error) {
            // Ensure no result is present on an errored response
            delete res.result;
            if (!res.error) {
                res.error = eth_rpc_errors_1.serializeError(error);
            }
        }
        return cb(error, res);
    }
    /**
     * For the given request and response, runs all middleware and their return
     * handlers, if any, and ensures that internal request processing semantics
     * are satisfied.
     */
    async _processRequest(req, res) {
        const [error, isComplete, returnHandlers,] = await JsonRpcEngine._runAllMiddleware(req, res, this._middleware);
        // Throw if "end" was not called, or if the response has neither a result
        // nor an error.
        JsonRpcEngine._checkForCompletion(req, res, isComplete);
        // The return handlers should run even if an error was encountered during
        // middleware processing.
        await JsonRpcEngine._runReturnHandlers(returnHandlers);
        // Now we re-throw the middleware processing error, if any, to catch it
        // further up the call chain.
        if (error) {
            throw error;
        }
    }
    /**
     * Serially executes the given stack of middleware.
     *
     * @returns An array of any error encountered during middleware execution,
     * a boolean indicating whether the request was completed, and an array of
     * middleware-defined return handlers.
     */
    static async _runAllMiddleware(req, res, middlewareStack) {
        const returnHandlers = [];
        let error = null;
        let isComplete = false;
        // Go down stack of middleware, call and collect optional returnHandlers
        for (const middleware of middlewareStack) {
            [error, isComplete] = await JsonRpcEngine._runMiddleware(req, res, middleware, returnHandlers);
            if (isComplete) {
                break;
            }
        }
        return [error, isComplete, returnHandlers.reverse()];
    }
    /**
     * Runs an individual middleware.
     *
     * @returns An array of any error encountered during middleware exection,
     * and a boolean indicating whether the request should end.
     */
    static _runMiddleware(req, res, middleware, returnHandlers) {
        return new Promise((resolve) => {
            const end = (err) => {
                const error = err || res.error;
                if (error) {
                    res.error = eth_rpc_errors_1.serializeError(error);
                }
                // True indicates that the request should end
                resolve([error, true]);
            };
            const next = (returnHandler) => {
                if (res.error) {
                    end(res.error);
                }
                else {
                    if (returnHandler) {
                        if (typeof returnHandler !== 'function') {
                            end(new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: "next" return handlers must be functions. ` +
                                `Received "${typeof returnHandler}" for request:\n${jsonify(req)}`, { request: req }));
                        }
                        returnHandlers.push(returnHandler);
                    }
                    // False indicates that the request should not end
                    resolve([null, false]);
                }
            };
            try {
                middleware(req, res, next, end);
            }
            catch (error) {
                end(error);
            }
        });
    }
    /**
     * Serially executes array of return handlers. The request and response are
     * assumed to be in their scope.
     */
    static async _runReturnHandlers(handlers) {
        for (const handler of handlers) {
            await new Promise((resolve, reject) => {
                handler((err) => (err ? reject(err) : resolve()));
            });
        }
    }
    /**
     * Throws an error if the response has neither a result nor an error, or if
     * the "isComplete" flag is falsy.
     */
    static _checkForCompletion(req, res, isComplete) {
        if (!('result' in res) && !('error' in res)) {
            throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: Response has no error or result for request:\n${jsonify(req)}`, { request: req });
        }
        if (!isComplete) {
            throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: Nothing ended request:\n${jsonify(req)}`, { request: req });
        }
    }
}
exports.JsonRpcEngine = JsonRpcEngine;
function jsonify(request) {
    return JSON.stringify(request, null, 2);
}


/***/ }),

/***/ 37832:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createAsyncMiddleware = void 0;
/**
 * JsonRpcEngine only accepts callback-based middleware directly.
 * createAsyncMiddleware exists to enable consumers to pass in async middleware
 * functions.
 *
 * Async middleware have no "end" function. Instead, they "end" if they return
 * without calling "next". Rather than passing in explicit return handlers,
 * async middleware can simply await "next", and perform operations on the
 * response object when execution resumes.
 *
 * To accomplish this, createAsyncMiddleware passes the async middleware a
 * wrapped "next" function. That function calls the internal JsonRpcEngine
 * "next" function with a return handler that resolves a promise when called.
 *
 * The return handler will always be called. Its resolution of the promise
 * enables the control flow described above.
 */
function createAsyncMiddleware(asyncMiddleware) {
    return async (req, res, next, end) => {
        // nextPromise is the key to the implementation
        // it is resolved by the return handler passed to the
        // "next" function
        let resolveNextPromise;
        const nextPromise = new Promise((resolve) => {
            resolveNextPromise = resolve;
        });
        let returnHandlerCallback = null;
        let nextWasCalled = false;
        // This will be called by the consumer's async middleware.
        const asyncNext = async () => {
            nextWasCalled = true;
            // We pass a return handler to next(). When it is called by the engine,
            // the consumer's async middleware will resume executing.
            // eslint-disable-next-line node/callback-return
            next((runReturnHandlersCallback) => {
                // This callback comes from JsonRpcEngine._runReturnHandlers
                returnHandlerCallback = runReturnHandlersCallback;
                resolveNextPromise();
            });
            await nextPromise;
        };
        try {
            await asyncMiddleware(req, res, asyncNext);
            if (nextWasCalled) {
                await nextPromise; // we must wait until the return handler is called
                returnHandlerCallback(null);
            }
            else {
                end(null);
            }
        }
        catch (error) {
            if (returnHandlerCallback) {
                returnHandlerCallback(error);
            }
            else {
                end(error);
            }
        }
    };
}
exports.createAsyncMiddleware = createAsyncMiddleware;


/***/ }),

/***/ 2563:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createScaffoldMiddleware = void 0;
function createScaffoldMiddleware(handlers) {
    return (req, res, next, end) => {
        const handler = handlers[req.method];
        // if no handler, return
        if (handler === undefined) {
            return next();
        }
        // if handler is fn, call as middleware
        if (typeof handler === 'function') {
            return handler(req, res, next, end);
        }
        // if handler is some other value, use as result
        res.result = handler;
        return end();
    };
}
exports.createScaffoldMiddleware = createScaffoldMiddleware;


/***/ }),

/***/ 67540:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getUniqueId = void 0;
// uint32 (two's complement) max
// more conservative than Number.MAX_SAFE_INTEGER
const MAX = 4294967295;
let idCounter = Math.floor(Math.random() * MAX);
function getUniqueId() {
    idCounter = (idCounter + 1) % MAX;
    return idCounter;
}
exports.getUniqueId = getUniqueId;


/***/ }),

/***/ 17607:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createIdRemapMiddleware = void 0;
const getUniqueId_1 = __webpack_require__(67540);
function createIdRemapMiddleware() {
    return (req, res, next, _end) => {
        const originalId = req.id;
        const newId = getUniqueId_1.getUniqueId();
        req.id = newId;
        res.id = newId;
        next((done) => {
            req.id = originalId;
            res.id = originalId;
            done();
        });
    };
}
exports.createIdRemapMiddleware = createIdRemapMiddleware;


/***/ }),

/***/ 31483:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(17607), exports);
__exportStar(__webpack_require__(37832), exports);
__exportStar(__webpack_require__(2563), exports);
__exportStar(__webpack_require__(67540), exports);
__exportStar(__webpack_require__(35636), exports);
__exportStar(__webpack_require__(23189), exports);


/***/ }),

/***/ 23189:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mergeMiddleware = void 0;
const JsonRpcEngine_1 = __webpack_require__(35636);
function mergeMiddleware(middlewareStack) {
    const engine = new JsonRpcEngine_1.JsonRpcEngine();
    middlewareStack.forEach((middleware) => engine.push(middleware));
    return engine.asMiddleware();
}
exports.mergeMiddleware = mergeMiddleware;


/***/ }),

/***/ 20907:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const readable_stream_1 = __webpack_require__(80116);
/**
 * Takes a JsonRpcEngine and returns a Duplex stream wrapping it.
 *
 * @param opts - Options bag.
 * @param opts.engine - The JsonRpcEngine to wrap in a stream.
 * @returns The stream wrapping the engine.
 */
function createEngineStream(opts) {
    if (!opts || !opts.engine) {
        throw new Error('Missing engine parameter!');
    }
    const { engine } = opts;
    const stream = new readable_stream_1.Duplex({ objectMode: true, read, write });
    // forward notifications
    if (engine.on) {
        engine.on('notification', (message) => {
            stream.push(message);
        });
    }
    return stream;
    function read() {
        return undefined;
    }
    function write(req, _encoding, cb) {
        engine.handle(req, (_err, res) => {
            stream.push(res);
        });
        cb();
    }
}
exports["default"] = createEngineStream;


/***/ }),

/***/ 36367:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const safe_event_emitter_1 = __importDefault(__webpack_require__(27010));
const readable_stream_1 = __webpack_require__(80116);
/**
 * Creates a JsonRpcEngine middleware with an associated Duplex stream and
 * EventEmitter. The middleware, and by extension stream, assume that middleware
 * parameters are properly formatted. No runtime type checking or validation is
 * performed.
 *
 * @returns The event emitter, middleware, and stream.
 */
function createStreamMiddleware() {
    const idMap = {};
    const stream = new readable_stream_1.Duplex({
        objectMode: true,
        read: readNoop,
        write: processMessage,
    });
    const events = new safe_event_emitter_1.default();
    const middleware = (req, res, next, end) => {
        // write req to stream
        stream.push(req);
        // register request on id map
        idMap[req.id] = { req, res, next, end };
    };
    return { events, middleware, stream };
    function readNoop() {
        return false;
    }
    function processMessage(res, _encoding, cb) {
        let err;
        try {
            const isNotification = !res.id;
            if (isNotification) {
                processNotification(res);
            }
            else {
                processResponse(res);
            }
        }
        catch (_err) {
            err = _err;
        }
        // continue processing stream
        cb(err);
    }
    function processResponse(res) {
        const context = idMap[res.id];
        if (!context) {
            throw new Error(`StreamMiddleware - Unknown response id "${res.id}"`);
        }
        delete idMap[res.id];
        // copy whole res onto original res
        Object.assign(context.res, res);
        // run callback on empty stack,
        // prevent internal stream-handler from catching errors
        setTimeout(context.end);
    }
    function processNotification(res) {
        events.emit('notification', res);
    }
}
exports["default"] = createStreamMiddleware;


/***/ }),

/***/ 24823:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createStreamMiddleware = exports.createEngineStream = void 0;
const createEngineStream_1 = __importDefault(__webpack_require__(20907));
exports.createEngineStream = createEngineStream_1.default;
const createStreamMiddleware_1 = __importDefault(__webpack_require__(36367));
exports.createStreamMiddleware = createStreamMiddleware_1.default;


/***/ }),

/***/ 74545:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var json = typeof JSON !== 'undefined' ? JSON : __webpack_require__(12139);

var isArray = Array.isArray || function (x) {
	return {}.toString.call(x) === '[object Array]';
};

var objectKeys = Object.keys || function (obj) {
	var has = Object.prototype.hasOwnProperty || function () { return true; };
	var keys = [];
	for (var key in obj) {
		if (has.call(obj, key)) { keys.push(key); }
	}
	return keys;
};

module.exports = function (obj, opts) {
	if (!opts) { opts = {}; }
	if (typeof opts === 'function') { opts = { cmp: opts }; }
	var space = opts.space || '';
	if (typeof space === 'number') { space = Array(space + 1).join(' '); }
	var cycles = typeof opts.cycles === 'boolean' ? opts.cycles : false;
	var replacer = opts.replacer || function (key, value) { return value; };

	var cmp = opts.cmp && (function (f) {
		return function (node) {
			return function (a, b) {
				var aobj = { key: a, value: node[a] };
				var bobj = { key: b, value: node[b] };
				return f(aobj, bobj);
			};
		};
	}(opts.cmp));

	var seen = [];
	return (function stringify(parent, key, node, level) {
		var indent = space ? '\n' + new Array(level + 1).join(space) : '';
		var colonSeparator = space ? ': ' : ':';

		if (node && node.toJSON && typeof node.toJSON === 'function') {
			node = node.toJSON();
		}

		node = replacer.call(parent, key, node);

		if (node === undefined) {
			return;
		}
		if (typeof node !== 'object' || node === null) {
			return json.stringify(node);
		}
		if (isArray(node)) {
			var out = [];
			for (var i = 0; i < node.length; i++) {
				var item = stringify(node, i, node[i], level + 1) || json.stringify(null);
				out.push(indent + space + item);
			}
			return '[' + out.join(',') + indent + ']';
		}

		if (seen.indexOf(node) !== -1) {
			if (cycles) { return json.stringify('__cycle__'); }
			throw new TypeError('Converting circular structure to JSON');
		} else { seen.push(node); }

		var keys = objectKeys(node).sort(cmp && cmp(node));
		var out = [];
		for (var i = 0; i < keys.length; i++) {
			var key = keys[i];
			var value = stringify(node, key, node[key], level + 1);

			if (!value) { continue; }

			var keyValue = json.stringify(key)
					+ colonSeparator
					+ value;

			out.push(indent + space + keyValue);
		}
		seen.splice(seen.indexOf(node), 1);
		return '{' + out.join(',') + indent + '}';

	}({ '': obj }, '', obj, 0));
};


/***/ }),

/***/ 12139:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.parse = __webpack_require__(99623);
exports.stringify = __webpack_require__(77505);


/***/ }),

/***/ 99623:
/***/ ((module) => {

"use strict";


var at; // The index of the current character
var ch; // The current character
var escapee = {
	'"': '"',
	'\\': '\\',
	'/': '/',
	b: '\b',
	f: '\f',
	n: '\n',
	r: '\r',
	t: '\t'
};
var text;

// Call error when something is wrong.
function error(m) {
	throw {
		name: 'SyntaxError',
		message: m,
		at: at,
		text: text
	};
}

function next(c) {
	// If a c parameter is provided, verify that it matches the current character.
	if (c && c !== ch) {
		error("Expected '" + c + "' instead of '" + ch + "'");
	}

	// Get the next character. When there are no more characters, return the empty string.

	ch = text.charAt(at);
	at += 1;
	return ch;
}

function number() {
	// Parse a number value.
	var num;
	var str = '';

	if (ch === '-') {
		str = '-';
		next('-');
	}
	while (ch >= '0' && ch <= '9') {
		str += ch;
		next();
	}
	if (ch === '.') {
		str += '.';
		while (next() && ch >= '0' && ch <= '9') {
			str += ch;
		}
	}
	if (ch === 'e' || ch === 'E') {
		str += ch;
		next();
		if (ch === '-' || ch === '+') {
			str += ch;
			next();
		}
		while (ch >= '0' && ch <= '9') {
			str += ch;
			next();
		}
	}
	num = Number(str);
	if (!isFinite(num)) {
		error('Bad number');
	}
	return num;
}

function string() {
	// Parse a string value.
	var hex;
	var i;
	var str = '';
	var uffff;

	// When parsing for string values, we must look for " and \ characters.
	if (ch === '"') {
		while (next()) {
			if (ch === '"') {
				next();
				return str;
			} else if (ch === '\\') {
				next();
				if (ch === 'u') {
					uffff = 0;
					for (i = 0; i < 4; i += 1) {
						hex = parseInt(next(), 16);
						if (!isFinite(hex)) {
							break;
						}
						uffff = (uffff * 16) + hex;
					}
					str += String.fromCharCode(uffff);
				} else if (typeof escapee[ch] === 'string') {
					str += escapee[ch];
				} else {
					break;
				}
			} else {
				str += ch;
			}
		}
	}
	error('Bad string');
}

// Skip whitespace.
function white() {
	while (ch && ch <= ' ') {
		next();
	}
}

// true, false, or null.
function word() {
	switch (ch) {
		case 't':
			next('t');
			next('r');
			next('u');
			next('e');
			return true;
		case 'f':
			next('f');
			next('a');
			next('l');
			next('s');
			next('e');
			return false;
		case 'n':
			next('n');
			next('u');
			next('l');
			next('l');
			return null;
		default:
			error("Unexpected '" + ch + "'");
	}
}

// Parse an array value.
function array() {
	var arr = [];

	if (ch === '[') {
		next('[');
		white();
		if (ch === ']') {
			next(']');
			return arr; // empty array
		}
		while (ch) {
			arr.push(value()); // eslint-disable-line no-use-before-define
			white();
			if (ch === ']') {
				next(']');
				return arr;
			}
			next(',');
			white();
		}
	}
	error('Bad array');
}

// Parse an object value.
function object() {
	var key;
	var obj = {};

	if (ch === '{') {
		next('{');
		white();
		if (ch === '}') {
			next('}');
			return obj; // empty object
		}
		while (ch) {
			key = string();
			white();
			next(':');
			if (Object.prototype.hasOwnProperty.call(obj, key)) {
				error('Duplicate key "' + key + '"');
			}
			obj[key] = value(); // eslint-disable-line no-use-before-define
			white();
			if (ch === '}') {
				next('}');
				return obj;
			}
			next(',');
			white();
		}
	}
	error('Bad object');
}

// Parse a JSON value. It could be an object, an array, a string, a number, or a word.
function value() {
	white();
	switch (ch) {
		case '{':
			return object();
		case '[':
			return array();
		case '"':
			return string();
		case '-':
			return number();
		default:
			return ch >= '0' && ch <= '9' ? number() : word();
	}
}

// Return the json_parse function. It will have access to all of the above functions and variables.
module.exports = function (source, reviver) {
	var result;

	text = source;
	at = 0;
	ch = ' ';
	result = value();
	white();
	if (ch) {
		error('Syntax error');
	}

	// If there is a reviver function, we recursively walk the new structure,
	// passing each name/value pair to the reviver function for possible
	// transformation, starting with a temporary root object that holds the result
	// in an empty key. If there is not a reviver function, we simply return the
	// result.

	return typeof reviver === 'function' ? (function walk(holder, key) {
		var k;
		var v;
		var val = holder[key];
		if (val && typeof val === 'object') {
			for (k in value) {
				if (Object.prototype.hasOwnProperty.call(val, k)) {
					v = walk(val, k);
					if (typeof v === 'undefined') {
						delete val[k];
					} else {
						val[k] = v;
					}
				}
			}
		}
		return reviver.call(holder, key, val);
	}({ '': result }, '')) : result;
};


/***/ }),

/***/ 77505:
/***/ ((module) => {

"use strict";


var escapable = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
var gap;
var indent;
var meta = { // table of character substitutions
	'\b': '\\b',
	'\t': '\\t',
	'\n': '\\n',
	'\f': '\\f',
	'\r': '\\r',
	'"': '\\"',
	'\\': '\\\\'
};
var rep;

function quote(string) {
	// If the string contains no control characters, no quote characters, and no
	// backslash characters, then we can safely slap some quotes around it.
	// Otherwise we must also replace the offending characters with safe escape sequences.

	escapable.lastIndex = 0;
	return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
		var c = meta[a];
		return typeof c === 'string' ? c
			: '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
	}) + '"' : '"' + string + '"';
}

function str(key, holder) {
	// Produce a string from holder[key].
	var i; // The loop counter.
	var k; // The member key.
	var v; // The member value.
	var length;
	var mind = gap;
	var partial;
	var value = holder[key];

	// If the value has a toJSON method, call it to obtain a replacement value.
	if (value && typeof value === 'object' && typeof value.toJSON === 'function') {
		value = value.toJSON(key);
	}

	// If we were called with a replacer function, then call the replacer to obtain a replacement value.
	if (typeof rep === 'function') {
		value = rep.call(holder, key, value);
	}

	// What happens next depends on the value's type.
	switch (typeof value) {
		case 'string':
			return quote(value);

		case 'number':
			// JSON numbers must be finite. Encode non-finite numbers as null.
			return isFinite(value) ? String(value) : 'null';

		case 'boolean':
		case 'null':
			// If the value is a boolean or null, convert it to a string. Note:
			// typeof null does not produce 'null'. The case is included here in
			// the remote chance that this gets fixed someday.
			return String(value);

		case 'object':
			if (!value) {
				return 'null';
			}
			gap += indent;
			partial = [];

			// Array.isArray
			if (Object.prototype.toString.apply(value) === '[object Array]') {
				length = value.length;
				for (i = 0; i < length; i += 1) {
					partial[i] = str(i, value) || 'null';
				}

				// Join all of the elements together, separated with commas, and wrap them in brackets.
				v = partial.length === 0 ? '[]' : gap
					? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'
					: '[' + partial.join(',') + ']';
				gap = mind;
				return v;
			}

			// If the replacer is an array, use it to select the members to be stringified.
			if (rep && typeof rep === 'object') {
				length = rep.length;
				for (i = 0; i < length; i += 1) {
					k = rep[i];
					if (typeof k === 'string') {
						v = str(k, value);
						if (v) {
							partial.push(quote(k) + (gap ? ': ' : ':') + v);
						}
					}
				}
			} else {
				// Otherwise, iterate through all of the keys in the object.
				for (k in value) {
					if (Object.prototype.hasOwnProperty.call(value, k)) {
						v = str(k, value);
						if (v) {
							partial.push(quote(k) + (gap ? ': ' : ':') + v);
						}
					}
				}
			}

			// Join all of the member texts together, separated with commas, and wrap them in braces.

			v = partial.length === 0 ? '{}' : gap
				? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'
				: '{' + partial.join(',') + '}';
			gap = mind;
			return v;
		default:
	}
}

module.exports = function (value, replacer, space) {
	var i;
	gap = '';
	indent = '';

	// If the space parameter is a number, make an indent string containing that many spaces.
	if (typeof space === 'number') {
		for (i = 0; i < space; i += 1) {
			indent += ' ';
		}
	} else if (typeof space === 'string') {
		// If the space parameter is a string, it will be used as the indent string.
		indent = space;
	}

	// If there is a replacer, it must be a function or an array. Otherwise, throw an error.
	rep = replacer;
	if (
		replacer
		&& typeof replacer !== 'function'
		&& (typeof replacer !== 'object' || typeof replacer.length !== 'number')
	) {
		throw new Error('JSON.stringify');
	}

	// Make a fake root object containing our value under the key of ''.
	// Return the result of stringifying the value.
	return str('', { '': value });
};


/***/ }),

/***/ 51101:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var inherits = __webpack_require__(86778)
var HashBase = __webpack_require__(39185)
var Buffer = (__webpack_require__(80480).Buffer)

var ARRAY16 = new Array(16)

function MD5 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
}

inherits(MD5, HashBase)

MD5.prototype._update = function () {
  var M = ARRAY16
  for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4)

  var a = this._a
  var b = this._b
  var c = this._c
  var d = this._d

  a = fnF(a, b, c, d, M[0], 0xd76aa478, 7)
  d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12)
  c = fnF(c, d, a, b, M[2], 0x242070db, 17)
  b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22)
  a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7)
  d = fnF(d, a, b, c, M[5], 0x4787c62a, 12)
  c = fnF(c, d, a, b, M[6], 0xa8304613, 17)
  b = fnF(b, c, d, a, M[7], 0xfd469501, 22)
  a = fnF(a, b, c, d, M[8], 0x698098d8, 7)
  d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12)
  c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17)
  b = fnF(b, c, d, a, M[11], 0x895cd7be, 22)
  a = fnF(a, b, c, d, M[12], 0x6b901122, 7)
  d = fnF(d, a, b, c, M[13], 0xfd987193, 12)
  c = fnF(c, d, a, b, M[14], 0xa679438e, 17)
  b = fnF(b, c, d, a, M[15], 0x49b40821, 22)

  a = fnG(a, b, c, d, M[1], 0xf61e2562, 5)
  d = fnG(d, a, b, c, M[6], 0xc040b340, 9)
  c = fnG(c, d, a, b, M[11], 0x265e5a51, 14)
  b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20)
  a = fnG(a, b, c, d, M[5], 0xd62f105d, 5)
  d = fnG(d, a, b, c, M[10], 0x02441453, 9)
  c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14)
  b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20)
  a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5)
  d = fnG(d, a, b, c, M[14], 0xc33707d6, 9)
  c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14)
  b = fnG(b, c, d, a, M[8], 0x455a14ed, 20)
  a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5)
  d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9)
  c = fnG(c, d, a, b, M[7], 0x676f02d9, 14)
  b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20)

  a = fnH(a, b, c, d, M[5], 0xfffa3942, 4)
  d = fnH(d, a, b, c, M[8], 0x8771f681, 11)
  c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16)
  b = fnH(b, c, d, a, M[14], 0xfde5380c, 23)
  a = fnH(a, b, c, d, M[1], 0xa4beea44, 4)
  d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11)
  c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16)
  b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23)
  a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4)
  d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11)
  c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16)
  b = fnH(b, c, d, a, M[6], 0x04881d05, 23)
  a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4)
  d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11)
  c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16)
  b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23)

  a = fnI(a, b, c, d, M[0], 0xf4292244, 6)
  d = fnI(d, a, b, c, M[7], 0x432aff97, 10)
  c = fnI(c, d, a, b, M[14], 0xab9423a7, 15)
  b = fnI(b, c, d, a, M[5], 0xfc93a039, 21)
  a = fnI(a, b, c, d, M[12], 0x655b59c3, 6)
  d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10)
  c = fnI(c, d, a, b, M[10], 0xffeff47d, 15)
  b = fnI(b, c, d, a, M[1], 0x85845dd1, 21)
  a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6)
  d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10)
  c = fnI(c, d, a, b, M[6], 0xa3014314, 15)
  b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21)
  a = fnI(a, b, c, d, M[4], 0xf7537e82, 6)
  d = fnI(d, a, b, c, M[11], 0xbd3af235, 10)
  c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15)
  b = fnI(b, c, d, a, M[9], 0xeb86d391, 21)

  this._a = (this._a + a) | 0
  this._b = (this._b + b) | 0
  this._c = (this._c + c) | 0
  this._d = (this._d + d) | 0
}

MD5.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.allocUnsafe(16)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fnF (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + b) | 0
}

function fnG (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + b) | 0
}

function fnH (a, b, c, d, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0
}

function fnI (a, b, c, d, m, k, s) {
  return (rotl((a + ((c ^ (b | (~d)))) + m + k) | 0, s) + b) | 0
}

module.exports = MD5


/***/ }),

/***/ 76254:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(7661)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InvalidStatusCodeError = exports.InvalidCertError = void 0;
const DEFAULT_OPT = Object.freeze({
    redirect: true,
    expectStatusCode: 200,
    headers: {},
    full: false,
    keepAlive: true,
    cors: false,
    referrer: false,
    sslAllowSelfSigned: false,
    _redirectCount: 0,
});
class InvalidCertError extends Error {
    constructor(msg, fingerprint256) {
        super(msg);
        this.fingerprint256 = fingerprint256;
    }
}
exports.InvalidCertError = InvalidCertError;
class InvalidStatusCodeError extends Error {
    constructor(statusCode) {
        super(`Request Failed. Status Code: ${statusCode}`);
        this.statusCode = statusCode;
    }
}
exports.InvalidStatusCodeError = InvalidStatusCodeError;
function detectType(b, type) {
    if (!type || type === 'text' || type === 'json') {
        try {
            let text = new TextDecoder('utf8', { fatal: true }).decode(b);
            if (type === 'text')
                return text;
            try {
                return JSON.parse(text);
            }
            catch (err) {
                if (type === 'json')
                    throw err;
                return text;
            }
        }
        catch (err) {
            if (type === 'text' || type === 'json')
                throw err;
        }
    }
    return b;
}
let agents = {};
function fetchNode(url, _options) {
    let options = { ...DEFAULT_OPT, ..._options };
    const http = __webpack_require__(1107);
    const https = __webpack_require__(29394);
    const zlib = __webpack_require__(54);
    const { promisify } = __webpack_require__(10654);
    const { resolve: urlResolve } = __webpack_require__(43580);
    const isSecure = !!/^https/.test(url);
    let opts = {
        method: options.method || 'GET',
        headers: { 'Accept-Encoding': 'gzip, deflate, br' },
    };
    const compactFP = (s) => s.replace(/:| /g, '').toLowerCase();
    if (options.keepAlive) {
        const agentOpt = {
            keepAlive: true,
            keepAliveMsecs: 30 * 1000,
            maxFreeSockets: 1024,
            maxCachedSessions: 1024,
        };
        const agentKey = [
            isSecure,
            isSecure && options.sslPinnedCertificates?.map((i) => compactFP(i)).sort(),
        ].join();
        opts.agent =
            agents[agentKey] || (agents[agentKey] = new (isSecure ? https : http).Agent(agentOpt));
    }
    if (options.type === 'json')
        opts.headers['Content-Type'] = 'application/json';
    if (options.data) {
        if (!options.method)
            opts.method = 'POST';
        opts.body = options.type === 'json' ? JSON.stringify(options.data) : options.data;
    }
    opts.headers = { ...opts.headers, ...options.headers };
    if (options.sslAllowSelfSigned)
        opts.rejectUnauthorized = false;
    const handleRes = async (res) => {
        const status = res.statusCode;
        if (options.redirect && 300 <= status && status < 400 && res.headers['location']) {
            if (options._redirectCount == 10)
                throw new Error('Request failed. Too much redirects.');
            options._redirectCount += 1;
            return await fetchNode(urlResolve(url, res.headers['location']), options);
        }
        if (options.expectStatusCode && status !== options.expectStatusCode) {
            res.resume();
            throw new InvalidStatusCodeError(status);
        }
        let buf = [];
        for await (const chunk of res)
            buf.push(chunk);
        let bytes = Buffer.concat(buf);
        const encoding = res.headers['content-encoding'];
        if (encoding === 'br')
            bytes = await promisify(zlib.brotliDecompress)(bytes);
        if (encoding === 'gzip' || encoding === 'deflate')
            bytes = await promisify(zlib.unzip)(bytes);
        const body = detectType(bytes, options.type);
        if (options.full)
            return { headers: res.headers, status, body };
        return body;
    };
    return new Promise((resolve, reject) => {
        const handleError = async (err) => {
            if (err && err.code === 'DEPTH_ZERO_SELF_SIGNED_CERT') {
                try {
                    await fetchNode(url, { ...options, sslAllowSelfSigned: true, sslPinnedCertificates: [] });
                }
                catch (e) {
                    if (e && e.fingerprint256) {
                        err = new InvalidCertError(`Self-signed SSL certificate: ${e.fingerprint256}`, e.fingerprint256);
                    }
                }
            }
            reject(err);
        };
        const req = (isSecure ? https : http).request(url, opts, (res) => {
            res.on('error', handleError);
            (async () => {
                try {
                    resolve(await handleRes(res));
                }
                catch (error) {
                    reject(error);
                }
            })();
        });
        req.on('error', handleError);
        const pinned = options.sslPinnedCertificates?.map((i) => compactFP(i));
        const mfetchSecureConnect = (socket) => {
            const fp256 = compactFP(socket.getPeerCertificate()?.fingerprint256 || '');
            if (!fp256 && socket.isSessionReused())
                return;
            if (pinned.includes(fp256))
                return;
            req.emit('error', new InvalidCertError(`Invalid SSL certificate: ${fp256} Expected: ${pinned}`, fp256));
            return req.abort();
        };
        if (options.sslPinnedCertificates) {
            req.on('socket', (socket) => {
                const hasListeners = socket
                    .listeners('secureConnect')
                    .map((i) => (i.name || '').replace('bound ', ''))
                    .includes('mfetchSecureConnect');
                if (hasListeners)
                    return;
                socket.on('secureConnect', mfetchSecureConnect.bind(null, socket));
            });
        }
        if (options.keepAlive)
            req.setNoDelay(true);
        if (opts.body)
            req.write(opts.body);
        req.end();
    });
}
const SAFE_HEADERS = new Set(['Accept', 'Accept-Language', 'Content-Language', 'Content-Type'].map((i) => i.toLowerCase()));
const FORBIDDEN_HEADERS = new Set(['Accept-Charset', 'Accept-Encoding', 'Access-Control-Request-Headers', 'Access-Control-Request-Method',
    'Connection', 'Content-Length', 'Cookie', 'Cookie2', 'Date', 'DNT', 'Expect', 'Host', 'Keep-Alive', 'Origin', 'Referer', 'TE', 'Trailer',
    'Transfer-Encoding', 'Upgrade', 'Via'].map((i) => i.toLowerCase()));
async function fetchBrowser(url, _options) {
    let options = { ...DEFAULT_OPT, ..._options };
    const headers = new Headers();
    if (options.type === 'json')
        headers.set('Content-Type', 'application/json');
    let parsed = new URL(url);
    if (parsed.username) {
        const auth = btoa(`${parsed.username}:${parsed.password}`);
        headers.set('Authorization', `Basic ${auth}`);
        parsed.username = '';
        parsed.password = '';
    }
    url = '' + parsed;
    for (let k in options.headers) {
        const name = k.toLowerCase();
        if (SAFE_HEADERS.has(name) || (options.cors && !FORBIDDEN_HEADERS.has(name)))
            headers.set(k, options.headers[k]);
    }
    let opts = { headers, redirect: options.redirect ? 'follow' : 'manual' };
    if (!options.referrer)
        opts.referrerPolicy = 'no-referrer';
    if (options.cors)
        opts.mode = 'cors';
    if (options.data) {
        if (!options.method)
            opts.method = 'POST';
        opts.body = options.type === 'json' ? JSON.stringify(options.data) : options.data;
    }
    const res = await fetch(url, opts);
    if (options.expectStatusCode && res.status !== options.expectStatusCode)
        throw new InvalidStatusCodeError(res.status);
    const body = detectType(new Uint8Array(await res.arrayBuffer()), options.type);
    if (options.full)
        return { headers: Object.fromEntries(res.headers.entries()), status: res.status, body };
    return body;
}
const IS_NODE = !!(typeof process == 'object' &&
    process.versions &&
    process.versions.node &&
    process.versions.v8);
function fetchUrl(url, options) {
    const fn = IS_NODE ? fetchNode : fetchBrowser;
    return fn(url, options);
}
exports["default"] = fetchUrl;


/***/ }),

/***/ 40162:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var bn = __webpack_require__(73117);
var brorand = __webpack_require__(89799);

function MillerRabin(rand) {
  this.rand = rand || new brorand.Rand();
}
module.exports = MillerRabin;

MillerRabin.create = function create(rand) {
  return new MillerRabin(rand);
};

MillerRabin.prototype._randbelow = function _randbelow(n) {
  var len = n.bitLength();
  var min_bytes = Math.ceil(len / 8);

  // Generage random bytes until a number less than n is found.
  // This ensures that 0..n-1 have an equal probability of being selected.
  do
    var a = new bn(this.rand.generate(min_bytes));
  while (a.cmp(n) >= 0);

  return a;
};

MillerRabin.prototype._randrange = function _randrange(start, stop) {
  // Generate a random number greater than or equal to start and less than stop.
  var size = stop.sub(start);
  return start.add(this._randbelow(size));
};

MillerRabin.prototype.test = function test(n, k, cb) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  var prime = true;
  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);
    if (cb)
      cb(a);

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return false;
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s)
      return false;
  }

  return prime;
};

MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);

    var g = n.gcd(a);
    if (g.cmpn(1) !== 0)
      return g;

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return x.fromRed().subn(1).gcd(n);
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s) {
      x = x.redSqr();
      return x.fromRed().subn(1).gcd(n);
    }
  }

  return false;
};


/***/ }),

/***/ 17118:
/***/ ((module) => {

module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};


/***/ }),

/***/ 79484:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};


/***/ }),

/***/ 40436:
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}


/***/ }),

/***/ 7237:
/***/ ((module) => {

"use strict";


class Base {
  constructor (name, code, implementation, alphabet) {
    this.name = name
    this.code = code
    this.alphabet = alphabet
    if (implementation && alphabet) {
      this.engine = implementation(alphabet)
    }
  }

  encode (stringOrBuffer) {
    return this.engine.encode(stringOrBuffer)
  }

  decode (stringOrBuffer) {
    return this.engine.decode(stringOrBuffer)
  }

  isImplemented () {
    return this.engine
  }
}

module.exports = Base


/***/ }),

/***/ 20048:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const { Buffer } = __webpack_require__(19444)

module.exports = function base16 (alphabet) {
  return {
    encode (input) {
      if (typeof input === 'string') {
        return Buffer.from(input).toString('hex')
      }
      return input.toString('hex')
    },
    decode (input) {
      for (const char of input) {
        if (alphabet.indexOf(char) < 0) {
          throw new Error('invalid base16 character')
        }
      }
      return Buffer.from(input, 'hex')
    }
  }
}


/***/ }),

/***/ 81940:
/***/ ((module) => {

"use strict";


function decode (input, alphabet) {
  input = input.replace(new RegExp('=', 'g'), '')
  const length = input.length

  let bits = 0
  let value = 0

  let index = 0
  const output = new Uint8Array((length * 5 / 8) | 0)

  for (let i = 0; i < length; i++) {
    value = (value << 5) | alphabet.indexOf(input[i])
    bits += 5

    if (bits >= 8) {
      output[index++] = (value >>> (bits - 8)) & 255
      bits -= 8
    }
  }

  return output.buffer
}

function encode (buffer, alphabet) {
  const length = buffer.byteLength
  const view = new Uint8Array(buffer)
  const padding = alphabet.indexOf('=') === alphabet.length - 1

  if (padding) {
    alphabet = alphabet.substring(0, alphabet.length - 1)
  }

  let bits = 0
  let value = 0
  let output = ''

  for (let i = 0; i < length; i++) {
    value = (value << 8) | view[i]
    bits += 8

    while (bits >= 5) {
      output += alphabet[(value >>> (bits - 5)) & 31]
      bits -= 5
    }
  }

  if (bits > 0) {
    output += alphabet[(value << (5 - bits)) & 31]
  }

  if (padding) {
    while ((output.length % 8) !== 0) {
      output += '='
    }
  }

  return output
}

module.exports = function base32 (alphabet) {
  return {
    encode (input) {
      if (typeof input === 'string') {
        return encode(Uint8Array.from(input), alphabet)
      }

      return encode(input, alphabet)
    },
    decode (input) {
      for (const char of input) {
        if (alphabet.indexOf(char) < 0) {
          throw new Error('invalid base32 character')
        }
      }

      return decode(input, alphabet)
    }
  }
}


/***/ }),

/***/ 22583:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const { Buffer } = __webpack_require__(19444)

module.exports = function base64 (alphabet) {
  // The alphabet is only used to know:
  //   1. If padding is enabled (must contain '=')
  //   2. If the output must be url-safe (must contain '-' and '_')
  //   3. If the input of the output function is valid
  // The alphabets from RFC 4648 are always used.
  const padding = alphabet.indexOf('=') > -1
  const url = alphabet.indexOf('-') > -1 && alphabet.indexOf('_') > -1

  return {
    encode (input) {
      let output = ''

      if (typeof input === 'string') {
        output = Buffer.from(input).toString('base64')
      } else {
        output = input.toString('base64')
      }

      if (url) {
        output = output.replace(/\+/g, '-').replace(/\//g, '_')
      }

      const pad = output.indexOf('=')
      if (pad > 0 && !padding) {
        output = output.substring(0, pad)
      }

      return output
    },
    decode (input) {
      for (const char of input) {
        if (alphabet.indexOf(char) < 0) {
          throw new Error('invalid base64 character')
        }
      }

      return Buffer.from(input, 'base64')
    }
  }
}


/***/ }),

/***/ 89444:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Base = __webpack_require__(7237)
const baseX = __webpack_require__(33206)
const base16 = __webpack_require__(20048)
const base32 = __webpack_require__(81940)
const base64 = __webpack_require__(22583)

// name, code, implementation, alphabet
const constants = [
  ['base1', '1', '', '1'],
  ['base2', '0', baseX, '01'],
  ['base8', '7', baseX, '01234567'],
  ['base10', '9', baseX, '0123456789'],
  ['base16', 'f', base16, '0123456789abcdef'],
  ['base32', 'b', base32, 'abcdefghijklmnopqrstuvwxyz234567'],
  ['base32pad', 'c', base32, 'abcdefghijklmnopqrstuvwxyz234567='],
  ['base32hex', 'v', base32, '0123456789abcdefghijklmnopqrstuv'],
  ['base32hexpad', 't', base32, '0123456789abcdefghijklmnopqrstuv='],
  ['base32z', 'h', base32, 'ybndrfg8ejkmcpqxot1uwisza345h769'],
  ['base58flickr', 'Z', baseX, '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'],
  ['base58btc', 'z', baseX, '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'],
  ['base64', 'm', base64, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'],
  ['base64pad', 'M', base64, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='],
  ['base64url', 'u', base64, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'],
  ['base64urlpad', 'U', base64, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=']
]

const names = constants.reduce((prev, tupple) => {
  prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3])
  return prev
}, {})

const codes = constants.reduce((prev, tupple) => {
  prev[tupple[1]] = names[tupple[0]]
  return prev
}, {})

module.exports = {
  names: names,
  codes: codes
}


/***/ }),

/***/ 34408:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Implementation of the [multibase](https://github.com/multiformats/multibase) specification.
 * @module Multibase
 */


const { Buffer } = __webpack_require__(19444)
const constants = __webpack_require__(89444)

exports = module.exports = multibase
exports.encode = encode
exports.decode = decode
exports.isEncoded = isEncoded
exports.names = Object.freeze(Object.keys(constants.names))
exports.codes = Object.freeze(Object.keys(constants.codes))

const errNotSupported = new Error('Unsupported encoding')

/**
 * Create a new buffer with the multibase varint+code.
 *
 * @param {string|number} nameOrCode - The multibase name or code number.
 * @param {Buffer} buf - The data to be prefixed with multibase.
 * @memberof Multibase
 * @returns {Buffer}
 */
function multibase (nameOrCode, buf) {
  if (!buf) {
    throw new Error('requires an encoded buffer')
  }
  const base = getBase(nameOrCode)
  const codeBuf = Buffer.from(base.code)

  const name = base.name
  validEncode(name, buf)
  return Buffer.concat([codeBuf, buf])
}

/**
 * Encode data with the specified base and add the multibase prefix.
 *
 * @param {string|number} nameOrCode - The multibase name or code number.
 * @param {Buffer} buf - The data to be encoded.
 * @returns {Buffer}
 * @memberof Multibase
 */
function encode (nameOrCode, buf) {
  const base = getBase(nameOrCode)
  const name = base.name

  return multibase(name, Buffer.from(base.encode(buf)))
}

/**
 * Takes a buffer or string encoded with multibase header, decodes it and
 * returns the decoded buffer
 *
 * @param {Buffer|string} bufOrString
 * @returns {Buffer}
 * @memberof Multibase
 *
 */
function decode (bufOrString) {
  if (Buffer.isBuffer(bufOrString)) {
    bufOrString = bufOrString.toString()
  }

  const code = bufOrString.substring(0, 1)
  bufOrString = bufOrString.substring(1, bufOrString.length)

  if (typeof bufOrString === 'string') {
    bufOrString = Buffer.from(bufOrString)
  }

  const base = getBase(code)
  return Buffer.from(base.decode(bufOrString.toString()))
}

/**
 * Is the given data multibase encoded?
 *
 * @param {Buffer|string} bufOrString
 * @returns {boolean}
 * @memberof Multibase
 */
function isEncoded (bufOrString) {
  if (Buffer.isBuffer(bufOrString)) {
    bufOrString = bufOrString.toString()
  }

  // Ensure bufOrString is a string
  if (Object.prototype.toString.call(bufOrString) !== '[object String]') {
    return false
  }

  const code = bufOrString.substring(0, 1)
  try {
    const base = getBase(code)
    return base.name
  } catch (err) {
    return false
  }
}

/**
 * @param {string} name
 * @param {Buffer} buf
 * @private
 * @returns {undefined}
 */
function validEncode (name, buf) {
  const base = getBase(name)
  base.decode(buf.toString())
}

function getBase (nameOrCode) {
  let base

  if (constants.names[nameOrCode]) {
    base = constants.names[nameOrCode]
  } else if (constants.codes[nameOrCode]) {
    base = constants.codes[nameOrCode]
  } else {
    throw errNotSupported
  }

  if (!base.isImplemented()) {
    throw new Error('Base ' + nameOrCode + ' is not implemented yet')
  }

  return base
}


/***/ }),

/***/ 20792:
/***/ ((module) => {

"use strict";


class Base {
  constructor (name, code, implementation, alphabet) {
    this.name = name
    this.code = code
    this.alphabet = alphabet
    if (implementation && alphabet) {
      this.engine = implementation(alphabet)
    }
  }

  encode (stringOrBuffer) {
    return this.engine.encode(stringOrBuffer)
  }

  decode (stringOrBuffer) {
    return this.engine.decode(stringOrBuffer)
  }

  isImplemented () {
    return this.engine
  }
}

module.exports = Base


/***/ }),

/***/ 20020:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const { Buffer } = __webpack_require__(19444)

module.exports = function base16 (alphabet) {
  return {
    encode (input) {
      if (typeof input === 'string') {
        return Buffer.from(input).toString('hex')
      }
      return input.toString('hex')
    },
    decode (input) {
      for (const char of input) {
        if (alphabet.indexOf(char) < 0) {
          throw new Error('invalid base16 character')
        }
      }
      return Buffer.from(input, 'hex')
    }
  }
}


/***/ }),

/***/ 87365:
/***/ ((module) => {

"use strict";


function decode (input, alphabet) {
  input = input.replace(new RegExp('=', 'g'), '')
  const length = input.length

  let bits = 0
  let value = 0

  let index = 0
  const output = new Uint8Array((length * 5 / 8) | 0)

  for (let i = 0; i < length; i++) {
    value = (value << 5) | alphabet.indexOf(input[i])
    bits += 5

    if (bits >= 8) {
      output[index++] = (value >>> (bits - 8)) & 255
      bits -= 8
    }
  }

  return output.buffer
}

function encode (buffer, alphabet) {
  const length = buffer.byteLength
  const view = new Uint8Array(buffer)
  const padding = alphabet.indexOf('=') === alphabet.length - 1

  if (padding) {
    alphabet = alphabet.substring(0, alphabet.length - 1)
  }

  let bits = 0
  let value = 0
  let output = ''

  for (let i = 0; i < length; i++) {
    value = (value << 8) | view[i]
    bits += 8

    while (bits >= 5) {
      output += alphabet[(value >>> (bits - 5)) & 31]
      bits -= 5
    }
  }

  if (bits > 0) {
    output += alphabet[(value << (5 - bits)) & 31]
  }

  if (padding) {
    while ((output.length % 8) !== 0) {
      output += '='
    }
  }

  return output
}

module.exports = function base32 (alphabet) {
  return {
    encode (input) {
      if (typeof input === 'string') {
        return encode(Uint8Array.from(input), alphabet)
      }

      return encode(input, alphabet)
    },
    decode (input) {
      for (const char of input) {
        if (alphabet.indexOf(char) < 0) {
          throw new Error('invalid base32 character')
        }
      }

      return decode(input, alphabet)
    }
  }
}


/***/ }),

/***/ 64058:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const { Buffer } = __webpack_require__(19444)

module.exports = function base64 (alphabet) {
  // The alphabet is only used to know:
  //   1. If padding is enabled (must contain '=')
  //   2. If the output must be url-safe (must contain '-' and '_')
  //   3. If the input of the output function is valid
  // The alphabets from RFC 4648 are always used.
  const padding = alphabet.indexOf('=') > -1
  const url = alphabet.indexOf('-') > -1 && alphabet.indexOf('_') > -1

  return {
    encode (input) {
      let output = ''

      if (typeof input === 'string') {
        output = Buffer.from(input).toString('base64')
      } else {
        output = input.toString('base64')
      }

      if (url) {
        output = output.replace(/\+/g, '-').replace(/\//g, '_')
      }

      const pad = output.indexOf('=')
      if (pad > 0 && !padding) {
        output = output.substring(0, pad)
      }

      return output
    },
    decode (input) {
      for (const char of input) {
        if (alphabet.indexOf(char) < 0) {
          throw new Error('invalid base64 character')
        }
      }

      return Buffer.from(input, 'base64')
    }
  }
}


/***/ }),

/***/ 54726:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Base = __webpack_require__(20792)
const baseX = __webpack_require__(33206)
const base16 = __webpack_require__(20020)
const base32 = __webpack_require__(87365)
const base64 = __webpack_require__(64058)

// name, code, implementation, alphabet
const constants = [
  ['base1', '1', '', '1'],
  ['base2', '0', baseX, '01'],
  ['base8', '7', baseX, '01234567'],
  ['base10', '9', baseX, '0123456789'],
  ['base16', 'f', base16, '0123456789abcdef'],
  ['base32', 'b', base32, 'abcdefghijklmnopqrstuvwxyz234567'],
  ['base32pad', 'c', base32, 'abcdefghijklmnopqrstuvwxyz234567='],
  ['base32hex', 'v', base32, '0123456789abcdefghijklmnopqrstuv'],
  ['base32hexpad', 't', base32, '0123456789abcdefghijklmnopqrstuv='],
  ['base32z', 'h', base32, 'ybndrfg8ejkmcpqxot1uwisza345h769'],
  ['base58flickr', 'Z', baseX, '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'],
  ['base58btc', 'z', baseX, '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'],
  ['base64', 'm', base64, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'],
  ['base64pad', 'M', base64, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='],
  ['base64url', 'u', base64, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'],
  ['base64urlpad', 'U', base64, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=']
]

const names = constants.reduce((prev, tupple) => {
  prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3])
  return prev
}, {})

const codes = constants.reduce((prev, tupple) => {
  prev[tupple[1]] = names[tupple[0]]
  return prev
}, {})

module.exports = {
  names: names,
  codes: codes
}


/***/ }),

/***/ 6955:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Implementation of the [multibase](https://github.com/multiformats/multibase) specification.
 * @module Multibase
 */


const { Buffer } = __webpack_require__(19444)
const constants = __webpack_require__(54726)

exports = module.exports = multibase
exports.encode = encode
exports.decode = decode
exports.isEncoded = isEncoded
exports.names = Object.freeze(Object.keys(constants.names))
exports.codes = Object.freeze(Object.keys(constants.codes))

/**
 * Create a new buffer with the multibase varint+code.
 *
 * @param {string|number} nameOrCode - The multibase name or code number.
 * @param {Buffer} buf - The data to be prefixed with multibase.
 * @memberof Multibase
 * @returns {Buffer}
 */
function multibase (nameOrCode, buf) {
  if (!buf) {
    throw new Error('requires an encoded buffer')
  }
  const base = getBase(nameOrCode)
  const codeBuf = Buffer.from(base.code)

  const name = base.name
  validEncode(name, buf)
  return Buffer.concat([codeBuf, buf])
}

/**
 * Encode data with the specified base and add the multibase prefix.
 *
 * @param {string|number} nameOrCode - The multibase name or code number.
 * @param {Buffer} buf - The data to be encoded.
 * @returns {Buffer}
 * @memberof Multibase
 */
function encode (nameOrCode, buf) {
  const base = getBase(nameOrCode)
  const name = base.name

  return multibase(name, Buffer.from(base.encode(buf)))
}

/**
 * Takes a buffer or string encoded with multibase header, decodes it and
 * returns the decoded buffer
 *
 * @param {Buffer|string} bufOrString
 * @returns {Buffer}
 * @memberof Multibase
 *
 */
function decode (bufOrString) {
  if (Buffer.isBuffer(bufOrString)) {
    bufOrString = bufOrString.toString()
  }

  const code = bufOrString.substring(0, 1)
  bufOrString = bufOrString.substring(1, bufOrString.length)

  if (typeof bufOrString === 'string') {
    bufOrString = Buffer.from(bufOrString)
  }

  const base = getBase(code)
  return Buffer.from(base.decode(bufOrString.toString()))
}

/**
 * Is the given data multibase encoded?
 *
 * @param {Buffer|string} bufOrString
 * @returns {boolean}
 * @memberof Multibase
 */
function isEncoded (bufOrString) {
  if (Buffer.isBuffer(bufOrString)) {
    bufOrString = bufOrString.toString()
  }

  // Ensure bufOrString is a string
  if (Object.prototype.toString.call(bufOrString) !== '[object String]') {
    return false
  }

  const code = bufOrString.substring(0, 1)
  try {
    const base = getBase(code)
    return base.name
  } catch (err) {
    return false
  }
}

/**
 * @param {string} name
 * @param {Buffer} buf
 * @private
 * @returns {undefined}
 */
function validEncode (name, buf) {
  const base = getBase(name)
  base.decode(buf.toString())
}

function getBase (nameOrCode) {
  let base

  if (constants.names[nameOrCode]) {
    base = constants.names[nameOrCode]
  } else if (constants.codes[nameOrCode]) {
    base = constants.codes[nameOrCode]
  } else {
    throw new Error('Unsupported encoding')
  }

  if (!base.isImplemented()) {
    throw new Error('Base ' + nameOrCode + ' is not implemented yet')
  }

  return base
}


/***/ }),

/***/ 52528:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var __webpack_provided_process_dot_nextTick = __webpack_require__(52528);


var ensureCallable = function (fn) {
	if (typeof fn !== 'function') throw new TypeError(fn + " is not a function");
	return fn;
};

var byObserver = function (Observer) {
	var node = document.createTextNode(''), queue, currentQueue, i = 0;
	new Observer(function () {
		var callback;
		if (!queue) {
			if (!currentQueue) return;
			queue = currentQueue;
		} else if (currentQueue) {
			queue = currentQueue.concat(queue);
		}
		currentQueue = queue;
		queue = null;
		if (typeof currentQueue === 'function') {
			callback = currentQueue;
			currentQueue = null;
			callback();
			return;
		}
		node.data = (i = ++i % 2); // Invoke other batch, to handle leftover callbacks in case of crash
		while (currentQueue) {
			callback = currentQueue.shift();
			if (!currentQueue.length) currentQueue = null;
			callback();
		}
	}).observe(node, { characterData: true });
	return function (fn) {
		ensureCallable(fn);
		if (queue) {
			if (typeof queue === 'function') queue = [queue, fn];
			else queue.push(fn);
			return;
		}
		queue = fn;
		node.data = (i = ++i % 2);
	};
};

module.exports = (function () {
	// Node.js
	if ((typeof process === 'object') && process && (typeof __webpack_provided_process_dot_nextTick === 'function')) {
		return __webpack_provided_process_dot_nextTick;
	}

	// queueMicrotask
	if (typeof queueMicrotask === "function") {
		return function (cb) { queueMicrotask(ensureCallable(cb)); };
	}

	// MutationObserver
	if ((typeof document === 'object') && document) {
		if (typeof MutationObserver === 'function') return byObserver(MutationObserver);
		if (typeof WebKitMutationObserver === 'function') return byObserver(WebKitMutationObserver);
	}

	// W3C Draft
	// http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html
	if (typeof setImmediate === 'function') {
		return function (cb) { setImmediate(ensureCallable(cb)); };
	}

	// Wide available standard
	if ((typeof setTimeout === 'function') || (typeof setTimeout === 'object')) {
		return function (cb) { setTimeout(ensureCallable(cb), 0); };
	}

	return null;
}());


/***/ }),

/***/ 31638:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var BN = __webpack_require__(95081);
var stripHexPrefix = __webpack_require__(12325);

/**
 * Returns a BN object, converts a number value to a BN
 * @param {String|Number|Object} `arg` input a string number, hex string number, number, BigNumber or BN object
 * @return {Object} `output` BN object of the number
 * @throws if the argument is not an array, object that isn't a bignumber, not a string number or number
 */
module.exports = function numberToBN(arg) {
  if (typeof arg === 'string' || typeof arg === 'number') {
    var multiplier = new BN(1); // eslint-disable-line
    var formattedString = String(arg).toLowerCase().trim();
    var isHexPrefixed = formattedString.substr(0, 2) === '0x' || formattedString.substr(0, 3) === '-0x';
    var stringArg = stripHexPrefix(formattedString); // eslint-disable-line
    if (stringArg.substr(0, 1) === '-') {
      stringArg = stripHexPrefix(stringArg.slice(1));
      multiplier = new BN(-1, 10);
    }
    stringArg = stringArg === '' ? '0' : stringArg;

    if ((!stringArg.match(/^-?[0-9]+$/) && stringArg.match(/^[0-9A-Fa-f]+$/))
      || stringArg.match(/^[a-fA-F]+$/)
      || (isHexPrefixed === true && stringArg.match(/^[0-9A-Fa-f]+$/))) {
      return new BN(stringArg, 16).mul(multiplier);
    }

    if ((stringArg.match(/^-?[0-9]+$/) || stringArg === '') && isHexPrefixed === false) {
      return new BN(stringArg, 10).mul(multiplier);
    }
  } else if (typeof arg === 'object' && arg.toString && (!arg.pop && !arg.push)) {
    if (arg.toString(10).match(/^-?[0-9]+$/) && (arg.mul || arg.dividedToIntegerBy)) {
      return new BN(arg.toString(10), 10);
    }
  }

  throw new Error('[number-to-bn] while converting number ' + JSON.stringify(arg) + ' to BN.js instance, error: invalid number value. Value must be an integer, hex string, BN or BigNumber instance. Note, decimals are not supported.');
}


/***/ }),

/***/ 29879:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
// ie, `has-tostringtag/shams
var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')
    ? Symbol.toStringTag
    : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;

var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (
    [].__proto__ === Array.prototype // eslint-disable-line no-proto
        ? function (O) {
            return O.__proto__; // eslint-disable-line no-proto
        }
        : null
);

function addNumericSeparator(num, str) {
    if (
        num === Infinity
        || num === -Infinity
        || num !== num
        || (num && num > -1000 && num < 1000)
        || $test.call(/e/, str)
    ) {
        return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === 'number') {
        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
        if (int !== num) {
            var intStr = String(int);
            var dec = $slice.call(str, intStr.length + 1);
            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
        }
    }
    return $replace.call(str, sepRegex, '$&_');
}

var utilInspect = __webpack_require__(57002);
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;

module.exports = function inspect_(obj, options, depth, seen) {
    var opts = options || {};

    if (has(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (
        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
            : opts.maxStringLength !== null
        )
    ) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
    }

    if (
        has(opts, 'indent')
        && opts.indent !== null
        && opts.indent !== '\t'
        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
    ) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;

    if (typeof obj === 'undefined') {
        return 'undefined';
    }
    if (obj === null) {
        return 'null';
    }
    if (typeof obj === 'boolean') {
        return obj ? 'true' : 'false';
    }

    if (typeof obj === 'string') {
        return inspectString(obj, opts);
    }
    if (typeof obj === 'number') {
        if (obj === 0) {
            return Infinity / obj > 0 ? '0' : '-0';
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === 'bigint') {
        var bigIntStr = String(obj) + 'n';
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }

    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') { depth = 0; }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
        return isArray(obj) ? '[Array]' : '[Object]';
    }

    var indent = getIndent(opts, depth);

    if (typeof seen === 'undefined') {
        seen = [];
    } else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }

    function inspect(value, from, noIndent) {
        if (from) {
            seen = $arrSlice.call(seen);
            seen.push(from);
        }
        if (noIndent) {
            var newOpts = {
                depth: opts.depth
            };
            if (has(opts, 'quoteStyle')) {
                newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
    }

    if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
    }
    if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = '<' + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) { s += '...'; }
        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
        return s;
    }
    if (isArray(obj)) {
        if (obj.length === 0) { return '[]'; }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
            return '[' + indentedJoin(xs, indent) + ']';
        }
        return '[ ' + $join.call(xs, ', ') + ' ]';
    }
    if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
        }
        if (parts.length === 0) { return '[' + String(obj) + ']'; }
        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
    }
    if (typeof obj === 'object' && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
            return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
            return obj.inspect();
        }
    }
    if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
            mapForEach.call(obj, function (value, key) {
                mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
            });
        }
        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
            setForEach.call(obj, function (value) {
                setParts.push(inspect(value, obj));
            });
        }
        return collectionOf('Set', setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
        return weakCollectionOf('WeakMap');
    }
    if (isWeakSet(obj)) {
        return weakCollectionOf('WeakSet');
    }
    if (isWeakRef(obj)) {
        return weakCollectionOf('WeakRef');
    }
    if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
    }
    if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? '' : 'null prototype';
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
        if (ys.length === 0) { return tag + '{}'; }
        if (indent) {
            return tag + '{' + indentedJoin(ys, indent) + '}';
        }
        return tag + '{ ' + $join.call(ys, ', ') + ' }';
    }
    return String(obj);
};

function wrapQuotes(s, defaultStyle, opts) {
    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
    return quoteChar + s + quoteChar;
}

function quote(s) {
    return $replace.call(String(s), /"/g, '&quot;');
}

function isArray(obj) { return toStr(obj) === '[object Array]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isDate(obj) { return toStr(obj) === '[object Date]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isRegExp(obj) { return toStr(obj) === '[object RegExp]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isError(obj) { return toStr(obj) === '[object Error]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isString(obj) { return toStr(obj) === '[object String]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isNumber(obj) { return toStr(obj) === '[object Number]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isBoolean(obj) { return toStr(obj) === '[object Boolean]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }

// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
function isSymbol(obj) {
    if (hasShammedSymbols) {
        return obj && typeof obj === 'object' && obj instanceof Symbol;
    }
    if (typeof obj === 'symbol') {
        return true;
    }
    if (!obj || typeof obj !== 'object' || !symToString) {
        return false;
    }
    try {
        symToString.call(obj);
        return true;
    } catch (e) {}
    return false;
}

function isBigInt(obj) {
    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
        return false;
    }
    try {
        bigIntValueOf.call(obj);
        return true;
    } catch (e) {}
    return false;
}

var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
function has(obj, key) {
    return hasOwn.call(obj, key);
}

function toStr(obj) {
    return objectToString.call(obj);
}

function nameOf(f) {
    if (f.name) { return f.name; }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) { return m[1]; }
    return null;
}

function indexOf(xs, x) {
    if (xs.indexOf) { return xs.indexOf(x); }
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) { return i; }
    }
    return -1;
}

function isMap(x) {
    if (!mapSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        mapSize.call(x);
        try {
            setSize.call(x);
        } catch (s) {
            return true;
        }
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakMapHas.call(x, weakMapHas);
        try {
            weakSetHas.call(x, weakSetHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakRefDeref.call(x);
        return true;
    } catch (e) {}
    return false;
}

function isSet(x) {
    if (!setSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        setSize.call(x);
        try {
            mapSize.call(x);
        } catch (m) {
            return true;
        }
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakSetHas.call(x, weakSetHas);
        try {
            weakMapHas.call(x, weakMapHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isElement(x) {
    if (!x || typeof x !== 'object') { return false; }
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}

function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    // eslint-disable-next-line no-control-regex
    var s = $replace.call($replace.call(str, /(['\\])/g, '\\$1'), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
}

function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
        8: 'b',
        9: 't',
        10: 'n',
        12: 'f',
        13: 'r'
    }[n];
    if (x) { return '\\' + x; }
    return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
}

function markBoxed(str) {
    return 'Object(' + str + ')';
}

function weakCollectionOf(type) {
    return type + ' { ? }';
}

function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
    return type + ' (' + size + ') {' + joinedEntries + '}';
}

function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], '\n') >= 0) {
            return false;
        }
    }
    return true;
}

function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === '\t') {
        baseIndent = '\t';
    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), ' ');
    } else {
        return null;
    }
    return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
    };
}

function indentedJoin(xs, indent) {
    if (xs.length === 0) { return ''; }
    var lineJoiner = '\n' + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
}

function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
    }
    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
            symMap['$' + syms[k]] = syms[k];
        }
    }

    for (var key in obj) { // eslint-disable-line no-restricted-syntax
        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        } else if ($test.call(/[^\w$]/, key)) {
            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
        } else {
            xs.push(key + ': ' + inspect(obj[key], obj));
        }
    }
    if (typeof gOPS === 'function') {
        for (var j = 0; j < syms.length; j++) {
            if (isEnumerable.call(obj, syms[j])) {
                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
            }
        }
    }
    return xs;
}


/***/ }),

/***/ 56982:
/***/ ((module) => {

"use strict";


var numberIsNaN = function (value) {
	return value !== value;
};

module.exports = function is(a, b) {
	if (a === 0 && b === 0) {
		return 1 / a === 1 / b;
	}
	if (a === b) {
		return true;
	}
	if (numberIsNaN(a) && numberIsNaN(b)) {
		return true;
	}
	return false;
};



/***/ }),

/***/ 7560:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(34448);
var callBind = __webpack_require__(26210);

var implementation = __webpack_require__(56982);
var getPolyfill = __webpack_require__(76351);
var shim = __webpack_require__(53583);

var polyfill = callBind(getPolyfill(), Object);

define(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;


/***/ }),

/***/ 76351:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(56982);

module.exports = function getPolyfill() {
	return typeof Object.is === 'function' ? Object.is : implementation;
};


/***/ }),

/***/ 53583:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getPolyfill = __webpack_require__(76351);
var define = __webpack_require__(34448);

module.exports = function shimObjectIs() {
	var polyfill = getPolyfill();
	define(Object, { is: polyfill }, {
		is: function testObjectIs() {
			return Object.is !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),

/***/ 19215:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var keysShim;
if (!Object.keys) {
	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var isArgs = __webpack_require__(47578); // eslint-disable-line global-require
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$applicationCache: true,
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$onmozfullscreenchange: true,
		$onmozfullscreenerror: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};

	keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
}
module.exports = keysShim;


/***/ }),

/***/ 98519:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var slice = Array.prototype.slice;
var isArgs = __webpack_require__(47578);

var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) { return origKeys(o); } : __webpack_require__(19215);

var originalKeys = Object.keys;

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			var args = Object.keys(arguments);
			return args && args.length === arguments.length;
		}(1, 2));
		if (!keysWorksWithArguments) {
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				}
				return originalKeys(object);
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;


/***/ }),

/***/ 47578:
/***/ ((module) => {

"use strict";


var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};


/***/ }),

/***/ 13699:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// modified from https://github.com/es-shims/es6-shim
var objectKeys = __webpack_require__(98519);
var hasSymbols = __webpack_require__(72502)();
var callBound = __webpack_require__(8507);
var toObject = Object;
var $push = callBound('Array.prototype.push');
var $propIsEnumerable = callBound('Object.prototype.propertyIsEnumerable');
var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;

// eslint-disable-next-line no-unused-vars
module.exports = function assign(target, source1) {
	if (target == null) { throw new TypeError('target must be an object'); }
	var to = toObject(target); // step 1
	if (arguments.length === 1) {
		return to; // step 2
	}
	for (var s = 1; s < arguments.length; ++s) {
		var from = toObject(arguments[s]); // step 3.a.i

		// step 3.a.ii:
		var keys = objectKeys(from);
		var getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);
		if (getSymbols) {
			var syms = getSymbols(from);
			for (var j = 0; j < syms.length; ++j) {
				var key = syms[j];
				if ($propIsEnumerable(from, key)) {
					$push(keys, key);
				}
			}
		}

		// step 3.a.iii:
		for (var i = 0; i < keys.length; ++i) {
			var nextKey = keys[i];
			if ($propIsEnumerable(from, nextKey)) { // step 3.a.iii.2
				var propValue = from[nextKey]; // step 3.a.iii.2.a
				to[nextKey] = propValue; // step 3.a.iii.2.b
			}
		}
	}

	return to; // step 4
};


/***/ }),

/***/ 69183:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(13699);

var lacksProperEnumerationOrder = function () {
	if (!Object.assign) {
		return false;
	}
	/*
	 * v8, specifically in node 4.x, has a bug with incorrect property enumeration order
	 * note: this does not detect the bug unless there's 20 characters
	 */
	var str = 'abcdefghijklmnopqrst';
	var letters = str.split('');
	var map = {};
	for (var i = 0; i < letters.length; ++i) {
		map[letters[i]] = letters[i];
	}
	var obj = Object.assign({}, map);
	var actual = '';
	for (var k in obj) {
		actual += k;
	}
	return str !== actual;
};

var assignHasPendingExceptions = function () {
	if (!Object.assign || !Object.preventExtensions) {
		return false;
	}
	/*
	 * Firefox 37 still has "pending exception" logic in its Object.assign implementation,
	 * which is 72% slower than our shim, and Firefox 40's native implementation.
	 */
	var thrower = Object.preventExtensions({ 1: 2 });
	try {
		Object.assign(thrower, 'xy');
	} catch (e) {
		return thrower[1] === 'y';
	}
	return false;
};

module.exports = function getPolyfill() {
	if (!Object.assign) {
		return implementation;
	}
	if (lacksProperEnumerationOrder()) {
		return implementation;
	}
	if (assignHasPendingExceptions()) {
		return implementation;
	}
	return Object.assign;
};


/***/ }),

/***/ 71578:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wrappy = __webpack_require__(71285)
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}


/***/ }),

/***/ 21836:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js
// Fedor, you are amazing.


var asn1 = __webpack_require__(85041)

exports.certificate = __webpack_require__(80565)

var RSAPrivateKey = asn1.define('RSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('modulus').int(),
    this.key('publicExponent').int(),
    this.key('privateExponent').int(),
    this.key('prime1').int(),
    this.key('prime2').int(),
    this.key('exponent1').int(),
    this.key('exponent2').int(),
    this.key('coefficient').int()
  )
})
exports.RSAPrivateKey = RSAPrivateKey

var RSAPublicKey = asn1.define('RSAPublicKey', function () {
  this.seq().obj(
    this.key('modulus').int(),
    this.key('publicExponent').int()
  )
})
exports.RSAPublicKey = RSAPublicKey

var PublicKey = asn1.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})
exports.PublicKey = PublicKey

var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('none').null_().optional(),
    this.key('curve').objid().optional(),
    this.key('params').seq().obj(
      this.key('p').int(),
      this.key('q').int(),
      this.key('g').int()
    ).optional()
  )
})

var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPrivateKey').octstr()
  )
})
exports.PrivateKey = PrivateKeyInfo
var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').seq().obj(
      this.key('id').objid(),
      this.key('decrypt').seq().obj(
        this.key('kde').seq().obj(
          this.key('id').objid(),
          this.key('kdeparams').seq().obj(
            this.key('salt').octstr(),
            this.key('iters').int()
          )
        ),
        this.key('cipher').seq().obj(
          this.key('algo').objid(),
          this.key('iv').octstr()
        )
      )
    ),
    this.key('subjectPrivateKey').octstr()
  )
})

exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo

var DSAPrivateKey = asn1.define('DSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('p').int(),
    this.key('q').int(),
    this.key('g').int(),
    this.key('pub_key').int(),
    this.key('priv_key').int()
  )
})
exports.DSAPrivateKey = DSAPrivateKey

exports.DSAparam = asn1.define('DSAparam', function () {
  this.int()
})

var ECPrivateKey = asn1.define('ECPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('privateKey').octstr(),
    this.key('parameters').optional().explicit(0).use(ECParameters),
    this.key('publicKey').optional().explicit(1).bitstr()
  )
})
exports.ECPrivateKey = ECPrivateKey

var ECParameters = asn1.define('ECParameters', function () {
  this.choice({
    namedCurve: this.objid()
  })
})

exports.signature = asn1.define('signature', function () {
  this.seq().obj(
    this.key('r').int(),
    this.key('s').int()
  )
})


/***/ }),

/***/ 80565:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// from https://github.com/Rantanen/node-dtls/blob/25a7dc861bda38cfeac93a723500eea4f0ac2e86/Certificate.js
// thanks to @Rantanen



var asn = __webpack_require__(85041)

var Time = asn.define('Time', function () {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  })
})

var AttributeTypeValue = asn.define('AttributeTypeValue', function () {
  this.seq().obj(
    this.key('type').objid(),
    this.key('value').any()
  )
})

var AlgorithmIdentifier = asn.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('parameters').optional(),
    this.key('curve').objid().optional()
  )
})

var SubjectPublicKeyInfo = asn.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})

var RelativeDistinguishedName = asn.define('RelativeDistinguishedName', function () {
  this.setof(AttributeTypeValue)
})

var RDNSequence = asn.define('RDNSequence', function () {
  this.seqof(RelativeDistinguishedName)
})

var Name = asn.define('Name', function () {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  })
})

var Validity = asn.define('Validity', function () {
  this.seq().obj(
    this.key('notBefore').use(Time),
    this.key('notAfter').use(Time)
  )
})

var Extension = asn.define('Extension', function () {
  this.seq().obj(
    this.key('extnID').objid(),
    this.key('critical').bool().def(false),
    this.key('extnValue').octstr()
  )
})

var TBSCertificate = asn.define('TBSCertificate', function () {
  this.seq().obj(
    this.key('version').explicit(0).int().optional(),
    this.key('serialNumber').int(),
    this.key('signature').use(AlgorithmIdentifier),
    this.key('issuer').use(Name),
    this.key('validity').use(Validity),
    this.key('subject').use(Name),
    this.key('subjectPublicKeyInfo').use(SubjectPublicKeyInfo),
    this.key('issuerUniqueID').implicit(1).bitstr().optional(),
    this.key('subjectUniqueID').implicit(2).bitstr().optional(),
    this.key('extensions').explicit(3).seqof(Extension).optional()
  )
})

var X509Certificate = asn.define('X509Certificate', function () {
  this.seq().obj(
    this.key('tbsCertificate').use(TBSCertificate),
    this.key('signatureAlgorithm').use(AlgorithmIdentifier),
    this.key('signatureValue').bitstr()
  )
})

module.exports = X509Certificate


/***/ }),

/***/ 77648:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// adapted from https://github.com/apatil/pemstrip
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m
var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m
var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m
var evp = __webpack_require__(76778)
var ciphers = __webpack_require__(79876)
var Buffer = (__webpack_require__(80480).Buffer)
module.exports = function (okey, password) {
  var key = okey.toString()
  var match = key.match(findProc)
  var decrypted
  if (!match) {
    var match2 = key.match(fullRegex)
    decrypted = Buffer.from(match2[2].replace(/[\r\n]/g, ''), 'base64')
  } else {
    var suite = 'aes' + match[1]
    var iv = Buffer.from(match[2], 'hex')
    var cipherText = Buffer.from(match[3].replace(/[\r\n]/g, ''), 'base64')
    var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key
    var out = []
    var cipher = ciphers.createDecipheriv(suite, cipherKey, iv)
    out.push(cipher.update(cipherText))
    out.push(cipher.final())
    decrypted = Buffer.concat(out)
  }
  var tag = key.match(startRegex)[1]
  return {
    tag: tag,
    data: decrypted
  }
}


/***/ }),

/***/ 62992:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var asn1 = __webpack_require__(21836)
var aesid = __webpack_require__(22087)
var fixProc = __webpack_require__(77648)
var ciphers = __webpack_require__(79876)
var compat = __webpack_require__(3070)
var Buffer = (__webpack_require__(80480).Buffer)
module.exports = parseKeys

function parseKeys (buffer) {
  var password
  if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
    password = buffer.passphrase
    buffer = buffer.key
  }
  if (typeof buffer === 'string') {
    buffer = Buffer.from(buffer)
  }

  var stripped = fixProc(buffer, password)

  var type = stripped.tag
  var data = stripped.data
  var subtype, ndata
  switch (type) {
    case 'CERTIFICATE':
      ndata = asn1.certificate.decode(data, 'der').tbsCertificate.subjectPublicKeyInfo
      // falls through
    case 'PUBLIC KEY':
      if (!ndata) {
        ndata = asn1.PublicKey.decode(data, 'der')
      }
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der')
        case '1.2.840.10045.2.1':
          ndata.subjectPrivateKey = ndata.subjectPublicKey
          return {
            type: 'ec',
            data: ndata
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der')
          return {
            type: 'dsa',
            data: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      // throw new Error('unknown key type ' + type)
    case 'ENCRYPTED PRIVATE KEY':
      data = asn1.EncryptedPrivateKey.decode(data, 'der')
      data = decrypt(data, password)
      // falls through
    case 'PRIVATE KEY':
      ndata = asn1.PrivateKey.decode(data, 'der')
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der')
        case '1.2.840.10045.2.1':
          return {
            curve: ndata.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der')
          return {
            type: 'dsa',
            params: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      // throw new Error('unknown key type ' + type)
    case 'RSA PUBLIC KEY':
      return asn1.RSAPublicKey.decode(data, 'der')
    case 'RSA PRIVATE KEY':
      return asn1.RSAPrivateKey.decode(data, 'der')
    case 'DSA PRIVATE KEY':
      return {
        type: 'dsa',
        params: asn1.DSAPrivateKey.decode(data, 'der')
      }
    case 'EC PRIVATE KEY':
      data = asn1.ECPrivateKey.decode(data, 'der')
      return {
        curve: data.parameters.value,
        privateKey: data.privateKey
      }
    default: throw new Error('unknown key type ' + type)
  }
}
parseKeys.signature = asn1.signature
function decrypt (data, password) {
  var salt = data.algorithm.decrypt.kde.kdeparams.salt
  var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10)
  var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')]
  var iv = data.algorithm.decrypt.cipher.iv
  var cipherText = data.subjectPrivateKey
  var keylen = parseInt(algo.split('-')[1], 10) / 8
  var key = compat.pbkdf2Sync(password, salt, iters, keylen, 'sha1')
  var cipher = ciphers.createDecipheriv(algo, key, iv)
  var out = []
  out.push(cipher.update(cipherText))
  out.push(cipher.final())
  return Buffer.concat(out)
}


/***/ }),

/***/ 43088:
/***/ ((__unused_webpack_module, exports) => {

/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};


/***/ }),

/***/ 59504:
/***/ ((module) => {

/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    uri.pathNames = pathNames(uri, uri['path']);
    uri.queryKey = queryKey(uri, uri['query']);

    return uri;
};

function pathNames(obj, path) {
    var regx = /\/{2,9}/g,
        names = path.replace(regx, "/").split("/");

    if (path.substr(0, 1) == '/' || path.length === 0) {
        names.splice(0, 1);
    }
    if (path.substr(path.length - 1, 1) == '/') {
        names.splice(names.length - 1, 1);
    }

    return names;
}

function queryKey(uri, query) {
    var data = {};

    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {
        if ($1) {
            data[$1] = $2;
        }
    });

    return data;
}


/***/ }),

/***/ 3070:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.pbkdf2 = __webpack_require__(31580)
exports.pbkdf2Sync = __webpack_require__(26164)


/***/ }),

/***/ 31580:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Buffer = (__webpack_require__(80480).Buffer)

var checkParameters = __webpack_require__(32446)
var defaultEncoding = __webpack_require__(66594)
var sync = __webpack_require__(26164)
var toBuffer = __webpack_require__(87357)

var ZERO_BUF
var subtle = __webpack_require__.g.crypto && __webpack_require__.g.crypto.subtle
var toBrowser = {
  sha: 'SHA-1',
  'sha-1': 'SHA-1',
  sha1: 'SHA-1',
  sha256: 'SHA-256',
  'sha-256': 'SHA-256',
  sha384: 'SHA-384',
  'sha-384': 'SHA-384',
  'sha-512': 'SHA-512',
  sha512: 'SHA-512'
}
var checks = []
function checkNative (algo) {
  if (__webpack_require__.g.process && !__webpack_require__.g.process.browser) {
    return Promise.resolve(false)
  }
  if (!subtle || !subtle.importKey || !subtle.deriveBits) {
    return Promise.resolve(false)
  }
  if (checks[algo] !== undefined) {
    return checks[algo]
  }
  ZERO_BUF = ZERO_BUF || Buffer.alloc(8)
  var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo)
    .then(function () {
      return true
    }).catch(function () {
      return false
    })
  checks[algo] = prom
  return prom
}
var nextTick
function getNextTick () {
  if (nextTick) {
    return nextTick
  }
  if (__webpack_require__.g.process && __webpack_require__.g.process.nextTick) {
    nextTick = __webpack_require__.g.process.nextTick
  } else if (__webpack_require__.g.queueMicrotask) {
    nextTick = __webpack_require__.g.queueMicrotask
  } else if (__webpack_require__.g.setImmediate) {
    nextTick = __webpack_require__.g.setImmediate
  } else {
    nextTick = __webpack_require__.g.setTimeout
  }
  return nextTick
}
function browserPbkdf2 (password, salt, iterations, length, algo) {
  return subtle.importKey(
    'raw', password, { name: 'PBKDF2' }, false, ['deriveBits']
  ).then(function (key) {
    return subtle.deriveBits({
      name: 'PBKDF2',
      salt: salt,
      iterations: iterations,
      hash: {
        name: algo
      }
    }, key, length << 3)
  }).then(function (res) {
    return Buffer.from(res)
  })
}

function resolvePromise (promise, callback) {
  promise.then(function (out) {
    getNextTick()(function () {
      callback(null, out)
    })
  }, function (e) {
    getNextTick()(function () {
      callback(e)
    })
  })
}
module.exports = function (password, salt, iterations, keylen, digest, callback) {
  if (typeof digest === 'function') {
    callback = digest
    digest = undefined
  }

  digest = digest || 'sha1'
  var algo = toBrowser[digest.toLowerCase()]

  if (!algo || typeof __webpack_require__.g.Promise !== 'function') {
    getNextTick()(function () {
      var out
      try {
        out = sync(password, salt, iterations, keylen, digest)
      } catch (e) {
        return callback(e)
      }
      callback(null, out)
    })
    return
  }

  checkParameters(iterations, keylen)
  password = toBuffer(password, defaultEncoding, 'Password')
  salt = toBuffer(salt, defaultEncoding, 'Salt')
  if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2')

  resolvePromise(checkNative(algo).then(function (resp) {
    if (resp) return browserPbkdf2(password, salt, iterations, keylen, algo)

    return sync(password, salt, iterations, keylen, digest)
  }), callback)
}


/***/ }),

/***/ 66594:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defaultEncoding
/* istanbul ignore next */
if (__webpack_require__.g.process && __webpack_require__.g.process.browser) {
  defaultEncoding = 'utf-8'
} else if (__webpack_require__.g.process && __webpack_require__.g.process.version) {
  var pVersionMajor = parseInt("v20.0.0".split('.')[0].slice(1), 10)

  defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary'
} else {
  defaultEncoding = 'utf-8'
}
module.exports = defaultEncoding


/***/ }),

/***/ 32446:
/***/ ((module) => {

var MAX_ALLOC = Math.pow(2, 30) - 1 // default in iojs

module.exports = function (iterations, keylen) {
  if (typeof iterations !== 'number') {
    throw new TypeError('Iterations not a number')
  }

  if (iterations < 0) {
    throw new TypeError('Bad iterations')
  }

  if (typeof keylen !== 'number') {
    throw new TypeError('Key length not a number')
  }

  if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) { /* eslint no-self-compare: 0 */
    throw new TypeError('Bad key length')
  }
}


/***/ }),

/***/ 26164:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var md5 = __webpack_require__(1610)
var RIPEMD160 = __webpack_require__(95009)
var sha = __webpack_require__(60913)
var Buffer = (__webpack_require__(80480).Buffer)

var checkParameters = __webpack_require__(32446)
var defaultEncoding = __webpack_require__(66594)
var toBuffer = __webpack_require__(87357)

var ZEROS = Buffer.alloc(128)
var sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
}

function Hmac (alg, key, saltLen) {
  var hash = getDigest(alg)
  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  if (key.length > blocksize) {
    key = hash(key)
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = Buffer.allocUnsafe(blocksize + sizes[alg])
  var opad = Buffer.allocUnsafe(blocksize + sizes[alg])
  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4)
  ipad.copy(ipad1, 0, 0, blocksize)
  this.ipad1 = ipad1
  this.ipad2 = ipad
  this.opad = opad
  this.alg = alg
  this.blocksize = blocksize
  this.hash = hash
  this.size = sizes[alg]
}

Hmac.prototype.run = function (data, ipad) {
  data.copy(ipad, this.blocksize)
  var h = this.hash(ipad)
  h.copy(this.opad, this.blocksize)
  return this.hash(this.opad)
}

function getDigest (alg) {
  function shaFunc (data) {
    return sha(alg).update(data).digest()
  }
  function rmd160Func (data) {
    return new RIPEMD160().update(data).digest()
  }

  if (alg === 'rmd160' || alg === 'ripemd160') return rmd160Func
  if (alg === 'md5') return md5
  return shaFunc
}

function pbkdf2 (password, salt, iterations, keylen, digest) {
  checkParameters(iterations, keylen)
  password = toBuffer(password, defaultEncoding, 'Password')
  salt = toBuffer(salt, defaultEncoding, 'Salt')

  digest = digest || 'sha1'

  var hmac = new Hmac(digest, password, salt.length)

  var DK = Buffer.allocUnsafe(keylen)
  var block1 = Buffer.allocUnsafe(salt.length + 4)
  salt.copy(block1, 0, 0, salt.length)

  var destPos = 0
  var hLen = sizes[digest]
  var l = Math.ceil(keylen / hLen)

  for (var i = 1; i <= l; i++) {
    block1.writeUInt32BE(i, salt.length)

    var T = hmac.run(block1, hmac.ipad1)
    var U = T

    for (var j = 1; j < iterations; j++) {
      U = hmac.run(U, hmac.ipad2)
      for (var k = 0; k < hLen; k++) T[k] ^= U[k]
    }

    T.copy(DK, destPos)
    destPos += hLen
  }

  return DK
}

module.exports = pbkdf2


/***/ }),

/***/ 87357:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Buffer = (__webpack_require__(80480).Buffer)

module.exports = function (thing, encoding, name) {
  if (Buffer.isBuffer(thing)) {
    return thing
  } else if (typeof thing === 'string') {
    return Buffer.from(thing, encoding)
  } else if (ArrayBuffer.isView(thing)) {
    return Buffer.from(thing.buffer)
  } else {
    throw new TypeError(name + ' must be a string, a Buffer, a typed array or a DataView')
  }
}


/***/ }),

/***/ 18942:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var __webpack_provided_process_dot_nextTick = __webpack_require__(52528);


if (typeof process === 'undefined' ||
    !"v20.0.0" ||
    "v20.0.0".indexOf('v0.') === 0 ||
     false && 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return __webpack_provided_process_dot_nextTick(fn);
  case 2:
    return __webpack_provided_process_dot_nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return __webpack_provided_process_dot_nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return __webpack_provided_process_dot_nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return __webpack_provided_process_dot_nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}



/***/ }),

/***/ 95796:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.publicEncrypt = __webpack_require__(61785)
exports.privateDecrypt = __webpack_require__(7177)

exports.privateEncrypt = function privateEncrypt (key, buf) {
  return exports.publicEncrypt(key, buf, true)
}

exports.publicDecrypt = function publicDecrypt (key, buf) {
  return exports.privateDecrypt(key, buf, true)
}


/***/ }),

/***/ 95474:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createHash = __webpack_require__(68066)
var Buffer = (__webpack_require__(80480).Buffer)

module.exports = function (seed, len) {
  var t = Buffer.alloc(0)
  var i = 0
  var c
  while (t.length < len) {
    c = i2ops(i++)
    t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()])
  }
  return t.slice(0, len)
}

function i2ops (c) {
  var out = Buffer.allocUnsafe(4)
  out.writeUInt32BE(c, 0)
  return out
}


/***/ }),

/***/ 7177:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var parseKeys = __webpack_require__(62992)
var mgf = __webpack_require__(95474)
var xor = __webpack_require__(82872)
var BN = __webpack_require__(73117)
var crt = __webpack_require__(20208)
var createHash = __webpack_require__(68066)
var withPublic = __webpack_require__(40960)
var Buffer = (__webpack_require__(80480).Buffer)

module.exports = function privateDecrypt (privateKey, enc, reverse) {
  var padding
  if (privateKey.padding) {
    padding = privateKey.padding
  } else if (reverse) {
    padding = 1
  } else {
    padding = 4
  }

  var key = parseKeys(privateKey)
  var k = key.modulus.byteLength()
  if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {
    throw new Error('decryption error')
  }
  var msg
  if (reverse) {
    msg = withPublic(new BN(enc), key)
  } else {
    msg = crt(enc, key)
  }
  var zBuffer = Buffer.alloc(k - msg.length)
  msg = Buffer.concat([zBuffer, msg], k)
  if (padding === 4) {
    return oaep(key, msg)
  } else if (padding === 1) {
    return pkcs1(key, msg, reverse)
  } else if (padding === 3) {
    return msg
  } else {
    throw new Error('unknown padding')
  }
}

function oaep (key, msg) {
  var k = key.modulus.byteLength()
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()
  var hLen = iHash.length
  if (msg[0] !== 0) {
    throw new Error('decryption error')
  }
  var maskedSeed = msg.slice(1, hLen + 1)
  var maskedDb = msg.slice(hLen + 1)
  var seed = xor(maskedSeed, mgf(maskedDb, hLen))
  var db = xor(maskedDb, mgf(seed, k - hLen - 1))
  if (compare(iHash, db.slice(0, hLen))) {
    throw new Error('decryption error')
  }
  var i = hLen
  while (db[i] === 0) {
    i++
  }
  if (db[i++] !== 1) {
    throw new Error('decryption error')
  }
  return db.slice(i)
}

function pkcs1 (key, msg, reverse) {
  var p1 = msg.slice(0, 2)
  var i = 2
  var status = 0
  while (msg[i++] !== 0) {
    if (i >= msg.length) {
      status++
      break
    }
  }
  var ps = msg.slice(2, i - 1)

  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)) {
    status++
  }
  if (ps.length < 8) {
    status++
  }
  if (status) {
    throw new Error('decryption error')
  }
  return msg.slice(i)
}
function compare (a, b) {
  a = Buffer.from(a)
  b = Buffer.from(b)
  var dif = 0
  var len = a.length
  if (a.length !== b.length) {
    dif++
    len = Math.min(a.length, b.length)
  }
  var i = -1
  while (++i < len) {
    dif += (a[i] ^ b[i])
  }
  return dif
}


/***/ }),

/***/ 61785:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var parseKeys = __webpack_require__(62992)
var randomBytes = __webpack_require__(44613)
var createHash = __webpack_require__(68066)
var mgf = __webpack_require__(95474)
var xor = __webpack_require__(82872)
var BN = __webpack_require__(73117)
var withPublic = __webpack_require__(40960)
var crt = __webpack_require__(20208)
var Buffer = (__webpack_require__(80480).Buffer)

module.exports = function publicEncrypt (publicKey, msg, reverse) {
  var padding
  if (publicKey.padding) {
    padding = publicKey.padding
  } else if (reverse) {
    padding = 1
  } else {
    padding = 4
  }
  var key = parseKeys(publicKey)
  var paddedMsg
  if (padding === 4) {
    paddedMsg = oaep(key, msg)
  } else if (padding === 1) {
    paddedMsg = pkcs1(key, msg, reverse)
  } else if (padding === 3) {
    paddedMsg = new BN(msg)
    if (paddedMsg.cmp(key.modulus) >= 0) {
      throw new Error('data too long for modulus')
    }
  } else {
    throw new Error('unknown padding')
  }
  if (reverse) {
    return crt(paddedMsg, key)
  } else {
    return withPublic(paddedMsg, key)
  }
}

function oaep (key, msg) {
  var k = key.modulus.byteLength()
  var mLen = msg.length
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()
  var hLen = iHash.length
  var hLen2 = 2 * hLen
  if (mLen > k - hLen2 - 2) {
    throw new Error('message too long')
  }
  var ps = Buffer.alloc(k - mLen - hLen2 - 2)
  var dblen = k - hLen - 1
  var seed = randomBytes(hLen)
  var maskedDb = xor(Buffer.concat([iHash, ps, Buffer.alloc(1, 1), msg], dblen), mgf(seed, dblen))
  var maskedSeed = xor(seed, mgf(maskedDb, hLen))
  return new BN(Buffer.concat([Buffer.alloc(1), maskedSeed, maskedDb], k))
}
function pkcs1 (key, msg, reverse) {
  var mLen = msg.length
  var k = key.modulus.byteLength()
  if (mLen > k - 11) {
    throw new Error('message too long')
  }
  var ps
  if (reverse) {
    ps = Buffer.alloc(k - mLen - 3, 0xff)
  } else {
    ps = nonZero(k - mLen - 3)
  }
  return new BN(Buffer.concat([Buffer.from([0, reverse ? 1 : 2]), ps, Buffer.alloc(1), msg], k))
}
function nonZero (len) {
  var out = Buffer.allocUnsafe(len)
  var i = 0
  var cache = randomBytes(len * 2)
  var cur = 0
  var num
  while (i < len) {
    if (cur === cache.length) {
      cache = randomBytes(len * 2)
      cur = 0
    }
    num = cache[cur++]
    if (num) {
      out[i++] = num
    }
  }
  return out
}


/***/ }),

/***/ 40960:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var BN = __webpack_require__(73117)
var Buffer = (__webpack_require__(80480).Buffer)

function withPublic (paddedMsg, key) {
  return Buffer.from(paddedMsg
    .toRed(BN.mont(key.modulus))
    .redPow(new BN(key.publicExponent))
    .fromRed()
    .toArray())
}

module.exports = withPublic


/***/ }),

/***/ 82872:
/***/ ((module) => {

module.exports = function xor (a, b) {
  var len = a.length
  var i = -1
  while (++i < len) {
    a[i] ^= b[i]
  }
  return a
}


/***/ }),

/***/ 69067:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var once = __webpack_require__(71578)
var eos = __webpack_require__(93978)
var fs = __webpack_require__(16347) // we only need fs to get the ReadStream and WriteStream prototypes

var noop = function () {}
var ancient = /^v?\.0/.test("v20.0.0")

var isFn = function (fn) {
  return typeof fn === 'function'
}

var isFS = function (stream) {
  if (!ancient) return false // newer node version do not need to care about fs is a special way
  if (!fs) return false // browser
  return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close)
}

var isRequest = function (stream) {
  return stream.setHeader && isFn(stream.abort)
}

var destroyer = function (stream, reading, writing, callback) {
  callback = once(callback)

  var closed = false
  stream.on('close', function () {
    closed = true
  })

  eos(stream, {readable: reading, writable: writing}, function (err) {
    if (err) return callback(err)
    closed = true
    callback()
  })

  var destroyed = false
  return function (err) {
    if (closed) return
    if (destroyed) return
    destroyed = true

    if (isFS(stream)) return stream.close(noop) // use close for fs streams to avoid fd leaks
    if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want

    if (isFn(stream.destroy)) return stream.destroy()

    callback(err || new Error('stream was destroyed'))
  }
}

var call = function (fn) {
  fn()
}

var pipe = function (from, to) {
  return from.pipe(to)
}

var pump = function () {
  var streams = Array.prototype.slice.call(arguments)
  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop

  if (Array.isArray(streams[0])) streams = streams[0]
  if (streams.length < 2) throw new Error('pump requires two streams per minimum')

  var error
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1
    var writing = i > 0
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err
      if (err) destroys.forEach(call)
      if (reading) return
      destroys.forEach(call)
      callback(error)
    })
  })

  return streams.reduce(pipe)
}

module.exports = pump


/***/ }),

/***/ 85907:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;
/* provided dependency */ var Buffer = __webpack_require__(7661)["Buffer"];
/*!
 * MIT License
 * 
 * Copyright (c) 2017-2022 Peculiar Ventures, LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 */



const ARRAY_BUFFER_NAME = "[object ArrayBuffer]";
class BufferSourceConverter {
    static isArrayBuffer(data) {
        return Object.prototype.toString.call(data) === ARRAY_BUFFER_NAME;
    }
    static toArrayBuffer(data) {
        if (this.isArrayBuffer(data)) {
            return data;
        }
        if (data.byteLength === data.buffer.byteLength) {
            return data.buffer;
        }
        if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
            return data.buffer;
        }
        return this.toUint8Array(data.buffer)
            .slice(data.byteOffset, data.byteOffset + data.byteLength)
            .buffer;
    }
    static toUint8Array(data) {
        return this.toView(data, Uint8Array);
    }
    static toView(data, type) {
        if (data.constructor === type) {
            return data;
        }
        if (this.isArrayBuffer(data)) {
            return new type(data);
        }
        if (this.isArrayBufferView(data)) {
            return new type(data.buffer, data.byteOffset, data.byteLength);
        }
        throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'");
    }
    static isBufferSource(data) {
        return this.isArrayBufferView(data)
            || this.isArrayBuffer(data);
    }
    static isArrayBufferView(data) {
        return ArrayBuffer.isView(data)
            || (data && this.isArrayBuffer(data.buffer));
    }
    static isEqual(a, b) {
        const aView = BufferSourceConverter.toUint8Array(a);
        const bView = BufferSourceConverter.toUint8Array(b);
        if (aView.length !== bView.byteLength) {
            return false;
        }
        for (let i = 0; i < aView.length; i++) {
            if (aView[i] !== bView[i]) {
                return false;
            }
        }
        return true;
    }
    static concat(...args) {
        let buffers;
        if (Array.isArray(args[0]) && !(args[1] instanceof Function)) {
            buffers = args[0];
        }
        else if (Array.isArray(args[0]) && args[1] instanceof Function) {
            buffers = args[0];
        }
        else {
            if (args[args.length - 1] instanceof Function) {
                buffers = args.slice(0, args.length - 1);
            }
            else {
                buffers = args;
            }
        }
        let size = 0;
        for (const buffer of buffers) {
            size += buffer.byteLength;
        }
        const res = new Uint8Array(size);
        let offset = 0;
        for (const buffer of buffers) {
            const view = this.toUint8Array(buffer);
            res.set(view, offset);
            offset += view.length;
        }
        if (args[args.length - 1] instanceof Function) {
            return this.toView(res, args[args.length - 1]);
        }
        return res.buffer;
    }
}

const STRING_TYPE = "string";
const HEX_REGEX = /^[0-9a-f]+$/i;
const BASE64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
const BASE64URL_REGEX = /^[a-zA-Z0-9-_]+$/;
class Utf8Converter {
    static fromString(text) {
        const s = unescape(encodeURIComponent(text));
        const uintArray = new Uint8Array(s.length);
        for (let i = 0; i < s.length; i++) {
            uintArray[i] = s.charCodeAt(i);
        }
        return uintArray.buffer;
    }
    static toString(buffer) {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        let encodedString = "";
        for (let i = 0; i < buf.length; i++) {
            encodedString += String.fromCharCode(buf[i]);
        }
        const decodedString = decodeURIComponent(escape(encodedString));
        return decodedString;
    }
}
class Utf16Converter {
    static toString(buffer, littleEndian = false) {
        const arrayBuffer = BufferSourceConverter.toArrayBuffer(buffer);
        const dataView = new DataView(arrayBuffer);
        let res = "";
        for (let i = 0; i < arrayBuffer.byteLength; i += 2) {
            const code = dataView.getUint16(i, littleEndian);
            res += String.fromCharCode(code);
        }
        return res;
    }
    static fromString(text, littleEndian = false) {
        const res = new ArrayBuffer(text.length * 2);
        const dataView = new DataView(res);
        for (let i = 0; i < text.length; i++) {
            dataView.setUint16(i * 2, text.charCodeAt(i), littleEndian);
        }
        return res;
    }
}
class Convert {
    static isHex(data) {
        return typeof data === STRING_TYPE
            && HEX_REGEX.test(data);
    }
    static isBase64(data) {
        return typeof data === STRING_TYPE
            && BASE64_REGEX.test(data);
    }
    static isBase64Url(data) {
        return typeof data === STRING_TYPE
            && BASE64URL_REGEX.test(data);
    }
    static ToString(buffer, enc = "utf8") {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        switch (enc.toLowerCase()) {
            case "utf8":
                return this.ToUtf8String(buf);
            case "binary":
                return this.ToBinary(buf);
            case "hex":
                return this.ToHex(buf);
            case "base64":
                return this.ToBase64(buf);
            case "base64url":
                return this.ToBase64Url(buf);
            case "utf16le":
                return Utf16Converter.toString(buf, true);
            case "utf16":
            case "utf16be":
                return Utf16Converter.toString(buf);
            default:
                throw new Error(`Unknown type of encoding '${enc}'`);
        }
    }
    static FromString(str, enc = "utf8") {
        if (!str) {
            return new ArrayBuffer(0);
        }
        switch (enc.toLowerCase()) {
            case "utf8":
                return this.FromUtf8String(str);
            case "binary":
                return this.FromBinary(str);
            case "hex":
                return this.FromHex(str);
            case "base64":
                return this.FromBase64(str);
            case "base64url":
                return this.FromBase64Url(str);
            case "utf16le":
                return Utf16Converter.fromString(str, true);
            case "utf16":
            case "utf16be":
                return Utf16Converter.fromString(str);
            default:
                throw new Error(`Unknown type of encoding '${enc}'`);
        }
    }
    static ToBase64(buffer) {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        if (typeof btoa !== "undefined") {
            const binary = this.ToString(buf, "binary");
            return btoa(binary);
        }
        else {
            return Buffer.from(buf).toString("base64");
        }
    }
    static FromBase64(base64) {
        const formatted = this.formatString(base64);
        if (!formatted) {
            return new ArrayBuffer(0);
        }
        if (!Convert.isBase64(formatted)) {
            throw new TypeError("Argument 'base64Text' is not Base64 encoded");
        }
        if (typeof atob !== "undefined") {
            return this.FromBinary(atob(formatted));
        }
        else {
            return new Uint8Array(Buffer.from(formatted, "base64")).buffer;
        }
    }
    static FromBase64Url(base64url) {
        const formatted = this.formatString(base64url);
        if (!formatted) {
            return new ArrayBuffer(0);
        }
        if (!Convert.isBase64Url(formatted)) {
            throw new TypeError("Argument 'base64url' is not Base64Url encoded");
        }
        return this.FromBase64(this.Base64Padding(formatted.replace(/\-/g, "+").replace(/\_/g, "/")));
    }
    static ToBase64Url(data) {
        return this.ToBase64(data).replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
    }
    static FromUtf8String(text, encoding = Convert.DEFAULT_UTF8_ENCODING) {
        switch (encoding) {
            case "ascii":
                return this.FromBinary(text);
            case "utf8":
                return Utf8Converter.fromString(text);
            case "utf16":
            case "utf16be":
                return Utf16Converter.fromString(text);
            case "utf16le":
            case "usc2":
                return Utf16Converter.fromString(text, true);
            default:
                throw new Error(`Unknown type of encoding '${encoding}'`);
        }
    }
    static ToUtf8String(buffer, encoding = Convert.DEFAULT_UTF8_ENCODING) {
        switch (encoding) {
            case "ascii":
                return this.ToBinary(buffer);
            case "utf8":
                return Utf8Converter.toString(buffer);
            case "utf16":
            case "utf16be":
                return Utf16Converter.toString(buffer);
            case "utf16le":
            case "usc2":
                return Utf16Converter.toString(buffer, true);
            default:
                throw new Error(`Unknown type of encoding '${encoding}'`);
        }
    }
    static FromBinary(text) {
        const stringLength = text.length;
        const resultView = new Uint8Array(stringLength);
        for (let i = 0; i < stringLength; i++) {
            resultView[i] = text.charCodeAt(i);
        }
        return resultView.buffer;
    }
    static ToBinary(buffer) {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        let res = "";
        for (let i = 0; i < buf.length; i++) {
            res += String.fromCharCode(buf[i]);
        }
        return res;
    }
    static ToHex(buffer) {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        let result = "";
        const len = buf.length;
        for (let i = 0; i < len; i++) {
            const byte = buf[i];
            if (byte < 16) {
                result += "0";
            }
            result += byte.toString(16);
        }
        return result;
    }
    static FromHex(hexString) {
        let formatted = this.formatString(hexString);
        if (!formatted) {
            return new ArrayBuffer(0);
        }
        if (!Convert.isHex(formatted)) {
            throw new TypeError("Argument 'hexString' is not HEX encoded");
        }
        if (formatted.length % 2) {
            formatted = `0${formatted}`;
        }
        const res = new Uint8Array(formatted.length / 2);
        for (let i = 0; i < formatted.length; i = i + 2) {
            const c = formatted.slice(i, i + 2);
            res[i / 2] = parseInt(c, 16);
        }
        return res.buffer;
    }
    static ToUtf16String(buffer, littleEndian = false) {
        return Utf16Converter.toString(buffer, littleEndian);
    }
    static FromUtf16String(text, littleEndian = false) {
        return Utf16Converter.fromString(text, littleEndian);
    }
    static Base64Padding(base64) {
        const padCount = 4 - (base64.length % 4);
        if (padCount < 4) {
            for (let i = 0; i < padCount; i++) {
                base64 += "=";
            }
        }
        return base64;
    }
    static formatString(data) {
        return (data === null || data === void 0 ? void 0 : data.replace(/[\n\r\t ]/g, "")) || "";
    }
}
Convert.DEFAULT_UTF8_ENCODING = "utf8";

function assign(target, ...sources) {
    const res = arguments[0];
    for (let i = 1; i < arguments.length; i++) {
        const obj = arguments[i];
        for (const prop in obj) {
            res[prop] = obj[prop];
        }
    }
    return res;
}
function combine(...buf) {
    const totalByteLength = buf.map((item) => item.byteLength).reduce((prev, cur) => prev + cur);
    const res = new Uint8Array(totalByteLength);
    let currentPos = 0;
    buf.map((item) => new Uint8Array(item)).forEach((arr) => {
        for (const item2 of arr) {
            res[currentPos++] = item2;
        }
    });
    return res.buffer;
}
function isEqual(bytes1, bytes2) {
    if (!(bytes1 && bytes2)) {
        return false;
    }
    if (bytes1.byteLength !== bytes2.byteLength) {
        return false;
    }
    const b1 = new Uint8Array(bytes1);
    const b2 = new Uint8Array(bytes2);
    for (let i = 0; i < bytes1.byteLength; i++) {
        if (b1[i] !== b2[i]) {
            return false;
        }
    }
    return true;
}

__webpack_unused_export__ = BufferSourceConverter;
exports.ep = Convert;
__webpack_unused_export__ = assign;
__webpack_unused_export__ = combine;
__webpack_unused_export__ = isEqual;


/***/ }),

/***/ 66120:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

const strictUriEncode = __webpack_require__(43572);
const decodeComponent = __webpack_require__(43976);
const splitOnFirst = __webpack_require__(34067);
const filterObject = __webpack_require__(5786);

const isNullOrUndefined = value => value === null || value === undefined;

const encodeFragmentIdentifier = Symbol('encodeFragmentIdentifier');

function encoderForArrayFormat(options) {
	switch (options.arrayFormat) {
		case 'index':
			return key => (result, value) => {
				const index = result.length;

				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return [...result, [encode(key, options), '[', index, ']'].join('')];
				}

				return [
					...result,
					[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')
				];
			};

		case 'bracket':
			return key => (result, value) => {
				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return [...result, [encode(key, options), '[]'].join('')];
				}

				return [...result, [encode(key, options), '[]=', encode(value, options)].join('')];
			};

		case 'colon-list-separator':
			return key => (result, value) => {
				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return [...result, [encode(key, options), ':list='].join('')];
				}

				return [...result, [encode(key, options), ':list=', encode(value, options)].join('')];
			};

		case 'comma':
		case 'separator':
		case 'bracket-separator': {
			const keyValueSep = options.arrayFormat === 'bracket-separator' ?
				'[]=' :
				'=';

			return key => (result, value) => {
				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				// Translate null to an empty string so that it doesn't serialize as 'null'
				value = value === null ? '' : value;

				if (result.length === 0) {
					return [[encode(key, options), keyValueSep, encode(value, options)].join('')];
				}

				return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
			};
		}

		default:
			return key => (result, value) => {
				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return [...result, encode(key, options)];
				}

				return [...result, [encode(key, options), '=', encode(value, options)].join('')];
			};
	}
}

function parserForArrayFormat(options) {
	let result;

	switch (options.arrayFormat) {
		case 'index':
			return (key, value, accumulator) => {
				result = /\[(\d*)\]$/.exec(key);

				key = key.replace(/\[\d*\]$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				}

				if (accumulator[key] === undefined) {
					accumulator[key] = {};
				}

				accumulator[key][result[1]] = value;
			};

		case 'bracket':
			return (key, value, accumulator) => {
				result = /(\[\])$/.exec(key);
				key = key.replace(/\[\]$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				}

				if (accumulator[key] === undefined) {
					accumulator[key] = [value];
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};

		case 'colon-list-separator':
			return (key, value, accumulator) => {
				result = /(:list)$/.exec(key);
				key = key.replace(/:list$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				}

				if (accumulator[key] === undefined) {
					accumulator[key] = [value];
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};

		case 'comma':
		case 'separator':
			return (key, value, accumulator) => {
				const isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);
				const isEncodedArray = (typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator));
				value = isEncodedArray ? decode(value, options) : value;
				const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map(item => decode(item, options)) : value === null ? value : decode(value, options);
				accumulator[key] = newValue;
			};

		case 'bracket-separator':
			return (key, value, accumulator) => {
				const isArray = /(\[\])$/.test(key);
				key = key.replace(/\[\]$/, '');

				if (!isArray) {
					accumulator[key] = value ? decode(value, options) : value;
					return;
				}

				const arrayValue = value === null ?
					[] :
					value.split(options.arrayFormatSeparator).map(item => decode(item, options));

				if (accumulator[key] === undefined) {
					accumulator[key] = arrayValue;
					return;
				}

				accumulator[key] = [].concat(accumulator[key], arrayValue);
			};

		default:
			return (key, value, accumulator) => {
				if (accumulator[key] === undefined) {
					accumulator[key] = value;
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};
	}
}

function validateArrayFormatSeparator(value) {
	if (typeof value !== 'string' || value.length !== 1) {
		throw new TypeError('arrayFormatSeparator must be single character string');
	}
}

function encode(value, options) {
	if (options.encode) {
		return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
	}

	return value;
}

function decode(value, options) {
	if (options.decode) {
		return decodeComponent(value);
	}

	return value;
}

function keysSorter(input) {
	if (Array.isArray(input)) {
		return input.sort();
	}

	if (typeof input === 'object') {
		return keysSorter(Object.keys(input))
			.sort((a, b) => Number(a) - Number(b))
			.map(key => input[key]);
	}

	return input;
}

function removeHash(input) {
	const hashStart = input.indexOf('#');
	if (hashStart !== -1) {
		input = input.slice(0, hashStart);
	}

	return input;
}

function getHash(url) {
	let hash = '';
	const hashStart = url.indexOf('#');
	if (hashStart !== -1) {
		hash = url.slice(hashStart);
	}

	return hash;
}

function extract(input) {
	input = removeHash(input);
	const queryStart = input.indexOf('?');
	if (queryStart === -1) {
		return '';
	}

	return input.slice(queryStart + 1);
}

function parseValue(value, options) {
	if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === 'string' && value.trim() !== '')) {
		value = Number(value);
	} else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
		value = value.toLowerCase() === 'true';
	}

	return value;
}

function parse(query, options) {
	options = Object.assign({
		decode: true,
		sort: true,
		arrayFormat: 'none',
		arrayFormatSeparator: ',',
		parseNumbers: false,
		parseBooleans: false
	}, options);

	validateArrayFormatSeparator(options.arrayFormatSeparator);

	const formatter = parserForArrayFormat(options);

	// Create an object with no prototype
	const ret = Object.create(null);

	if (typeof query !== 'string') {
		return ret;
	}

	query = query.trim().replace(/^[?#&]/, '');

	if (!query) {
		return ret;
	}

	for (const param of query.split('&')) {
		if (param === '') {
			continue;
		}

		let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, ' ') : param, '=');

		// Missing `=` should be `null`:
		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
		value = value === undefined ? null : ['comma', 'separator', 'bracket-separator'].includes(options.arrayFormat) ? value : decode(value, options);
		formatter(decode(key, options), value, ret);
	}

	for (const key of Object.keys(ret)) {
		const value = ret[key];
		if (typeof value === 'object' && value !== null) {
			for (const k of Object.keys(value)) {
				value[k] = parseValue(value[k], options);
			}
		} else {
			ret[key] = parseValue(value, options);
		}
	}

	if (options.sort === false) {
		return ret;
	}

	return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
		const value = ret[key];
		if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {
			// Sort object keys, not values
			result[key] = keysSorter(value);
		} else {
			result[key] = value;
		}

		return result;
	}, Object.create(null));
}

exports.extract = extract;
exports.parse = parse;

exports.stringify = (object, options) => {
	if (!object) {
		return '';
	}

	options = Object.assign({
		encode: true,
		strict: true,
		arrayFormat: 'none',
		arrayFormatSeparator: ','
	}, options);

	validateArrayFormatSeparator(options.arrayFormatSeparator);

	const shouldFilter = key => (
		(options.skipNull && isNullOrUndefined(object[key])) ||
		(options.skipEmptyString && object[key] === '')
	);

	const formatter = encoderForArrayFormat(options);

	const objectCopy = {};

	for (const key of Object.keys(object)) {
		if (!shouldFilter(key)) {
			objectCopy[key] = object[key];
		}
	}

	const keys = Object.keys(objectCopy);

	if (options.sort !== false) {
		keys.sort(options.sort);
	}

	return keys.map(key => {
		const value = object[key];

		if (value === undefined) {
			return '';
		}

		if (value === null) {
			return encode(key, options);
		}

		if (Array.isArray(value)) {
			if (value.length === 0 && options.arrayFormat === 'bracket-separator') {
				return encode(key, options) + '[]';
			}

			return value
				.reduce(formatter(key), [])
				.join('&');
		}

		return encode(key, options) + '=' + encode(value, options);
	}).filter(x => x.length > 0).join('&');
};

exports.parseUrl = (url, options) => {
	options = Object.assign({
		decode: true
	}, options);

	const [url_, hash] = splitOnFirst(url, '#');

	return Object.assign(
		{
			url: url_.split('?')[0] || '',
			query: parse(extract(url), options)
		},
		options && options.parseFragmentIdentifier && hash ? {fragmentIdentifier: decode(hash, options)} : {}
	);
};

exports.stringifyUrl = (object, options) => {
	options = Object.assign({
		encode: true,
		strict: true,
		[encodeFragmentIdentifier]: true
	}, options);

	const url = removeHash(object.url).split('?')[0] || '';
	const queryFromUrl = exports.extract(object.url);
	const parsedQueryFromUrl = exports.parse(queryFromUrl, {sort: false});

	const query = Object.assign(parsedQueryFromUrl, object.query);
	let queryString = exports.stringify(query, options);
	if (queryString) {
		queryString = `?${queryString}`;
	}

	let hash = getHash(object.url);
	if (object.fragmentIdentifier) {
		hash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
	}

	return `${url}${queryString}${hash}`;
};

exports.pick = (input, filter, options) => {
	options = Object.assign({
		parseFragmentIdentifier: true,
		[encodeFragmentIdentifier]: false
	}, options);

	const {url, query, fragmentIdentifier} = exports.parseUrl(input, options);
	return exports.stringifyUrl({
		url,
		query: filterObject(query, filter),
		fragmentIdentifier
	}, options);
};

exports.exclude = (input, filter, options) => {
	const exclusionFilter = Array.isArray(filter) ? key => !filter.includes(key) : (key, value) => !filter(key, value);

	return exports.pick(input, exclusionFilter, options);
};


/***/ }),

/***/ 79660:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
let promise

module.exports = typeof queueMicrotask === 'function'
  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : __webpack_require__.g)
  // reuse resolved promise, and allocate it lazily
  : cb => (promise || (promise = Promise.resolve()))
    .then(cb)
    .catch(err => setTimeout(() => { throw err }, 0))


/***/ }),

/***/ 15955:
/***/ ((module) => {

"use strict";

function tryStringify (o) {
  try { return JSON.stringify(o) } catch(e) { return '"[Circular]"' }
}

module.exports = format

function format(f, args, opts) {
  var ss = (opts && opts.stringify) || tryStringify
  var offset = 1
  if (typeof f === 'object' && f !== null) {
    var len = args.length + offset
    if (len === 1) return f
    var objects = new Array(len)
    objects[0] = ss(f)
    for (var index = 1; index < len; index++) {
      objects[index] = ss(args[index])
    }
    return objects.join(' ')
  }
  if (typeof f !== 'string') {
    return f
  }
  var argLen = args.length
  if (argLen === 0) return f
  var str = ''
  var a = 1 - offset
  var lastPos = -1
  var flen = (f && f.length) || 0
  for (var i = 0; i < flen;) {
    if (f.charCodeAt(i) === 37 && i + 1 < flen) {
      lastPos = lastPos > -1 ? lastPos : 0
      switch (f.charCodeAt(i + 1)) {
        case 100: // 'd'
        case 102: // 'f'
          if (a >= argLen)
            break
          if (args[a] == null)  break
          if (lastPos < i)
            str += f.slice(lastPos, i)
          str += Number(args[a])
          lastPos = i + 2
          i++
          break
        case 105: // 'i'
          if (a >= argLen)
            break
          if (args[a] == null)  break
          if (lastPos < i)
            str += f.slice(lastPos, i)
          str += Math.floor(Number(args[a]))
          lastPos = i + 2
          i++
          break
        case 79: // 'O'
        case 111: // 'o'
        case 106: // 'j'
          if (a >= argLen)
            break
          if (args[a] === undefined) break
          if (lastPos < i)
            str += f.slice(lastPos, i)
          var type = typeof args[a]
          if (type === 'string') {
            str += '\'' + args[a] + '\''
            lastPos = i + 2
            i++
            break
          }
          if (type === 'function') {
            str += args[a].name || '<anonymous>'
            lastPos = i + 2
            i++
            break
          }
          str += ss(args[a])
          lastPos = i + 2
          i++
          break
        case 115: // 's'
          if (a >= argLen)
            break
          if (lastPos < i)
            str += f.slice(lastPos, i)
          str += String(args[a])
          lastPos = i + 2
          i++
          break
        case 37: // '%'
          if (lastPos < i)
            str += f.slice(lastPos, i)
          str += '%'
          lastPos = i + 2
          i++
          a--
          break
      }
      ++a
    }
    ++i
  }
  if (lastPos === -1)
    return f
  else if (lastPos < flen) {
    str += f.slice(lastPos)
  }

  return str
}


/***/ }),

/***/ 44613:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var __webpack_provided_process_dot_nextTick = __webpack_require__(52528);


// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var MAX_BYTES = 65536

// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var MAX_UINT32 = 4294967295

function oldBrowser () {
  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
}

var Buffer = (__webpack_require__(80480).Buffer)
var crypto = __webpack_require__.g.crypto || __webpack_require__.g.msCrypto

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes
} else {
  module.exports = oldBrowser
}

function randomBytes (size, cb) {
  // phantomjs needs to throw
  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')

  var bytes = Buffer.allocUnsafe(size)

  if (size > 0) {  // getRandomValues fails on IE if size == 0
    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues
      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
      for (var generated = 0; generated < size; generated += MAX_BYTES) {
        // buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))
      }
    } else {
      crypto.getRandomValues(bytes)
    }
  }

  if (typeof cb === 'function') {
    return __webpack_provided_process_dot_nextTick(function () {
      cb(null, bytes)
    })
  }

  return bytes
}


/***/ }),

/***/ 32693:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var __webpack_provided_process_dot_nextTick = __webpack_require__(52528);


function oldBrowser () {
  throw new Error('secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11')
}
var safeBuffer = __webpack_require__(80480)
var randombytes = __webpack_require__(44613)
var Buffer = safeBuffer.Buffer
var kBufferMaxLength = safeBuffer.kMaxLength
var crypto = __webpack_require__.g.crypto || __webpack_require__.g.msCrypto
var kMaxUint32 = Math.pow(2, 32) - 1
function assertOffset (offset, length) {
  if (typeof offset !== 'number' || offset !== offset) { // eslint-disable-line no-self-compare
    throw new TypeError('offset must be a number')
  }

  if (offset > kMaxUint32 || offset < 0) {
    throw new TypeError('offset must be a uint32')
  }

  if (offset > kBufferMaxLength || offset > length) {
    throw new RangeError('offset out of range')
  }
}

function assertSize (size, offset, length) {
  if (typeof size !== 'number' || size !== size) { // eslint-disable-line no-self-compare
    throw new TypeError('size must be a number')
  }

  if (size > kMaxUint32 || size < 0) {
    throw new TypeError('size must be a uint32')
  }

  if (size + offset > length || size > kBufferMaxLength) {
    throw new RangeError('buffer too small')
  }
}
if ((crypto && crypto.getRandomValues) || !true) {
  exports.randomFill = randomFill
  exports.randomFillSync = randomFillSync
} else {
  exports.randomFill = oldBrowser
  exports.randomFillSync = oldBrowser
}
function randomFill (buf, offset, size, cb) {
  if (!Buffer.isBuffer(buf) && !(buf instanceof __webpack_require__.g.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
  }

  if (typeof offset === 'function') {
    cb = offset
    offset = 0
    size = buf.length
  } else if (typeof size === 'function') {
    cb = size
    size = buf.length - offset
  } else if (typeof cb !== 'function') {
    throw new TypeError('"cb" argument must be a function')
  }
  assertOffset(offset, buf.length)
  assertSize(size, offset, buf.length)
  return actualFill(buf, offset, size, cb)
}

function actualFill (buf, offset, size, cb) {
  if (true) {
    var ourBuf = buf.buffer
    var uint = new Uint8Array(ourBuf, offset, size)
    crypto.getRandomValues(uint)
    if (cb) {
      __webpack_provided_process_dot_nextTick(function () {
        cb(null, buf)
      })
      return
    }
    return buf
  }
  if (cb) {
    randombytes(size, function (err, bytes) {
      if (err) {
        return cb(err)
      }
      bytes.copy(buf, offset)
      cb(null, buf)
    })
    return
  }
  var bytes = randombytes(size)
  bytes.copy(buf, offset)
  return buf
}
function randomFillSync (buf, offset, size) {
  if (typeof offset === 'undefined') {
    offset = 0
  }
  if (!Buffer.isBuffer(buf) && !(buf instanceof __webpack_require__.g.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
  }

  assertOffset(offset, buf.length)

  if (size === undefined) size = buf.length - offset

  assertSize(size, offset, buf.length)

  return actualFill(buf, offset, size)
}


/***/ }),

/***/ 95009:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Buffer = (__webpack_require__(7661).Buffer)
var inherits = __webpack_require__(86778)
var HashBase = __webpack_require__(39185)

var ARRAY16 = new Array(16)

var zl = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
]

var zr = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
]

var sl = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
]

var sr = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
]

var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]
var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]

function RIPEMD160 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0
}

inherits(RIPEMD160, HashBase)

RIPEMD160.prototype._update = function () {
  var words = ARRAY16
  for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4)

  var al = this._a | 0
  var bl = this._b | 0
  var cl = this._c | 0
  var dl = this._d | 0
  var el = this._e | 0

  var ar = this._a | 0
  var br = this._b | 0
  var cr = this._c | 0
  var dr = this._d | 0
  var er = this._e | 0

  // computation
  for (var i = 0; i < 80; i += 1) {
    var tl
    var tr
    if (i < 16) {
      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i])
      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i])
    } else if (i < 32) {
      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i])
      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i])
    } else if (i < 48) {
      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i])
      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i])
    } else if (i < 64) {
      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i])
      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i])
    } else { // if (i<80) {
      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i])
      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i])
    }

    al = el
    el = dl
    dl = rotl(cl, 10)
    cl = bl
    bl = tl

    ar = er
    er = dr
    dr = rotl(cr, 10)
    cr = br
    br = tr
  }

  // update state
  var t = (this._b + cl + dr) | 0
  this._b = (this._c + dl + er) | 0
  this._c = (this._d + el + ar) | 0
  this._d = (this._e + al + br) | 0
  this._e = (this._a + bl + cr) | 0
  this._a = t
}

RIPEMD160.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  buffer.writeInt32LE(this._e, 16)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fn1 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0
}

function fn2 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0
}

function fn3 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0
}

function fn4 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0
}

function fn5 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0
}

module.exports = RIPEMD160


/***/ }),

/***/ 99347:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(7661)["Buffer"];

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLength = exports.decode = exports.encode = void 0;
var bn_js_1 = __importDefault(__webpack_require__(73182));
/**
 * RLP Encoding based on: https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP
 * This function takes in a data, convert it to buffer if not, and a length for recursion
 * @param input - will be converted to buffer
 * @returns returns buffer of encoded data
 **/
function encode(input) {
    if (Array.isArray(input)) {
        var output = [];
        for (var i = 0; i < input.length; i++) {
            output.push(encode(input[i]));
        }
        var buf = Buffer.concat(output);
        return Buffer.concat([encodeLength(buf.length, 192), buf]);
    }
    else {
        var inputBuf = toBuffer(input);
        return inputBuf.length === 1 && inputBuf[0] < 128
            ? inputBuf
            : Buffer.concat([encodeLength(inputBuf.length, 128), inputBuf]);
    }
}
exports.encode = encode;
/**
 * Parse integers. Check if there is no leading zeros
 * @param v The value to parse
 * @param base The base to parse the integer into
 */
function safeParseInt(v, base) {
    if (v[0] === '0' && v[1] === '0') {
        throw new Error('invalid RLP: extra zeros');
    }
    return parseInt(v, base);
}
function encodeLength(len, offset) {
    if (len < 56) {
        return Buffer.from([len + offset]);
    }
    else {
        var hexLength = intToHex(len);
        var lLength = hexLength.length / 2;
        var firstByte = intToHex(offset + 55 + lLength);
        return Buffer.from(firstByte + hexLength, 'hex');
    }
}
function decode(input, stream) {
    if (stream === void 0) { stream = false; }
    if (!input || input.length === 0) {
        return Buffer.from([]);
    }
    var inputBuffer = toBuffer(input);
    var decoded = _decode(inputBuffer);
    if (stream) {
        return decoded;
    }
    if (decoded.remainder.length !== 0) {
        throw new Error('invalid remainder');
    }
    return decoded.data;
}
exports.decode = decode;
/**
 * Get the length of the RLP input
 * @param input
 * @returns The length of the input or an empty Buffer if no input
 */
function getLength(input) {
    if (!input || input.length === 0) {
        return Buffer.from([]);
    }
    var inputBuffer = toBuffer(input);
    var firstByte = inputBuffer[0];
    if (firstByte <= 0x7f) {
        return inputBuffer.length;
    }
    else if (firstByte <= 0xb7) {
        return firstByte - 0x7f;
    }
    else if (firstByte <= 0xbf) {
        return firstByte - 0xb6;
    }
    else if (firstByte <= 0xf7) {
        // a list between  0-55 bytes long
        return firstByte - 0xbf;
    }
    else {
        // a list  over 55 bytes long
        var llength = firstByte - 0xf6;
        var length_1 = safeParseInt(inputBuffer.slice(1, llength).toString('hex'), 16);
        return llength + length_1;
    }
}
exports.getLength = getLength;
/** Decode an input with RLP */
function _decode(input) {
    var length, llength, data, innerRemainder, d;
    var decoded = [];
    var firstByte = input[0];
    if (firstByte <= 0x7f) {
        // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.
        return {
            data: input.slice(0, 1),
            remainder: input.slice(1),
        };
    }
    else if (firstByte <= 0xb7) {
        // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string
        // The range of the first byte is [0x80, 0xb7]
        length = firstByte - 0x7f;
        // set 0x80 null to 0
        if (firstByte === 0x80) {
            data = Buffer.from([]);
        }
        else {
            data = input.slice(1, length);
        }
        if (length === 2 && data[0] < 0x80) {
            throw new Error('invalid rlp encoding: byte must be less 0x80');
        }
        return {
            data: data,
            remainder: input.slice(length),
        };
    }
    else if (firstByte <= 0xbf) {
        // string is greater than 55 bytes long. A single byte with the value (0xb7 plus the length of the length),
        // followed by the length, followed by the string
        llength = firstByte - 0xb6;
        if (input.length - 1 < llength) {
            throw new Error('invalid RLP: not enough bytes for string length');
        }
        length = safeParseInt(input.slice(1, llength).toString('hex'), 16);
        if (length <= 55) {
            throw new Error('invalid RLP: expected string length to be greater than 55');
        }
        data = input.slice(llength, length + llength);
        if (data.length < length) {
            throw new Error('invalid RLP: not enough bytes for string');
        }
        return {
            data: data,
            remainder: input.slice(length + llength),
        };
    }
    else if (firstByte <= 0xf7) {
        // a list between  0-55 bytes long
        length = firstByte - 0xbf;
        innerRemainder = input.slice(1, length);
        while (innerRemainder.length) {
            d = _decode(innerRemainder);
            decoded.push(d.data);
            innerRemainder = d.remainder;
        }
        return {
            data: decoded,
            remainder: input.slice(length),
        };
    }
    else {
        // a list  over 55 bytes long
        llength = firstByte - 0xf6;
        length = safeParseInt(input.slice(1, llength).toString('hex'), 16);
        var totalLength = llength + length;
        if (totalLength > input.length) {
            throw new Error('invalid rlp: total length is larger than the data');
        }
        innerRemainder = input.slice(llength, totalLength);
        if (innerRemainder.length === 0) {
            throw new Error('invalid rlp, List has a invalid length');
        }
        while (innerRemainder.length) {
            d = _decode(innerRemainder);
            decoded.push(d.data);
            innerRemainder = d.remainder;
        }
        return {
            data: decoded,
            remainder: input.slice(totalLength),
        };
    }
}
/** Check if a string is prefixed by 0x */
function isHexPrefixed(str) {
    return str.slice(0, 2) === '0x';
}
/** Removes 0x from a given String */
function stripHexPrefix(str) {
    if (typeof str !== 'string') {
        return str;
    }
    return isHexPrefixed(str) ? str.slice(2) : str;
}
/** Transform an integer into its hexadecimal value */
function intToHex(integer) {
    if (integer < 0) {
        throw new Error('Invalid integer as argument, must be unsigned!');
    }
    var hex = integer.toString(16);
    return hex.length % 2 ? "0" + hex : hex;
}
/** Pad a string to be even */
function padToEven(a) {
    return a.length % 2 ? "0" + a : a;
}
/** Transform an integer into a Buffer */
function intToBuffer(integer) {
    var hex = intToHex(integer);
    return Buffer.from(hex, 'hex');
}
/** Transform anything into a Buffer */
function toBuffer(v) {
    if (!Buffer.isBuffer(v)) {
        if (typeof v === 'string') {
            if (isHexPrefixed(v)) {
                return Buffer.from(padToEven(stripHexPrefix(v)), 'hex');
            }
            else {
                return Buffer.from(v);
            }
        }
        else if (typeof v === 'number' || typeof v === 'bigint') {
            if (!v) {
                return Buffer.from([]);
            }
            else {
                return intToBuffer(v);
            }
        }
        else if (v === null || v === undefined) {
            return Buffer.from([]);
        }
        else if (v instanceof Uint8Array) {
            return Buffer.from(v);
        }
        else if (bn_js_1.default.isBN(v)) {
            // converts a BN to a Buffer
            return Buffer.from(v.toArray());
        }
        else {
            throw new Error('invalid type');
        }
    }
    return v;
}


/***/ }),

/***/ 50877:
/***/ ((module, exports, __webpack_require__) => {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(7661)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ 80480:
/***/ ((module, exports, __webpack_require__) => {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(7661)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ 77423:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function safeJsonParse(value) {
    if (typeof value !== 'string') {
        throw new Error(`Cannot safe json parse value of type ${typeof value}`);
    }
    try {
        return JSON.parse(value);
    }
    catch (_a) {
        return value;
    }
}
exports.safeJsonParse = safeJsonParse;
function safeJsonStringify(value) {
    return typeof value === 'string'
        ? value
        : JSON.stringify(value, (key, value) => typeof value === 'undefined' ? null : value);
}
exports.safeJsonStringify = safeJsonStringify;


/***/ }),

/***/ 44383:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint-disable node/no-deprecated-api */



var buffer = __webpack_require__(7661)
var Buffer = buffer.Buffer

var safer = {}

var key

for (key in buffer) {
  if (!buffer.hasOwnProperty(key)) continue
  if (key === 'SlowBuffer' || key === 'Buffer') continue
  safer[key] = buffer[key]
}

var Safer = safer.Buffer = {}
for (key in Buffer) {
  if (!Buffer.hasOwnProperty(key)) continue
  if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue
  Safer[key] = Buffer[key]
}

safer.Buffer.prototype = Buffer.prototype

if (!Safer.from || Safer.from === Uint8Array.from) {
  Safer.from = function (value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value)
    }
    if (value && typeof value.length === 'undefined') {
      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value)
    }
    return Buffer(value, encodingOrOffset, length)
  }
}

if (!Safer.alloc) {
  Safer.alloc = function (size, fill, encoding) {
    if (typeof size !== 'number') {
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size)
    }
    if (size < 0 || size >= 2 * (1 << 30)) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"')
    }
    var buf = Buffer(size)
    if (!fill || fill.length === 0) {
      buf.fill(0)
    } else if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
    return buf
  }
}

if (!safer.kStringMaxLength) {
  try {
    safer.kStringMaxLength = process.binding('buffer').kStringMaxLength
  } catch (e) {
    // we can't determine kStringMaxLength in environments where process.binding
    // is unsupported, so let's not set it
  }
}

if (!safer.constants) {
  safer.constants = {
    MAX_LENGTH: safer.kMaxLength
  }
  if (safer.kStringMaxLength) {
    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength
  }
}

module.exports = safer


/***/ }),

/***/ 96803:
/***/ (function(module) {

"use strict";


(function(root) {
    const MAX_VALUE = 0x7fffffff;

    // The SHA256 and PBKDF2 implementation are from scrypt-async-js:
    // See: https://github.com/dchest/scrypt-async-js
    function SHA256(m) {
        const K = new Uint32Array([
           0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,
           0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,
           0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,
           0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
           0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152,
           0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,
           0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,
           0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
           0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,
           0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08,
           0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f,
           0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
           0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
       ]);

        let h0 = 0x6a09e667, h1 = 0xbb67ae85, h2 = 0x3c6ef372, h3 = 0xa54ff53a;
        let h4 = 0x510e527f, h5 = 0x9b05688c, h6 = 0x1f83d9ab, h7 = 0x5be0cd19;
        const w = new Uint32Array(64);

        function blocks(p) {
            let off = 0, len = p.length;
            while (len >= 64) {
                let a = h0, b = h1, c = h2, d = h3, e = h4, f = h5, g = h6, h = h7, u, i, j, t1, t2;

                for (i = 0; i < 16; i++) {
                    j = off + i*4;
                    w[i] = ((p[j] & 0xff)<<24) | ((p[j+1] & 0xff)<<16) |
                    ((p[j+2] & 0xff)<<8) | (p[j+3] & 0xff);
                }

                for (i = 16; i < 64; i++) {
                    u = w[i-2];
                    t1 = ((u>>>17) | (u<<(32-17))) ^ ((u>>>19) | (u<<(32-19))) ^ (u>>>10);

                    u = w[i-15];
                    t2 = ((u>>>7) | (u<<(32-7))) ^ ((u>>>18) | (u<<(32-18))) ^ (u>>>3);

                    w[i] = (((t1 + w[i-7]) | 0) + ((t2 + w[i-16]) | 0)) | 0;
                }

                for (i = 0; i < 64; i++) {
                    t1 = ((((((e>>>6) | (e<<(32-6))) ^ ((e>>>11) | (e<<(32-11))) ^
                             ((e>>>25) | (e<<(32-25)))) + ((e & f) ^ (~e & g))) | 0) +
                          ((h + ((K[i] + w[i]) | 0)) | 0)) | 0;

                    t2 = ((((a>>>2) | (a<<(32-2))) ^ ((a>>>13) | (a<<(32-13))) ^
                           ((a>>>22) | (a<<(32-22)))) + ((a & b) ^ (a & c) ^ (b & c))) | 0;

                    h = g;
                    g = f;
                    f = e;
                    e = (d + t1) | 0;
                    d = c;
                    c = b;
                    b = a;
                    a = (t1 + t2) | 0;
                }

                h0 = (h0 + a) | 0;
                h1 = (h1 + b) | 0;
                h2 = (h2 + c) | 0;
                h3 = (h3 + d) | 0;
                h4 = (h4 + e) | 0;
                h5 = (h5 + f) | 0;
                h6 = (h6 + g) | 0;
                h7 = (h7 + h) | 0;

                off += 64;
                len -= 64;
            }
        }

        blocks(m);

        let i, bytesLeft = m.length % 64,
        bitLenHi = (m.length / 0x20000000) | 0,
        bitLenLo = m.length << 3,
        numZeros = (bytesLeft < 56) ? 56 : 120,
        p = m.slice(m.length - bytesLeft, m.length);

        p.push(0x80);
        for (i = bytesLeft + 1; i < numZeros; i++) { p.push(0); }
        p.push((bitLenHi >>> 24) & 0xff);
        p.push((bitLenHi >>> 16) & 0xff);
        p.push((bitLenHi >>> 8)  & 0xff);
        p.push((bitLenHi >>> 0)  & 0xff);
        p.push((bitLenLo >>> 24) & 0xff);
        p.push((bitLenLo >>> 16) & 0xff);
        p.push((bitLenLo >>> 8)  & 0xff);
        p.push((bitLenLo >>> 0)  & 0xff);

        blocks(p);

        return [
            (h0 >>> 24) & 0xff, (h0 >>> 16) & 0xff, (h0 >>> 8) & 0xff, (h0 >>> 0) & 0xff,
            (h1 >>> 24) & 0xff, (h1 >>> 16) & 0xff, (h1 >>> 8) & 0xff, (h1 >>> 0) & 0xff,
            (h2 >>> 24) & 0xff, (h2 >>> 16) & 0xff, (h2 >>> 8) & 0xff, (h2 >>> 0) & 0xff,
            (h3 >>> 24) & 0xff, (h3 >>> 16) & 0xff, (h3 >>> 8) & 0xff, (h3 >>> 0) & 0xff,
            (h4 >>> 24) & 0xff, (h4 >>> 16) & 0xff, (h4 >>> 8) & 0xff, (h4 >>> 0) & 0xff,
            (h5 >>> 24) & 0xff, (h5 >>> 16) & 0xff, (h5 >>> 8) & 0xff, (h5 >>> 0) & 0xff,
            (h6 >>> 24) & 0xff, (h6 >>> 16) & 0xff, (h6 >>> 8) & 0xff, (h6 >>> 0) & 0xff,
            (h7 >>> 24) & 0xff, (h7 >>> 16) & 0xff, (h7 >>> 8) & 0xff, (h7 >>> 0) & 0xff
        ];
    }

    function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {
        // compress password if it's longer than hash block length
        password = (password.length <= 64) ? password : SHA256(password);

        const innerLen = 64 + salt.length + 4;
        const inner = new Array(innerLen);
        const outerKey = new Array(64);

        let i;
        let dk = [];

        // inner = (password ^ ipad) || salt || counter
        for (i = 0; i < 64; i++) { inner[i] = 0x36; }
        for (i = 0; i < password.length; i++) { inner[i] ^= password[i]; }
        for (i = 0; i < salt.length; i++) { inner[64 + i] = salt[i]; }
        for (i = innerLen - 4; i < innerLen; i++) { inner[i] = 0; }

        // outerKey = password ^ opad
        for (i = 0; i < 64; i++) outerKey[i] = 0x5c;
        for (i = 0; i < password.length; i++) outerKey[i] ^= password[i];

        // increments counter inside inner
        function incrementCounter() {
            for (let i = innerLen - 1; i >= innerLen - 4; i--) {
                inner[i]++;
                if (inner[i] <= 0xff) return;
                inner[i] = 0;
            }
        }

        // output blocks = SHA256(outerKey || SHA256(inner)) ...
        while (dkLen >= 32) {
            incrementCounter();
            dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))));
            dkLen -= 32;
        }
        if (dkLen > 0) {
            incrementCounter();
            dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))).slice(0, dkLen));
        }

        return dk;
    }

    // The following is an adaptation of scryptsy
    // See: https://www.npmjs.com/package/scryptsy
    function blockmix_salsa8(BY, Yi, r, x, _X) {
        let i;

        arraycopy(BY, (2 * r - 1) * 16, _X, 0, 16);
        for (i = 0; i < 2 * r; i++) {
            blockxor(BY, i * 16, _X, 16);
            salsa20_8(_X, x);
            arraycopy(_X, 0, BY, Yi + (i * 16), 16);
        }

        for (i = 0; i < r; i++) {
            arraycopy(BY, Yi + (i * 2) * 16, BY, (i * 16), 16);
        }

        for (i = 0; i < r; i++) {
            arraycopy(BY, Yi + (i * 2 + 1) * 16, BY, (i + r) * 16, 16);
        }
    }

    function R(a, b) {
        return (a << b) | (a >>> (32 - b));
    }

    function salsa20_8(B, x) {
        arraycopy(B, 0, x, 0, 16);

        for (let i = 8; i > 0; i -= 2) {
            x[ 4] ^= R(x[ 0] + x[12], 7);
            x[ 8] ^= R(x[ 4] + x[ 0], 9);
            x[12] ^= R(x[ 8] + x[ 4], 13);
            x[ 0] ^= R(x[12] + x[ 8], 18);
            x[ 9] ^= R(x[ 5] + x[ 1], 7);
            x[13] ^= R(x[ 9] + x[ 5], 9);
            x[ 1] ^= R(x[13] + x[ 9], 13);
            x[ 5] ^= R(x[ 1] + x[13], 18);
            x[14] ^= R(x[10] + x[ 6], 7);
            x[ 2] ^= R(x[14] + x[10], 9);
            x[ 6] ^= R(x[ 2] + x[14], 13);
            x[10] ^= R(x[ 6] + x[ 2], 18);
            x[ 3] ^= R(x[15] + x[11], 7);
            x[ 7] ^= R(x[ 3] + x[15], 9);
            x[11] ^= R(x[ 7] + x[ 3], 13);
            x[15] ^= R(x[11] + x[ 7], 18);
            x[ 1] ^= R(x[ 0] + x[ 3], 7);
            x[ 2] ^= R(x[ 1] + x[ 0], 9);
            x[ 3] ^= R(x[ 2] + x[ 1], 13);
            x[ 0] ^= R(x[ 3] + x[ 2], 18);
            x[ 6] ^= R(x[ 5] + x[ 4], 7);
            x[ 7] ^= R(x[ 6] + x[ 5], 9);
            x[ 4] ^= R(x[ 7] + x[ 6], 13);
            x[ 5] ^= R(x[ 4] + x[ 7], 18);
            x[11] ^= R(x[10] + x[ 9], 7);
            x[ 8] ^= R(x[11] + x[10], 9);
            x[ 9] ^= R(x[ 8] + x[11], 13);
            x[10] ^= R(x[ 9] + x[ 8], 18);
            x[12] ^= R(x[15] + x[14], 7);
            x[13] ^= R(x[12] + x[15], 9);
            x[14] ^= R(x[13] + x[12], 13);
            x[15] ^= R(x[14] + x[13], 18);
        }

        for (let i = 0; i < 16; ++i) {
            B[i] += x[i];
        }
    }

    // naive approach... going back to loop unrolling may yield additional performance
    function blockxor(S, Si, D, len) {
        for (let i = 0; i < len; i++) {
            D[i] ^= S[Si + i]
        }
    }

    function arraycopy(src, srcPos, dest, destPos, length) {
        while (length--) {
            dest[destPos++] = src[srcPos++];
        }
    }

    function checkBufferish(o) {
        if (!o || typeof(o.length) !== 'number') { return false; }

        for (let i = 0; i < o.length; i++) {
            const v = o[i];
            if (typeof(v) !== 'number' || v % 1 || v < 0 || v >= 256) {
                return false;
            }
        }

        return true;
    }

    function ensureInteger(value, name) {
        if (typeof(value) !== "number" || (value % 1)) { throw new Error('invalid ' + name); }
        return value;
    }

    // N = Cpu cost, r = Memory cost, p = parallelization cost
    // callback(error, progress, key)
    function _scrypt(password, salt, N, r, p, dkLen, callback) {

        N = ensureInteger(N, 'N');
        r = ensureInteger(r, 'r');
        p = ensureInteger(p, 'p');

        dkLen = ensureInteger(dkLen, 'dkLen');

        if (N === 0 || (N & (N - 1)) !== 0) { throw new Error('N must be power of 2'); }

        if (N > MAX_VALUE / 128 / r) { throw new Error('N too large'); }
        if (r > MAX_VALUE / 128 / p) { throw new Error('r too large'); }

        if (!checkBufferish(password)) {
            throw new Error('password must be an array or buffer');
        }
        password = Array.prototype.slice.call(password);

        if (!checkBufferish(salt)) {
            throw new Error('salt must be an array or buffer');
        }
        salt = Array.prototype.slice.call(salt);

        let b = PBKDF2_HMAC_SHA256_OneIter(password, salt, p * 128 * r);
        const B = new Uint32Array(p * 32 * r)
        for (let i = 0; i < B.length; i++) {
            const j = i * 4;
            B[i] = ((b[j + 3] & 0xff) << 24) |
                   ((b[j + 2] & 0xff) << 16) |
                   ((b[j + 1] & 0xff) << 8) |
                   ((b[j + 0] & 0xff) << 0);
        }

        const XY = new Uint32Array(64 * r);
        const V = new Uint32Array(32 * r * N);

        const Yi = 32 * r;

        // scratch space
        const x = new Uint32Array(16);       // salsa20_8
        const _X = new Uint32Array(16);      // blockmix_salsa8

        const totalOps = p * N * 2;
        let currentOp = 0;
        let lastPercent10 = null;

        // Set this to true to abandon the scrypt on the next step
        let stop = false;

        // State information
        let state = 0;
        let i0 = 0, i1;
        let Bi;

        // How many blockmix_salsa8 can we do per step?
        const limit = callback ? parseInt(1000 / r): 0xffffffff;

        // Trick from scrypt-async; if there is a setImmediate shim in place, use it
        const nextTick = (typeof(setImmediate) !== 'undefined') ? setImmediate : setTimeout;

        // This is really all I changed; making scryptsy a state machine so we occasionally
        // stop and give other evnts on the evnt loop a chance to run. ~RicMoo
        const incrementalSMix = function() {
            if (stop) {
                return callback(new Error('cancelled'), currentOp / totalOps);
            }

            let steps;

            switch (state) {
                case 0:
                    // for (var i = 0; i < p; i++)...
                    Bi = i0 * 32 * r;

                    arraycopy(B, Bi, XY, 0, Yi);                       // ROMix - 1

                    state = 1;                                         // Move to ROMix 2
                    i1 = 0;

                    // Fall through

                case 1:

                    // Run up to 1000 steps of the first inner smix loop
                    steps = N - i1;
                    if (steps > limit) { steps = limit; }
                    for (let i = 0; i < steps; i++) {                  // ROMix - 2
                        arraycopy(XY, 0, V, (i1 + i) * Yi, Yi)         // ROMix - 3
                        blockmix_salsa8(XY, Yi, r, x, _X);             // ROMix - 4
                    }

                    // for (var i = 0; i < N; i++)
                    i1 += steps;
                    currentOp += steps;

                    if (callback) {
                        // Call the callback with the progress (optionally stopping us)
                        const percent10 = parseInt(1000 * currentOp / totalOps);
                        if (percent10 !== lastPercent10) {
                            stop = callback(null, currentOp / totalOps);
                            if (stop) { break; }
                            lastPercent10 = percent10;
                        }
                    }

                    if (i1 < N) { break; }

                    i1 = 0;                                          // Move to ROMix 6
                    state = 2;

                    // Fall through

                case 2:

                    // Run up to 1000 steps of the second inner smix loop
                    steps = N - i1;
                    if (steps > limit) { steps = limit; }
                    for (let i = 0; i < steps; i++) {                // ROMix - 6
                        const offset = (2 * r - 1) * 16;             // ROMix - 7
                        const j = XY[offset] & (N - 1);
                        blockxor(V, j * Yi, XY, Yi);                 // ROMix - 8 (inner)
                        blockmix_salsa8(XY, Yi, r, x, _X);           // ROMix - 9 (outer)
                    }

                    // for (var i = 0; i < N; i++)...
                    i1 += steps;
                    currentOp += steps;

                    // Call the callback with the progress (optionally stopping us)
                    if (callback) {
                        const percent10 = parseInt(1000 * currentOp / totalOps);
                        if (percent10 !== lastPercent10) {
                            stop = callback(null, currentOp / totalOps);
                            if (stop) { break; }
                            lastPercent10 = percent10;
                        }
                    }

                    if (i1 < N) { break; }

                    arraycopy(XY, 0, B, Bi, Yi);                     // ROMix - 10

                    // for (var i = 0; i < p; i++)...
                    i0++;
                    if (i0 < p) {
                        state = 0;
                        break;
                    }

                    b = [];
                    for (let i = 0; i < B.length; i++) {
                        b.push((B[i] >>  0) & 0xff);
                        b.push((B[i] >>  8) & 0xff);
                        b.push((B[i] >> 16) & 0xff);
                        b.push((B[i] >> 24) & 0xff);
                    }

                    const derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b, dkLen);

                    // Send the result to the callback
                    if (callback) { callback(null, 1.0, derivedKey); }

                    // Done; don't break (which would reschedule)
                    return derivedKey;
            }

            // Schedule the next steps
            if (callback) { nextTick(incrementalSMix); }
        }

        // Run the smix state machine until completion
        if (!callback) {
            while (true) {
                const derivedKey = incrementalSMix();
                if (derivedKey != undefined) { return derivedKey; }
            }
        }

        // Bootstrap the async incremental smix
        incrementalSMix();
    }

    const lib = {
        scrypt: function(password, salt, N, r, p, dkLen, progressCallback) {
            return new Promise(function(resolve, reject) {
                let lastProgress = 0;
                if (progressCallback) { progressCallback(0); }
                _scrypt(password, salt, N, r, p, dkLen, function(error, progress, key) {
                    if (error) {
                        reject(error);
                    } else if (key) {
                        if (progressCallback && lastProgress !== 1) {
                            progressCallback(1);
                        }
                        resolve(new Uint8Array(key));
                    } else if (progressCallback && progress !== lastProgress) {
                        lastProgress = progress;
                        return progressCallback(progress);
                    }
                });
            });
        },
        syncScrypt: function(password, salt, N, r, p, dkLen) {
            return new Uint8Array(_scrypt(password, salt, N, r, p, dkLen));
        }
    };

    // node.js
    if (true) {
       module.exports = lib;

    // RequireJS/AMD
    // http://www.requirejs.org/docs/api.html
    // https://github.com/amdjs/amdjs-api/wiki/AMD
    } else {}

})(this);


/***/ }),

/***/ 96702:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Buffer = (__webpack_require__(80480).Buffer)

// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = Buffer.from(data, enc)
  }

  var block = this._block
  var blockSize = this._blockSize
  var length = data.length
  var accum = this._len

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize
    var remainder = Math.min(length - offset, blockSize - assigned)

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i]
    }

    accum += remainder
    offset += remainder

    if ((accum % blockSize) === 0) {
      this._update(block)
    }
  }

  this._len += length
  return this
}

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize

  this._block[rem] = 0x80

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1)

  if (rem >= this._finalSize) {
    this._update(this._block)
    this._block.fill(0)
  }

  var bits = this._len * 8

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4)

  // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0
    var highBits = (bits - lowBits) / 0x100000000

    this._block.writeUInt32BE(highBits, this._blockSize - 8)
    this._block.writeUInt32BE(lowBits, this._blockSize - 4)
  }

  this._update(this._block)
  var hash = this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash


/***/ }),

/***/ 60913:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = __webpack_require__(67667)
exports.sha1 = __webpack_require__(32706)
exports.sha224 = __webpack_require__(70079)
exports.sha256 = __webpack_require__(5774)
exports.sha384 = __webpack_require__(49383)
exports.sha512 = __webpack_require__(50573)


/***/ }),

/***/ 67667:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = __webpack_require__(86778)
var Hash = __webpack_require__(96702)
var Buffer = (__webpack_require__(80480).Buffer)

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha


/***/ }),

/***/ 32706:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = __webpack_require__(86778)
var Hash = __webpack_require__(96702)
var Buffer = (__webpack_require__(80480).Buffer)

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1


/***/ }),

/***/ 70079:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = __webpack_require__(86778)
var Sha256 = __webpack_require__(5774)
var Hash = __webpack_require__(96702)
var Buffer = (__webpack_require__(80480).Buffer)

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8
  this._b = 0x367cd507
  this._c = 0x3070dd17
  this._d = 0xf70e5939
  this._e = 0xffc00b31
  this._f = 0x68581511
  this._g = 0x64f98fa7
  this._h = 0xbefa4fa4

  return this
}

Sha224.prototype._hash = function () {
  var H = Buffer.allocUnsafe(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224


/***/ }),

/***/ 5774:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = __webpack_require__(86778)
var Hash = __webpack_require__(96702)
var Buffer = (__webpack_require__(80480).Buffer)

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = Buffer.allocUnsafe(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256


/***/ }),

/***/ 49383:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var inherits = __webpack_require__(86778)
var SHA512 = __webpack_require__(50573)
var Hash = __webpack_require__(96702)
var Buffer = (__webpack_require__(80480).Buffer)

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d
  this._bh = 0x629a292a
  this._ch = 0x9159015a
  this._dh = 0x152fecd8
  this._eh = 0x67332667
  this._fh = 0x8eb44a87
  this._gh = 0xdb0c2e0d
  this._hh = 0x47b5481d

  this._al = 0xc1059ed8
  this._bl = 0x367cd507
  this._cl = 0x3070dd17
  this._dl = 0xf70e5939
  this._el = 0xffc00b31
  this._fl = 0x68581511
  this._gl = 0x64f98fa7
  this._hl = 0xbefa4fa4

  return this
}

Sha384.prototype._hash = function () {
  var H = Buffer.allocUnsafe(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)

  return H
}

module.exports = Sha384


/***/ }),

/***/ 50573:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var inherits = __webpack_require__(86778)
var Hash = __webpack_require__(96702)
var Buffer = (__webpack_require__(80480).Buffer)

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._ah = 0x6a09e667
  this._bh = 0xbb67ae85
  this._ch = 0x3c6ef372
  this._dh = 0xa54ff53a
  this._eh = 0x510e527f
  this._fh = 0x9b05688c
  this._gh = 0x1f83d9ab
  this._hh = 0x5be0cd19

  this._al = 0xf3bcc908
  this._bl = 0x84caa73b
  this._cl = 0xfe94f82b
  this._dl = 0x5f1d36f1
  this._el = 0xade682d1
  this._fl = 0x2b3e6c1f
  this._gl = 0xfb41bd6b
  this._hl = 0x137e2179

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
}

function sigma1 (x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
}

function Gamma0 (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
}

function Gamma0l (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
}

function Gamma1 (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
}

function Gamma1l (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
}

function getCarry (a, b) {
  return (a >>> 0) < (b >>> 0) ? 1 : 0
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var ah = this._ah | 0
  var bh = this._bh | 0
  var ch = this._ch | 0
  var dh = this._dh | 0
  var eh = this._eh | 0
  var fh = this._fh | 0
  var gh = this._gh | 0
  var hh = this._hh | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4)
    W[i + 1] = M.readInt32BE(i * 4 + 4)
  }
  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2]
    var xl = W[i - 15 * 2 + 1]
    var gamma0 = Gamma0(xh, xl)
    var gamma0l = Gamma0l(xl, xh)

    xh = W[i - 2 * 2]
    xl = W[i - 2 * 2 + 1]
    var gamma1 = Gamma1(xh, xl)
    var gamma1l = Gamma1l(xl, xh)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2]
    var Wi7l = W[i - 7 * 2 + 1]

    var Wi16h = W[i - 16 * 2]
    var Wi16l = W[i - 16 * 2 + 1]

    var Wil = (gamma0l + Wi7l) | 0
    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
    Wil = (Wil + gamma1l) | 0
    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
    Wil = (Wil + Wi16l) | 0
    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0

    W[i] = Wih
    W[i + 1] = Wil
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j]
    Wil = W[j + 1]

    var majh = maj(ah, bh, ch)
    var majl = maj(al, bl, cl)

    var sigma0h = sigma0(ah, al)
    var sigma0l = sigma0(al, ah)
    var sigma1h = sigma1(eh, el)
    var sigma1l = sigma1(el, eh)

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = K[j]
    var Kil = K[j + 1]

    var chh = Ch(eh, fh, gh)
    var chl = Ch(el, fl, gl)

    var t1l = (hl + sigma1l) | 0
    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
    t1l = (t1l + chl) | 0
    t1h = (t1h + chh + getCarry(t1l, chl)) | 0
    t1l = (t1l + Kil) | 0
    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
    t1l = (t1l + Wil) | 0
    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0

    // t2 = sigma0 + maj
    var t2l = (sigma0l + majl) | 0
    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0

    hh = gh
    hl = gl
    gh = fh
    gl = fl
    fh = eh
    fl = el
    el = (dl + t1l) | 0
    eh = (dh + t1h + getCarry(el, dl)) | 0
    dh = ch
    dl = cl
    ch = bh
    cl = bl
    bh = ah
    bl = al
    al = (t1l + t2l) | 0
    ah = (t1h + t2h + getCarry(al, t1l)) | 0
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
}

Sha512.prototype._hash = function () {
  var H = Buffer.allocUnsafe(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)
  writeInt64BE(this._gh, this._gl, 48)
  writeInt64BE(this._hh, this._hl, 56)

  return H
}

module.exports = Sha512


/***/ }),

/***/ 5259:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;
__webpack_unused_export__ = ({value:true});__webpack_unused_export__=__webpack_unused_export__=__webpack_unused_export__=exports.Aj=__webpack_unused_export__=void 0;var _buffer=__webpack_require__(7661);var _sponge=_interopRequireDefault(__webpack_require__(77686));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj}}var createHash=function createHash(_ref){var allowedSizes=_ref.allowedSizes,defaultSize=_ref.defaultSize,padding=_ref.padding;return function Hash(){var _this=this;var size=arguments.length>0&&arguments[0]!==undefined?arguments[0]:defaultSize;if(!this||this.constructor!==Hash){return new Hash(size)}if(allowedSizes&&!allowedSizes.includes(size)){throw new Error("Unsupported hash length")}var sponge=new _sponge["default"]({capacity:size});this.update=function(input){var encoding=arguments.length>1&&arguments[1]!==undefined?arguments[1]:"utf8";if(_buffer.Buffer.isBuffer(input)){sponge.absorb(input);return _this}if(typeof input==="string"){return _this.update(_buffer.Buffer.from(input,encoding))}throw new TypeError("Not a string or buffer")};this.digest=function(){var formatOrOptions=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"binary";var options=typeof formatOrOptions==="string"?{format:formatOrOptions}:formatOrOptions;var buffer=sponge.squeeze({buffer:options.buffer,padding:options.padding||padding});if(options.format&&options.format!=="binary"){return buffer.toString(options.format)}return buffer};this.reset=function(){sponge.reset();return _this};return this}};var Keccak=createHash({allowedSizes:[224,256,384,512],defaultSize:512,padding:1});__webpack_unused_export__=Keccak;var SHA3=createHash({allowedSizes:[224,256,384,512],defaultSize:512,padding:6});exports.Aj=SHA3;var SHAKE=createHash({allowedSizes:[128,256],defaultSize:256,padding:31});__webpack_unused_export__=SHAKE;var SHA3Hash=Keccak;__webpack_unused_export__=SHA3Hash;SHA3.SHA3Hash=SHA3Hash;var _default=SHA3;__webpack_unused_export__=_default;

/***/ }),

/***/ 77686:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value:true}));exports["default"]=void 0;var _buffer=__webpack_require__(7661);var _permute=_interopRequireDefault(__webpack_require__(60605));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj}}var xorWords=function xorWords(I,O){for(var i=0;i<I.length;i+=8){var o=i/4;O[o]^=I[i+7]<<24|I[i+6]<<16|I[i+5]<<8|I[i+4];O[o+1]^=I[i+3]<<24|I[i+2]<<16|I[i+1]<<8|I[i]}return O};var readWords=function readWords(I,O){for(var o=0;o<O.length;o+=8){var i=o/4;O[o]=I[i+1];O[o+1]=I[i+1]>>>8;O[o+2]=I[i+1]>>>16;O[o+3]=I[i+1]>>>24;O[o+4]=I[i];O[o+5]=I[i]>>>8;O[o+6]=I[i]>>>16;O[o+7]=I[i]>>>24}return O};var Sponge=function Sponge(_ref){var _this=this;var capacity=_ref.capacity,padding=_ref.padding;var keccak=(0,_permute["default"])();var stateSize=200;var blockSize=capacity/8;var queueSize=stateSize-capacity/4;var queueOffset=0;var state=new Uint32Array(stateSize/4);var queue=_buffer.Buffer.allocUnsafe(queueSize);this.absorb=function(buffer){for(var i=0;i<buffer.length;i++){queue[queueOffset]=buffer[i];queueOffset+=1;if(queueOffset>=queueSize){xorWords(queue,state);keccak(state);queueOffset=0}}return _this};this.squeeze=function(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var output={buffer:options.buffer||_buffer.Buffer.allocUnsafe(blockSize),padding:options.padding||padding,queue:_buffer.Buffer.allocUnsafe(queue.length),state:new Uint32Array(state.length)};queue.copy(output.queue);for(var i=0;i<state.length;i++){output.state[i]=state[i]}output.queue.fill(0,queueOffset);output.queue[queueOffset]|=output.padding;output.queue[queueSize-1]|=128;xorWords(output.queue,output.state);for(var offset=0;offset<output.buffer.length;offset+=queueSize){keccak(output.state);readWords(output.state,output.buffer.slice(offset,offset+queueSize))}return output.buffer};this.reset=function(){queue.fill(0);state.fill(0);queueOffset=0;return _this};return this};var _default=Sponge;exports["default"]=_default;

/***/ }),

/***/ 21024:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value:true}));exports["default"]=void 0;var _copy=_interopRequireDefault(__webpack_require__(99302));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj}}var chi=function chi(_ref){var A=_ref.A,C=_ref.C;for(var y=0;y<25;y+=5){for(var x=0;x<5;x++){(0,_copy["default"])(A,y+x)(C,x)}for(var _x=0;_x<5;_x++){var xy=(y+_x)*2;var x1=(_x+1)%5*2;var x2=(_x+2)%5*2;A[xy]^=~C[x1]&C[x2];A[xy+1]^=~C[x1+1]&C[x2+1]}}};var _default=chi;exports["default"]=_default;

/***/ }),

/***/ 99302:
/***/ ((module) => {

"use strict";
var copy=function copy(I,i){return function(O,o){var oi=o*2;var ii=i*2;O[oi]=I[ii];O[oi+1]=I[ii+1]}};module.exports=copy;

/***/ }),

/***/ 60605:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value:true}));exports["default"]=void 0;var _chi=_interopRequireDefault(__webpack_require__(21024));var _iota=_interopRequireDefault(__webpack_require__(22452));var _rhoPi=_interopRequireDefault(__webpack_require__(59890));var _theta=_interopRequireDefault(__webpack_require__(94252));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj}}var permute=function permute(){var C=new Uint32Array(10);var D=new Uint32Array(10);var W=new Uint32Array(2);return function(A){for(var roundIndex=0;roundIndex<24;roundIndex++){(0,_theta["default"])({A:A,C:C,D:D,W:W});(0,_rhoPi["default"])({A:A,C:C,W:W});(0,_chi["default"])({A:A,C:C});(0,_iota["default"])({A:A,roundIndex:roundIndex})}C.fill(0);D.fill(0);W.fill(0)}};var _default=permute;exports["default"]=_default;

/***/ }),

/***/ 22452:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value:true}));exports["default"]=void 0;var _roundConstants=_interopRequireDefault(__webpack_require__(31901));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj}}var iota=function iota(_ref){var A=_ref.A,roundIndex=_ref.roundIndex;var i=roundIndex*2;A[0]^=_roundConstants["default"][i];A[1]^=_roundConstants["default"][i+1]};var _default=iota;exports["default"]=_default;

/***/ }),

/***/ 31901:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value:true}));exports["default"]=void 0;var ROUND_CONSTANTS=new Uint32Array([0,1,0,32898,2147483648,32906,2147483648,2147516416,0,32907,0,2147483649,2147483648,2147516545,2147483648,32777,0,138,0,136,0,2147516425,0,2147483658,0,2147516555,2147483648,139,2147483648,32905,2147483648,32771,2147483648,32770,2147483648,128,0,32778,2147483648,2147483658,2147483648,2147516545,2147483648,32896,0,2147483649,2147483648,2147516424]);var _default=ROUND_CONSTANTS;exports["default"]=_default;

/***/ }),

/***/ 59890:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value:true}));exports["default"]=void 0;var _piShuffles=_interopRequireDefault(__webpack_require__(61541));var _rhoOffsets=_interopRequireDefault(__webpack_require__(93787));var _copy=_interopRequireDefault(__webpack_require__(99302));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj}}var rhoPi=function rhoPi(_ref){var A=_ref.A,C=_ref.C,W=_ref.W;(0,_copy["default"])(A,1)(W,0);var H=0;var L=0;var Wi=0;var ri=32;for(var i=0;i<24;i++){var j=_piShuffles["default"][i];var r=_rhoOffsets["default"][i];(0,_copy["default"])(A,j)(C,0);H=W[0];L=W[1];ri=32-r;Wi=r<32?0:1;W[Wi]=H<<r|L>>>ri;W[(Wi+1)%2]=L<<r|H>>>ri;(0,_copy["default"])(W,0)(A,j);(0,_copy["default"])(C,0)(W,0)}};var _default=rhoPi;exports["default"]=_default;

/***/ }),

/***/ 61541:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value:true}));exports["default"]=void 0;var PI_SHUFFLES=[10,7,11,17,18,3,5,16,8,21,24,4,15,23,19,13,12,2,20,14,22,9,6,1];var _default=PI_SHUFFLES;exports["default"]=_default;

/***/ }),

/***/ 93787:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value:true}));exports["default"]=void 0;var RHO_OFFSETS=[1,3,6,10,15,21,28,36,45,55,2,14,27,41,56,8,25,43,62,18,39,61,20,44];var _default=RHO_OFFSETS;exports["default"]=_default;

/***/ }),

/***/ 94252:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value:true}));exports["default"]=void 0;var _copy=_interopRequireDefault(__webpack_require__(99302));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj}}var theta=function theta(_ref){var A=_ref.A,C=_ref.C,D=_ref.D,W=_ref.W;var H=0;var L=0;for(var x=0;x<5;x++){var x20=x*2;var x21=(x+5)*2;var x22=(x+10)*2;var x23=(x+15)*2;var x24=(x+20)*2;C[x20]=A[x20]^A[x21]^A[x22]^A[x23]^A[x24];C[x20+1]=A[x20+1]^A[x21+1]^A[x22+1]^A[x23+1]^A[x24+1]}for(var _x=0;_x<5;_x++){(0,_copy["default"])(C,(_x+1)%5)(W,0);H=W[0];L=W[1];W[0]=H<<1|L>>>31;W[1]=L<<1|H>>>31;D[_x*2]=C[(_x+4)%5*2]^W[0];D[_x*2+1]=C[(_x+4)%5*2+1]^W[1];for(var y=0;y<25;y+=5){A[(y+_x)*2]^=D[_x*2];A[(y+_x)*2+1]^=D[_x*2+1]}}};var _default=theta;exports["default"]=_default;

/***/ }),

/***/ 26571:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(46858);
var callBound = __webpack_require__(8507);
var inspect = __webpack_require__(29879);

var $TypeError = GetIntrinsic('%TypeError%');
var $WeakMap = GetIntrinsic('%WeakMap%', true);
var $Map = GetIntrinsic('%Map%', true);

var $weakMapGet = callBound('WeakMap.prototype.get', true);
var $weakMapSet = callBound('WeakMap.prototype.set', true);
var $weakMapHas = callBound('WeakMap.prototype.has', true);
var $mapGet = callBound('Map.prototype.get', true);
var $mapSet = callBound('Map.prototype.set', true);
var $mapHas = callBound('Map.prototype.has', true);

/*
 * This function traverses the list returning the node corresponding to the
 * given key.
 *
 * That node is also moved to the head of the list, so that if it's accessed
 * again we don't need to traverse the whole list. By doing so, all the recently
 * used nodes can be accessed relatively quickly.
 */
var listGetNode = function (list, key) { // eslint-disable-line consistent-return
	for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
		if (curr.key === key) {
			prev.next = curr.next;
			curr.next = list.next;
			list.next = curr; // eslint-disable-line no-param-reassign
			return curr;
		}
	}
};

var listGet = function (objects, key) {
	var node = listGetNode(objects, key);
	return node && node.value;
};
var listSet = function (objects, key, value) {
	var node = listGetNode(objects, key);
	if (node) {
		node.value = value;
	} else {
		// Prepend the new node to the beginning of the list
		objects.next = { // eslint-disable-line no-param-reassign
			key: key,
			next: objects.next,
			value: value
		};
	}
};
var listHas = function (objects, key) {
	return !!listGetNode(objects, key);
};

module.exports = function getSideChannel() {
	var $wm;
	var $m;
	var $o;
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		get: function (key) { // eslint-disable-line consistent-return
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapGet($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapGet($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listGet($o, key);
				}
			}
		},
		has: function (key) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapHas($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapHas($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listHas($o, key);
				}
			}
			return false;
		},
		set: function (key, value) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if (!$wm) {
					$wm = new $WeakMap();
				}
				$weakMapSet($wm, key, value);
			} else if ($Map) {
				if (!$m) {
					$m = new $Map();
				}
				$mapSet($m, key, value);
			} else {
				if (!$o) {
					/*
					 * Initialize the linked list as an empty node, so that we don't have
					 * to special-case handling of the first node: we can always refer to
					 * it as (previous node).next, instead of something like (list).head
					 */
					$o = { key: {}, next: null };
				}
				listSet($o, key, value);
			}
		}
	};
	return channel;
};


/***/ }),

/***/ 74064:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = __webpack_require__(96746);
var isBuf = __webpack_require__(17475);
var toString = Object.prototype.toString;
var withNativeBlob = typeof Blob === 'function' || (typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]');
var withNativeFile = typeof File === 'function' || (typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]');

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet) {
  var buffers = [];
  var packetData = packet.data;
  var pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

function _deconstructPacket(data, buffers) {
  if (!data) return data;

  if (isBuf(data)) {
    var placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (isArray(data)) {
    var newData = new Array(data.length);
    for (var i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }
    return newData;
  } else if (typeof data === 'object' && !(data instanceof Date)) {
    var newData = {};
    for (var key in data) {
      newData[key] = _deconstructPacket(data[key], buffers);
    }
    return newData;
  }
  return data;
}

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  packet.attachments = undefined; // no longer useful
  return packet;
};

function _reconstructPacket(data, buffers) {
  if (!data) return data;

  if (data && data._placeholder) {
    return buffers[data.num]; // appropriate buffer (should be natural order anyway)
  } else if (isArray(data)) {
    for (var i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (typeof data === 'object') {
    for (var key in data) {
      data[key] = _reconstructPacket(data[key], buffers);
    }
  }

  return data;
}

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((withNativeBlob && obj instanceof Blob) ||
        (withNativeFile && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (typeof obj === 'object' && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};


/***/ }),

/***/ 69092:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/**
 * Module dependencies.
 */

var debug = __webpack_require__(91758)('socket.io-parser');
var Emitter = __webpack_require__(43547);
var binary = __webpack_require__(74064);
var isArray = __webpack_require__(96746);
var isBuf = __webpack_require__(17475);

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'ACK',
  'ERROR',
  'BINARY_EVENT',
  'BINARY_ACK'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

var ERROR_PACKET = exports.ERROR + '"encode error"';

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
    encodeAsBinary(obj, callback);
  } else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {

  // first is type
  var str = '' + obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
    str += obj.attachments + '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' !== obj.nsp) {
    str += obj.nsp + ',';
  }

  // immediately followed by the id
  if (null != obj.id) {
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    var payload = tryStringify(obj.data);
    if (payload !== false) {
      str += payload;
    } else {
      return ERROR_PACKET;
    }
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

function tryStringify(str) {
  try {
    return JSON.stringify(str);
  } catch(e){
    return false;
  }
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an encoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if (typeof obj === 'string') {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  } else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  } else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var i = 0;
  // look up type
  var p = {
    type: Number(str.charAt(0))
  };

  if (null == exports.types[p.type]) {
    return error('unknown packet type ' + p.type);
  }

  // look up attachments if type binary
  if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {
    var start = i + 1;
    while (str.charAt(++i) !== '-' && i != str.length) {}
    var buf = str.substring(start, i);
    if (buf != Number(buf) || str.charAt(i) !== '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' === str.charAt(i + 1)) {
    var start = i + 1;
    while (++i) {
      var c = str.charAt(i);
      if (',' === c) break;
      if (i === str.length) break;
    }
    p.nsp = str.substring(start, i);
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    var start = i + 1;
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      if (i === str.length) break;
    }
    p.id = Number(str.substring(start, i + 1));
  }

  // look up json data
  if (str.charAt(++i)) {
    var payload = tryParse(str.substr(i));
    var isPayloadValid = payload !== false && (p.type === exports.ERROR || isArray(payload));
    if (isPayloadValid) {
      p.data = payload;
    } else {
      return error('invalid payload');
    }
  }

  debug('decoded %s as %j', str, p);
  return p;
}

function tryParse(str) {
  try {
    return JSON.parse(str);
  } catch(e){
    return false;
  }
}

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length === this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(msg) {
  return {
    type: exports.ERROR,
    data: 'parser error: ' + msg
  };
}


/***/ }),

/***/ 17475:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(7661)["Buffer"];

module.exports = isBuf;

var withNativeBuffer = typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function';
var withNativeArrayBuffer = typeof ArrayBuffer === 'function';

var isView = function (obj) {
  return typeof ArrayBuffer.isView === 'function' ? ArrayBuffer.isView(obj) : (obj.buffer instanceof ArrayBuffer);
};

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (withNativeBuffer && Buffer.isBuffer(obj)) ||
          (withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)));
}


/***/ }),

/***/ 34067:
/***/ ((module) => {

"use strict";


module.exports = (string, separator) => {
	if (!(typeof string === 'string' && typeof separator === 'string')) {
		throw new TypeError('Expected the arguments to be of type `string`');
	}

	if (separator === '') {
		return [string];
	}

	const separatorIndex = string.indexOf(separator);

	if (separatorIndex === -1) {
		return [string];
	}

	return [
		string.slice(0, separatorIndex),
		string.slice(separatorIndex + separator.length)
	];
};


/***/ }),

/***/ 50190:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = (__webpack_require__(58470).EventEmitter);
var inherits = __webpack_require__(86778);

inherits(Stream, EE);
Stream.Readable = __webpack_require__(11036);
Stream.Writable = __webpack_require__(8738);
Stream.Duplex = __webpack_require__(15156);
Stream.Transform = __webpack_require__(73358);
Stream.PassThrough = __webpack_require__(51312);
Stream.finished = __webpack_require__(41321)
Stream.pipeline = __webpack_require__(11757)

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};


/***/ }),

/***/ 1107:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var ClientRequest = __webpack_require__(16990)
var response = __webpack_require__(81859)
var extend = __webpack_require__(29790)
var statusCodes = __webpack_require__(37433)
var url = __webpack_require__(43580)

var http = exports

http.request = function (opts, cb) {
	if (typeof opts === 'string')
		opts = url.parse(opts)
	else
		opts = extend(opts)

	// Normally, the page is loaded from http or https, so not specifying a protocol
	// will result in a (valid) protocol-relative url. However, this won't work if
	// the protocol is something else, like 'file:'
	var defaultProtocol = __webpack_require__.g.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''

	var protocol = opts.protocol || defaultProtocol
	var host = opts.hostname || opts.host
	var port = opts.port
	var path = opts.path || '/'

	// Necessary for IPv6 addresses
	if (host && host.indexOf(':') !== -1)
		host = '[' + host + ']'

	// This may be a relative url. The browser should always be able to interpret it correctly.
	opts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path
	opts.method = (opts.method || 'GET').toUpperCase()
	opts.headers = opts.headers || {}

	// Also valid opts.auth, opts.mode

	var req = new ClientRequest(opts)
	if (cb)
		req.on('response', cb)
	return req
}

http.get = function get (opts, cb) {
	var req = http.request(opts, cb)
	req.end()
	return req
}

http.ClientRequest = ClientRequest
http.IncomingMessage = response.IncomingMessage

http.Agent = function () {}
http.Agent.defaultMaxSockets = 4

http.globalAgent = new http.Agent()

http.STATUS_CODES = statusCodes

http.METHODS = [
	'CHECKOUT',
	'CONNECT',
	'COPY',
	'DELETE',
	'GET',
	'HEAD',
	'LOCK',
	'M-SEARCH',
	'MERGE',
	'MKACTIVITY',
	'MKCOL',
	'MOVE',
	'NOTIFY',
	'OPTIONS',
	'PATCH',
	'POST',
	'PROPFIND',
	'PROPPATCH',
	'PURGE',
	'PUT',
	'REPORT',
	'SEARCH',
	'SUBSCRIBE',
	'TRACE',
	'UNLOCK',
	'UNSUBSCRIBE'
]

/***/ }),

/***/ 29292:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.fetch = isFunction(__webpack_require__.g.fetch) && isFunction(__webpack_require__.g.ReadableStream)

exports.writableStream = isFunction(__webpack_require__.g.WritableStream)

exports.abortController = isFunction(__webpack_require__.g.AbortController)

exports.blobConstructor = false
try {
	new Blob([new ArrayBuffer(1)])
	exports.blobConstructor = true
} catch (e) {}

// The xhr request to example.com may violate some restrictive CSP configurations,
// so if we're running in a browser that supports `fetch`, avoid calling getXHR()
// and assume support for certain features below.
var xhr
function getXHR () {
	// Cache the xhr value
	if (xhr !== undefined) return xhr

	if (__webpack_require__.g.XMLHttpRequest) {
		xhr = new __webpack_require__.g.XMLHttpRequest()
		// If XDomainRequest is available (ie only, where xhr might not work
		// cross domain), use the page location. Otherwise use example.com
		// Note: this doesn't actually make an http request.
		try {
			xhr.open('GET', __webpack_require__.g.XDomainRequest ? '/' : 'https://example.com')
		} catch(e) {
			xhr = null
		}
	} else {
		// Service workers don't have XHR
		xhr = null
	}
	return xhr
}

function checkTypeSupport (type) {
	var xhr = getXHR()
	if (!xhr) return false
	try {
		xhr.responseType = type
		return xhr.responseType === type
	} catch (e) {}
	return false
}

// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.
// Safari 7.1 appears to have fixed this bug.
var haveArrayBuffer = typeof __webpack_require__.g.ArrayBuffer !== 'undefined'
var haveSlice = haveArrayBuffer && isFunction(__webpack_require__.g.ArrayBuffer.prototype.slice)

// If fetch is supported, then arraybuffer will be supported too. Skip calling
// checkTypeSupport(), since that calls getXHR().
exports.arraybuffer = exports.fetch || (haveArrayBuffer && checkTypeSupport('arraybuffer'))

// These next two tests unavoidably show warnings in Chrome. Since fetch will always
// be used if it's available, just return false for these to avoid the warnings.
exports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream')
exports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer &&
	checkTypeSupport('moz-chunked-arraybuffer')

// If fetch is supported, then overrideMimeType will be supported too. Skip calling
// getXHR().
exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false)

exports.vbArray = isFunction(__webpack_require__.g.VBArray)

function isFunction (value) {
	return typeof value === 'function'
}

xhr = null // Help gc


/***/ }),

/***/ 16990:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(7661)["Buffer"];
/* provided dependency */ var __webpack_provided_process_dot_nextTick = __webpack_require__(52528);
var capability = __webpack_require__(29292)
var inherits = __webpack_require__(86778)
var response = __webpack_require__(81859)
var stream = __webpack_require__(65746)
var toArrayBuffer = __webpack_require__(70936)

var IncomingMessage = response.IncomingMessage
var rStates = response.readyStates

function decideMode (preferBinary, useFetch) {
	if (capability.fetch && useFetch) {
		return 'fetch'
	} else if (capability.mozchunkedarraybuffer) {
		return 'moz-chunked-arraybuffer'
	} else if (capability.msstream) {
		return 'ms-stream'
	} else if (capability.arraybuffer && preferBinary) {
		return 'arraybuffer'
	} else if (capability.vbArray && preferBinary) {
		return 'text:vbarray'
	} else {
		return 'text'
	}
}

var ClientRequest = module.exports = function (opts) {
	var self = this
	stream.Writable.call(self)

	self._opts = opts
	self._body = []
	self._headers = {}
	if (opts.auth)
		self.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'))
	Object.keys(opts.headers).forEach(function (name) {
		self.setHeader(name, opts.headers[name])
	})

	var preferBinary
	var useFetch = true
	if (opts.mode === 'disable-fetch' || ('requestTimeout' in opts && !capability.abortController)) {
		// If the use of XHR should be preferred. Not typically needed.
		useFetch = false
		preferBinary = true
	} else if (opts.mode === 'prefer-streaming') {
		// If streaming is a high priority but binary compatibility and
		// the accuracy of the 'content-type' header aren't
		preferBinary = false
	} else if (opts.mode === 'allow-wrong-content-type') {
		// If streaming is more important than preserving the 'content-type' header
		preferBinary = !capability.overrideMimeType
	} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
		// Use binary if text streaming may corrupt data or the content-type header, or for speed
		preferBinary = true
	} else {
		throw new Error('Invalid value for opts.mode')
	}
	self._mode = decideMode(preferBinary, useFetch)
	self._fetchTimer = null

	self.on('finish', function () {
		self._onFinish()
	})
}

inherits(ClientRequest, stream.Writable)

ClientRequest.prototype.setHeader = function (name, value) {
	var self = this
	var lowerName = name.toLowerCase()
	// This check is not necessary, but it prevents warnings from browsers about setting unsafe
	// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
	// http-browserify did it, so I will too.
	if (unsafeHeaders.indexOf(lowerName) !== -1)
		return

	self._headers[lowerName] = {
		name: name,
		value: value
	}
}

ClientRequest.prototype.getHeader = function (name) {
	var header = this._headers[name.toLowerCase()]
	if (header)
		return header.value
	return null
}

ClientRequest.prototype.removeHeader = function (name) {
	var self = this
	delete self._headers[name.toLowerCase()]
}

ClientRequest.prototype._onFinish = function () {
	var self = this

	if (self._destroyed)
		return
	var opts = self._opts

	var headersObj = self._headers
	var body = null
	if (opts.method !== 'GET' && opts.method !== 'HEAD') {
		if (capability.arraybuffer) {
			body = toArrayBuffer(Buffer.concat(self._body))
		} else if (capability.blobConstructor) {
			body = new __webpack_require__.g.Blob(self._body.map(function (buffer) {
				return toArrayBuffer(buffer)
			}), {
				type: (headersObj['content-type'] || {}).value || ''
			})
		} else {
			// get utf8 string
			body = Buffer.concat(self._body).toString()
		}
	}

	// create flattened list of headers
	var headersList = []
	Object.keys(headersObj).forEach(function (keyName) {
		var name = headersObj[keyName].name
		var value = headersObj[keyName].value
		if (Array.isArray(value)) {
			value.forEach(function (v) {
				headersList.push([name, v])
			})
		} else {
			headersList.push([name, value])
		}
	})

	if (self._mode === 'fetch') {
		var signal = null
		var fetchTimer = null
		if (capability.abortController) {
			var controller = new AbortController()
			signal = controller.signal
			self._fetchAbortController = controller

			if ('requestTimeout' in opts && opts.requestTimeout !== 0) {
				self._fetchTimer = __webpack_require__.g.setTimeout(function () {
					self.emit('requestTimeout')
					if (self._fetchAbortController)
						self._fetchAbortController.abort()
				}, opts.requestTimeout)
			}
		}

		__webpack_require__.g.fetch(self._opts.url, {
			method: self._opts.method,
			headers: headersList,
			body: body || undefined,
			mode: 'cors',
			credentials: opts.withCredentials ? 'include' : 'same-origin',
			signal: signal
		}).then(function (response) {
			self._fetchResponse = response
			self._connect()
		}, function (reason) {
			__webpack_require__.g.clearTimeout(self._fetchTimer)
			if (!self._destroyed)
				self.emit('error', reason)
		})
	} else {
		var xhr = self._xhr = new __webpack_require__.g.XMLHttpRequest()
		try {
			xhr.open(self._opts.method, self._opts.url, true)
		} catch (err) {
			__webpack_provided_process_dot_nextTick(function () {
				self.emit('error', err)
			})
			return
		}

		// Can't set responseType on really old browsers
		if ('responseType' in xhr)
			xhr.responseType = self._mode.split(':')[0]

		if ('withCredentials' in xhr)
			xhr.withCredentials = !!opts.withCredentials

		if (self._mode === 'text' && 'overrideMimeType' in xhr)
			xhr.overrideMimeType('text/plain; charset=x-user-defined')

		if ('requestTimeout' in opts) {
			xhr.timeout = opts.requestTimeout
			xhr.ontimeout = function () {
				self.emit('requestTimeout')
			}
		}

		headersList.forEach(function (header) {
			xhr.setRequestHeader(header[0], header[1])
		})

		self._response = null
		xhr.onreadystatechange = function () {
			switch (xhr.readyState) {
				case rStates.LOADING:
				case rStates.DONE:
					self._onXHRProgress()
					break
			}
		}
		// Necessary for streaming in Firefox, since xhr.response is ONLY defined
		// in onprogress, not in onreadystatechange with xhr.readyState = 3
		if (self._mode === 'moz-chunked-arraybuffer') {
			xhr.onprogress = function () {
				self._onXHRProgress()
			}
		}

		xhr.onerror = function () {
			if (self._destroyed)
				return
			self.emit('error', new Error('XHR error'))
		}

		try {
			xhr.send(body)
		} catch (err) {
			__webpack_provided_process_dot_nextTick(function () {
				self.emit('error', err)
			})
			return
		}
	}
}

/**
 * Checks if xhr.status is readable and non-zero, indicating no error.
 * Even though the spec says it should be available in readyState 3,
 * accessing it throws an exception in IE8
 */
function statusValid (xhr) {
	try {
		var status = xhr.status
		return (status !== null && status !== 0)
	} catch (e) {
		return false
	}
}

ClientRequest.prototype._onXHRProgress = function () {
	var self = this

	if (!statusValid(self._xhr) || self._destroyed)
		return

	if (!self._response)
		self._connect()

	self._response._onXHRProgress()
}

ClientRequest.prototype._connect = function () {
	var self = this

	if (self._destroyed)
		return

	self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._fetchTimer)
	self._response.on('error', function(err) {
		self.emit('error', err)
	})

	self.emit('response', self._response)
}

ClientRequest.prototype._write = function (chunk, encoding, cb) {
	var self = this

	self._body.push(chunk)
	cb()
}

ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {
	var self = this
	self._destroyed = true
	__webpack_require__.g.clearTimeout(self._fetchTimer)
	if (self._response)
		self._response._destroyed = true
	if (self._xhr)
		self._xhr.abort()
	else if (self._fetchAbortController)
		self._fetchAbortController.abort()
}

ClientRequest.prototype.end = function (data, encoding, cb) {
	var self = this
	if (typeof data === 'function') {
		cb = data
		data = undefined
	}

	stream.Writable.prototype.end.call(self, data, encoding, cb)
}

ClientRequest.prototype.flushHeaders = function () {}
ClientRequest.prototype.setTimeout = function () {}
ClientRequest.prototype.setNoDelay = function () {}
ClientRequest.prototype.setSocketKeepAlive = function () {}

// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
var unsafeHeaders = [
	'accept-charset',
	'accept-encoding',
	'access-control-request-headers',
	'access-control-request-method',
	'connection',
	'content-length',
	'cookie',
	'cookie2',
	'date',
	'dnt',
	'expect',
	'host',
	'keep-alive',
	'origin',
	'referer',
	'te',
	'trailer',
	'transfer-encoding',
	'upgrade',
	'via'
]


/***/ }),

/***/ 81859:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var __webpack_provided_process_dot_nextTick = __webpack_require__(52528);
/* provided dependency */ var Buffer = __webpack_require__(7661)["Buffer"];
var capability = __webpack_require__(29292)
var inherits = __webpack_require__(86778)
var stream = __webpack_require__(65746)

var rStates = exports.readyStates = {
	UNSENT: 0,
	OPENED: 1,
	HEADERS_RECEIVED: 2,
	LOADING: 3,
	DONE: 4
}

var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, fetchTimer) {
	var self = this
	stream.Readable.call(self)

	self._mode = mode
	self.headers = {}
	self.rawHeaders = []
	self.trailers = {}
	self.rawTrailers = []

	// Fake the 'close' event, but only once 'end' fires
	self.on('end', function () {
		// The nextTick is necessary to prevent the 'request' module from causing an infinite loop
		__webpack_provided_process_dot_nextTick(function () {
			self.emit('close')
		})
	})

	if (mode === 'fetch') {
		self._fetchResponse = response

		self.url = response.url
		self.statusCode = response.status
		self.statusMessage = response.statusText
		
		response.headers.forEach(function (header, key){
			self.headers[key.toLowerCase()] = header
			self.rawHeaders.push(key, header)
		})

		if (capability.writableStream) {
			var writable = new WritableStream({
				write: function (chunk) {
					return new Promise(function (resolve, reject) {
						if (self._destroyed) {
							reject()
						} else if(self.push(new Buffer(chunk))) {
							resolve()
						} else {
							self._resumeFetch = resolve
						}
					})
				},
				close: function () {
					__webpack_require__.g.clearTimeout(fetchTimer)
					if (!self._destroyed)
						self.push(null)
				},
				abort: function (err) {
					if (!self._destroyed)
						self.emit('error', err)
				}
			})

			try {
				response.body.pipeTo(writable).catch(function (err) {
					__webpack_require__.g.clearTimeout(fetchTimer)
					if (!self._destroyed)
						self.emit('error', err)
				})
				return
			} catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this
		}
		// fallback for when writableStream or pipeTo aren't available
		var reader = response.body.getReader()
		function read () {
			reader.read().then(function (result) {
				if (self._destroyed)
					return
				if (result.done) {
					__webpack_require__.g.clearTimeout(fetchTimer)
					self.push(null)
					return
				}
				self.push(new Buffer(result.value))
				read()
			}).catch(function (err) {
				__webpack_require__.g.clearTimeout(fetchTimer)
				if (!self._destroyed)
					self.emit('error', err)
			})
		}
		read()
	} else {
		self._xhr = xhr
		self._pos = 0

		self.url = xhr.responseURL
		self.statusCode = xhr.status
		self.statusMessage = xhr.statusText
		var headers = xhr.getAllResponseHeaders().split(/\r?\n/)
		headers.forEach(function (header) {
			var matches = header.match(/^([^:]+):\s*(.*)/)
			if (matches) {
				var key = matches[1].toLowerCase()
				if (key === 'set-cookie') {
					if (self.headers[key] === undefined) {
						self.headers[key] = []
					}
					self.headers[key].push(matches[2])
				} else if (self.headers[key] !== undefined) {
					self.headers[key] += ', ' + matches[2]
				} else {
					self.headers[key] = matches[2]
				}
				self.rawHeaders.push(matches[1], matches[2])
			}
		})

		self._charset = 'x-user-defined'
		if (!capability.overrideMimeType) {
			var mimeType = self.rawHeaders['mime-type']
			if (mimeType) {
				var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/)
				if (charsetMatch) {
					self._charset = charsetMatch[1].toLowerCase()
				}
			}
			if (!self._charset)
				self._charset = 'utf-8' // best guess
		}
	}
}

inherits(IncomingMessage, stream.Readable)

IncomingMessage.prototype._read = function () {
	var self = this

	var resolve = self._resumeFetch
	if (resolve) {
		self._resumeFetch = null
		resolve()
	}
}

IncomingMessage.prototype._onXHRProgress = function () {
	var self = this

	var xhr = self._xhr

	var response = null
	switch (self._mode) {
		case 'text:vbarray': // For IE9
			if (xhr.readyState !== rStates.DONE)
				break
			try {
				// This fails in IE8
				response = new __webpack_require__.g.VBArray(xhr.responseBody).toArray()
			} catch (e) {}
			if (response !== null) {
				self.push(new Buffer(response))
				break
			}
			// Falls through in IE8	
		case 'text':
			try { // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4
				response = xhr.responseText
			} catch (e) {
				self._mode = 'text:vbarray'
				break
			}
			if (response.length > self._pos) {
				var newData = response.substr(self._pos)
				if (self._charset === 'x-user-defined') {
					var buffer = new Buffer(newData.length)
					for (var i = 0; i < newData.length; i++)
						buffer[i] = newData.charCodeAt(i) & 0xff

					self.push(buffer)
				} else {
					self.push(newData, self._charset)
				}
				self._pos = response.length
			}
			break
		case 'arraybuffer':
			if (xhr.readyState !== rStates.DONE || !xhr.response)
				break
			response = xhr.response
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'moz-chunked-arraybuffer': // take whole
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING || !response)
				break
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'ms-stream':
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING)
				break
			var reader = new __webpack_require__.g.MSStreamReader()
			reader.onprogress = function () {
				if (reader.result.byteLength > self._pos) {
					self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))))
					self._pos = reader.result.byteLength
				}
			}
			reader.onload = function () {
				self.push(null)
			}
			// reader.onerror = ??? // TODO: this
			reader.readAsArrayBuffer(response)
			break
	}

	// The ms-stream case handles end separately in reader.onload()
	if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
		self.push(null)
	}
}


/***/ }),

/***/ 43572:
/***/ ((module) => {

"use strict";

module.exports = str => encodeURIComponent(str).replace(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);


/***/ }),

/***/ 56575:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = (__webpack_require__(50877).Buffer);
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.s = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ 16448:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = (__webpack_require__(80480).Buffer);
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.s = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ 12325:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isHexPrefixed = __webpack_require__(84725);

/**
 * Removes '0x' from a given `String` is present
 * @param {String} str the string value
 * @return {String|Optional} a string by pass if necessary
 */
module.exports = function stripHexPrefix(str) {
  if (typeof str !== 'string') {
    return str;
  }

  return isHexPrefixed(str) ? str.slice(2) : str;
}


/***/ }),

/***/ 6334:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// This is free and unencumbered software released into the public domain.
// See LICENSE.md for more information.

//
// Utilities
//

/**
 * @param {number} a The number to test.
 * @param {number} min The minimum value in the range, inclusive.
 * @param {number} max The maximum value in the range, inclusive.
 * @return {boolean} True if a >= min and a <= max.
 */
function inRange(a, min, max) {
  return min <= a && a <= max;
}

/**
 * @param {*} o
 * @return {Object}
 */
function ToDictionary(o) {
  if (o === undefined) return {};
  if (o === Object(o)) return o;
  throw TypeError('Could not convert argument to dictionary');
}

/**
 * @param {string} string Input string of UTF-16 code units.
 * @return {!Array.<number>} Code points.
 */
function stringToCodePoints(string) {
  // https://heycam.github.io/webidl/#dfn-obtain-unicode

  // 1. Let S be the DOMString value.
  var s = String(string);

  // 2. Let n be the length of S.
  var n = s.length;

  // 3. Initialize i to 0.
  var i = 0;

  // 4. Initialize U to be an empty sequence of Unicode characters.
  var u = [];

  // 5. While i < n:
  while (i < n) {

    // 1. Let c be the code unit in S at index i.
    var c = s.charCodeAt(i);

    // 2. Depending on the value of c:

    // c < 0xD800 or c > 0xDFFF
    if (c < 0xD800 || c > 0xDFFF) {
      // Append to U the Unicode character with code point c.
      u.push(c);
    }

    // 0xDC00 ≤ c ≤ 0xDFFF
    else if (0xDC00 <= c && c <= 0xDFFF) {
      // Append to U a U+FFFD REPLACEMENT CHARACTER.
      u.push(0xFFFD);
    }

    // 0xD800 ≤ c ≤ 0xDBFF
    else if (0xD800 <= c && c <= 0xDBFF) {
      // 1. If i = n−1, then append to U a U+FFFD REPLACEMENT
      // CHARACTER.
      if (i === n - 1) {
        u.push(0xFFFD);
      }
      // 2. Otherwise, i < n−1:
      else {
        // 1. Let d be the code unit in S at index i+1.
        var d = string.charCodeAt(i + 1);

        // 2. If 0xDC00 ≤ d ≤ 0xDFFF, then:
        if (0xDC00 <= d && d <= 0xDFFF) {
          // 1. Let a be c & 0x3FF.
          var a = c & 0x3FF;

          // 2. Let b be d & 0x3FF.
          var b = d & 0x3FF;

          // 3. Append to U the Unicode character with code point
          // 2^16+2^10*a+b.
          u.push(0x10000 + (a << 10) + b);

          // 4. Set i to i+1.
          i += 1;
        }

        // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a
        // U+FFFD REPLACEMENT CHARACTER.
        else  {
          u.push(0xFFFD);
        }
      }
    }

    // 3. Set i to i+1.
    i += 1;
  }

  // 6. Return U.
  return u;
}

/**
 * @param {!Array.<number>} code_points Array of code points.
 * @return {string} string String of UTF-16 code units.
 */
function codePointsToString(code_points) {
  var s = '';
  for (var i = 0; i < code_points.length; ++i) {
    var cp = code_points[i];
    if (cp <= 0xFFFF) {
      s += String.fromCharCode(cp);
    } else {
      cp -= 0x10000;
      s += String.fromCharCode((cp >> 10) + 0xD800,
                               (cp & 0x3FF) + 0xDC00);
    }
  }
  return s;
}


//
// Implementation of Encoding specification
// https://encoding.spec.whatwg.org/
//

//
// 3. Terminology
//

/**
 * End-of-stream is a special token that signifies no more tokens
 * are in the stream.
 * @const
 */ var end_of_stream = -1;

/**
 * A stream represents an ordered sequence of tokens.
 *
 * @constructor
 * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide the
 * stream.
 */
function Stream(tokens) {
  /** @type {!Array.<number>} */
  this.tokens = [].slice.call(tokens);
}

Stream.prototype = {
  /**
   * @return {boolean} True if end-of-stream has been hit.
   */
  endOfStream: function() {
    return !this.tokens.length;
  },

  /**
   * When a token is read from a stream, the first token in the
   * stream must be returned and subsequently removed, and
   * end-of-stream must be returned otherwise.
   *
   * @return {number} Get the next token from the stream, or
   * end_of_stream.
   */
   read: function() {
    if (!this.tokens.length)
      return end_of_stream;
     return this.tokens.shift();
   },

  /**
   * When one or more tokens are prepended to a stream, those tokens
   * must be inserted, in given order, before the first token in the
   * stream.
   *
   * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.
   */
  prepend: function(token) {
    if (Array.isArray(token)) {
      var tokens = /**@type {!Array.<number>}*/(token);
      while (tokens.length)
        this.tokens.unshift(tokens.pop());
    } else {
      this.tokens.unshift(token);
    }
  },

  /**
   * When one or more tokens are pushed to a stream, those tokens
   * must be inserted, in given order, after the last token in the
   * stream.
   *
   * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.
   */
  push: function(token) {
    if (Array.isArray(token)) {
      var tokens = /**@type {!Array.<number>}*/(token);
      while (tokens.length)
        this.tokens.push(tokens.shift());
    } else {
      this.tokens.push(token);
    }
  }
};

//
// 4. Encodings
//

// 4.1 Encoders and decoders

/** @const */
var finished = -1;

/**
 * @param {boolean} fatal If true, decoding errors raise an exception.
 * @param {number=} opt_code_point Override the standard fallback code point.
 * @return {number} The code point to insert on a decoding error.
 */
function decoderError(fatal, opt_code_point) {
  if (fatal)
    throw TypeError('Decoder error');
  return opt_code_point || 0xFFFD;
}

//
// 7. API
//

/** @const */ var DEFAULT_ENCODING = 'utf-8';

// 7.1 Interface TextDecoder

/**
 * @constructor
 * @param {string=} encoding The label of the encoding;
 *     defaults to 'utf-8'.
 * @param {Object=} options
 */
function TextDecoder(encoding, options) {
  if (!(this instanceof TextDecoder)) {
    return new TextDecoder(encoding, options);
  }
  encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
  if (encoding !== DEFAULT_ENCODING) {
    throw new Error('Encoding not supported. Only utf-8 is supported');
  }
  options = ToDictionary(options);

  /** @private @type {boolean} */
  this._streaming = false;
  /** @private @type {boolean} */
  this._BOMseen = false;
  /** @private @type {?Decoder} */
  this._decoder = null;
  /** @private @type {boolean} */
  this._fatal = Boolean(options['fatal']);
  /** @private @type {boolean} */
  this._ignoreBOM = Boolean(options['ignoreBOM']);

  Object.defineProperty(this, 'encoding', {value: 'utf-8'});
  Object.defineProperty(this, 'fatal', {value: this._fatal});
  Object.defineProperty(this, 'ignoreBOM', {value: this._ignoreBOM});
}

TextDecoder.prototype = {
  /**
   * @param {ArrayBufferView=} input The buffer of bytes to decode.
   * @param {Object=} options
   * @return {string} The decoded string.
   */
  decode: function decode(input, options) {
    var bytes;
    if (typeof input === 'object' && input instanceof ArrayBuffer) {
      bytes = new Uint8Array(input);
    } else if (typeof input === 'object' && 'buffer' in input &&
               input.buffer instanceof ArrayBuffer) {
      bytes = new Uint8Array(input.buffer,
                             input.byteOffset,
                             input.byteLength);
    } else {
      bytes = new Uint8Array(0);
    }

    options = ToDictionary(options);

    if (!this._streaming) {
      this._decoder = new UTF8Decoder({fatal: this._fatal});
      this._BOMseen = false;
    }
    this._streaming = Boolean(options['stream']);

    var input_stream = new Stream(bytes);

    var code_points = [];

    /** @type {?(number|!Array.<number>)} */
    var result;

    while (!input_stream.endOfStream()) {
      result = this._decoder.handler(input_stream, input_stream.read());
      if (result === finished)
        break;
      if (result === null)
        continue;
      if (Array.isArray(result))
        code_points.push.apply(code_points, /**@type {!Array.<number>}*/(result));
      else
        code_points.push(result);
    }
    if (!this._streaming) {
      do {
        result = this._decoder.handler(input_stream, input_stream.read());
        if (result === finished)
          break;
        if (result === null)
          continue;
        if (Array.isArray(result))
          code_points.push.apply(code_points, /**@type {!Array.<number>}*/(result));
        else
          code_points.push(result);
      } while (!input_stream.endOfStream());
      this._decoder = null;
    }

    if (code_points.length) {
      // If encoding is one of utf-8, utf-16be, and utf-16le, and
      // ignore BOM flag and BOM seen flag are unset, run these
      // subsubsteps:
      if (['utf-8'].indexOf(this.encoding) !== -1 &&
          !this._ignoreBOM && !this._BOMseen) {
        // If token is U+FEFF, set BOM seen flag.
        if (code_points[0] === 0xFEFF) {
          this._BOMseen = true;
          code_points.shift();
        } else {
          // Otherwise, if token is not end-of-stream, set BOM seen
          // flag and append token to output.
          this._BOMseen = true;
        }
      }
    }

    return codePointsToString(code_points);
  }
};

// 7.2 Interface TextEncoder

/**
 * @constructor
 * @param {string=} encoding The label of the encoding;
 *     defaults to 'utf-8'.
 * @param {Object=} options
 */
function TextEncoder(encoding, options) {
  if (!(this instanceof TextEncoder))
    return new TextEncoder(encoding, options);
  encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
  if (encoding !== DEFAULT_ENCODING) {
    throw new Error('Encoding not supported. Only utf-8 is supported');
  }
  options = ToDictionary(options);

  /** @private @type {boolean} */
  this._streaming = false;
  /** @private @type {?Encoder} */
  this._encoder = null;
  /** @private @type {{fatal: boolean}} */
  this._options = {fatal: Boolean(options['fatal'])};

  Object.defineProperty(this, 'encoding', {value: 'utf-8'});
}

TextEncoder.prototype = {
  /**
   * @param {string=} opt_string The string to encode.
   * @param {Object=} options
   * @return {Uint8Array} Encoded bytes, as a Uint8Array.
   */
  encode: function encode(opt_string, options) {
    opt_string = opt_string ? String(opt_string) : '';
    options = ToDictionary(options);

    // NOTE: This option is nonstandard. None of the encodings
    // permitted for encoding (i.e. UTF-8, UTF-16) are stateful,
    // so streaming is not necessary.
    if (!this._streaming)
      this._encoder = new UTF8Encoder(this._options);
    this._streaming = Boolean(options['stream']);

    var bytes = [];
    var input_stream = new Stream(stringToCodePoints(opt_string));
    /** @type {?(number|!Array.<number>)} */
    var result;
    while (!input_stream.endOfStream()) {
      result = this._encoder.handler(input_stream, input_stream.read());
      if (result === finished)
        break;
      if (Array.isArray(result))
        bytes.push.apply(bytes, /**@type {!Array.<number>}*/(result));
      else
        bytes.push(result);
    }
    if (!this._streaming) {
      while (true) {
        result = this._encoder.handler(input_stream, input_stream.read());
        if (result === finished)
          break;
        if (Array.isArray(result))
          bytes.push.apply(bytes, /**@type {!Array.<number>}*/(result));
        else
          bytes.push(result);
      }
      this._encoder = null;
    }
    return new Uint8Array(bytes);
  }
};

//
// 8. The encoding
//

// 8.1 utf-8

/**
 * @constructor
 * @implements {Decoder}
 * @param {{fatal: boolean}} options
 */
function UTF8Decoder(options) {
  var fatal = options.fatal;

  // utf-8's decoder's has an associated utf-8 code point, utf-8
  // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8
  // lower boundary (initially 0x80), and a utf-8 upper boundary
  // (initially 0xBF).
  var /** @type {number} */ utf8_code_point = 0,
      /** @type {number} */ utf8_bytes_seen = 0,
      /** @type {number} */ utf8_bytes_needed = 0,
      /** @type {number} */ utf8_lower_boundary = 0x80,
      /** @type {number} */ utf8_upper_boundary = 0xBF;

  /**
   * @param {Stream} stream The stream of bytes being decoded.
   * @param {number} bite The next byte read from the stream.
   * @return {?(number|!Array.<number>)} The next code point(s)
   *     decoded, or null if not enough data exists in the input
   *     stream to decode a complete code point.
   */
  this.handler = function(stream, bite) {
    // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,
    // set utf-8 bytes needed to 0 and return error.
    if (bite === end_of_stream && utf8_bytes_needed !== 0) {
      utf8_bytes_needed = 0;
      return decoderError(fatal);
    }

    // 2. If byte is end-of-stream, return finished.
    if (bite === end_of_stream)
      return finished;

    // 3. If utf-8 bytes needed is 0, based on byte:
    if (utf8_bytes_needed === 0) {

      // 0x00 to 0x7F
      if (inRange(bite, 0x00, 0x7F)) {
        // Return a code point whose value is byte.
        return bite;
      }

      // 0xC2 to 0xDF
      if (inRange(bite, 0xC2, 0xDF)) {
        // Set utf-8 bytes needed to 1 and utf-8 code point to byte
        // − 0xC0.
        utf8_bytes_needed = 1;
        utf8_code_point = bite - 0xC0;
      }

      // 0xE0 to 0xEF
      else if (inRange(bite, 0xE0, 0xEF)) {
        // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.
        if (bite === 0xE0)
          utf8_lower_boundary = 0xA0;
        // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.
        if (bite === 0xED)
          utf8_upper_boundary = 0x9F;
        // 3. Set utf-8 bytes needed to 2 and utf-8 code point to
        // byte − 0xE0.
        utf8_bytes_needed = 2;
        utf8_code_point = bite - 0xE0;
      }

      // 0xF0 to 0xF4
      else if (inRange(bite, 0xF0, 0xF4)) {
        // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.
        if (bite === 0xF0)
          utf8_lower_boundary = 0x90;
        // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.
        if (bite === 0xF4)
          utf8_upper_boundary = 0x8F;
        // 3. Set utf-8 bytes needed to 3 and utf-8 code point to
        // byte − 0xF0.
        utf8_bytes_needed = 3;
        utf8_code_point = bite - 0xF0;
      }

      // Otherwise
      else {
        // Return error.
        return decoderError(fatal);
      }

      // Then (byte is in the range 0xC2 to 0xF4) set utf-8 code
      // point to utf-8 code point << (6 × utf-8 bytes needed) and
      // return continue.
      utf8_code_point = utf8_code_point << (6 * utf8_bytes_needed);
      return null;
    }

    // 4. If byte is not in the range utf-8 lower boundary to utf-8
    // upper boundary, run these substeps:
    if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {

      // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8
      // bytes seen to 0, set utf-8 lower boundary to 0x80, and set
      // utf-8 upper boundary to 0xBF.
      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
      utf8_lower_boundary = 0x80;
      utf8_upper_boundary = 0xBF;

      // 2. Prepend byte to stream.
      stream.prepend(bite);

      // 3. Return error.
      return decoderError(fatal);
    }

    // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary
    // to 0xBF.
    utf8_lower_boundary = 0x80;
    utf8_upper_boundary = 0xBF;

    // 6. Increase utf-8 bytes seen by one and set utf-8 code point
    // to utf-8 code point + (byte − 0x80) << (6 × (utf-8 bytes
    // needed − utf-8 bytes seen)).
    utf8_bytes_seen += 1;
    utf8_code_point += (bite - 0x80) << (6 * (utf8_bytes_needed - utf8_bytes_seen));

    // 7. If utf-8 bytes seen is not equal to utf-8 bytes needed,
    // continue.
    if (utf8_bytes_seen !== utf8_bytes_needed)
      return null;

    // 8. Let code point be utf-8 code point.
    var code_point = utf8_code_point;

    // 9. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes
    // seen to 0.
    utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;

    // 10. Return a code point whose value is code point.
    return code_point;
  };
}

/**
 * @constructor
 * @implements {Encoder}
 * @param {{fatal: boolean}} options
 */
function UTF8Encoder(options) {
  var fatal = options.fatal;
  /**
   * @param {Stream} stream Input stream.
   * @param {number} code_point Next code point read from the stream.
   * @return {(number|!Array.<number>)} Byte(s) to emit.
   */
  this.handler = function(stream, code_point) {
    // 1. If code point is end-of-stream, return finished.
    if (code_point === end_of_stream)
      return finished;

    // 2. If code point is in the range U+0000 to U+007F, return a
    // byte whose value is code point.
    if (inRange(code_point, 0x0000, 0x007f))
      return code_point;

    // 3. Set count and offset based on the range code point is in:
    var count, offset;
    // U+0080 to U+07FF:    1 and 0xC0
    if (inRange(code_point, 0x0080, 0x07FF)) {
      count = 1;
      offset = 0xC0;
    }
    // U+0800 to U+FFFF:    2 and 0xE0
    else if (inRange(code_point, 0x0800, 0xFFFF)) {
      count = 2;
      offset = 0xE0;
    }
    // U+10000 to U+10FFFF: 3 and 0xF0
    else if (inRange(code_point, 0x10000, 0x10FFFF)) {
      count = 3;
      offset = 0xF0;
    }

    // 4.Let bytes be a byte sequence whose first byte is (code
    // point >> (6 × count)) + offset.
    var bytes = [(code_point >> (6 * count)) + offset];

    // 5. Run these substeps while count is greater than 0:
    while (count > 0) {

      // 1. Set temp to code point >> (6 × (count − 1)).
      var temp = code_point >> (6 * (count - 1));

      // 2. Append to bytes 0x80 | (temp & 0x3F).
      bytes.push(0x80 | (temp & 0x3F));

      // 3. Decrease count by one.
      count -= 1;
    }

    // 6. Return bytes bytes, in order.
    return bytes;
  };
}

exports.TextEncoder = TextEncoder;
exports.TextDecoder = TextDecoder;

/***/ }),

/***/ 92104:
/***/ ((module) => {

module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}


/***/ }),

/***/ 70936:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Buffer = (__webpack_require__(7661).Buffer)

module.exports = function (buf) {
	// If the buffer is backed by a Uint8Array, a faster version will work
	if (buf instanceof Uint8Array) {
		// If the buffer isn't a subarray, return the underlying ArrayBuffer
		if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
			return buf.buffer
		} else if (typeof buf.buffer.slice === 'function') {
			// Otherwise we need to get a proper copy
			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)
		}
	}

	if (Buffer.isBuffer(buf)) {
		// This is the slow version that will work with any Buffer
		// implementation (even in old browsers)
		var arrayCopy = new Uint8Array(buf.length)
		var len = buf.length
		for (var i = 0; i < len; i++) {
			arrayCopy[i] = buf[i]
		}
		return arrayCopy.buffer
	} else {
		throw new Error('Argument must be a Buffer')
	}
}


/***/ }),

/***/ 51706:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
});
__webpack_unused_export__ = undefined;
exports.Qc = parse;
__webpack_unused_export__ = toCodePoints;

var _regex = __webpack_require__(64349);

var _regex2 = _interopRequireDefault(_regex);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TypeName = __webpack_unused_export__ = 'emoji';
// Copyright Twitter Inc. Licensed under MIT
// https://github.com/twitter/twemoji-parser/blob/master/LICENSE.md
function parse(text, options) {
  var assetType = options && options.assetType ? options.assetType : 'svg';
  var getTwemojiUrl = options && options.buildUrl ? options.buildUrl : function (codepoints, assetType) {
    return assetType === 'png' ? 'https://twemoji.maxcdn.com/2/72x72/' + codepoints + '.png' : 'https://twemoji.maxcdn.com/2/svg/' + codepoints + '.svg';
  };

  var entities = [];

  _regex2.default.lastIndex = 0;
  while (true) {
    var result = _regex2.default.exec(text);
    if (!result) {
      break;
    }

    var emojiText = result[0];
    var codepoints = toCodePoints(removeVS16s(emojiText)).join('-');

    entities.push({
      url: codepoints ? getTwemojiUrl(codepoints, assetType) : '',
      indices: [result.index, _regex2.default.lastIndex],
      text: emojiText,
      type: TypeName
    });
  }
  return entities;
}

var vs16RegExp = /\uFE0F/g;
// avoid using a string literal like '\u200D' here because minifiers expand it inline
var zeroWidthJoiner = String.fromCharCode(0x200d);

var removeVS16s = function removeVS16s(rawEmoji) {
  return rawEmoji.indexOf(zeroWidthJoiner) < 0 ? rawEmoji.replace(vs16RegExp, '') : rawEmoji;
};

function toCodePoints(unicodeSurrogates) {
  var points = [];
  var char = 0;
  var previous = 0;
  var i = 0;
  while (i < unicodeSurrogates.length) {
    char = unicodeSurrogates.charCodeAt(i++);
    if (previous) {
      points.push((0x10000 + (previous - 0xd800 << 10) + (char - 0xdc00)).toString(16));
      previous = 0;
    } else if (char > 0xd800 && char <= 0xdbff) {
      previous = char;
    } else {
      points.push(char.toString(16));
    }
  }
  return points;
}

/***/ }),

/***/ 64349:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
// Copyright Twitter Inc. Licensed under MIT
// https://github.com/twitter/twemoji-parser/blob/master/LICENSE.md

// This file is auto-generated
exports["default"] = /(?:\ud83d[\udc68\udc69])(?:\ud83c[\udffb-\udfff])?\u200d(?:\u2695\ufe0f|\u2696\ufe0f|\u2708\ufe0f|\ud83c[\udf3e\udf73\udf93\udfa4\udfa8\udfeb\udfed]|\ud83d[\udcbb\udcbc\udd27\udd2c\ude80\ude92]|\ud83e[\uddb0-\uddb3])|(?:\ud83c[\udfcb\udfcc]|\ud83d[\udd74\udd75]|\u26f9)((?:\ud83c[\udffb-\udfff]|\ufe0f)\u200d[\u2640\u2642]\ufe0f)|(?:\ud83c[\udfc3\udfc4\udfca]|\ud83d[\udc6e\udc71\udc73\udc77\udc81\udc82\udc86\udc87\ude45-\ude47\ude4b\ude4d\ude4e\udea3\udeb4-\udeb6]|\ud83e[\udd26\udd35\udd37-\udd39\udd3d\udd3e\uddb8\uddb9\uddd6-\udddd])(?:\ud83c[\udffb-\udfff])?\u200d[\u2640\u2642]\ufe0f|(?:\ud83d\udc68\u200d\u2764\ufe0f\u200d\ud83d\udc8b\u200d\ud83d\udc68|\ud83d\udc68\u200d\ud83d\udc68\u200d\ud83d\udc66\u200d\ud83d\udc66|\ud83d\udc68\u200d\ud83d\udc68\u200d\ud83d\udc67\u200d\ud83d[\udc66\udc67]|\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc66\u200d\ud83d\udc66|\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d[\udc66\udc67]|\ud83d\udc69\u200d\u2764\ufe0f\u200d\ud83d\udc8b\u200d\ud83d[\udc68\udc69]|\ud83d\udc69\u200d\ud83d\udc69\u200d\ud83d\udc66\u200d\ud83d\udc66|\ud83d\udc69\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d[\udc66\udc67]|\ud83d\udc68\u200d\u2764\ufe0f\u200d\ud83d\udc68|\ud83d\udc68\u200d\ud83d\udc66\u200d\ud83d\udc66|\ud83d\udc68\u200d\ud83d\udc67\u200d\ud83d[\udc66\udc67]|\ud83d\udc68\u200d\ud83d\udc68\u200d\ud83d[\udc66\udc67]|\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d[\udc66\udc67]|\ud83d\udc69\u200d\u2764\ufe0f\u200d\ud83d[\udc68\udc69]|\ud83d\udc69\u200d\ud83d\udc66\u200d\ud83d\udc66|\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d[\udc66\udc67]|\ud83d\udc69\u200d\ud83d\udc69\u200d\ud83d[\udc66\udc67]|\ud83c\udff3\ufe0f\u200d\ud83c\udf08|\ud83c\udff4\u200d\u2620\ufe0f|\ud83d\udc41\u200d\ud83d\udde8|\ud83d\udc68\u200d\ud83d[\udc66\udc67]|\ud83d\udc69\u200d\ud83d[\udc66\udc67]|\ud83d\udc6f\u200d\u2640\ufe0f|\ud83d\udc6f\u200d\u2642\ufe0f|\ud83e\udd3c\u200d\u2640\ufe0f|\ud83e\udd3c\u200d\u2642\ufe0f|\ud83e\uddde\u200d\u2640\ufe0f|\ud83e\uddde\u200d\u2642\ufe0f|\ud83e\udddf\u200d\u2640\ufe0f|\ud83e\udddf\u200d\u2642\ufe0f)|[#*0-9]\ufe0f?\u20e3|(?:[©®\u2122\u265f]\ufe0f)|(?:\ud83c[\udc04\udd70\udd71\udd7e\udd7f\ude02\ude1a\ude2f\ude37\udf21\udf24-\udf2c\udf36\udf7d\udf96\udf97\udf99-\udf9b\udf9e\udf9f\udfcd\udfce\udfd4-\udfdf\udff3\udff5\udff7]|\ud83d[\udc3f\udc41\udcfd\udd49\udd4a\udd6f\udd70\udd73\udd76-\udd79\udd87\udd8a-\udd8d\udda5\udda8\uddb1\uddb2\uddbc\uddc2-\uddc4\uddd1-\uddd3\udddc-\uddde\udde1\udde3\udde8\uddef\uddf3\uddfa\udecb\udecd-\udecf\udee0-\udee5\udee9\udef0\udef3]|[\u203c\u2049\u2139\u2194-\u2199\u21a9\u21aa\u231a\u231b\u2328\u23cf\u23ed-\u23ef\u23f1\u23f2\u23f8-\u23fa\u24c2\u25aa\u25ab\u25b6\u25c0\u25fb-\u25fe\u2600-\u2604\u260e\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262a\u262e\u262f\u2638-\u263a\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267b\u267f\u2692-\u2697\u2699\u269b\u269c\u26a0\u26a1\u26aa\u26ab\u26b0\u26b1\u26bd\u26be\u26c4\u26c5\u26c8\u26cf\u26d1\u26d3\u26d4\u26e9\u26ea\u26f0-\u26f5\u26f8\u26fa\u26fd\u2702\u2708\u2709\u270f\u2712\u2714\u2716\u271d\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u2764\u27a1\u2934\u2935\u2b05-\u2b07\u2b1b\u2b1c\u2b50\u2b55\u3030\u303d\u3297\u3299])(?:\ufe0f|(?!\ufe0e))|(?:(?:\ud83c[\udfcb\udfcc]|\ud83d[\udd74\udd75\udd90]|[\u261d\u26f7\u26f9\u270c\u270d])(?:\ufe0f|(?!\ufe0e))|(?:\ud83c[\udf85\udfc2-\udfc4\udfc7\udfca]|\ud83d[\udc42\udc43\udc46-\udc50\udc66-\udc69\udc6e\udc70-\udc78\udc7c\udc81-\udc83\udc85-\udc87\udcaa\udd7a\udd95\udd96\ude45-\ude47\ude4b-\ude4f\udea3\udeb4-\udeb6\udec0\udecc]|\ud83e[\udd18-\udd1c\udd1e\udd1f\udd26\udd30-\udd39\udd3d\udd3e\uddb5\uddb6\uddb8\uddb9\uddd1-\udddd]|[\u270a\u270b]))(?:\ud83c[\udffb-\udfff])?|(?:\ud83c\udff4\udb40\udc67\udb40\udc62\udb40\udc65\udb40\udc6e\udb40\udc67\udb40\udc7f|\ud83c\udff4\udb40\udc67\udb40\udc62\udb40\udc73\udb40\udc63\udb40\udc74\udb40\udc7f|\ud83c\udff4\udb40\udc67\udb40\udc62\udb40\udc77\udb40\udc6c\udb40\udc73\udb40\udc7f|\ud83c\udde6\ud83c[\udde8-\uddec\uddee\uddf1\uddf2\uddf4\uddf6-\uddfa\uddfc\uddfd\uddff]|\ud83c\udde7\ud83c[\udde6\udde7\udde9-\uddef\uddf1-\uddf4\uddf6-\uddf9\uddfb\uddfc\uddfe\uddff]|\ud83c\udde8\ud83c[\udde6\udde8\udde9\uddeb-\uddee\uddf0-\uddf5\uddf7\uddfa-\uddff]|\ud83c\udde9\ud83c[\uddea\uddec\uddef\uddf0\uddf2\uddf4\uddff]|\ud83c\uddea\ud83c[\udde6\udde8\uddea\uddec\udded\uddf7-\uddfa]|\ud83c\uddeb\ud83c[\uddee-\uddf0\uddf2\uddf4\uddf7]|\ud83c\uddec\ud83c[\udde6\udde7\udde9-\uddee\uddf1-\uddf3\uddf5-\uddfa\uddfc\uddfe]|\ud83c\udded\ud83c[\uddf0\uddf2\uddf3\uddf7\uddf9\uddfa]|\ud83c\uddee\ud83c[\udde8-\uddea\uddf1-\uddf4\uddf6-\uddf9]|\ud83c\uddef\ud83c[\uddea\uddf2\uddf4\uddf5]|\ud83c\uddf0\ud83c[\uddea\uddec-\uddee\uddf2\uddf3\uddf5\uddf7\uddfc\uddfe\uddff]|\ud83c\uddf1\ud83c[\udde6-\udde8\uddee\uddf0\uddf7-\uddfb\uddfe]|\ud83c\uddf2\ud83c[\udde6\udde8-\udded\uddf0-\uddff]|\ud83c\uddf3\ud83c[\udde6\udde8\uddea-\uddec\uddee\uddf1\uddf4\uddf5\uddf7\uddfa\uddff]|\ud83c\uddf4\ud83c\uddf2|\ud83c\uddf5\ud83c[\udde6\uddea-\udded\uddf0-\uddf3\uddf7-\uddf9\uddfc\uddfe]|\ud83c\uddf6\ud83c\udde6|\ud83c\uddf7\ud83c[\uddea\uddf4\uddf8\uddfa\uddfc]|\ud83c\uddf8\ud83c[\udde6-\uddea\uddec-\uddf4\uddf7-\uddf9\uddfb\uddfd-\uddff]|\ud83c\uddf9\ud83c[\udde6\udde8\udde9\uddeb-\udded\uddef-\uddf4\uddf7\uddf9\uddfb\uddfc\uddff]|\ud83c\uddfa\ud83c[\udde6\uddec\uddf2\uddf3\uddf8\uddfe\uddff]|\ud83c\uddfb\ud83c[\udde6\udde8\uddea\uddec\uddee\uddf3\uddfa]|\ud83c\uddfc\ud83c[\uddeb\uddf8]|\ud83c\uddfd\ud83c\uddf0|\ud83c\uddfe\ud83c[\uddea\uddf9]|\ud83c\uddff\ud83c[\udde6\uddf2\uddfc]|\ud83c[\udccf\udd8e\udd91-\udd9a\udde6-\uddff\ude01\ude32-\ude36\ude38-\ude3a\ude50\ude51\udf00-\udf20\udf2d-\udf35\udf37-\udf7c\udf7e-\udf84\udf86-\udf93\udfa0-\udfc1\udfc5\udfc6\udfc8\udfc9\udfcf-\udfd3\udfe0-\udff0\udff4\udff8-\udfff]|\ud83d[\udc00-\udc3e\udc40\udc44\udc45\udc51-\udc65\udc6a-\udc6d\udc6f\udc79-\udc7b\udc7d-\udc80\udc84\udc88-\udca9\udcab-\udcfc\udcff-\udd3d\udd4b-\udd4e\udd50-\udd67\udda4\uddfb-\ude44\ude48-\ude4a\ude80-\udea2\udea4-\udeb3\udeb7-\udebf\udec1-\udec5\uded0-\uded2\udeeb\udeec\udef4-\udef9]|\ud83e[\udd10-\udd17\udd1d\udd20-\udd25\udd27-\udd2f\udd3a\udd3c\udd40-\udd45\udd47-\udd70\udd73-\udd76\udd7a\udd7c-\udda2\uddb4\uddb7\uddc0-\uddc2\uddd0\uddde-\uddff]|[\u23e9-\u23ec\u23f0\u23f3\u267e\u26ce\u2705\u2728\u274c\u274e\u2753-\u2755\u2795-\u2797\u27b0\u27bf\ue50a])|\ufe0f/g;

/***/ }),

/***/ 54958:
/***/ ((__unused_webpack_module, exports) => {

/*! https://mths.be/utf8js v3.0.0 by @mathias */
;(function(root) {

	var stringFromCharCode = String.fromCharCode;

	// Taken from https://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from https://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	function checkScalarValue(codePoint) {
		if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
			throw Error(
				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
				' is not a scalar value'
			);
		}
	}
	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			checkScalarValue(codePoint);
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string) {
		var codePoints = ucs2decode(string);
		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, it’s not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				checkScalarValue(codePoint);
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString) {
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	root.version = '3.0.0';
	root.encode = utf8encode;
	root.decode = utf8decode;

}( false ? 0 : exports));


/***/ }),

/***/ 31118:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!__webpack_require__.g.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = __webpack_require__.g.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}


/***/ }),

/***/ 81665:
/***/ ((module) => {

module.exports = read

var MSB = 0x80
  , REST = 0x7F

function read(buf, offset) {
  var res    = 0
    , offset = offset || 0
    , shift  = 0
    , counter = offset
    , b
    , l = buf.length

  do {
    if (counter >= l) {
      read.bytes = 0
      throw new RangeError('Could not decode varint')
    }
    b = buf[counter++]
    res += shift < 28
      ? (b & REST) << shift
      : (b & REST) * Math.pow(2, shift)
    shift += 7
  } while (b >= MSB)

  read.bytes = counter - offset

  return res
}


/***/ }),

/***/ 76161:
/***/ ((module) => {

module.exports = encode

var MSB = 0x80
  , REST = 0x7F
  , MSBALL = ~REST
  , INT = Math.pow(2, 31)

function encode(num, out, offset) {
  out = out || []
  offset = offset || 0
  var oldOffset = offset

  while(num >= INT) {
    out[offset++] = (num & 0xFF) | MSB
    num /= 128
  }
  while(num & MSBALL) {
    out[offset++] = (num & 0xFF) | MSB
    num >>>= 7
  }
  out[offset] = num | 0
  
  encode.bytes = offset - oldOffset + 1
  
  return out
}


/***/ }),

/***/ 8612:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
    encode: __webpack_require__(76161)
  , decode: __webpack_require__(81665)
  , encodingLength: __webpack_require__(49706)
}


/***/ }),

/***/ 49706:
/***/ ((module) => {


var N1 = Math.pow(2,  7)
var N2 = Math.pow(2, 14)
var N3 = Math.pow(2, 21)
var N4 = Math.pow(2, 28)
var N5 = Math.pow(2, 35)
var N6 = Math.pow(2, 42)
var N7 = Math.pow(2, 49)
var N8 = Math.pow(2, 56)
var N9 = Math.pow(2, 63)

module.exports = function (value) {
  return (
    value < N1 ? 1
  : value < N2 ? 2
  : value < N3 ? 3
  : value < N4 ? 4
  : value < N5 ? 5
  : value < N6 ? 6
  : value < N7 ? 7
  : value < N8 ? 8
  : value < N9 ? 9
  :              10
  )
}


/***/ }),

/***/ 78484:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*
 This file is part of web3.js.

 web3.js is free software: you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 web3.js is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public License
 along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
 */
/**
 * @file index.js
 * @author Fabian Vogelsteller <fabian@ethereum.org>
 * @date 2016
 */

var EventEmitter = __webpack_require__(7687);
/**
 * This function generates a defer promise and adds eventEmitter functionality to it
 *
 * @method eventifiedPromise
 */
var PromiEvent = function PromiEvent(justPromise) {
    var resolve, reject, eventEmitter = new Promise(function () {
        resolve = arguments[0];
        reject = arguments[1];
    });
    if (justPromise) {
        return {
            resolve: resolve,
            reject: reject,
            eventEmitter: eventEmitter
        };
    }
    // get eventEmitter
    var emitter = new EventEmitter();
    // add eventEmitter to the promise
    eventEmitter._events = emitter._events;
    eventEmitter.emit = emitter.emit;
    eventEmitter.on = emitter.on;
    eventEmitter.once = emitter.once;
    eventEmitter.off = emitter.off;
    eventEmitter.listeners = emitter.listeners;
    eventEmitter.addListener = emitter.addListener;
    eventEmitter.removeListener = emitter.removeListener;
    eventEmitter.removeAllListeners = emitter.removeAllListeners;
    return {
        resolve: resolve,
        reject: reject,
        eventEmitter: eventEmitter
    };
};
PromiEvent.resolve = function (value) {
    var promise = PromiEvent(true);
    promise.resolve(value);
    return promise.eventEmitter;
};
module.exports = PromiEvent;


/***/ }),

/***/ 95194:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file batch.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var Jsonrpc = __webpack_require__(52596);
var errors = (__webpack_require__(59849).errors);
var Batch = function (requestManager) {
    this.requestManager = requestManager;
    this.requests = [];
};
/**
 * Should be called to add create new request to batch request
 *
 * @method add
 * @param {Object} jsonrpc requet object
 */
Batch.prototype.add = function (request) {
    this.requests.push(request);
};
/**
 * Should be called to execute batch request
 *
 * @method execute
 */
Batch.prototype.execute = function () {
    var requests = this.requests;
    var sortResponses = this._sortResponses.bind(this);
    this.requestManager.sendBatch(requests, function (err, results) {
        results = sortResponses(results);
        requests.map(function (request, index) {
            return results[index] || {};
        }).forEach(function (result, index) {
            if (requests[index].callback) {
                if (result && result.error) {
                    return requests[index].callback(errors.ErrorResponse(result));
                }
                if (!Jsonrpc.isValidResponse(result)) {
                    return requests[index].callback(errors.InvalidResponse(result));
                }
                try {
                    requests[index].callback(null, requests[index].format ? requests[index].format(result.result) : result.result);
                }
                catch (err) {
                    requests[index].callback(err);
                }
            }
        });
    });
};
// Sort responses
Batch.prototype._sortResponses = function (responses) {
    return (responses || []).sort((a, b) => a.id - b.id);
};
module.exports = Batch;


/***/ }),

/***/ 19025:
/***/ ((module) => {

"use strict";
/*
 This file is part of web3.js.

 web3.js is free software: you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 web3.js is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public License
 along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
 */
/**
 * @file givenProvider.js
 * @author Fabian Vogelsteller <fabian@ethereum.org>
 * @date 2017
 */

var givenProvider = null;
// ADD GIVEN PROVIDER
/* jshint ignore:start */
var global = typeof globalThis === 'object' ? globalThis : undefined;
if (!global) {
    try {
        global = Function('return this')();
    }
    catch (e) {
        global = self;
    }
}
// EIP-1193: window.ethereum
if (typeof global.ethereum !== 'undefined') {
    givenProvider = global.ethereum;
    // Legacy web3.currentProvider
}
else if (typeof global.web3 !== 'undefined' && global.web3.currentProvider) {
    if (global.web3.currentProvider.sendAsync) {
        global.web3.currentProvider.send = global.web3.currentProvider.sendAsync;
        delete global.web3.currentProvider.sendAsync;
    }
    // if connection is 'ipcProviderWrapper', add subscription support
    if (!global.web3.currentProvider.on &&
        global.web3.currentProvider.connection &&
        global.web3.currentProvider.connection.constructor.name === 'ipcProviderWrapper') {
        global.web3.currentProvider.on = function (type, callback) {
            if (typeof callback !== 'function')
                throw new Error('The second parameter callback must be a function.');
            switch (type) {
                case 'data':
                    this.connection.on('data', function (data) {
                        var result = '';
                        data = data.toString();
                        try {
                            result = JSON.parse(data);
                        }
                        catch (e) {
                            return callback(new Error('Couldn\'t parse response data' + data));
                        }
                        // notification
                        if (!result.id && result.method.indexOf('_subscription') !== -1) {
                            callback(null, result);
                        }
                    });
                    break;
                default:
                    this.connection.on(type, callback);
                    break;
            }
        };
    }
    givenProvider = global.web3.currentProvider;
}
/* jshint ignore:end */
module.exports = givenProvider;


/***/ }),

/***/ 77304:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*
    This file is part of web3.js.
    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.
    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file index.js
 * @author Fabian Vogelsteller <fabian@ethereum.org>
 * @date 2017
 */

const { callbackify } = __webpack_require__(10654);
var errors = (__webpack_require__(59849).errors);
var Jsonrpc = __webpack_require__(52596);
var BatchManager = __webpack_require__(95194);
var givenProvider = __webpack_require__(19025);
/**
 * It's responsible for passing messages to providers
 * It's also responsible for polling the ethereum node for incoming messages
 * Default poll timeout is 1 second
 * Singleton
 *
 * @param {string|Object}provider
 * @param {Net.Socket} net
 *
 * @constructor
 */
var RequestManager = function RequestManager(provider, net) {
    this.provider = null;
    this.providers = RequestManager.providers;
    this.setProvider(provider, net);
    this.subscriptions = new Map();
};
RequestManager.givenProvider = givenProvider;
RequestManager.providers = {
    WebsocketProvider: __webpack_require__(72937),
    HttpProvider: __webpack_require__(69685),
    IpcProvider: __webpack_require__(56606)
};
/**
 * Should be used to set provider of request manager
 *
 * @method setProvider
 *
 * @param {Object} provider
 * @param {net.Socket} net
 *
 * @returns void
 */
RequestManager.prototype.setProvider = function (provider, net) {
    var _this = this;
    // autodetect provider
    if (provider && typeof provider === 'string' && this.providers) {
        // HTTP
        if (/^http(s)?:\/\//i.test(provider)) {
            provider = new this.providers.HttpProvider(provider);
            // WS
        }
        else if (/^ws(s)?:\/\//i.test(provider)) {
            provider = new this.providers.WebsocketProvider(provider);
            // IPC
        }
        else if (provider && typeof net === 'object' && typeof net.connect === 'function') {
            provider = new this.providers.IpcProvider(provider, net);
        }
        else if (provider) {
            throw new Error('Can\'t autodetect provider for "' + provider + '"');
        }
    }
    // reset the old one before changing, if still connected
    if (this.provider && this.provider.connected)
        this.clearSubscriptions();
    this.provider = provider || null;
    // listen to incoming notifications
    if (this.provider && this.provider.on) {
        if (typeof provider.request === 'function') { // EIP-1193 provider
            this.provider.on('message', function (payload) {
                if (payload && payload.type === 'eth_subscription' && payload.data) {
                    const data = payload.data;
                    if (data.subscription && _this.subscriptions.has(data.subscription)) {
                        _this.subscriptions.get(data.subscription).callback(null, data.result);
                    }
                }
            });
        }
        else { // legacy provider subscription event
            this.provider.on('data', function data(result, deprecatedResult) {
                result = result || deprecatedResult; // this is for possible old providers, which may had the error first handler
                // if result is a subscription, call callback for that subscription
                if (result.method && result.params && result.params.subscription && _this.subscriptions.has(result.params.subscription)) {
                    _this.subscriptions.get(result.params.subscription).callback(null, result.params.result);
                }
            });
        }
        // resubscribe if the provider has reconnected
        this.provider.on('connect', function connect() {
            _this.subscriptions.forEach(function (subscription) {
                subscription.subscription.resubscribe();
            });
        });
        // notify all subscriptions about the error condition
        this.provider.on('error', function error(error) {
            _this.subscriptions.forEach(function (subscription) {
                subscription.callback(error);
            });
        });
        // notify all subscriptions about bad close conditions
        const disconnect = function disconnect(event) {
            if (!_this._isCleanCloseEvent(event) || _this._isIpcCloseError(event)) {
                _this.subscriptions.forEach(function (subscription) {
                    subscription.callback(errors.ConnectionCloseError(event));
                    _this.subscriptions.delete(subscription.subscription.id);
                });
                if (_this.provider && _this.provider.emit) {
                    _this.provider.emit('error', errors.ConnectionCloseError(event));
                }
            }
            if (_this.provider && _this.provider.emit) {
                _this.provider.emit('end', event);
            }
        };
        this.provider.on('disconnect', disconnect);
        // TODO add end, timeout??
    }
};
/**
 * Asynchronously send request to provider.
 * Prefers to use the `request` method available on the provider as specified in [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193).
 * If `request` is not available, falls back to `sendAsync` and `send` respectively.
 * @method send
 * @param {Object} data
 * @param {Function} callback
 */
RequestManager.prototype.send = function (data, callback) {
    callback = callback || function () { };
    if (!this.provider) {
        return callback(errors.InvalidProvider());
    }
    const { method, params } = data;
    const jsonrpcPayload = Jsonrpc.toPayload(method, params);
    const jsonrpcResultCallback = this._jsonrpcResultCallback(callback, jsonrpcPayload);
    if (this.provider.request) {
        const callbackRequest = callbackify(this.provider.request.bind(this.provider));
        const requestArgs = { method, params };
        callbackRequest(requestArgs, callback);
    }
    else if (this.provider.sendAsync) {
        this.provider.sendAsync(jsonrpcPayload, jsonrpcResultCallback);
    }
    else if (this.provider.send) {
        this.provider.send(jsonrpcPayload, jsonrpcResultCallback);
    }
    else {
        throw new Error('Provider does not have a request or send method to use.');
    }
};
/**
 * Asynchronously send batch request.
 * Only works if provider supports batch methods through `sendAsync` or `send`.
 * @method sendBatch
 * @param {Array} data - array of payload objects
 * @param {Function} callback
 */
RequestManager.prototype.sendBatch = function (data, callback) {
    if (!this.provider) {
        return callback(errors.InvalidProvider());
    }
    var payload = Jsonrpc.toBatchPayload(data);
    this.provider[this.provider.sendAsync ? 'sendAsync' : 'send'](payload, function (err, results) {
        if (err) {
            return callback(err);
        }
        if (!Array.isArray(results)) {
            return callback(errors.InvalidResponse(results));
        }
        callback(null, results);
    });
};
/**
 * Waits for notifications
 *
 * @method addSubscription
 * @param {Subscription} subscription         the subscription
 * @param {String} type         the subscription namespace (eth, personal, etc)
 * @param {Function} callback   the callback to call for incoming notifications
 */
RequestManager.prototype.addSubscription = function (subscription, callback) {
    if (this.provider.on) {
        this.subscriptions.set(subscription.id, {
            callback: callback,
            subscription: subscription
        });
    }
    else {
        throw new Error('The provider doesn\'t support subscriptions: ' + this.provider.constructor.name);
    }
};
/**
 * Waits for notifications
 *
 * @method removeSubscription
 * @param {String} id           the subscription id
 * @param {Function} callback   fired once the subscription is removed
 */
RequestManager.prototype.removeSubscription = function (id, callback) {
    if (this.subscriptions.has(id)) {
        var type = this.subscriptions.get(id).subscription.options.type;
        // remove subscription first to avoid reentry
        this.subscriptions.delete(id);
        // then, try to actually unsubscribe
        this.send({
            method: type + '_unsubscribe',
            params: [id]
        }, callback);
        return;
    }
    if (typeof callback === 'function') {
        // call the callback if the subscription was already removed
        callback(null);
    }
};
/**
 * Should be called to reset the subscriptions
 *
 * @method reset
 *
 * @returns {boolean}
 */
RequestManager.prototype.clearSubscriptions = function (keepIsSyncing) {
    try {
        var _this = this;
        // uninstall all subscriptions
        if (this.subscriptions.size > 0) {
            this.subscriptions.forEach(function (value, id) {
                if (!keepIsSyncing || value.name !== 'syncing')
                    _this.removeSubscription(id);
            });
        }
        //  reset notification callbacks etc.
        if (this.provider.reset)
            this.provider.reset();
        return true;
    }
    catch (e) {
        throw new Error(`Error while clearing subscriptions: ${e}`);
    }
};
/**
 * Evaluates WS close event
 *
 * @method _isCleanClose
 *
 * @param {CloseEvent | boolean} event WS close event or exception flag
 *
 * @returns {boolean}
 */
RequestManager.prototype._isCleanCloseEvent = function (event) {
    return typeof event === 'object' && ([1000].includes(event.code) || event.wasClean === true);
};
/**
 * Detects Ipc close error. The node.net module emits ('close', isException)
 *
 * @method _isIpcCloseError
 *
 * @param {CloseEvent | boolean} event WS close event or exception flag
 *
 * @returns {boolean}
 */
RequestManager.prototype._isIpcCloseError = function (event) {
    return typeof event === 'boolean' && event;
};
/**
 * The jsonrpc result callback for RequestManager.send
 *
 * @method _jsonrpcResultCallback
 *
 * @param {Function} callback the callback to use
 * @param {Object} payload the jsonrpc payload
 *
 * @returns {Function} return callback of form (err, result)
 *
 */
RequestManager.prototype._jsonrpcResultCallback = function (callback, payload) {
    return function (err, result) {
        if (result && result.id && payload.id !== result.id) {
            return callback(new Error(`Wrong response id ${result.id} (expected: ${payload.id}) in ${JSON.stringify(payload)}`));
        }
        if (err) {
            return callback(err);
        }
        if (result && result.error) {
            return callback(errors.ErrorResponse(result));
        }
        if (!Jsonrpc.isValidResponse(result)) {
            return callback(errors.InvalidResponse(result));
        }
        callback(null, result.result);
    };
};
module.exports = {
    Manager: RequestManager,
    BatchManager: BatchManager
};


/***/ }),

/***/ 52596:
/***/ ((module) => {

"use strict";
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file jsonrpc.js
 * @authors:
 *   Fabian Vogelsteller <fabian@ethereum.org>
 *   Marek Kotewicz <marek@ethdev.com>
 *   Aaron Kumavis <aaron@kumavis.me>
 * @date 2015
 */

// Initialize Jsonrpc as a simple object with utility functions.
var Jsonrpc = {
    // This is the starting counter for the Jsonrpc.id.
    // Pick a random number between 0 and the maximum safe integer
    messageId: Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)
};
/**
 * Should be called to valid json create payload object
 *
 * @method toPayload
 * @param {Function} method of jsonrpc call, required
 * @param {Array} params, an array of method params, optional
 * @returns {Object} valid jsonrpc payload object
 */
Jsonrpc.toPayload = function (method, params) {
    if (!method) {
        throw new Error('JSONRPC method should be specified for params: "' + JSON.stringify(params) + '"!');
    }
    if (Jsonrpc.messageId === Number.MAX_SAFE_INTEGER) {
        // if the maximum safe integer has been reached, restart from a random number
        Jsonrpc.messageId = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
    }
    else {
        // advance message ID
        Jsonrpc.messageId++;
    }
    return {
        jsonrpc: '2.0',
        id: Jsonrpc.messageId,
        method: method,
        params: params || []
    };
};
/**
 * Should be called to check if jsonrpc response is valid
 *
 * @method isValidResponse
 * @param {Object}
 * @returns {Boolean} true if response is valid, otherwise false
 */
Jsonrpc.isValidResponse = function (response) {
    return Array.isArray(response) ? response.every(validateSingleMessage) : validateSingleMessage(response);
    function validateSingleMessage(message) {
        return !!message &&
            !message.error &&
            message.jsonrpc === '2.0' &&
            (typeof message.id === 'number' || typeof message.id === 'string') &&
            message.result !== undefined; // only undefined is not valid json object
    }
};
/**
 * Should be called to create batch payload object
 *
 * @method toBatchPayload
 * @param {Array} messages, an array of objects with method (required) and params (optional) fields
 * @returns {Array} batch payload
 */
Jsonrpc.toBatchPayload = function (messages) {
    return messages.map(function (message) {
        return Jsonrpc.toPayload(message.method, message.params);
    });
};
module.exports = Jsonrpc;


/***/ }),

/***/ 58481:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file index.js
 * @author Fabian Vogelsteller <fabian@ethereum.org>
 * @date 2017
 */

var Subscription = __webpack_require__(81457);
var Subscriptions = function Subscriptions(options) {
    this.name = options.name;
    this.type = options.type;
    this.subscriptions = options.subscriptions || {};
    this.requestManager = null;
};
Subscriptions.prototype.setRequestManager = function (rm) {
    this.requestManager = rm;
};
Subscriptions.prototype.attachToObject = function (obj) {
    var func = this.buildCall();
    var name = this.name.split('.');
    if (name.length > 1) {
        obj[name[0]] = obj[name[0]] || {};
        obj[name[0]][name[1]] = func;
    }
    else {
        obj[name[0]] = func;
    }
};
Subscriptions.prototype.buildCall = function () {
    var _this = this;
    return function () {
        if (!_this.subscriptions[arguments[0]]) {
            console.warn('Subscription ' + JSON.stringify(arguments[0]) + ' doesn\'t exist. Subscribing anyway.');
        }
        var subscription = new Subscription({
            subscription: _this.subscriptions[arguments[0]] || {},
            requestManager: _this.requestManager,
            type: _this.type
        });
        return subscription.subscribe.apply(subscription, arguments);
    };
};
module.exports = {
    subscriptions: Subscriptions,
    subscription: Subscription
};


/***/ }),

/***/ 81457:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file subscription.js
 * @author Fabian Vogelsteller <fabian@ethereum.org>
 * @date 2017
 */

var errors = (__webpack_require__(59849).errors);
var EventEmitter = __webpack_require__(7687);
var formatters = (__webpack_require__(59849).formatters);
function identity(value) {
    return value;
}
function Subscription(options) {
    EventEmitter.call(this);
    this.id = null;
    this.callback = identity;
    this.arguments = null;
    this.lastBlock = null; // "from" block tracker for backfilling events on reconnection
    this.options = {
        subscription: options.subscription,
        type: options.type,
        requestManager: options.requestManager
    };
}
// INHERIT
Subscription.prototype = Object.create(EventEmitter.prototype);
Subscription.prototype.constructor = Subscription;
/**
 * Should be used to extract callback from array of arguments. Modifies input param
 *
 * @method extractCallback
 * @param {Array} arguments
 * @return {Function|Null} callback, if exists
 */
Subscription.prototype._extractCallback = function (args) {
    if (typeof args[args.length - 1] === 'function') {
        return args.pop(); // modify the args array!
    }
};
/**
 * Should be called to check if the number of arguments is correct
 *
 * @method validateArgs
 * @param {Array} arguments
 * @throws {Error} if it is not
 */
Subscription.prototype._validateArgs = function (args) {
    var subscription = this.options.subscription;
    if (!subscription)
        subscription = {};
    if (!subscription.params)
        subscription.params = 0;
    if (args.length !== subscription.params) {
        throw errors.InvalidNumberOfParams(args.length, subscription.params, subscription.subscriptionName);
    }
};
/**
 * Should be called to format input args of method
 *
 * @method formatInput
 * @param {Array}
 * @return {Array}
 */
Subscription.prototype._formatInput = function (args) {
    var subscription = this.options.subscription;
    if (!subscription) {
        return args;
    }
    if (!subscription.inputFormatter) {
        return args;
    }
    var formattedArgs = subscription.inputFormatter.map(function (formatter, index) {
        return formatter ? formatter(args[index]) : args[index];
    });
    return formattedArgs;
};
/**
 * Should be called to format output(result) of method
 *
 * @method formatOutput
 * @param result {Object}
 * @return {Object}
 */
Subscription.prototype._formatOutput = function (result) {
    var subscription = this.options.subscription;
    return (subscription && subscription.outputFormatter && result) ? subscription.outputFormatter(result) : result;
};
/**
 * Should create payload from given input args
 *
 * @method toPayload
 * @param {Array} args
 * @return {Object}
 */
Subscription.prototype._toPayload = function (args) {
    var params = [];
    this.callback = this._extractCallback(args) || identity;
    if (!this.subscriptionMethod) {
        this.subscriptionMethod = args.shift();
        // replace subscription with given name
        if (this.options.subscription.subscriptionName) {
            this.subscriptionMethod = this.options.subscription.subscriptionName;
        }
    }
    if (!this.arguments) {
        this.arguments = this._formatInput(args);
        this._validateArgs(this.arguments);
        args = []; // make empty after validation
    }
    // re-add subscriptionName
    params.push(this.subscriptionMethod);
    params = params.concat(this.arguments);
    if (args.length) {
        throw new Error('Only a callback is allowed as parameter on an already instantiated subscription.');
    }
    return {
        method: this.options.type + '_subscribe',
        params: params
    };
};
/**
 * Unsubscribes and clears callbacks
 *
 * @method unsubscribe
 * @return {Object}
 */
Subscription.prototype.unsubscribe = function (callback) {
    this.options.requestManager.removeSubscription(this.id, callback);
    this.id = null;
    this.lastBlock = null;
    this.removeAllListeners();
};
/**
 * Subscribes and watches for changes
 *
 * @method subscribe
 * @param {String} subscription the subscription
 * @param {Object} options the options object with address topics and fromBlock
 * @return {Object}
 */
Subscription.prototype.subscribe = function () {
    var _this = this;
    var args = Array.prototype.slice.call(arguments);
    var payload = this._toPayload(args);
    if (!payload) {
        return this;
    }
    // throw error, if provider is not set
    if (!this.options.requestManager.provider) {
        setTimeout(function () {
            var err1 = new Error('No provider set.');
            _this.callback(err1, null, _this);
            _this.emit('error', err1);
        }, 0);
        return this;
    }
    // throw error, if provider doesnt support subscriptions
    if (!this.options.requestManager.provider.on) {
        setTimeout(function () {
            var err2 = new Error('The current provider doesn\'t support subscriptions: ' +
                _this.options.requestManager.provider.constructor.name);
            _this.callback(err2, null, _this);
            _this.emit('error', err2);
        }, 0);
        return this;
    }
    // Re-subscription only: continue fetching from the last block we received.
    // a dropped connection may have resulted in gaps in the logs...
    if (this.lastBlock && !!this.options.params && typeof this.options.params === 'object') {
        payload.params[1] = this.options.params;
        payload.params[1].fromBlock = formatters.inputBlockNumberFormatter(this.lastBlock + 1);
    }
    // if id is there unsubscribe first
    if (this.id) {
        this.unsubscribe();
    }
    // store the params in the options object
    this.options.params = payload.params[1];
    // get past logs, if fromBlock is available
    if (payload.params[0] === 'logs' && !!payload.params[1] && typeof payload.params[1] === 'object' && payload.params[1].hasOwnProperty('fromBlock') && isFinite(payload.params[1].fromBlock)) {
        // send the subscription request
        // copy the params to avoid race-condition with deletion below this block
        var blockParams = Object.assign({}, payload.params[1]);
        this.options.requestManager.send({
            method: 'eth_getLogs',
            params: [blockParams]
        }, function (err, logs) {
            if (!err) {
                logs.forEach(function (log) {
                    var output = _this._formatOutput(log);
                    _this.callback(null, output, _this);
                    _this.emit('data', output);
                });
                // TODO subscribe here? after the past logs?
            }
            else {
                setTimeout(function () {
                    _this.callback(err, null, _this);
                    _this.emit('error', err);
                }, 0);
            }
        });
    }
    // create subscription
    // TODO move to separate function? so that past logs can go first?
    if (typeof payload.params[1] === 'object')
        delete payload.params[1].fromBlock;
    this.options.requestManager.send(payload, function (err, result) {
        if (!err && result) {
            _this.id = result;
            _this.method = payload.params[0];
            // call callback on notifications
            _this.options.requestManager.addSubscription(_this, function (error, result) {
                if (!error) {
                    if (!Array.isArray(result)) {
                        result = [result];
                    }
                    result.forEach(function (resultItem) {
                        var output = _this._formatOutput(resultItem);
                        // Track current block (for gaps introduced by dropped connections)
                        _this.lastBlock = !!output && typeof output === 'object' ? output.blockNumber : null;
                        if (typeof _this.options.subscription.subscriptionHandler === 'function') {
                            return _this.options.subscription.subscriptionHandler.call(_this, output);
                        }
                        else {
                            _this.emit('data', output);
                        }
                        // call the callback, last so that unsubscribe there won't affect the emit above
                        _this.callback(null, output, _this);
                    });
                }
                else {
                    _this.callback(error, false, _this);
                    _this.emit('error', error);
                }
            });
            _this.emit('connected', result);
        }
        else {
            setTimeout(function () {
                _this.callback(err, false, _this);
                _this.emit('error', err);
            }, 0);
        }
    });
    // return an object to cancel the subscription
    return this;
};
/**
 * Resubscribe
 *
 * @method resubscribe
 *
 * @returns {void}
 */
Subscription.prototype.resubscribe = function () {
    this.options.requestManager.removeSubscription(this.id); // unsubscribe
    this.id = null;
    this.subscribe(this.callback);
};
module.exports = Subscription;


/***/ }),

/***/ 23216:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*
 This file is part of web3.js.

 web3.js is free software: you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 web3.js is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public License
 along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
 */
/**
 * @file extend.js
 * @author Fabian Vogelsteller <fabian@ethereum.org>
 * @date 2017
 */

var formatters = (__webpack_require__(59849).formatters);
var Method = __webpack_require__(2464);
var utils = __webpack_require__(84976);
var extend = function (pckg) {
    /* jshint maxcomplexity:5 */
    var ex = function (extension) {
        var extendedObject;
        if (extension.property) {
            if (!pckg[extension.property]) {
                pckg[extension.property] = {};
            }
            extendedObject = pckg[extension.property];
        }
        else {
            extendedObject = pckg;
        }
        if (extension.methods) {
            extension.methods.forEach(function (method) {
                if (!(method instanceof Method)) {
                    method = new Method(method);
                }
                method.attachToObject(extendedObject);
                method.setRequestManager(pckg._requestManager);
            });
        }
        return pckg;
    };
    ex.formatters = formatters;
    ex.utils = utils;
    ex.Method = Method;
    return ex;
};
module.exports = extend;


/***/ }),

/***/ 83599:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file index.js
 * @author Fabian Vogelsteller <fabian@ethereum.org>
 * @date 2017
 */
const requestManager = __webpack_require__(77304);
const extend = __webpack_require__(23216);
const packageInit = (pkg, args) => {
    args = Array.prototype.slice.call(args);
    if (!pkg) {
        throw new Error('You need to instantiate using the "new" keyword.');
    }
    // make property of pkg._provider, which can properly set providers
    Object.defineProperty(pkg, 'currentProvider', {
        get: () => {
            return pkg._provider;
        },
        set: (value) => {
            return pkg.setProvider(value);
        },
        enumerable: true,
        configurable: true
    });
    // inherit from parent package or create a new RequestManager
    if (args[0] && args[0]._requestManager) {
        pkg._requestManager = args[0]._requestManager;
    }
    else {
        pkg._requestManager = new requestManager.Manager(args[0], args[1]);
    }
    // add givenProvider
    pkg.givenProvider = requestManager.Manager.givenProvider;
    pkg.providers = requestManager.Manager.providers;
    pkg._provider = pkg._requestManager.provider;
    // add SETPROVIDER function (don't overwrite if already existing)
    if (!pkg.setProvider) {
        pkg.setProvider = (provider, net) => {
            pkg._requestManager.setProvider(provider, net);
            pkg._provider = pkg._requestManager.provider;
            return true;
        };
    }
    pkg.setRequestManager = (manager) => {
        pkg._requestManager = manager;
        pkg._provider = manager.provider;
    };
    // attach batch request creation
    pkg.BatchRequest = requestManager.BatchManager.bind(null, pkg._requestManager);
    // attach extend function
    pkg.extend = extend(pkg);
};
const addProviders = (pkg) => {
    pkg.givenProvider = requestManager.Manager.givenProvider;
    pkg.providers = requestManager.Manager.providers;
};
module.exports = {
    packageInit,
    addProviders
};


/***/ }),

/***/ 65797:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 This file is part of web3.js.

 web3.js is free software: you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 web3.js is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public License
 along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
 */
/**
 * @file index.js
 * @author Marek Kotewicz <marek@parity.io>
 * @author Fabian Vogelsteller <fabian@frozeman.de>
 * @date 2018
 */
var Buffer = (__webpack_require__(7661).Buffer);
var utils = __webpack_require__(84976);
var EthersAbiCoder = (__webpack_require__(84123)/* .AbiCoder */ .RQ);
var ParamType = (__webpack_require__(84123)/* .ParamType */ ._R);
var ethersAbiCoder = new EthersAbiCoder(function (type, value) {
    if (type.match(/^u?int/) && !Array.isArray(value) && (!(!!value && typeof value === 'object') || value.constructor.name !== 'BN')) {
        return value.toString();
    }
    return value;
});
// result method
function Result() {
}
/**
 * ABICoder prototype should be used to encode/decode solidity params of any type
 */
var ABICoder = function () {
};
/**
 * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.
 *
 * @method encodeFunctionSignature
 * @param {String|Object} functionName
 * @return {String} encoded function name
 */
ABICoder.prototype.encodeFunctionSignature = function (functionName) {
    if (typeof functionName === 'function' || typeof functionName === 'object' && functionName) {
        functionName = utils._jsonInterfaceMethodToString(functionName);
    }
    return utils.sha3(functionName).slice(0, 10);
};
/**
 * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.
 *
 * @method encodeEventSignature
 * @param {String|Object} functionName
 * @return {String} encoded function name
 */
ABICoder.prototype.encodeEventSignature = function (functionName) {
    if (typeof functionName === 'function' || typeof functionName === 'object' && functionName) {
        functionName = utils._jsonInterfaceMethodToString(functionName);
    }
    return utils.sha3(functionName);
};
/**
 * Should be used to encode plain param
 *
 * @method encodeParameter
 *
 * @param {String|Object} type
 * @param {any} param
 *
 * @return {String} encoded plain param
 */
ABICoder.prototype.encodeParameter = function (type, param) {
    return this.encodeParameters([type], [param]);
};
/**
 * Should be used to encode list of params
 *
 * @method encodeParameters
 *
 * @param {Array<String|Object>} types
 * @param {Array<any>} params
 *
 * @return {String} encoded list of params
 */
ABICoder.prototype.encodeParameters = function (types, params) {
    var self = this;
    types = self.mapTypes(types);
    params = params.map(function (param, index) {
        let type = types[index];
        if (typeof type === 'object' && type.type) {
            // We may get a named type of shape {name, type}
            type = type.type;
        }
        param = self.formatParam(type, param);
        // Format params for tuples
        if (typeof type === 'string' && type.includes('tuple')) {
            const coder = ethersAbiCoder._getCoder(ParamType.from(type));
            const modifyParams = (coder, param) => {
                if (coder.name === 'array') {
                    if (!coder.type.match(/\[(\d+)\]/)) {
                        return param.map(p => modifyParams(ethersAbiCoder._getCoder(ParamType.from(coder.type.replace('[]', ''))), p));
                    }
                    const arrayLength = parseInt(coder.type.match(/\[(\d+)\]/)[1]);
                    if (param.length !== arrayLength) {
                        throw new Error('Array length does not matches with the given input');
                    }
                    return param.map(p => modifyParams(ethersAbiCoder._getCoder(ParamType.from(coder.type.replace(/\[\d+\]/, ''))), p));
                }
                coder.coders.forEach((c, i) => {
                    if (c.name === 'tuple') {
                        modifyParams(c, param[i]);
                    }
                    else {
                        param[i] = self.formatParam(c.name, param[i]);
                    }
                });
            };
            modifyParams(coder, param);
        }
        return param;
    });
    return ethersAbiCoder.encode(types, params);
};
/**
 * Map types if simplified format is used
 *
 * @method mapTypes
 * @param {Array} types
 * @return {Array}
 */
ABICoder.prototype.mapTypes = function (types) {
    var self = this;
    var mappedTypes = [];
    types.forEach(function (type) {
        // Remap `function` type params to bytes24 since Ethers does not
        // recognize former type. Solidity docs say `Function` is a bytes24
        // encoding the contract address followed by the function selector hash.
        if (typeof type === 'object' && type.type === 'function') {
            type = Object.assign({}, type, { type: "bytes24" });
        }
        if (self.isSimplifiedStructFormat(type)) {
            var structName = Object.keys(type)[0];
            mappedTypes.push(Object.assign(self.mapStructNameAndType(structName), {
                components: self.mapStructToCoderFormat(type[structName])
            }));
            return;
        }
        mappedTypes.push(type);
    });
    return mappedTypes;
};
/**
 * Check if type is simplified struct format
 *
 * @method isSimplifiedStructFormat
 * @param {string | Object} type
 * @returns {boolean}
 */
ABICoder.prototype.isSimplifiedStructFormat = function (type) {
    return typeof type === 'object' && typeof type.components === 'undefined' && typeof type.name === 'undefined';
};
/**
 * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used
 *
 * @method mapStructNameAndType
 * @param {string} structName
 * @return {{type: string, name: *}}
 */
ABICoder.prototype.mapStructNameAndType = function (structName) {
    var type = 'tuple';
    if (structName.indexOf('[]') > -1) {
        type = 'tuple[]';
        structName = structName.slice(0, -2);
    }
    return { type: type, name: structName };
};
/**
 * Maps the simplified format in to the expected format of the ABICoder
 *
 * @method mapStructToCoderFormat
 * @param {Object} struct
 * @return {Array}
 */
ABICoder.prototype.mapStructToCoderFormat = function (struct) {
    var self = this;
    var components = [];
    Object.keys(struct).forEach(function (key) {
        if (typeof struct[key] === 'object') {
            components.push(Object.assign(self.mapStructNameAndType(key), {
                components: self.mapStructToCoderFormat(struct[key])
            }));
            return;
        }
        components.push({
            name: key,
            type: struct[key]
        });
    });
    return components;
};
/**
 * Handle some formatting of params for backwards compatability with Ethers V4
 *
 * @method formatParam
 * @param {String} - type
 * @param {any} - param
 * @return {any} - The formatted param
 */
ABICoder.prototype.formatParam = function (type, param) {
    const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
    const paramTypeBytesArray = new RegExp(/^bytes([0-9]*)\[\]$/);
    const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
    const paramTypeNumberArray = new RegExp(/^(u?int)([0-9]*)\[\]$/);
    // Format BN to string
    if (utils.isBN(param) || utils.isBigNumber(param)) {
        return param.toString(10);
    }
    if (type.match(paramTypeBytesArray) || type.match(paramTypeNumberArray)) {
        return param.map(p => this.formatParam(type.replace('[]', ''), p));
    }
    // Format correct width for u?int[0-9]*
    let match = type.match(paramTypeNumber);
    if (match) {
        let size = parseInt(match[2] || "256");
        if (size / 8 < param.length) {
            param = param.startsWith("-")
                // pad to correct bit width, with - at the beginning
                ? `-${utils.leftPad(param.substring(1), size)}`
                // pad to correct bit width
                : utils.leftPad(param, size);
        }
    }
    // Format correct length for bytes[0-9]+
    match = type.match(paramTypeBytes);
    if (match) {
        if (Buffer.isBuffer(param)) {
            param = utils.toHex(param);
        }
        // format to correct length
        let size = parseInt(match[1]);
        if (size) {
            let maxSize = size * 2;
            if (param.substring(0, 2) === '0x') {
                maxSize += 2;
            }
            if (param.length < maxSize) {
                // pad to correct length
                param = utils.rightPad(param, size * 2);
            }
        }
        // format odd-length bytes to even-length
        if (param.length % 2 === 1) {
            param = '0x0' + param.substring(2);
        }
    }
    return param;
};
/**
 * Encodes a function call from its json interface and parameters.
 *
 * @method encodeFunctionCall
 * @param {Array} jsonInterface
 * @param {Array} params
 * @return {String} The encoded ABI for this function call
 */
ABICoder.prototype.encodeFunctionCall = function (jsonInterface, params) {
    return this.encodeFunctionSignature(jsonInterface) + this.encodeParameters(jsonInterface.inputs, params).replace('0x', '');
};
/**
 * Should be used to decode bytes to plain param
 *
 * @method decodeParameter
 * @param {String} type
 * @param {String} bytes
 * @return {Object} plain param
 */
ABICoder.prototype.decodeParameter = function (type, bytes) {
    return this.decodeParameters([type], bytes)[0];
};
/**
 * Should be used to decode list of params
 *
 * @method decodeParameter
 * @param {Array} outputs
 * @param {String} bytes
 * @return {Array} array of plain params
 */
ABICoder.prototype.decodeParameters = function (outputs, bytes) {
    return this.decodeParametersWith(outputs, bytes, false);
};
/**
 * Should be used to decode list of params
 *
 * @method decodeParameter
 * @param {Array} outputs
 * @param {String} bytes
 * @param {Boolean} loose
 * @return {Array} array of plain params
 */
ABICoder.prototype.decodeParametersWith = function (outputs, bytes, loose) {
    if (outputs.length > 0 && (!bytes || bytes === '0x' || bytes === '0X')) {
        throw new Error('Returned values aren\'t valid, did it run Out of Gas? ' +
            'You might also see this error if you are not using the ' +
            'correct ABI for the contract you are retrieving data from, ' +
            'requesting data from a block number that does not exist, ' +
            'or querying a node which is not fully synced.');
    }
    var res = ethersAbiCoder.decode(this.mapTypes(outputs), '0x' + bytes.replace(/0x/i, ''), loose);
    var returnValue = new Result();
    returnValue.__length__ = 0;
    outputs.forEach(function (output, i) {
        var decodedValue = res[returnValue.__length__];
        const isStringObject = typeof output === 'object' && output.type && output.type === 'string';
        const isStringType = typeof output === 'string' && output === 'string';
        // only convert `0x` to null if it's not string value
        decodedValue = (decodedValue === '0x' && !isStringObject && !isStringType) ? null : decodedValue;
        returnValue[i] = decodedValue;
        if ((typeof output === 'function' || !!output && typeof output === 'object') && output.name) {
            returnValue[output.name] = decodedValue;
        }
        returnValue.__length__++;
    });
    return returnValue;
};
/**
 * Decodes events non- and indexed parameters.
 *
 * @method decodeLog
 * @param {Object} inputs
 * @param {String} data
 * @param {Array} topics
 * @return {Array} array of plain params
 */
ABICoder.prototype.decodeLog = function (inputs, data, topics) {
    var _this = this;
    topics = Array.isArray(topics) ? topics : [topics];
    data = data || '';
    var notIndexedInputs = [];
    var indexedParams = [];
    var topicCount = 0;
    // TODO check for anonymous logs?
    inputs.forEach(function (input, i) {
        if (input.indexed) {
            indexedParams[i] = (['bool', 'int', 'uint', 'address', 'fixed', 'ufixed'].find(function (staticType) {
                return input.type.indexOf(staticType) !== -1;
            })) ? _this.decodeParameter(input.type, topics[topicCount]) : topics[topicCount];
            topicCount++;
        }
        else {
            notIndexedInputs[i] = input;
        }
    });
    var nonIndexedData = data;
    var notIndexedParams = (nonIndexedData) ? this.decodeParametersWith(notIndexedInputs, nonIndexedData, true) : [];
    var returnValue = new Result();
    returnValue.__length__ = 0;
    inputs.forEach(function (res, i) {
        returnValue[i] = (res.type === 'string') ? '' : null;
        if (typeof notIndexedParams[i] !== 'undefined') {
            returnValue[i] = notIndexedParams[i];
        }
        if (typeof indexedParams[i] !== 'undefined') {
            returnValue[i] = indexedParams[i];
        }
        if (res.name) {
            returnValue[res.name] = returnValue[i];
        }
        returnValue.__length__++;
    });
    return returnValue;
};
var coder = new ABICoder();
module.exports = coder;


/***/ }),

/***/ 53348:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file iban.js
 *
 * Details: https://github.com/ethereum/wiki/wiki/ICAP:-Inter-exchange-Client-Address-Protocol
 *
 * @author Marek Kotewicz <marek@parity.io>
 * @date 2015
 */

const utils = __webpack_require__(84976);
const BigNumber = __webpack_require__(73182);
const leftPad = function (string, bytes) {
    let result = string;
    while (result.length < bytes * 2) {
        result = '0' + result;
    }
    return result;
};
/**
 * Prepare an IBAN for mod 97 computation by moving the first 4 chars to the end and transforming the letters to
 * numbers (A = 10, B = 11, ..., Z = 35), as specified in ISO13616.
 *
 * @method iso13616Prepare
 * @param {String} iban the IBAN
 * @returns {String} the prepared IBAN
 */
const iso13616Prepare = function (iban) {
    const A = 'A'.charCodeAt(0);
    const Z = 'Z'.charCodeAt(0);
    iban = iban.toUpperCase();
    iban = iban.slice(4) + iban.slice(0, 4);
    return iban.split('').map(function (n) {
        const code = n.charCodeAt(0);
        if (code >= A && code <= Z) {
            // A = 10, B = 11, ... Z = 35
            return code - A + 10;
        }
        else {
            return n;
        }
    }).join('');
};
/**
 * Calculates the MOD 97 10 of the passed IBAN as specified in ISO7064.
 *
 * @method mod9710
 * @param {String} iban
 * @returns {Number}
 */
const mod9710 = function (iban) {
    let remainder = iban;
    let block;
    while (remainder.length > 2) {
        block = remainder.slice(0, 9);
        remainder = parseInt(block, 10) % 97 + remainder.slice(block.length);
    }
    return parseInt(remainder, 10) % 97;
};
/**
 * This prototype should be used to create iban object from iban correct string
 *
 * @param {String} iban
 */
class Iban {
    constructor(iban) {
        this._iban = iban;
    }
    /**
     * This method should be used to create an ethereum address from a direct iban address
     *
     * @method toAddress
     * @param {String} iban address
     * @return {String} the ethereum address
     */
    static toAddress(ib) {
        ib = new Iban(ib);
        if (!ib.isDirect()) {
            throw new Error('IBAN is indirect and can\'t be converted');
        }
        return ib.toAddress();
    }
    /**
     * This method should be used to create iban address from an ethereum address
     *
     * @method toIban
     * @param {String} address
     * @return {String} the IBAN address
     */
    static toIban(address) {
        return Iban.fromAddress(address).toString();
    }
    /**
     * This method should be used to create iban object from an ethereum address
     *
     * @method fromAddress
     * @param {String} address
     * @return {Iban} the IBAN object
     */
    static fromAddress(address) {
        if (!utils.isAddress(address)) {
            throw new Error('Provided address is not a valid address: ' + address);
        }
        address = address.replace('0x', '').replace('0X', '');
        const asBn = new BigNumber(address, 16);
        const base36 = asBn.toString(36);
        const padded = leftPad(base36, 15);
        return Iban.fromBban(padded.toUpperCase());
    }
    /**
     * Convert the passed BBAN to an IBAN for this country specification.
     * Please note that <i>"generation of the IBAN shall be the exclusive responsibility of the bank/branch servicing the account"</i>.
     * This method implements the preferred algorithm described in http://en.wikipedia.org/wiki/International_Bank_Account_Number#Generating_IBAN_check_digits
     *
     * @method fromBban
     * @param {String} bban the BBAN to convert to IBAN
     * @returns {Iban} the IBAN object
     */
    static fromBban(bban) {
        const countryCode = 'XE';
        const remainder = mod9710(iso13616Prepare(countryCode + '00' + bban));
        const checkDigit = ('0' + (98 - remainder)).slice(-2);
        return new Iban(countryCode + checkDigit + bban);
    }
    /**
     * Should be used to create IBAN object for given institution and identifier
     *
     * @method createIndirect
     * @param {Object} options, required options are "institution" and "identifier"
     * @return {Iban} the IBAN object
     */
    static createIndirect(options) {
        return Iban.fromBban('ETH' + options.institution + options.identifier);
    }
    /**
     * This method should be used to check if given string is valid iban object
     *
     * @method isValid
     * @param {String} iban string
     * @return {Boolean} true if it is valid IBAN
     */
    static isValid(iban) {
        const i = new Iban(iban);
        return i.isValid();
    }
    ;
    /**
     * Should be called to check if iban is correct
     *
     * @method isValid
     * @returns {Boolean} true if it is, otherwise false
     */
    isValid() {
        return /^XE[0-9]{2}(ETH[0-9A-Z]{13}|[0-9A-Z]{30,31})$/.test(this._iban) &&
            mod9710(iso13616Prepare(this._iban)) === 1;
    }
    ;
    /**
     * Should be called to check if iban number is direct
     *
     * @method isDirect
     * @returns {Boolean} true if it is, otherwise false
     */
    isDirect() {
        return this._iban.length === 34 || this._iban.length === 35;
    }
    ;
    /**
     * Should be called to check if iban number if indirect
     *
     * @method isIndirect
     * @returns {Boolean} true if it is, otherwise false
     */
    isIndirect() {
        return this._iban.length === 20;
    }
    ;
    /**
     * Should be called to get iban checksum
     * Uses the mod-97-10 checksumming protocol (ISO/IEC 7064:2003)
     *
     * @method checksum
     * @returns {String} checksum
     */
    checksum() {
        return this._iban.slice(2, 4);
    }
    ;
    /**
     * Should be called to get institution identifier
     * eg. XREG
     *
     * @method institution
     * @returns {String} institution identifier
     */
    institution() {
        return this.isIndirect() ? this._iban.slice(7, 11) : '';
    }
    ;
    /**
     * Should be called to get client identifier within institution
     * eg. GAVOFYORK
     *
     * @method client
     * @returns {String} client identifier
     */
    client() {
        return this.isIndirect() ? this._iban.slice(11) : '';
    }
    ;
    /**
     * Should be called to get client direct address
     *
     * @method toAddress
     * @returns {String} ethereum address
     */
    toAddress() {
        if (this.isDirect()) {
            const base36 = this._iban.slice(4);
            const asBn = new BigNumber(base36, 36);
            return utils.toChecksumAddress(asBn.toString(16, 20));
        }
        return '';
    }
    ;
    toString() {
        return this._iban;
    }
    ;
}
module.exports = Iban;


/***/ }),

/***/ 27762:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file index.js
 * @author Fabian Vogelsteller <fabian@ethereum.org>
 * @date 2017
 */

var core = __webpack_require__(83599);
var Method = __webpack_require__(2464);
var utils = __webpack_require__(84976);
var Net = __webpack_require__(27124);
var formatters = (__webpack_require__(59849).formatters);
var Personal = function Personal() {
    var _this = this;
    // sets _requestmanager
    core.packageInit(this, arguments);
    this.net = new Net(this);
    var defaultAccount = null;
    var defaultBlock = 'latest';
    Object.defineProperty(this, 'defaultAccount', {
        get: function () {
            return defaultAccount;
        },
        set: function (val) {
            if (val) {
                defaultAccount = utils.toChecksumAddress(formatters.inputAddressFormatter(val));
            }
            // update defaultBlock
            methods.forEach(function (method) {
                method.defaultAccount = defaultAccount;
            });
            return val;
        },
        enumerable: true
    });
    Object.defineProperty(this, 'defaultBlock', {
        get: function () {
            return defaultBlock;
        },
        set: function (val) {
            defaultBlock = val;
            // update defaultBlock
            methods.forEach(function (method) {
                method.defaultBlock = defaultBlock;
            });
            return val;
        },
        enumerable: true
    });
    var methods = [
        new Method({
            name: 'getAccounts',
            call: 'personal_listAccounts',
            params: 0,
            outputFormatter: utils.toChecksumAddress
        }),
        new Method({
            name: 'newAccount',
            call: 'personal_newAccount',
            params: 1,
            inputFormatter: [null],
            outputFormatter: utils.toChecksumAddress
        }),
        new Method({
            name: 'unlockAccount',
            call: 'personal_unlockAccount',
            params: 3,
            inputFormatter: [formatters.inputAddressFormatter, null, null]
        }),
        new Method({
            name: 'lockAccount',
            call: 'personal_lockAccount',
            params: 1,
            inputFormatter: [formatters.inputAddressFormatter]
        }),
        new Method({
            name: 'importRawKey',
            call: 'personal_importRawKey',
            params: 2
        }),
        new Method({
            name: 'sendTransaction',
            call: 'personal_sendTransaction',
            params: 2,
            inputFormatter: [formatters.inputTransactionFormatter, null]
        }),
        new Method({
            name: 'signTransaction',
            call: 'personal_signTransaction',
            params: 2,
            inputFormatter: [formatters.inputTransactionFormatter, null]
        }),
        new Method({
            name: 'sign',
            call: 'personal_sign',
            params: 3,
            inputFormatter: [formatters.inputSignFormatter, formatters.inputAddressFormatter, null]
        }),
        new Method({
            name: 'ecRecover',
            call: 'personal_ecRecover',
            params: 2,
            inputFormatter: [formatters.inputSignFormatter, null]
        })
    ];
    methods.forEach(function (method) {
        method.attachToObject(_this);
        method.setRequestManager(_this._requestManager);
        method.defaultBlock = _this.defaultBlock;
        method.defaultAccount = _this.defaultAccount;
    });
};
core.addProviders(Personal);
module.exports = Personal;


/***/ }),

/***/ 27124:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file index.js
 * @author Fabian Vogelsteller <fabian@ethereum.org>
 * @date 2017
 */

var core = __webpack_require__(83599);
var Method = __webpack_require__(2464);
var utils = __webpack_require__(84976);
var Net = function () {
    var _this = this;
    // sets _requestmanager
    core.packageInit(this, arguments);
    [
        new Method({
            name: 'getId',
            call: 'net_version',
            params: 0,
            outputFormatter: parseInt
        }),
        new Method({
            name: 'isListening',
            call: 'net_listening',
            params: 0
        }),
        new Method({
            name: 'getPeerCount',
            call: 'net_peerCount',
            params: 0,
            outputFormatter: utils.hexToNumber
        })
    ].forEach(function (method) {
        method.attachToObject(_this);
        method.setRequestManager(_this._requestManager);
    });
};
core.addProviders(Net);
module.exports = Net;


/***/ }),

/***/ 69685:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file httpprovider.js
 * @authors:
 *   Marek Kotewicz <marek@parity.io>
 *   Marian Oancea
 *   Fabian Vogelsteller <fabian@ethereum.org>
 *   AyanamiTech <ayanami0330@protonmail.com>
 * @date 2015
 */
var errors = (__webpack_require__(59849).errors);
var fetch = __webpack_require__(27714);
var http = __webpack_require__(1107);
var https = __webpack_require__(29394);
// Apply missing polyfill for IE
(__webpack_require__(90826).polyfill)();
// import abortController if abortController is not included in node
if (typeof __webpack_require__.g !== "undefined" && !__webpack_require__.g.AbortController) {
    __webpack_require__(18875);
}
/**
 * HttpProvider should be used to send rpc calls over http
 */
var HttpProvider = function HttpProvider(host, options) {
    options = options || {};
    this.withCredentials = options.withCredentials;
    this.timeout = options.timeout || 0;
    this.headers = options.headers;
    this.agent = options.agent;
    this.forceGlobalFetch = options.forceGlobalFetch || false;
    this.connected = false;
    // keepAlive is true unless explicitly set to false
    const keepAlive = options.keepAlive !== false;
    this.host = host || 'http://localhost:8545';
    if (!this.agent) {
        if (this.host.substring(0, 5) === "https") {
            this.httpsAgent = new https.Agent({ keepAlive });
        }
        else {
            this.httpAgent = new http.Agent({ keepAlive });
        }
    }
};
/**
 * Should be used to make async request
 *
 * @method send
 * @param {Object} payload
 * @param {Function} callback triggered on end with (err, result)
 */
HttpProvider.prototype.send = function (payload, callback) {
    var options = {
        method: 'POST',
        body: JSON.stringify(payload)
    };
    var headers = {};
    var controller;
    var fetchFunc = this.forceGlobalFetch ? globalThis.fetch : fetch;
    if (typeof AbortController !== 'undefined') {
        controller = new AbortController();
    }
    else if (typeof window !== 'undefined' && typeof window.AbortController !== 'undefined') {
        // Some chrome version doesn't recognize new AbortController(); so we are using it from window instead
        // https://stackoverflow.com/questions/55718778/why-abortcontroller-is-not-defined
        controller = new window.AbortController();
    }
    if (typeof controller !== 'undefined') {
        options.signal = controller.signal;
    }
    // the current runtime is node
    if (typeof XMLHttpRequest === 'undefined') {
        // https://github.com/node-fetch/node-fetch#custom-agent
        var agents = { httpsAgent: this.httpsAgent, httpAgent: this.httpAgent };
        if (this.agent) {
            agents.httpsAgent = this.agent.https;
            agents.httpAgent = this.agent.http;
        }
        if (this.host.substring(0, 5) === "https") {
            options.agent = agents.httpsAgent;
        }
        else {
            options.agent = agents.httpAgent;
        }
    }
    if (this.headers) {
        this.headers.forEach(function (header) {
            headers[header.name] = header.value;
        });
    }
    // Default headers
    if (!headers['Content-Type']) {
        headers['Content-Type'] = 'application/json';
    }
    // As the Fetch API supports the credentials as following options 'include', 'omit', 'same-origin'
    // https://developer.mozilla.org/en-US/docs/Web/API/fetch#credentials
    // To avoid breaking change in 1.x we override this value based on boolean option.
    if (this.withCredentials) {
        options.credentials = 'include';
    }
    else {
        options.credentials = 'omit';
    }
    options.headers = headers;
    if (this.timeout > 0 && typeof controller !== 'undefined') {
        this.timeoutId = setTimeout(function () {
            controller.abort();
        }, this.timeout);
    }
    var success = function (response) {
        if (this.timeoutId !== undefined) {
            clearTimeout(this.timeoutId);
        }
        // Response is a stream data so should be awaited for json response
        response
            .json()
            .then(function (data) {
            callback(null, data);
        }, function () {
            response
                .text()
                .then(function (text) {
                callback(errors.InvalidResponse(text));
            }, function () {
                callback(errors.InvalidResponse(""));
            });
        });
    };
    var failed = function (error) {
        if (this.timeoutId !== undefined) {
            clearTimeout(this.timeoutId);
        }
        if (error.name === 'AbortError') {
            callback(errors.ConnectionTimeout(this.timeout));
            return;
        }
        callback(errors.InvalidConnection(this.host, error));
    };
    fetchFunc(this.host, options)
        .then(success.bind(this), failed.bind(this));
};
HttpProvider.prototype.disconnect = function () {
    //NO OP
};
/**
 * Returns the desired boolean.
 *
 * @method supportsSubscriptions
 * @returns {boolean}
 */
HttpProvider.prototype.supportsSubscriptions = function () {
    return false;
};
module.exports = HttpProvider;


/***/ }),

/***/ 56606:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file index.js
 * @authors:
 *   Fabian Vogelsteller <fabian@ethereum.org>
 * @date 2017
 */

var errors = (__webpack_require__(59849).errors);
var oboe = __webpack_require__(92963);
var IpcProvider = function IpcProvider(path, net) {
    var _this = this;
    this.responseCallbacks = {};
    this.notificationCallbacks = [];
    this.path = path;
    this.connected = false;
    this.connection = net.connect({ path: this.path });
    this.addDefaultEvents();
    // LISTEN FOR CONNECTION RESPONSES
    var callback = function (result) {
        /*jshint maxcomplexity: 6 */
        var id = null;
        // get the id which matches the returned id
        if (Array.isArray(result)) {
            result.forEach(function (load) {
                if (_this.responseCallbacks[load.id])
                    id = load.id;
            });
        }
        else {
            id = result.id;
        }
        // notification
        if (!id && result.method.indexOf('_subscription') !== -1) {
            _this.notificationCallbacks.forEach(function (callback) {
                if (typeof callback === 'function')
                    callback(result);
            });
            // fire the callback
        }
        else if (_this.responseCallbacks[id]) {
            _this.responseCallbacks[id](null, result);
            delete _this.responseCallbacks[id];
        }
    };
    // use oboe.js for Sockets
    if (net.constructor.name === 'Socket') {
        oboe(this.connection)
            .done(callback);
    }
    else {
        this.connection.on('data', function (data) {
            _this._parseResponse(data.toString()).forEach(callback);
        });
    }
};
/**
Will add the error and end event to timeout existing calls

@method addDefaultEvents
*/
IpcProvider.prototype.addDefaultEvents = function () {
    var _this = this;
    this.connection.on('connect', function () {
        _this.connected = true;
    });
    this.connection.on('close', function () {
        _this.connected = false;
    });
    this.connection.on('error', function () {
        _this._timeout();
    });
    this.connection.on('end', function () {
        _this._timeout();
    });
    this.connection.on('timeout', function () {
        _this._timeout();
    });
};
/**
 Will parse the response and make an array out of it.

 NOTE, this exists for backwards compatibility reasons.

 @method _parseResponse
 @param {String} data
 */
IpcProvider.prototype._parseResponse = function (data) {
    var _this = this, returnValues = [];
    // DE-CHUNKER
    var dechunkedData = data
        .replace(/\}[\n\r]?\{/g, '}|--|{') // }{
        .replace(/\}\][\n\r]?\[\{/g, '}]|--|[{') // }][{
        .replace(/\}[\n\r]?\[\{/g, '}|--|[{') // }[{
        .replace(/\}\][\n\r]?\{/g, '}]|--|{') // }]{
        .split('|--|');
    dechunkedData.forEach(function (data) {
        // prepend the last chunk
        if (_this.lastChunk)
            data = _this.lastChunk + data;
        var result = null;
        try {
            result = JSON.parse(data);
        }
        catch (e) {
            _this.lastChunk = data;
            // start timeout to cancel all requests
            clearTimeout(_this.lastChunkTimeout);
            _this.lastChunkTimeout = setTimeout(function () {
                _this._timeout();
                throw errors.InvalidResponse(data);
            }, 1000 * 15);
            return;
        }
        // cancel timeout and set chunk to null
        clearTimeout(_this.lastChunkTimeout);
        _this.lastChunk = null;
        if (result)
            returnValues.push(result);
    });
    return returnValues;
};
/**
Get the adds a callback to the responseCallbacks object,
which will be called if a response matching the response Id will arrive.

@method _addResponseCallback
*/
IpcProvider.prototype._addResponseCallback = function (payload, callback) {
    var id = payload.id || payload[0].id;
    var method = payload.method || payload[0].method;
    this.responseCallbacks[id] = callback;
    this.responseCallbacks[id].method = method;
};
/**
Timeout all requests when the end/error event is fired

@method _timeout
*/
IpcProvider.prototype._timeout = function () {
    for (var key in this.responseCallbacks) {
        if (this.responseCallbacks.hasOwnProperty(key)) {
            this.responseCallbacks[key](errors.InvalidConnection('on IPC'));
            delete this.responseCallbacks[key];
        }
    }
};
/**
 Try to reconnect

 @method reconnect
 */
IpcProvider.prototype.reconnect = function () {
    this.connection.connect({ path: this.path });
};
IpcProvider.prototype.send = function (payload, callback) {
    // try reconnect, when connection is gone
    if (!this.connection.writable)
        this.connection.connect({ path: this.path });
    this.connection.write(JSON.stringify(payload));
    this._addResponseCallback(payload, callback);
};
/**
Subscribes to provider events.provider

@method on
@param {String} type    'notification', 'connect', 'error', 'end' or 'data'
@param {Function} callback   the callback to call
*/
IpcProvider.prototype.on = function (type, callback) {
    if (typeof callback !== 'function')
        throw new Error('The second parameter callback must be a function.');
    switch (type) {
        case 'data':
            this.notificationCallbacks.push(callback);
            break;
        // adds error, end, timeout, connect
        default:
            this.connection.on(type, callback);
            break;
    }
};
/**
 Subscribes to provider events.provider

 @method on
 @param {String} type    'connect', 'error', 'end' or 'data'
 @param {Function} callback   the callback to call
 */
IpcProvider.prototype.once = function (type, callback) {
    if (typeof callback !== 'function')
        throw new Error('The second parameter callback must be a function.');
    this.connection.once(type, callback);
};
/**
Removes event listener

@method removeListener
@param {String} type    'data', 'connect', 'error', 'end' or 'data'
@param {Function} callback   the callback to call
*/
IpcProvider.prototype.removeListener = function (type, callback) {
    var _this = this;
    switch (type) {
        case 'data':
            this.notificationCallbacks.forEach(function (cb, index) {
                if (cb === callback)
                    _this.notificationCallbacks.splice(index, 1);
            });
            break;
        default:
            this.connection.removeListener(type, callback);
            break;
    }
};
/**
Removes all event listeners

@method removeAllListeners
@param {String} type    'data', 'connect', 'error', 'end' or 'data'
*/
IpcProvider.prototype.removeAllListeners = function (type) {
    switch (type) {
        case 'data':
            this.notificationCallbacks = [];
            break;
        default:
            this.connection.removeAllListeners(type);
            break;
    }
};
/**
Resets the providers, clears all callbacks

@method reset
*/
IpcProvider.prototype.reset = function () {
    this._timeout();
    this.notificationCallbacks = [];
    this.connection.removeAllListeners('error');
    this.connection.removeAllListeners('end');
    this.connection.removeAllListeners('timeout');
    this.addDefaultEvents();
};
/**
 * Returns the desired boolean.
 *
 * @method supportsSubscriptions
 * @returns {boolean}
 */
IpcProvider.prototype.supportsSubscriptions = function () {
    return true;
};
module.exports = IpcProvider;


/***/ }),

/***/ 37174:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(7661)["Buffer"];
var isNode = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';
var isRN = typeof navigator !== 'undefined' && navigator.product === 'ReactNative';
var _btoa = null;
var helpers = null;
if (isNode || isRN) {
    _btoa = function (str) {
        return Buffer.from(str).toString('base64');
    };
    var url = __webpack_require__(43580);
    if (url.URL) {
        // Use the new Node 6+ API for parsing URLs that supports username/password
        var newURL = url.URL;
        helpers = function (url) {
            return new newURL(url);
        };
    }
    else {
        // Web3 supports Node.js 5, so fall back to the legacy URL API if necessary
        helpers = (__webpack_require__(43580).parse);
    }
}
else {
    _btoa = btoa.bind(typeof globalThis === 'object' ? globalThis : self);
    helpers = function (url) {
        return new URL(url);
    };
}
module.exports = {
    parseURL: helpers,
    btoa: _btoa
};


/***/ }),

/***/ 72937:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*
 This file is part of web3.js.

 web3.js is free software: you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 web3.js is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public License
 along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
 */
/**
 * @file WebsocketProvider.js
 * @authors: Samuel Furter <samuel@ethereum.org>, Fabian Vogelsteller <fabian@ethereum.org>
 * @date 2019
 */

var EventEmitter = __webpack_require__(7687);
var helpers = __webpack_require__(37174);
var errors = (__webpack_require__(59849).errors);
var Ws = (__webpack_require__(42658).w3cwebsocket);
/**
 * @param {string} url
 * @param {Object} options
 *
 * @constructor
 */
var WebsocketProvider = function WebsocketProvider(url, options) {
    EventEmitter.call(this);
    options = options || {};
    this.url = url;
    this._customTimeout = options.timeout || 1000 * 15;
    this.headers = options.headers || {};
    this.protocol = options.protocol || undefined;
    this.reconnectOptions = Object.assign({
        auto: false,
        delay: 5000,
        maxAttempts: false,
        onTimeout: false
    }, options.reconnect);
    this.clientConfig = options.clientConfig || undefined; // Allow a custom client configuration
    this.requestOptions = options.requestOptions || undefined; // Allow a custom request options (https://github.com/theturtle32/WebSocket-Node/blob/master/docs/WebSocketClient.md#connectrequesturl-requestedprotocols-origin-headers-requestoptions)
    this.DATA = 'data';
    this.CLOSE = 'close';
    this.ERROR = 'error';
    this.CONNECT = 'connect';
    this.RECONNECT = 'reconnect';
    this.connection = null;
    this.requestQueue = new Map();
    this.responseQueue = new Map();
    this.reconnectAttempts = 0;
    this.reconnecting = false;
    this.connectFailedDescription = null;
    // The w3cwebsocket implementation does not support Basic Auth
    // username/password in the URL. So generate the basic auth header, and
    // pass through with any additional headers supplied in constructor
    var parsedURL = helpers.parseURL(url);
    if (parsedURL.username && parsedURL.password) {
        this.headers.authorization = 'Basic ' + helpers.btoa(parsedURL.username + ':' + parsedURL.password);
    }
    // When all node core implementations that do not have the
    // WHATWG compatible URL parser go out of service this line can be removed.
    if (parsedURL.auth) {
        this.headers.authorization = 'Basic ' + helpers.btoa(parsedURL.auth);
    }
    // make property `connected` which will return the current connection status
    Object.defineProperty(this, 'connected', {
        get: function () {
            return this.connection && this.connection.readyState === this.connection.OPEN;
        },
        enumerable: true
    });
    this.connect();
};
// Inherit from EventEmitter
WebsocketProvider.prototype = Object.create(EventEmitter.prototype);
WebsocketProvider.prototype.constructor = WebsocketProvider;
/**
 * Connects to the configured node
 *
 * @method connect
 *
 * @returns {void}
 */
WebsocketProvider.prototype.connect = function () {
    this.connection = new Ws(this.url, this.protocol, undefined, this.headers, this.requestOptions, this.clientConfig);
    this._addSocketListeners();
};
/**
 * Listener for the `data` event of the underlying WebSocket object
 *
 * @method _onMessage
 *
 * @returns {void}
 */
WebsocketProvider.prototype._onMessage = function (e) {
    var _this = this;
    this._parseResponse((typeof e.data === 'string') ? e.data : '').forEach(function (result) {
        if (result.method && result.method.indexOf('_subscription') !== -1) {
            _this.emit(_this.DATA, result);
            return;
        }
        var id = result.id;
        // get the id which matches the returned id
        if (Array.isArray(result)) {
            id = result[0].id;
        }
        if (_this.responseQueue.has(id)) {
            if (_this.responseQueue.get(id).callback !== undefined) {
                _this.responseQueue.get(id).callback(false, result);
            }
            _this.responseQueue.delete(id);
        }
    });
};
/**
 * Listener for the `open` event of the underlying WebSocket object
 *
 * @method _onConnect
 *
 * @returns {void}
 */
WebsocketProvider.prototype._onConnect = function () {
    this.emit(this.CONNECT);
    this.reconnectAttempts = 0;
    this.reconnecting = false;
    if (this.requestQueue.size > 0) {
        var _this = this;
        this.requestQueue.forEach(function (request, key) {
            _this.send(request.payload, request.callback);
            _this.requestQueue.delete(key);
        });
    }
};
WebsocketProvider.prototype._onConnectFailed = function (event) {
    this.connectFailedDescription = event.toString().split('\n')[0];
    var _this = this;
    if (this.connectFailedDescription) {
        event.description = this.connectFailedDescription;
        this.connectFailedDescription = null; // clean the message, so it won't be used in the next connection
    }
    event.code = 1006;
    event.reason = 'connection failed';
    if (this.reconnectOptions.auto && (![1000, 1001].includes(event.code) || event.wasClean === false)) {
        this.reconnect();
        return;
    }
    this.emit(this.ERROR, event);
    if (this.requestQueue.size > 0) {
        this.requestQueue.forEach(function (request, key) {
            request.callback(errors.ConnectionNotOpenError(event));
            _this.requestQueue.delete(key);
        });
    }
    if (this.responseQueue.size > 0) {
        this.responseQueue.forEach(function (request, key) {
            request.callback(errors.InvalidConnection('on WS', event));
            _this.responseQueue.delete(key);
        });
    }
    //clean connection on our own
    if (this.connection._connection) {
        this.connection._connection.removeAllListeners();
    }
    this.connection._client.removeAllListeners();
    this.connection._readyState = 3; // set readyState to CLOSED
    this.emit(this.CLOSE, event);
};
/**
 * Listener for the `close` event of the underlying WebSocket object
 *
 * @method _onClose
 *
 * @returns {void}
 */
WebsocketProvider.prototype._onClose = function (event) {
    var _this = this;
    if (this.reconnectOptions.auto && (![1000, 1001].includes(event.code) || event.wasClean === false)) {
        this.reconnect();
        return;
    }
    this.emit(this.CLOSE, event);
    if (this.requestQueue.size > 0) {
        this.requestQueue.forEach(function (request, key) {
            request.callback(errors.ConnectionNotOpenError(event));
            _this.requestQueue.delete(key);
        });
    }
    if (this.responseQueue.size > 0) {
        this.responseQueue.forEach(function (request, key) {
            request.callback(errors.InvalidConnection('on WS', event));
            _this.responseQueue.delete(key);
        });
    }
    this._removeSocketListeners();
    this.removeAllListeners();
};
/**
 * Will add the required socket listeners
 *
 * @method _addSocketListeners
 *
 * @returns {void}
 */
WebsocketProvider.prototype._addSocketListeners = function () {
    this.connection.addEventListener('message', this._onMessage.bind(this));
    this.connection.addEventListener('open', this._onConnect.bind(this));
    this.connection.addEventListener('close', this._onClose.bind(this));
    if (this.connection._client) {
        this.connection._client.removeAllListeners('connectFailed'); //Override the internal listeners, so they don't trigger a `close` event. We want to trigger `_onClose` manually with a description.
        this.connection._client.on('connectFailed', this._onConnectFailed.bind(this));
    }
};
/**
 * Will remove all socket listeners
 *
 * @method _removeSocketListeners
 *
 * @returns {void}
 */
WebsocketProvider.prototype._removeSocketListeners = function () {
    this.connection.removeEventListener('message', this._onMessage);
    this.connection.removeEventListener('open', this._onConnect);
    this.connection.removeEventListener('close', this._onClose);
    if (this.connection._connection)
        this.connection._client.removeListener('connectFailed', this._onConnectFailed);
};
/**
 * Will parse the response and make an array out of it.
 *
 * @method _parseResponse
 *
 * @param {String} data
 *
 * @returns {Array}
 */
WebsocketProvider.prototype._parseResponse = function (data) {
    var _this = this, returnValues = [];
    // DE-CHUNKER
    var dechunkedData = data
        .replace(/\}[\n\r]?\{/g, '}|--|{') // }{
        .replace(/\}\][\n\r]?\[\{/g, '}]|--|[{') // }][{
        .replace(/\}[\n\r]?\[\{/g, '}|--|[{') // }[{
        .replace(/\}\][\n\r]?\{/g, '}]|--|{') // }]{
        .split('|--|');
    dechunkedData.forEach(function (data) {
        // prepend the last chunk
        if (_this.lastChunk)
            data = _this.lastChunk + data;
        var result = null;
        try {
            result = JSON.parse(data);
        }
        catch (e) {
            _this.lastChunk = data;
            // start timeout to cancel all requests
            clearTimeout(_this.lastChunkTimeout);
            _this.lastChunkTimeout = setTimeout(function () {
                if (_this.reconnectOptions.auto && _this.reconnectOptions.onTimeout) {
                    _this.reconnect();
                    return;
                }
                _this.emit(_this.ERROR, errors.ConnectionTimeout(_this._customTimeout));
                if (_this.requestQueue.size > 0) {
                    _this.requestQueue.forEach(function (request, key) {
                        request.callback(errors.ConnectionTimeout(_this._customTimeout));
                        _this.requestQueue.delete(key);
                    });
                }
            }, _this._customTimeout);
            return;
        }
        // cancel timeout and set chunk to null
        clearTimeout(_this.lastChunkTimeout);
        _this.lastChunk = null;
        if (result)
            returnValues.push(result);
    });
    return returnValues;
};
/**
 * Does check if the provider is connecting and will add it to the queue or will send it directly
 *
 * @method send
 *
 * @param {Object} payload
 * @param {Function} callback
 *
 * @returns {void}
 */
WebsocketProvider.prototype.send = function (payload, callback) {
    var _this = this;
    var id = payload.id;
    var request = { payload: payload, callback: callback };
    if (Array.isArray(payload)) {
        id = payload[0].id;
    }
    if (this.connection.readyState === this.connection.CONNECTING || this.reconnecting) {
        this.requestQueue.set(id, request);
        return;
    }
    if (this.connection.readyState !== this.connection.OPEN) {
        this.requestQueue.delete(id);
        this.emit(this.ERROR, errors.ConnectionNotOpenError());
        request.callback(errors.ConnectionNotOpenError());
        return;
    }
    this.responseQueue.set(id, request);
    this.requestQueue.delete(id);
    try {
        this.connection.send(JSON.stringify(request.payload));
    }
    catch (error) {
        request.callback(error);
        _this.responseQueue.delete(id);
    }
};
/**
 * Resets the providers, clears all callbacks
 *
 * @method reset
 *
 * @returns {void}
 */
WebsocketProvider.prototype.reset = function () {
    this.responseQueue.clear();
    this.requestQueue.clear();
    this.removeAllListeners();
    this._removeSocketListeners();
    this._addSocketListeners();
};
/**
 * Closes the current connection with the given code and reason arguments
 *
 * @method disconnect
 *
 * @param {number} code
 * @param {string} reason
 *
 * @returns {void}
 */
WebsocketProvider.prototype.disconnect = function (code, reason) {
    this._removeSocketListeners();
    this.connection.close(code || 1000, reason);
};
/**
 * Returns the desired boolean.
 *
 * @method supportsSubscriptions
 *
 * @returns {boolean}
 */
WebsocketProvider.prototype.supportsSubscriptions = function () {
    return true;
};
/**
 * Removes the listeners and reconnects to the socket.
 *
 * @method reconnect
 *
 * @returns {void}
 */
WebsocketProvider.prototype.reconnect = function () {
    var _this = this;
    this.reconnecting = true;
    if (this.responseQueue.size > 0) {
        this.responseQueue.forEach(function (request, key) {
            try {
                _this.responseQueue.delete(key);
                request.callback(errors.PendingRequestsOnReconnectingError());
            }
            catch (e) {
                console.error("Error encountered in reconnect: ", e);
            }
        });
    }
    if (!this.reconnectOptions.maxAttempts ||
        this.reconnectAttempts < this.reconnectOptions.maxAttempts) {
        setTimeout(function () {
            _this.reconnectAttempts++;
            _this._removeSocketListeners();
            _this.emit(_this.RECONNECT, _this.reconnectAttempts);
            _this.connect();
        }, this.reconnectOptions.delay);
        return;
    }
    this.emit(this.ERROR, errors.MaxAttemptsReachedOnReconnectingError());
    this.reconnecting = false;
    if (this.requestQueue.size > 0) {
        this.requestQueue.forEach(function (request, key) {
            request.callback(errors.MaxAttemptsReachedOnReconnectingError());
            _this.requestQueue.delete(key);
        });
    }
};
module.exports = WebsocketProvider;


/***/ }),

/***/ 42658:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _globalThis;
if (typeof globalThis === 'object') {
	_globalThis = globalThis;
} else {
	try {
		_globalThis = __webpack_require__(79653);
	} catch (error) {
	} finally {
		if (!_globalThis && typeof window !== 'undefined') { _globalThis = window; }
		if (!_globalThis) { throw new Error('Could not determine global this'); }
	}
}

var NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;
var websocket_version = __webpack_require__(69533);


/**
 * Expose a W3C WebSocket class with just one or two arguments.
 */
function W3CWebSocket(uri, protocols) {
	var native_instance;

	if (protocols) {
		native_instance = new NativeWebSocket(uri, protocols);
	}
	else {
		native_instance = new NativeWebSocket(uri);
	}

	/**
	 * 'native_instance' is an instance of nativeWebSocket (the browser's WebSocket
	 * class). Since it is an Object it will be returned as it is when creating an
	 * instance of W3CWebSocket via 'new W3CWebSocket()'.
	 *
	 * ECMAScript 5: http://bclary.com/2004/11/07/#a-13.2.2
	 */
	return native_instance;
}
if (NativeWebSocket) {
	['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'].forEach(function(prop) {
		Object.defineProperty(W3CWebSocket, prop, {
			get: function() { return NativeWebSocket[prop]; }
		});
	});
}

/**
 * Module exports.
 */
module.exports = {
    'w3cwebsocket' : NativeWebSocket ? W3CWebSocket : null,
    'version'      : websocket_version
};


/***/ }),

/***/ 69533:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(82007).version;


/***/ }),

/***/ 91469:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var forEach = __webpack_require__(62979);
var availableTypedArrays = __webpack_require__(3089);
var callBind = __webpack_require__(26210);
var callBound = __webpack_require__(8507);
var gOPD = __webpack_require__(13367);

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = __webpack_require__(39639)();

var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;
var typedArrays = availableTypedArrays();

var $slice = callBound('String.prototype.slice');
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');

var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
	for (var i = 0; i < array.length; i += 1) {
		if (array[i] === value) {
			return i;
		}
	}
	return -1;
};
var cache = { __proto__: null };
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		if (Symbol.toStringTag in arr) {
			var proto = getPrototypeOf(arr);
			var descriptor = gOPD(proto, Symbol.toStringTag);
			if (!descriptor) {
				var superProto = getPrototypeOf(proto);
				descriptor = gOPD(superProto, Symbol.toStringTag);
			}
			cache['$' + typedArray] = callBind(descriptor.get);
		}
	});
} else {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		cache['$' + typedArray] = callBind(arr.slice);
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var found = false;
	forEach(cache, function (getter, typedArray) {
		if (!found) {
			try {
				if ('$' + getter(value) === typedArray) {
					found = $slice(typedArray, 1);
				}
			} catch (e) { /**/ }
		}
	});
	return found;
};

var trySlices = function tryAllSlices(value) {
	var found = false;
	forEach(cache, function (getter, name) {
		if (!found) {
			try {
				getter(value);
				found = $slice(name, 1);
			} catch (e) { /**/ }
		}
	});
	return found;
};

module.exports = function whichTypedArray(value) {
	if (!value || typeof value !== 'object') { return false; }
	if (!hasToStringTag) {
		var tag = $slice($toString(value), 8, -1);
		if ($indexOf(typedArrays, tag) > -1) {
			return tag;
		}
		if (tag !== 'Object') {
			return false;
		}
		// node < 0.6 hits here on real Typed Arrays
		return trySlices(value);
	}
	if (!gOPD) { return null; } // unknown engine
	return tryTypedArrays(value);
};


/***/ }),

/***/ 71285:
/***/ ((module) => {

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}


/***/ }),

/***/ 72675:
/***/ ((module) => {

"use strict";


module.exports = function () {
  throw new Error(
    'ws does not work in the browser. Browser clients must use the native ' +
      'WebSocket object'
  );
};


/***/ }),

/***/ 29790:
/***/ ((module) => {

module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}


/***/ }),

/***/ 81838:
/***/ ((module) => {

"use strict";


var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
  , length = 64
  , map = {}
  , seed = 0
  , i = 0
  , prev;

/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}

/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode(str) {
  var decoded = 0;

  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}

/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
  var now = encode(+new Date());

  if (now !== prev) return seed = 0, prev = now;
  return now +'.'+ encode(seed++);
}

//
// Map each character to its index.
//
for (; i < length; i++) map[alphabet[i]] = i;

//
// Expose the `yeast`, `encode` and `decode` functions.
//
yeast.encode = encode;
yeast.decode = decode;
module.exports = yeast;


/***/ }),

/***/ 99740:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/81476119d77e46ae4f25.svg";

/***/ }),

/***/ 19248:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/4c3cdc3e27c188162bc1.svg";

/***/ }),

/***/ 80307:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/8d0a705c69a78cfdee64.svg";

/***/ }),

/***/ 63433:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/eb4a50a93abc2842f0fb.svg";

/***/ }),

/***/ 44717:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/ea40bdfd3fb5ac25afac.svg";

/***/ }),

/***/ 3424:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/4824a77df5e47632844b.svg";

/***/ }),

/***/ 60321:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/7589dc3974f0e7d59889.svg";

/***/ }),

/***/ 92747:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/bcf16a8215bb8789ab01.svg";

/***/ }),

/***/ 49294:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/60fc382be22dba5a3cbe.svg";

/***/ }),

/***/ 21479:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/e0100225f8bc85f0167a.svg";

/***/ }),

/***/ 88230:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/9d278c2d676fb7de4dcd.svg";

/***/ }),

/***/ 6442:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/ce95a3395b8906e96480.svg";

/***/ }),

/***/ 93845:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/b350e8b4afc859f200d7.svg";

/***/ }),

/***/ 73565:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/43d83cad3c05d145998e.svg";

/***/ }),

/***/ 47093:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/4555ac5c86b05810dc14.svg";

/***/ }),

/***/ 32263:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/4b2a5b9803c6017cac41.svg";

/***/ }),

/***/ 667:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/11d9fb7af366124a9862.svg";

/***/ }),

/***/ 75185:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/cae94af7789399417ce2.svg";

/***/ }),

/***/ 76208:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/e184d93a4e52977f0994.svg";

/***/ }),

/***/ 46778:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/1e904912db17134f3c36.svg";

/***/ }),

/***/ 51702:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/3b55a3c504b506670570.svg";

/***/ }),

/***/ 84:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/0a311c363bb103ac41e3.svg";

/***/ }),

/***/ 51337:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/dbeadf0ec05aeb8e294f.svg";

/***/ }),

/***/ 89988:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/be7969dfc6081bcf9070.svg";

/***/ }),

/***/ 52426:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/a9ffd8003cab2cb93753.svg";

/***/ }),

/***/ 962:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/3f6182b395b15928e100.svg";

/***/ }),

/***/ 84011:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/a6e309792b5166ff5138.svg";

/***/ }),

/***/ 41984:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/0169fa3c218dad371c78.svg";

/***/ }),

/***/ 56025:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/b81957e765433e5834b9.svg";

/***/ }),

/***/ 38838:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/49b196b5af5a4a8db3d4.svg";

/***/ }),

/***/ 94091:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/4cdd64cf2b9ad6ce4c86.svg";

/***/ }),

/***/ 74796:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/b7db4b009df68e15ee16.svg";

/***/ }),

/***/ 89965:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/815ffb72839108eeac99.svg";

/***/ }),

/***/ 40233:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/8c535ec6a95da373df5a.svg";

/***/ }),

/***/ 87634:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/fbc0107c6efdd792cedd.svg";

/***/ }),

/***/ 93568:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/1678f00de99ee022c55e.svg";

/***/ }),

/***/ 24604:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/b487b7b7ee4d7f94d9bc.svg";

/***/ }),

/***/ 54878:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/420dd69a70f9c32b103b.svg";

/***/ }),

/***/ 78063:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/b1d27753bcb661107e3e.svg";

/***/ }),

/***/ 41854:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/cb5a85ca970763e322ce.svg";

/***/ }),

/***/ 14241:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/4f444abfc6cf78a2d34c.svg";

/***/ }),

/***/ 52684:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/2ab10f3101163f41b225.svg";

/***/ }),

/***/ 52924:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/94dba21809226690497f.svg";

/***/ }),

/***/ 47282:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/97e5f27fcb0bb090567e.svg";

/***/ }),

/***/ 16660:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/8665e903bccafe31a57f.svg";

/***/ }),

/***/ 20507:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/351207d6159aa96c9241.svg";

/***/ }),

/***/ 37279:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/b27b11c8e396bbcb725a.svg";

/***/ }),

/***/ 55143:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/1da25ada49915f1b34ed.svg";

/***/ }),

/***/ 90386:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/c56d9ec11c1d7f560e60.svg";

/***/ }),

/***/ 18219:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/c48b38d9cb938e9f94c2.svg";

/***/ }),

/***/ 42166:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/e763575fa1d4bc9db5fe.svg";

/***/ }),

/***/ 47226:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/860c7214595f30730ebc.svg";

/***/ }),

/***/ 36607:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/0105fc478d422238b663.svg";

/***/ }),

/***/ 50039:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/fd07f7e7eda2475269aa.svg";

/***/ }),

/***/ 55767:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/06de9ff5792b8dbf0a75.svg";

/***/ }),

/***/ 89654:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/0d31e3bf82a934b772aa.svg";

/***/ }),

/***/ 34206:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/3f7e90d54fd14660ebcd.svg";

/***/ }),

/***/ 6611:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/eb6fd0e89d65a49b01ec.svg";

/***/ }),

/***/ 92862:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/54fdeb622104624f8c38.svg";

/***/ }),

/***/ 83651:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/7d305d467a9c8c5ac483.svg";

/***/ }),

/***/ 83581:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/cf601b836fed9ddf9b47.svg";

/***/ }),

/***/ 36423:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/a6df182476f1514ac4c7.svg";

/***/ }),

/***/ 77247:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/cbae8d3bc8037f1a0aa2.svg";

/***/ }),

/***/ 53671:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/d7ea51dc08ba3b963da7.svg";

/***/ }),

/***/ 15965:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/799ce8628619697765ff.svg";

/***/ }),

/***/ 16880:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/96c6eb9e5d97c5715acb.svg";

/***/ }),

/***/ 67525:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/78c81a7c8345277e7a12.svg";

/***/ }),

/***/ 65261:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/d00ba34b86302a2f418f.svg";

/***/ }),

/***/ 72243:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/1e310e511eb7edbc23df.svg";

/***/ }),

/***/ 46850:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/eee31967b4a2c69f6a06.svg";

/***/ }),

/***/ 46700:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/8988b5904cbcec8bb5d2.svg";

/***/ }),

/***/ 78952:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/f54a8dcc25f09ac94f1b.svg";

/***/ }),

/***/ 77637:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/3969ce11511be81a9b76.svg";

/***/ }),

/***/ 4335:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/32f8c826de95d9e649b7.svg";

/***/ }),

/***/ 71553:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/e91c52be961ae12e1425.svg";

/***/ }),

/***/ 42371:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/5f534d083a5656ac1cba.svg";

/***/ }),

/***/ 32916:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/0641370c15130f83a2fa.svg";

/***/ }),

/***/ 5668:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/4d2320a50a58518d4e21.svg";

/***/ }),

/***/ 62210:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/e7c1f49eb3ffb33918b4.svg";

/***/ }),

/***/ 5703:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/4bb4146a70aa38a51227.svg";

/***/ }),

/***/ 99119:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/26ec602b9ee7e05aaef7.svg";

/***/ }),

/***/ 30228:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/bd9e01d6c4b85bb48b46.svg";

/***/ }),

/***/ 30445:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/e953f7b0e0aa46416f72.svg";

/***/ }),

/***/ 66043:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/ac494040510afb53644d.svg";

/***/ }),

/***/ 6731:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/6231104c11668c065dc9.svg";

/***/ }),

/***/ 33484:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/8b8f249785a9b95eef25.svg";

/***/ }),

/***/ 22845:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/caad244ce28de29a557e.svg";

/***/ }),

/***/ 20582:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/37bedb0c7e3928a11abb.svg";

/***/ }),

/***/ 27884:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/b3a665eb31570f59a3e7.svg";

/***/ }),

/***/ 66258:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/850f7d21693ca9d68f59.svg";

/***/ }),

/***/ 23251:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/21cbeab9f0210a7f137e.svg";

/***/ }),

/***/ 92814:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/ebded7ed3d9baa9cf46f.svg";

/***/ }),

/***/ 24608:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/1d8aedc387bdb622faaf.svg";

/***/ }),

/***/ 6576:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/0cd5781240ff162d6fdf.svg";

/***/ }),

/***/ 70948:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/d385cd845dfc601084fa.svg";

/***/ }),

/***/ 69722:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/236f42db39c64e3fb867.svg";

/***/ }),

/***/ 85976:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/92efa6225c2e07254c49.svg";

/***/ }),

/***/ 90601:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/e02b389717a6bd6c8ec5.svg";

/***/ }),

/***/ 65409:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/b422f960c33982f13bc8.svg";

/***/ }),

/***/ 82728:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/ce87c10c760f5773c4c7.svg";

/***/ }),

/***/ 23663:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/0fdef9d727d2fbdb93ca.svg";

/***/ }),

/***/ 64695:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/4e8a08d050dfc2546073.svg";

/***/ }),

/***/ 97772:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/f06d30c4b4e2a91f18c0.svg";

/***/ }),

/***/ 88541:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/3345b9484685bd92e1ea.svg";

/***/ }),

/***/ 18666:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/4a84e0c4df722f51d065.svg";

/***/ }),

/***/ 68582:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/3f0cbcabdd33026c4142.svg";

/***/ }),

/***/ 50845:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/2baee02b3b36eda50e8c.svg";

/***/ }),

/***/ 69891:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/e474112d22f0fdc90fa4.svg";

/***/ }),

/***/ 88192:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/c60309cbff2b6d1cf23c.svg";

/***/ }),

/***/ 17737:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/d3973271271a022bfc24.svg";

/***/ }),

/***/ 60568:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/b37bd7ef29e628f8b61a.svg";

/***/ }),

/***/ 59916:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/1cb004c95b11a62c4536.svg";

/***/ }),

/***/ 78080:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/fdb152c4ceab8b15f528.svg";

/***/ }),

/***/ 86398:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/a5a5d77fde700ad21a37.svg";

/***/ }),

/***/ 95820:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/b568aca31b25dc0e223d.svg";

/***/ }),

/***/ 59542:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/f332371c595c3fce2845.svg";

/***/ }),

/***/ 1759:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/a713d50ef4977dac6e84.svg";

/***/ }),

/***/ 72305:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/6b05c0da21803906a59e.svg";

/***/ }),

/***/ 5641:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/fefa2d491731ab6daed5.svg";

/***/ }),

/***/ 18033:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/52cbe52770849692410c.svg";

/***/ }),

/***/ 63932:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/c57f387db418cf9869a7.svg";

/***/ }),

/***/ 93899:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/72dfe10a093811487a1d.svg";

/***/ }),

/***/ 38101:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/603913e001ea25b7ece8.svg";

/***/ }),

/***/ 74640:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/c33d96b5558cbaf96235.svg";

/***/ }),

/***/ 41371:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/8381076c16bbcfb52570.svg";

/***/ }),

/***/ 32728:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/08392d718d2508c016c4.svg";

/***/ }),

/***/ 98592:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/d75d5006735a47c4474b.svg";

/***/ }),

/***/ 42513:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/aa1f7ef7fbd604df204c.svg";

/***/ }),

/***/ 75524:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/8b5ee9431b40dbe3a51b.svg";

/***/ }),

/***/ 928:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/64e9c3573cf4eaa8bf24.svg";

/***/ }),

/***/ 37501:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/26d8744df234851e4e8f.svg";

/***/ }),

/***/ 75250:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/59c7fd65f4dad4cd069f.svg";

/***/ }),

/***/ 79688:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/99d7f00bd49bd96f30ac.svg";

/***/ }),

/***/ 71514:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/e8f1a4dbda90a0fbc528.svg";

/***/ }),

/***/ 41754:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/6a3fae79f91b42e4c39a.svg";

/***/ }),

/***/ 68540:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/a7a5d5ea9f8db8353af1.svg";

/***/ }),

/***/ 36976:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/281a67f73e1fbfe6228d.svg";

/***/ }),

/***/ 27737:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/1db65721ee43e1fdf733.svg";

/***/ }),

/***/ 75018:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/a8ec944ed493aa3b6363.svg";

/***/ }),

/***/ 95876:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/6cefd6b002b81e78657f.svg";

/***/ }),

/***/ 75746:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/a13b19c1e0e0cf1d49ac.svg";

/***/ }),

/***/ 84826:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/d77763ee138604229d69.svg";

/***/ }),

/***/ 51940:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/8e48474be57f20b9ceb9.svg";

/***/ }),

/***/ 71632:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/7c2fcd8478cf826ba065.svg";

/***/ }),

/***/ 87654:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/34899107ce8e62f047a2.svg";

/***/ }),

/***/ 69564:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/f87ebe4e4f5bb4547e03.svg";

/***/ }),

/***/ 57208:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/261697ae2f6bfdc62f0b.svg";

/***/ }),

/***/ 97560:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/3b2eb68ea991917c0a2b.svg";

/***/ }),

/***/ 64970:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/53aedff1de497f4fccaf.svg";

/***/ }),

/***/ 65226:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/f503a20652b35b1844dc.svg";

/***/ }),

/***/ 5289:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/3278fff5eb7f39f6ce89.svg";

/***/ }),

/***/ 68118:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/1696f65fee6066daeaca.svg";

/***/ }),

/***/ 97406:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/1519fbd550cde1b5d87c.svg";

/***/ }),

/***/ 5720:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/9d6a64120fe10c5208bc.svg";

/***/ }),

/***/ 82112:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/2cf6185a203c483fc08d.svg";

/***/ }),

/***/ 34166:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/e835632efe81e95d00e6.svg";

/***/ }),

/***/ 69484:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/ccf237d06fcd1c2b7159.svg";

/***/ }),

/***/ 57418:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/d01a3738e9a304361d7f.svg";

/***/ }),

/***/ 60737:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/6accc0e71c1faeedcec1.svg";

/***/ }),

/***/ 98331:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/b5ae74c4ee66f4dfe8fe.svg";

/***/ }),

/***/ 52122:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/9907a58188967fdd264c.svg";

/***/ }),

/***/ 31967:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/4b18a4a7462505c505c8.svg";

/***/ }),

/***/ 97234:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/06bab1e6ce3c49d7df39.svg";

/***/ }),

/***/ 94706:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/1a60df2c23cb66c7f566.svg";

/***/ }),

/***/ 89869:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/06949ee1b4c2316e461f.svg";

/***/ }),

/***/ 78264:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/72a9e86a6a7ec9a05734.svg";

/***/ }),

/***/ 73073:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/c85c71f79b330906030e.svg";

/***/ }),

/***/ 89038:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/c95c0f06b1a11aab987d.svg";

/***/ }),

/***/ 7652:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/eb9e2d949a0ef904712c.svg";

/***/ }),

/***/ 20023:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/6e44a760332fc9c81400.svg";

/***/ }),

/***/ 61122:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/06793bed97207a49a78f.svg";

/***/ }),

/***/ 31395:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/50da02ac43a895550aad.svg";

/***/ }),

/***/ 2963:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/ec0dd532c529a0d83dec.svg";

/***/ }),

/***/ 20126:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/8d07f7f04249ff778b23.svg";

/***/ }),

/***/ 72851:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/38fc05cc229fa9987d4f.svg";

/***/ }),

/***/ 43908:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/92886b7e2c86d7f4b265.svg";

/***/ }),

/***/ 19762:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/929108fb9ea8292a37ad.svg";

/***/ }),

/***/ 43878:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/3f39105b1045655dcd4f.svg";

/***/ }),

/***/ 88107:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/ed136d2a95c624255ed5.svg";

/***/ }),

/***/ 61804:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/1515109164001012ccd6.svg";

/***/ }),

/***/ 95856:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/7aea26cc866f09b5378c.svg";

/***/ }),

/***/ 82627:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/96d0f4d05e91a5e310ce.svg";

/***/ }),

/***/ 58905:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/30679948ac1a1794bb5d.svg";

/***/ }),

/***/ 93656:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/aefe25cbb5d0405b21d7.svg";

/***/ }),

/***/ 69820:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/8f42f3b665705a56c734.svg";

/***/ }),

/***/ 29665:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/e512bfd842f46e95444b.svg";

/***/ }),

/***/ 72333:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/523c3f9bdb09a2710275.svg";

/***/ }),

/***/ 60130:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/48e2b15afaa597e7f9ce.svg";

/***/ }),

/***/ 1339:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/2e78e7584599246fd98a.svg";

/***/ }),

/***/ 35786:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/0daa9fb3d002f76ff7f9.svg";

/***/ }),

/***/ 32722:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/a84f51fe7c30e358a2a5.svg";

/***/ }),

/***/ 17478:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/daaa627afbc28a36893a.svg";

/***/ }),

/***/ 30790:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/92319a9b699f3f87186e.svg";

/***/ }),

/***/ 84147:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/72387178b0e40567da2f.svg";

/***/ }),

/***/ 3901:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/f0a542644afffdf16372.svg";

/***/ }),

/***/ 59737:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/cecbb3b8b954ce0f0d18.svg";

/***/ }),

/***/ 94299:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/011ea72d939f145ef361.svg";

/***/ }),

/***/ 9897:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/7749e1376a1f851c91d6.svg";

/***/ }),

/***/ 68977:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/689ad4fac4fdaff15635.svg";

/***/ }),

/***/ 27959:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/1d3e8ab0295227f74267.svg";

/***/ }),

/***/ 24239:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/e0ab013223f69da04ee2.svg";

/***/ }),

/***/ 7942:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/4a9dd3b3b865197807f2.svg";

/***/ }),

/***/ 38485:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/8dd1ed27b76f9360d190.svg";

/***/ }),

/***/ 79593:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/5b65af94241bea74aaf9.svg";

/***/ }),

/***/ 34558:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/994d7439213364fc10c9.svg";

/***/ }),

/***/ 79970:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/53ae219d93e9932528ad.svg";

/***/ }),

/***/ 92242:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/efe236a735da67ff2807.svg";

/***/ }),

/***/ 58177:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/4405c82922c2748017e0.svg";

/***/ }),

/***/ 10572:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/3802dfabec44f67775c1.svg";

/***/ }),

/***/ 19011:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/b48748af313475f1d2e7.svg";

/***/ }),

/***/ 40596:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/12bc04258f0fd29bc096.svg";

/***/ }),

/***/ 80490:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/cf852cca7f0888969da8.svg";

/***/ }),

/***/ 52796:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/4a0345392d63d4095d10.svg";

/***/ }),

/***/ 71322:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/e0c89d7579b84f3260ab.svg";

/***/ }),

/***/ 19083:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/308ad4b1115e6390de1c.svg";

/***/ }),

/***/ 76080:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/58e7ac74e600d306e7ee.svg";

/***/ }),

/***/ 85091:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/c74e1398c2aeda037427.svg";

/***/ }),

/***/ 84989:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/77ee1ffcbfe1d8ce0e1b.svg";

/***/ }),

/***/ 71963:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/0b7ad17f2d6bad6e809b.svg";

/***/ }),

/***/ 98365:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/ee8ed91422ee2b71d0a6.svg";

/***/ }),

/***/ 38035:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/d8b0d20948568f118d84.svg";

/***/ }),

/***/ 5777:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/bd1de63d5e9d737ac5b8.svg";

/***/ }),

/***/ 4821:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/bb23be05adf909928ad3.svg";

/***/ }),

/***/ 12051:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/512331aadb5ee2231244.svg";

/***/ }),

/***/ 69846:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/df716229c90e5023dc24.svg";

/***/ }),

/***/ 50183:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/1921eca1822f320e6231.svg";

/***/ }),

/***/ 20277:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/e28fe903f325dbf7e399.svg";

/***/ }),

/***/ 85782:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/3044631dc9f8a7c7c581.svg";

/***/ }),

/***/ 61130:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/9422f34f554ccb76e0ac.svg";

/***/ }),

/***/ 89743:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/d043e1cfcb106a5d96d2.svg";

/***/ }),

/***/ 84023:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/535867ceb1e4747d467d.svg";

/***/ }),

/***/ 60009:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/5cc171ee81419ad92ac3.svg";

/***/ }),

/***/ 93173:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/1030b651d801de692ed4.svg";

/***/ }),

/***/ 11268:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/05ee13941b90ff962802.svg";

/***/ }),

/***/ 50580:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/668db7f31b7258ceb3e5.svg";

/***/ }),

/***/ 32658:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/bba5b5b08416a958614f.svg";

/***/ }),

/***/ 30762:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/f56a61b491ad4ee669e5.svg";

/***/ }),

/***/ 41617:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/cf852cca7f0888969da8.svg";

/***/ }),

/***/ 28331:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/a9a926b7e906fbdd7267.svg";

/***/ }),

/***/ 90094:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/b37203f1dfc15f134209.svg";

/***/ }),

/***/ 63919:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/0e8eb0188a957034b6cb.svg";

/***/ }),

/***/ 88703:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/1e86f0ee8bf616e832ac.svg";

/***/ }),

/***/ 30670:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/586d4dbccfd1c9a485f8.svg";

/***/ }),

/***/ 67925:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/dc1ef1e8364829efe910.svg";

/***/ }),

/***/ 79854:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/744429e1ecb568111a05.svg";

/***/ }),

/***/ 98970:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/8015c25a64c3834c87e8.svg";

/***/ }),

/***/ 82614:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/d93b8ef994f5a24451de.svg";

/***/ }),

/***/ 5285:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/86f546f0b5f1bb9d7b53.svg";

/***/ }),

/***/ 25691:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/be0aa4732920cca42013.svg";

/***/ }),

/***/ 72636:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/7fb51494e21471c535b8.svg";

/***/ }),

/***/ 72261:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/1373ee6b2ba4ec8705c5.svg";

/***/ }),

/***/ 82268:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/8ba0bb44953ed6645ecc.svg";

/***/ }),

/***/ 90963:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/5273ee13be5cd63fe8d8.svg";

/***/ }),

/***/ 87590:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/54de32e03b36c2e92624.svg";

/***/ }),

/***/ 10849:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/f0c24ea2e92d762dd104.svg";

/***/ }),

/***/ 12414:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/100ac81c35dab7e74f9c.svg";

/***/ }),

/***/ 2329:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/4798aae159f5886fdebc.svg";

/***/ }),

/***/ 11238:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/7cbdabc10c223b1013c2.svg";

/***/ }),

/***/ 16066:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/14d63982713beec2f3d6.svg";

/***/ }),

/***/ 76435:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/2fa7f0607c3fbddd375b.svg";

/***/ }),

/***/ 75653:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/ea38c617151a581fb872.svg";

/***/ }),

/***/ 97420:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/058945230dfd49860f34.svg";

/***/ }),

/***/ 64831:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/b27fb9eece26318759f8.svg";

/***/ }),

/***/ 33056:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/6d21fcd324d36e7024ae.svg";

/***/ }),

/***/ 20061:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/da065553f7b5056957b3.svg";

/***/ }),

/***/ 78826:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/ee8ed91422ee2b71d0a6.svg";

/***/ }),

/***/ 11892:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/e1d47d0caca28246d754.svg";

/***/ }),

/***/ 81107:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/cfb325d4ed0b72a29dec.svg";

/***/ }),

/***/ 20987:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/d2a1b9b2f0979760c20e.svg";

/***/ }),

/***/ 50267:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/be4531487133c43d9d8c.svg";

/***/ }),

/***/ 90704:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/f77f10cf4c2aabfde5de.svg";

/***/ }),

/***/ 20055:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/c6f4e28f7a956185df1e.svg";

/***/ }),

/***/ 64454:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/6b927b48ac81d9d95d97.svg";

/***/ }),

/***/ 7798:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/1765e44a5e209933843b.svg";

/***/ }),

/***/ 36303:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/59ea40cda4f2bc77a912.svg";

/***/ }),

/***/ 8670:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/f90e877ed5b244a7ba37.svg";

/***/ }),

/***/ 84207:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/1fe8c3d9e4273b4752ad.svg";

/***/ }),

/***/ 58946:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/4afbee1230209af117d3.svg";

/***/ }),

/***/ 31827:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/9807d5d23a84e69c7415.svg";

/***/ }),

/***/ 82869:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/a4bcc0a098020a5a000c.svg";

/***/ }),

/***/ 21210:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/c5d3d0a3e27bb23e41f2.svg";

/***/ }),

/***/ 69557:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/7932d3a03cb99291c96b.svg";

/***/ }),

/***/ 14368:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/3e8f24dcd5438826ee37.svg";

/***/ }),

/***/ 15593:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/7f3ffa8f459b394a850f.svg";

/***/ }),

/***/ 19986:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/1c1350b978981155e793.svg";

/***/ }),

/***/ 96712:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/9f6b9e01fe2a1c21a197.svg";

/***/ }),

/***/ 41733:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/806afa9d4fc8dcdab76f.svg";

/***/ }),

/***/ 75828:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/1ff0a975bfb14dae08f7.svg";

/***/ }),

/***/ 8226:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/4708b9f2cfc60f607a9d.svg";

/***/ }),

/***/ 40423:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/f49dfacb4d8a3c365f12.svg";

/***/ }),

/***/ 89279:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/dcf1130654a6a5116a00.svg";

/***/ }),

/***/ 52127:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/72a9e86a6a7ec9a05734.svg";

/***/ }),

/***/ 27778:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/6dc4384737d3e9c09117.svg";

/***/ }),

/***/ 80987:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/dfb28b8fe25932a596ab.svg";

/***/ }),

/***/ 53760:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/84d6f170659f0bf223a1.svg";

/***/ }),

/***/ 41440:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/9e35e7111facb265a7e3.svg";

/***/ }),

/***/ 27980:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/16d1097394ec7df5ce89.svg";

/***/ }),

/***/ 60398:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/754ee8dec598813faff2.svg";

/***/ }),

/***/ 37270:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/caeb17c72a045ab67fe8.svg";

/***/ }),

/***/ 82930:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/b225329b97b9cb3eccb2.svg";

/***/ }),

/***/ 66251:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/d345d4db088a334ab20f.svg";

/***/ }),

/***/ 43440:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/3ac2354cb30dbad68e7e.svg";

/***/ }),

/***/ 82802:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/da5d4c648b701df1101c.svg";

/***/ }),

/***/ 30672:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/7dad2403109a7f56fd51.svg";

/***/ }),

/***/ 22274:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/3914a2e4a71d68e217e8.svg";

/***/ }),

/***/ 89302:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/b31ce198e867c1f6e8b6.svg";

/***/ }),

/***/ 8556:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/879e3e538d8f4d7b2db2.svg";

/***/ }),

/***/ 77597:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/093bd1a112c1c168201b.svg";

/***/ }),

/***/ 63443:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/52675ba3f81cc17e6337.svg";

/***/ }),

/***/ 20840:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/0557cacd23e6aaf683d4.svg";

/***/ }),

/***/ 43728:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/059046d3dc5a44daf667.svg";

/***/ }),

/***/ 54711:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/c64afc612ab8a8bcd7f7.svg";

/***/ }),

/***/ 40062:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/75e85fbfa69131a3c4d5.svg";

/***/ }),

/***/ 80963:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/fe28fbf14de1fd589548.svg";

/***/ }),

/***/ 93923:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/b350e8b4afc859f200d7.svg";

/***/ }),

/***/ 77739:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/3f66f4598525f8a44eb7.svg";

/***/ }),

/***/ 64948:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/494826f2aab91ee8cf5b.svg";

/***/ }),

/***/ 60184:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/34d93d5d00ae2ce90f07.svg";

/***/ }),

/***/ 77213:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/8fed51a5886fcfaa69d2.svg";

/***/ }),

/***/ 73808:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/ecb7ff5ba244a1517f07.svg";

/***/ }),

/***/ 10922:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/fac8724ac698d1c38271.svg";

/***/ }),

/***/ 77986:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/ed7d11c35715ed12914a.svg";

/***/ }),

/***/ 78674:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/d74495df2f5a46a9ce7c.svg";

/***/ }),

/***/ 43785:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/51858bd0f6bfa85ce6c6.svg";

/***/ }),

/***/ 32649:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/e3c0e567ef47cf14a5cb.svg";

/***/ }),

/***/ 50426:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/0ccf959067f23c702390.svg";

/***/ }),

/***/ 1263:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/c26c6914ad5e47691cbe.svg";

/***/ }),

/***/ 92346:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/b45474adb0009b90a723.svg";

/***/ }),

/***/ 51221:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/df823dd3bbff36b65f34.svg";

/***/ }),

/***/ 80959:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/791c352d610efc9ea3f6.svg";

/***/ }),

/***/ 43311:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/4a813d02ee800290c550.svg";

/***/ }),

/***/ 18836:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/bef3306e89220fc0710b.svg";

/***/ }),

/***/ 65442:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/685379e5a567608fb04c.svg";

/***/ }),

/***/ 3450:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/59de656ef7b13b6daa00.svg";

/***/ }),

/***/ 1915:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/d8d661aa91b68bdba3be.svg";

/***/ }),

/***/ 15905:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/1a46c477572b6d7c7da4.svg";

/***/ }),

/***/ 50690:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/6d14e8f1a3f2d6e9c844.svg";

/***/ }),

/***/ 71852:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/6a41309b7065146fde24.svg";

/***/ }),

/***/ 85751:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/8e827e236fa6e0efa6e5.svg";

/***/ }),

/***/ 23862:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/c2d514d57af7155988db.svg";

/***/ }),

/***/ 68560:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/3a9875e9f49aafa63e74.svg";

/***/ }),

/***/ 99123:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/1a2abe53268039969384.svg";

/***/ }),

/***/ 49806:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/3869743e3aea73bcfdbc.svg";

/***/ }),

/***/ 82735:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/bc9570a76392ed1b5efa.svg";

/***/ }),

/***/ 17794:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/d2218bcfc41b447f53cf.svg";

/***/ }),

/***/ 1597:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/aed0a027a355f84be4ec.svg";

/***/ }),

/***/ 40063:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/591a8d039ac5e921edf9.svg";

/***/ }),

/***/ 8223:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/1903d2d66de04764b9b9.svg";

/***/ }),

/***/ 64223:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/7b789c24e525df0b31a9.svg";

/***/ }),

/***/ 51495:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/b7feea70c840add093f0.svg";

/***/ }),

/***/ 50821:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/d417375fffc0d86aba58.svg";

/***/ }),

/***/ 21930:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/159b6ab3863c4c37c466.svg";

/***/ }),

/***/ 58407:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/12957e2b3e670965cf3f.svg";

/***/ }),

/***/ 85496:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/b4acd68d550cb17e688e.svg";

/***/ }),

/***/ 84889:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/091b316096db57d738d5.svg";

/***/ }),

/***/ 7901:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/c82aff34059dcd4882ec.svg";

/***/ }),

/***/ 59790:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/5828d507a7b2e4d27d1b.svg";

/***/ }),

/***/ 64486:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/28f796265ccda8773e53.svg";

/***/ }),

/***/ 21586:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/e8e9d9c0f3dcfeaa401a.svg";

/***/ }),

/***/ 5026:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/56a8de0f326650b88a51.svg";

/***/ }),

/***/ 77340:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/a0f07e7942b3122c139a.svg";

/***/ }),

/***/ 90135:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/9da3c7636f82793db170.svg";

/***/ }),

/***/ 78637:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/a1a78bb1426420f8468e.svg";

/***/ }),

/***/ 86320:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/68f7a9bc2e9f63aaaf51.svg";

/***/ }),

/***/ 37968:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/9a06c1796ff42575aaf7.svg";

/***/ }),

/***/ 51678:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/e0f98c9dcb867e7d990e.svg";

/***/ }),

/***/ 82157:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/1b34413890f42f616df3.svg";

/***/ }),

/***/ 6172:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/44e11c4809958ae6ae1d.svg";

/***/ }),

/***/ 14767:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/087ef94e60011bf6760c.svg";

/***/ }),

/***/ 44186:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/4855302241b35de1633d.svg";

/***/ }),

/***/ 65649:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/ad5c6161ae3692817274.svg";

/***/ }),

/***/ 3474:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/b5c8e85dc740123b8671.svg";

/***/ }),

/***/ 43771:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/82f623abab3979dce1be.svg";

/***/ }),

/***/ 9509:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/4f70f4be56b565686991.svg";

/***/ }),

/***/ 28638:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/e60eadded54942e7a746.svg";

/***/ }),

/***/ 60520:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/b86826780483e7685e00.svg";

/***/ }),

/***/ 37471:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/8bb703479e7424d78dec.svg";

/***/ }),

/***/ 42333:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/091f7b8291c08192321d.svg";

/***/ }),

/***/ 17555:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/e1e8e3db4a117e3ac2f3.svg";

/***/ }),

/***/ 71381:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/b8bc8b3693e9e78cfec8.svg";

/***/ }),

/***/ 31731:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/fb1bfaba14ae9c33f0b1.svg";

/***/ }),

/***/ 34621:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/f752544dc1064967d742.svg";

/***/ }),

/***/ 95605:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/71997d0b1743357e5f8f.svg";

/***/ }),

/***/ 52878:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/cafe36168737619a7800.svg";

/***/ }),

/***/ 39691:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/b9619683df4575225539.svg";

/***/ }),

/***/ 5960:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/c944e12ed4a638e8c188.svg";

/***/ }),

/***/ 61968:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/f49ade5dd2da26c4ea33.svg";

/***/ }),

/***/ 99024:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/f488b7859084ce46ffc5.svg";

/***/ }),

/***/ 58220:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/c069039762df6dc92783.svg";

/***/ }),

/***/ 28862:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/1be2da346a948fed6dad.svg";

/***/ }),

/***/ 59067:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/7ea70acb5716ec1e7ed9.svg";

/***/ }),

/***/ 59165:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/03ac5de045e4b30fb6a6.svg";

/***/ }),

/***/ 5537:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/882da129539e3be74f0d.svg";

/***/ }),

/***/ 61330:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/482038c8597672fb48c8.svg";

/***/ }),

/***/ 50485:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/7cc24f733244d7b14984.svg";

/***/ }),

/***/ 33561:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/4f7cfb8b987aac6e2ac6.svg";

/***/ }),

/***/ 46832:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/7b3bbd33f3814c227a9b.svg";

/***/ }),

/***/ 64311:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/fec23fb53a4e8e3b7bf6.svg";

/***/ }),

/***/ 11322:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/7c46f48c5fd9ab476b7d.svg";

/***/ }),

/***/ 46925:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/9c767df600fe773f47b5.svg";

/***/ }),

/***/ 56041:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/77ab2868b13ae2dda2ff.svg";

/***/ }),

/***/ 7952:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/577d0e5c75bd2e4c0b12.svg";

/***/ }),

/***/ 29604:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/f7f2e488d2de59054c87.svg";

/***/ }),

/***/ 94377:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/a85a115abfbe0c3e2904.svg";

/***/ }),

/***/ 2107:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/ef9a2a9c57d919f734b5.svg";

/***/ }),

/***/ 80058:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/cb8d49f83d4b328fae48.png";

/***/ }),

/***/ 58543:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/e5bb5330b8a782824f4c.png";

/***/ }),

/***/ 33379:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/c8c7c32b0a343f281c6e.png";

/***/ }),

/***/ 38282:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/884ed01c61bbab8e524c.png";

/***/ }),

/***/ 32761:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/361479c7d701f3e15de4.png";

/***/ }),

/***/ 13387:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/7682ebd4b49ad81cc09c.png";

/***/ }),

/***/ 22550:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/3567e2258b9549d45ff3.png";

/***/ }),

/***/ 89559:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/6a7cd5f6fec1123f655e.png";

/***/ }),

/***/ 20523:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/b8cbf2d6b6928d732fc9.png";

/***/ }),

/***/ 49650:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/7d24922a6c6a6ee206bc.png";

/***/ }),

/***/ 84535:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/0eaf2877382deb7be052.png";

/***/ }),

/***/ 98960:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/18cc1e9593c98f12a941.png";

/***/ }),

/***/ 47196:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/d05bb282d47a9239d673.png";

/***/ }),

/***/ 51245:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/1b9e652eef75c053b6ca.png";

/***/ }),

/***/ 78973:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/d05bb282d47a9239d673.png";

/***/ }),

/***/ 87361:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/b5dfb16729ebae3d5da0.png";

/***/ }),

/***/ 99714:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/77e2ab89b7b40d3aa60e.png";

/***/ }),

/***/ 18787:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/936742645a844ea1e748.png";

/***/ }),

/***/ 65718:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/37e4f7c89a569c84ae97.png";

/***/ }),

/***/ 92869:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/4d57ad1a0f879f6c7da8.png";

/***/ }),

/***/ 40852:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/1ab58a34a0022249600a.png";

/***/ }),

/***/ 31337:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/f4d9edee12b803640d6f.png";

/***/ }),

/***/ 6466:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/107df702e4571133040f.png";

/***/ }),

/***/ 75035:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/3b76af6b82452778bfe2.png";

/***/ }),

/***/ 28233:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/c37c12e053b365886e10.png";

/***/ }),

/***/ 81679:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/3d01e86a259f5c08325b.png";

/***/ }),

/***/ 6510:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/e151ef2b82727c3881e1.png";

/***/ }),

/***/ 65531:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/0c3b46b836f44283e009.png";

/***/ }),

/***/ 15861:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/625b21693ea176a83262.png";

/***/ }),

/***/ 69553:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/1de6dd0005bb179fcfde.png";

/***/ }),

/***/ 62939:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/5606bd8354875c55c2bf.png";

/***/ }),

/***/ 58439:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/f1663665b45324754111.png";

/***/ }),

/***/ 18502:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/0b0a54d8df125d5cc820.png";

/***/ }),

/***/ 46141:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/5f9d6344e4c2fbc6a8d3.png";

/***/ }),

/***/ 80130:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/90176527092abba269c4.png";

/***/ }),

/***/ 49683:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/1cb7de56917987650812.png";

/***/ }),

/***/ 16012:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/381facf3730db44829a1.png";

/***/ }),

/***/ 34180:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/5923a119357ae9c12444.png";

/***/ }),

/***/ 21532:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/75862cc182d1478421f8.png";

/***/ }),

/***/ 10206:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/677ac7372ac1cf75e836.png";

/***/ }),

/***/ 91055:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/a24762f140ed780fcfcb.png";

/***/ }),

/***/ 61800:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/5fa7c3a5fd9ba7e5db31.png";

/***/ }),

/***/ 81334:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/02cdbc5891db6578734e.png";

/***/ }),

/***/ 95945:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/7df8fdabbbb222480c26.png";

/***/ }),

/***/ 92259:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/be4f7c820e3639bda615.png";

/***/ }),

/***/ 90178:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/3e3fcdcaa97ce99f0470.png";

/***/ }),

/***/ 8177:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/e4133bdbc8e9e4f57e37.png";

/***/ }),

/***/ 79615:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/4b5609544824a751317a.png";

/***/ }),

/***/ 66222:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/9109df9d58e6e463ea97.png";

/***/ }),

/***/ 42642:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/421018e3c23dc5f8b067.png";

/***/ }),

/***/ 18095:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/1f3c8830105a02615880.png";

/***/ }),

/***/ 21740:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/b85ae831340ec901be3d.png";

/***/ }),

/***/ 83409:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/814b73a8315916478992.png";

/***/ }),

/***/ 78546:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/0c3b46b836f44283e009.png";

/***/ }),

/***/ 13292:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/5923a119357ae9c12444.png";

/***/ }),

/***/ 16474:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/ddde651119bbc0eb87ab.png";

/***/ }),

/***/ 8277:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/6e3a870c629ccaf7631c.png";

/***/ }),

/***/ 52201:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/d4d166f1ab62db1505bb.png";

/***/ }),

/***/ 25170:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/13bf9aaeb43e434dfb3f.png";

/***/ }),

/***/ 85898:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 44087:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 10985:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 11314:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 79391:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 81388:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 47840:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 57002:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 16347:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 66988:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 45210:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 84232:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 14050:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 88941:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 54504:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 87942:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 82880:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 39201:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 3089:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var possibleNames = [
	'BigInt64Array',
	'BigUint64Array',
	'Float32Array',
	'Float64Array',
	'Int16Array',
	'Int32Array',
	'Int8Array',
	'Uint16Array',
	'Uint32Array',
	'Uint8Array',
	'Uint8ClampedArray'
];

var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;

module.exports = function availableTypedArrays() {
	var out = [];
	for (var i = 0; i < possibleNames.length; i++) {
		if (typeof g[possibleNames[i]] === 'function') {
			out[out.length] = possibleNames[i];
		}
	}
	return out;
};


/***/ }),

/***/ 80839:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const format = __webpack_require__(15955)

module.exports = pino

const _console = pfGlobalThisOrFallback().console || {}
const stdSerializers = {
  mapHttpRequest: mock,
  mapHttpResponse: mock,
  wrapRequestSerializer: passthrough,
  wrapResponseSerializer: passthrough,
  wrapErrorSerializer: passthrough,
  req: mock,
  res: mock,
  err: asErrValue
}

function shouldSerialize (serialize, serializers) {
  if (Array.isArray(serialize)) {
    const hasToFilter = serialize.filter(function (k) {
      return k !== '!stdSerializers.err'
    })
    return hasToFilter
  } else if (serialize === true) {
    return Object.keys(serializers)
  }

  return false
}

function pino (opts) {
  opts = opts || {}
  opts.browser = opts.browser || {}

  const transmit = opts.browser.transmit
  if (transmit && typeof transmit.send !== 'function') { throw Error('pino: transmit option must have a send function') }

  const proto = opts.browser.write || _console
  if (opts.browser.write) opts.browser.asObject = true
  const serializers = opts.serializers || {}
  const serialize = shouldSerialize(opts.browser.serialize, serializers)
  let stdErrSerialize = opts.browser.serialize

  if (
    Array.isArray(opts.browser.serialize) &&
    opts.browser.serialize.indexOf('!stdSerializers.err') > -1
  ) stdErrSerialize = false

  const levels = ['error', 'fatal', 'warn', 'info', 'debug', 'trace']

  if (typeof proto === 'function') {
    proto.error = proto.fatal = proto.warn =
    proto.info = proto.debug = proto.trace = proto
  }
  if (opts.enabled === false) opts.level = 'silent'
  const level = opts.level || 'info'
  const logger = Object.create(proto)
  if (!logger.log) logger.log = noop

  Object.defineProperty(logger, 'levelVal', {
    get: getLevelVal
  })
  Object.defineProperty(logger, 'level', {
    get: getLevel,
    set: setLevel
  })

  const setOpts = {
    transmit,
    serialize,
    asObject: opts.browser.asObject,
    levels,
    timestamp: getTimeFunction(opts)
  }
  logger.levels = pino.levels
  logger.level = level

  logger.setMaxListeners = logger.getMaxListeners =
  logger.emit = logger.addListener = logger.on =
  logger.prependListener = logger.once =
  logger.prependOnceListener = logger.removeListener =
  logger.removeAllListeners = logger.listeners =
  logger.listenerCount = logger.eventNames =
  logger.write = logger.flush = noop
  logger.serializers = serializers
  logger._serialize = serialize
  logger._stdErrSerialize = stdErrSerialize
  logger.child = child

  if (transmit) logger._logEvent = createLogEventShape()

  function getLevelVal () {
    return this.level === 'silent'
      ? Infinity
      : this.levels.values[this.level]
  }

  function getLevel () {
    return this._level
  }
  function setLevel (level) {
    if (level !== 'silent' && !this.levels.values[level]) {
      throw Error('unknown level ' + level)
    }
    this._level = level

    set(setOpts, logger, 'error', 'log') // <-- must stay first
    set(setOpts, logger, 'fatal', 'error')
    set(setOpts, logger, 'warn', 'error')
    set(setOpts, logger, 'info', 'log')
    set(setOpts, logger, 'debug', 'log')
    set(setOpts, logger, 'trace', 'log')
  }

  function child (bindings, childOptions) {
    if (!bindings) {
      throw new Error('missing bindings for child Pino')
    }
    childOptions = childOptions || {}
    if (serialize && bindings.serializers) {
      childOptions.serializers = bindings.serializers
    }
    const childOptionsSerializers = childOptions.serializers
    if (serialize && childOptionsSerializers) {
      var childSerializers = Object.assign({}, serializers, childOptionsSerializers)
      var childSerialize = opts.browser.serialize === true
        ? Object.keys(childSerializers)
        : serialize
      delete bindings.serializers
      applySerializers([bindings], childSerialize, childSerializers, this._stdErrSerialize)
    }
    function Child (parent) {
      this._childLevel = (parent._childLevel | 0) + 1
      this.error = bind(parent, bindings, 'error')
      this.fatal = bind(parent, bindings, 'fatal')
      this.warn = bind(parent, bindings, 'warn')
      this.info = bind(parent, bindings, 'info')
      this.debug = bind(parent, bindings, 'debug')
      this.trace = bind(parent, bindings, 'trace')
      if (childSerializers) {
        this.serializers = childSerializers
        this._serialize = childSerialize
      }
      if (transmit) {
        this._logEvent = createLogEventShape(
          [].concat(parent._logEvent.bindings, bindings)
        )
      }
    }
    Child.prototype = this
    return new Child(this)
  }
  return logger
}

pino.levels = {
  values: {
    fatal: 60,
    error: 50,
    warn: 40,
    info: 30,
    debug: 20,
    trace: 10
  },
  labels: {
    10: 'trace',
    20: 'debug',
    30: 'info',
    40: 'warn',
    50: 'error',
    60: 'fatal'
  }
}

pino.stdSerializers = stdSerializers
pino.stdTimeFunctions = Object.assign({}, { nullTime, epochTime, unixTime, isoTime })

function set (opts, logger, level, fallback) {
  const proto = Object.getPrototypeOf(logger)
  logger[level] = logger.levelVal > logger.levels.values[level]
    ? noop
    : (proto[level] ? proto[level] : (_console[level] || _console[fallback] || noop))

  wrap(opts, logger, level)
}

function wrap (opts, logger, level) {
  if (!opts.transmit && logger[level] === noop) return

  logger[level] = (function (write) {
    return function LOG () {
      const ts = opts.timestamp()
      const args = new Array(arguments.length)
      const proto = (Object.getPrototypeOf && Object.getPrototypeOf(this) === _console) ? _console : this
      for (var i = 0; i < args.length; i++) args[i] = arguments[i]

      if (opts.serialize && !opts.asObject) {
        applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize)
      }
      if (opts.asObject) write.call(proto, asObject(this, level, args, ts))
      else write.apply(proto, args)

      if (opts.transmit) {
        const transmitLevel = opts.transmit.level || logger.level
        const transmitValue = pino.levels.values[transmitLevel]
        const methodValue = pino.levels.values[level]
        if (methodValue < transmitValue) return
        transmit(this, {
          ts,
          methodLevel: level,
          methodValue,
          transmitLevel,
          transmitValue: pino.levels.values[opts.transmit.level || logger.level],
          send: opts.transmit.send,
          val: logger.levelVal
        }, args)
      }
    }
  })(logger[level])
}

function asObject (logger, level, args, ts) {
  if (logger._serialize) applySerializers(args, logger._serialize, logger.serializers, logger._stdErrSerialize)
  const argsCloned = args.slice()
  let msg = argsCloned[0]
  const o = {}
  if (ts) {
    o.time = ts
  }
  o.level = pino.levels.values[level]
  let lvl = (logger._childLevel | 0) + 1
  if (lvl < 1) lvl = 1
  // deliberate, catching objects, arrays
  if (msg !== null && typeof msg === 'object') {
    while (lvl-- && typeof argsCloned[0] === 'object') {
      Object.assign(o, argsCloned.shift())
    }
    msg = argsCloned.length ? format(argsCloned.shift(), argsCloned) : undefined
  } else if (typeof msg === 'string') msg = format(argsCloned.shift(), argsCloned)
  if (msg !== undefined) o.msg = msg
  return o
}

function applySerializers (args, serialize, serializers, stdErrSerialize) {
  for (const i in args) {
    if (stdErrSerialize && args[i] instanceof Error) {
      args[i] = pino.stdSerializers.err(args[i])
    } else if (typeof args[i] === 'object' && !Array.isArray(args[i])) {
      for (const k in args[i]) {
        if (serialize && serialize.indexOf(k) > -1 && k in serializers) {
          args[i][k] = serializers[k](args[i][k])
        }
      }
    }
  }
}

function bind (parent, bindings, level) {
  return function () {
    const args = new Array(1 + arguments.length)
    args[0] = bindings
    for (var i = 1; i < args.length; i++) {
      args[i] = arguments[i - 1]
    }
    return parent[level].apply(this, args)
  }
}

function transmit (logger, opts, args) {
  const send = opts.send
  const ts = opts.ts
  const methodLevel = opts.methodLevel
  const methodValue = opts.methodValue
  const val = opts.val
  const bindings = logger._logEvent.bindings

  applySerializers(
    args,
    logger._serialize || Object.keys(logger.serializers),
    logger.serializers,
    logger._stdErrSerialize === undefined ? true : logger._stdErrSerialize
  )
  logger._logEvent.ts = ts
  logger._logEvent.messages = args.filter(function (arg) {
    // bindings can only be objects, so reference equality check via indexOf is fine
    return bindings.indexOf(arg) === -1
  })

  logger._logEvent.level.label = methodLevel
  logger._logEvent.level.value = methodValue

  send(methodLevel, logger._logEvent, val)

  logger._logEvent = createLogEventShape(bindings)
}

function createLogEventShape (bindings) {
  return {
    ts: 0,
    messages: [],
    bindings: bindings || [],
    level: { label: '', value: 0 }
  }
}

function asErrValue (err) {
  const obj = {
    type: err.constructor.name,
    msg: err.message,
    stack: err.stack
  }
  for (const key in err) {
    if (obj[key] === undefined) {
      obj[key] = err[key]
    }
  }
  return obj
}

function getTimeFunction (opts) {
  if (typeof opts.timestamp === 'function') {
    return opts.timestamp
  }
  if (opts.timestamp === false) {
    return nullTime
  }
  return epochTime
}

function mock () { return {} }
function passthrough (a) { return a }
function noop () {}

function nullTime () { return false }
function epochTime () { return Date.now() }
function unixTime () { return Math.round(Date.now() / 1000.0) }
function isoTime () { return new Date(Date.now()).toISOString() } // using Date.now() for testability

/* eslint-disable */
/* istanbul ignore next */
function pfGlobalThisOrFallback () {
  function defd (o) { return typeof o !== 'undefined' && o }
  try {
    if (typeof globalThis !== 'undefined') return globalThis
    Object.defineProperty(Object.prototype, 'globalThis', {
      get: function () {
        delete Object.prototype.globalThis
        return (this.globalThis = this)
      },
      configurable: true
    })
    return globalThis
  } catch (e) {
    return defd(self) || defd(window) || defd(this) || {}
  }
}
/* eslint-enable */


/***/ }),

/***/ 16315:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   v: () => (/* binding */ concatArrayBuffer)
/* harmony export */ });
function concatArrayBuffer(...parts) {
    const buffers = parts.map((x) => new Uint8Array(x));
    const u8 = new Uint8Array(buffers.reduce((a, b) => a + b.length, 0));
    let last = 0;
    for (const each of buffers) {
        u8.set(each, last);
        last += each.length;
    }
    return u8.buffer;
}


/***/ }),

/***/ 54093:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   P: () => (/* binding */ defer)
/* harmony export */ });
/**
 * ! Please use the Promise constructor if possible
 * If you don't understand https://groups.google.com/forum/#!topic/bluebird-js/mUiX2-vXW2s
 */
function defer() {
    let a, b;
    const p = new Promise((x, y) => {
        a = x;
        b = y;
    });
    return [p, a, b];
}


/***/ }),

/***/ 24687:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export lazy */
/**
 * @description The lazy decorator.
 * @example
 * class T {
 *     ;@lazy accessor value = lazy.of(() => getData())
 * }
 */
function lazy(target, _context) {
    const { get, set } = target;
    let init = false;
    return {
        get() {
            const val = get.call(this);
            if (!init) {
                if (typeof val !== 'function')
                    throw new TypeError('Please use lazy.of(() => ...) to wrap the value.');
                set.call(this, val());
                init = true;
            }
            return val;
        },
        set(val) {
            init ||= true;
            set.call(this, val);
        },
    };
}
/**
 * DO NOT use this function without the lazy decorator! It actually returning the init function instead of the value
 * @param init The init function
 */
lazy.of = (init) => init;


/***/ }),

/***/ 22444:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   J: () => (/* binding */ memoizePromise)
/* harmony export */ });
/**
 * The promise version of lodash-es/memoize
 * @param memoize lodash.memoize
 * @param f An async function
 * @param resolver If the function has 1 param, it can be undefined
 * as `x => x`. If it has more than 1 param, you must specify a function
 * to map the param the memoize key.
 */
function memoizePromise(memoize, f, resolver) {
    if (resolver === undefined)
        resolver = ((x) => x);
    const memorizedFunction = memoize(async function (...args) {
        try {
            // ? DO NOT remove "await" here
            return await f(...args);
        }
        catch (error) {
            memorizedFunction.cache.delete(resolver(...args));
            throw error;
        }
    }, resolver);
    return memorizedFunction;
}


/***/ }),

/***/ 83043:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   s: () => (/* binding */ formatFileSize)
/* harmony export */ });
/// <reference types="user-agent-data-types" />
function formatFileSize(input = 0, si = isMacPlatform(), fractionDigits = 1) {
    if (input === 0 || Number.isNaN(input)) {
        return '0 B';
    }
    const units = ['', 'K', 'M', 'G', 'T', 'P'];
    const base = si ? 1000 : 0x400;
    const n = Math.min(Math.floor(Math.log(input) / Math.log(base)), units.length - 1);
    const value = input / Math.pow(base, n);
    const formatted = n === 0 ? value : value.toFixed(fractionDigits);
    return `${formatted} ${units[n]}${si ? '' : 'i'}B`;
}
/** @internal */
function isMacPlatform() {
    try {
        return /^Mac/.test(navigator.userAgentData?.platform ?? navigator.platform);
    }
    catch {
        return false;
    }
}


/***/ }),

/***/ 56077:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony exports getDimensionAsPNG, getDimensionAsJPEG */
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30898);

/* eslint-disable no-bitwise */
function getDimensionAsPNG(buf) {
    const view = new DataView(buf, 0, 28);
    return { width: view.getInt32(16), height: view.getInt32(20) };
}
/**
 * Get dimension of a JPEG image
 * @see http://vip.sugovica.hu/Sardi/kepnezo/JPEG%20File%20Layout%20and%20Format.htm
 */
function getDimensionAsJPEG(buf) {
    const MAGIC_1 = Uint8Array.of(0xff, 0xd8, 0xff, 0xe0);
    const MAGIC_2 = Uint8Array.of(0x4a, 0x46, 0x49, 0x46, 0x00);
    const view = new DataView(buf);
    let index = 0;
    if (!isArrayBufferEqual(buf.slice(index, index + 4), MAGIC_1)) {
        return;
    }
    index += 4;
    if (!isArrayBufferEqual(buf.slice(index + 2, index + 6), MAGIC_2)) {
        return;
    }
    let blockLength = view.getUint8(index) * 256 + view.getUint8(index + 1);
    while (index < view.byteLength) {
        index += blockLength;
        if (index >= view.byteLength)
            return;
        if (view.getUint8(index) !== 0xff)
            return;
        const marker = view.getUint8(index + 1); // SOF0 / SOF2 marker
        if (!(marker === 0xc0 || marker === 0xc2)) {
            index += 2;
            blockLength = view.getUint8(index) * 256 + view.getUint8(index + 1);
            continue;
        }
        return {
            height: view.getUint8(index + 5) * 256 + view.getUint8(index + 6),
            width: view.getUint8(index + 7) * 256 + view.getUint8(index + 8),
        };
    }
    return undefined;
}


/***/ }),

/***/ 6722:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Y: () => (/* binding */ getEnumAsArray)
/* harmony export */ });
function getEnumAsArray(enumObject) {
    return (Object.keys(enumObject)
        // Leave only key of enum
        .filter((x) => Number.isNaN(Number.parseInt(x)))
        .map((key) => ({ key, value: enumObject[key] })));
}


/***/ }),

/***/ 56999:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   d: () => (/* binding */ combineAbortSignal)
/* harmony export */ });
function combineAbortSignal(..._) {
    const args = _.filter(Boolean);
    if (args.length === 0)
        return undefined;
    if (args.length === 1)
        return args[0] ?? undefined;
    const controller = new AbortController();
    const abort = () => controller.abort();
    for (const each of args) {
        each.addEventListener('abort', abort, { signal: controller.signal });
    }
    return controller.signal;
}


/***/ }),

/***/ 48261:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   g: () => (/* binding */ delay)
/* harmony export */ });
/**
 * Return a promise that resolved after `time` ms.
 * If `time` is `Infinity`, it will never resolve.
 * @param time - Time to sleep. In `ms`.
 */
function delay(time) {
    return new Promise((resolve) => (Number.isFinite(time) ? setTimeout(resolve, time) : void 0));
}


/***/ }),

/***/ 11278:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   V: () => (/* binding */ timeout)
/* harmony export */ });
/**
 * Accept a promise and then set a timeout on it. After `time` ms, it will reject.
 * @param promise - The promise that you want to set time limit on.
 * @param time - Time before timeout. In `ms`.
 * @param rejectReason - When reject, show a reason. Defaults to `"timeout"`
 */
function timeout(promise, time, rejectReason) {
    if (!Number.isFinite(time))
        return (async () => promise)();
    let timer;
    const race = Promise.race([
        promise,
        new Promise((r, reject) => {
            timer = setTimeout(() => reject(new Error(rejectReason ?? 'timeout')), time);
        }),
    ]);
    race.finally(() => clearTimeout(timer));
    return race;
}


/***/ }),

/***/ 57228:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (/* binding */ Browser)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(57941);
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4844);



var arr = [];
var each = arr.forEach;
var slice = arr.slice;
function defaults(obj) {
  each.call(slice.call(arguments, 1), function (source) {
    if (source) {
      for (var prop in source) {
        if (obj[prop] === undefined) obj[prop] = source[prop];
      }
    }
  });
  return obj;
}

// eslint-disable-next-line no-control-regex
var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
var serializeCookie = function serializeCookie(name, val, options) {
  var opt = options || {};
  opt.path = opt.path || '/';
  var value = encodeURIComponent(val);
  var str = "".concat(name, "=").concat(value);
  if (opt.maxAge > 0) {
    var maxAge = opt.maxAge - 0;
    if (Number.isNaN(maxAge)) throw new Error('maxAge should be a Number');
    str += "; Max-Age=".concat(Math.floor(maxAge));
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError('option domain is invalid');
    }
    str += "; Domain=".concat(opt.domain);
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError('option path is invalid');
    }
    str += "; Path=".concat(opt.path);
  }
  if (opt.expires) {
    if (typeof opt.expires.toUTCString !== 'function') {
      throw new TypeError('option expires is invalid');
    }
    str += "; Expires=".concat(opt.expires.toUTCString());
  }
  if (opt.httpOnly) str += '; HttpOnly';
  if (opt.secure) str += '; Secure';
  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === 'string' ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str += '; SameSite=Strict';
        break;
      case 'lax':
        str += '; SameSite=Lax';
        break;
      case 'strict':
        str += '; SameSite=Strict';
        break;
      case 'none':
        str += '; SameSite=None';
        break;
      default:
        throw new TypeError('option sameSite is invalid');
    }
  }
  return str;
};
var cookie = {
  create: function create(name, value, minutes, domain) {
    var cookieOptions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
      path: '/',
      sameSite: 'strict'
    };
    if (minutes) {
      cookieOptions.expires = new Date();
      cookieOptions.expires.setTime(cookieOptions.expires.getTime() + minutes * 60 * 1000);
    }
    if (domain) cookieOptions.domain = domain;
    document.cookie = serializeCookie(name, encodeURIComponent(value), cookieOptions);
  },
  read: function read(name) {
    var nameEQ = "".concat(name, "=");
    var ca = document.cookie.split(';');
    for (var i = 0; i < ca.length; i++) {
      var c = ca[i];
      while (c.charAt(0) === ' ') {
        c = c.substring(1, c.length);
      }
      if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
    }
    return null;
  },
  remove: function remove(name) {
    this.create(name, '', -1);
  }
};
var cookie$1 = {
  name: 'cookie',
  lookup: function lookup(options) {
    var found;
    if (options.lookupCookie && typeof document !== 'undefined') {
      var c = cookie.read(options.lookupCookie);
      if (c) found = c;
    }
    return found;
  },
  cacheUserLanguage: function cacheUserLanguage(lng, options) {
    if (options.lookupCookie && typeof document !== 'undefined') {
      cookie.create(options.lookupCookie, lng, options.cookieMinutes, options.cookieDomain, options.cookieOptions);
    }
  }
};

var querystring = {
  name: 'querystring',
  lookup: function lookup(options) {
    var found;
    if (typeof window !== 'undefined') {
      var search = window.location.search;
      if (!window.location.search && window.location.hash && window.location.hash.indexOf('?') > -1) {
        search = window.location.hash.substring(window.location.hash.indexOf('?'));
      }
      var query = search.substring(1);
      var params = query.split('&');
      for (var i = 0; i < params.length; i++) {
        var pos = params[i].indexOf('=');
        if (pos > 0) {
          var key = params[i].substring(0, pos);
          if (key === options.lookupQuerystring) {
            found = params[i].substring(pos + 1);
          }
        }
      }
    }
    return found;
  }
};

var hasLocalStorageSupport = null;
var localStorageAvailable = function localStorageAvailable() {
  if (hasLocalStorageSupport !== null) return hasLocalStorageSupport;
  try {
    hasLocalStorageSupport = window !== 'undefined' && window.localStorage !== null;
    var testKey = 'i18next.translate.boo';
    window.localStorage.setItem(testKey, 'foo');
    window.localStorage.removeItem(testKey);
  } catch (e) {
    hasLocalStorageSupport = false;
  }
  return hasLocalStorageSupport;
};
var localStorage = {
  name: 'localStorage',
  lookup: function lookup(options) {
    var found;
    if (options.lookupLocalStorage && localStorageAvailable()) {
      var lng = window.localStorage.getItem(options.lookupLocalStorage);
      if (lng) found = lng;
    }
    return found;
  },
  cacheUserLanguage: function cacheUserLanguage(lng, options) {
    if (options.lookupLocalStorage && localStorageAvailable()) {
      window.localStorage.setItem(options.lookupLocalStorage, lng);
    }
  }
};

var hasSessionStorageSupport = null;
var sessionStorageAvailable = function sessionStorageAvailable() {
  if (hasSessionStorageSupport !== null) return hasSessionStorageSupport;
  try {
    hasSessionStorageSupport = window !== 'undefined' && window.sessionStorage !== null;
    var testKey = 'i18next.translate.boo';
    window.sessionStorage.setItem(testKey, 'foo');
    window.sessionStorage.removeItem(testKey);
  } catch (e) {
    hasSessionStorageSupport = false;
  }
  return hasSessionStorageSupport;
};
var sessionStorage = {
  name: 'sessionStorage',
  lookup: function lookup(options) {
    var found;
    if (options.lookupSessionStorage && sessionStorageAvailable()) {
      var lng = window.sessionStorage.getItem(options.lookupSessionStorage);
      if (lng) found = lng;
    }
    return found;
  },
  cacheUserLanguage: function cacheUserLanguage(lng, options) {
    if (options.lookupSessionStorage && sessionStorageAvailable()) {
      window.sessionStorage.setItem(options.lookupSessionStorage, lng);
    }
  }
};

var navigator$1 = {
  name: 'navigator',
  lookup: function lookup(options) {
    var found = [];
    if (typeof navigator !== 'undefined') {
      if (navigator.languages) {
        // chrome only; not an array, so can't use .push.apply instead of iterating
        for (var i = 0; i < navigator.languages.length; i++) {
          found.push(navigator.languages[i]);
        }
      }
      if (navigator.userLanguage) {
        found.push(navigator.userLanguage);
      }
      if (navigator.language) {
        found.push(navigator.language);
      }
    }
    return found.length > 0 ? found : undefined;
  }
};

var htmlTag = {
  name: 'htmlTag',
  lookup: function lookup(options) {
    var found;
    var htmlTag = options.htmlTag || (typeof document !== 'undefined' ? document.documentElement : null);
    if (htmlTag && typeof htmlTag.getAttribute === 'function') {
      found = htmlTag.getAttribute('lang');
    }
    return found;
  }
};

var path = {
  name: 'path',
  lookup: function lookup(options) {
    var found;
    if (typeof window !== 'undefined') {
      var language = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
      if (language instanceof Array) {
        if (typeof options.lookupFromPathIndex === 'number') {
          if (typeof language[options.lookupFromPathIndex] !== 'string') {
            return undefined;
          }
          found = language[options.lookupFromPathIndex].replace('/', '');
        } else {
          found = language[0].replace('/', '');
        }
      }
    }
    return found;
  }
};

var subdomain = {
  name: 'subdomain',
  lookup: function lookup(options) {
    // If given get the subdomain index else 1
    var lookupFromSubdomainIndex = typeof options.lookupFromSubdomainIndex === 'number' ? options.lookupFromSubdomainIndex + 1 : 1;
    // get all matches if window.location. is existing
    // first item of match is the match itself and the second is the first group macht which sould be the first subdomain match
    // is the hostname no public domain get the or option of localhost
    var language = typeof window !== 'undefined' && window.location && window.location.hostname && window.location.hostname.match(/^(\w{2,5})\.(([a-z0-9-]{1,63}\.[a-z]{2,6})|localhost)/i);

    // if there is no match (null) return undefined
    if (!language) return undefined;
    // return the given group match
    return language[lookupFromSubdomainIndex];
  }
};

function getDefaults() {
  return {
    order: ['querystring', 'cookie', 'localStorage', 'sessionStorage', 'navigator', 'htmlTag'],
    lookupQuerystring: 'lng',
    lookupCookie: 'i18next',
    lookupLocalStorage: 'i18nextLng',
    lookupSessionStorage: 'i18nextLng',
    // cache user language
    caches: ['localStorage'],
    excludeCacheFor: ['cimode'],
    // cookieMinutes: 10,
    // cookieDomain: 'myDomain'

    convertDetectedLanguage: function convertDetectedLanguage(l) {
      return l;
    }
  };
}
var Browser = /*#__PURE__*/function () {
  function Browser(services) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0,_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, Browser);
    this.type = 'languageDetector';
    this.detectors = {};
    this.init(services, options);
  }
  (0,_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(Browser, [{
    key: "init",
    value: function init(services) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var i18nOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      this.services = services || {
        languageUtils: {}
      }; // this way the language detector can be used without i18next
      this.options = defaults(options, this.options || {}, getDefaults());
      if (typeof this.options.convertDetectedLanguage === 'string' && this.options.convertDetectedLanguage.indexOf('15897') > -1) {
        this.options.convertDetectedLanguage = function (l) {
          return l.replace('-', '_');
        };
      }

      // backwards compatibility
      if (this.options.lookupFromUrlIndex) this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;
      this.i18nOptions = i18nOptions;
      this.addDetector(cookie$1);
      this.addDetector(querystring);
      this.addDetector(localStorage);
      this.addDetector(sessionStorage);
      this.addDetector(navigator$1);
      this.addDetector(htmlTag);
      this.addDetector(path);
      this.addDetector(subdomain);
    }
  }, {
    key: "addDetector",
    value: function addDetector(detector) {
      this.detectors[detector.name] = detector;
    }
  }, {
    key: "detect",
    value: function detect(detectionOrder) {
      var _this = this;
      if (!detectionOrder) detectionOrder = this.options.order;
      var detected = [];
      detectionOrder.forEach(function (detectorName) {
        if (_this.detectors[detectorName]) {
          var lookup = _this.detectors[detectorName].lookup(_this.options);
          if (lookup && typeof lookup === 'string') lookup = [lookup];
          if (lookup) detected = detected.concat(lookup);
        }
      });
      detected = detected.map(function (d) {
        return _this.options.convertDetectedLanguage(d);
      });
      if (this.services.languageUtils.getBestMatchFromCodes) return detected; // new i18next v19.5.0
      return detected.length > 0 ? detected[0] : null; // a little backward compatibility
    }
  }, {
    key: "cacheUserLanguage",
    value: function cacheUserLanguage(lng, caches) {
      var _this2 = this;
      if (!caches) caches = this.options.caches;
      if (!caches) return;
      if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1) return;
      caches.forEach(function (cacheName) {
        if (_this2.detectors[cacheName]) _this2.detectors[cacheName].cacheUserLanguage(lng, _this2.options);
      });
    }
  }]);
  return Browser;
}();
Browser.type = 'languageDetector';




/***/ }),

/***/ 44281:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   B: () => (/* binding */ toString)
/* harmony export */ });
function toString(val) {
    var value = String(val);
    if (value === '[object Object]') {
        try {
            value = JSON.stringify(val);
        }
        catch (_a) { }
    }
    return value;
}


/***/ }),

/***/ 37814:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E: () => (/* binding */ allocUnsafe)
/* harmony export */ });
/* unused harmony export alloc */
/* harmony import */ var _util_as_uint8array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16626);

function alloc(size = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.alloc != null) {
    return asUint8Array(globalThis.Buffer.alloc(size));
  }
  return new Uint8Array(size);
}
function allocUnsafe(size = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return (0,_util_as_uint8array_js__WEBPACK_IMPORTED_MODULE_0__/* .asUint8Array */ .P)(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}

/***/ }),

/***/ 67698:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   z: () => (/* binding */ concat)
/* harmony export */ });
/* harmony import */ var _alloc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37814);
/* harmony import */ var _util_as_uint8array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16626);


function concat(arrays, length) {
  if (!length) {
    length = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = (0,_alloc_js__WEBPACK_IMPORTED_MODULE_0__/* .allocUnsafe */ .E)(length);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return (0,_util_as_uint8array_js__WEBPACK_IMPORTED_MODULE_1__/* .asUint8Array */ .P)(output);
}

/***/ }),

/***/ 88138:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   m: () => (/* binding */ fromString)
/* harmony export */ });
/* harmony import */ var _util_bases_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(67063);
/* harmony import */ var _util_as_uint8array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16626);


function fromString(string, encoding = 'utf8') {
  const base = _util_bases_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z[encoding];
  if (!base) {
    throw new Error(`Unsupported encoding "${ encoding }"`);
  }
  if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return (0,_util_as_uint8array_js__WEBPACK_IMPORTED_MODULE_1__/* .asUint8Array */ .P)(globalThis.Buffer.from(string, 'utf-8'));
  }
  return base.decoder.decode(`${ base.prefix }${ string }`);
}

/***/ }),

/***/ 20725:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BB: () => (/* reexport safe */ _to_string_js__WEBPACK_IMPORTED_MODULE_1__.B),
/* harmony export */   mL: () => (/* reexport safe */ _from_string_js__WEBPACK_IMPORTED_MODULE_0__.m),
/* harmony export */   zo: () => (/* reexport safe */ _concat_js__WEBPACK_IMPORTED_MODULE_2__.z)
/* harmony export */ });
/* harmony import */ var _concat_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(67698);
/* harmony import */ var _from_string_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(88138);
/* harmony import */ var _to_string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(76109);








/***/ }),

/***/ 76109:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   B: () => (/* binding */ toString)
/* harmony export */ });
/* harmony import */ var _util_bases_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(67063);

function toString(array, encoding = 'utf8') {
  const base = _util_bases_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z[encoding];
  if (!base) {
    throw new Error(`Unsupported encoding "${ encoding }"`);
  }
  if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString('utf8');
  }
  return base.encoder.encode(array).substring(1);
}

/***/ }),

/***/ 16626:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   P: () => (/* binding */ asUint8Array)
/* harmony export */ });
function asUint8Array(buf) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  return buf;
}

/***/ }),

/***/ 67063:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var multiformats_basics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(35551);
/* harmony import */ var _alloc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(37814);


function createCodec(name, prefix, encode, decode) {
  return {
    name,
    prefix,
    encoder: {
      name,
      prefix,
      encode
    },
    decoder: { decode }
  };
}
const string = createCodec('utf8', 'u', buf => {
  const decoder = new TextDecoder('utf8');
  return 'u' + decoder.decode(buf);
}, str => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
const ascii = createCodec('ascii', 'a', buf => {
  let string = 'a';
  for (let i = 0; i < buf.length; i++) {
    string += String.fromCharCode(buf[i]);
  }
  return string;
}, str => {
  str = str.substring(1);
  const buf = (0,_alloc_js__WEBPACK_IMPORTED_MODULE_1__/* .allocUnsafe */ .E)(str.length);
  for (let i = 0; i < str.length; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
});
const BASES = {
  utf8: string,
  'utf-8': string,
  hex: multiformats_basics__WEBPACK_IMPORTED_MODULE_0__/* .bases */ .gh.base16,
  latin1: ascii,
  ascii: ascii,
  binary: ascii,
  ...multiformats_basics__WEBPACK_IMPORTED_MODULE_0__/* .bases */ .gh
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BASES);

/***/ }),

/***/ 54169:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Khl: () => (/* binding */ open_sea_url),
/* harmony export */   bGE: () => (/* binding */ looks_rare_url)
/* harmony export */ });
/* unused harmony exports aave_url, algorand_url, arbitrum_url, arweave_url, avalanche_url, bsc_url, celo_url, coincarp_url, coin_gecko_url, coin_market_cap_url, cosmos_url, crossbell_url, cross_sync_url, cyber_connect_url, danger_url, debank_url, discord_url, discord_round_url, discord_round_black_dark_url, discord_round_black_light_url, discord_round_gray_url, eip_1577_url, eth_url, ether_scan_url, facebook_colored_url, facebook_round_url, facebook_round_gray_url, fantom_url, farcaster_url, firefly_dark_url, firefly_light_url, flow_url, gem_url, git_hub_url, git_hub_gray_url, gnosis_url, instagram_url, instagram_colored_url, instagram_round_colored_url, instagram_round_gray_url, ipfs_url, keybase_url, kusama_url, leaderboard_url, lens_url, link_3_url, mask_dark_url, mask_light_url, mask_banner_url, mask_blue_url, mask_grey_dark_url, mask_grey_light_url, mask_placeholder_dark_url, mask_placeholder_dim_url, mask_placeholder_light_url, mask_square_dark_url, mask_square_light_url, mask_text_url, mask_text_nightly_url, mask_wallet_url, medium_url, medium_gray_url, meta_mask_url, minds_url, minds_round_url, mini_mask_dark_url, mini_mask_light_url, mirror_url, momoka_url, next_id_mini_dark_url, next_id_mini_light_url, nftgo_url, nft_scan_url, open_sea_colored_url, optimism_url, pancake_swap_url, pets_url, planet_url, polka_dot_url, polygon_url, polygon_scan_url, rarible_url, reddit_round_url, reddit_round_gray_url, rsk_url, rss_3_url, simple_hash_url, solana_url, sushi_swap_url, sybil_url, telegram_round_url, twitter_colored_url, twitter_other_colored_url, twitter_round_url, twitter_round_gray_url, twitter_x_dark_url, twitter_x_light_url, twitter_x_round_dark_url, twitter_x_round_light_url, uniswap_url, weth_url, x_2_y_2_url, x_log_dark_url, x_log_url, you_tube_url, you_tube_gray_url, zerion_url, zero_x_dark_url, zero_x_url, zilliqa_url, zk_scan_url, zora_url, add_url, add_no_border_url, add_user_url, america_url, appearance_url, appendices_url, application_nft_url, approve_url, arrow_back_url, arrow_down_round_url, arrow_downward_url, arrow_drop_url, arrow_right_url, arrow_up_url, arrow_up_round_url, back_up_url, base_close_dark_url, base_close_light_url, base_contacts_url, base_upload_url, base_user_url, best_trade_url, blue_pin_url, bordered_success_url, busy_wallet_nav_url, buy_url, cached_url, candle_url, card_url, check_url, checkbox_url, checkbox_blank_url, checkbox_border_url, checkbox_no_url, check_circle_url, chevron_up_url, china_url, circle_close_url, circle_loading_url, circle_warning_url, clear_dark_url, clear_light_url, close_url, cloud_url, cloud_backup_url, cloud_backup_2_url, cloud_link_url, cny_url, collectible_url, comeback_url, connect_url, contacts_url, copy_url, currency_url, dark_url, decrease_url, default_token_dark_url, default_token_dim_url, default_token_light_url, delete_url, disconnect_url, document_url, documents_url, download_url, download_2_url, drop_url, dump_url, edit_url, edit_2_url, empty_url, empty_simple_dark_url, empty_simple_light_url, encrypted_files_url, europe_url, eye_dark_url, eye_light_url, eye_color_url, eye_off_dark_url, eye_off_light_url, facebook_url, file_url, file_message_url, fill_success_url, filter_url, flag_url, folder_url, gas_url, gas_station_url, gear_dark_url, gear_light_url, gear_settings_url, globe_url, gray_masks_url, hamburger_menu_url, history_url, hkd_url, hong_kong_url, identity_dark_url, identity_light_url, info_dark_url, info_light_url, interaction_url, interaction_circle_url, japan_url, jpy_url, key_square_url, left_arrow_url, linear_calendar_dark_url, linear_calendar_light_url, link_url, link_out_url, loader_url, loading_base_dark_url, loading_base_light_url, local_backup_url, lock_url, mask_avatar_dark_url, mask_avatar_light_url, mask_in_minds_url, mask_me_url, masks_url, message_url, mnemonic_url, more_url, next_id_avatar_dark_url, next_id_avatar_light_url, next_id_persona_warning_url, nft_red_packet_url, outlined_mask_url, personas_outline_url, pin_dark_url, pin_light_url, play_dark_url, play_url, plugin_url, plugins_url, popup_close_url, popup_link_url, popup_restore_url, popup_trash_url, primary_info_url, provider_url, public_key_dark_url, public_key_light_url, public_key_2_url, questions_url, radio_button_checked_url, radio_button_un_checked_url, radio_no_dark_url, radio_no_light_url, receive_colorful_url, red_packet_url, refresh_url, restore_url, restore_colorful_url, retweet_dark_url, retweet_light_url, right_url, right_arrow_url, risk_url, search_url, security_risk_url, security_warning_url, selected_dark_url, selected_light_url, self_url, send_url, send_colorful_url, setting_url, settings_url, settings_2_url, sharp_mask_url, sign_up_account_url, smart_pay_url, star_url, success_url, success_for_snack_bar_url, sun_url, swap_url, swap_colorful_url, switch_logo_dark_url, switch_logo_light_url, telegram_round_gray_url, tick_url, time_url, tips_url, transaction_failed_url, trash_url, trash_line_url, tutorial_url, twitter_url, twitter_stroke_url, tx_in_url, tx_out_url, undo_url, upload_url, usd_url, user_url, verification_url, wallet_url, wallet_nav_url, wallet_setting_url, warning_url, warning_triangle_url, web_url, web_black_dark_url, web_black_light_url, menu_personas_url, menu_personas_active_url, menu_settings_url, menu_settings_active_url, menu_wallets_url, menu_wallets_active_url, approval_url, art_blocks_url, avatar_url, bit_url, calendar_url, collectibles_url, cross_bridge_url, cyber_connect_dark_url, cyber_connect_light_url, decentralized_search_url, ens_url, ens_cover_url, file_service_url, find_truman_url, gitcoin_dark_url, gitcoin_light_url, good_ghosting_dark_url, good_ghosting_light_url, markets_url, markets_claim_url, mask_box_url, nft_avatar_url, pool_together_url, savings_url, scam_sniffer_url, security_checker_url, setting_info_dark_url, setting_info_light_url, shared_url, snapshot_url, space_id_url, tip_coin_url, transak_url, unstoppable_url, valuables_dark_url, valuables_light_url, web_3_profile_url, web_3_profile_card_url, achievement_burn_url, achievement_receive_url, approval_approve_url, collectible_approve_url, collectible_burn_url, collectible_in_url, collectible_mint_url, collectible_out_url, donation_donate_url, donation_launch_url, follow_url, governance_propose_url, governance_vote_url, note_burn_url, note_create_url, note_edit_url, note_link_url, note_mint_url, profile_burn_url, profile_create_url, profile_link_url, profile_proxy_url, profile_update_url, rss_3_link_url, token_bridge_url, token_burn_url, token_in_url, token_liquidity_url, token_mint_url, token_out_url, token_stake_url, token_swap_url, token_unstake_url, unfollow_url, unknown_burn_url, unknown_cancel_url, unknown_in_url, unknown_out_url, cn_url, email_url, jp_url, kr_url, settings_appearance_dark_url, settings_appearance_light_url, settings_backup_dark_url, settings_backup_light_url, settings_email_dark_url, settings_email_light_url, settings_language_dark_url, settings_language_light_url, settings_password_dark_url, settings_password_light_url, settings_phone_dark_url, settings_phone_light_url, settings_restore_dark_url, settings_restore_light_url, settings_sync_dark_url, settings_sync_light_url, uk_url */
function aave_url() { return /* unused asset import */ undefined }
function algorand_url() { return /* unused asset import */ undefined }
function arbitrum_url() { return /* unused asset import */ undefined }
function arweave_url() { return /* unused asset import */ undefined }
function avalanche_url() { return /* unused asset import */ undefined }
function bsc_url() { return /* unused asset import */ undefined }
function celo_url() { return /* unused asset import */ undefined }
function coincarp_url() { return /* unused asset import */ undefined }
function coin_gecko_url() { return /* unused asset import */ undefined }
function coin_market_cap_url() { return /* unused asset import */ undefined }
function cosmos_url() { return /* unused asset import */ undefined }
function crossbell_url() { return /* unused asset import */ undefined }
function cross_sync_url() { return /* unused asset import */ undefined }
function cyber_connect_url() { return /* unused asset import */ undefined }
function danger_url() { return /* unused asset import */ undefined }
function debank_url() { return /* unused asset import */ undefined }
function discord_url() { return /* unused asset import */ undefined }
function discord_round_url() { return /* unused asset import */ undefined }
function discord_round_black_dark_url() { return /* unused asset import */ undefined }
function discord_round_black_light_url() { return /* unused asset import */ undefined }
function discord_round_gray_url() { return /* unused asset import */ undefined }
function eip_1577_url() { return /* unused asset import */ undefined }
function eth_url() { return /* unused asset import */ undefined }
function ether_scan_url() { return /* unused asset import */ undefined }
function facebook_colored_url() { return /* unused asset import */ undefined }
function facebook_round_url() { return /* unused asset import */ undefined }
function facebook_round_gray_url() { return /* unused asset import */ undefined }
function fantom_url() { return /* unused asset import */ undefined }
function farcaster_url() { return /* unused asset import */ undefined }
function firefly_dark_url() { return /* unused asset import */ undefined }
function firefly_light_url() { return /* unused asset import */ undefined }
function flow_url() { return /* unused asset import */ undefined }
function gem_url() { return /* unused asset import */ undefined }
function git_hub_url() { return /* unused asset import */ undefined }
function git_hub_gray_url() { return /* unused asset import */ undefined }
function gnosis_url() { return /* unused asset import */ undefined }
function instagram_url() { return /* unused asset import */ undefined }
function instagram_colored_url() { return /* unused asset import */ undefined }
function instagram_round_colored_url() { return /* unused asset import */ undefined }
function instagram_round_gray_url() { return /* unused asset import */ undefined }
function ipfs_url() { return /* unused asset import */ undefined }
function keybase_url() { return /* unused asset import */ undefined }
function kusama_url() { return /* unused asset import */ undefined }
function leaderboard_url() { return /* unused asset import */ undefined }
function lens_url() { return /* unused asset import */ undefined }
function link_3_url() { return /* unused asset import */ undefined }
function looks_rare_url() { return new URL(/* asset import */ __webpack_require__(16660), __webpack_require__.b) }
function mask_dark_url() { return /* unused asset import */ undefined }
function mask_light_url() { return /* unused asset import */ undefined }
function mask_banner_url() { return /* unused asset import */ undefined }
function mask_blue_url() { return /* unused asset import */ undefined }
function mask_grey_dark_url() { return /* unused asset import */ undefined }
function mask_grey_light_url() { return /* unused asset import */ undefined }
function mask_placeholder_dark_url() { return /* unused asset import */ undefined }
function mask_placeholder_dim_url() { return /* unused asset import */ undefined }
function mask_placeholder_light_url() { return /* unused asset import */ undefined }
function mask_square_dark_url() { return /* unused asset import */ undefined }
function mask_square_light_url() { return /* unused asset import */ undefined }
function mask_text_url() { return /* unused asset import */ undefined }
function mask_text_nightly_url() { return /* unused asset import */ undefined }
function mask_wallet_url() { return /* unused asset import */ undefined }
function medium_url() { return /* unused asset import */ undefined }
function medium_gray_url() { return /* unused asset import */ undefined }
function meta_mask_url() { return /* unused asset import */ undefined }
function minds_url() { return /* unused asset import */ undefined }
function minds_round_url() { return /* unused asset import */ undefined }
function mini_mask_dark_url() { return /* unused asset import */ undefined }
function mini_mask_light_url() { return /* unused asset import */ undefined }
function mirror_url() { return /* unused asset import */ undefined }
function momoka_url() { return /* unused asset import */ undefined }
function next_id_mini_dark_url() { return /* unused asset import */ undefined }
function next_id_mini_light_url() { return /* unused asset import */ undefined }
function nftgo_url() { return /* unused asset import */ undefined }
function nft_scan_url() { return /* unused asset import */ undefined }
function open_sea_url() { return new URL(/* asset import */ __webpack_require__(78952), __webpack_require__.b) }
function open_sea_colored_url() { return /* unused asset import */ undefined }
function optimism_url() { return /* unused asset import */ undefined }
function pancake_swap_url() { return /* unused asset import */ undefined }
function pets_url() { return /* unused asset import */ undefined }
function planet_url() { return /* unused asset import */ undefined }
function polka_dot_url() { return /* unused asset import */ undefined }
function polygon_url() { return /* unused asset import */ undefined }
function polygon_scan_url() { return /* unused asset import */ undefined }
function rarible_url() { return /* unused asset import */ undefined }
function reddit_round_url() { return /* unused asset import */ undefined }
function reddit_round_gray_url() { return /* unused asset import */ undefined }
function rsk_url() { return /* unused asset import */ undefined }
function rss_3_url() { return /* unused asset import */ undefined }
function simple_hash_url() { return /* unused asset import */ undefined }
function solana_url() { return /* unused asset import */ undefined }
function sushi_swap_url() { return /* unused asset import */ undefined }
function sybil_url() { return /* unused asset import */ undefined }
function telegram_round_url() { return /* unused asset import */ undefined }
function twitter_colored_url() { return /* unused asset import */ undefined }
function twitter_other_colored_url() { return /* unused asset import */ undefined }
function twitter_round_url() { return /* unused asset import */ undefined }
function twitter_round_gray_url() { return /* unused asset import */ undefined }
function twitter_x_dark_url() { return /* unused asset import */ undefined }
function twitter_x_light_url() { return /* unused asset import */ undefined }
function twitter_x_round_dark_url() { return /* unused asset import */ undefined }
function twitter_x_round_light_url() { return /* unused asset import */ undefined }
function uniswap_url() { return /* unused asset import */ undefined }
function weth_url() { return /* unused asset import */ undefined }
function x_2_y_2_url() { return /* unused asset import */ undefined }
function x_log_dark_url() { return /* unused asset import */ undefined }
function x_log_url() { return /* unused asset import */ undefined }
function you_tube_url() { return /* unused asset import */ undefined }
function you_tube_gray_url() { return /* unused asset import */ undefined }
function zerion_url() { return /* unused asset import */ undefined }
function zero_x_dark_url() { return /* unused asset import */ undefined }
function zero_x_url() { return /* unused asset import */ undefined }
function zilliqa_url() { return /* unused asset import */ undefined }
function zk_scan_url() { return /* unused asset import */ undefined }
function zora_url() { return /* unused asset import */ undefined }
function add_url() { return /* unused asset import */ undefined }
function add_no_border_url() { return /* unused asset import */ undefined }
function add_user_url() { return /* unused asset import */ undefined }
function america_url() { return /* unused asset import */ undefined }
function appearance_url() { return /* unused asset import */ undefined }
function appendices_url() { return /* unused asset import */ undefined }
function application_nft_url() { return /* unused asset import */ undefined }
function approve_url() { return /* unused asset import */ undefined }
function arrow_back_url() { return /* unused asset import */ undefined }
function arrow_down_round_url() { return /* unused asset import */ undefined }
function arrow_downward_url() { return /* unused asset import */ undefined }
function arrow_drop_url() { return /* unused asset import */ undefined }
function arrow_right_url() { return /* unused asset import */ undefined }
function arrow_up_url() { return /* unused asset import */ undefined }
function arrow_up_round_url() { return /* unused asset import */ undefined }
function back_up_url() { return /* unused asset import */ undefined }
function base_close_dark_url() { return /* unused asset import */ undefined }
function base_close_light_url() { return /* unused asset import */ undefined }
function base_contacts_url() { return /* unused asset import */ undefined }
function base_upload_url() { return /* unused asset import */ undefined }
function base_user_url() { return /* unused asset import */ undefined }
function best_trade_url() { return /* unused asset import */ undefined }
function blue_pin_url() { return /* unused asset import */ undefined }
function bordered_success_url() { return /* unused asset import */ undefined }
function busy_wallet_nav_url() { return /* unused asset import */ undefined }
function buy_url() { return /* unused asset import */ undefined }
function cached_url() { return /* unused asset import */ undefined }
function candle_url() { return /* unused asset import */ undefined }
function card_url() { return /* unused asset import */ undefined }
function check_url() { return /* unused asset import */ undefined }
function checkbox_url() { return /* unused asset import */ undefined }
function checkbox_blank_url() { return /* unused asset import */ undefined }
function checkbox_border_url() { return /* unused asset import */ undefined }
function checkbox_no_url() { return /* unused asset import */ undefined }
function check_circle_url() { return /* unused asset import */ undefined }
function chevron_up_url() { return /* unused asset import */ undefined }
function china_url() { return /* unused asset import */ undefined }
function circle_close_url() { return /* unused asset import */ undefined }
function circle_loading_url() { return /* unused asset import */ undefined }
function circle_warning_url() { return /* unused asset import */ undefined }
function clear_dark_url() { return /* unused asset import */ undefined }
function clear_light_url() { return /* unused asset import */ undefined }
function close_url() { return /* unused asset import */ undefined }
function cloud_url() { return /* unused asset import */ undefined }
function cloud_backup_url() { return /* unused asset import */ undefined }
function cloud_backup_2_url() { return /* unused asset import */ undefined }
function cloud_link_url() { return /* unused asset import */ undefined }
function cny_url() { return /* unused asset import */ undefined }
function collectible_url() { return /* unused asset import */ undefined }
function comeback_url() { return /* unused asset import */ undefined }
function connect_url() { return /* unused asset import */ undefined }
function contacts_url() { return /* unused asset import */ undefined }
function copy_url() { return /* unused asset import */ undefined }
function currency_url() { return /* unused asset import */ undefined }
function dark_url() { return /* unused asset import */ undefined }
function decrease_url() { return /* unused asset import */ undefined }
function default_token_dark_url() { return /* unused asset import */ undefined }
function default_token_dim_url() { return /* unused asset import */ undefined }
function default_token_light_url() { return /* unused asset import */ undefined }
function delete_url() { return /* unused asset import */ undefined }
function disconnect_url() { return /* unused asset import */ undefined }
function document_url() { return /* unused asset import */ undefined }
function documents_url() { return /* unused asset import */ undefined }
function download_url() { return /* unused asset import */ undefined }
function download_2_url() { return /* unused asset import */ undefined }
function drop_url() { return /* unused asset import */ undefined }
function dump_url() { return /* unused asset import */ undefined }
function edit_url() { return /* unused asset import */ undefined }
function edit_2_url() { return /* unused asset import */ undefined }
function empty_url() { return /* unused asset import */ undefined }
function empty_simple_dark_url() { return /* unused asset import */ undefined }
function empty_simple_light_url() { return /* unused asset import */ undefined }
function encrypted_files_url() { return /* unused asset import */ undefined }
function europe_url() { return /* unused asset import */ undefined }
function eye_dark_url() { return /* unused asset import */ undefined }
function eye_light_url() { return /* unused asset import */ undefined }
function eye_color_url() { return /* unused asset import */ undefined }
function eye_off_dark_url() { return /* unused asset import */ undefined }
function eye_off_light_url() { return /* unused asset import */ undefined }
function facebook_url() { return /* unused asset import */ undefined }
function file_url() { return /* unused asset import */ undefined }
function file_message_url() { return /* unused asset import */ undefined }
function fill_success_url() { return /* unused asset import */ undefined }
function filter_url() { return /* unused asset import */ undefined }
function flag_url() { return /* unused asset import */ undefined }
function folder_url() { return /* unused asset import */ undefined }
function gas_url() { return /* unused asset import */ undefined }
function gas_station_url() { return /* unused asset import */ undefined }
function gear_dark_url() { return /* unused asset import */ undefined }
function gear_light_url() { return /* unused asset import */ undefined }
function gear_settings_url() { return /* unused asset import */ undefined }
function globe_url() { return /* unused asset import */ undefined }
function gray_masks_url() { return /* unused asset import */ undefined }
function hamburger_menu_url() { return /* unused asset import */ undefined }
function history_url() { return /* unused asset import */ undefined }
function hkd_url() { return /* unused asset import */ undefined }
function hong_kong_url() { return /* unused asset import */ undefined }
function identity_dark_url() { return /* unused asset import */ undefined }
function identity_light_url() { return /* unused asset import */ undefined }
function info_dark_url() { return /* unused asset import */ undefined }
function info_light_url() { return /* unused asset import */ undefined }
function interaction_url() { return /* unused asset import */ undefined }
function interaction_circle_url() { return /* unused asset import */ undefined }
function japan_url() { return /* unused asset import */ undefined }
function jpy_url() { return /* unused asset import */ undefined }
function key_square_url() { return /* unused asset import */ undefined }
function left_arrow_url() { return /* unused asset import */ undefined }
function linear_calendar_dark_url() { return /* unused asset import */ undefined }
function linear_calendar_light_url() { return /* unused asset import */ undefined }
function link_url() { return /* unused asset import */ undefined }
function link_out_url() { return /* unused asset import */ undefined }
function loader_url() { return /* unused asset import */ undefined }
function loading_base_dark_url() { return /* unused asset import */ undefined }
function loading_base_light_url() { return /* unused asset import */ undefined }
function local_backup_url() { return /* unused asset import */ undefined }
function lock_url() { return /* unused asset import */ undefined }
function mask_avatar_dark_url() { return /* unused asset import */ undefined }
function mask_avatar_light_url() { return /* unused asset import */ undefined }
function mask_in_minds_url() { return /* unused asset import */ undefined }
function mask_me_url() { return /* unused asset import */ undefined }
function masks_url() { return /* unused asset import */ undefined }
function message_url() { return /* unused asset import */ undefined }
function mnemonic_url() { return /* unused asset import */ undefined }
function more_url() { return /* unused asset import */ undefined }
function next_id_avatar_dark_url() { return /* unused asset import */ undefined }
function next_id_avatar_light_url() { return /* unused asset import */ undefined }
function next_id_persona_warning_url() { return /* unused asset import */ undefined }
function nft_red_packet_url() { return /* unused asset import */ undefined }
function outlined_mask_url() { return /* unused asset import */ undefined }
function personas_outline_url() { return /* unused asset import */ undefined }
function pin_dark_url() { return /* unused asset import */ undefined }
function pin_light_url() { return /* unused asset import */ undefined }
function play_dark_url() { return /* unused asset import */ undefined }
function play_url() { return /* unused asset import */ undefined }
function plugin_url() { return /* unused asset import */ undefined }
function plugins_url() { return /* unused asset import */ undefined }
function popup_close_url() { return /* unused asset import */ undefined }
function popup_link_url() { return /* unused asset import */ undefined }
function popup_restore_url() { return /* unused asset import */ undefined }
function popup_trash_url() { return /* unused asset import */ undefined }
function primary_info_url() { return /* unused asset import */ undefined }
function provider_url() { return /* unused asset import */ undefined }
function public_key_dark_url() { return /* unused asset import */ undefined }
function public_key_light_url() { return /* unused asset import */ undefined }
function public_key_2_url() { return /* unused asset import */ undefined }
function questions_url() { return /* unused asset import */ undefined }
function radio_button_checked_url() { return /* unused asset import */ undefined }
function radio_button_un_checked_url() { return /* unused asset import */ undefined }
function radio_no_dark_url() { return /* unused asset import */ undefined }
function radio_no_light_url() { return /* unused asset import */ undefined }
function receive_colorful_url() { return /* unused asset import */ undefined }
function red_packet_url() { return /* unused asset import */ undefined }
function refresh_url() { return /* unused asset import */ undefined }
function restore_url() { return /* unused asset import */ undefined }
function restore_colorful_url() { return /* unused asset import */ undefined }
function retweet_dark_url() { return /* unused asset import */ undefined }
function retweet_light_url() { return /* unused asset import */ undefined }
function right_url() { return /* unused asset import */ undefined }
function right_arrow_url() { return /* unused asset import */ undefined }
function risk_url() { return /* unused asset import */ undefined }
function search_url() { return /* unused asset import */ undefined }
function security_risk_url() { return /* unused asset import */ undefined }
function security_warning_url() { return /* unused asset import */ undefined }
function selected_dark_url() { return /* unused asset import */ undefined }
function selected_light_url() { return /* unused asset import */ undefined }
function self_url() { return /* unused asset import */ undefined }
function send_url() { return /* unused asset import */ undefined }
function send_colorful_url() { return /* unused asset import */ undefined }
function setting_url() { return /* unused asset import */ undefined }
function settings_url() { return /* unused asset import */ undefined }
function settings_2_url() { return /* unused asset import */ undefined }
function sharp_mask_url() { return /* unused asset import */ undefined }
function sign_up_account_url() { return /* unused asset import */ undefined }
function smart_pay_url() { return /* unused asset import */ undefined }
function star_url() { return /* unused asset import */ undefined }
function success_url() { return /* unused asset import */ undefined }
function success_for_snack_bar_url() { return /* unused asset import */ undefined }
function sun_url() { return /* unused asset import */ undefined }
function swap_url() { return /* unused asset import */ undefined }
function swap_colorful_url() { return /* unused asset import */ undefined }
function switch_logo_dark_url() { return /* unused asset import */ undefined }
function switch_logo_light_url() { return /* unused asset import */ undefined }
function telegram_round_gray_url() { return /* unused asset import */ undefined }
function tick_url() { return /* unused asset import */ undefined }
function time_url() { return /* unused asset import */ undefined }
function tips_url() { return /* unused asset import */ undefined }
function transaction_failed_url() { return /* unused asset import */ undefined }
function trash_url() { return /* unused asset import */ undefined }
function trash_line_url() { return /* unused asset import */ undefined }
function tutorial_url() { return /* unused asset import */ undefined }
function twitter_url() { return /* unused asset import */ undefined }
function twitter_stroke_url() { return /* unused asset import */ undefined }
function tx_in_url() { return /* unused asset import */ undefined }
function tx_out_url() { return /* unused asset import */ undefined }
function undo_url() { return /* unused asset import */ undefined }
function upload_url() { return /* unused asset import */ undefined }
function usd_url() { return /* unused asset import */ undefined }
function user_url() { return /* unused asset import */ undefined }
function verification_url() { return /* unused asset import */ undefined }
function wallet_url() { return /* unused asset import */ undefined }
function wallet_nav_url() { return /* unused asset import */ undefined }
function wallet_setting_url() { return /* unused asset import */ undefined }
function warning_url() { return /* unused asset import */ undefined }
function warning_triangle_url() { return /* unused asset import */ undefined }
function web_url() { return /* unused asset import */ undefined }
function web_black_dark_url() { return /* unused asset import */ undefined }
function web_black_light_url() { return /* unused asset import */ undefined }
function menu_personas_url() { return /* unused asset import */ undefined }
function menu_personas_active_url() { return /* unused asset import */ undefined }
function menu_settings_url() { return /* unused asset import */ undefined }
function menu_settings_active_url() { return /* unused asset import */ undefined }
function menu_wallets_url() { return /* unused asset import */ undefined }
function menu_wallets_active_url() { return /* unused asset import */ undefined }
function approval_url() { return /* unused asset import */ undefined }
function art_blocks_url() { return /* unused asset import */ undefined }
function avatar_url() { return /* unused asset import */ undefined }
function bit_url() { return /* unused asset import */ undefined }
function calendar_url() { return /* unused asset import */ undefined }
function collectibles_url() { return /* unused asset import */ undefined }
function cross_bridge_url() { return /* unused asset import */ undefined }
function cyber_connect_dark_url() { return /* unused asset import */ undefined }
function cyber_connect_light_url() { return /* unused asset import */ undefined }
function decentralized_search_url() { return /* unused asset import */ undefined }
function ens_url() { return /* unused asset import */ undefined }
function ens_cover_url() { return /* unused asset import */ undefined }
function file_service_url() { return /* unused asset import */ undefined }
function find_truman_url() { return /* unused asset import */ undefined }
function gitcoin_dark_url() { return /* unused asset import */ undefined }
function gitcoin_light_url() { return /* unused asset import */ undefined }
function good_ghosting_dark_url() { return /* unused asset import */ undefined }
function good_ghosting_light_url() { return /* unused asset import */ undefined }
function markets_url() { return /* unused asset import */ undefined }
function markets_claim_url() { return /* unused asset import */ undefined }
function mask_box_url() { return /* unused asset import */ undefined }
function nft_avatar_url() { return /* unused asset import */ undefined }
function pool_together_url() { return /* unused asset import */ undefined }
function savings_url() { return /* unused asset import */ undefined }
function scam_sniffer_url() { return /* unused asset import */ undefined }
function security_checker_url() { return /* unused asset import */ undefined }
function setting_info_dark_url() { return /* unused asset import */ undefined }
function setting_info_light_url() { return /* unused asset import */ undefined }
function shared_url() { return /* unused asset import */ undefined }
function snapshot_url() { return /* unused asset import */ undefined }
function space_id_url() { return /* unused asset import */ undefined }
function tip_coin_url() { return /* unused asset import */ undefined }
function transak_url() { return /* unused asset import */ undefined }
function unstoppable_url() { return /* unused asset import */ undefined }
function valuables_dark_url() { return /* unused asset import */ undefined }
function valuables_light_url() { return /* unused asset import */ undefined }
function web_3_profile_url() { return /* unused asset import */ undefined }
function web_3_profile_card_url() { return /* unused asset import */ undefined }
function achievement_burn_url() { return /* unused asset import */ undefined }
function achievement_receive_url() { return /* unused asset import */ undefined }
function approval_approve_url() { return /* unused asset import */ undefined }
function collectible_approve_url() { return /* unused asset import */ undefined }
function collectible_burn_url() { return /* unused asset import */ undefined }
function collectible_in_url() { return /* unused asset import */ undefined }
function collectible_mint_url() { return /* unused asset import */ undefined }
function collectible_out_url() { return /* unused asset import */ undefined }
function donation_donate_url() { return /* unused asset import */ undefined }
function donation_launch_url() { return /* unused asset import */ undefined }
function follow_url() { return /* unused asset import */ undefined }
function governance_propose_url() { return /* unused asset import */ undefined }
function governance_vote_url() { return /* unused asset import */ undefined }
function note_burn_url() { return /* unused asset import */ undefined }
function note_create_url() { return /* unused asset import */ undefined }
function note_edit_url() { return /* unused asset import */ undefined }
function note_link_url() { return /* unused asset import */ undefined }
function note_mint_url() { return /* unused asset import */ undefined }
function profile_burn_url() { return /* unused asset import */ undefined }
function profile_create_url() { return /* unused asset import */ undefined }
function profile_link_url() { return /* unused asset import */ undefined }
function profile_proxy_url() { return /* unused asset import */ undefined }
function profile_update_url() { return /* unused asset import */ undefined }
function rss_3_link_url() { return /* unused asset import */ undefined }
function token_bridge_url() { return /* unused asset import */ undefined }
function token_burn_url() { return /* unused asset import */ undefined }
function token_in_url() { return /* unused asset import */ undefined }
function token_liquidity_url() { return /* unused asset import */ undefined }
function token_mint_url() { return /* unused asset import */ undefined }
function token_out_url() { return /* unused asset import */ undefined }
function token_stake_url() { return /* unused asset import */ undefined }
function token_swap_url() { return /* unused asset import */ undefined }
function token_unstake_url() { return /* unused asset import */ undefined }
function unfollow_url() { return /* unused asset import */ undefined }
function unknown_burn_url() { return /* unused asset import */ undefined }
function unknown_cancel_url() { return /* unused asset import */ undefined }
function unknown_in_url() { return /* unused asset import */ undefined }
function unknown_out_url() { return /* unused asset import */ undefined }
function cn_url() { return /* unused asset import */ undefined }
function email_url() { return /* unused asset import */ undefined }
function jp_url() { return /* unused asset import */ undefined }
function kr_url() { return /* unused asset import */ undefined }
function settings_appearance_dark_url() { return /* unused asset import */ undefined }
function settings_appearance_light_url() { return /* unused asset import */ undefined }
function settings_backup_dark_url() { return /* unused asset import */ undefined }
function settings_backup_light_url() { return /* unused asset import */ undefined }
function settings_email_dark_url() { return /* unused asset import */ undefined }
function settings_email_light_url() { return /* unused asset import */ undefined }
function settings_language_dark_url() { return /* unused asset import */ undefined }
function settings_language_light_url() { return /* unused asset import */ undefined }
function settings_password_dark_url() { return /* unused asset import */ undefined }
function settings_password_light_url() { return /* unused asset import */ undefined }
function settings_phone_dark_url() { return /* unused asset import */ undefined }
function settings_phone_light_url() { return /* unused asset import */ undefined }
function settings_restore_dark_url() { return /* unused asset import */ undefined }
function settings_restore_light_url() { return /* unused asset import */ undefined }
function settings_sync_dark_url() { return /* unused asset import */ undefined }
function settings_sync_light_url() { return /* unused asset import */ undefined }
function uk_url() { return /* unused asset import */ undefined }

/***/ }),

/***/ 44513:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   v: () => (/* binding */ MaskIconPaletteContext)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78996);


const MaskIconPaletteContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext('dark')
MaskIconPaletteContext.displayName = 'MaskIconPaletteContext'


/***/ }),

/***/ 77745:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   x: () => (/* binding */ __createIcon)
/* harmony export */ });
/* harmony import */ var _mui_material__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(78130);
/* harmony import */ var _mui_material__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43204);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78996);
/* harmony import */ var _MaskIconPaletteContext_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(44513);




/**
 * @typedef {[currentVariant: null | string[], url: string, jsx: object | null, supportColor?: boolean]} RawIcon
 */

/**
 * @param {string} name
 * @param {Array<import('./internal.js').__RawIcon__>} variants
 * @param {[number, number]} intrinsicSize
 * @returns {React.ComponentType<import('./internal').GeneratedIconProps>}
 */
function __createIcon(name, variants, intrinsicSize = [24, 24]) {
    function Icon(/** @type {import('./internal').GeneratedIconProps} */ props, ref) {
        /* eslint-disable */
        let { size = 24, variant, color, sx, height, width, ...rest } = props

        const hasClickHandler = rest.onClick

        const defaultPalette = useDefaultPalette()
        const selected = selectVariant(variants, variant || defaultPalette)
        const url = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(selected.u, [selected])
        const jsx = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(selected.j || undefine_f, [selected])
        const supportColor = selected.s

        const iconStyle = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
            const bg = supportColor
                ? null
                : {
                      backgroundImage: `url(${url})`,
                      backgroundSize: 'contain',
                  }
            const base = {
                display: 'inline-block',
                backgroundRepeat: 'no-repeat',
                backgroundPosition: 'center',
                flexShrink: 0,
                aspectRatio: String(intrinsicSize[0] / intrinsicSize[1]),
                '--icon-color': color, // for dynamic color with var()
                color: color ? `var(--icon-color, var(--default-color))` : undefined, // for dynamic color with `currentColor`
                height: height ?? size,
                width: width ?? size,
            }
            if (hasClickHandler) base.cursor = 'pointer'

            return {
                ...base,
                ...bg,
            }
        }, [selected, height, width, size, hasClickHandler, color])

        const iconProps = {
            'aria-hidden': true,
            ...rest,
            ref,
            'data-icon': name,
            sx: { ...iconStyle, ...sx },
            // To align icon center.
            fontSize: 0,
        }
        if (hasClickHandler) {
            iconProps['aria-hidden'] = false
            iconProps['role'] = 'button'
        }
        if (supportColor && jsx) {
            iconProps.component = 'span'
            return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, iconProps, jsx)
        }
        iconProps.component = 'span'
        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, iconProps)
    }
    Icon.displayName = name
    return react__WEBPACK_IMPORTED_MODULE_0__.memo(react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(Icon))
}

function useDefaultPalette() {
    const palette = react__WEBPACK_IMPORTED_MODULE_0__.useContext(_MaskIconPaletteContext_js__WEBPACK_IMPORTED_MODULE_2__/* .MaskIconPaletteContext */ .v)

    const theme = (0,_mui_material__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)()
    const isDarkMode = theme.palette.mode === 'dark'
    if (isDarkMode && palette === 'dim') return 'dim'
    return theme.palette.mode
}

/**
 * @param {Array<import('./internal.js').__RawIcon__>} variants
 * @param {string} palette
 */
function selectVariant(variants, palette) {
    if (variants.length === 1) return variants[0]

    const light = variants.find((x) => !x.c || x.c.includes('light'))
    // !x.c means light
    const dark = variants.find((x) => x.c?.includes('dark'))
    const dim = variants.find((x) => x.c?.includes('dim'))

    if (palette === 'light') return light || dark || dim || variants[0]
    if (palette === 'dark') return dark || dim || light || variants[0]
    if (palette === 'dim') return dim || dark || light || variants[0]
    return variants[0]
}

function undefine_f() {
    return void 0
}


/***/ }),

/***/ 37415:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"sha224WithRSAEncryption":{"sign":"rsa","hash":"sha224","id":"302d300d06096086480165030402040500041c"},"RSA-SHA224":{"sign":"ecdsa/rsa","hash":"sha224","id":"302d300d06096086480165030402040500041c"},"sha256WithRSAEncryption":{"sign":"rsa","hash":"sha256","id":"3031300d060960864801650304020105000420"},"RSA-SHA256":{"sign":"ecdsa/rsa","hash":"sha256","id":"3031300d060960864801650304020105000420"},"sha384WithRSAEncryption":{"sign":"rsa","hash":"sha384","id":"3041300d060960864801650304020205000430"},"RSA-SHA384":{"sign":"ecdsa/rsa","hash":"sha384","id":"3041300d060960864801650304020205000430"},"sha512WithRSAEncryption":{"sign":"rsa","hash":"sha512","id":"3051300d060960864801650304020305000440"},"RSA-SHA512":{"sign":"ecdsa/rsa","hash":"sha512","id":"3051300d060960864801650304020305000440"},"RSA-SHA1":{"sign":"rsa","hash":"sha1","id":"3021300906052b0e03021a05000414"},"ecdsa-with-SHA1":{"sign":"ecdsa","hash":"sha1","id":""},"sha256":{"sign":"ecdsa","hash":"sha256","id":""},"sha224":{"sign":"ecdsa","hash":"sha224","id":""},"sha384":{"sign":"ecdsa","hash":"sha384","id":""},"sha512":{"sign":"ecdsa","hash":"sha512","id":""},"DSA-SHA":{"sign":"dsa","hash":"sha1","id":""},"DSA-SHA1":{"sign":"dsa","hash":"sha1","id":""},"DSA":{"sign":"dsa","hash":"sha1","id":""},"DSA-WITH-SHA224":{"sign":"dsa","hash":"sha224","id":""},"DSA-SHA224":{"sign":"dsa","hash":"sha224","id":""},"DSA-WITH-SHA256":{"sign":"dsa","hash":"sha256","id":""},"DSA-SHA256":{"sign":"dsa","hash":"sha256","id":""},"DSA-WITH-SHA384":{"sign":"dsa","hash":"sha384","id":""},"DSA-SHA384":{"sign":"dsa","hash":"sha384","id":""},"DSA-WITH-SHA512":{"sign":"dsa","hash":"sha512","id":""},"DSA-SHA512":{"sign":"dsa","hash":"sha512","id":""},"DSA-RIPEMD160":{"sign":"dsa","hash":"rmd160","id":""},"ripemd160WithRSA":{"sign":"rsa","hash":"rmd160","id":"3021300906052b2403020105000414"},"RSA-RIPEMD160":{"sign":"rsa","hash":"rmd160","id":"3021300906052b2403020105000414"},"md5WithRSAEncryption":{"sign":"rsa","hash":"md5","id":"3020300c06082a864886f70d020505000410"},"RSA-MD5":{"sign":"rsa","hash":"md5","id":"3020300c06082a864886f70d020505000410"}}');

/***/ }),

/***/ 35121:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"1.3.132.0.10":"secp256k1","1.3.132.0.33":"p224","1.2.840.10045.3.1.1":"p192","1.2.840.10045.3.1.7":"p256","1.3.132.0.34":"p384","1.3.132.0.35":"p521"}');

/***/ }),

/***/ 57592:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"modp1":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"},"modp2":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"},"modp5":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"},"modp14":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"},"modp15":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"},"modp16":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"},"modp17":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"},"modp18":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"}}');

/***/ }),

/***/ 22087:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"2.16.840.1.101.3.4.1.1":"aes-128-ecb","2.16.840.1.101.3.4.1.2":"aes-128-cbc","2.16.840.1.101.3.4.1.3":"aes-128-ofb","2.16.840.1.101.3.4.1.4":"aes-128-cfb","2.16.840.1.101.3.4.1.21":"aes-192-ecb","2.16.840.1.101.3.4.1.22":"aes-192-cbc","2.16.840.1.101.3.4.1.23":"aes-192-ofb","2.16.840.1.101.3.4.1.24":"aes-192-cfb","2.16.840.1.101.3.4.1.41":"aes-256-ecb","2.16.840.1.101.3.4.1.42":"aes-256-cbc","2.16.840.1.101.3.4.1.43":"aes-256-ofb","2.16.840.1.101.3.4.1.44":"aes-256-cfb"}');

/***/ }),

/***/ 82007:
/***/ ((module) => {

"use strict";
module.exports = {"version":"1.0.34"};

/***/ }),

/***/ 25828:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"AAVE_SUBGRAPHS":{"Mainnet":"https://api.thegraph.com/subgraphs/name/aave/protocol-v2","Kovan":"https://api.thegraph.com/subgraphs/name/aave/protocol-v2-kovan"},"AAVE_LENDING_POOL_ADDRESSES_PROVIDER_CONTRACT_ADDRESS":{"Mainnet":"0xb53c1a33016b2dc2ff3653530bff1848a515c8c5","Kovan":"0x88757f2f99175387ab4c6a4b3067c77a695b0349"},"AAVE_PROTOCOL_DATA_PROVIDER_CONTRACT_ADDRESS":{"Mainnet":"0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d"}}');

/***/ }),

/***/ 97996:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"CLAIMERS":{"Mainnet":"","Arbitrum":"https://raw.githubusercontent.com/DimensionDev/Mask-Arbitrum-Claimer/master/claimer.json"},"CONTRACT_ADDRESS":{"Mainnet":"","Arbitrum":"0x9A359f736674913e405Eb64C2048c6293DC97CbF"}}');

/***/ }),

/***/ 30390:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"ARB_CONTRACT_ADDRESS":{"Mainnet":"","Arbitrum":"0x5d482D501b369F5bA034DEC5c5fb7A50d2D6Ca20"}}');

/***/ }),

/***/ 978:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"GEN_ART_721_MINTER":{"Mainnet":"0x1DEC9E52f1320F7Deb29cBCd7B7d67f3dF785142","Ropsten":"0xfd50294f1ddeccdf6ea55bc57a15916328177653"}}');

/***/ }),

/***/ 60702:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"PLATFORM_ID":{"Mainnet":"ethereum","BSC":"binance-smart-chain","Base":"base","Matic":"polygon-pos","Arbitrum":"arbitrum-one","xDai":"xdai","Optimism":"optimistic-ethereum","Avalanche":"avalanche","Celo":"celo","Fantom":"fantom","Aurora":"aurora","Astar":"astar","Boba":"boba"},"COIN_ID":{"Mainnet":"ethereum","BSC":"binancecoin","Base":"ethereum","Matic":"matic-network","Arbitrum":"ethereum","xDai":"xdai","Optimism":"ethereum","Avalanche":"avalanche-2","Celo":"celo","Fantom":"fantom","Aurora":"ethereum","Conflux":"conflux-token","Astar":"astar","Pulse":"pulsechain","Moonbeam":"moonbeam","Klaytn":"klay-token","Harmony":"harmony","Moonriver":"moonriver","Cronos":"crypto-com-chain","BitTorrent":"bittorrent","Boba":"boba-network"}}');

/***/ }),

/***/ 74476:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"CRYPTOPUNKS_CONTRACT_ADDRESS":{"Mainnet":"0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB"}}');

/***/ }),

/***/ 92995:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"CHAIN_ID":{"Mainnet":"eth","BSC":"bsc","Base":"base","Matic":"matic","Arbitrum":"arb","xDai":"xdai","Optimism":"op","Avalanche":"avax","Celo":"celo","Fantom":"ftm","Aurora":"aurora","Conflux":"Conflux","Astar":"astar","Pulse":"pls","Harmony":"hmy","Boba":"boba","Brise":"brise","Cronos":"cro","Klaytn":"klay","Moonbeam":"mobm","Moonriver":"movr","Arbitrum_Nova":"nova","Canto":"canto","DFK":"dfk","Dogechain":"doge","Evmos":"evmos","Fuse":"fuse","HuobiEco":"heco","IoTex":"iotx","Kava":"kava","Kcc":"kcc","Metise":"metis","Milkomeda":"mada","OKXChain":"okt","Palm":"palm","RSK":"rsk","SmartBitcoinCash":"sbch","Shiden":"sdn","SongbirdCanary":"sgb","Step":"step","Telos":"tlos","Wanchain":"wan","Scroll":"scrl"}}');

/***/ }),

/***/ 30246:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"ENS_CONTRACT_ADDRESS":{"Mainnet":"0x57f1887a8BF19b14fC0dF6Fd9B2acc9Af147eA85"},"ENS_NAME_WRAPPER_CONTRACT_ADDRESS":{"Mainnet":"0xD4416b13d2b3a9aBae7AcD5D6C2BbDBE25686401"}}');

/***/ }),

/***/ 45831:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"BALANCE_CHECKER_ADDRESS":{"Mainnet":"0xb1F8e55c7f64D203C1400B9D8555d050F94aDF39","Ropsten":"0xD5C432dFbDEcB6068583BC5241D1b308D70721a4","Rinkeby":"0x0987506Bc4C4167E1a6d0Be0e007E4A9609d5c77","BSC":"0xC119574D5Fb333F5AC018658D4d8b5035E16bf39","BSCT":"0x7f004a42D760Eb68eB95Fa50f739917675181fCA","Base":"0x2cF46Db820e279c5fBF778367D49d9C931D54524","Base_Goerli":"0xc3e62b2CC70439C32a381Bfc056aCEd1d7162cef","Matic":"0x6cc1b1058F9153358278C35E0b2D382f1585854B","Mumbai":"0xFEd05EE9b7DdbAb97Abc55e27EF95C7c14688Aad","Arbitrum":"0xAb7B1bE4233A04e5C43a810E75657ECED8E5463B","Arbitrum_Rinkeby":"0xF98dC9391273c5ab9fa2c980A8d4F875ece802db","xDai":"0x96c7D011cdFD467f551605f0f5Fce279F86F4186","Optimism":"0xB1c568e9C3E6bdaf755A60c7418C269eb11524FC","Optimism_Kovan":"0xB1c568e9C3E6bdaf755A60c7418C269eb11524FC","Avalanche":"0xC119574D5Fb333F5AC018658D4d8b5035E16bf39","Celo":"0x8e28F1d64ceD52b9A09aB1AA3071Aa3c05802d1F","Fantom":"0xc119574d5fb333f5ac018658d4d8b5035e16bf39","Aurora":"0xC119574D5Fb333F5AC018658D4d8b5035E16bf39","Astar":"0xf5056B96ab242C566002852d0b98ce0BcDf1af51","Scroll":"0xbC7d98985966f56A66B0cB5F23d865676dc2ac84"},"MULTICALL_ADDRESS":{"Mainnet":"0x1F98415757620B543A52E61c46B32eB19261F984","Ropsten":"0x1F98415757620B543A52E61c46B32eB19261F984","Rinkeby":"0x1F98415757620B543A52E61c46B32eB19261F984","Kovan":"0x1F98415757620B543A52E61c46B32eB19261F984","Gorli":"0x1F98415757620B543A52E61c46B32eB19261F984","BSC":"0x5211fe40fE49a13CC86E3bC77855152457eDE585","Base":"0xb1A316f63FE588c7103a135372c3eCd8a1A479De","Base_Goerli":"0x3A71F021bd2320Ea92313874EA401716605D130F","Matic":"0x54c06a5D7C6447BE47E07390eD7da7e6994585f4","Mumbai":"0x7b48A507567B744EBcFB78DDf8CE2489ebA448b9","Arbitrum":"0xadF885960B47eA2CD9B55E6DAc6B42b7Cb2806dB","Arbitrum_Rinkeby":"0xa501c031958F579dB7676fF1CE78AD305794d579","xDai":"0xAb7B1bE4233A04e5C43a810E75657ECED8E5463B","Optimism":"0x1F98415757620B543A52E61c46B32eB19261F984","Optimism_Kovan":"0x1F98415757620B543A52E61c46B32eB19261F984","Optimism_Goerli":"0x1F98415757620B543A52E61c46B32eB19261F984","Avalanche":"0x6cc1b1058F9153358278C35E0b2D382f1585854B","Celo":"0x072453AdEC16cFC7FB6Af1517c3f25407180cccC","Fantom":"0x913975af2Bb8a6Be4100D7dc5e9765B77F6A5d6c","Aurora":"0x6cc1b1058F9153358278C35E0b2D382f1585854B","Conflux":"0x19f179d7e0d7d9f9d5386afff64271d98a91615b","Astar":"0x1410304B91a280ad083196B0B50e9d8df749d860","Scroll":"0x20Ee232E34B87061fE3ba0DB738A3531A3e915BF"},"ENS_REGISTRAR_ADDRESS":{"Mainnet":"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e","Ropsten":"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e","Rinkeby":"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e","Kovan":"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e","Gorli":"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"},"ENS_REVERSE_RECORDS_ADDRESS":{"Mainnet":"0x3671aE578E63FdF66ad4F3E12CC0c0d71Ac7510C","Ropsten":"0x3671aE578E63FdF66ad4F3E12CC0c0d71Ac7510C","Rinkeby":"0x3671aE578E63FdF66ad4F3E12CC0c0d71Ac7510C","Kovan":"0x3671aE578E63FdF66ad4F3E12CC0c0d71Ac7510C","Gorli":"0x3671aE578E63FdF66ad4F3E12CC0c0d71Ac7510C"}}');

/***/ }),

/***/ 68818:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"ETHERSCAN_URL":{"Mainnet":"https://etherscan-proxy.r2d2.to","BSC":"https://etherscan-proxy.r2d2.to","Base":"https://etherscan-proxy.r2d2.to","Matic":"https://etherscan-proxy.r2d2.to","Arbitrum":"https://etherscan-proxy.r2d2.to","xDai":"https://etherscan-proxy.r2d2.to","Optimism":"https://etherscan-proxy.r2d2.to","Optimism_Kovan":"https://etherscan-proxy.r2d2.to","Optimism_Goerli":"https://etherscan-proxy.r2d2.to","Avalanche":"https://etherscan-proxy.r2d2.to","Avalanche_Fuji":"https://etherscan-proxy.r2d2.to","Celo":"https://etherscan-proxy.r2d2.to","Fantom":"https://etherscan-proxy.r2d2.to","Aurora":"https://etherscan-proxy.r2d2.to","Aurora_Testnet":"https://etherscan-proxy.r2d2.to","Conflux":"https://etherscan-proxy.r2d2.to","Astar":"https://etherscan-proxy.r2d2.to"}}');

/***/ }),

/***/ 72071:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"GITCOIN_MAINTAINER_ADDRESS":{"Mainnet":"0xde21F729137C5Af1b01d73aF1dC21eFfa2B8a0d6","Rinkeby":"0xde21F729137C5Af1b01d73aF1dC21eFfa2B8a0d6","Matic":"0x366adf5b96ee15aff5d66b0fa44a56330b55e97b","Mumbai":"0x366adf5b96ee15aff5d66b0fa44a56330b55e97b"},"BULK_CHECKOUT_ADDRESS":{"Mainnet":"0x7d655c57f71464B6f83811C55D84009Cd9f5221C","Rinkeby":"0x7d655c57f71464B6f83811C55D84009Cd9f5221C","Matic":"0xb99080b9407436eBb2b8Fe56D45fFA47E9bb8877","Mumbai":"0x3E2849E2A489C8fE47F52847c42aF2E8A82B9973"},"GITCOIN_ETH_ADDRESS":{"Mainnet":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","Rinkeby":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","BSC":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","Matic":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","Mumbai":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"},"TOKEN_LIST":{"Mainnet":["0x0000000000000000000000000000000000000000","0x7D1AfA7B718fb893dB30A3aBc0Cfc608AaCfeBB0","0x6B175474E89094C44Da98b954EedeAC495271d0F","0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48","0xdAC17F958D2ee523a2206206994597C13D831ec7","0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2","0xDd1Ad9A21Ce722C151A836373baBe42c868cE9a4","0x0D8775F648430679A709E98d2b0Cb6250d2887EF","0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C","0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599","0x1a4b46696b2bb4794eb3d4c26f1c55f9170fa4c5","0xc944E90C64B2c07662A292be6244BDf05Cda44a7","0x111111111117dC0aa78b770fA6A738034120C302","0x69af81e73A73B40adF4f3d4223Cd9b1ECE623074","0x0F5D2fB29fb7d3CFeE444a200298f468908cC942","0x5A98FcBEA516Cf06857215779Fd812CA3beF1B32","0x514910771AF9Ca656af840dff83E8264EcF986CA","0x9469D013805bFfB7D3DEBe5E7839237e535ec483","0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984"],"Ropsten":[],"Rinkeby":[],"Kovan":[],"Gorli":[],"BSC":["0x0000000000000000000000000000000000000000","0xcf6bb5389c92bdda8a3747ddb454cb7a64626c63","0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56"],"BSCT":[],"Base":[],"Base_Goerli":[],"Matic":["0x0000000000000000000000000000000000000000","0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619","0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174","0xc2132D05D31c914a87C6611C10748AEb04B58e8F","0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063"],"Mumbai":[],"Arbitrum":[],"Arbitrum_Rinkeby":[],"xDai":[],"Optimism":[],"Optimism_Kovan":[],"Optimism_Goerli":[],"Avalanche":[],"Avalanche_Fuji":[],"Celo":[],"Fantom":[],"Aurora":[],"Aurora_Testnet":[],"Conflux":[],"Astar":[]}}');

/***/ }),

/***/ 1389:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"WHITE_LISTS":{"Mainnet":["0x69af81e73A73B40adF4f3d4223Cd9b1ECE623074"],"Ropsten":["0x5B966f3a32Db9C180843bCb40267A66b73E4f022"],"Rinkeby":["0xFD9Eb54f6aC885079e7bB3E207922Bb7256E3fcb"],"Kovan":[],"Gorli":[],"BSC":["0x2eD9a5C8C13b93955103B9a7C167B67Ef4d568a3"],"BSCT":[],"Base":[],"Base_Goerli":[],"Matic":["0x2B9E7ccDF0F4e5B24757c1E1a80e311E34Cb10c7"],"Mumbai":[],"Arbitrum":[],"Arbitrum_Rinkeby":[],"xDai":[],"Optimism":[],"Optimism_Kovan":[],"Optimism_Goerli":[],"Avalanche":[],"Avalanche_Fuji":[],"Celo":[],"Fantom":[],"Aurora":[],"Aurora_Testnet":[],"Conflux":[],"Astar":[]}}');

/***/ }),

/***/ 59740:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"LENS_PROFILE_CONTRACT_ADDRESS":{"Mainnet":"","Matic":"0xDb46d1Dc155634FbC732f92E853b10B288AD5a1d"}}');

/***/ }),

/***/ 38186:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"LENS_HUB_PROXY_CONTRACT_ADDRESS":{"Mainnet":"","Matic":"0xDb46d1Dc155634FbC732f92E853b10B288AD5a1d"}}');

/***/ }),

/***/ 3278:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"LIDO_stETH_ADDRESS":{"Mainnet":"0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84","Gorli":"0x1643E812aE58766192Cf7D2Cf9567dF2C37e9B7F"},"LIDO_REFERRAL_ADDRESS":{"Mainnet":"0x934b510d4c9103e6a87aef13b816fb080286d649","Ropsten":"0x934b510d4c9103e6a87aef13b816fb080286d649","Rinkeby":"0x934b510d4c9103e6a87aef13b816fb080286d649","Kovan":"0x934b510d4c9103e6a87aef13b816fb080286d649","Gorli":"0x934b510d4c9103e6a87aef13b816fb080286d649","BSC":"0x934b510d4c9103e6a87aef13b816fb080286d649","BSCT":"0x934b510d4c9103e6a87aef13b816fb080286d649","Matic":"0x934b510d4c9103e6a87aef13b816fb080286d649","Mumbai":"0x934b510d4c9103e6a87aef13b816fb080286d649","Arbitrum":"0x934b510d4c9103e6a87aef13b816fb080286d649","Arbitrum_Rinkeby":"0x934b510d4c9103e6a87aef13b816fb080286d649","xDai":"0x934b510d4c9103e6a87aef13b816fb080286d649","Avalanche":"0x934b510d4c9103e6a87aef13b816fb080286d649","Avalanche_Fuji":"0x934b510d4c9103e6a87aef13b816fb080286d649","Celo":"0x934b510d4c9103e6a87aef13b816fb080286d649","Fantom":"0x934b510d4c9103e6a87aef13b816fb080286d649","Aurora":"0x934b510d4c9103e6a87aef13b816fb080286d649","Aurora_Testnet":"0x934b510d4c9103e6a87aef13b816fb080286d649"}}');

/***/ }),

/***/ 1353:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"MASK_BOX_CONTRACT_ADDRESS":{"Mainnet":"0x294428f04b0F9EbC49B7Ad61E2736ebD6808c145","Rinkeby":"0xF8ED169BC0cdA735A88d32AC10b88AA5B69181ac","Base":"0xc3e62b2CC70439C32a381Bfc056aCEd1d7162cef","Base_Goerli":"0x8D03d9b43e98Cc2f790Be4E96503fD0CcFd04a2D","Matic":"0x02F98667b3A1202a320F67a669a5e4e451fD0cc1","Optimism":"0x9D205B3A1B2724d545Ca7e3717ea629b9844401a","Optimism_Kovan":"0xdb93ccd481012bb5d1e2c8d0af7c5f2940c00fdc","Avalanche":"0x05ee315E407C21a594f807D61d6CC11306D1F149","Avalanche_Fuji":"0xae5c53294003f72b27cef476680979453193673d","Aurora":"0xf5056B96ab242C566002852d0b98ce0BcDf1af51","Aurora_Testnet":"0xB4D669bc117735FdA44e90e52795132187705B21","Astar":"0x041Bdc5b713aFc3AA06b9511E1e55552138b139A"},"MASK_BOX_CONTRACT_FROM_BLOCK":{"Mainnet":13687866,"Ropsten":0,"Rinkeby":9369286,"Kovan":0,"Gorli":0,"BSC":0,"BSCT":0,"Base":0,"Base_Goerli":0,"Matic":21774098,"Mumbai":0,"Arbitrum":0,"Arbitrum_Rinkeby":0,"xDai":0,"Optimism":1272779,"Optimism_Kovan":0,"Optimism_Goerli":0,"Avalanche":8351767,"Avalanche_Fuji":4752026,"Celo":0,"Fantom":0,"Aurora":57259004,"Aurora_Testnet":77919118,"Conflux":0,"Astar":911315}}');

/***/ }),

/***/ 62337:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"RED_PACKET_NFT_ADDRESS":{"Mainnet":"0x8d285739523FC2Ac8eC9c9C229ee863C8C9bF8C8","BSC":"0xf8968e1Fcf1440Be5Cec7Bb495bcee79753d5E06","Base":"0xbC7d98985966f56A66B0cB5F23d865676dc2ac84","Base_Goerli":"0x727F8030964CCEC6B0E344399c8d8E2B4C837351","Matic":"0xf6Dc042717EF4C097348bE00f4BaE688dcaDD4eA","Optimism":"0xC86e48D8FE6E8b999840927859290F4e41bDa779","Optimism_Kovan":"0x2690906609A9AF3bF08B8384CD9A0F97A88A7E9c","Avalanche":"0x96c7D011cdFD467f551605f0f5Fce279F86F4186","Avalanche_Fuji":"0x5de932BD252DD79231C9eDB5F2e30D488B785109","Aurora":"0x05ee315E407C21a594f807D61d6CC11306D1F149","Aurora_Testnet":"0x97369fEE7db34E0BfE47861f2ec44b4378d13eB4","Conflux":"0x5b966f3a32db9c180843bcb40267a66b73e4f022","Astar":"0xc3e62b2CC70439C32a381Bfc056aCEd1d7162cef","Scroll":"0x727F8030964CCEC6B0E344399c8d8E2B4C837351"},"NFT_RED_PACKET_ADDRESS_BLOCK_HEIGHT":{"Mainnet":13229711,"Ropsten":0,"Rinkeby":0,"Kovan":0,"Gorli":0,"BSC":10932348,"BSCT":0,"Base":0,"Base_Goerli":0,"Matic":19131916,"Mumbai":0,"Arbitrum":0,"Arbitrum_Rinkeby":0,"xDai":0,"Optimism":0,"Optimism_Kovan":0,"Optimism_Goerli":0,"Avalanche":0,"Avalanche_Fuji":0,"Celo":0,"Fantom":0,"Aurora":0,"Aurora_Testnet":0,"Conflux":0,"Astar":0,"Scroll":96705}}');

/***/ }),

/***/ 56971:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"REFERRER_ADDRESS":{"Mainnet":"0x934B510D4C9103E6a87AEf13b816fb080286D649","BSC":"0x934B510D4C9103E6a87AEf13b816fb080286D649","Matic":"0x934B510D4C9103E6a87AEf13b816fb080286D649","Arbitrum":"0x934B510D4C9103E6a87AEf13b816fb080286D649","xDai":"0x934B510D4C9103E6a87AEf13b816fb080286D649","Optimism":"0x934B510D4C9103E6a87AEf13b816fb080286D649","Avalanche":"0x934B510D4C9103E6a87AEf13b816fb080286D649","Avalanche_Fuji":"0x934B510D4C9103E6a87AEf13b816fb080286D649","Celo":"0x934B510D4C9103E6a87AEf13b816fb080286D649","Fantom":"0x934B510D4C9103E6a87AEf13b816fb080286D649"}}');

/***/ }),

/***/ 78343:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"NFTS_BLOCK_ADDRESS":{"Mainnet":"0x8ed6DC7228Ec0A6aEFb4F4d55fB7f8b3A4F5D384"}}');

/***/ }),

/***/ 19684:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"HAPPY_RED_PACKET_ADDRESS_V1":{"Mainnet":"0x26760783c12181efa3c435aee4ae686c53bdddbb","Ropsten":"0x6d84e4863c0530bc0bb4291ef0ff454a40660ca3","Rinkeby":"0x575f906db24154977c7361c2319e2b25e897e3b6"},"HAPPY_RED_PACKET_ADDRESS_V2":{"Mainnet":"0x8D8912E1237F9FF3EF661F32743CFB276E052F98","Ropsten":"0x2E37676de88aD97f2BdBAa24d1421b4E3f3a63c8","Rinkeby":"0x575f906db24154977c7361c2319e2b25e897e3b6"},"HAPPY_RED_PACKET_ADDRESS_V3":{"Mainnet":"","BSC":"0x71834a3FDeA3E70F14a93ED85c6be70925D0CAd9","Matic":"0x913975af2bb8a6be4100d7dc5e9765b77f6a5d6c","Mumbai":"0x0061E06c9f640a03C4981f43762d2AE5e03873c5","Arbitrum":"0x02Ea0720254F7fa4eca7d09A1b9C783F1020EbEF","Arbitrum_Rinkeby":"0x6B70EC653c4331bdD0D0DCC7C941eb594e69a91d"},"HAPPY_RED_PACKET_ADDRESS_V4":{"Mainnet":"0xaBBe1101FD8fa5847c452A6D70C8655532B03C33","BSC":"0x0ca42C178e14c618c81B8438043F27d9D38145f6","Base":"0x8D03d9b43e98Cc2f790Be4E96503fD0CcFd04a2D","Base_Goerli":"0x16f61cb37169523635B6761f3C946892fb3c18fB","Matic":"0x93e0b87A0aD0C991dc1B5176ddCD850c9a78aabb","Arbitrum":"0x83D6b366f21e413f214EB077D5378478e71a5eD2","Arbitrum_Rinkeby":"0x4A77E797031257db72F7D2C3Ec08a4FAc5c8CfE9","xDai":"0x54a0A221C25Fc0a347EC929cFC5db0be17fA2a2B","Optimism":"0x981be454a930479d92C91a0092D204b64845A5D6","Optimism_Kovan":"0x68EDbfA3E564C987FaaAB54f4FD1E7567D4151Dd","Avalanche":"0xF9F7C1496c21bC0180f4B64daBE0754ebFc8A8c0","Avalanche_Fuji":"0x3f64DFB6009d138DfD7b62916f3322A438d8b00D","Celo":"0xAb7B1bE4233A04e5C43a810E75657ECED8E5463B","Fantom":"0x578a7Fee5f0D8CEc7d00578Bf37374C5b95C4b98","Aurora":"0x19f179D7e0D7d9F9d5386afFF64271D98A91615B","Aurora_Testnet":"0xdB93cCd481012bB5D1E2c8d0aF7C5f2940c00fdC","Conflux":"0x96c7d011cdfd467f551605f0f5fce279f86f4186","Astar":"0x2cF46Db820e279c5fBF778367D49d9C931D54524","Scroll":"0x16f61cb37169523635B6761f3C946892fb3c18fB"},"HAPPY_RED_PACKET_ADDRESS_V4_BLOCK_HEIGHT":{"Mainnet":12939427,"Ropsten":0,"Rinkeby":0,"Kovan":0,"Gorli":0,"BSC":9657240,"BSCT":0,"Base":0,"Base_Goerli":0,"Matic":17494774,"Mumbai":0,"Arbitrum":909051,"Arbitrum_Rinkeby":0,"xDai":18101937,"Optimism":1266143,"Optimism_Kovan":442843,"Optimism_Goerli":0,"Avalanche":8306507,"Avalanche_Fuji":4751550,"Celo":10413552,"Fantom":25112473,"Aurora":57552338,"Aurora_Testnet":77918765,"Conflux":37670572,"Astar":910985,"Scroll":96705}}');

/***/ }),

/***/ 91687:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"RPC_URLS":{"Mainnet":["https://mainnet.infura.io/v3/d74bd8586b9e44449cef131d39ceeefb","https://mainnet.infura.io/v3/d65858b010d249419cf8687eca12b094","https://mainnet.infura.io/v3/a9d66980bf334e59a42ca19095f3daeb","https://mainnet.infura.io/v3/f39cc8734e294fba9c3938486df2b1bc","https://mainnet.infura.io/v3/659123dd11294baf8a294d7a11cec92c"],"Ropsten":["https://ropsten.infura.io/v3/d74bd8586b9e44449cef131d39ceeefb","https://ropsten.infura.io/v3/d65858b010d249419cf8687eca12b094","https://ropsten.infura.io/v3/a9d66980bf334e59a42ca19095f3daeb","https://ropsten.infura.io/v3/f39cc8734e294fba9c3938486df2b1bc","https://ropsten.infura.io/v3/659123dd11294baf8a294d7a11cec92c"],"Rinkeby":["https://rinkeby.infura.io/v3/d74bd8586b9e44449cef131d39ceeefb","https://rinkeby.infura.io/v3/d65858b010d249419cf8687eca12b094","https://rinkeby.infura.io/v3/a9d66980bf334e59a42ca19095f3daeb","https://rinkeby.infura.io/v3/f39cc8734e294fba9c3938486df2b1bc","https://rinkeby.infura.io/v3/659123dd11294baf8a294d7a11cec92c"],"Kovan":["https://kovan.infura.io/v3/d74bd8586b9e44449cef131d39ceeefb","https://kovan.infura.io/v3/d65858b010d249419cf8687eca12b094","https://kovan.infura.io/v3/a9d66980bf334e59a42ca19095f3daeb","https://kovan.infura.io/v3/f39cc8734e294fba9c3938486df2b1bc","https://kovan.infura.io/v3/659123dd11294baf8a294d7a11cec92c"],"Gorli":["https://goerli.infura.io/v3/d74bd8586b9e44449cef131d39ceeefb","https://goerli.infura.io/v3/d65858b010d249419cf8687eca12b094","https://goerli.infura.io/v3/a9d66980bf334e59a42ca19095f3daeb","https://goerli.infura.io/v3/f39cc8734e294fba9c3938486df2b1bc","https://goerli.infura.io/v3/659123dd11294baf8a294d7a11cec92c"],"BSC":["https://bsc-dataseed.binance.org/"],"BSCT":["https://data-seed-prebsc-1-s1.binance.org:8545/"],"Base":["https://mainnet.base.org"],"Base_Goerli":["https://goerli.base.org"],"Matic":["https://polygon-mainnet.infura.io/v3/d74bd8586b9e44449cef131d39ceeefb","https://polygon-mainnet.infura.io/v3/d65858b010d249419cf8687eca12b094","https://polygon-mainnet.infura.io/v3/a9d66980bf334e59a42ca19095f3daeb","https://polygon-mainnet.infura.io/v3/f39cc8734e294fba9c3938486df2b1bc","https://polygon-mainnet.infura.io/v3/659123dd11294baf8a294d7a11cec92c"],"Mumbai":["https://polygon-mumbai.infura.io/v3/d74bd8586b9e44449cef131d39ceeefb","https://polygon-mumbai.infura.io/v3/d65858b010d249419cf8687eca12b094","https://polygon-mumbai.infura.io/v3/a9d66980bf334e59a42ca19095f3daeb","https://polygon-mumbai.infura.io/v3/f39cc8734e294fba9c3938486df2b1bc","https://polygon-mumbai.infura.io/v3/659123dd11294baf8a294d7a11cec92c"],"Arbitrum":["https://arb1.arbitrum.io/rpc"],"Arbitrum_Rinkeby":["https://rinkeby.arbitrum.io/rpc"],"xDai":["https://rpc.gnosischain.com"],"Optimism":["https://node.onekey.so/optimism","https://opt-mainnet.g.alchemy.com/v2/y1SaoYHvGr3u34ETP9fIbuTU0aBGnJ70"],"Optimism_Kovan":["https://kovan.optimism.io"],"Optimism_Goerli":["https://goerli.optimism.io"],"Avalanche":["https://api.avax.network/ext/bc/C/rpc"],"Avalanche_Fuji":["https://api.avax-test.network/ext/bc/C/rpc"],"Celo":["https://forno.celo.org"],"Fantom":["https://rpc.ftm.tools"],"Aurora":["https://mainnet.aurora.dev"],"Aurora_Testnet":["https://testnet.aurora.dev"],"Conflux":["https://evm.confluxrpc.com"],"Astar":["https://astar.api.onfinality.io/public"],"Scroll":["https://rpc.scroll.io"]},"RPC_URLS_OFFICIAL":{"Mainnet":["https://mainnet.infura.io/v3/d65858b010d249419cf8687eca12b094"],"Ropsten":["https://ropsten.infura.io/v3/d65858b010d249419cf8687eca12b094"],"Rinkeby":["https://rinkeby.infura.io/v3/d65858b010d249419cf8687eca12b094"],"Kovan":["https://kovan.infura.io/v3/d65858b010d249419cf8687eca12b094"],"Gorli":["https://goerli.infura.io/v3/d65858b010d249419cf8687eca12b094"],"BSC":["https://bsc-dataseed1.binance.org"],"BSCT":["https://data-seed-prebsc-1-s1.binance.org:8545"],"Base":["https://mainnet.base.org"],"Base_Goerli":["https://goerli.base.org"],"Matic":["https://polygon-rpc.com/"],"Mumbai":["https://matic-mumbai.chainstacklabs.com"],"Arbitrum":["https://arb1.arbitrum.io/rpc"],"Arbitrum_Rinkeby":["https://rinkeby.arbitrum.io/rpc"],"xDai":["https://rpc.gnosischain.com"],"Optimism":["https://mainnet.optimism.io/"],"Optimism_Kovan":["https://kovan.optimism.io/"],"Optimism_Goerli":["https://goerli.optimism.io/"],"Avalanche":["https://api.avax.network/ext/bc/C/rpc"],"Avalanche_Fuji":["https://api.avax-test.network/ext/bc/C/rpc"],"Celo":["https://forno.celo.org"],"Fantom":["https://rpc.ftm.tools"],"Aurora":["https://mainnet.aurora.dev"],"Aurora_Testnet":["https://testnet.aurora.dev/"],"Conflux":["https://evm.confluxrpc.com"],"Astar":["https://rpc.astar.network:8545"],"Scroll":["https://rpc.scroll.io"]},"RPC_WEIGHTS":{"Mainnet":[0,1,2,3,4],"Ropsten":[0,1,2,3,4],"Rinkeby":[0,1,2,3,4],"Kovan":[0,1,2,3,4],"Gorli":[0,1,2,3,4],"BSC":[0,0,0,0,0],"BSCT":[0,0,0,0,0],"Base":[0,0,0,0,0],"Base_Goerli":[0,0,0,0,0],"Matic":[0,1,2,3,4],"Mumbai":[0,1,2,3,4],"Arbitrum":[0,0,0,0,0],"Arbitrum_Rinkeby":[0,0,0,0,0],"xDai":[0,0,0,0,0],"Optimism":[0,1,2,2,2],"Optimism_Kovan":[0,0,0,0,0],"Optimism_Goerli":[0,0,0,0,0],"Avalanche":[0,0,0,0,0],"Avalanche_Fuji":[0,0,0,0,0],"Celo":[0,0,0,0,0],"Fantom":[0,0,0,0,0],"Aurora":[0,0,0,0,0],"Aurora_Testnet":[0,0,0,0,0],"Conflux":[0,0,0,0,0],"Astar":[0,0,0,0,0],"Scroll":[0,0,0,0,0]}}');

/***/ }),

/***/ 62455:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"LOGIC_WALLET_CONTRACT_ADDRESS":{"Mainnet":"","Matic":"0xA835E7EbE39107907d7F58D459945979f86a34AD","Mumbai":"0x0912FD4D5bA43C5583B1796bb17586080cb117D3"},"EP_CONTRACT_ADDRESS":{"Mainnet":"","Matic":"0x43B87595F319B17F3386Ac244A00944B3f5A532A","Mumbai":"0x8A42F70047a99298822dD1dbA34b454fc49913F2"},"CREATE2_FACTORY_CONTRACT_ADDRESS":{"Mainnet":"","Matic":"0xce0042B868300000d44A59004Da54A005ffdcf9f","Mumbai":"0xce0042B868300000d44A59004Da54A005ffdcf9f"},"PAYMASTER_NATIVE_CONTRACT_ADDRESS":{"Mainnet":"","Matic":"0x0B81e2d66F6c52AaAEa836240f63e1b43643B5f9","Mumbai":"0x8C2306B8C31c7eC78078e1C5C53dE6fee1627BF7"},"PAYMASTER_MASK_CONTRACT_ADDRESS":{"Mainnet":"","Matic":"0x46a47fEf332FBB124D8197afFED5994D89B6BF71","Mumbai":"0x808c7f48a64404e4e97d9b62b21f13F984fF1a96"},"PAYMASTER_MINIMAL_STAKE_AMOUNT":{"Mainnet":"","Matic":"5000000000000000000","Mumbai":"5000000000000000000"},"PAYMASTER_UNSTAKE_DELAY":{"Mainnet":0,"Ropsten":0,"Rinkeby":0,"Kovan":0,"Gorli":0,"BSC":0,"BSCT":0,"Base":0,"Base_Goerli":0,"Matic":60,"Mumbai":60,"Arbitrum":0,"Arbitrum_Rinkeby":0,"xDai":0,"Optimism":0,"Optimism_Kovan":0,"Optimism_Goerli":0,"Avalanche":0,"Avalanche_Fuji":0,"Celo":0,"Fantom":0,"Aurora":0,"Aurora_Testnet":0,"Conflux":0,"Astar":0},"PAYMENT_TOKEN_ADDRESS":{"Mainnet":"","Matic":"0x2B9E7ccDF0F4e5B24757c1E1a80e311E34Cb10c7","Mumbai":"0xF8935Df67cAB7BfcA9532D1Ac2088C5c39b995b5"}}');

/***/ }),

/***/ 97874:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"SID_CONTRACT_ADDRESS":{"Mainnet":"","BSC":"0xE3b1D32e43Ce8d658368e2CBFF95D57Ef39Be8a6"}}');

/***/ }),

/***/ 50828:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"NATIVE_TOKEN_ASSET_BASE_URI":{"Mainnet":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/ethereum"],"Ropsten":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/ethereum"],"Rinkeby":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/ethereum"],"Kovan":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/ethereum"],"Gorli":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/ethereum"],"BSC":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/smartchain"],"BSCT":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/smartchain"],"Base":[],"Base_Goerli":[],"Matic":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/polygon"],"Mumbai":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/polygon"],"Arbitrum":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/arbitrum"],"Arbitrum_Rinkeby":[],"xDai":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/xdai"],"Optimism":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/optimism"],"Optimism_Kovan":[],"Optimism_Goerli":[],"Avalanche":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/avalanchec"],"Avalanche_Fuji":[],"Celo":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/celo"],"Fantom":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/fantom"],"Aurora":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/aurora"],"Aurora_Testnet":[],"Conflux":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/conflux"],"Astar":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/astar"],"Scroll":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/scroll"]},"ERC20_TOKEN_ASSET_BASE_URI":{"Mainnet":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/ethereum/assets"],"Ropsten":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/ropsten/assets"],"Rinkeby":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/rinkeby/assets"],"Kovan":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/kovan/assets"],"Gorli":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/gorli/assets"],"BSC":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/bnb/assets"],"BSCT":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/chapel/assets"],"Base":[],"Base_Goerli":[],"Matic":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/polygon/assets"],"Mumbai":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/mumbai/assets"],"Arbitrum":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/arbitrum/assets"],"Arbitrum_Rinkeby":[],"xDai":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/xdai/assets"],"Optimism":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/optimism/assets"],"Optimism_Kovan":[],"Optimism_Goerli":[],"Avalanche":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/avalanchec/assets"],"Avalanche_Fuji":[],"Celo":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/celo/assets"],"Fantom":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/fantom/assets"],"Aurora":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/aurora/assets"],"Aurora_Testnet":[],"Conflux":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/conflux/assets"],"Astar":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/astar/assets"],"Scroll":["https://imagedelivery.net/PCnTHRkdRhGodr0AWBAvMA/Assets/blockchains/scroll/assets"]}}');

/***/ }),

/***/ 52598:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"FUNGIBLE_TOKEN_LISTS":{"Mainnet":["https://tokens.r2d2.to/latest/1/tokens.json"],"Ropsten":["https://tokens.r2d2.to/latest/3/tokens.json"],"Rinkeby":["https://tokens.r2d2.to/latest/4/tokens.json"],"Kovan":["https://irhonin.github.io/kovan-token-list/kovan-token-list.json"],"Gorli":["https://tokens.r2d2.to/latest/5/tokens.json"],"BSC":["https://tokens.r2d2.to/latest/56/tokens.json"],"BSCT":["https://tokens.r2d2.to/latest/97/tokens.json"],"Base":["https://tokens.r2d2.to/latest/8453/tokens.json"],"Base_Goerli":["https://tokens.r2d2.to/latest/84531/tokens.json"],"Matic":["https://tokens.r2d2.to/latest/137/tokens.json"],"Mumbai":["https://tokens.r2d2.to/latest/80001/tokens.json"],"Arbitrum":["https://tokens.r2d2.to/latest/42161/tokens.json"],"Arbitrum_Rinkeby":["https://tokens.r2d2.to/latest/421611/tokens.json"],"xDai":["https://tokens.r2d2.to/latest/100/tokens.json"],"Optimism":["https://tokens.r2d2.to/latest/10/tokens.json"],"Optimism_Kovan":[],"Optimism_Goerli":[],"Avalanche":["https://tokens.r2d2.to/latest/43114/tokens.json"],"Avalanche_Fuji":[],"Celo":["https://tokens.r2d2.to/latest/42220/tokens.json"],"Fantom":["https://tokens.r2d2.to/latest/250/tokens.json"],"Aurora":["https://tokens.r2d2.to/latest/1313161554/tokens.json"],"Aurora_Testnet":[],"Conflux":["https://tokens.r2d2.to/latest/1030/tokens.json"],"Astar":["https://tokens.r2d2.to/latest/592/tokens.json"],"Scroll":["https://tokens.r2d2.to/latest/534352/tokens.json"]}}');

/***/ }),

/***/ 42482:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"APE_ADDRESS":{"Mainnet":"0x4d224452801aced8b2f0aebe155379bb5d594381"},"WNATIVE_ADDRESS":{"Mainnet":"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2","Ropsten":"0xc778417E063141139Fce010982780140Aa0cD5Ab","Rinkeby":"0xc778417E063141139Fce010982780140Aa0cD5Ab","Kovan":"0xd0A1E359811322d97991E03f863a0C30C2cF029C","Gorli":"0xb4fbf271143f4fbf7b91a5ded31805e42b2208d6","BSC":"0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c","BSCT":"0xaE8E19eFB41e7b96815649A6a60785e1fbA84C1e","Matic":"0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270","Mumbai":"0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889","Arbitrum":"0x82aF49447D8a07e3bd95BD0d56f35241523fBab1","Arbitrum_Rinkeby":"0xB47e6A5f8b33b3F17603C83a0535A9dcD7E32681","xDai":"0xe91D153E0b41518A2Ce8Dd3D7944Fa863463a97d","Optimism":"0x4200000000000000000000000000000000000006","Optimism_Kovan":"0x4200000000000000000000000000000000000006","Optimism_Goerli":"0x4200000000000000000000000000000000000006","Avalanche":"0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7","Celo":"0x471EcE3750Da237f93B8E339c536989b8978a438","Fantom":"0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83","Aurora":"0xC9BdeEd33CD01541e1eeD10f90519d2C06Fe3feB","Astar":"0xaeaaf0e2c81af264101b9129c00f4440ccf0f720","Scroll":"0x5300000000000000000000000000000000000004"},"LDO_stETH_ADDRESS":{"Mainnet":"0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84","Gorli":"0x1643E812aE58766192Cf7D2Cf9567dF2C37e9B7F"},"ELK_ADDRESS":{"Mainnet":"0xeEeEEb57642040bE42185f49C52F7E9B38f8eeeE","BSC":"0xeEeEEb57642040bE42185f49C52F7E9B38f8eeeE","Matic":"0xeEeEEb57642040bE42185f49C52F7E9B38f8eeeE","xDai":"0xeEeEEb57642040bE42185f49C52F7E9B38f8eeeE","Optimism":"0xeeeeeb57642040be42185f49c52f7e9b38f8eeee","Avalanche":"0xeeeeeb57642040be42185f49c52f7e9b38f8eeee","Fantom":"0xeEeEEb57642040bE42185f49C52F7E9B38f8eeeE"},"USDC_ADDRESS":{"Mainnet":"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48","Ropsten":"0x0D9C8723B343A8368BebE0B5E89273fF8D712e3C","Rinkeby":"0x4DBCdF9B62e891a7cec5A2568C3F4FAF9E8Abe2b","Kovan":"0x2F375e94FC336Cdec2Dc0cCB5277FE59CBf1cAe5","BSC":"0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d","Matic":"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174","Arbitrum":"0xe865dF68133fcEd7c2285ff3896B406CAfAa2dB8","xDai":"0xDDAfbb505ad214D7b80b1f830fcCc89B60fb7A83","Optimism":"0x7F5c764cBc14f9669B88837ca1490cCa17c31607","Avalanche":"0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664","Celo":"0x2A3684e9Dc20B857375EA04235F2F7edBe818FA7","Fantom":"0x04068da6c83afcfa0e13ba15a6696662335d5b75","Aurora":"0xb12bfca5a55806aaf64e99521918a4bf0fc40802","Astar":"0x6a2d262D56735DbA19Dd70682B39F6bE9a931D98","Scroll":"0x06eFdBFf2a14a7c8E15944D1F4A48F9F95F663A4"},"USDT_ADDRESS":{"Mainnet":"0xdAC17F958D2ee523a2206206994597C13D831ec7","Ropsten":"0x516de3a7A567d81737e3a46ec4FF9cFD1fcb0136","Rinkeby":"0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02","BSC":"0x55d398326f99059fF775485246999027B3197955","Matic":"0xc2132D05D31c914a87C6611C10748AEb04B58e8F","Arbitrum":"0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9","xDai":"0x4ECaBa5870353805a9F068101A40E0f32ed605C6","Optimism":"0x94b008aA00579c1307B0EF2c499aD98a8ce58e58","Avalanche":"0xc7198437980c041c805A1EDcbA50c1Ce5db95118","Celo":"0xb020d981420744f6b0fedd22bb67cd37ce18a1d5","Aurora":"0x4988a896b1227218e4a686fde5eabdcabd91571f","Astar":"0x3795C36e7D12A8c252A20C5a7B455f7c57b60283","Scroll":"0xf55BEC9cafDbE8730f096Aa55dad6D22d44099Df"},"aUSDT_ADDRESS":{"Mainnet":"0x71fc860F7D3A592A4a98740e39dB31d25db65ae8","Gorli":"0x1643E812aE58766192Cf7D2Cf9567dF2C37e9B7F"},"HUSD_ADDRESS":{"Mainnet":"0xdf574c24545e5ffecb9a659c229253d4111d87e1","xDai":"0x1e37E5b504F7773460d6eB0e24D2e7C223B66EC7"},"BUSD_ADDRESS":{"Mainnet":"0x4fabb145d64652a948d72533023f6e7a623c7c53","BSC":"0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56","xDai":"0xdd96B45877d0E8361a4DDb732da741e97f3191Ff","Avalanche":"0x19860ccb0a68fd4213ab9d8266f7bbf05a8dde98","Astar":"0x4Bf769b05E832FCdc9053fFFBC78Ca889aCb5E1E"},"COMP_ADDRESS":{"Mainnet":"0xc00e94Cb662C3520282E6f5717214004A7f26888","Matic":"0x8505b9d2254A7Ae468c0E9dd10Ccea3A837aef5c","Avalanche":"0xc3048e19e76cb9a3aa9d77d8c03c29fc906e2437"},"EASY_ADDRESS":{"Mainnet":"","Matic":"0xDb3b3b147A030F032633f6C4BEBf9a2fB5a882B5"},"MKR_ADDRESS":{"Mainnet":"0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2"},"MASK_ADDRESS":{"Mainnet":"0x69af81e73A73B40adF4f3d4223Cd9b1ECE623074","Ropsten":"0x5B966f3a32Db9C180843bCb40267A66b73E4f022","Rinkeby":"0xFD9Eb54f6aC885079e7bB3E207922Bb7256E3fcb","BSC":"0x2eD9a5C8C13b93955103B9a7C167B67Ef4d568a3","Matic":"0x2B9E7ccDF0F4e5B24757c1E1a80e311E34Cb10c7","Mumbai":"0xF8935Df67cAB7BfcA9532D1Ac2088C5c39b995b5"},"MSKA_ADDRESS":{"Mainnet":"","Ropsten":"0xe54bf69054da160c597f8b5177924b9e4b81e930","Rinkeby":"0x960B816d6dD03eD514c03F56788279154348Ea37"},"MSKB_ADDRESS":{"Mainnet":"","Ropsten":"0xe379c7a6ba07575a5a49d8f8ebfd04921b86917d","Rinkeby":"0xFa4Bddbc85c0aC7a543c4b59dCfb5deB17F67D8E"},"MSKC_ADDRESS":{"Mainnet":"","Ropsten":"0xb1465b954f893d921566d8bb4092b6f03fc8c313","Rinkeby":"0xbE88c0E7029929f50c81690275395Da1d05745B0"},"MSKD_ADDRESS":{"Mainnet":"","Ropsten":"0x49A6D6FE38405e21C4402CcEacd23636AbE301bf","Rinkeby":"0x57b9bD626507421d82C7542e2877D72fE7815aFd"},"MSKE_ADDRESS":{"Mainnet":"","Ropsten":"0xE8f4dDB8c8b655B4e161d3480522d1d576561A4D","Rinkeby":"0xB46e44E06B89798Af11b8fE456b4796dc9026cE0"},"DAI_ADDRESS":{"Mainnet":"0x6B175474E89094C44Da98b954EedeAC495271d0F","Ropsten":"0x31f42841c2db5173425b5223809cf3a38fede360","Rinkeby":"0x5592ec0cfb4dbc12d3ab100b257153436a1f0fea","Kovan":"0x1528F3FCc26d13F7079325Fb78D9442607781c8C","BSC":"0x1AF3F329e8BE154074D8769D1FFa4eE058B1DBc3","Matic":"0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063","Optimism":"0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1","Avalanche":"0xd586E7F844cEa2F87f50152665BCbc2C279D8d70","Fantom":"0x8D11eC38a3EB5E956B052f67Da8Bdc9bef8Abf3E","Aurora":"0xe3520349f477a5f6eb06107066048508498a291b","Astar":"0x6De33698e9e9b787e09d3Bd7771ef63557E148bb"},"AMPL_ADDRESS":{"Mainnet":"0xD46bA6D942050d489DBd938a2C909A5d5039A161"},"OKB_ADDRESS":{"Mainnet":"0x75231F58b43240C9718Dd58B4967c5114342a86c"},"UST_ADDRESS":{"Mainnet":"0xa47c8bf37f92aBed4A126BDA807A7b7498661acD","BSC":"0x23396cF899Ca06c4472205fC903bDB4de249D6fC"},"eUSDC_ADDRESS":{"Mainnet":"","Matic":"0x4eBdE54ba404bE158262EDe801744b92b9878c61"},"eUSDT_ADDRESS":{"Mainnet":"","Matic":"0xfc39742Fe9420a7Af23757Fc7E78D1c3AE4A9474"},"fUSDT_ADDRESS":{"Mainnet":"","Fantom":"0x049d68029688eAbF473097a2fC38ef61633A3C7A"},"eDAI_ADDRESS":{"Mainnet":"","Matic":"0xa1C09C8F4f5D03fcC27b456475d53d988e98D7C5"},"UNITOKEN_ADDRESS":{"Mainnet":"","Matic":"0xb33EaAd8d922B1083446DC23f610c2567fB5180f"},"TT01_ADDRESS":{"Mainnet":"","Matic":"0x1DBb7f76CDC5413eE211ff4100723791B2d98c05"},"TT02_ADDRESS":{"Mainnet":"","Matic":"0xd07B432B565AE10C6Dc0739989Ee3CF36A8dFf29"},"TART_ADDRESS":{"Mainnet":"0x97371b72B1e897103BEFd628e22a2829e86eBc3D"},"QUICK_ADDRESS":{"Mainnet":"","Matic":"0x831753DD7087CaC61aB5644b308642cc1c33Dc13"},"WANNA_ADDRESS":{"Mainnet":"","Aurora":"0x7faA64Faf54750a2E3eE621166635fEAF406Ab22"},"WBTC_ADDRESS":{"Mainnet":"0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599","Matic":"0x1BFD67037B42Cf73acF2047067bd4F2C47D9BfD6","xDai":"0x8e5bBbb09Ed1ebdE8674Cda39A0c169401db4252","Optimism":"0x68f180fcCe6836688e9084f035309E29Bf0A2095","Avalanche":"0x50b7545627a5162F82A992c33b87aDc75187B218","Celo":"0xBe50a3013A1c94768A1ABb78c3cB79AB28fc1aCE","Fantom":"0x321162Cd933E2Be498Cd2267a90534A804051b11","Aurora":"0xf4eb217ba2454613b15dbdea6e5f22276410e89e","Astar":"0xad543f18cFf85c77E140E3E5E3c3392f6Ba9d5CA"},"IGG_ADDRESS":{"Mainnet":"","Matic":"0xe6FC6C7CB6d2c31b359A49A33eF08aB87F4dE7CE"},"OM_ADDRESS":{"Mainnet":"","Matic":"0x9f5755D47fB80100E7ee65Bf7e136FCA85Dd9334"},"SUSHI_ADDRESS":{"Mainnet":"0x6B3595068778DD592e39A122f4f5a5cF09C90fE2"},"YAM_ADDRESS":{"Mainnet":"0x0e2298E3B3390e3b945a5456fBf59eCc3f55DA16"},"RUNE_ADDRESS":{"Mainnet":"0x3155BA85D5F96b2d030a4966AF206230e46849cb"},"YFI_ADDRESS":{"Mainnet":"0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e"},"sUSD_ADDRESS":{"Mainnet":"0x57ab1ec28d129707052df4df418d58a2d46d5f51","Matic":"0xF81b4Bec6Ca8f9fe7bE01CA734F55B2b6e03A7a0"},"BTCB_ADDRESS":{"Mainnet":"","BSC":"0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c"},"CAKE_ADDRESS":{"Mainnet":"","BSC":"0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82"},"maUSDC_ADDRESS":{"Mainnet":"","Matic":"0x9719d867A500Ef117cC201206B8ab51e794d3F82"},"stETH_ADDRESS":{"Mainnet":"0xDFe66B14D37C77F4E9b180cEb433d1b164f0281D"},"NFTX_ADDRESS":{"Mainnet":"0x87d73E916D7057945c9BcD8cdd94e42A6F47f776"},"cUSD_ADDRESS":{"Mainnet":"","Celo":"0x765de816845861e75a25fca122bb6898b8b1282a"},"cEUR_ADDRESS":{"Mainnet":"","Celo":"0x765de816845861e75a25fca122bb6898b8b1282a"},"xTRI_ADDRESS":{"Mainnet":"","Aurora":"0x802119e4e253D5C19aA06A5d567C5a41596D6803"},"JOE_ADDRESS":{"Mainnet":"","Avalanche":"0xce347E069B68C53A9ED5e7DA5952529cAF8ACCd4"},"PNG_ADDRESS":{"Mainnet":"","Avalanche":"0x60781C2586D68229fde47564546784ab3fACA982"},"VIPER_ADDRESS":{"Mainnet":""},"JEWEL_ADDRESS":{"Mainnet":""},"CRYSTAL_ADDRESS":{"Mainnet":""},"OPENX_ADDRESS":{"Mainnet":""},"ETHER_ADDRESS":{"Mainnet":"","BSC":"0x2170Ed0880ac9A755fd29B2688956BD959F933F8","Matic":"0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619","Avalanche":"0x49D5c2BdFfac6CE2BFdB6640F4F80f226bc10bAB"},"NATIVE_TOKEN_ADDRESS":{"Mainnet":"0x0000000000000000000000000000000000000000","Ropsten":"0x0000000000000000000000000000000000000000","Rinkeby":"0x0000000000000000000000000000000000000000","Kovan":"0x0000000000000000000000000000000000000000","Gorli":"0x0000000000000000000000000000000000000000","BSC":"0x0000000000000000000000000000000000000000","BSCT":"0x0000000000000000000000000000000000000000","Base":"0x0000000000000000000000000000000000000000","Base_Goerli":"0x0000000000000000000000000000000000000000","Matic":"0x0000000000000000000000000000000000000000","Mumbai":"0x0000000000000000000000000000000000000000","Arbitrum":"0x0000000000000000000000000000000000000000","Arbitrum_Rinkeby":"0x0000000000000000000000000000000000000000","xDai":"0x0000000000000000000000000000000000000000","Optimism":"0x0000000000000000000000000000000000000000","Optimism_Kovan":"0x0000000000000000000000000000000000000000","Optimism_Goerli":"0x0000000000000000000000000000000000000000","Avalanche":"0x0000000000000000000000000000000000000000","Avalanche_Fuji":"0x0000000000000000000000000000000000000000","Celo":"0x471ece3750da237f93b8e339c536989b8978a438","Fantom":"0x0000000000000000000000000000000000000000","Aurora":"0x0000000000000000000000000000000000000000","Aurora_Testnet":"0x0000000000000000000000000000000000000000","Conflux":"0x0000000000000000000000000000000000000000","Astar":"0x0000000000000000000000000000000000000000","Scroll":"0x0000000000000000000000000000000000000000"},"WETH_ADDRESS":{"Mainnet":"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2","Arbitrum":"0x82aF49447D8a07e3bd95BD0d56f35241523fBab1","Astar":"0x81ECac0D6Be0550A00FF064a4f9dd2400585FE9c"},"aWETH_ADDRESS":{"Mainnet":"0x030bA81f1c18d280636F32af80b9AAd02Cf0854e"},"ZRX_ADDRESS":{"Mainnet":"0xE41d2489571d322189246DaFA5ebDe1F4699F498"},"aZRX_ADDRESS":{"Mainnet":"0xDf7FF54aAcAcbFf42dfe29DD6144A69b629f8C9e"},"UNI_ADDRESS":{"Mainnet":"0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984"},"aUNI_ADDRESS":{"Mainnet":"0xB9D7CB55f463405CDfBe4E90a6D2Df01C2B92BF1"},"LIDO_ADDRESS":{"Mainnet":"0x5A98FcBEA516Cf06857215779Fd812CA3beF1B32","Gorli":"0x56340274fB5a72af1A3C6609061c451De7961Bd4"},"AAVE_ADDRESS":{"Mainnet":"0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9"},"aAAVE_ADDRESS":{"Mainnet":"0xFFC97d72E13E01096502Cb8Eb52dEe56f74DAD7B"},"BAT_ADDRESS":{"Mainnet":"0x0D8775F648430679A709E98d2b0Cb6250d2887EF"},"aBAT_ADDRESS":{"Mainnet":"0x05Ec93c0365baAeAbF7AefFb0972ea7ECdD39CF1"},"ENJ_ADDRESS":{"Mainnet":"0xF629cBd94d3791C9250152BD8dfBDF380E2a3B9c"},"aENJ_ADDRESS":{"Mainnet":"0xaC6Df26a590F08dcC95D5a4705ae8abbc88509Ef"},"KNC_ADDRESS":{"Mainnet":"0xdd974D5C2e2928deA5F71b9825b8b646686BD200"},"aKNC_ADDRESS":{"Mainnet":"0x39C6b3e42d6A679d7D776778Fe880BC9487C2EDA"},"LINK_ADDRESS":{"Mainnet":"0x514910771AF9Ca656af840dff83E8264EcF986CA","Optimism":"0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6"},"aLINK_ADDRESS":{"Mainnet":"0xa06bC25B5805d5F8d82847D191Cb4Af5A3e873E0"},"MANA_ADDRESS":{"Mainnet":"0x0F5D2fB29fb7d3CFeE444a200298f468908cC942"},"aMANA_ADDRESS":{"Mainnet":"0xa685a61171bb30d4072B338c80Cb7b2c865c873E"},"REN_ADDRESS":{"Mainnet":"0x408e41876cCCDC0F92210600ef50372656052a38"},"aREN_ADDRESS":{"Mainnet":"0xCC12AbE4ff81c9378D670De1b57F8e0Dd228D77a"},"SNX_ADDRESS":{"Mainnet":"0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F"},"aSNX_ADDRESS":{"Mainnet":"0x35f6B052C598d933D69A4EEC4D04c73A191fE6c2"},"TUSD_ADDRESS":{"Mainnet":"0x0000000000085d4780B73119b644AE5ecd22b376"},"aTUSD_ADDRESS":{"Mainnet":"0x101cc05f4A51C0319f570d5E146a8C625198e636"},"CRV_ADDRESS":{"Mainnet":"0xD533a949740bb3306d119CC777fa900bA034cd52"},"aCRV_ADDRESS":{"Mainnet":"0x8dAE6Cb04688C62d939ed9B68d32Bc62e49970b1"},"GUSD_ADDRESS":{"Mainnet":"0x056Fd409E1d7A124BD7017459dFEa2F387b6d5Cd"},"aGUSD_ADDRESS":{"Mainnet":"0xD37EE7e4f452C6638c96536e68090De8cBcdb583"},"BAL_ADDRESS":{"Mainnet":"0xba100000625a3754423978a60c9317c58a424e3D"},"aBAL_ADDRESS":{"Mainnet":"0x272F97b7a56a387aE942350bBC7Df5700f8a4576"},"xSUSHI_ADDRESS":{"Mainnet":"0x8798249c2E607446EfB7Ad49eC89dD1865Ff4272"},"aXSUSHI_ADDRESS":{"Mainnet":"0xF256CC7847E919FAc9B808cC216cAc87CCF2f47a"},"renFIL_ADDRESS":{"Mainnet":"0xD5147bc8e386d91Cc5DBE72099DAC6C9b99276F5"},"aRENFIL_ADDRESS":{"Mainnet":"0x514cd6756CCBe28772d4Cb81bC3156BA9d1744aa"},"RAI_ADDRESS":{"Mainnet":"0x03ab458634910AaD20eF5f1C8ee96F1D6ac54919"},"aRAI_ADDRESS":{"Mainnet":"0xc9BC48c72154ef3e5425641a3c747242112a46AF"},"USDP_ADDRESS":{"Mainnet":"0x8E870D67F660D95d5be530380D0eC0bd388289E1"},"aUSDP_ADDRESS":{"Mainnet":"0x2e8F4bdbE3d47d7d7DE490437AeA9915D930F1A3"},"DPI_ADDRESS":{"Mainnet":"0x1494CA1F11D487c2bBe4543E90080AeBa4BA3C2b"},"aDPI_ADDRESS":{"Mainnet":"0x6F634c6135D2EBD550000ac92F494F9CB8183dAe"},"FRAX_ADDRESS":{"Mainnet":"0x853d955aCEf822Db058eb8505911ED77F175b99e"},"aFRAX_ADDRESS":{"Mainnet":"0xd4937682df3C8aEF4FE912A96A74121C0829E664"},"FEI_ADDRESS":{"Mainnet":"0x956F47F50A910163D8BF957Cf5846D573E7f87CA"},"aFEI_ADDRESS":{"Mainnet":"0x683923dB55Fead99A79Fa01A27EeC3cB19679cC3"},"aWBTC_ADDRESS":{"Mainnet":"0x9ff58f4fFB29fA2266Ab25e75e2A8b3503311656"},"aYFI_ADDRESS":{"Mainnet":"0x5165d24277cD063F5ac44Efd447B27025e888f37"},"aBUSD_ADDRESS":{"Mainnet":"0xA361718326c15715591c299427c62086F69923D9"},"aDAI_ADDRESS":{"Mainnet":"0x028171bCA77440897B824Ca71D1c56caC55b68A3"},"aMKR_ADDRESS":{"Mainnet":"0xc713e5E149D5D0715DcD1c156a020976e7E56B88"},"aSUSD_ADDRESS":{"Mainnet":"0x6C5024Cd4F8A59110119C56f8933403A539555EB"},"aUSDC_ADDRESS":{"Mainnet":"0xBcca60bB61934080951369a648Fb03DF4F96263C"},"aAMPL_ADDRESS":{"Mainnet":"0x1E6bb68Acec8fefBD87D192bE09bb274170a0548","Conflux":"0x0000000000000000000000000000000000000000"},"SDN_ADDRESS":{"Mainnet":""},"VERSA_ADDRESS":{"Mainnet":"","Astar":"0xB9dEDB74bd7b298aBf76b9dFbE5b62F0aB05a57b"},"YUMI_ADDRESS":{"Mainnet":"","Astar":"0x665F8B21878bDECa8bD94507120730a40dCd4F61"},"xYUMI_ADDRESS":{"Mainnet":"","Astar":"0xCc7a1Bd54375fa5bc408aC319569eCc81c8d4208"},"ZIP_ADDRESS":{"Mainnet":"","Optimism":"0xFA436399d0458Dbe8aB890c3441256E3E09022a8"},"OP_ADDRESS":{"Mainnet":"","Optimism":"0x4200000000000000000000000000000000000042"},"RARI_ADDRESS":{"Mainnet":"0xFca59Cd816aB1eaD66534D82bc21E7515cE441CF"}}');

/***/ }),

/***/ 25189:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"UNISWAP_V2_ROUTER_ADDRESS":{"Mainnet":"0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D","Ropsten":"0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D","Rinkeby":"0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D","Kovan":"0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D","Gorli":"0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D","Avalanche":"0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D","Avalanche_Fuji":"0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D"},"UNISWAP_V2_FACTORY_ADDRESS":{"Mainnet":"0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f","Ropsten":"0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f","Rinkeby":"0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f","Kovan":"0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f","Gorli":"0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f","Avalanche":"0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f","Avalanche_Fuji":"0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f"},"UNISWAP_V2_THEGRAPH":{"Mainnet":"https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v2"},"UNISWAP_V2_INIT_CODE_HASH":{"Mainnet":"0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f","Ropsten":"0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f","Rinkeby":"0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f","Kovan":"0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f","Gorli":"0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f","Avalanche":"0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f","Avalanche_Fuji":"0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f"},"UNISWAP_SWAP_ROUTER_ADDRESS":{"Mainnet":"0xe592427a0aece92de3edee1f18e0157c05861564","Ropsten":"0xe592427a0aece92de3edee1f18e0157c05861564","Rinkeby":"0xe592427a0aece92de3edee1f18e0157c05861564","Kovan":"0xe592427a0aece92de3edee1f18e0157c05861564","Gorli":"0xe592427a0aece92de3edee1f18e0157c05861564","Matic":"0xe592427a0aece92de3edee1f18e0157c05861564","Mumbai":"0xe592427a0aece92de3edee1f18e0157c05861564","Arbitrum":"0xE592427A0AEce92De3Edee1F18E0157C05861564","Arbitrum_Rinkeby":"0xE592427A0AEce92De3Edee1F18E0157C05861564","Optimism":"0xE592427A0AEce92De3Edee1F18E0157C05861564","Optimism_Kovan":"0xE592427A0AEce92De3Edee1F18E0157C05861564","Optimism_Goerli":"0xE592427A0AEce92De3Edee1F18E0157C05861564","Celo":"0xE592427A0AEce92De3Edee1F18E0157C05861564"},"UNISWAP_V3_FACTORY_ADDRESS":{"Mainnet":"0x1F98431c8aD98523631AE4a59f267346ea31F984","Ropsten":"0x1F98431c8aD98523631AE4a59f267346ea31F984","Rinkeby":"0x1F98431c8aD98523631AE4a59f267346ea31F984","Kovan":"0x1F98431c8aD98523631AE4a59f267346ea31F984","Gorli":"0x1F98431c8aD98523631AE4a59f267346ea31F984","Matic":"0x1F98431c8aD98523631AE4a59f267346ea31F984","Mumbai":"0x1F98431c8aD98523631AE4a59f267346ea31F984","Arbitrum":"0x1F98431c8aD98523631AE4a59f267346ea31F984","Arbitrum_Rinkeby":"0x1F98431c8aD98523631AE4a59f267346ea31F984","Optimism":"0x1F98431c8aD98523631AE4a59f267346ea31F984","Optimism_Kovan":"0x1F98431c8aD98523631AE4a59f267346ea31F984","Optimism_Goerli":"0x1F98431c8aD98523631AE4a59f267346ea31F984","Celo":"0x1F98431c8aD98523631AE4a59f267346ea31F984"},"UNISWAP_V3_QUOTER_ADDRESS":{"Mainnet":"0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6","Ropsten":"0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6","Rinkeby":"0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6","Kovan":"0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6","Gorli":"0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6","Matic":"0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6","Mumbai":"0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6","Arbitrum":"0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6","Arbitrum_Rinkeby":"0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6","Optimism":"0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6","Optimism_Kovan":"0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6","Optimism_Goerli":"0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6","Celo":"0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6"},"UNISWAP_V3_THEGRAPH":{"Mainnet":"https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v3","Ropsten":"https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v3","Rinkeby":"https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v3","Kovan":"https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v3","Gorli":"https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v3","Matic":"https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v3","Mumbai":"https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v3","Arbitrum":"https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v3","Arbitrum_Rinkeby":"https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v3","Optimism":"https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v3","Optimism_Kovan":"https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v3","Optimism_Goerli":"https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v3","Celo":"https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v3"},"UNISWAP_V3_INIT_CODE_HASH":{"Mainnet":"0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54","Ropsten":"0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54","Rinkeby":"0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54","Kovan":"0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54","Gorli":"0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54","Matic":"0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54","Mumbai":"0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54","Arbitrum":"0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54","Arbitrum_Rinkeby":"0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54","Optimism":"0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54","Optimism_Kovan":"0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54","Optimism_Goerli":"0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54","Celo":"0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54"},"SUSHISWAP_ROUTER_ADDRESS":{"Mainnet":"0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F","Ropsten":"0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F","Rinkeby":"0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F","Kovan":"0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F","Gorli":"0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F","BSC":"0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506","BSCT":"0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506","Matic":"0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506","Mumbai":"0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506","Arbitrum":"0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506","Arbitrum_Rinkeby":"0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506","xDai":"0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506","Optimism":"0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506","Avalanche":"0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506","Avalanche_Fuji":"0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506","Celo":"0x1421bDe4B10e8dd459b3BCb598810B1337D56842","Fantom":"0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506","Aurora":"0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506"},"SUSHISWAP_FACTORY_ADDRESS":{"Mainnet":"0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac","Ropsten":"0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac","Rinkeby":"0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac","Kovan":"0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac","Gorli":"0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac","BSC":"0xc35DADB65012eC5796536bD9864eD8773aBc74C4","BSCT":"0xc35DADB65012eC5796536bD9864eD8773aBc74C4","Matic":"0xc35DADB65012eC5796536bD9864eD8773aBc74C4","Mumbai":"0xc35DADB65012eC5796536bD9864eD8773aBc74C4","Arbitrum":"0xc35DADB65012eC5796536bD9864eD8773aBc74C4","Arbitrum_Rinkeby":"0xc35DADB65012eC5796536bD9864eD8773aBc74C4","xDai":"0xc35DADB65012eC5796536bD9864eD8773aBc74C4","Optimism":"0xc35DADB65012eC5796536bD9864eD8773aBc74C4","Optimism_Kovan":"0xc35DADB65012eC5796536bD9864eD8773aBc74C4","Optimism_Goerli":"0xc35DADB65012eC5796536bD9864eD8773aBc74C4","Avalanche":"0xc35DADB65012eC5796536bD9864eD8773aBc74C4","Avalanche_Fuji":"0xc35DADB65012eC5796536bD9864eD8773aBc74C4","Celo":"0xc35DADB65012eC5796536bD9864eD8773aBc74C4","Fantom":"0xc35DADB65012eC5796536bD9864eD8773aBc74C4"},"SUSHISWAP_THEGRAPH":{"Mainnet":"https://api.thegraph.com/subgraphs/name/zippoxer/sushiswap-subgraph-fork"},"SUSHISWAP_INIT_CODE_HASH":{"Mainnet":"0xe18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303","Ropsten":"0xe18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303","Rinkeby":"0xe18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303","Kovan":"0xe18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303","Gorli":"0xe18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303","BSC":"0xe18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303","BSCT":"0xe18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303","Matic":"0xe18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303","Mumbai":"0xe18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303","Arbitrum":"0xe18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303","Arbitrum_Rinkeby":"0xe18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303","xDai":"0xe18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303","Optimism":"0xe18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303","Avalanche":"0xe18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303","Avalanche_Fuji":"0xe18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303","Celo":"0xe18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303","Fantom":"0xe18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303"},"QUICKSWAP_ROUTER_ADDRESS":{"Mainnet":"","Matic":"0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff"},"QUICKSWAP_FACTORY_ADDRESS":{"Mainnet":"","Matic":"0x5757371414417b8C6CAad45bAeF941aBc7d3Ab32"},"QUICKSWAP_THEGRAPH":{"Mainnet":"","Matic":"https://api.thegraph.com/subgraphs/name/sameepsi/quickswap"},"QUICKSWAP_INIT_CODE_HASH":{"Mainnet":"","Matic":"0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f"},"PANCAKESWAP_ROUTER_ADDRESS":{"Mainnet":"","BSC":"0x10ED43C718714eb63d5aA57B78B54704E256024E"},"PANCAKESWAP_FACTORY_ADDRESS":{"Mainnet":"","BSC":"0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73"},"PANCAKESWAP_THEGRAPH":{"Mainnet":"","BSC":"https://thegraph.com/explorer/subgraph/pancakeswap/exchange"},"PANCAKESWAP_INIT_CODE_HASH":{"Mainnet":"","BSC":"0x00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5"},"DODO_ETH_ADDRESS":{"Mainnet":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","Rinkeby":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","Kovan":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","BSC":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","Matic":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","Arbitrum":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","Arbitrum_Rinkeby":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","Aurora":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"},"DODO_EXCHANGE_PROXY_ADDRESS":{"Mainnet":"0xCB859eA579b28e02B87A1FDE08d087ab9dbE5149","Rinkeby":"0xcC8d87A7C747eeE4242045C47Ef25e0A81D56ae3","Kovan":"0xa375b128e139ae54EF7F189BC8fEb4624f1c2Afa","BSC":"0xa128Ba44B2738A558A1fdC06d6303d52D3Cef8c1","Matic":"0x6D310348d5c12009854DFCf72e0DF9027e8cb4f4","Arbitrum":"0xA867241cDC8d3b0C07C85cC06F25a0cD3b5474d8","Aurora":"0x335aC99bb3E51BDbF22025f092Ebc1Cf2c5cC619"},"BANCOR_ETH_ADDRESS":{"Mainnet":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","Ropsten":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"},"ZERO_X_ETH_ADDRESS":{"Mainnet":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","BSC":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","Matic":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","Arbitrum":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","xDai":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","Optimism":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","Avalanche":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","Celo":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","Fantom":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","Aurora":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","Conflux":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","Astar":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"},"BANCOR_EXCHANGE_PROXY_ADDRESS":{"Mainnet":"0x2F9EC37d6CcFFf1caB21733BdaDEdE11c823cCB0","Ropsten":"0xA6DB4B0963C37Bc959CbC0a874B5bDDf2250f26F"},"TRADERJOE_ROUTER_ADDRESS":{"Mainnet":"","Rinkeby":"0x7E2528476b14507f003aE9D123334977F5Ad7B14","xDai":"0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506","Avalanche":"0x60aE616a2155Ee3d9A68541Ba4544862310933d4","Avalanche_Fuji":"0x5db0735cf88F85E78ed742215090c465979B5006"},"TRADERJOE_FACTORY_ADDRESS":{"Mainnet":"","Rinkeby":"0x86f83be9770894d8e46301b12E88e14AdC6cdb5F","Avalanche":"0x9Ad6C38BE94206cA50bb0d90783181662f0Cfa10","Avalanche_Fuji":"0x7eeccb3028870540EEc3D88C2259506f2d34fEE0"},"TRADERJOE_THEGRAPH":{"Mainnet":"https://api.thegraph.com/subgraphs/name/traderjoe-xyz/exchange"},"TRADERJOE_INIT_CODE_HASH":{"Mainnet":"","Rinkeby":"0x0bbca9af0511ad1a1da383135cf3a8d2ac620e549ef9f6ae3a4c33c2fed0af91","Avalanche":"0x0bbca9af0511ad1a1da383135cf3a8d2ac620e549ef9f6ae3a4c33c2fed0af91","Avalanche_Fuji":"0x0bbca9af0511ad1a1da383135cf3a8d2ac620e549ef9f6ae3a4c33c2fed0af91"},"OPENOCEAN_ETH_ADDRESS":{"Mainnet":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","BSC":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","Matic":"0x0000000000000000000000000000000000001010","Arbitrum":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","xDai":"0x0000000000000000000000000000000000000000","Optimism":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","Avalanche":"0x0000000000000000000000000000000000000000"},"OPENOCEAN_EXCHANGE_PROXY_ADDRESS":{"Mainnet":"0x6352a56caadC4F1E25CD6c75970Fa768A3304e64","BSC":"0x6352a56caadC4F1E25CD6c75970Fa768A3304e64","Matic":"0x6352a56caadc4f1e25cd6c75970fa768a3304e64","Arbitrum":"0x6352a56caadc4f1e25cd6c75970fa768a3304e64","xDai":"0x6352a56caadC4F1E25CD6c75970Fa768A3304e64","Optimism":"0x6352a56caadC4F1E25CD6c75970Fa768A3304e64","Avalanche":"0x6352a56caadC4F1E25CD6c75970Fa768A3304e64","Avalanche_Fuji":"0x6352a56caadC4F1E25CD6c75970Fa768A3304e64"},"PANGOLIN_ROUTER_ADDRESS":{"Mainnet":"","Rinkeby":"0x7E2528476b14507f003aE9D123334977F5Ad7B14","Avalanche":"0xE54Ca86531e17Ef3616d22Ca28b0D458b6C89106","Avalanche_Fuji":"0xE54Ca86531e17Ef3616d22Ca28b0D458b6C89106"},"PANGOLIN_FACTORY_ADDRESS":{"Mainnet":"","Avalanche":"0xefa94DE7a4656D787667C749f7E1223D71E9FD88","Avalanche_Fuji":"0xE4A575550C2b460d2307b82dCd7aFe84AD1484dd"},"PANGOLIN_THEGRAPH":{"Mainnet":"","Avalanche":"https://api.thegraph.com/subgraphs/name/dasconnor/pangolin-dex\'"},"PANGOLIN_INIT_CODE_HASH":{"Mainnet":"","Avalanche":"0x40231f6b438bce0797c9ada29b718a87ea0a5cea3fe9a771abdd76bd41a3e545","Avalanche_Fuji":"0x40231f6b438bce0797c9ada29b718a87ea0a5cea3fe9a771abdd76bd41a3e545"},"WANNASWAP_ROUTER_V2_ADDRESS":{"Mainnet":"","Aurora":"0xa3a1eF5Ae6561572023363862e238aFA84C72ef5"},"WANNASWAP_ROUTER_ADDRESS":{"Mainnet":"","Aurora":"0x8f1E0Cf0f9f269Bc977C38635E560aa5b0E63323"},"WANNASWAP_FACTORY_ADDRESS":{"Mainnet":"","Aurora":"0x7928D4FeA7b2c90C732c10aFF59cf403f0C38246"},"WANNASWAP_THEGRAPH":{"Mainnet":"","BSC":"https://thegraph.com/explorer/subgraph/pancakeswap/exchange"},"WANNASWAP_INIT_CODE_HASH":{"Mainnet":"","Aurora":"0xa06b8b0642cf6a9298322d0c8ac3c68c291ca24dc66245cf23aa2abc33b57e21"},"TRISOLARIS_ROUTER_ADDRESS":{"Mainnet":"","Matic":"0x60913758635b54e6C9685f92201A5704eEe74748","Aurora":"0x2CB45Edb4517d5947aFdE3BEAbF95A582506858B"},"TRISOLARIS_FACTORY_ADDRESS":{"Mainnet":"","Matic":"0x10475e37cF1D006b56A4E4739Bcb478361564D22","Aurora":"0xc66F594268041dB60507F00703b152492fb176E7"},"TRISOLARIS_THEGRAPH":{"Mainnet":"","BSC":"https://thegraph.com/explorer/subgraph/pancakeswap/exchange"},"TRISOLARIS_INIT_CODE_HASH":{"Mainnet":"","Matic":"0x4a697f690d1f46e0f1a897a8662acae31ced3039b00c052392ed0bc179f9f28c","Aurora":"0x754e1d90e536e4c1df81b7f030f47b4ca80c87120e145c294f098c83a6cb5ace"},"MDEX_ROUTER_ADDRESS":{"Mainnet":"0x74119c3bca85bEA0538A62319a79b4a372590B47","BSC":"0x0384E9ad329396C3A6A401243Ca71633B2bC4333"},"MDEX_FACTORY_ADDRESS":{"Mainnet":"0x7DAe51BD3E3376B8c7c4900E9107f12Be3AF1bA8","BSC":"0x3CD1C46068dAEa5Ebb0d3f55F6915B10648062B8"},"MDEX_THEGRAPH":{"Mainnet":""},"MDEX_INIT_CODE_HASH":{"Mainnet":"0x8ecc069c645df696f2ca5116ab459c5c2889f299e73c1b208aaa3cdd7d110b16","BSC":"0x0d994d996174b05cfc7bed897dc1b20b4c458fc8d64fe98bc78b3c64a6b4d093"},"JUGGLERRED_INIT_CODE_HASH":{"Mainnet":"","Optimism":"0x00df6f7248463b27d2ee7dd0b735fb2b62d9877f528541c958399a1711b5bc4b","Optimism_Kovan":"0x00df6f7248463b27d2ee7dd0b735fb2b62d9877f528541c958399a1711b5bc4b"},"JUGGLERRED_ROUTER_ADDRESS":{"Mainnet":"","Optimism":"0x3A682E671D1C74F82A45C074E531D33Bd1CEb09c","Optimism_Kovan":"0x3A682E671D1C74F82A45C074E531D33Bd1CEb09c"},"JUGGLERRED_FACTORY_ADDRESS":{"Mainnet":"","Optimism":"0x0BEf94f16cE5b7c83B0BDbD9924cF80239BA9837","Optimism_Kovan":"0x0BEf94f16cE5b7c83B0BDbD9924cF80239BA9837"},"JUGGLERRED_THEGRAPH":{"Mainnet":""},"VENOMSWAP_ROUTER_ADDRESS":{"Mainnet":""},"VENOMSWAP_FACTORY_ADDRESS":{"Mainnet":""},"VENOMSWAP_THEGRAPH":{"Mainnet":""},"VENOMSWAP_INIT_CODE_HASH":{"Mainnet":""},"OPENSWAP_ROUTER_ADDRESS":{"Mainnet":""},"OPENSWAP_FACTORY_ADDRESS":{"Mainnet":""},"OPENSWAP_THEGRAPH":{"Mainnet":""},"OPENSWAP_INIT_CODE_HASH":{"Mainnet":""},"DEFIKINGDOMS_ROUTER_ADDRESS":{"Mainnet":""},"DEFIKINGDOMS_FACTORY_ADDRESS":{"Mainnet":""},"DEFIKINGDOMS_THEGRAPH":{"Mainnet":""},"DEFIKINGDOMS_INIT_CODE_HASH":{"Mainnet":""},"ARTHSWAP_ROUTER_ADDRESS":{"Mainnet":"","Astar":"0xE915D2393a08a00c5A463053edD31bAe2199b9e7"},"ARTHSWAP_FACTORY_ADDRESS":{"Mainnet":"","Astar":"0xA9473608514457b4bF083f9045fA63ae5810A03E"},"ARTHSWAP_THEGRAPH":{"Mainnet":""},"ARTHSWAP_INIT_CODE_HASH":{"Mainnet":"","Astar":"0x613b36de6401276e4d938ad0db4063490e66bb3ab2e4aec17cab78a15ea7a0b6"},"VERSA_ROUTER_ADDRESS":{"Mainnet":"","Astar":"0xDAC282cA5534DC5936165197263E5f08b2C4577c"},"VERSA_FACTORY_ADDRESS":{"Mainnet":"","Astar":"0x4346A7C8C39Bf91b8a80933c2fdb10d815c401dB"},"VERSA_THEGRAPH":{"Mainnet":""},"VERSA_INIT_CODE_HASH":{"Mainnet":"","Astar":"0xd85454abf78812c626635684bd82ec9bbcf160e8f7b0cfb33b5fd6f4db851b88"},"ASTAREXCHANGE_ROUTER_ADDRESS":{"Mainnet":"","Astar":"0xD38F0bC4a0728d2a1fCAaFa364F7c8422Ba1CD14"},"ASTAREXCHANGE_FACTORY_ADDRESS":{"Mainnet":"","Astar":"0x95f506E72777efCB3C54878bB4160b00Cd11cd84"},"ASTAREXCHANGE_THEGRAPH":{"Mainnet":""},"ASTAREXCHANGE_INIT_CODE_HASH":{"Mainnet":"","Astar":"0xc2cba59c13ce63f268e47d20538deaff688bc65268a5214b851a42ba61d73118"},"YUMISWAP_ROUTER_ADDRESS":{"Mainnet":"","Astar":"0xa4183Dca1d46580970d19CB25f4735065018e4E9"},"YUMISWAP_FACTORY_ADDRESS":{"Mainnet":"","Astar":"0xD3CFB8A232Ad5D0A7ABc817ae3BD1F3E7AE4b5E0"},"YUMISWAP_THEGRAPH":{"Mainnet":""},"YUMISWAP_INIT_CODE_HASH":{"Mainnet":"","Astar":"0xa40fa53e635b27774c3263c392063fc460318850b3a47e9d53f199b16e18bb23"}}');

/***/ }),

/***/ 66745:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"UNISWAP_V2_SUBGRAPH_URL":{"Mainnet":"https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v2"},"UNISWAP_V2_HEALTH_URL":{"Mainnet":"https://api.thegraph.com/index-node/graphql"},"ETHEREUM_BLOCKS_SUBGRAPH_URL":{"Mainnet":"https://api.thegraph.com/subgraphs/name/blocklytics/ethereum-blocks"}}');

/***/ }),

/***/ 88592:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"index","type":"uint256"},{"indexed":true,"internalType":"address","name":"claimer","type":"address"},{"indexed":true,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"Claimed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"index","type":"uint256"},{"indexed":true,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"startTime","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"endTime","type":"uint256"},{"indexed":false,"internalType":"bytes32","name":"merkleRoot","type":"bytes32"}],"name":"EventCreated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[{"internalType":"uint256","name":"_eventIndex","type":"uint256"},{"internalType":"bytes32[]","name":"_merkleProof","type":"bytes32[]"},{"internalType":"address","name":"_claimer","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"claim","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"claimEvents","outputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"startTime","type":"uint256"},{"internalType":"uint256","name":"endTime","type":"uint256"},{"internalType":"bytes32","name":"merkleRoot","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"eventIndex","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_eventIndex","type":"uint256"},{"internalType":"address","name":"_address","type":"address"}],"name":"isClaimed","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_token","type":"address"},{"internalType":"uint256","name":"_endTimeFromNow","type":"uint256"},{"internalType":"bytes32","name":"_merkleRoot","type":"bytes32"}],"name":"setupEvent","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_token","type":"address"},{"internalType":"uint256","name":"_startTime","type":"uint256"},{"internalType":"uint256","name":"_endTime","type":"uint256"},{"internalType":"bytes32","name":"_merkleRoot","type":"bytes32"}],"name":"setupEvent","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_eventIndex","type":"uint256"},{"internalType":"bytes32","name":"_merkleRoot","type":"bytes32"}],"name":"updateMerkleRoot","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_token","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"withdrawToken","outputs":[],"stateMutability":"nonpayable","type":"function"}]');

/***/ }),

/***/ 91976:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('[{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"uint256","name":"nonce","type":"uint256"}],"name":"fund","stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes","name":"initCode","type":"bytes"},{"internalType":"bytes32","name":"salt","type":"bytes32"}],"name":"deploy","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"nonpayable","type":"function"}]');

/***/ }),

/***/ 95528:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('[{"constant":true,"inputs":[],"name":"name","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"spender","type":"address"},{"name":"value","type":"uint256"}],"name":"approve","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"totalSupply","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"from","type":"address"},{"name":"to","type":"address"},{"name":"value","type":"uint256"}],"name":"transferFrom","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"decimals","outputs":[{"name":"","type":"uint8"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"symbol","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"to","type":"address"},{"name":"value","type":"uint256"}],"name":"transfer","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_owner","type":"address"},{"name":"_spender","type":"address"}],"name":"allowance","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"payable":true,"stateMutability":"payable","type":"fallback"},{"anonymous":false,"inputs":[{"indexed":true,"name":"owner","type":"address"},{"indexed":true,"name":"spender","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"name":"increaseAllowance","inputs":[{"type":"address","name":"spender","internalType":"address"},{"name":"addedValue","type":"uint256","internalType":"uint256"}],"outputs":[{"type":"bool","internalType":"bool","name":""}],"stateMutability":"nonpayable","type":"function"}]');

/***/ }),

/***/ 78770:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('[{"inputs":[{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"approved","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":false,"internalType":"bool","name":"approved","type":"bool"}],"name":"ApprovalForAll","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"ownerOf","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"tokenURI","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"baseURI","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"uint256","name":"index","type":"uint256"}],"name":"tokenOfOwnerByIndex","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"index","type":"uint256"}],"name":"tokenByIndex","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"approve","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"getApproved","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"bool","name":"approved","type":"bool"}],"name":"setApprovalForAll","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"operator","type":"address"}],"name":"isApprovedForAll","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"transferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"safeTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"bytes","name":"_data","type":"bytes"}],"name":"safeTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"}]');

/***/ }),

/***/ 74122:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":false,"internalType":"bytes32","name":"id","type":"bytes32"},{"indexed":false,"internalType":"address","name":"claimer","type":"address"},{"indexed":false,"internalType":"uint256","name":"claimed_value","type":"uint256"},{"indexed":false,"internalType":"address","name":"token_address","type":"address"}],"name":"ClaimSuccess","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"total","type":"uint256"},{"indexed":false,"internalType":"bytes32","name":"id","type":"bytes32"},{"indexed":false,"internalType":"string","name":"name","type":"string"},{"indexed":false,"internalType":"string","name":"message","type":"string"},{"indexed":false,"internalType":"address","name":"creator","type":"address"},{"indexed":false,"internalType":"uint256","name":"creation_time","type":"uint256"},{"indexed":false,"internalType":"address","name":"token_address","type":"address"},{"indexed":false,"internalType":"uint256","name":"number","type":"uint256"},{"indexed":false,"internalType":"bool","name":"ifrandom","type":"bool"},{"indexed":false,"internalType":"uint256","name":"duration","type":"uint256"}],"name":"CreationSuccess","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"bytes32","name":"id","type":"bytes32"},{"indexed":false,"internalType":"address","name":"token_address","type":"address"},{"indexed":false,"internalType":"uint256","name":"remaining_balance","type":"uint256"}],"name":"RefundSuccess","type":"event"},{"inputs":[{"internalType":"bytes32","name":"id","type":"bytes32"}],"name":"check_availability","outputs":[{"internalType":"address","name":"token_address","type":"address"},{"internalType":"uint256","name":"balance","type":"uint256"},{"internalType":"uint256","name":"total","type":"uint256"},{"internalType":"uint256","name":"claimed","type":"uint256"},{"internalType":"bool","name":"expired","type":"bool"},{"internalType":"uint256","name":"claimed_amount","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"id","type":"bytes32"},{"internalType":"bytes","name":"signedMsg","type":"bytes"},{"internalType":"address payable","name":"recipient","type":"address"}],"name":"claim","outputs":[{"internalType":"uint256","name":"claimed","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_public_key","type":"address"},{"internalType":"uint256","name":"_number","type":"uint256"},{"internalType":"bool","name":"_ifrandom","type":"bool"},{"internalType":"uint256","name":"_duration","type":"uint256"},{"internalType":"bytes32","name":"_seed","type":"bytes32"},{"internalType":"string","name":"_message","type":"string"},{"internalType":"string","name":"_name","type":"string"},{"internalType":"uint256","name":"_token_type","type":"uint256"},{"internalType":"address","name":"_token_addr","type":"address"},{"internalType":"uint256","name":"_total_tokens","type":"uint256"}],"name":"create_red_packet","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"id","type":"bytes32"}],"name":"refund","outputs":[],"stateMutability":"nonpayable","type":"function"}]');

/***/ }),

/***/ 80847:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"id","type":"bytes32"},{"indexed":true,"internalType":"address","name":"claimer","type":"address"},{"indexed":false,"internalType":"uint256","name":"claimed_token_id","type":"uint256"},{"indexed":false,"internalType":"address","name":"token_address","type":"address"}],"name":"ClaimSuccess","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"total_tokens","type":"uint256"},{"indexed":true,"internalType":"bytes32","name":"id","type":"bytes32"},{"indexed":false,"internalType":"string","name":"name","type":"string"},{"indexed":false,"internalType":"string","name":"message","type":"string"},{"indexed":true,"internalType":"address","name":"creator","type":"address"},{"indexed":false,"internalType":"uint256","name":"creation_time","type":"uint256"},{"indexed":false,"internalType":"address","name":"token_address","type":"address"},{"indexed":false,"internalType":"uint256","name":"packet_number","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"duration","type":"uint256"},{"indexed":false,"internalType":"uint256[]","name":"token_ids","type":"uint256[]"}],"name":"CreationSuccess","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"id","type":"bytes32"},{"indexed":true,"internalType":"address","name":"token_address","type":"address"},{"indexed":false,"internalType":"uint16","name":"remaining_balance","type":"uint16"},{"indexed":false,"internalType":"uint256[]","name":"remaining_token_ids","type":"uint256[]"},{"indexed":false,"internalType":"uint256","name":"bit_status","type":"uint256"}],"name":"RefundSuccess","type":"event"},{"inputs":[{"internalType":"bytes32","name":"pkt_id","type":"bytes32"}],"name":"check_availability","outputs":[{"internalType":"address","name":"token_address","type":"address"},{"internalType":"uint16","name":"balance","type":"uint16"},{"internalType":"uint256","name":"total_pkts","type":"uint256"},{"internalType":"bool","name":"expired","type":"bool"},{"internalType":"uint256","name":"claimed_id","type":"uint256"},{"internalType":"uint256","name":"bit_status","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"id","type":"bytes32"}],"name":"check_claimed_id","outputs":[{"internalType":"uint256","name":"claimed_token_id","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"id","type":"bytes32"}],"name":"check_erc721_remain_ids","outputs":[{"internalType":"uint256","name":"bit_status","type":"uint256"},{"internalType":"uint256[]","name":"erc721_token_ids","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256[]","name":"erc721_token_id_list","type":"uint256[]"},{"internalType":"address","name":"token_addr","type":"address"}],"name":"check_ownership","outputs":[{"internalType":"bool","name":"is_your_token","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"pkt_id","type":"bytes32"},{"internalType":"bytes","name":"signedMsg","type":"bytes"},{"internalType":"address payable","name":"recipient","type":"address"}],"name":"claim","outputs":[{"internalType":"uint256","name":"claimed","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_public_key","type":"address"},{"internalType":"uint64","name":"_duration","type":"uint64"},{"internalType":"bytes32","name":"_seed","type":"bytes32"},{"internalType":"string","name":"_message","type":"string"},{"internalType":"string","name":"_name","type":"string"},{"internalType":"address","name":"_token_addr","type":"address"},{"internalType":"uint256[]","name":"_erc721_token_ids","type":"uint256[]"}],"name":"create_red_packet","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"id","type":"bytes32"}],"name":"refund","outputs":[],"stateMutability":"nonpayable","type":"function"}]');

/***/ }),

/***/ 68101:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('[{"inputs":[{"internalType":"address","name":"_factory","type":"address"},{"internalType":"address","name":"_WETH","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"WETH","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"tokenA","type":"address"},{"internalType":"address","name":"tokenB","type":"address"},{"internalType":"uint256","name":"amountADesired","type":"uint256"},{"internalType":"uint256","name":"amountBDesired","type":"uint256"},{"internalType":"uint256","name":"amountAMin","type":"uint256"},{"internalType":"uint256","name":"amountBMin","type":"uint256"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"addLiquidity","outputs":[{"internalType":"uint256","name":"amountA","type":"uint256"},{"internalType":"uint256","name":"amountB","type":"uint256"},{"internalType":"uint256","name":"liquidity","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"amountTokenDesired","type":"uint256"},{"internalType":"uint256","name":"amountTokenMin","type":"uint256"},{"internalType":"uint256","name":"amountETHMin","type":"uint256"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"addLiquidityETH","outputs":[{"internalType":"uint256","name":"amountToken","type":"uint256"},{"internalType":"uint256","name":"amountETH","type":"uint256"},{"internalType":"uint256","name":"liquidity","type":"uint256"}],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"factory","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"},{"internalType":"uint256","name":"reserveIn","type":"uint256"},{"internalType":"uint256","name":"reserveOut","type":"uint256"}],"name":"getAmountIn","outputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"reserveIn","type":"uint256"},{"internalType":"uint256","name":"reserveOut","type":"uint256"}],"name":"getAmountOut","outputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"}],"name":"getAmountsIn","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"}],"name":"getAmountsOut","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountA","type":"uint256"},{"internalType":"uint256","name":"reserveA","type":"uint256"},{"internalType":"uint256","name":"reserveB","type":"uint256"}],"name":"quote","outputs":[{"internalType":"uint256","name":"amountB","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"address","name":"tokenA","type":"address"},{"internalType":"address","name":"tokenB","type":"address"},{"internalType":"uint256","name":"liquidity","type":"uint256"},{"internalType":"uint256","name":"amountAMin","type":"uint256"},{"internalType":"uint256","name":"amountBMin","type":"uint256"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"removeLiquidity","outputs":[{"internalType":"uint256","name":"amountA","type":"uint256"},{"internalType":"uint256","name":"amountB","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"liquidity","type":"uint256"},{"internalType":"uint256","name":"amountTokenMin","type":"uint256"},{"internalType":"uint256","name":"amountETHMin","type":"uint256"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"removeLiquidityETH","outputs":[{"internalType":"uint256","name":"amountToken","type":"uint256"},{"internalType":"uint256","name":"amountETH","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"liquidity","type":"uint256"},{"internalType":"uint256","name":"amountTokenMin","type":"uint256"},{"internalType":"uint256","name":"amountETHMin","type":"uint256"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"removeLiquidityETHSupportingFeeOnTransferTokens","outputs":[{"internalType":"uint256","name":"amountETH","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"liquidity","type":"uint256"},{"internalType":"uint256","name":"amountTokenMin","type":"uint256"},{"internalType":"uint256","name":"amountETHMin","type":"uint256"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"bool","name":"approveMax","type":"bool"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"removeLiquidityETHWithPermit","outputs":[{"internalType":"uint256","name":"amountToken","type":"uint256"},{"internalType":"uint256","name":"amountETH","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"liquidity","type":"uint256"},{"internalType":"uint256","name":"amountTokenMin","type":"uint256"},{"internalType":"uint256","name":"amountETHMin","type":"uint256"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"bool","name":"approveMax","type":"bool"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"removeLiquidityETHWithPermitSupportingFeeOnTransferTokens","outputs":[{"internalType":"uint256","name":"amountETH","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"tokenA","type":"address"},{"internalType":"address","name":"tokenB","type":"address"},{"internalType":"uint256","name":"liquidity","type":"uint256"},{"internalType":"uint256","name":"amountAMin","type":"uint256"},{"internalType":"uint256","name":"amountBMin","type":"uint256"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"bool","name":"approveMax","type":"bool"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"removeLiquidityWithPermit","outputs":[{"internalType":"uint256","name":"amountA","type":"uint256"},{"internalType":"uint256","name":"amountB","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapETHForExactTokens","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapExactETHForTokens","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapExactETHForTokensSupportingFeeOnTransferTokens","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapExactTokensForETH","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapExactTokensForETHSupportingFeeOnTransferTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapExactTokensForTokens","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapExactTokensForTokensSupportingFeeOnTransferTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"},{"internalType":"uint256","name":"amountInMax","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapTokensForExactETH","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"},{"internalType":"uint256","name":"amountInMax","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapTokensForExactTokens","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapAVAXForExactTokens","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapExactAVAXForTokensSupportingFeeOnTransferTokens","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapExactTokensForAVAX","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapExactTokensForAVAXSupportingFeeOnTransferTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"},{"internalType":"uint256","name":"amountInMax","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapTokensForExactAVAX","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapExactAVAXForTokens","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"WAVAX","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"stateMutability":"payable","type":"receive"}]');

/***/ }),

/***/ 5247:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('[{"inputs":[{"internalType":"address","name":"_factory","type":"address"},{"internalType":"address","name":"_WETH9","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"WETH9","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"bytes","name":"path","type":"bytes"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMinimum","type":"uint256"}],"internalType":"struct ISwapRouter.ExactInputParams","name":"params","type":"tuple"}],"name":"exactInput","outputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"}],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"tokenIn","type":"address"},{"internalType":"address","name":"tokenOut","type":"address"},{"internalType":"uint24","name":"fee","type":"uint24"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMinimum","type":"uint256"},{"internalType":"uint160","name":"sqrtPriceLimitX96","type":"uint160"}],"internalType":"struct ISwapRouter.ExactInputSingleParams","name":"params","type":"tuple"}],"name":"exactInputSingle","outputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"}],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"bytes","name":"path","type":"bytes"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"uint256","name":"amountOut","type":"uint256"},{"internalType":"uint256","name":"amountInMaximum","type":"uint256"}],"internalType":"struct ISwapRouter.ExactOutputParams","name":"params","type":"tuple"}],"name":"exactOutput","outputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"}],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"tokenIn","type":"address"},{"internalType":"address","name":"tokenOut","type":"address"},{"internalType":"uint24","name":"fee","type":"uint24"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"uint256","name":"amountOut","type":"uint256"},{"internalType":"uint256","name":"amountInMaximum","type":"uint256"},{"internalType":"uint160","name":"sqrtPriceLimitX96","type":"uint160"}],"internalType":"struct ISwapRouter.ExactOutputSingleParams","name":"params","type":"tuple"}],"name":"exactOutputSingle","outputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"}],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"factory","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"data","type":"bytes[]"}],"name":"multicall","outputs":[{"internalType":"bytes[]","name":"results","type":"bytes[]"}],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"refundETH","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"selfPermit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"nonce","type":"uint256"},{"internalType":"uint256","name":"expiry","type":"uint256"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"selfPermitAllowed","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"nonce","type":"uint256"},{"internalType":"uint256","name":"expiry","type":"uint256"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"selfPermitAllowedIfNecessary","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"selfPermitIfNecessary","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"amountMinimum","type":"uint256"},{"internalType":"address","name":"recipient","type":"address"}],"name":"sweepToken","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"amountMinimum","type":"uint256"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"feeBips","type":"uint256"},{"internalType":"address","name":"feeRecipient","type":"address"}],"name":"sweepTokenWithFee","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"int256","name":"amount0Delta","type":"int256"},{"internalType":"int256","name":"amount1Delta","type":"int256"},{"internalType":"bytes","name":"_data","type":"bytes"}],"name":"uniswapV3SwapCallback","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountMinimum","type":"uint256"},{"internalType":"address","name":"recipient","type":"address"}],"name":"unwrapWETH9","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountMinimum","type":"uint256"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"feeBips","type":"uint256"},{"internalType":"address","name":"feeRecipient","type":"address"}],"name":"unwrapWETH9WithFee","outputs":[],"stateMutability":"payable","type":"function"},{"stateMutability":"payable","type":"receive"}]');

/***/ }),

/***/ 54369:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('[{"constant":true,"inputs":[],"name":"name","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"guy","type":"address"},{"name":"wad","type":"uint256"}],"name":"approve","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"totalSupply","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"src","type":"address"},{"name":"dst","type":"address"},{"name":"wad","type":"uint256"}],"name":"transferFrom","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"wad","type":"uint256"}],"name":"withdraw","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"decimals","outputs":[{"name":"","type":"uint8"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"","type":"address"}],"name":"balanceOf","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"symbol","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"dst","type":"address"},{"name":"wad","type":"uint256"}],"name":"transfer","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[],"name":"deposit","outputs":[],"payable":true,"stateMutability":"payable","type":"function"},{"constant":true,"inputs":[{"name":"","type":"address"},{"name":"","type":"address"}],"name":"allowance","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"payable":true,"stateMutability":"payable","type":"fallback"},{"anonymous":false,"inputs":[{"indexed":true,"name":"src","type":"address"},{"indexed":true,"name":"guy","type":"address"},{"indexed":false,"name":"wad","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"src","type":"address"},{"indexed":true,"name":"dst","type":"address"},{"indexed":false,"name":"wad","type":"uint256"}],"name":"Transfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"dst","type":"address"},{"indexed":false,"name":"wad","type":"uint256"}],"name":"Deposit","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"src","type":"address"},{"indexed":false,"name":"wad","type":"uint256"}],"name":"Withdrawal","type":"event"}]');

/***/ }),

/***/ 49734:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"oldEntryPoint","type":"address"},{"indexed":true,"internalType":"address","name":"newEntryPoint","type":"address"}],"name":"EntryPointChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint8","name":"version","type":"uint8"}],"name":"Initialized","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"oldOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnerChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"oldPaymaster","type":"address"},{"indexed":true,"internalType":"address","name":"newPaymaster","type":"address"}],"name":"PaymasterChanged","type":"event"},{"inputs":[],"name":"NAME","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"VERSION","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"addDeposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"changeOwner","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newPaymaster","type":"address"}],"name":"changePaymaster","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"entryPoint","outputs":[{"internalType":"contract EntryPoint","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"dest","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"bytes","name":"func","type":"bytes"}],"name":"exec","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address[]","name":"dest","type":"address[]"},{"internalType":"bytes[]","name":"func","type":"bytes[]"}],"name":"execBatch","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"dest","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"bytes","name":"func","type":"bytes"}],"name":"execFromEntryPoint","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"getDeposit","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract EntryPoint","name":"_entryPointAddress","type":"address"},{"internalType":"address","name":"_owner","type":"address"},{"internalType":"address","name":"_gasToken","type":"address"},{"internalType":"address","name":"_approveFor","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"},{"internalType":"address","name":"_nativeTokenPaymaster","type":"address"}],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"nativeTokenPaymaster","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"nonce","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"},{"internalType":"uint256[]","name":"","type":"uint256[]"},{"internalType":"uint256[]","name":"","type":"uint256[]"},{"internalType":"bytes","name":"","type":"bytes"}],"name":"onERC1155BatchReceived","outputs":[{"internalType":"bytes4","name":"","type":"bytes4"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"},{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"bytes","name":"","type":"bytes"}],"name":"onERC1155Received","outputs":[{"internalType":"bytes4","name":"","type":"bytes4"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"},{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"bytes","name":"","type":"bytes"}],"name":"onERC721Received","outputs":[{"internalType":"bytes4","name":"","type":"bytes4"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"},{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"bytes","name":"","type":"bytes"},{"internalType":"bytes","name":"","type":"bytes"}],"name":"tokensReceived","outputs":[],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"address payable","name":"dest","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newEntryPoint","type":"address"}],"name":"updateEntryPoint","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"uint256","name":"nonce","type":"uint256"},{"internalType":"bytes","name":"initCode","type":"bytes"},{"internalType":"bytes","name":"callData","type":"bytes"},{"internalType":"uint256","name":"callGas","type":"uint256"},{"internalType":"uint256","name":"verificationGas","type":"uint256"},{"internalType":"uint256","name":"preVerificationGas","type":"uint256"},{"internalType":"uint256","name":"maxFeePerGas","type":"uint256"},{"internalType":"uint256","name":"maxPriorityFeePerGas","type":"uint256"},{"internalType":"address","name":"paymaster","type":"address"},{"internalType":"bytes","name":"paymasterData","type":"bytes"},{"internalType":"bytes","name":"signature","type":"bytes"}],"internalType":"struct UserOperation","name":"userOp","type":"tuple"},{"internalType":"bytes32","name":"requestId","type":"bytes32"},{"internalType":"uint256","name":"missingWalletFunds","type":"uint256"}],"name":"validateUserOp","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address payable","name":"withdrawAddress","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"withdrawDepositTo","outputs":[],"stateMutability":"nonpayable","type":"function"},{"stateMutability":"payable","type":"receive"}]');

/***/ }),

/***/ 45397:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('[{"id":"0x21ca39943e91d704678f5d00b6616650f066fd63","name":"Wrapped Mirror TSLA Token","symbol":"mTSLA","decimals":18,"contract_address":"0x21ca39943e91d704678f5d00b6616650f066fd63"},{"id":"0xd36932143f6ebdedd872d5fb0651f4b72fd15a84","name":"Wrapped Mirror mAAPL Token","symbol":"mAAPL","decimals":18,"contract_address":"0xd36932143f6ebdedd872d5fb0651f4b72fd15a84"},{"id":"0x41bbedd7286daab5910a1f15d12cbda839852bd7","name":"Wrapped Mirror mMSFT Token","symbol":"mMSFT","decimals":18,"contract_address":"0x41bbedd7286daab5910a1f15d12cbda839852bd7"},{"id":"0x13b02c8de71680e71f0820c996e4be43c2f57d15","name":"Wrapped Mirror mQQQ Token","symbol":"mQQQ","decimals":18,"contract_address":"0x13b02c8de71680e71f0820c996e4be43c2f57d15"},{"id":"0x0cae9e4d663793c2a2a0b211c1cf4bbca2b9caa7","name":"Wrapped Mirror mAMZN Token","symbol":"mAMZN","decimals":18,"contract_address":"0x0cae9e4d663793c2a2a0b211c1cf4bbca2b9caa7"},{"id":"0x1d350417d9787e000cc1b95d70e9536dcd91f373","name":"Wrapped Mirror mIAU Token","symbol":"mIAU","decimals":18,"contract_address":"0x1d350417d9787e000cc1b95d70e9536dcd91f373"},{"id":"0x56aa298a19c93c6801fdde870fa63ef75cc0af72","name":"Wrapped Mirror mBABA Token","symbol":"mBABA","decimals":18,"contract_address":"0x56aa298a19c93c6801fdde870fa63ef75cc0af72"},{"id":"0x9d1555d8cB3C846Bb4f7D5B1B1080872c3166676","name":"Wrapped Mirror mSLV Token","symbol":"mSLV","decimals":18,"contract_address":"0x9d1555d8cB3C846Bb4f7D5B1B1080872c3166676"},{"id":"0x31c63146a635eb7465e5853020b39713ac356991","name":"Wrapped Mirror mUSO Token","symbol":"mUSO","decimals":18,"contract_address":"0x31c63146a635eb7465e5853020b39713ac356991"},{"id":"0xc8d674114bac90148d11d3c1d33c61835a0f9dcd","name":"Wrapped Mirror mNFLX Token","symbol":"mNFLX","decimals":18,"contract_address":"0xc8d674114bac90148d11d3c1d33c61835a0f9dcd"},{"id":"0xedb0414627e6f1e3f082de65cd4f9c693d78cca9","name":"Wrapped Mirror mTWTR Token","symbol":"mTWTR","decimals":18,"contract_address":"0xedb0414627e6f1e3f082de65cd4f9c693d78cca9"},{"id":"0xf72fcd9dcf0190923fadd44811e240ef4533fc86","name":"Wrapped Mirror mVIXY Token","symbol":"mVIXY","decimals":18,"contract_address":"0xf72fcd9dcf0190923fadd44811e240ef4533fc86"},{"id":"0x59a921db27dd6d4d974745b7ffc5c33932653442","name":"Wrapped Mirror mGOOGL Token","symbol":"mGOOGL","decimals":18,"contract_address":"0x59a921db27dd6d4d974745b7ffc5c33932653442"}]');

/***/ })

}]);
//# sourceMappingURL=3493.js.map