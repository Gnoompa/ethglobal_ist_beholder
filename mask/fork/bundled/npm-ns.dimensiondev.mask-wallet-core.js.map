{"version":3,"file":"bundled/npm-ns.dimensiondev.mask-wallet-core.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAwC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;;AAExC;;AAEA;;AAEA,0BAA0B;;AAE1B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,oDAAoD,8BAA8B;;AAElF;;AAEA;AACA;AACA,yEAAyE,kDAAW;AACpF,8CAA8C,kDAAW;AACzD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yEAAyE,kDAAW;AACpF,8CAA8C,kDAAW;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB,YAAY;AACZ;AACO;AACP;AACA,uBAAuB,2EAAoC;AAC3D,4CAA4C,6DAAsB;AAClE;AACA,QAAQ,mDAAY;AACpB;AACA;AACA;AACA,QAAQ,2DAAoB;AAC5B;AACA,MAAM;AACN,QAAQ,2EAAoC;AAC5C;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN,QAAQ,gEAAyB;AACjC;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,WAAW,cAAc;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEO,oDAAoD;AAC3D;AACA,CAAC;;AAEM;AACP;AACA;;AAEO,mDAAmD;AAC1D;AACA,CAAC;;AAEM;AACP;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEO,kDAAkD;AACzD,cAAc,2BAAe,8BAA8B,CAAC;AAC5D;AACA,CAAC;;AAEM;AACP;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEO,yCAAyC;AAChD;AACA;AACA,CAAC;;AAEM;AACP;AACA;AACA;;AAEO,yCAAyC;AAChD;AACA;AACA,CAAC;;AAEM,2CAA2C;AAClD;AACA;AACA,CAAC;;AAEM,+CAA+C;AACtD;AACA;AACA,CAAC;;AAEM,2CAA2C;AAClD,cAAc,qBAAM;AACpB;AACA,CAAC;;AAEM;AACP;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEO;AACP;AACA,sCAAsC,6DAAsB,EAAE,8DAAuB;AACrF;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA,MAAM;AACN,QAAQ,2DAAoB;AAC5B;AACA;;AAEO;AACP;AACA;;AAEO;AACP,cAAc,kDAAW;AACzB;AACA;;;;;;;;;;;;;;;;;AC9SA;AACgD;;AAEhD;AACA,gBAAgB,sDAAgB,YAAY,sDAAgB,UAAU,oDAAc;;AAEpF;AACA,cAAc,qDAAe,gBAAgB,qDAAe,gBAAgB;;AAErE;;AAEP;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC,sBAAsB,aAAa;AACnC,sBAAsB,eAAe;AACrC,sBAAsB,aAAa;AACnC,sBAAsB,aAAa;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4CAA4C;AAC/D;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA,oGAAoG,8DAA8D;AAClK;AACA;AACA;AACA,mBAAmB,2CAA2C;AAC9D,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,0CAA0C;AAC/D,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,gCAAgC;AACtD,sBAAsB,yBAAyB;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2CAA2C;AAC9D;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,0CAA0C;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,mCAAmC;AACvD;AACA;AACA;AACA;;AAEA;AACA,mGAAmG,6DAA6D;AAChK;AACA;AACA;AACA,mBAAmB,0CAA0C;AAC7D,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,yCAAyC;AAC9D,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,cAAc;AACd,kBAAkB,QAAQ;AAC1B,kBAAkB,QAAQ;AAC1B,kBAAkB,QAAQ;AAC1B;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,cAAc;AACd,kBAAkB,QAAQ;AAC1B,kBAAkB,QAAQ;AAC1B;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,cAAc;AACd,kBAAkB,QAAQ;AAC1B,kBAAkB,QAAQ;AAC1B,kBAAkB,QAAQ;AAC1B;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,cAAc;AACd,kBAAkB,QAAQ;AAC1B,kBAAkB,QAAQ;AAC1B,kBAAkB,QAAQ;AAC1B;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC,sBAAsB,aAAa;AACnC,sBAAsB,wBAAwB;AAC9C,sBAAsB,iBAAiB;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA,6EAA6E,uCAAuC;AACpH;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,mBAAmB;AACxC,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC,sBAAsB,aAAa;AACnC,sBAAsB,aAAa;AACnC,sBAAsB,aAAa;AACnC,sBAAsB,aAAa;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA,oFAAoF,8CAA8C;AAClI;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,0BAA0B;AAC/C,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,8BAA8B;AACpD,sBAAsB,gCAAgC;AACtD,sBAAsB,uCAAuC;AAC7D,sBAAsB,wCAAwC;AAC9D,sBAAsB,oCAAoC;AAC1D,sBAAsB,gDAAgD;AACtE,sBAAsB,yCAAyC;AAC/D,sBAAsB,+CAA+C;AACrE,sBAAsB,uCAAuC;AAC7D,sBAAsB,4CAA4C;AAClE,sBAAsB,yCAAyC;AAC/D,sBAAsB,wCAAwC;AAC9D,sBAAsB,gCAAgC;AACtD,sBAAsB,2BAA2B;AACjD,sBAAsB,yBAAyB;AAC/C,sBAAsB,6CAA6C;AACnE,sBAAsB,6CAA6C;AACnE,sBAAsB,iCAAiC;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,wCAAwC;AAC5D;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,0CAA0C;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,iDAAiD;AACrE;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,kDAAkD;AACtE;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,8CAA8C;AAClE;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,0DAA0D;AAC9E;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,mDAAmD;AACvE;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,yDAAyD;AAC7E;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,iDAAiD;AACrE;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,sDAAsD;AAC1E;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,mDAAmD;AACvE;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,kDAAkD;AACtE;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,0CAA0C;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,qCAAqC;AACzD;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,mCAAmC;AACvD;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,uDAAuD;AAC3E;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,uDAAuD;AAC3E;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,2CAA2C;AAC/D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB,khBAAkhB;AACtiB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,yEAAyE,mCAAmC;AAC5G;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,eAAe;AACpC,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,2BAA2B;AACjD,sBAAsB,6BAA6B;AACnD,sBAAsB,+BAA+B;AACrD,sBAAsB,sCAAsC;AAC5D,sBAAsB,uCAAuC;AAC7D,sBAAsB,mCAAmC;AACzD,sBAAsB,+CAA+C;AACrE,sBAAsB,wCAAwC;AAC9D,sBAAsB,sCAAsC;AAC5D,sBAAsB,kCAAkC;AACxD,sBAAsB,uCAAuC;AAC7D,sBAAsB,+BAA+B;AACrD,sBAAsB,0BAA0B;AAChD,sBAAsB,wBAAwB;AAC9C,sBAAsB,4CAA4C;AAClE,sBAAsB,4CAA4C;AAClE,sBAAsB,gCAAgC;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,qCAAqC;AACzD;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,uCAAuC;AAC3D;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,yCAAyC;AAC7D;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,gDAAgD;AACpE;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,iDAAiD;AACrE;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,6CAA6C;AACjE;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,yDAAyD;AAC7E;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,kDAAkD;AACtE;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,gDAAgD;AACpE;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,4CAA4C;AAChE;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,iDAAiD;AACrE;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,yCAAyC;AAC7D;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,oCAAoC;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,kCAAkC;AACtD;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,sDAAsD;AAC1E;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,sDAAsD;AAC1E;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,0CAA0C;AAC9D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB,obAAob;AACxc;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,0EAA0E,oCAAoC;AAC9G;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,gBAAgB;AACrC,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC,sBAAsB,aAAa;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA,+EAA+E,yCAAyC;AACxH;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,qBAAqB;AAC1C,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA,+EAA+E,yCAAyC;AACxH;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,qBAAqB;AAC1C,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA,8EAA8E,wCAAwC;AACtH;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,oBAAoB;AACzC,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,eAAe;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yCAAyC;AAC5D;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;;AAEA;AACA,iGAAiG,2DAA2D;AAC5J;AACA;AACA;AACA,mBAAmB,wCAAwC;AAC3D,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,uCAAuC;AAC5D,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,sCAAsC;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wCAAwC;AAC3D;AACA;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,iCAAiC;AACrD;AACA;AACA;AACA;;AAEA;AACA,gGAAgG,0DAA0D;AAC1J;AACA;AACA;AACA,mBAAmB,uCAAuC;AAC1D,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yBAAyB;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,sCAAsC;AAC3D,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC,sBAAsB,aAAa;AACnC,sBAAsB,eAAe;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qCAAqC;AACxD;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;;AAEA;AACA,6FAA6F,uDAAuD;AACpJ;AACA;AACA;AACA,mBAAmB,oCAAoC;AACvD,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,mCAAmC;AACxD,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC,sBAAsB,aAAa;AACnC,sBAAsB,eAAe;AACrC,sBAAsB,aAAa;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2CAA2C;AAC9D;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA,mGAAmG,6DAA6D;AAChK;AACA;AACA;AACA,mBAAmB,0CAA0C;AAC7D,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,yCAAyC;AAC9D,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oCAAoC;AACvD;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA,4FAA4F,sDAAsD;AAClJ;AACA;AACA;AACA,mBAAmB,mCAAmC;AACtD,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,kCAAkC;AACvD,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC,sBAAsB,aAAa;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mCAAmC;AACtD;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA,2FAA2F,qDAAqD;AAChJ;AACA;AACA;AACA,mBAAmB,kCAAkC;AACrD,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,iCAAiC;AACtD,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kCAAkC;AACrD;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA,0FAA0F,oDAAoD;AAC9I;AACA;AACA;AACA,mBAAmB,iCAAiC;AACpD,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,gCAAgC;AACrD,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC,sBAAsB,aAAa;AACnC,sBAAsB,aAAa;AACnC,sBAAsB,eAAe;AACrC,sBAAsB,aAAa;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wCAAwC;AAC3D;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA,gGAAgG,0DAA0D;AAC1J;AACA;AACA;AACA,mBAAmB,uCAAuC;AAC1D,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,sCAAsC;AAC3D,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC,sBAAsB,aAAa;AACnC,sBAAsB,aAAa;AACnC,sBAAsB,eAAe;AACrC,sBAAsB,aAAa;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qCAAqC;AACxD;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA,6FAA6F,uDAAuD;AACpJ;AACA;AACA;AACA,mBAAmB,oCAAoC;AACvD,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,mCAAmC;AACxD,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8BAA8B;AACjD;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA,sFAAsF,gDAAgD;AACtI;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,4BAA4B;AACjD,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,eAAe;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yCAAyC;AAC5D;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;;AAEA;AACA,iGAAiG,2DAA2D;AAC5J;AACA;AACA;AACA,mBAAmB,wCAAwC;AAC3D,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,uCAAuC;AAC5D,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,sCAAsC;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wCAAwC;AAC3D;AACA;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,iCAAiC;AACrD;AACA;AACA;AACA;;AAEA;AACA,gGAAgG,0DAA0D;AAC1J;AACA;AACA;AACA,mBAAmB,uCAAuC;AAC1D,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yBAAyB;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,sCAAsC;AAC3D,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,yBAAyB;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;;AAEA;AACA,kFAAkF,4CAA4C;AAC9H;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA,gCAAgC,yBAAyB;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,wBAAwB;AAC7C,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,iCAAiC;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;;AAEA;AACA,iFAAiF,2CAA2C;AAC5H;AACA;AACA;AACA,mBAAmB,wBAAwB;AAC3C,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA,gCAAgC,+BAA+B;AAC/D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,uBAAuB;AAC5C,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA,oFAAoF,8CAA8C;AAClI;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,0BAA0B;AAC/C,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,yBAAyB;AAC/C,sBAAsB,aAAa;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,mCAAmC;AACvD;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA,mFAAmF,6CAA6C;AAChI;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,yBAAyB;AAC9C,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC,sBAAsB,aAAa;AACnC,sBAAsB,aAAa;AACnC,sBAAsB,eAAe;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mCAAmC;AACtD;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;;AAEA;AACA,2FAA2F,qDAAqD;AAChJ;AACA;AACA;AACA,mBAAmB,kCAAkC;AACrD,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,iCAAiC;AACtD,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,yBAAyB;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kCAAkC;AACrD;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,mCAAmC;AACvD;AACA;AACA;AACA;;AAEA;AACA,0FAA0F,oDAAoD;AAC9I;AACA;AACA;AACA,mBAAmB,iCAAiC;AACpD,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,gCAAgC;AACrD,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC,sBAAsB,aAAa;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oCAAoC;AACvD;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA,4FAA4F,sDAAsD;AAClJ;AACA;AACA;AACA,mBAAmB,mCAAmC;AACtD,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,kCAAkC;AACvD,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,yBAAyB;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mCAAmC;AACtD;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,mCAAmC;AACvD;AACA;AACA;AACA;;AAEA;AACA,2FAA2F,qDAAqD;AAChJ;AACA;AACA;AACA,mBAAmB,kCAAkC;AACrD,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,iCAAiC;AACtD,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC,sBAAsB,aAAa;AACnC,sBAAsB,aAAa;AACnC,sBAAsB,aAAa;AACnC,sBAAsB,eAAe;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gCAAgC;AACnD;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;;AAEA;AACA,wFAAwF,kDAAkD;AAC1I;AACA;AACA;AACA,mBAAmB,+BAA+B;AAClD,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,8BAA8B;AACnD,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,yBAAyB;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+BAA+B;AAClD;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,mCAAmC;AACvD;AACA;AACA;AACA;;AAEA;AACA,uFAAuF,iDAAiD;AACxI;AACA;AACA;AACA,mBAAmB,8BAA8B;AACjD,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,6BAA6B;AAClD,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC,sBAAsB,aAAa;AACnC,sBAAsB,aAAa;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oCAAoC;AACvD;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA,4FAA4F,sDAAsD;AAClJ;AACA;AACA;AACA,mBAAmB,mCAAmC;AACtD,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,kCAAkC;AACvD,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,yBAAyB;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mCAAmC;AACtD;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,mCAAmC;AACvD;AACA;AACA;AACA;;AAEA;AACA,2FAA2F,qDAAqD;AAChJ;AACA;AACA;AACA,mBAAmB,kCAAkC;AACrD,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,iCAAiC;AACtD,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA,qFAAqF,+CAA+C;AACpI;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,2BAA2B;AAChD,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA,oFAAoF,8CAA8C;AAClI;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,0BAA0B;AAC/C,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC,sBAAsB,aAAa;AACnC,sBAAsB,aAAa;AACnC,sBAAsB,eAAe;AACrC,sBAAsB,0BAA0B;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,oCAAoC;AACxD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,oFAAoF,8CAA8C;AAClI;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,0BAA0B;AAC/C,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,2BAA2B;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,qCAAqC;AACzD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,mFAAmF,6CAA6C;AAChI;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,yBAAyB;AAC9C,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC,sBAAsB,aAAa;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+BAA+B;AAClD;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA,uFAAuF,iDAAiD;AACxI;AACA;AACA;AACA,mBAAmB,8BAA8B;AACjD,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,6BAA6B;AAClD,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC,sBAAsB,eAAe;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8BAA8B;AACjD;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;;AAEA;AACA,sFAAsF,gDAAgD;AACtI;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,4BAA4B;AACjD,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC,sBAAsB,aAAa;AACnC,sBAAsB,aAAa;AACnC,sBAAsB,mCAAmC;AACzD,sBAAsB,kCAAkC;AACxD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,6CAA6C;AACjE;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,4CAA4C;AAChE;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB,+FAA+F;AACnH;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,6EAA6E,uCAAuC;AACpH;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,mBAAmB;AACxC,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,cAAc;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;;AAEA;AACA,4EAA4E,sCAAsC;AAClH;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,kBAAkB;AACvC,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA,CAAC;;AAEM;;AAEP;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC,sBAAsB,aAAa;AACnC,sBAAsB,aAAa;AACnC,sBAAsB,aAAa;AACnC,sBAAsB,aAAa;AACnC,sBAAsB,aAAa;AACnC,sBAAsB,aAAa;AACnC,sBAAsB,aAAa;AACnC,sBAAsB,iBAAiB;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA,yEAAyE,wCAAwC;AACjH;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,oBAAoB;AACzC,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC,sBAAsB,aAAa;AACnC,sBAAsB,iBAAiB;AACvC,sBAAsB,iBAAiB;AACvC,sBAAsB,iBAAiB;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA,0EAA0E,yCAAyC;AACnH;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC,mBAAmB,kBAAkB;AACrC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,mBAAmB,QAAQ;AAC3B,qBAAqB,qBAAqB;AAC1C,oBAAoB,OAAO;AAC3B,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA,CAAC;;AAE2B","sources":["webpack://mask-network/./node_modules/.pnpm/@dimensiondev+mask-wallet-core@0.1.0-20211013082857-eb62e5f_protobufjs@6.11.4/node_modules/@dimensiondev/mask-wallet-core/bundle/index.js","webpack://mask-network/./node_modules/.pnpm/@dimensiondev+mask-wallet-core@0.1.0-20211013082857-eb62e5f_protobufjs@6.11.4/node_modules/@dimensiondev/mask-wallet-core/bundle/index_bg.js","webpack://mask-network/./node_modules/.pnpm/@dimensiondev+mask-wallet-core@0.1.0-20211013082857-eb62e5f_protobufjs@6.11.4/node_modules/@dimensiondev/mask-wallet-core/proto/index.esm.js"],"sourcesContent":["import * as wasm from \"./index_bg.wasm\";\nexport * from \"./index_bg.js\";","import * as wasm from './index_bg.wasm';\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1);\n    getUint8Memory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n/**\n* @param {Uint8Array} input\n* @returns {Uint8Array}\n*/\nexport function request(input) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        var ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.request(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v1 = getArrayU8FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 1);\n        return v1;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n\nconst lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;\n\nlet cachedTextEncoder = new lTextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nexport function __wbg_getRandomValues_98117e9a7e993920() { return handleError(function (arg0, arg1) {\n    getObject(arg0).getRandomValues(getObject(arg1));\n}, arguments) };\n\nexport function __wbindgen_object_drop_ref(arg0) {\n    takeObject(arg0);\n};\n\nexport function __wbg_randomFillSync_64cc7d048f228ca8() { return handleError(function (arg0, arg1, arg2) {\n    getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));\n}, arguments) };\n\nexport function __wbg_process_2f24d6544ea7b200(arg0) {\n    var ret = getObject(arg0).process;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_is_object(arg0) {\n    const val = getObject(arg0);\n    var ret = typeof(val) === 'object' && val !== null;\n    return ret;\n};\n\nexport function __wbg_versions_6164651e75405d4a(arg0) {\n    var ret = getObject(arg0).versions;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_node_4b517d861cbcb3bc(arg0) {\n    var ret = getObject(arg0).node;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_is_string(arg0) {\n    var ret = typeof(getObject(arg0)) === 'string';\n    return ret;\n};\n\nexport function __wbg_modulerequire_3440a4bcf44437db() { return handleError(function (arg0, arg1) {\n    var ret = module.require(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_crypto_98fc271021c7d2ad(arg0) {\n    var ret = getObject(arg0).crypto;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_msCrypto_a2cdb043d2bfe57f(arg0) {\n    var ret = getObject(arg0).msCrypto;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_newnoargs_be86524d73f67598(arg0, arg1) {\n    var ret = new Function(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_call_888d259a5fefc347() { return handleError(function (arg0, arg1) {\n    var ret = getObject(arg0).call(getObject(arg1));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbindgen_object_clone_ref(arg0) {\n    var ret = getObject(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_self_c6fbdfc2918d5e58() { return handleError(function () {\n    var ret = self.self;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_window_baec038b5ab35c54() { return handleError(function () {\n    var ret = window.window;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_globalThis_3f735a5746d41fbd() { return handleError(function () {\n    var ret = globalThis.globalThis;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_global_1bc0b39582740e95() { return handleError(function () {\n    var ret = global.global;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbindgen_is_undefined(arg0) {\n    var ret = getObject(arg0) === undefined;\n    return ret;\n};\n\nexport function __wbg_buffer_397eaa4d72ee94dd(arg0) {\n    var ret = getObject(arg0).buffer;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_a7ce447f15ff496f(arg0) {\n    var ret = new Uint8Array(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_set_969ad0a60e51d320(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nexport function __wbg_length_1eb8fc608a0d4cdb(arg0) {\n    var ret = getObject(arg0).length;\n    return ret;\n};\n\nexport function __wbg_newwithlength_929232475839a482(arg0) {\n    var ret = new Uint8Array(arg0 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_subarray_8b658422a224f479(arg0, arg1, arg2) {\n    var ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_693216e109162396() {\n    var ret = new Error();\n    return addHeapObject(ret);\n};\n\nexport function __wbg_stack_0ddaca5d1abfb52f(arg0, arg1) {\n    var ret = getObject(arg1).stack;\n    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport function __wbg_error_09919627ac0992f5(arg0, arg1) {\n    try {\n        console.error(getStringFromWasm0(arg0, arg1));\n    } finally {\n        wasm.__wbindgen_free(arg0, arg1);\n    }\n};\n\nexport function __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\nexport function __wbindgen_memory() {\n    var ret = wasm.memory;\n    return addHeapObject(ret);\n};\n\n","/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\nimport * as $protobuf from \"protobufjs/minimal\";\n\n// Common aliases\nconst $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nconst $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\nexport const api = $root.api = (() => {\n\n    /**\n     * Namespace api.\n     * @exports api\n     * @namespace\n     */\n    const api = {};\n\n    api.CreateStoredKeyNewAccountAtPathParam = (function() {\n\n        /**\n         * Properties of a CreateStoredKeyNewAccountAtPathParam.\n         * @memberof api\n         * @interface ICreateStoredKeyNewAccountAtPathParam\n         * @property {Uint8Array|null} [StoredKeyData] CreateStoredKeyNewAccountAtPathParam StoredKeyData\n         * @property {string|null} [name] CreateStoredKeyNewAccountAtPathParam name\n         * @property {api.Coin|null} [coin] CreateStoredKeyNewAccountAtPathParam coin\n         * @property {string|null} [derivationPath] CreateStoredKeyNewAccountAtPathParam derivationPath\n         * @property {string|null} [password] CreateStoredKeyNewAccountAtPathParam password\n         */\n\n        /**\n         * Constructs a new CreateStoredKeyNewAccountAtPathParam.\n         * @memberof api\n         * @classdesc Represents a CreateStoredKeyNewAccountAtPathParam.\n         * @implements ICreateStoredKeyNewAccountAtPathParam\n         * @constructor\n         * @param {api.ICreateStoredKeyNewAccountAtPathParam=} [properties] Properties to set\n         */\n        function CreateStoredKeyNewAccountAtPathParam(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CreateStoredKeyNewAccountAtPathParam StoredKeyData.\n         * @member {Uint8Array} StoredKeyData\n         * @memberof api.CreateStoredKeyNewAccountAtPathParam\n         * @instance\n         */\n        CreateStoredKeyNewAccountAtPathParam.prototype.StoredKeyData = $util.newBuffer([]);\n\n        /**\n         * CreateStoredKeyNewAccountAtPathParam name.\n         * @member {string} name\n         * @memberof api.CreateStoredKeyNewAccountAtPathParam\n         * @instance\n         */\n        CreateStoredKeyNewAccountAtPathParam.prototype.name = \"\";\n\n        /**\n         * CreateStoredKeyNewAccountAtPathParam coin.\n         * @member {api.Coin} coin\n         * @memberof api.CreateStoredKeyNewAccountAtPathParam\n         * @instance\n         */\n        CreateStoredKeyNewAccountAtPathParam.prototype.coin = 0;\n\n        /**\n         * CreateStoredKeyNewAccountAtPathParam derivationPath.\n         * @member {string} derivationPath\n         * @memberof api.CreateStoredKeyNewAccountAtPathParam\n         * @instance\n         */\n        CreateStoredKeyNewAccountAtPathParam.prototype.derivationPath = \"\";\n\n        /**\n         * CreateStoredKeyNewAccountAtPathParam password.\n         * @member {string} password\n         * @memberof api.CreateStoredKeyNewAccountAtPathParam\n         * @instance\n         */\n        CreateStoredKeyNewAccountAtPathParam.prototype.password = \"\";\n\n        /**\n         * Encodes the specified CreateStoredKeyNewAccountAtPathParam message. Does not implicitly {@link api.CreateStoredKeyNewAccountAtPathParam.verify|verify} messages.\n         * @function encode\n         * @memberof api.CreateStoredKeyNewAccountAtPathParam\n         * @static\n         * @param {api.ICreateStoredKeyNewAccountAtPathParam} message CreateStoredKeyNewAccountAtPathParam message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CreateStoredKeyNewAccountAtPathParam.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.StoredKeyData != null && Object.hasOwnProperty.call(message, \"StoredKeyData\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.StoredKeyData);\n            if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);\n            if (message.coin != null && Object.hasOwnProperty.call(message, \"coin\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.coin);\n            if (message.derivationPath != null && Object.hasOwnProperty.call(message, \"derivationPath\"))\n                writer.uint32(/* id 4, wireType 2 =*/34).string(message.derivationPath);\n            if (message.password != null && Object.hasOwnProperty.call(message, \"password\"))\n                writer.uint32(/* id 5, wireType 2 =*/42).string(message.password);\n            return writer;\n        };\n\n        /**\n         * Decodes a CreateStoredKeyNewAccountAtPathParam message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.CreateStoredKeyNewAccountAtPathParam\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.CreateStoredKeyNewAccountAtPathParam} CreateStoredKeyNewAccountAtPathParam\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CreateStoredKeyNewAccountAtPathParam.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.CreateStoredKeyNewAccountAtPathParam();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.StoredKeyData = reader.bytes();\n                    break;\n                case 2:\n                    message.name = reader.string();\n                    break;\n                case 3:\n                    message.coin = reader.int32();\n                    break;\n                case 4:\n                    message.derivationPath = reader.string();\n                    break;\n                case 5:\n                    message.password = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return CreateStoredKeyNewAccountAtPathParam;\n    })();\n\n    api.CreateStoredKeyNewAccountAtPathResp = (function() {\n\n        /**\n         * Properties of a CreateStoredKeyNewAccountAtPathResp.\n         * @memberof api\n         * @interface ICreateStoredKeyNewAccountAtPathResp\n         * @property {api.IStoredKeyAccountInfo|null} [account] CreateStoredKeyNewAccountAtPathResp account\n         * @property {api.IStoredKeyInfo|null} [storedKey] CreateStoredKeyNewAccountAtPathResp storedKey\n         */\n\n        /**\n         * Constructs a new CreateStoredKeyNewAccountAtPathResp.\n         * @memberof api\n         * @classdesc Represents a CreateStoredKeyNewAccountAtPathResp.\n         * @implements ICreateStoredKeyNewAccountAtPathResp\n         * @constructor\n         * @param {api.ICreateStoredKeyNewAccountAtPathResp=} [properties] Properties to set\n         */\n        function CreateStoredKeyNewAccountAtPathResp(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CreateStoredKeyNewAccountAtPathResp account.\n         * @member {api.IStoredKeyAccountInfo|null|undefined} account\n         * @memberof api.CreateStoredKeyNewAccountAtPathResp\n         * @instance\n         */\n        CreateStoredKeyNewAccountAtPathResp.prototype.account = null;\n\n        /**\n         * CreateStoredKeyNewAccountAtPathResp storedKey.\n         * @member {api.IStoredKeyInfo|null|undefined} storedKey\n         * @memberof api.CreateStoredKeyNewAccountAtPathResp\n         * @instance\n         */\n        CreateStoredKeyNewAccountAtPathResp.prototype.storedKey = null;\n\n        /**\n         * Encodes the specified CreateStoredKeyNewAccountAtPathResp message. Does not implicitly {@link api.CreateStoredKeyNewAccountAtPathResp.verify|verify} messages.\n         * @function encode\n         * @memberof api.CreateStoredKeyNewAccountAtPathResp\n         * @static\n         * @param {api.ICreateStoredKeyNewAccountAtPathResp} message CreateStoredKeyNewAccountAtPathResp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CreateStoredKeyNewAccountAtPathResp.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.account != null && Object.hasOwnProperty.call(message, \"account\"))\n                $root.api.StoredKeyAccountInfo.encode(message.account, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.storedKey != null && Object.hasOwnProperty.call(message, \"storedKey\"))\n                $root.api.StoredKeyInfo.encode(message.storedKey, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Decodes a CreateStoredKeyNewAccountAtPathResp message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.CreateStoredKeyNewAccountAtPathResp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.CreateStoredKeyNewAccountAtPathResp} CreateStoredKeyNewAccountAtPathResp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CreateStoredKeyNewAccountAtPathResp.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.CreateStoredKeyNewAccountAtPathResp();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.account = $root.api.StoredKeyAccountInfo.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.storedKey = $root.api.StoredKeyInfo.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return CreateStoredKeyNewAccountAtPathResp;\n    })();\n\n    /**\n     * Coin enum.\n     * @name api.Coin\n     * @enum {number}\n     * @property {number} Ethereum=0 Ethereum value\n     * @property {number} Polkadot=1 Polkadot value\n     * @property {number} Solana=2 Solana value\n     */\n    api.Coin = (function() {\n        const valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"Ethereum\"] = 0;\n        values[valuesById[1] = \"Polkadot\"] = 1;\n        values[valuesById[2] = \"Solana\"] = 2;\n        return values;\n    })();\n\n    /**\n     * StoredKeyType enum.\n     * @name api.StoredKeyType\n     * @enum {number}\n     * @property {number} PrivateKey=0 PrivateKey value\n     * @property {number} Mnemonic=1 Mnemonic value\n     */\n    api.StoredKeyType = (function() {\n        const valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"PrivateKey\"] = 0;\n        values[valuesById[1] = \"Mnemonic\"] = 1;\n        return values;\n    })();\n\n    /**\n     * StoredKeyImportType enum.\n     * @name api.StoredKeyImportType\n     * @enum {number}\n     * @property {number} PrivateKeyImportType=0 PrivateKeyImportType value\n     * @property {number} MnemonicImportType=1 MnemonicImportType value\n     * @property {number} KeyStoreJSONImportType=2 KeyStoreJSONImportType value\n     */\n    api.StoredKeyImportType = (function() {\n        const valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"PrivateKeyImportType\"] = 0;\n        values[valuesById[1] = \"MnemonicImportType\"] = 1;\n        values[valuesById[2] = \"KeyStoreJSONImportType\"] = 2;\n        return values;\n    })();\n\n    /**\n     * StoredKeyExportType enum.\n     * @name api.StoredKeyExportType\n     * @enum {number}\n     * @property {number} PrivateKeyExportType=0 PrivateKeyExportType value\n     * @property {number} MnemonicExportType=1 MnemonicExportType value\n     * @property {number} KeyStoreJSONExportType=2 KeyStoreJSONExportType value\n     */\n    api.StoredKeyExportType = (function() {\n        const valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"PrivateKeyExportType\"] = 0;\n        values[valuesById[1] = \"MnemonicExportType\"] = 1;\n        values[valuesById[2] = \"KeyStoreJSONExportType\"] = 2;\n        return values;\n    })();\n\n    api.StoredKeyInfo = (function() {\n\n        /**\n         * Properties of a StoredKeyInfo.\n         * @memberof api\n         * @interface IStoredKeyInfo\n         * @property {string|null} [id] StoredKeyInfo id\n         * @property {string|null} [hash] StoredKeyInfo hash\n         * @property {api.StoredKeyType|null} [type] StoredKeyInfo type\n         * @property {Uint8Array|null} [data] StoredKeyInfo data\n         */\n\n        /**\n         * Constructs a new StoredKeyInfo.\n         * @memberof api\n         * @classdesc Represents a StoredKeyInfo.\n         * @implements IStoredKeyInfo\n         * @constructor\n         * @param {api.IStoredKeyInfo=} [properties] Properties to set\n         */\n        function StoredKeyInfo(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * StoredKeyInfo id.\n         * @member {string} id\n         * @memberof api.StoredKeyInfo\n         * @instance\n         */\n        StoredKeyInfo.prototype.id = \"\";\n\n        /**\n         * StoredKeyInfo hash.\n         * @member {string} hash\n         * @memberof api.StoredKeyInfo\n         * @instance\n         */\n        StoredKeyInfo.prototype.hash = \"\";\n\n        /**\n         * StoredKeyInfo type.\n         * @member {api.StoredKeyType} type\n         * @memberof api.StoredKeyInfo\n         * @instance\n         */\n        StoredKeyInfo.prototype.type = 0;\n\n        /**\n         * StoredKeyInfo data.\n         * @member {Uint8Array} data\n         * @memberof api.StoredKeyInfo\n         * @instance\n         */\n        StoredKeyInfo.prototype.data = $util.newBuffer([]);\n\n        /**\n         * Encodes the specified StoredKeyInfo message. Does not implicitly {@link api.StoredKeyInfo.verify|verify} messages.\n         * @function encode\n         * @memberof api.StoredKeyInfo\n         * @static\n         * @param {api.IStoredKeyInfo} message StoredKeyInfo message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        StoredKeyInfo.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.id != null && Object.hasOwnProperty.call(message, \"id\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);\n            if (message.hash != null && Object.hasOwnProperty.call(message, \"hash\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.hash);\n            if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);\n            if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.data);\n            return writer;\n        };\n\n        /**\n         * Decodes a StoredKeyInfo message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.StoredKeyInfo\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.StoredKeyInfo} StoredKeyInfo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        StoredKeyInfo.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.StoredKeyInfo();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.id = reader.string();\n                    break;\n                case 2:\n                    message.hash = reader.string();\n                    break;\n                case 3:\n                    message.type = reader.int32();\n                    break;\n                case 4:\n                    message.data = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return StoredKeyInfo;\n    })();\n\n    api.StoredKeyAccountInfo = (function() {\n\n        /**\n         * Properties of a StoredKeyAccountInfo.\n         * @memberof api\n         * @interface IStoredKeyAccountInfo\n         * @property {string|null} [address] StoredKeyAccountInfo address\n         * @property {string|null} [name] StoredKeyAccountInfo name\n         * @property {string|null} [derivationPath] StoredKeyAccountInfo derivationPath\n         * @property {string|null} [coin] StoredKeyAccountInfo coin\n         * @property {string|null} [extendedPublicKey] StoredKeyAccountInfo extendedPublicKey\n         */\n\n        /**\n         * Constructs a new StoredKeyAccountInfo.\n         * @memberof api\n         * @classdesc Represents a StoredKeyAccountInfo.\n         * @implements IStoredKeyAccountInfo\n         * @constructor\n         * @param {api.IStoredKeyAccountInfo=} [properties] Properties to set\n         */\n        function StoredKeyAccountInfo(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * StoredKeyAccountInfo address.\n         * @member {string} address\n         * @memberof api.StoredKeyAccountInfo\n         * @instance\n         */\n        StoredKeyAccountInfo.prototype.address = \"\";\n\n        /**\n         * StoredKeyAccountInfo name.\n         * @member {string} name\n         * @memberof api.StoredKeyAccountInfo\n         * @instance\n         */\n        StoredKeyAccountInfo.prototype.name = \"\";\n\n        /**\n         * StoredKeyAccountInfo derivationPath.\n         * @member {string} derivationPath\n         * @memberof api.StoredKeyAccountInfo\n         * @instance\n         */\n        StoredKeyAccountInfo.prototype.derivationPath = \"\";\n\n        /**\n         * StoredKeyAccountInfo coin.\n         * @member {string} coin\n         * @memberof api.StoredKeyAccountInfo\n         * @instance\n         */\n        StoredKeyAccountInfo.prototype.coin = \"\";\n\n        /**\n         * StoredKeyAccountInfo extendedPublicKey.\n         * @member {string} extendedPublicKey\n         * @memberof api.StoredKeyAccountInfo\n         * @instance\n         */\n        StoredKeyAccountInfo.prototype.extendedPublicKey = \"\";\n\n        /**\n         * Encodes the specified StoredKeyAccountInfo message. Does not implicitly {@link api.StoredKeyAccountInfo.verify|verify} messages.\n         * @function encode\n         * @memberof api.StoredKeyAccountInfo\n         * @static\n         * @param {api.IStoredKeyAccountInfo} message StoredKeyAccountInfo message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        StoredKeyAccountInfo.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.address != null && Object.hasOwnProperty.call(message, \"address\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);\n            if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);\n            if (message.derivationPath != null && Object.hasOwnProperty.call(message, \"derivationPath\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.derivationPath);\n            if (message.coin != null && Object.hasOwnProperty.call(message, \"coin\"))\n                writer.uint32(/* id 4, wireType 2 =*/34).string(message.coin);\n            if (message.extendedPublicKey != null && Object.hasOwnProperty.call(message, \"extendedPublicKey\"))\n                writer.uint32(/* id 5, wireType 2 =*/42).string(message.extendedPublicKey);\n            return writer;\n        };\n\n        /**\n         * Decodes a StoredKeyAccountInfo message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.StoredKeyAccountInfo\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.StoredKeyAccountInfo} StoredKeyAccountInfo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        StoredKeyAccountInfo.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.StoredKeyAccountInfo();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.address = reader.string();\n                    break;\n                case 2:\n                    message.name = reader.string();\n                    break;\n                case 3:\n                    message.derivationPath = reader.string();\n                    break;\n                case 4:\n                    message.coin = reader.string();\n                    break;\n                case 5:\n                    message.extendedPublicKey = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return StoredKeyAccountInfo;\n    })();\n\n    api.MWRequest = (function() {\n\n        /**\n         * Properties of a MWRequest.\n         * @memberof api\n         * @interface IMWRequest\n         * @property {api.ILoadStoredKeyParam|null} [param_load_stored_key] MWRequest param_load_stored_key\n         * @property {api.ICreateStoredKeyParam|null} [param_create_stored_key] MWRequest param_create_stored_key\n         * @property {api.IImportPrivateStoredKeyParam|null} [param_import_private_key] MWRequest param_import_private_key\n         * @property {api.IImportMnemonicStoredKeyParam|null} [param_import_mnemonic] MWRequest param_import_mnemonic\n         * @property {api.IImportJSONStoredKeyParam|null} [param_import_json] MWRequest param_import_json\n         * @property {api.ICreateStoredKeyNewAccountAtPathParam|null} [param_create_account_of_coin_at_path] MWRequest param_create_account_of_coin_at_path\n         * @property {api.IExportKeyStorePrivateKeyParam|null} [param_export_private_key] MWRequest param_export_private_key\n         * @property {api.IExportKeyStorePrivateKeyOfPathParam|null} [param_export_private_key_of_path] MWRequest param_export_private_key_of_path\n         * @property {api.IExportKeyStoreMnemonicParam|null} [param_export_mnemonic] MWRequest param_export_mnemonic\n         * @property {api.IExportKeyStoreJSONOfAddressParam|null} [param_export_key_store_json_of_address] MWRequest param_export_key_store_json_of_address\n         * @property {api.IExportKeyStoreJSONOfPathParam|null} [param_export_key_store_json_of_path] MWRequest param_export_key_store_json_of_path\n         * @property {api.IUpdateStoredKeyPasswordParam|null} [param_update_key_store_password] MWRequest param_update_key_store_password\n         * @property {api.ISignTransactionParam|null} [param_sign_transaction] MWRequest param_sign_transaction\n         * @property {api.IGetVersionParam|null} [param_get_version] MWRequest param_get_version\n         * @property {api.IValidateParam|null} [param_validation] MWRequest param_validation\n         * @property {api.IGetKeyStoreSupportImportTypeParam|null} [param_get_stored_key_import_type] MWRequest param_get_stored_key_import_type\n         * @property {api.IGetKeyStoreSupportExportTypeParam|null} [param_get_stored_key_export_type] MWRequest param_get_stored_key_export_type\n         * @property {api.IGenerateMnemonicParam|null} [param_generate_mnemonic] MWRequest param_generate_mnemonic\n         */\n\n        /**\n         * Constructs a new MWRequest.\n         * @memberof api\n         * @classdesc Represents a MWRequest.\n         * @implements IMWRequest\n         * @constructor\n         * @param {api.IMWRequest=} [properties] Properties to set\n         */\n        function MWRequest(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * MWRequest param_load_stored_key.\n         * @member {api.ILoadStoredKeyParam|null|undefined} param_load_stored_key\n         * @memberof api.MWRequest\n         * @instance\n         */\n        MWRequest.prototype.param_load_stored_key = null;\n\n        /**\n         * MWRequest param_create_stored_key.\n         * @member {api.ICreateStoredKeyParam|null|undefined} param_create_stored_key\n         * @memberof api.MWRequest\n         * @instance\n         */\n        MWRequest.prototype.param_create_stored_key = null;\n\n        /**\n         * MWRequest param_import_private_key.\n         * @member {api.IImportPrivateStoredKeyParam|null|undefined} param_import_private_key\n         * @memberof api.MWRequest\n         * @instance\n         */\n        MWRequest.prototype.param_import_private_key = null;\n\n        /**\n         * MWRequest param_import_mnemonic.\n         * @member {api.IImportMnemonicStoredKeyParam|null|undefined} param_import_mnemonic\n         * @memberof api.MWRequest\n         * @instance\n         */\n        MWRequest.prototype.param_import_mnemonic = null;\n\n        /**\n         * MWRequest param_import_json.\n         * @member {api.IImportJSONStoredKeyParam|null|undefined} param_import_json\n         * @memberof api.MWRequest\n         * @instance\n         */\n        MWRequest.prototype.param_import_json = null;\n\n        /**\n         * MWRequest param_create_account_of_coin_at_path.\n         * @member {api.ICreateStoredKeyNewAccountAtPathParam|null|undefined} param_create_account_of_coin_at_path\n         * @memberof api.MWRequest\n         * @instance\n         */\n        MWRequest.prototype.param_create_account_of_coin_at_path = null;\n\n        /**\n         * MWRequest param_export_private_key.\n         * @member {api.IExportKeyStorePrivateKeyParam|null|undefined} param_export_private_key\n         * @memberof api.MWRequest\n         * @instance\n         */\n        MWRequest.prototype.param_export_private_key = null;\n\n        /**\n         * MWRequest param_export_private_key_of_path.\n         * @member {api.IExportKeyStorePrivateKeyOfPathParam|null|undefined} param_export_private_key_of_path\n         * @memberof api.MWRequest\n         * @instance\n         */\n        MWRequest.prototype.param_export_private_key_of_path = null;\n\n        /**\n         * MWRequest param_export_mnemonic.\n         * @member {api.IExportKeyStoreMnemonicParam|null|undefined} param_export_mnemonic\n         * @memberof api.MWRequest\n         * @instance\n         */\n        MWRequest.prototype.param_export_mnemonic = null;\n\n        /**\n         * MWRequest param_export_key_store_json_of_address.\n         * @member {api.IExportKeyStoreJSONOfAddressParam|null|undefined} param_export_key_store_json_of_address\n         * @memberof api.MWRequest\n         * @instance\n         */\n        MWRequest.prototype.param_export_key_store_json_of_address = null;\n\n        /**\n         * MWRequest param_export_key_store_json_of_path.\n         * @member {api.IExportKeyStoreJSONOfPathParam|null|undefined} param_export_key_store_json_of_path\n         * @memberof api.MWRequest\n         * @instance\n         */\n        MWRequest.prototype.param_export_key_store_json_of_path = null;\n\n        /**\n         * MWRequest param_update_key_store_password.\n         * @member {api.IUpdateStoredKeyPasswordParam|null|undefined} param_update_key_store_password\n         * @memberof api.MWRequest\n         * @instance\n         */\n        MWRequest.prototype.param_update_key_store_password = null;\n\n        /**\n         * MWRequest param_sign_transaction.\n         * @member {api.ISignTransactionParam|null|undefined} param_sign_transaction\n         * @memberof api.MWRequest\n         * @instance\n         */\n        MWRequest.prototype.param_sign_transaction = null;\n\n        /**\n         * MWRequest param_get_version.\n         * @member {api.IGetVersionParam|null|undefined} param_get_version\n         * @memberof api.MWRequest\n         * @instance\n         */\n        MWRequest.prototype.param_get_version = null;\n\n        /**\n         * MWRequest param_validation.\n         * @member {api.IValidateParam|null|undefined} param_validation\n         * @memberof api.MWRequest\n         * @instance\n         */\n        MWRequest.prototype.param_validation = null;\n\n        /**\n         * MWRequest param_get_stored_key_import_type.\n         * @member {api.IGetKeyStoreSupportImportTypeParam|null|undefined} param_get_stored_key_import_type\n         * @memberof api.MWRequest\n         * @instance\n         */\n        MWRequest.prototype.param_get_stored_key_import_type = null;\n\n        /**\n         * MWRequest param_get_stored_key_export_type.\n         * @member {api.IGetKeyStoreSupportExportTypeParam|null|undefined} param_get_stored_key_export_type\n         * @memberof api.MWRequest\n         * @instance\n         */\n        MWRequest.prototype.param_get_stored_key_export_type = null;\n\n        /**\n         * MWRequest param_generate_mnemonic.\n         * @member {api.IGenerateMnemonicParam|null|undefined} param_generate_mnemonic\n         * @memberof api.MWRequest\n         * @instance\n         */\n        MWRequest.prototype.param_generate_mnemonic = null;\n\n        // OneOf field names bound to virtual getters and setters\n        let $oneOfFields;\n\n        /**\n         * MWRequest request.\n         * @member {\"param_load_stored_key\"|\"param_create_stored_key\"|\"param_import_private_key\"|\"param_import_mnemonic\"|\"param_import_json\"|\"param_create_account_of_coin_at_path\"|\"param_export_private_key\"|\"param_export_private_key_of_path\"|\"param_export_mnemonic\"|\"param_export_key_store_json_of_address\"|\"param_export_key_store_json_of_path\"|\"param_update_key_store_password\"|\"param_sign_transaction\"|\"param_get_version\"|\"param_validation\"|\"param_get_stored_key_import_type\"|\"param_get_stored_key_export_type\"|\"param_generate_mnemonic\"|undefined} request\n         * @memberof api.MWRequest\n         * @instance\n         */\n        Object.defineProperty(MWRequest.prototype, \"request\", {\n            get: $util.oneOfGetter($oneOfFields = [\"param_load_stored_key\", \"param_create_stored_key\", \"param_import_private_key\", \"param_import_mnemonic\", \"param_import_json\", \"param_create_account_of_coin_at_path\", \"param_export_private_key\", \"param_export_private_key_of_path\", \"param_export_mnemonic\", \"param_export_key_store_json_of_address\", \"param_export_key_store_json_of_path\", \"param_update_key_store_password\", \"param_sign_transaction\", \"param_get_version\", \"param_validation\", \"param_get_stored_key_import_type\", \"param_get_stored_key_export_type\", \"param_generate_mnemonic\"]),\n            set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Encodes the specified MWRequest message. Does not implicitly {@link api.MWRequest.verify|verify} messages.\n         * @function encode\n         * @memberof api.MWRequest\n         * @static\n         * @param {api.IMWRequest} message MWRequest message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        MWRequest.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.param_load_stored_key != null && Object.hasOwnProperty.call(message, \"param_load_stored_key\"))\n                $root.api.LoadStoredKeyParam.encode(message.param_load_stored_key, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.param_create_stored_key != null && Object.hasOwnProperty.call(message, \"param_create_stored_key\"))\n                $root.api.CreateStoredKeyParam.encode(message.param_create_stored_key, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.param_import_private_key != null && Object.hasOwnProperty.call(message, \"param_import_private_key\"))\n                $root.api.ImportPrivateStoredKeyParam.encode(message.param_import_private_key, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            if (message.param_import_mnemonic != null && Object.hasOwnProperty.call(message, \"param_import_mnemonic\"))\n                $root.api.ImportMnemonicStoredKeyParam.encode(message.param_import_mnemonic, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n            if (message.param_import_json != null && Object.hasOwnProperty.call(message, \"param_import_json\"))\n                $root.api.ImportJSONStoredKeyParam.encode(message.param_import_json, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n            if (message.param_create_account_of_coin_at_path != null && Object.hasOwnProperty.call(message, \"param_create_account_of_coin_at_path\"))\n                $root.api.CreateStoredKeyNewAccountAtPathParam.encode(message.param_create_account_of_coin_at_path, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();\n            if (message.param_export_private_key != null && Object.hasOwnProperty.call(message, \"param_export_private_key\"))\n                $root.api.ExportKeyStorePrivateKeyParam.encode(message.param_export_private_key, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();\n            if (message.param_export_private_key_of_path != null && Object.hasOwnProperty.call(message, \"param_export_private_key_of_path\"))\n                $root.api.ExportKeyStorePrivateKeyOfPathParam.encode(message.param_export_private_key_of_path, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();\n            if (message.param_export_mnemonic != null && Object.hasOwnProperty.call(message, \"param_export_mnemonic\"))\n                $root.api.ExportKeyStoreMnemonicParam.encode(message.param_export_mnemonic, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();\n            if (message.param_export_key_store_json_of_address != null && Object.hasOwnProperty.call(message, \"param_export_key_store_json_of_address\"))\n                $root.api.ExportKeyStoreJSONOfAddressParam.encode(message.param_export_key_store_json_of_address, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();\n            if (message.param_export_key_store_json_of_path != null && Object.hasOwnProperty.call(message, \"param_export_key_store_json_of_path\"))\n                $root.api.ExportKeyStoreJSONOfPathParam.encode(message.param_export_key_store_json_of_path, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();\n            if (message.param_update_key_store_password != null && Object.hasOwnProperty.call(message, \"param_update_key_store_password\"))\n                $root.api.UpdateStoredKeyPasswordParam.encode(message.param_update_key_store_password, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();\n            if (message.param_sign_transaction != null && Object.hasOwnProperty.call(message, \"param_sign_transaction\"))\n                $root.api.SignTransactionParam.encode(message.param_sign_transaction, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();\n            if (message.param_get_version != null && Object.hasOwnProperty.call(message, \"param_get_version\"))\n                $root.api.GetVersionParam.encode(message.param_get_version, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();\n            if (message.param_validation != null && Object.hasOwnProperty.call(message, \"param_validation\"))\n                $root.api.ValidateParam.encode(message.param_validation, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();\n            if (message.param_get_stored_key_import_type != null && Object.hasOwnProperty.call(message, \"param_get_stored_key_import_type\"))\n                $root.api.GetKeyStoreSupportImportTypeParam.encode(message.param_get_stored_key_import_type, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();\n            if (message.param_get_stored_key_export_type != null && Object.hasOwnProperty.call(message, \"param_get_stored_key_export_type\"))\n                $root.api.GetKeyStoreSupportExportTypeParam.encode(message.param_get_stored_key_export_type, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();\n            if (message.param_generate_mnemonic != null && Object.hasOwnProperty.call(message, \"param_generate_mnemonic\"))\n                $root.api.GenerateMnemonicParam.encode(message.param_generate_mnemonic, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Decodes a MWRequest message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.MWRequest\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.MWRequest} MWRequest\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        MWRequest.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.MWRequest();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.param_load_stored_key = $root.api.LoadStoredKeyParam.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.param_create_stored_key = $root.api.CreateStoredKeyParam.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.param_import_private_key = $root.api.ImportPrivateStoredKeyParam.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.param_import_mnemonic = $root.api.ImportMnemonicStoredKeyParam.decode(reader, reader.uint32());\n                    break;\n                case 5:\n                    message.param_import_json = $root.api.ImportJSONStoredKeyParam.decode(reader, reader.uint32());\n                    break;\n                case 10:\n                    message.param_create_account_of_coin_at_path = $root.api.CreateStoredKeyNewAccountAtPathParam.decode(reader, reader.uint32());\n                    break;\n                case 13:\n                    message.param_export_private_key = $root.api.ExportKeyStorePrivateKeyParam.decode(reader, reader.uint32());\n                    break;\n                case 14:\n                    message.param_export_private_key_of_path = $root.api.ExportKeyStorePrivateKeyOfPathParam.decode(reader, reader.uint32());\n                    break;\n                case 15:\n                    message.param_export_mnemonic = $root.api.ExportKeyStoreMnemonicParam.decode(reader, reader.uint32());\n                    break;\n                case 16:\n                    message.param_export_key_store_json_of_address = $root.api.ExportKeyStoreJSONOfAddressParam.decode(reader, reader.uint32());\n                    break;\n                case 17:\n                    message.param_export_key_store_json_of_path = $root.api.ExportKeyStoreJSONOfPathParam.decode(reader, reader.uint32());\n                    break;\n                case 18:\n                    message.param_update_key_store_password = $root.api.UpdateStoredKeyPasswordParam.decode(reader, reader.uint32());\n                    break;\n                case 20:\n                    message.param_sign_transaction = $root.api.SignTransactionParam.decode(reader, reader.uint32());\n                    break;\n                case 21:\n                    message.param_get_version = $root.api.GetVersionParam.decode(reader, reader.uint32());\n                    break;\n                case 22:\n                    message.param_validation = $root.api.ValidateParam.decode(reader, reader.uint32());\n                    break;\n                case 23:\n                    message.param_get_stored_key_import_type = $root.api.GetKeyStoreSupportImportTypeParam.decode(reader, reader.uint32());\n                    break;\n                case 24:\n                    message.param_get_stored_key_export_type = $root.api.GetKeyStoreSupportExportTypeParam.decode(reader, reader.uint32());\n                    break;\n                case 25:\n                    message.param_generate_mnemonic = $root.api.GenerateMnemonicParam.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return MWRequest;\n    })();\n\n    api.MWResponse = (function() {\n\n        /**\n         * Properties of a MWResponse.\n         * @memberof api\n         * @interface IMWResponse\n         * @property {api.IMWResponseError|null} [error] MWResponse error\n         * @property {api.ILoadStoredKeyResp|null} [resp_load_stored_key] MWResponse resp_load_stored_key\n         * @property {api.ICreateStoredKeyResp|null} [resp_create_stored_key] MWResponse resp_create_stored_key\n         * @property {api.IImportPrivateStoredKeyResp|null} [resp_import_private_key] MWResponse resp_import_private_key\n         * @property {api.IImportMnemonicStoredKeyResp|null} [resp_import_mnemonic] MWResponse resp_import_mnemonic\n         * @property {api.IImportJSONStoredKeyResp|null} [resp_import_json] MWResponse resp_import_json\n         * @property {api.ICreateStoredKeyNewAccountAtPathResp|null} [resp_create_account_of_coin_at_path] MWResponse resp_create_account_of_coin_at_path\n         * @property {api.IExportKeyStorePrivateKeyResp|null} [resp_export_private_key] MWResponse resp_export_private_key\n         * @property {api.IExportKeyStoreMnemonicResp|null} [resp_export_mnemonic] MWResponse resp_export_mnemonic\n         * @property {api.IExportKeyStoreJSONResp|null} [resp_export_key_store_json] MWResponse resp_export_key_store_json\n         * @property {api.IUpdateStoredKeyPasswordResp|null} [resp_update_key_store_password] MWResponse resp_update_key_store_password\n         * @property {api.ISignTransactionResp|null} [resp_sign_transaction] MWResponse resp_sign_transaction\n         * @property {api.IGetVersionResp|null} [resp_get_version] MWResponse resp_get_version\n         * @property {api.IValidateResp|null} [resp_validate] MWResponse resp_validate\n         * @property {api.IGetKeyStoreSupportImportTypeResp|null} [resp_get_stored_key_import_type] MWResponse resp_get_stored_key_import_type\n         * @property {api.IGetKeyStoreSupportExportTypeResp|null} [resp_get_stored_key_export_type] MWResponse resp_get_stored_key_export_type\n         * @property {api.IGenerateMnemonicResp|null} [resp_generate_mnemonic] MWResponse resp_generate_mnemonic\n         */\n\n        /**\n         * Constructs a new MWResponse.\n         * @memberof api\n         * @classdesc Represents a MWResponse.\n         * @implements IMWResponse\n         * @constructor\n         * @param {api.IMWResponse=} [properties] Properties to set\n         */\n        function MWResponse(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * MWResponse error.\n         * @member {api.IMWResponseError|null|undefined} error\n         * @memberof api.MWResponse\n         * @instance\n         */\n        MWResponse.prototype.error = null;\n\n        /**\n         * MWResponse resp_load_stored_key.\n         * @member {api.ILoadStoredKeyResp|null|undefined} resp_load_stored_key\n         * @memberof api.MWResponse\n         * @instance\n         */\n        MWResponse.prototype.resp_load_stored_key = null;\n\n        /**\n         * MWResponse resp_create_stored_key.\n         * @member {api.ICreateStoredKeyResp|null|undefined} resp_create_stored_key\n         * @memberof api.MWResponse\n         * @instance\n         */\n        MWResponse.prototype.resp_create_stored_key = null;\n\n        /**\n         * MWResponse resp_import_private_key.\n         * @member {api.IImportPrivateStoredKeyResp|null|undefined} resp_import_private_key\n         * @memberof api.MWResponse\n         * @instance\n         */\n        MWResponse.prototype.resp_import_private_key = null;\n\n        /**\n         * MWResponse resp_import_mnemonic.\n         * @member {api.IImportMnemonicStoredKeyResp|null|undefined} resp_import_mnemonic\n         * @memberof api.MWResponse\n         * @instance\n         */\n        MWResponse.prototype.resp_import_mnemonic = null;\n\n        /**\n         * MWResponse resp_import_json.\n         * @member {api.IImportJSONStoredKeyResp|null|undefined} resp_import_json\n         * @memberof api.MWResponse\n         * @instance\n         */\n        MWResponse.prototype.resp_import_json = null;\n\n        /**\n         * MWResponse resp_create_account_of_coin_at_path.\n         * @member {api.ICreateStoredKeyNewAccountAtPathResp|null|undefined} resp_create_account_of_coin_at_path\n         * @memberof api.MWResponse\n         * @instance\n         */\n        MWResponse.prototype.resp_create_account_of_coin_at_path = null;\n\n        /**\n         * MWResponse resp_export_private_key.\n         * @member {api.IExportKeyStorePrivateKeyResp|null|undefined} resp_export_private_key\n         * @memberof api.MWResponse\n         * @instance\n         */\n        MWResponse.prototype.resp_export_private_key = null;\n\n        /**\n         * MWResponse resp_export_mnemonic.\n         * @member {api.IExportKeyStoreMnemonicResp|null|undefined} resp_export_mnemonic\n         * @memberof api.MWResponse\n         * @instance\n         */\n        MWResponse.prototype.resp_export_mnemonic = null;\n\n        /**\n         * MWResponse resp_export_key_store_json.\n         * @member {api.IExportKeyStoreJSONResp|null|undefined} resp_export_key_store_json\n         * @memberof api.MWResponse\n         * @instance\n         */\n        MWResponse.prototype.resp_export_key_store_json = null;\n\n        /**\n         * MWResponse resp_update_key_store_password.\n         * @member {api.IUpdateStoredKeyPasswordResp|null|undefined} resp_update_key_store_password\n         * @memberof api.MWResponse\n         * @instance\n         */\n        MWResponse.prototype.resp_update_key_store_password = null;\n\n        /**\n         * MWResponse resp_sign_transaction.\n         * @member {api.ISignTransactionResp|null|undefined} resp_sign_transaction\n         * @memberof api.MWResponse\n         * @instance\n         */\n        MWResponse.prototype.resp_sign_transaction = null;\n\n        /**\n         * MWResponse resp_get_version.\n         * @member {api.IGetVersionResp|null|undefined} resp_get_version\n         * @memberof api.MWResponse\n         * @instance\n         */\n        MWResponse.prototype.resp_get_version = null;\n\n        /**\n         * MWResponse resp_validate.\n         * @member {api.IValidateResp|null|undefined} resp_validate\n         * @memberof api.MWResponse\n         * @instance\n         */\n        MWResponse.prototype.resp_validate = null;\n\n        /**\n         * MWResponse resp_get_stored_key_import_type.\n         * @member {api.IGetKeyStoreSupportImportTypeResp|null|undefined} resp_get_stored_key_import_type\n         * @memberof api.MWResponse\n         * @instance\n         */\n        MWResponse.prototype.resp_get_stored_key_import_type = null;\n\n        /**\n         * MWResponse resp_get_stored_key_export_type.\n         * @member {api.IGetKeyStoreSupportExportTypeResp|null|undefined} resp_get_stored_key_export_type\n         * @memberof api.MWResponse\n         * @instance\n         */\n        MWResponse.prototype.resp_get_stored_key_export_type = null;\n\n        /**\n         * MWResponse resp_generate_mnemonic.\n         * @member {api.IGenerateMnemonicResp|null|undefined} resp_generate_mnemonic\n         * @memberof api.MWResponse\n         * @instance\n         */\n        MWResponse.prototype.resp_generate_mnemonic = null;\n\n        // OneOf field names bound to virtual getters and setters\n        let $oneOfFields;\n\n        /**\n         * MWResponse response.\n         * @member {\"error\"|\"resp_load_stored_key\"|\"resp_create_stored_key\"|\"resp_import_private_key\"|\"resp_import_mnemonic\"|\"resp_import_json\"|\"resp_create_account_of_coin_at_path\"|\"resp_export_private_key\"|\"resp_export_mnemonic\"|\"resp_export_key_store_json\"|\"resp_update_key_store_password\"|\"resp_sign_transaction\"|\"resp_get_version\"|\"resp_validate\"|\"resp_get_stored_key_import_type\"|\"resp_get_stored_key_export_type\"|\"resp_generate_mnemonic\"|undefined} response\n         * @memberof api.MWResponse\n         * @instance\n         */\n        Object.defineProperty(MWResponse.prototype, \"response\", {\n            get: $util.oneOfGetter($oneOfFields = [\"error\", \"resp_load_stored_key\", \"resp_create_stored_key\", \"resp_import_private_key\", \"resp_import_mnemonic\", \"resp_import_json\", \"resp_create_account_of_coin_at_path\", \"resp_export_private_key\", \"resp_export_mnemonic\", \"resp_export_key_store_json\", \"resp_update_key_store_password\", \"resp_sign_transaction\", \"resp_get_version\", \"resp_validate\", \"resp_get_stored_key_import_type\", \"resp_get_stored_key_export_type\", \"resp_generate_mnemonic\"]),\n            set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Encodes the specified MWResponse message. Does not implicitly {@link api.MWResponse.verify|verify} messages.\n         * @function encode\n         * @memberof api.MWResponse\n         * @static\n         * @param {api.IMWResponse} message MWResponse message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        MWResponse.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.error != null && Object.hasOwnProperty.call(message, \"error\"))\n                $root.api.MWResponseError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.resp_load_stored_key != null && Object.hasOwnProperty.call(message, \"resp_load_stored_key\"))\n                $root.api.LoadStoredKeyResp.encode(message.resp_load_stored_key, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.resp_create_stored_key != null && Object.hasOwnProperty.call(message, \"resp_create_stored_key\"))\n                $root.api.CreateStoredKeyResp.encode(message.resp_create_stored_key, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            if (message.resp_import_private_key != null && Object.hasOwnProperty.call(message, \"resp_import_private_key\"))\n                $root.api.ImportPrivateStoredKeyResp.encode(message.resp_import_private_key, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n            if (message.resp_import_mnemonic != null && Object.hasOwnProperty.call(message, \"resp_import_mnemonic\"))\n                $root.api.ImportMnemonicStoredKeyResp.encode(message.resp_import_mnemonic, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n            if (message.resp_import_json != null && Object.hasOwnProperty.call(message, \"resp_import_json\"))\n                $root.api.ImportJSONStoredKeyResp.encode(message.resp_import_json, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n            if (message.resp_create_account_of_coin_at_path != null && Object.hasOwnProperty.call(message, \"resp_create_account_of_coin_at_path\"))\n                $root.api.CreateStoredKeyNewAccountAtPathResp.encode(message.resp_create_account_of_coin_at_path, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();\n            if (message.resp_export_private_key != null && Object.hasOwnProperty.call(message, \"resp_export_private_key\"))\n                $root.api.ExportKeyStorePrivateKeyResp.encode(message.resp_export_private_key, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();\n            if (message.resp_export_mnemonic != null && Object.hasOwnProperty.call(message, \"resp_export_mnemonic\"))\n                $root.api.ExportKeyStoreMnemonicResp.encode(message.resp_export_mnemonic, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();\n            if (message.resp_export_key_store_json != null && Object.hasOwnProperty.call(message, \"resp_export_key_store_json\"))\n                $root.api.ExportKeyStoreJSONResp.encode(message.resp_export_key_store_json, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();\n            if (message.resp_update_key_store_password != null && Object.hasOwnProperty.call(message, \"resp_update_key_store_password\"))\n                $root.api.UpdateStoredKeyPasswordResp.encode(message.resp_update_key_store_password, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();\n            if (message.resp_sign_transaction != null && Object.hasOwnProperty.call(message, \"resp_sign_transaction\"))\n                $root.api.SignTransactionResp.encode(message.resp_sign_transaction, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();\n            if (message.resp_get_version != null && Object.hasOwnProperty.call(message, \"resp_get_version\"))\n                $root.api.GetVersionResp.encode(message.resp_get_version, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();\n            if (message.resp_validate != null && Object.hasOwnProperty.call(message, \"resp_validate\"))\n                $root.api.ValidateResp.encode(message.resp_validate, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();\n            if (message.resp_get_stored_key_import_type != null && Object.hasOwnProperty.call(message, \"resp_get_stored_key_import_type\"))\n                $root.api.GetKeyStoreSupportImportTypeResp.encode(message.resp_get_stored_key_import_type, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();\n            if (message.resp_get_stored_key_export_type != null && Object.hasOwnProperty.call(message, \"resp_get_stored_key_export_type\"))\n                $root.api.GetKeyStoreSupportExportTypeResp.encode(message.resp_get_stored_key_export_type, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();\n            if (message.resp_generate_mnemonic != null && Object.hasOwnProperty.call(message, \"resp_generate_mnemonic\"))\n                $root.api.GenerateMnemonicResp.encode(message.resp_generate_mnemonic, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Decodes a MWResponse message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.MWResponse\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.MWResponse} MWResponse\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        MWResponse.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.MWResponse();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.error = $root.api.MWResponseError.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.resp_load_stored_key = $root.api.LoadStoredKeyResp.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.resp_create_stored_key = $root.api.CreateStoredKeyResp.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.resp_import_private_key = $root.api.ImportPrivateStoredKeyResp.decode(reader, reader.uint32());\n                    break;\n                case 5:\n                    message.resp_import_mnemonic = $root.api.ImportMnemonicStoredKeyResp.decode(reader, reader.uint32());\n                    break;\n                case 6:\n                    message.resp_import_json = $root.api.ImportJSONStoredKeyResp.decode(reader, reader.uint32());\n                    break;\n                case 11:\n                    message.resp_create_account_of_coin_at_path = $root.api.CreateStoredKeyNewAccountAtPathResp.decode(reader, reader.uint32());\n                    break;\n                case 14:\n                    message.resp_export_private_key = $root.api.ExportKeyStorePrivateKeyResp.decode(reader, reader.uint32());\n                    break;\n                case 15:\n                    message.resp_export_mnemonic = $root.api.ExportKeyStoreMnemonicResp.decode(reader, reader.uint32());\n                    break;\n                case 16:\n                    message.resp_export_key_store_json = $root.api.ExportKeyStoreJSONResp.decode(reader, reader.uint32());\n                    break;\n                case 17:\n                    message.resp_update_key_store_password = $root.api.UpdateStoredKeyPasswordResp.decode(reader, reader.uint32());\n                    break;\n                case 19:\n                    message.resp_sign_transaction = $root.api.SignTransactionResp.decode(reader, reader.uint32());\n                    break;\n                case 20:\n                    message.resp_get_version = $root.api.GetVersionResp.decode(reader, reader.uint32());\n                    break;\n                case 21:\n                    message.resp_validate = $root.api.ValidateResp.decode(reader, reader.uint32());\n                    break;\n                case 22:\n                    message.resp_get_stored_key_import_type = $root.api.GetKeyStoreSupportImportTypeResp.decode(reader, reader.uint32());\n                    break;\n                case 23:\n                    message.resp_get_stored_key_export_type = $root.api.GetKeyStoreSupportExportTypeResp.decode(reader, reader.uint32());\n                    break;\n                case 24:\n                    message.resp_generate_mnemonic = $root.api.GenerateMnemonicResp.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return MWResponse;\n    })();\n\n    api.MWResponseError = (function() {\n\n        /**\n         * Properties of a MWResponseError.\n         * @memberof api\n         * @interface IMWResponseError\n         * @property {string|null} [errorCode] MWResponseError errorCode\n         * @property {string|null} [errorMsg] MWResponseError errorMsg\n         */\n\n        /**\n         * Constructs a new MWResponseError.\n         * @memberof api\n         * @classdesc Represents a MWResponseError.\n         * @implements IMWResponseError\n         * @constructor\n         * @param {api.IMWResponseError=} [properties] Properties to set\n         */\n        function MWResponseError(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * MWResponseError errorCode.\n         * @member {string} errorCode\n         * @memberof api.MWResponseError\n         * @instance\n         */\n        MWResponseError.prototype.errorCode = \"\";\n\n        /**\n         * MWResponseError errorMsg.\n         * @member {string} errorMsg\n         * @memberof api.MWResponseError\n         * @instance\n         */\n        MWResponseError.prototype.errorMsg = \"\";\n\n        /**\n         * Encodes the specified MWResponseError message. Does not implicitly {@link api.MWResponseError.verify|verify} messages.\n         * @function encode\n         * @memberof api.MWResponseError\n         * @static\n         * @param {api.IMWResponseError} message MWResponseError message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        MWResponseError.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.errorCode != null && Object.hasOwnProperty.call(message, \"errorCode\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.errorCode);\n            if (message.errorMsg != null && Object.hasOwnProperty.call(message, \"errorMsg\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.errorMsg);\n            return writer;\n        };\n\n        /**\n         * Decodes a MWResponseError message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.MWResponseError\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.MWResponseError} MWResponseError\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        MWResponseError.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.MWResponseError();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.errorCode = reader.string();\n                    break;\n                case 2:\n                    message.errorMsg = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return MWResponseError;\n    })();\n\n    api.GetVersionParam = (function() {\n\n        /**\n         * Properties of a GetVersionParam.\n         * @memberof api\n         * @interface IGetVersionParam\n         */\n\n        /**\n         * Constructs a new GetVersionParam.\n         * @memberof api\n         * @classdesc Represents a GetVersionParam.\n         * @implements IGetVersionParam\n         * @constructor\n         * @param {api.IGetVersionParam=} [properties] Properties to set\n         */\n        function GetVersionParam(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * Encodes the specified GetVersionParam message. Does not implicitly {@link api.GetVersionParam.verify|verify} messages.\n         * @function encode\n         * @memberof api.GetVersionParam\n         * @static\n         * @param {api.IGetVersionParam} message GetVersionParam message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        GetVersionParam.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            return writer;\n        };\n\n        /**\n         * Decodes a GetVersionParam message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.GetVersionParam\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.GetVersionParam} GetVersionParam\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        GetVersionParam.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.GetVersionParam();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return GetVersionParam;\n    })();\n\n    api.GetVersionResp = (function() {\n\n        /**\n         * Properties of a GetVersionResp.\n         * @memberof api\n         * @interface IGetVersionResp\n         * @property {string|null} [version] GetVersionResp version\n         */\n\n        /**\n         * Constructs a new GetVersionResp.\n         * @memberof api\n         * @classdesc Represents a GetVersionResp.\n         * @implements IGetVersionResp\n         * @constructor\n         * @param {api.IGetVersionResp=} [properties] Properties to set\n         */\n        function GetVersionResp(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * GetVersionResp version.\n         * @member {string} version\n         * @memberof api.GetVersionResp\n         * @instance\n         */\n        GetVersionResp.prototype.version = \"\";\n\n        /**\n         * Encodes the specified GetVersionResp message. Does not implicitly {@link api.GetVersionResp.verify|verify} messages.\n         * @function encode\n         * @memberof api.GetVersionResp\n         * @static\n         * @param {api.IGetVersionResp} message GetVersionResp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        GetVersionResp.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.version != null && Object.hasOwnProperty.call(message, \"version\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.version);\n            return writer;\n        };\n\n        /**\n         * Decodes a GetVersionResp message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.GetVersionResp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.GetVersionResp} GetVersionResp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        GetVersionResp.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.GetVersionResp();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.version = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return GetVersionResp;\n    })();\n\n    api.GetKeyStoreSupportExportTypeParam = (function() {\n\n        /**\n         * Properties of a GetKeyStoreSupportExportTypeParam.\n         * @memberof api\n         * @interface IGetKeyStoreSupportExportTypeParam\n         * @property {api.Coin|null} [coin] GetKeyStoreSupportExportTypeParam coin\n         */\n\n        /**\n         * Constructs a new GetKeyStoreSupportExportTypeParam.\n         * @memberof api\n         * @classdesc Represents a GetKeyStoreSupportExportTypeParam.\n         * @implements IGetKeyStoreSupportExportTypeParam\n         * @constructor\n         * @param {api.IGetKeyStoreSupportExportTypeParam=} [properties] Properties to set\n         */\n        function GetKeyStoreSupportExportTypeParam(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * GetKeyStoreSupportExportTypeParam coin.\n         * @member {api.Coin} coin\n         * @memberof api.GetKeyStoreSupportExportTypeParam\n         * @instance\n         */\n        GetKeyStoreSupportExportTypeParam.prototype.coin = 0;\n\n        /**\n         * Encodes the specified GetKeyStoreSupportExportTypeParam message. Does not implicitly {@link api.GetKeyStoreSupportExportTypeParam.verify|verify} messages.\n         * @function encode\n         * @memberof api.GetKeyStoreSupportExportTypeParam\n         * @static\n         * @param {api.IGetKeyStoreSupportExportTypeParam} message GetKeyStoreSupportExportTypeParam message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        GetKeyStoreSupportExportTypeParam.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.coin != null && Object.hasOwnProperty.call(message, \"coin\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.coin);\n            return writer;\n        };\n\n        /**\n         * Decodes a GetKeyStoreSupportExportTypeParam message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.GetKeyStoreSupportExportTypeParam\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.GetKeyStoreSupportExportTypeParam} GetKeyStoreSupportExportTypeParam\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        GetKeyStoreSupportExportTypeParam.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.GetKeyStoreSupportExportTypeParam();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.coin = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return GetKeyStoreSupportExportTypeParam;\n    })();\n\n    api.GetKeyStoreSupportExportTypeResp = (function() {\n\n        /**\n         * Properties of a GetKeyStoreSupportExportTypeResp.\n         * @memberof api\n         * @interface IGetKeyStoreSupportExportTypeResp\n         * @property {Array.<api.StoredKeyImportType>|null} [type] GetKeyStoreSupportExportTypeResp type\n         */\n\n        /**\n         * Constructs a new GetKeyStoreSupportExportTypeResp.\n         * @memberof api\n         * @classdesc Represents a GetKeyStoreSupportExportTypeResp.\n         * @implements IGetKeyStoreSupportExportTypeResp\n         * @constructor\n         * @param {api.IGetKeyStoreSupportExportTypeResp=} [properties] Properties to set\n         */\n        function GetKeyStoreSupportExportTypeResp(properties) {\n            this.type = [];\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * GetKeyStoreSupportExportTypeResp type.\n         * @member {Array.<api.StoredKeyImportType>} type\n         * @memberof api.GetKeyStoreSupportExportTypeResp\n         * @instance\n         */\n        GetKeyStoreSupportExportTypeResp.prototype.type = $util.emptyArray;\n\n        /**\n         * Encodes the specified GetKeyStoreSupportExportTypeResp message. Does not implicitly {@link api.GetKeyStoreSupportExportTypeResp.verify|verify} messages.\n         * @function encode\n         * @memberof api.GetKeyStoreSupportExportTypeResp\n         * @static\n         * @param {api.IGetKeyStoreSupportExportTypeResp} message GetKeyStoreSupportExportTypeResp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        GetKeyStoreSupportExportTypeResp.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.type != null && message.type.length) {\n                writer.uint32(/* id 1, wireType 2 =*/10).fork();\n                for (let i = 0; i < message.type.length; ++i)\n                    writer.int32(message.type[i]);\n                writer.ldelim();\n            }\n            return writer;\n        };\n\n        /**\n         * Decodes a GetKeyStoreSupportExportTypeResp message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.GetKeyStoreSupportExportTypeResp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.GetKeyStoreSupportExportTypeResp} GetKeyStoreSupportExportTypeResp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        GetKeyStoreSupportExportTypeResp.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.GetKeyStoreSupportExportTypeResp();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.type && message.type.length))\n                        message.type = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.type.push(reader.int32());\n                    } else\n                        message.type.push(reader.int32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return GetKeyStoreSupportExportTypeResp;\n    })();\n\n    api.ExportKeyStorePrivateKeyParam = (function() {\n\n        /**\n         * Properties of an ExportKeyStorePrivateKeyParam.\n         * @memberof api\n         * @interface IExportKeyStorePrivateKeyParam\n         * @property {Uint8Array|null} [StoredKeyData] ExportKeyStorePrivateKeyParam StoredKeyData\n         * @property {string|null} [password] ExportKeyStorePrivateKeyParam password\n         * @property {api.Coin|null} [coin] ExportKeyStorePrivateKeyParam coin\n         */\n\n        /**\n         * Constructs a new ExportKeyStorePrivateKeyParam.\n         * @memberof api\n         * @classdesc Represents an ExportKeyStorePrivateKeyParam.\n         * @implements IExportKeyStorePrivateKeyParam\n         * @constructor\n         * @param {api.IExportKeyStorePrivateKeyParam=} [properties] Properties to set\n         */\n        function ExportKeyStorePrivateKeyParam(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ExportKeyStorePrivateKeyParam StoredKeyData.\n         * @member {Uint8Array} StoredKeyData\n         * @memberof api.ExportKeyStorePrivateKeyParam\n         * @instance\n         */\n        ExportKeyStorePrivateKeyParam.prototype.StoredKeyData = $util.newBuffer([]);\n\n        /**\n         * ExportKeyStorePrivateKeyParam password.\n         * @member {string} password\n         * @memberof api.ExportKeyStorePrivateKeyParam\n         * @instance\n         */\n        ExportKeyStorePrivateKeyParam.prototype.password = \"\";\n\n        /**\n         * ExportKeyStorePrivateKeyParam coin.\n         * @member {api.Coin} coin\n         * @memberof api.ExportKeyStorePrivateKeyParam\n         * @instance\n         */\n        ExportKeyStorePrivateKeyParam.prototype.coin = 0;\n\n        /**\n         * Encodes the specified ExportKeyStorePrivateKeyParam message. Does not implicitly {@link api.ExportKeyStorePrivateKeyParam.verify|verify} messages.\n         * @function encode\n         * @memberof api.ExportKeyStorePrivateKeyParam\n         * @static\n         * @param {api.IExportKeyStorePrivateKeyParam} message ExportKeyStorePrivateKeyParam message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ExportKeyStorePrivateKeyParam.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.StoredKeyData != null && Object.hasOwnProperty.call(message, \"StoredKeyData\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.StoredKeyData);\n            if (message.password != null && Object.hasOwnProperty.call(message, \"password\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);\n            if (message.coin != null && Object.hasOwnProperty.call(message, \"coin\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.coin);\n            return writer;\n        };\n\n        /**\n         * Decodes an ExportKeyStorePrivateKeyParam message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.ExportKeyStorePrivateKeyParam\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.ExportKeyStorePrivateKeyParam} ExportKeyStorePrivateKeyParam\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ExportKeyStorePrivateKeyParam.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ExportKeyStorePrivateKeyParam();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.StoredKeyData = reader.bytes();\n                    break;\n                case 2:\n                    message.password = reader.string();\n                    break;\n                case 3:\n                    message.coin = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return ExportKeyStorePrivateKeyParam;\n    })();\n\n    api.ExportKeyStorePrivateKeyOfPathParam = (function() {\n\n        /**\n         * Properties of an ExportKeyStorePrivateKeyOfPathParam.\n         * @memberof api\n         * @interface IExportKeyStorePrivateKeyOfPathParam\n         * @property {Uint8Array|null} [StoredKeyData] ExportKeyStorePrivateKeyOfPathParam StoredKeyData\n         * @property {string|null} [password] ExportKeyStorePrivateKeyOfPathParam password\n         * @property {api.Coin|null} [coin] ExportKeyStorePrivateKeyOfPathParam coin\n         * @property {string|null} [derivationPath] ExportKeyStorePrivateKeyOfPathParam derivationPath\n         */\n\n        /**\n         * Constructs a new ExportKeyStorePrivateKeyOfPathParam.\n         * @memberof api\n         * @classdesc Represents an ExportKeyStorePrivateKeyOfPathParam.\n         * @implements IExportKeyStorePrivateKeyOfPathParam\n         * @constructor\n         * @param {api.IExportKeyStorePrivateKeyOfPathParam=} [properties] Properties to set\n         */\n        function ExportKeyStorePrivateKeyOfPathParam(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ExportKeyStorePrivateKeyOfPathParam StoredKeyData.\n         * @member {Uint8Array} StoredKeyData\n         * @memberof api.ExportKeyStorePrivateKeyOfPathParam\n         * @instance\n         */\n        ExportKeyStorePrivateKeyOfPathParam.prototype.StoredKeyData = $util.newBuffer([]);\n\n        /**\n         * ExportKeyStorePrivateKeyOfPathParam password.\n         * @member {string} password\n         * @memberof api.ExportKeyStorePrivateKeyOfPathParam\n         * @instance\n         */\n        ExportKeyStorePrivateKeyOfPathParam.prototype.password = \"\";\n\n        /**\n         * ExportKeyStorePrivateKeyOfPathParam coin.\n         * @member {api.Coin} coin\n         * @memberof api.ExportKeyStorePrivateKeyOfPathParam\n         * @instance\n         */\n        ExportKeyStorePrivateKeyOfPathParam.prototype.coin = 0;\n\n        /**\n         * ExportKeyStorePrivateKeyOfPathParam derivationPath.\n         * @member {string} derivationPath\n         * @memberof api.ExportKeyStorePrivateKeyOfPathParam\n         * @instance\n         */\n        ExportKeyStorePrivateKeyOfPathParam.prototype.derivationPath = \"\";\n\n        /**\n         * Encodes the specified ExportKeyStorePrivateKeyOfPathParam message. Does not implicitly {@link api.ExportKeyStorePrivateKeyOfPathParam.verify|verify} messages.\n         * @function encode\n         * @memberof api.ExportKeyStorePrivateKeyOfPathParam\n         * @static\n         * @param {api.IExportKeyStorePrivateKeyOfPathParam} message ExportKeyStorePrivateKeyOfPathParam message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ExportKeyStorePrivateKeyOfPathParam.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.StoredKeyData != null && Object.hasOwnProperty.call(message, \"StoredKeyData\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.StoredKeyData);\n            if (message.password != null && Object.hasOwnProperty.call(message, \"password\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);\n            if (message.coin != null && Object.hasOwnProperty.call(message, \"coin\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.coin);\n            if (message.derivationPath != null && Object.hasOwnProperty.call(message, \"derivationPath\"))\n                writer.uint32(/* id 4, wireType 2 =*/34).string(message.derivationPath);\n            return writer;\n        };\n\n        /**\n         * Decodes an ExportKeyStorePrivateKeyOfPathParam message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.ExportKeyStorePrivateKeyOfPathParam\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.ExportKeyStorePrivateKeyOfPathParam} ExportKeyStorePrivateKeyOfPathParam\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ExportKeyStorePrivateKeyOfPathParam.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ExportKeyStorePrivateKeyOfPathParam();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.StoredKeyData = reader.bytes();\n                    break;\n                case 2:\n                    message.password = reader.string();\n                    break;\n                case 3:\n                    message.coin = reader.int32();\n                    break;\n                case 4:\n                    message.derivationPath = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return ExportKeyStorePrivateKeyOfPathParam;\n    })();\n\n    api.ExportKeyStorePrivateKeyResp = (function() {\n\n        /**\n         * Properties of an ExportKeyStorePrivateKeyResp.\n         * @memberof api\n         * @interface IExportKeyStorePrivateKeyResp\n         * @property {string|null} [privateKey] ExportKeyStorePrivateKeyResp privateKey\n         */\n\n        /**\n         * Constructs a new ExportKeyStorePrivateKeyResp.\n         * @memberof api\n         * @classdesc Represents an ExportKeyStorePrivateKeyResp.\n         * @implements IExportKeyStorePrivateKeyResp\n         * @constructor\n         * @param {api.IExportKeyStorePrivateKeyResp=} [properties] Properties to set\n         */\n        function ExportKeyStorePrivateKeyResp(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ExportKeyStorePrivateKeyResp privateKey.\n         * @member {string} privateKey\n         * @memberof api.ExportKeyStorePrivateKeyResp\n         * @instance\n         */\n        ExportKeyStorePrivateKeyResp.prototype.privateKey = \"\";\n\n        /**\n         * Encodes the specified ExportKeyStorePrivateKeyResp message. Does not implicitly {@link api.ExportKeyStorePrivateKeyResp.verify|verify} messages.\n         * @function encode\n         * @memberof api.ExportKeyStorePrivateKeyResp\n         * @static\n         * @param {api.IExportKeyStorePrivateKeyResp} message ExportKeyStorePrivateKeyResp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ExportKeyStorePrivateKeyResp.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.privateKey != null && Object.hasOwnProperty.call(message, \"privateKey\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.privateKey);\n            return writer;\n        };\n\n        /**\n         * Decodes an ExportKeyStorePrivateKeyResp message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.ExportKeyStorePrivateKeyResp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.ExportKeyStorePrivateKeyResp} ExportKeyStorePrivateKeyResp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ExportKeyStorePrivateKeyResp.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ExportKeyStorePrivateKeyResp();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.privateKey = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return ExportKeyStorePrivateKeyResp;\n    })();\n\n    api.ExportKeyStoreMnemonicParam = (function() {\n\n        /**\n         * Properties of an ExportKeyStoreMnemonicParam.\n         * @memberof api\n         * @interface IExportKeyStoreMnemonicParam\n         * @property {Uint8Array|null} [StoredKeyData] ExportKeyStoreMnemonicParam StoredKeyData\n         * @property {string|null} [password] ExportKeyStoreMnemonicParam password\n         */\n\n        /**\n         * Constructs a new ExportKeyStoreMnemonicParam.\n         * @memberof api\n         * @classdesc Represents an ExportKeyStoreMnemonicParam.\n         * @implements IExportKeyStoreMnemonicParam\n         * @constructor\n         * @param {api.IExportKeyStoreMnemonicParam=} [properties] Properties to set\n         */\n        function ExportKeyStoreMnemonicParam(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ExportKeyStoreMnemonicParam StoredKeyData.\n         * @member {Uint8Array} StoredKeyData\n         * @memberof api.ExportKeyStoreMnemonicParam\n         * @instance\n         */\n        ExportKeyStoreMnemonicParam.prototype.StoredKeyData = $util.newBuffer([]);\n\n        /**\n         * ExportKeyStoreMnemonicParam password.\n         * @member {string} password\n         * @memberof api.ExportKeyStoreMnemonicParam\n         * @instance\n         */\n        ExportKeyStoreMnemonicParam.prototype.password = \"\";\n\n        /**\n         * Encodes the specified ExportKeyStoreMnemonicParam message. Does not implicitly {@link api.ExportKeyStoreMnemonicParam.verify|verify} messages.\n         * @function encode\n         * @memberof api.ExportKeyStoreMnemonicParam\n         * @static\n         * @param {api.IExportKeyStoreMnemonicParam} message ExportKeyStoreMnemonicParam message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ExportKeyStoreMnemonicParam.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.StoredKeyData != null && Object.hasOwnProperty.call(message, \"StoredKeyData\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.StoredKeyData);\n            if (message.password != null && Object.hasOwnProperty.call(message, \"password\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);\n            return writer;\n        };\n\n        /**\n         * Decodes an ExportKeyStoreMnemonicParam message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.ExportKeyStoreMnemonicParam\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.ExportKeyStoreMnemonicParam} ExportKeyStoreMnemonicParam\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ExportKeyStoreMnemonicParam.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ExportKeyStoreMnemonicParam();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.StoredKeyData = reader.bytes();\n                    break;\n                case 2:\n                    message.password = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return ExportKeyStoreMnemonicParam;\n    })();\n\n    api.ExportKeyStoreMnemonicResp = (function() {\n\n        /**\n         * Properties of an ExportKeyStoreMnemonicResp.\n         * @memberof api\n         * @interface IExportKeyStoreMnemonicResp\n         * @property {string|null} [mnemonic] ExportKeyStoreMnemonicResp mnemonic\n         */\n\n        /**\n         * Constructs a new ExportKeyStoreMnemonicResp.\n         * @memberof api\n         * @classdesc Represents an ExportKeyStoreMnemonicResp.\n         * @implements IExportKeyStoreMnemonicResp\n         * @constructor\n         * @param {api.IExportKeyStoreMnemonicResp=} [properties] Properties to set\n         */\n        function ExportKeyStoreMnemonicResp(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ExportKeyStoreMnemonicResp mnemonic.\n         * @member {string} mnemonic\n         * @memberof api.ExportKeyStoreMnemonicResp\n         * @instance\n         */\n        ExportKeyStoreMnemonicResp.prototype.mnemonic = \"\";\n\n        /**\n         * Encodes the specified ExportKeyStoreMnemonicResp message. Does not implicitly {@link api.ExportKeyStoreMnemonicResp.verify|verify} messages.\n         * @function encode\n         * @memberof api.ExportKeyStoreMnemonicResp\n         * @static\n         * @param {api.IExportKeyStoreMnemonicResp} message ExportKeyStoreMnemonicResp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ExportKeyStoreMnemonicResp.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.mnemonic != null && Object.hasOwnProperty.call(message, \"mnemonic\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.mnemonic);\n            return writer;\n        };\n\n        /**\n         * Decodes an ExportKeyStoreMnemonicResp message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.ExportKeyStoreMnemonicResp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.ExportKeyStoreMnemonicResp} ExportKeyStoreMnemonicResp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ExportKeyStoreMnemonicResp.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ExportKeyStoreMnemonicResp();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.mnemonic = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return ExportKeyStoreMnemonicResp;\n    })();\n\n    api.ExportKeyStoreJSONOfAddressParam = (function() {\n\n        /**\n         * Properties of an ExportKeyStoreJSONOfAddressParam.\n         * @memberof api\n         * @interface IExportKeyStoreJSONOfAddressParam\n         * @property {Uint8Array|null} [StoredKeyData] ExportKeyStoreJSONOfAddressParam StoredKeyData\n         * @property {string|null} [password] ExportKeyStoreJSONOfAddressParam password\n         * @property {string|null} [newPassword] ExportKeyStoreJSONOfAddressParam newPassword\n         * @property {api.Coin|null} [coin] ExportKeyStoreJSONOfAddressParam coin\n         * @property {string|null} [address] ExportKeyStoreJSONOfAddressParam address\n         */\n\n        /**\n         * Constructs a new ExportKeyStoreJSONOfAddressParam.\n         * @memberof api\n         * @classdesc Represents an ExportKeyStoreJSONOfAddressParam.\n         * @implements IExportKeyStoreJSONOfAddressParam\n         * @constructor\n         * @param {api.IExportKeyStoreJSONOfAddressParam=} [properties] Properties to set\n         */\n        function ExportKeyStoreJSONOfAddressParam(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ExportKeyStoreJSONOfAddressParam StoredKeyData.\n         * @member {Uint8Array} StoredKeyData\n         * @memberof api.ExportKeyStoreJSONOfAddressParam\n         * @instance\n         */\n        ExportKeyStoreJSONOfAddressParam.prototype.StoredKeyData = $util.newBuffer([]);\n\n        /**\n         * ExportKeyStoreJSONOfAddressParam password.\n         * @member {string} password\n         * @memberof api.ExportKeyStoreJSONOfAddressParam\n         * @instance\n         */\n        ExportKeyStoreJSONOfAddressParam.prototype.password = \"\";\n\n        /**\n         * ExportKeyStoreJSONOfAddressParam newPassword.\n         * @member {string} newPassword\n         * @memberof api.ExportKeyStoreJSONOfAddressParam\n         * @instance\n         */\n        ExportKeyStoreJSONOfAddressParam.prototype.newPassword = \"\";\n\n        /**\n         * ExportKeyStoreJSONOfAddressParam coin.\n         * @member {api.Coin} coin\n         * @memberof api.ExportKeyStoreJSONOfAddressParam\n         * @instance\n         */\n        ExportKeyStoreJSONOfAddressParam.prototype.coin = 0;\n\n        /**\n         * ExportKeyStoreJSONOfAddressParam address.\n         * @member {string} address\n         * @memberof api.ExportKeyStoreJSONOfAddressParam\n         * @instance\n         */\n        ExportKeyStoreJSONOfAddressParam.prototype.address = \"\";\n\n        /**\n         * Encodes the specified ExportKeyStoreJSONOfAddressParam message. Does not implicitly {@link api.ExportKeyStoreJSONOfAddressParam.verify|verify} messages.\n         * @function encode\n         * @memberof api.ExportKeyStoreJSONOfAddressParam\n         * @static\n         * @param {api.IExportKeyStoreJSONOfAddressParam} message ExportKeyStoreJSONOfAddressParam message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ExportKeyStoreJSONOfAddressParam.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.StoredKeyData != null && Object.hasOwnProperty.call(message, \"StoredKeyData\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.StoredKeyData);\n            if (message.password != null && Object.hasOwnProperty.call(message, \"password\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);\n            if (message.newPassword != null && Object.hasOwnProperty.call(message, \"newPassword\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.newPassword);\n            if (message.coin != null && Object.hasOwnProperty.call(message, \"coin\"))\n                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.coin);\n            if (message.address != null && Object.hasOwnProperty.call(message, \"address\"))\n                writer.uint32(/* id 5, wireType 2 =*/42).string(message.address);\n            return writer;\n        };\n\n        /**\n         * Decodes an ExportKeyStoreJSONOfAddressParam message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.ExportKeyStoreJSONOfAddressParam\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.ExportKeyStoreJSONOfAddressParam} ExportKeyStoreJSONOfAddressParam\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ExportKeyStoreJSONOfAddressParam.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ExportKeyStoreJSONOfAddressParam();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.StoredKeyData = reader.bytes();\n                    break;\n                case 2:\n                    message.password = reader.string();\n                    break;\n                case 3:\n                    message.newPassword = reader.string();\n                    break;\n                case 4:\n                    message.coin = reader.int32();\n                    break;\n                case 5:\n                    message.address = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return ExportKeyStoreJSONOfAddressParam;\n    })();\n\n    api.ExportKeyStoreJSONOfPathParam = (function() {\n\n        /**\n         * Properties of an ExportKeyStoreJSONOfPathParam.\n         * @memberof api\n         * @interface IExportKeyStoreJSONOfPathParam\n         * @property {Uint8Array|null} [StoredKeyData] ExportKeyStoreJSONOfPathParam StoredKeyData\n         * @property {string|null} [password] ExportKeyStoreJSONOfPathParam password\n         * @property {string|null} [newPassword] ExportKeyStoreJSONOfPathParam newPassword\n         * @property {api.Coin|null} [coin] ExportKeyStoreJSONOfPathParam coin\n         * @property {string|null} [derivationPath] ExportKeyStoreJSONOfPathParam derivationPath\n         */\n\n        /**\n         * Constructs a new ExportKeyStoreJSONOfPathParam.\n         * @memberof api\n         * @classdesc Represents an ExportKeyStoreJSONOfPathParam.\n         * @implements IExportKeyStoreJSONOfPathParam\n         * @constructor\n         * @param {api.IExportKeyStoreJSONOfPathParam=} [properties] Properties to set\n         */\n        function ExportKeyStoreJSONOfPathParam(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ExportKeyStoreJSONOfPathParam StoredKeyData.\n         * @member {Uint8Array} StoredKeyData\n         * @memberof api.ExportKeyStoreJSONOfPathParam\n         * @instance\n         */\n        ExportKeyStoreJSONOfPathParam.prototype.StoredKeyData = $util.newBuffer([]);\n\n        /**\n         * ExportKeyStoreJSONOfPathParam password.\n         * @member {string} password\n         * @memberof api.ExportKeyStoreJSONOfPathParam\n         * @instance\n         */\n        ExportKeyStoreJSONOfPathParam.prototype.password = \"\";\n\n        /**\n         * ExportKeyStoreJSONOfPathParam newPassword.\n         * @member {string} newPassword\n         * @memberof api.ExportKeyStoreJSONOfPathParam\n         * @instance\n         */\n        ExportKeyStoreJSONOfPathParam.prototype.newPassword = \"\";\n\n        /**\n         * ExportKeyStoreJSONOfPathParam coin.\n         * @member {api.Coin} coin\n         * @memberof api.ExportKeyStoreJSONOfPathParam\n         * @instance\n         */\n        ExportKeyStoreJSONOfPathParam.prototype.coin = 0;\n\n        /**\n         * ExportKeyStoreJSONOfPathParam derivationPath.\n         * @member {string} derivationPath\n         * @memberof api.ExportKeyStoreJSONOfPathParam\n         * @instance\n         */\n        ExportKeyStoreJSONOfPathParam.prototype.derivationPath = \"\";\n\n        /**\n         * Encodes the specified ExportKeyStoreJSONOfPathParam message. Does not implicitly {@link api.ExportKeyStoreJSONOfPathParam.verify|verify} messages.\n         * @function encode\n         * @memberof api.ExportKeyStoreJSONOfPathParam\n         * @static\n         * @param {api.IExportKeyStoreJSONOfPathParam} message ExportKeyStoreJSONOfPathParam message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ExportKeyStoreJSONOfPathParam.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.StoredKeyData != null && Object.hasOwnProperty.call(message, \"StoredKeyData\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.StoredKeyData);\n            if (message.password != null && Object.hasOwnProperty.call(message, \"password\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);\n            if (message.newPassword != null && Object.hasOwnProperty.call(message, \"newPassword\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.newPassword);\n            if (message.coin != null && Object.hasOwnProperty.call(message, \"coin\"))\n                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.coin);\n            if (message.derivationPath != null && Object.hasOwnProperty.call(message, \"derivationPath\"))\n                writer.uint32(/* id 5, wireType 2 =*/42).string(message.derivationPath);\n            return writer;\n        };\n\n        /**\n         * Decodes an ExportKeyStoreJSONOfPathParam message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.ExportKeyStoreJSONOfPathParam\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.ExportKeyStoreJSONOfPathParam} ExportKeyStoreJSONOfPathParam\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ExportKeyStoreJSONOfPathParam.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ExportKeyStoreJSONOfPathParam();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.StoredKeyData = reader.bytes();\n                    break;\n                case 2:\n                    message.password = reader.string();\n                    break;\n                case 3:\n                    message.newPassword = reader.string();\n                    break;\n                case 4:\n                    message.coin = reader.int32();\n                    break;\n                case 5:\n                    message.derivationPath = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return ExportKeyStoreJSONOfPathParam;\n    })();\n\n    api.ExportKeyStoreJSONResp = (function() {\n\n        /**\n         * Properties of an ExportKeyStoreJSONResp.\n         * @memberof api\n         * @interface IExportKeyStoreJSONResp\n         * @property {string|null} [json] ExportKeyStoreJSONResp json\n         */\n\n        /**\n         * Constructs a new ExportKeyStoreJSONResp.\n         * @memberof api\n         * @classdesc Represents an ExportKeyStoreJSONResp.\n         * @implements IExportKeyStoreJSONResp\n         * @constructor\n         * @param {api.IExportKeyStoreJSONResp=} [properties] Properties to set\n         */\n        function ExportKeyStoreJSONResp(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ExportKeyStoreJSONResp json.\n         * @member {string} json\n         * @memberof api.ExportKeyStoreJSONResp\n         * @instance\n         */\n        ExportKeyStoreJSONResp.prototype.json = \"\";\n\n        /**\n         * Encodes the specified ExportKeyStoreJSONResp message. Does not implicitly {@link api.ExportKeyStoreJSONResp.verify|verify} messages.\n         * @function encode\n         * @memberof api.ExportKeyStoreJSONResp\n         * @static\n         * @param {api.IExportKeyStoreJSONResp} message ExportKeyStoreJSONResp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ExportKeyStoreJSONResp.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.json != null && Object.hasOwnProperty.call(message, \"json\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.json);\n            return writer;\n        };\n\n        /**\n         * Decodes an ExportKeyStoreJSONResp message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.ExportKeyStoreJSONResp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.ExportKeyStoreJSONResp} ExportKeyStoreJSONResp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ExportKeyStoreJSONResp.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ExportKeyStoreJSONResp();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.json = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return ExportKeyStoreJSONResp;\n    })();\n\n    api.GetKeyStoreSupportImportTypeParam = (function() {\n\n        /**\n         * Properties of a GetKeyStoreSupportImportTypeParam.\n         * @memberof api\n         * @interface IGetKeyStoreSupportImportTypeParam\n         * @property {api.Coin|null} [coin] GetKeyStoreSupportImportTypeParam coin\n         */\n\n        /**\n         * Constructs a new GetKeyStoreSupportImportTypeParam.\n         * @memberof api\n         * @classdesc Represents a GetKeyStoreSupportImportTypeParam.\n         * @implements IGetKeyStoreSupportImportTypeParam\n         * @constructor\n         * @param {api.IGetKeyStoreSupportImportTypeParam=} [properties] Properties to set\n         */\n        function GetKeyStoreSupportImportTypeParam(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * GetKeyStoreSupportImportTypeParam coin.\n         * @member {api.Coin} coin\n         * @memberof api.GetKeyStoreSupportImportTypeParam\n         * @instance\n         */\n        GetKeyStoreSupportImportTypeParam.prototype.coin = 0;\n\n        /**\n         * Encodes the specified GetKeyStoreSupportImportTypeParam message. Does not implicitly {@link api.GetKeyStoreSupportImportTypeParam.verify|verify} messages.\n         * @function encode\n         * @memberof api.GetKeyStoreSupportImportTypeParam\n         * @static\n         * @param {api.IGetKeyStoreSupportImportTypeParam} message GetKeyStoreSupportImportTypeParam message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        GetKeyStoreSupportImportTypeParam.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.coin != null && Object.hasOwnProperty.call(message, \"coin\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.coin);\n            return writer;\n        };\n\n        /**\n         * Decodes a GetKeyStoreSupportImportTypeParam message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.GetKeyStoreSupportImportTypeParam\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.GetKeyStoreSupportImportTypeParam} GetKeyStoreSupportImportTypeParam\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        GetKeyStoreSupportImportTypeParam.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.GetKeyStoreSupportImportTypeParam();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.coin = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return GetKeyStoreSupportImportTypeParam;\n    })();\n\n    api.GetKeyStoreSupportImportTypeResp = (function() {\n\n        /**\n         * Properties of a GetKeyStoreSupportImportTypeResp.\n         * @memberof api\n         * @interface IGetKeyStoreSupportImportTypeResp\n         * @property {Array.<api.StoredKeyImportType>|null} [type] GetKeyStoreSupportImportTypeResp type\n         */\n\n        /**\n         * Constructs a new GetKeyStoreSupportImportTypeResp.\n         * @memberof api\n         * @classdesc Represents a GetKeyStoreSupportImportTypeResp.\n         * @implements IGetKeyStoreSupportImportTypeResp\n         * @constructor\n         * @param {api.IGetKeyStoreSupportImportTypeResp=} [properties] Properties to set\n         */\n        function GetKeyStoreSupportImportTypeResp(properties) {\n            this.type = [];\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * GetKeyStoreSupportImportTypeResp type.\n         * @member {Array.<api.StoredKeyImportType>} type\n         * @memberof api.GetKeyStoreSupportImportTypeResp\n         * @instance\n         */\n        GetKeyStoreSupportImportTypeResp.prototype.type = $util.emptyArray;\n\n        /**\n         * Encodes the specified GetKeyStoreSupportImportTypeResp message. Does not implicitly {@link api.GetKeyStoreSupportImportTypeResp.verify|verify} messages.\n         * @function encode\n         * @memberof api.GetKeyStoreSupportImportTypeResp\n         * @static\n         * @param {api.IGetKeyStoreSupportImportTypeResp} message GetKeyStoreSupportImportTypeResp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        GetKeyStoreSupportImportTypeResp.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.type != null && message.type.length) {\n                writer.uint32(/* id 1, wireType 2 =*/10).fork();\n                for (let i = 0; i < message.type.length; ++i)\n                    writer.int32(message.type[i]);\n                writer.ldelim();\n            }\n            return writer;\n        };\n\n        /**\n         * Decodes a GetKeyStoreSupportImportTypeResp message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.GetKeyStoreSupportImportTypeResp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.GetKeyStoreSupportImportTypeResp} GetKeyStoreSupportImportTypeResp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        GetKeyStoreSupportImportTypeResp.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.GetKeyStoreSupportImportTypeResp();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.type && message.type.length))\n                        message.type = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.type.push(reader.int32());\n                    } else\n                        message.type.push(reader.int32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return GetKeyStoreSupportImportTypeResp;\n    })();\n\n    api.LoadStoredKeyParam = (function() {\n\n        /**\n         * Properties of a LoadStoredKeyParam.\n         * @memberof api\n         * @interface ILoadStoredKeyParam\n         * @property {Array.<Uint8Array>|null} [data] LoadStoredKeyParam data\n         */\n\n        /**\n         * Constructs a new LoadStoredKeyParam.\n         * @memberof api\n         * @classdesc Represents a LoadStoredKeyParam.\n         * @implements ILoadStoredKeyParam\n         * @constructor\n         * @param {api.ILoadStoredKeyParam=} [properties] Properties to set\n         */\n        function LoadStoredKeyParam(properties) {\n            this.data = [];\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * LoadStoredKeyParam data.\n         * @member {Array.<Uint8Array>} data\n         * @memberof api.LoadStoredKeyParam\n         * @instance\n         */\n        LoadStoredKeyParam.prototype.data = $util.emptyArray;\n\n        /**\n         * Encodes the specified LoadStoredKeyParam message. Does not implicitly {@link api.LoadStoredKeyParam.verify|verify} messages.\n         * @function encode\n         * @memberof api.LoadStoredKeyParam\n         * @static\n         * @param {api.ILoadStoredKeyParam} message LoadStoredKeyParam message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        LoadStoredKeyParam.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.data != null && message.data.length)\n                for (let i = 0; i < message.data.length; ++i)\n                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data[i]);\n            return writer;\n        };\n\n        /**\n         * Decodes a LoadStoredKeyParam message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.LoadStoredKeyParam\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.LoadStoredKeyParam} LoadStoredKeyParam\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        LoadStoredKeyParam.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.LoadStoredKeyParam();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.data && message.data.length))\n                        message.data = [];\n                    message.data.push(reader.bytes());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return LoadStoredKeyParam;\n    })();\n\n    api.LoadStoredKeyResp = (function() {\n\n        /**\n         * Properties of a LoadStoredKeyResp.\n         * @memberof api\n         * @interface ILoadStoredKeyResp\n         * @property {Array.<api.IStoredKeyInfo>|null} [StoredKeys] LoadStoredKeyResp StoredKeys\n         */\n\n        /**\n         * Constructs a new LoadStoredKeyResp.\n         * @memberof api\n         * @classdesc Represents a LoadStoredKeyResp.\n         * @implements ILoadStoredKeyResp\n         * @constructor\n         * @param {api.ILoadStoredKeyResp=} [properties] Properties to set\n         */\n        function LoadStoredKeyResp(properties) {\n            this.StoredKeys = [];\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * LoadStoredKeyResp StoredKeys.\n         * @member {Array.<api.IStoredKeyInfo>} StoredKeys\n         * @memberof api.LoadStoredKeyResp\n         * @instance\n         */\n        LoadStoredKeyResp.prototype.StoredKeys = $util.emptyArray;\n\n        /**\n         * Encodes the specified LoadStoredKeyResp message. Does not implicitly {@link api.LoadStoredKeyResp.verify|verify} messages.\n         * @function encode\n         * @memberof api.LoadStoredKeyResp\n         * @static\n         * @param {api.ILoadStoredKeyResp} message LoadStoredKeyResp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        LoadStoredKeyResp.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.StoredKeys != null && message.StoredKeys.length)\n                for (let i = 0; i < message.StoredKeys.length; ++i)\n                    $root.api.StoredKeyInfo.encode(message.StoredKeys[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Decodes a LoadStoredKeyResp message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.LoadStoredKeyResp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.LoadStoredKeyResp} LoadStoredKeyResp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        LoadStoredKeyResp.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.LoadStoredKeyResp();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.StoredKeys && message.StoredKeys.length))\n                        message.StoredKeys = [];\n                    message.StoredKeys.push($root.api.StoredKeyInfo.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return LoadStoredKeyResp;\n    })();\n\n    api.CreateStoredKeyParam = (function() {\n\n        /**\n         * Properties of a CreateStoredKeyParam.\n         * @memberof api\n         * @interface ICreateStoredKeyParam\n         * @property {string|null} [password] CreateStoredKeyParam password\n         */\n\n        /**\n         * Constructs a new CreateStoredKeyParam.\n         * @memberof api\n         * @classdesc Represents a CreateStoredKeyParam.\n         * @implements ICreateStoredKeyParam\n         * @constructor\n         * @param {api.ICreateStoredKeyParam=} [properties] Properties to set\n         */\n        function CreateStoredKeyParam(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CreateStoredKeyParam password.\n         * @member {string} password\n         * @memberof api.CreateStoredKeyParam\n         * @instance\n         */\n        CreateStoredKeyParam.prototype.password = \"\";\n\n        /**\n         * Encodes the specified CreateStoredKeyParam message. Does not implicitly {@link api.CreateStoredKeyParam.verify|verify} messages.\n         * @function encode\n         * @memberof api.CreateStoredKeyParam\n         * @static\n         * @param {api.ICreateStoredKeyParam} message CreateStoredKeyParam message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CreateStoredKeyParam.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.password != null && Object.hasOwnProperty.call(message, \"password\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);\n            return writer;\n        };\n\n        /**\n         * Decodes a CreateStoredKeyParam message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.CreateStoredKeyParam\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.CreateStoredKeyParam} CreateStoredKeyParam\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CreateStoredKeyParam.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.CreateStoredKeyParam();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 2:\n                    message.password = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return CreateStoredKeyParam;\n    })();\n\n    api.CreateStoredKeyResp = (function() {\n\n        /**\n         * Properties of a CreateStoredKeyResp.\n         * @memberof api\n         * @interface ICreateStoredKeyResp\n         * @property {api.IStoredKeyInfo|null} [StoredKey] CreateStoredKeyResp StoredKey\n         * @property {string|null} [mnemonic] CreateStoredKeyResp mnemonic\n         */\n\n        /**\n         * Constructs a new CreateStoredKeyResp.\n         * @memberof api\n         * @classdesc Represents a CreateStoredKeyResp.\n         * @implements ICreateStoredKeyResp\n         * @constructor\n         * @param {api.ICreateStoredKeyResp=} [properties] Properties to set\n         */\n        function CreateStoredKeyResp(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CreateStoredKeyResp StoredKey.\n         * @member {api.IStoredKeyInfo|null|undefined} StoredKey\n         * @memberof api.CreateStoredKeyResp\n         * @instance\n         */\n        CreateStoredKeyResp.prototype.StoredKey = null;\n\n        /**\n         * CreateStoredKeyResp mnemonic.\n         * @member {string} mnemonic\n         * @memberof api.CreateStoredKeyResp\n         * @instance\n         */\n        CreateStoredKeyResp.prototype.mnemonic = \"\";\n\n        /**\n         * Encodes the specified CreateStoredKeyResp message. Does not implicitly {@link api.CreateStoredKeyResp.verify|verify} messages.\n         * @function encode\n         * @memberof api.CreateStoredKeyResp\n         * @static\n         * @param {api.ICreateStoredKeyResp} message CreateStoredKeyResp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CreateStoredKeyResp.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.StoredKey != null && Object.hasOwnProperty.call(message, \"StoredKey\"))\n                $root.api.StoredKeyInfo.encode(message.StoredKey, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.mnemonic != null && Object.hasOwnProperty.call(message, \"mnemonic\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.mnemonic);\n            return writer;\n        };\n\n        /**\n         * Decodes a CreateStoredKeyResp message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.CreateStoredKeyResp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.CreateStoredKeyResp} CreateStoredKeyResp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CreateStoredKeyResp.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.CreateStoredKeyResp();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.StoredKey = $root.api.StoredKeyInfo.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.mnemonic = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return CreateStoredKeyResp;\n    })();\n\n    api.ImportPrivateStoredKeyParam = (function() {\n\n        /**\n         * Properties of an ImportPrivateStoredKeyParam.\n         * @memberof api\n         * @interface IImportPrivateStoredKeyParam\n         * @property {string|null} [privateKey] ImportPrivateStoredKeyParam privateKey\n         * @property {string|null} [password] ImportPrivateStoredKeyParam password\n         * @property {string|null} [name] ImportPrivateStoredKeyParam name\n         * @property {api.Coin|null} [coin] ImportPrivateStoredKeyParam coin\n         */\n\n        /**\n         * Constructs a new ImportPrivateStoredKeyParam.\n         * @memberof api\n         * @classdesc Represents an ImportPrivateStoredKeyParam.\n         * @implements IImportPrivateStoredKeyParam\n         * @constructor\n         * @param {api.IImportPrivateStoredKeyParam=} [properties] Properties to set\n         */\n        function ImportPrivateStoredKeyParam(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ImportPrivateStoredKeyParam privateKey.\n         * @member {string} privateKey\n         * @memberof api.ImportPrivateStoredKeyParam\n         * @instance\n         */\n        ImportPrivateStoredKeyParam.prototype.privateKey = \"\";\n\n        /**\n         * ImportPrivateStoredKeyParam password.\n         * @member {string} password\n         * @memberof api.ImportPrivateStoredKeyParam\n         * @instance\n         */\n        ImportPrivateStoredKeyParam.prototype.password = \"\";\n\n        /**\n         * ImportPrivateStoredKeyParam name.\n         * @member {string} name\n         * @memberof api.ImportPrivateStoredKeyParam\n         * @instance\n         */\n        ImportPrivateStoredKeyParam.prototype.name = \"\";\n\n        /**\n         * ImportPrivateStoredKeyParam coin.\n         * @member {api.Coin} coin\n         * @memberof api.ImportPrivateStoredKeyParam\n         * @instance\n         */\n        ImportPrivateStoredKeyParam.prototype.coin = 0;\n\n        /**\n         * Encodes the specified ImportPrivateStoredKeyParam message. Does not implicitly {@link api.ImportPrivateStoredKeyParam.verify|verify} messages.\n         * @function encode\n         * @memberof api.ImportPrivateStoredKeyParam\n         * @static\n         * @param {api.IImportPrivateStoredKeyParam} message ImportPrivateStoredKeyParam message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ImportPrivateStoredKeyParam.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.privateKey != null && Object.hasOwnProperty.call(message, \"privateKey\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.privateKey);\n            if (message.password != null && Object.hasOwnProperty.call(message, \"password\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);\n            if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);\n            if (message.coin != null && Object.hasOwnProperty.call(message, \"coin\"))\n                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.coin);\n            return writer;\n        };\n\n        /**\n         * Decodes an ImportPrivateStoredKeyParam message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.ImportPrivateStoredKeyParam\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.ImportPrivateStoredKeyParam} ImportPrivateStoredKeyParam\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ImportPrivateStoredKeyParam.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ImportPrivateStoredKeyParam();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.privateKey = reader.string();\n                    break;\n                case 2:\n                    message.password = reader.string();\n                    break;\n                case 3:\n                    message.name = reader.string();\n                    break;\n                case 4:\n                    message.coin = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return ImportPrivateStoredKeyParam;\n    })();\n\n    api.ImportPrivateStoredKeyResp = (function() {\n\n        /**\n         * Properties of an ImportPrivateStoredKeyResp.\n         * @memberof api\n         * @interface IImportPrivateStoredKeyResp\n         * @property {api.IStoredKeyInfo|null} [StoredKey] ImportPrivateStoredKeyResp StoredKey\n         */\n\n        /**\n         * Constructs a new ImportPrivateStoredKeyResp.\n         * @memberof api\n         * @classdesc Represents an ImportPrivateStoredKeyResp.\n         * @implements IImportPrivateStoredKeyResp\n         * @constructor\n         * @param {api.IImportPrivateStoredKeyResp=} [properties] Properties to set\n         */\n        function ImportPrivateStoredKeyResp(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ImportPrivateStoredKeyResp StoredKey.\n         * @member {api.IStoredKeyInfo|null|undefined} StoredKey\n         * @memberof api.ImportPrivateStoredKeyResp\n         * @instance\n         */\n        ImportPrivateStoredKeyResp.prototype.StoredKey = null;\n\n        /**\n         * Encodes the specified ImportPrivateStoredKeyResp message. Does not implicitly {@link api.ImportPrivateStoredKeyResp.verify|verify} messages.\n         * @function encode\n         * @memberof api.ImportPrivateStoredKeyResp\n         * @static\n         * @param {api.IImportPrivateStoredKeyResp} message ImportPrivateStoredKeyResp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ImportPrivateStoredKeyResp.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.StoredKey != null && Object.hasOwnProperty.call(message, \"StoredKey\"))\n                $root.api.StoredKeyInfo.encode(message.StoredKey, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Decodes an ImportPrivateStoredKeyResp message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.ImportPrivateStoredKeyResp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.ImportPrivateStoredKeyResp} ImportPrivateStoredKeyResp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ImportPrivateStoredKeyResp.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ImportPrivateStoredKeyResp();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.StoredKey = $root.api.StoredKeyInfo.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return ImportPrivateStoredKeyResp;\n    })();\n\n    api.ImportMnemonicStoredKeyParam = (function() {\n\n        /**\n         * Properties of an ImportMnemonicStoredKeyParam.\n         * @memberof api\n         * @interface IImportMnemonicStoredKeyParam\n         * @property {string|null} [mnemonic] ImportMnemonicStoredKeyParam mnemonic\n         * @property {string|null} [password] ImportMnemonicStoredKeyParam password\n         */\n\n        /**\n         * Constructs a new ImportMnemonicStoredKeyParam.\n         * @memberof api\n         * @classdesc Represents an ImportMnemonicStoredKeyParam.\n         * @implements IImportMnemonicStoredKeyParam\n         * @constructor\n         * @param {api.IImportMnemonicStoredKeyParam=} [properties] Properties to set\n         */\n        function ImportMnemonicStoredKeyParam(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ImportMnemonicStoredKeyParam mnemonic.\n         * @member {string} mnemonic\n         * @memberof api.ImportMnemonicStoredKeyParam\n         * @instance\n         */\n        ImportMnemonicStoredKeyParam.prototype.mnemonic = \"\";\n\n        /**\n         * ImportMnemonicStoredKeyParam password.\n         * @member {string} password\n         * @memberof api.ImportMnemonicStoredKeyParam\n         * @instance\n         */\n        ImportMnemonicStoredKeyParam.prototype.password = \"\";\n\n        /**\n         * Encodes the specified ImportMnemonicStoredKeyParam message. Does not implicitly {@link api.ImportMnemonicStoredKeyParam.verify|verify} messages.\n         * @function encode\n         * @memberof api.ImportMnemonicStoredKeyParam\n         * @static\n         * @param {api.IImportMnemonicStoredKeyParam} message ImportMnemonicStoredKeyParam message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ImportMnemonicStoredKeyParam.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.mnemonic != null && Object.hasOwnProperty.call(message, \"mnemonic\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.mnemonic);\n            if (message.password != null && Object.hasOwnProperty.call(message, \"password\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.password);\n            return writer;\n        };\n\n        /**\n         * Decodes an ImportMnemonicStoredKeyParam message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.ImportMnemonicStoredKeyParam\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.ImportMnemonicStoredKeyParam} ImportMnemonicStoredKeyParam\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ImportMnemonicStoredKeyParam.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ImportMnemonicStoredKeyParam();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.mnemonic = reader.string();\n                    break;\n                case 3:\n                    message.password = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return ImportMnemonicStoredKeyParam;\n    })();\n\n    api.ImportMnemonicStoredKeyResp = (function() {\n\n        /**\n         * Properties of an ImportMnemonicStoredKeyResp.\n         * @memberof api\n         * @interface IImportMnemonicStoredKeyResp\n         * @property {api.IStoredKeyInfo|null} [StoredKey] ImportMnemonicStoredKeyResp StoredKey\n         */\n\n        /**\n         * Constructs a new ImportMnemonicStoredKeyResp.\n         * @memberof api\n         * @classdesc Represents an ImportMnemonicStoredKeyResp.\n         * @implements IImportMnemonicStoredKeyResp\n         * @constructor\n         * @param {api.IImportMnemonicStoredKeyResp=} [properties] Properties to set\n         */\n        function ImportMnemonicStoredKeyResp(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ImportMnemonicStoredKeyResp StoredKey.\n         * @member {api.IStoredKeyInfo|null|undefined} StoredKey\n         * @memberof api.ImportMnemonicStoredKeyResp\n         * @instance\n         */\n        ImportMnemonicStoredKeyResp.prototype.StoredKey = null;\n\n        /**\n         * Encodes the specified ImportMnemonicStoredKeyResp message. Does not implicitly {@link api.ImportMnemonicStoredKeyResp.verify|verify} messages.\n         * @function encode\n         * @memberof api.ImportMnemonicStoredKeyResp\n         * @static\n         * @param {api.IImportMnemonicStoredKeyResp} message ImportMnemonicStoredKeyResp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ImportMnemonicStoredKeyResp.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.StoredKey != null && Object.hasOwnProperty.call(message, \"StoredKey\"))\n                $root.api.StoredKeyInfo.encode(message.StoredKey, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Decodes an ImportMnemonicStoredKeyResp message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.ImportMnemonicStoredKeyResp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.ImportMnemonicStoredKeyResp} ImportMnemonicStoredKeyResp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ImportMnemonicStoredKeyResp.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ImportMnemonicStoredKeyResp();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.StoredKey = $root.api.StoredKeyInfo.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return ImportMnemonicStoredKeyResp;\n    })();\n\n    api.ImportJSONStoredKeyParam = (function() {\n\n        /**\n         * Properties of an ImportJSONStoredKeyParam.\n         * @memberof api\n         * @interface IImportJSONStoredKeyParam\n         * @property {string|null} [json] ImportJSONStoredKeyParam json\n         * @property {string|null} [name] ImportJSONStoredKeyParam name\n         * @property {string|null} [keyStoreJsonPassword] ImportJSONStoredKeyParam keyStoreJsonPassword\n         * @property {string|null} [password] ImportJSONStoredKeyParam password\n         * @property {api.Coin|null} [coin] ImportJSONStoredKeyParam coin\n         */\n\n        /**\n         * Constructs a new ImportJSONStoredKeyParam.\n         * @memberof api\n         * @classdesc Represents an ImportJSONStoredKeyParam.\n         * @implements IImportJSONStoredKeyParam\n         * @constructor\n         * @param {api.IImportJSONStoredKeyParam=} [properties] Properties to set\n         */\n        function ImportJSONStoredKeyParam(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ImportJSONStoredKeyParam json.\n         * @member {string} json\n         * @memberof api.ImportJSONStoredKeyParam\n         * @instance\n         */\n        ImportJSONStoredKeyParam.prototype.json = \"\";\n\n        /**\n         * ImportJSONStoredKeyParam name.\n         * @member {string} name\n         * @memberof api.ImportJSONStoredKeyParam\n         * @instance\n         */\n        ImportJSONStoredKeyParam.prototype.name = \"\";\n\n        /**\n         * ImportJSONStoredKeyParam keyStoreJsonPassword.\n         * @member {string} keyStoreJsonPassword\n         * @memberof api.ImportJSONStoredKeyParam\n         * @instance\n         */\n        ImportJSONStoredKeyParam.prototype.keyStoreJsonPassword = \"\";\n\n        /**\n         * ImportJSONStoredKeyParam password.\n         * @member {string} password\n         * @memberof api.ImportJSONStoredKeyParam\n         * @instance\n         */\n        ImportJSONStoredKeyParam.prototype.password = \"\";\n\n        /**\n         * ImportJSONStoredKeyParam coin.\n         * @member {api.Coin} coin\n         * @memberof api.ImportJSONStoredKeyParam\n         * @instance\n         */\n        ImportJSONStoredKeyParam.prototype.coin = 0;\n\n        /**\n         * Encodes the specified ImportJSONStoredKeyParam message. Does not implicitly {@link api.ImportJSONStoredKeyParam.verify|verify} messages.\n         * @function encode\n         * @memberof api.ImportJSONStoredKeyParam\n         * @static\n         * @param {api.IImportJSONStoredKeyParam} message ImportJSONStoredKeyParam message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ImportJSONStoredKeyParam.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.json != null && Object.hasOwnProperty.call(message, \"json\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.json);\n            if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);\n            if (message.keyStoreJsonPassword != null && Object.hasOwnProperty.call(message, \"keyStoreJsonPassword\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.keyStoreJsonPassword);\n            if (message.password != null && Object.hasOwnProperty.call(message, \"password\"))\n                writer.uint32(/* id 4, wireType 2 =*/34).string(message.password);\n            if (message.coin != null && Object.hasOwnProperty.call(message, \"coin\"))\n                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.coin);\n            return writer;\n        };\n\n        /**\n         * Decodes an ImportJSONStoredKeyParam message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.ImportJSONStoredKeyParam\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.ImportJSONStoredKeyParam} ImportJSONStoredKeyParam\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ImportJSONStoredKeyParam.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ImportJSONStoredKeyParam();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.json = reader.string();\n                    break;\n                case 2:\n                    message.name = reader.string();\n                    break;\n                case 3:\n                    message.keyStoreJsonPassword = reader.string();\n                    break;\n                case 4:\n                    message.password = reader.string();\n                    break;\n                case 5:\n                    message.coin = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return ImportJSONStoredKeyParam;\n    })();\n\n    api.ImportJSONStoredKeyResp = (function() {\n\n        /**\n         * Properties of an ImportJSONStoredKeyResp.\n         * @memberof api\n         * @interface IImportJSONStoredKeyResp\n         * @property {api.IStoredKeyInfo|null} [StoredKey] ImportJSONStoredKeyResp StoredKey\n         */\n\n        /**\n         * Constructs a new ImportJSONStoredKeyResp.\n         * @memberof api\n         * @classdesc Represents an ImportJSONStoredKeyResp.\n         * @implements IImportJSONStoredKeyResp\n         * @constructor\n         * @param {api.IImportJSONStoredKeyResp=} [properties] Properties to set\n         */\n        function ImportJSONStoredKeyResp(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ImportJSONStoredKeyResp StoredKey.\n         * @member {api.IStoredKeyInfo|null|undefined} StoredKey\n         * @memberof api.ImportJSONStoredKeyResp\n         * @instance\n         */\n        ImportJSONStoredKeyResp.prototype.StoredKey = null;\n\n        /**\n         * Encodes the specified ImportJSONStoredKeyResp message. Does not implicitly {@link api.ImportJSONStoredKeyResp.verify|verify} messages.\n         * @function encode\n         * @memberof api.ImportJSONStoredKeyResp\n         * @static\n         * @param {api.IImportJSONStoredKeyResp} message ImportJSONStoredKeyResp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ImportJSONStoredKeyResp.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.StoredKey != null && Object.hasOwnProperty.call(message, \"StoredKey\"))\n                $root.api.StoredKeyInfo.encode(message.StoredKey, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Decodes an ImportJSONStoredKeyResp message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.ImportJSONStoredKeyResp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.ImportJSONStoredKeyResp} ImportJSONStoredKeyResp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ImportJSONStoredKeyResp.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ImportJSONStoredKeyResp();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.StoredKey = $root.api.StoredKeyInfo.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return ImportJSONStoredKeyResp;\n    })();\n\n    api.UpdateStoredKeyPasswordParam = (function() {\n\n        /**\n         * Properties of an UpdateStoredKeyPasswordParam.\n         * @memberof api\n         * @interface IUpdateStoredKeyPasswordParam\n         * @property {Uint8Array|null} [StoredKeyData] UpdateStoredKeyPasswordParam StoredKeyData\n         * @property {string|null} [oldPassword] UpdateStoredKeyPasswordParam oldPassword\n         * @property {string|null} [newPassword] UpdateStoredKeyPasswordParam newPassword\n         */\n\n        /**\n         * Constructs a new UpdateStoredKeyPasswordParam.\n         * @memberof api\n         * @classdesc Represents an UpdateStoredKeyPasswordParam.\n         * @implements IUpdateStoredKeyPasswordParam\n         * @constructor\n         * @param {api.IUpdateStoredKeyPasswordParam=} [properties] Properties to set\n         */\n        function UpdateStoredKeyPasswordParam(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * UpdateStoredKeyPasswordParam StoredKeyData.\n         * @member {Uint8Array} StoredKeyData\n         * @memberof api.UpdateStoredKeyPasswordParam\n         * @instance\n         */\n        UpdateStoredKeyPasswordParam.prototype.StoredKeyData = $util.newBuffer([]);\n\n        /**\n         * UpdateStoredKeyPasswordParam oldPassword.\n         * @member {string} oldPassword\n         * @memberof api.UpdateStoredKeyPasswordParam\n         * @instance\n         */\n        UpdateStoredKeyPasswordParam.prototype.oldPassword = \"\";\n\n        /**\n         * UpdateStoredKeyPasswordParam newPassword.\n         * @member {string} newPassword\n         * @memberof api.UpdateStoredKeyPasswordParam\n         * @instance\n         */\n        UpdateStoredKeyPasswordParam.prototype.newPassword = \"\";\n\n        /**\n         * Encodes the specified UpdateStoredKeyPasswordParam message. Does not implicitly {@link api.UpdateStoredKeyPasswordParam.verify|verify} messages.\n         * @function encode\n         * @memberof api.UpdateStoredKeyPasswordParam\n         * @static\n         * @param {api.IUpdateStoredKeyPasswordParam} message UpdateStoredKeyPasswordParam message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        UpdateStoredKeyPasswordParam.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.StoredKeyData != null && Object.hasOwnProperty.call(message, \"StoredKeyData\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.StoredKeyData);\n            if (message.oldPassword != null && Object.hasOwnProperty.call(message, \"oldPassword\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.oldPassword);\n            if (message.newPassword != null && Object.hasOwnProperty.call(message, \"newPassword\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.newPassword);\n            return writer;\n        };\n\n        /**\n         * Decodes an UpdateStoredKeyPasswordParam message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.UpdateStoredKeyPasswordParam\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.UpdateStoredKeyPasswordParam} UpdateStoredKeyPasswordParam\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        UpdateStoredKeyPasswordParam.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.UpdateStoredKeyPasswordParam();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.StoredKeyData = reader.bytes();\n                    break;\n                case 2:\n                    message.oldPassword = reader.string();\n                    break;\n                case 3:\n                    message.newPassword = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return UpdateStoredKeyPasswordParam;\n    })();\n\n    api.UpdateStoredKeyPasswordResp = (function() {\n\n        /**\n         * Properties of an UpdateStoredKeyPasswordResp.\n         * @memberof api\n         * @interface IUpdateStoredKeyPasswordResp\n         * @property {api.IStoredKeyInfo|null} [StoredKey] UpdateStoredKeyPasswordResp StoredKey\n         */\n\n        /**\n         * Constructs a new UpdateStoredKeyPasswordResp.\n         * @memberof api\n         * @classdesc Represents an UpdateStoredKeyPasswordResp.\n         * @implements IUpdateStoredKeyPasswordResp\n         * @constructor\n         * @param {api.IUpdateStoredKeyPasswordResp=} [properties] Properties to set\n         */\n        function UpdateStoredKeyPasswordResp(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * UpdateStoredKeyPasswordResp StoredKey.\n         * @member {api.IStoredKeyInfo|null|undefined} StoredKey\n         * @memberof api.UpdateStoredKeyPasswordResp\n         * @instance\n         */\n        UpdateStoredKeyPasswordResp.prototype.StoredKey = null;\n\n        /**\n         * Encodes the specified UpdateStoredKeyPasswordResp message. Does not implicitly {@link api.UpdateStoredKeyPasswordResp.verify|verify} messages.\n         * @function encode\n         * @memberof api.UpdateStoredKeyPasswordResp\n         * @static\n         * @param {api.IUpdateStoredKeyPasswordResp} message UpdateStoredKeyPasswordResp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        UpdateStoredKeyPasswordResp.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.StoredKey != null && Object.hasOwnProperty.call(message, \"StoredKey\"))\n                $root.api.StoredKeyInfo.encode(message.StoredKey, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Decodes an UpdateStoredKeyPasswordResp message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.UpdateStoredKeyPasswordResp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.UpdateStoredKeyPasswordResp} UpdateStoredKeyPasswordResp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        UpdateStoredKeyPasswordResp.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.UpdateStoredKeyPasswordResp();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.StoredKey = $root.api.StoredKeyInfo.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return UpdateStoredKeyPasswordResp;\n    })();\n\n    api.GenerateMnemonicParam = (function() {\n\n        /**\n         * Properties of a GenerateMnemonicParam.\n         * @memberof api\n         * @interface IGenerateMnemonicParam\n         */\n\n        /**\n         * Constructs a new GenerateMnemonicParam.\n         * @memberof api\n         * @classdesc Represents a GenerateMnemonicParam.\n         * @implements IGenerateMnemonicParam\n         * @constructor\n         * @param {api.IGenerateMnemonicParam=} [properties] Properties to set\n         */\n        function GenerateMnemonicParam(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * Encodes the specified GenerateMnemonicParam message. Does not implicitly {@link api.GenerateMnemonicParam.verify|verify} messages.\n         * @function encode\n         * @memberof api.GenerateMnemonicParam\n         * @static\n         * @param {api.IGenerateMnemonicParam} message GenerateMnemonicParam message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        GenerateMnemonicParam.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            return writer;\n        };\n\n        /**\n         * Decodes a GenerateMnemonicParam message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.GenerateMnemonicParam\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.GenerateMnemonicParam} GenerateMnemonicParam\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        GenerateMnemonicParam.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.GenerateMnemonicParam();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return GenerateMnemonicParam;\n    })();\n\n    api.GenerateMnemonicResp = (function() {\n\n        /**\n         * Properties of a GenerateMnemonicResp.\n         * @memberof api\n         * @interface IGenerateMnemonicResp\n         * @property {string|null} [mnemonic] GenerateMnemonicResp mnemonic\n         */\n\n        /**\n         * Constructs a new GenerateMnemonicResp.\n         * @memberof api\n         * @classdesc Represents a GenerateMnemonicResp.\n         * @implements IGenerateMnemonicResp\n         * @constructor\n         * @param {api.IGenerateMnemonicResp=} [properties] Properties to set\n         */\n        function GenerateMnemonicResp(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * GenerateMnemonicResp mnemonic.\n         * @member {string} mnemonic\n         * @memberof api.GenerateMnemonicResp\n         * @instance\n         */\n        GenerateMnemonicResp.prototype.mnemonic = \"\";\n\n        /**\n         * Encodes the specified GenerateMnemonicResp message. Does not implicitly {@link api.GenerateMnemonicResp.verify|verify} messages.\n         * @function encode\n         * @memberof api.GenerateMnemonicResp\n         * @static\n         * @param {api.IGenerateMnemonicResp} message GenerateMnemonicResp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        GenerateMnemonicResp.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.mnemonic != null && Object.hasOwnProperty.call(message, \"mnemonic\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.mnemonic);\n            return writer;\n        };\n\n        /**\n         * Decodes a GenerateMnemonicResp message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.GenerateMnemonicResp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.GenerateMnemonicResp} GenerateMnemonicResp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        GenerateMnemonicResp.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.GenerateMnemonicResp();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.mnemonic = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return GenerateMnemonicResp;\n    })();\n\n    api.SignTransactionParam = (function() {\n\n        /**\n         * Properties of a SignTransactionParam.\n         * @memberof api\n         * @interface ISignTransactionParam\n         * @property {Uint8Array|null} [storedKeyData] SignTransactionParam storedKeyData\n         * @property {string|null} [derivationPath] SignTransactionParam derivationPath\n         * @property {string|null} [password] SignTransactionParam password\n         * @property {api.Coin|null} [coin] SignTransactionParam coin\n         * @property {ethereum.ISignInput|null} [sign_input] SignTransactionParam sign_input\n         */\n\n        /**\n         * Constructs a new SignTransactionParam.\n         * @memberof api\n         * @classdesc Represents a SignTransactionParam.\n         * @implements ISignTransactionParam\n         * @constructor\n         * @param {api.ISignTransactionParam=} [properties] Properties to set\n         */\n        function SignTransactionParam(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * SignTransactionParam storedKeyData.\n         * @member {Uint8Array} storedKeyData\n         * @memberof api.SignTransactionParam\n         * @instance\n         */\n        SignTransactionParam.prototype.storedKeyData = $util.newBuffer([]);\n\n        /**\n         * SignTransactionParam derivationPath.\n         * @member {string} derivationPath\n         * @memberof api.SignTransactionParam\n         * @instance\n         */\n        SignTransactionParam.prototype.derivationPath = \"\";\n\n        /**\n         * SignTransactionParam password.\n         * @member {string} password\n         * @memberof api.SignTransactionParam\n         * @instance\n         */\n        SignTransactionParam.prototype.password = \"\";\n\n        /**\n         * SignTransactionParam coin.\n         * @member {api.Coin} coin\n         * @memberof api.SignTransactionParam\n         * @instance\n         */\n        SignTransactionParam.prototype.coin = 0;\n\n        /**\n         * SignTransactionParam sign_input.\n         * @member {ethereum.ISignInput|null|undefined} sign_input\n         * @memberof api.SignTransactionParam\n         * @instance\n         */\n        SignTransactionParam.prototype.sign_input = null;\n\n        // OneOf field names bound to virtual getters and setters\n        let $oneOfFields;\n\n        /**\n         * SignTransactionParam input.\n         * @member {\"sign_input\"|undefined} input\n         * @memberof api.SignTransactionParam\n         * @instance\n         */\n        Object.defineProperty(SignTransactionParam.prototype, \"input\", {\n            get: $util.oneOfGetter($oneOfFields = [\"sign_input\"]),\n            set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Encodes the specified SignTransactionParam message. Does not implicitly {@link api.SignTransactionParam.verify|verify} messages.\n         * @function encode\n         * @memberof api.SignTransactionParam\n         * @static\n         * @param {api.ISignTransactionParam} message SignTransactionParam message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        SignTransactionParam.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.storedKeyData != null && Object.hasOwnProperty.call(message, \"storedKeyData\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.storedKeyData);\n            if (message.derivationPath != null && Object.hasOwnProperty.call(message, \"derivationPath\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.derivationPath);\n            if (message.password != null && Object.hasOwnProperty.call(message, \"password\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.password);\n            if (message.coin != null && Object.hasOwnProperty.call(message, \"coin\"))\n                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.coin);\n            if (message.sign_input != null && Object.hasOwnProperty.call(message, \"sign_input\"))\n                $root.ethereum.SignInput.encode(message.sign_input, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Decodes a SignTransactionParam message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.SignTransactionParam\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.SignTransactionParam} SignTransactionParam\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        SignTransactionParam.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.SignTransactionParam();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.storedKeyData = reader.bytes();\n                    break;\n                case 2:\n                    message.derivationPath = reader.string();\n                    break;\n                case 3:\n                    message.password = reader.string();\n                    break;\n                case 4:\n                    message.coin = reader.int32();\n                    break;\n                case 5:\n                    message.sign_input = $root.ethereum.SignInput.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return SignTransactionParam;\n    })();\n\n    api.SignTransactionResp = (function() {\n\n        /**\n         * Properties of a SignTransactionResp.\n         * @memberof api\n         * @interface ISignTransactionResp\n         * @property {ethereum.ISignOutput|null} [sign_output] SignTransactionResp sign_output\n         */\n\n        /**\n         * Constructs a new SignTransactionResp.\n         * @memberof api\n         * @classdesc Represents a SignTransactionResp.\n         * @implements ISignTransactionResp\n         * @constructor\n         * @param {api.ISignTransactionResp=} [properties] Properties to set\n         */\n        function SignTransactionResp(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * SignTransactionResp sign_output.\n         * @member {ethereum.ISignOutput|null|undefined} sign_output\n         * @memberof api.SignTransactionResp\n         * @instance\n         */\n        SignTransactionResp.prototype.sign_output = null;\n\n        // OneOf field names bound to virtual getters and setters\n        let $oneOfFields;\n\n        /**\n         * SignTransactionResp output.\n         * @member {\"sign_output\"|undefined} output\n         * @memberof api.SignTransactionResp\n         * @instance\n         */\n        Object.defineProperty(SignTransactionResp.prototype, \"output\", {\n            get: $util.oneOfGetter($oneOfFields = [\"sign_output\"]),\n            set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Encodes the specified SignTransactionResp message. Does not implicitly {@link api.SignTransactionResp.verify|verify} messages.\n         * @function encode\n         * @memberof api.SignTransactionResp\n         * @static\n         * @param {api.ISignTransactionResp} message SignTransactionResp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        SignTransactionResp.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.sign_output != null && Object.hasOwnProperty.call(message, \"sign_output\"))\n                $root.ethereum.SignOutput.encode(message.sign_output, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Decodes a SignTransactionResp message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.SignTransactionResp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.SignTransactionResp} SignTransactionResp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        SignTransactionResp.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.SignTransactionResp();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.sign_output = $root.ethereum.SignOutput.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return SignTransactionResp;\n    })();\n\n    api.PasswordValidationParam = (function() {\n\n        /**\n         * Properties of a PasswordValidationParam.\n         * @memberof api\n         * @interface IPasswordValidationParam\n         * @property {Uint8Array|null} [storedKeyData] PasswordValidationParam storedKeyData\n         * @property {string|null} [password] PasswordValidationParam password\n         */\n\n        /**\n         * Constructs a new PasswordValidationParam.\n         * @memberof api\n         * @classdesc Represents a PasswordValidationParam.\n         * @implements IPasswordValidationParam\n         * @constructor\n         * @param {api.IPasswordValidationParam=} [properties] Properties to set\n         */\n        function PasswordValidationParam(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * PasswordValidationParam storedKeyData.\n         * @member {Uint8Array} storedKeyData\n         * @memberof api.PasswordValidationParam\n         * @instance\n         */\n        PasswordValidationParam.prototype.storedKeyData = $util.newBuffer([]);\n\n        /**\n         * PasswordValidationParam password.\n         * @member {string} password\n         * @memberof api.PasswordValidationParam\n         * @instance\n         */\n        PasswordValidationParam.prototype.password = \"\";\n\n        /**\n         * Encodes the specified PasswordValidationParam message. Does not implicitly {@link api.PasswordValidationParam.verify|verify} messages.\n         * @function encode\n         * @memberof api.PasswordValidationParam\n         * @static\n         * @param {api.IPasswordValidationParam} message PasswordValidationParam message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        PasswordValidationParam.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.storedKeyData != null && Object.hasOwnProperty.call(message, \"storedKeyData\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.storedKeyData);\n            if (message.password != null && Object.hasOwnProperty.call(message, \"password\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);\n            return writer;\n        };\n\n        /**\n         * Decodes a PasswordValidationParam message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.PasswordValidationParam\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.PasswordValidationParam} PasswordValidationParam\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        PasswordValidationParam.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.PasswordValidationParam();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.storedKeyData = reader.bytes();\n                    break;\n                case 2:\n                    message.password = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return PasswordValidationParam;\n    })();\n\n    api.AddressValidationParam = (function() {\n\n        /**\n         * Properties of an AddressValidationParam.\n         * @memberof api\n         * @interface IAddressValidationParam\n         * @property {string|null} [address] AddressValidationParam address\n         * @property {api.Coin|null} [coin] AddressValidationParam coin\n         */\n\n        /**\n         * Constructs a new AddressValidationParam.\n         * @memberof api\n         * @classdesc Represents an AddressValidationParam.\n         * @implements IAddressValidationParam\n         * @constructor\n         * @param {api.IAddressValidationParam=} [properties] Properties to set\n         */\n        function AddressValidationParam(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * AddressValidationParam address.\n         * @member {string} address\n         * @memberof api.AddressValidationParam\n         * @instance\n         */\n        AddressValidationParam.prototype.address = \"\";\n\n        /**\n         * AddressValidationParam coin.\n         * @member {api.Coin} coin\n         * @memberof api.AddressValidationParam\n         * @instance\n         */\n        AddressValidationParam.prototype.coin = 0;\n\n        /**\n         * Encodes the specified AddressValidationParam message. Does not implicitly {@link api.AddressValidationParam.verify|verify} messages.\n         * @function encode\n         * @memberof api.AddressValidationParam\n         * @static\n         * @param {api.IAddressValidationParam} message AddressValidationParam message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        AddressValidationParam.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.address != null && Object.hasOwnProperty.call(message, \"address\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);\n            if (message.coin != null && Object.hasOwnProperty.call(message, \"coin\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.coin);\n            return writer;\n        };\n\n        /**\n         * Decodes an AddressValidationParam message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.AddressValidationParam\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.AddressValidationParam} AddressValidationParam\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        AddressValidationParam.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.AddressValidationParam();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.address = reader.string();\n                    break;\n                case 2:\n                    message.coin = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return AddressValidationParam;\n    })();\n\n    api.ValidateParam = (function() {\n\n        /**\n         * Properties of a ValidateParam.\n         * @memberof api\n         * @interface IValidateParam\n         * @property {string|null} [privateKey] ValidateParam privateKey\n         * @property {string|null} [mnemonic] ValidateParam mnemonic\n         * @property {string|null} [keyStoreJSON] ValidateParam keyStoreJSON\n         * @property {api.IPasswordValidationParam|null} [storedKeyPassword] ValidateParam storedKeyPassword\n         * @property {api.IAddressValidationParam|null} [addressValidationParam] ValidateParam addressValidationParam\n         */\n\n        /**\n         * Constructs a new ValidateParam.\n         * @memberof api\n         * @classdesc Represents a ValidateParam.\n         * @implements IValidateParam\n         * @constructor\n         * @param {api.IValidateParam=} [properties] Properties to set\n         */\n        function ValidateParam(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ValidateParam privateKey.\n         * @member {string} privateKey\n         * @memberof api.ValidateParam\n         * @instance\n         */\n        ValidateParam.prototype.privateKey = \"\";\n\n        /**\n         * ValidateParam mnemonic.\n         * @member {string} mnemonic\n         * @memberof api.ValidateParam\n         * @instance\n         */\n        ValidateParam.prototype.mnemonic = \"\";\n\n        /**\n         * ValidateParam keyStoreJSON.\n         * @member {string} keyStoreJSON\n         * @memberof api.ValidateParam\n         * @instance\n         */\n        ValidateParam.prototype.keyStoreJSON = \"\";\n\n        /**\n         * ValidateParam storedKeyPassword.\n         * @member {api.IPasswordValidationParam|null|undefined} storedKeyPassword\n         * @memberof api.ValidateParam\n         * @instance\n         */\n        ValidateParam.prototype.storedKeyPassword = null;\n\n        /**\n         * ValidateParam addressValidationParam.\n         * @member {api.IAddressValidationParam|null|undefined} addressValidationParam\n         * @memberof api.ValidateParam\n         * @instance\n         */\n        ValidateParam.prototype.addressValidationParam = null;\n\n        // OneOf field names bound to virtual getters and setters\n        let $oneOfFields;\n\n        /**\n         * ValidateParam input.\n         * @member {\"privateKey\"|\"mnemonic\"|\"keyStoreJSON\"|\"storedKeyPassword\"|\"addressValidationParam\"|undefined} input\n         * @memberof api.ValidateParam\n         * @instance\n         */\n        Object.defineProperty(ValidateParam.prototype, \"input\", {\n            get: $util.oneOfGetter($oneOfFields = [\"privateKey\", \"mnemonic\", \"keyStoreJSON\", \"storedKeyPassword\", \"addressValidationParam\"]),\n            set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Encodes the specified ValidateParam message. Does not implicitly {@link api.ValidateParam.verify|verify} messages.\n         * @function encode\n         * @memberof api.ValidateParam\n         * @static\n         * @param {api.IValidateParam} message ValidateParam message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ValidateParam.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.privateKey != null && Object.hasOwnProperty.call(message, \"privateKey\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.privateKey);\n            if (message.mnemonic != null && Object.hasOwnProperty.call(message, \"mnemonic\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.mnemonic);\n            if (message.keyStoreJSON != null && Object.hasOwnProperty.call(message, \"keyStoreJSON\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.keyStoreJSON);\n            if (message.storedKeyPassword != null && Object.hasOwnProperty.call(message, \"storedKeyPassword\"))\n                $root.api.PasswordValidationParam.encode(message.storedKeyPassword, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n            if (message.addressValidationParam != null && Object.hasOwnProperty.call(message, \"addressValidationParam\"))\n                $root.api.AddressValidationParam.encode(message.addressValidationParam, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Decodes a ValidateParam message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.ValidateParam\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.ValidateParam} ValidateParam\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ValidateParam.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ValidateParam();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.privateKey = reader.string();\n                    break;\n                case 2:\n                    message.mnemonic = reader.string();\n                    break;\n                case 3:\n                    message.keyStoreJSON = reader.string();\n                    break;\n                case 4:\n                    message.storedKeyPassword = $root.api.PasswordValidationParam.decode(reader, reader.uint32());\n                    break;\n                case 5:\n                    message.addressValidationParam = $root.api.AddressValidationParam.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return ValidateParam;\n    })();\n\n    api.ValidateResp = (function() {\n\n        /**\n         * Properties of a ValidateResp.\n         * @memberof api\n         * @interface IValidateResp\n         * @property {boolean|null} [valid] ValidateResp valid\n         */\n\n        /**\n         * Constructs a new ValidateResp.\n         * @memberof api\n         * @classdesc Represents a ValidateResp.\n         * @implements IValidateResp\n         * @constructor\n         * @param {api.IValidateResp=} [properties] Properties to set\n         */\n        function ValidateResp(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ValidateResp valid.\n         * @member {boolean} valid\n         * @memberof api.ValidateResp\n         * @instance\n         */\n        ValidateResp.prototype.valid = false;\n\n        /**\n         * Encodes the specified ValidateResp message. Does not implicitly {@link api.ValidateResp.verify|verify} messages.\n         * @function encode\n         * @memberof api.ValidateResp\n         * @static\n         * @param {api.IValidateResp} message ValidateResp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ValidateResp.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.valid != null && Object.hasOwnProperty.call(message, \"valid\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.valid);\n            return writer;\n        };\n\n        /**\n         * Decodes a ValidateResp message from the specified reader or buffer.\n         * @function decode\n         * @memberof api.ValidateResp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {api.ValidateResp} ValidateResp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ValidateResp.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.api.ValidateResp();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.valid = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return ValidateResp;\n    })();\n\n    return api;\n})();\n\nexport const ethereum = $root.ethereum = (() => {\n\n    /**\n     * Namespace ethereum.\n     * @exports ethereum\n     * @namespace\n     */\n    const ethereum = {};\n\n    ethereum.SignInput = (function() {\n\n        /**\n         * Properties of a SignInput.\n         * @memberof ethereum\n         * @interface ISignInput\n         * @property {number|Long|null} [chain_id] SignInput chain_id\n         * @property {string|null} [nonce] SignInput nonce\n         * @property {string|null} [gas_price] SignInput gas_price\n         * @property {string|null} [gas_limit] SignInput gas_limit\n         * @property {string|null} [max_inclusion_fee_per_gas] SignInput max_inclusion_fee_per_gas\n         * @property {string|null} [max_fee_per_gas] SignInput max_fee_per_gas\n         * @property {string|null} [amount] SignInput amount\n         * @property {string|null} [to_address] SignInput to_address\n         * @property {Uint8Array|null} [payload] SignInput payload\n         */\n\n        /**\n         * Constructs a new SignInput.\n         * @memberof ethereum\n         * @classdesc Represents a SignInput.\n         * @implements ISignInput\n         * @constructor\n         * @param {ethereum.ISignInput=} [properties] Properties to set\n         */\n        function SignInput(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * SignInput chain_id.\n         * @member {number|Long} chain_id\n         * @memberof ethereum.SignInput\n         * @instance\n         */\n        SignInput.prototype.chain_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n        /**\n         * SignInput nonce.\n         * @member {string} nonce\n         * @memberof ethereum.SignInput\n         * @instance\n         */\n        SignInput.prototype.nonce = \"\";\n\n        /**\n         * SignInput gas_price.\n         * @member {string} gas_price\n         * @memberof ethereum.SignInput\n         * @instance\n         */\n        SignInput.prototype.gas_price = \"\";\n\n        /**\n         * SignInput gas_limit.\n         * @member {string} gas_limit\n         * @memberof ethereum.SignInput\n         * @instance\n         */\n        SignInput.prototype.gas_limit = \"\";\n\n        /**\n         * SignInput max_inclusion_fee_per_gas.\n         * @member {string} max_inclusion_fee_per_gas\n         * @memberof ethereum.SignInput\n         * @instance\n         */\n        SignInput.prototype.max_inclusion_fee_per_gas = \"\";\n\n        /**\n         * SignInput max_fee_per_gas.\n         * @member {string} max_fee_per_gas\n         * @memberof ethereum.SignInput\n         * @instance\n         */\n        SignInput.prototype.max_fee_per_gas = \"\";\n\n        /**\n         * SignInput amount.\n         * @member {string} amount\n         * @memberof ethereum.SignInput\n         * @instance\n         */\n        SignInput.prototype.amount = \"\";\n\n        /**\n         * SignInput to_address.\n         * @member {string} to_address\n         * @memberof ethereum.SignInput\n         * @instance\n         */\n        SignInput.prototype.to_address = \"\";\n\n        /**\n         * SignInput payload.\n         * @member {Uint8Array} payload\n         * @memberof ethereum.SignInput\n         * @instance\n         */\n        SignInput.prototype.payload = $util.newBuffer([]);\n\n        /**\n         * Encodes the specified SignInput message. Does not implicitly {@link ethereum.SignInput.verify|verify} messages.\n         * @function encode\n         * @memberof ethereum.SignInput\n         * @static\n         * @param {ethereum.ISignInput} message SignInput message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        SignInput.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.chain_id != null && Object.hasOwnProperty.call(message, \"chain_id\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.chain_id);\n            if (message.nonce != null && Object.hasOwnProperty.call(message, \"nonce\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.nonce);\n            if (message.gas_price != null && Object.hasOwnProperty.call(message, \"gas_price\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.gas_price);\n            if (message.gas_limit != null && Object.hasOwnProperty.call(message, \"gas_limit\"))\n                writer.uint32(/* id 4, wireType 2 =*/34).string(message.gas_limit);\n            if (message.max_inclusion_fee_per_gas != null && Object.hasOwnProperty.call(message, \"max_inclusion_fee_per_gas\"))\n                writer.uint32(/* id 5, wireType 2 =*/42).string(message.max_inclusion_fee_per_gas);\n            if (message.max_fee_per_gas != null && Object.hasOwnProperty.call(message, \"max_fee_per_gas\"))\n                writer.uint32(/* id 6, wireType 2 =*/50).string(message.max_fee_per_gas);\n            if (message.amount != null && Object.hasOwnProperty.call(message, \"amount\"))\n                writer.uint32(/* id 7, wireType 2 =*/58).string(message.amount);\n            if (message.to_address != null && Object.hasOwnProperty.call(message, \"to_address\"))\n                writer.uint32(/* id 8, wireType 2 =*/66).string(message.to_address);\n            if (message.payload != null && Object.hasOwnProperty.call(message, \"payload\"))\n                writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.payload);\n            return writer;\n        };\n\n        /**\n         * Decodes a SignInput message from the specified reader or buffer.\n         * @function decode\n         * @memberof ethereum.SignInput\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ethereum.SignInput} SignInput\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        SignInput.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ethereum.SignInput();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.chain_id = reader.uint64();\n                    break;\n                case 2:\n                    message.nonce = reader.string();\n                    break;\n                case 3:\n                    message.gas_price = reader.string();\n                    break;\n                case 4:\n                    message.gas_limit = reader.string();\n                    break;\n                case 5:\n                    message.max_inclusion_fee_per_gas = reader.string();\n                    break;\n                case 6:\n                    message.max_fee_per_gas = reader.string();\n                    break;\n                case 7:\n                    message.amount = reader.string();\n                    break;\n                case 8:\n                    message.to_address = reader.string();\n                    break;\n                case 9:\n                    message.payload = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return SignInput;\n    })();\n\n    ethereum.SignOutput = (function() {\n\n        /**\n         * Properties of a SignOutput.\n         * @memberof ethereum\n         * @interface ISignOutput\n         * @property {Uint8Array|null} [encoded] SignOutput encoded\n         * @property {number|null} [v] SignOutput v\n         * @property {Uint8Array|null} [r] SignOutput r\n         * @property {Uint8Array|null} [s] SignOutput s\n         * @property {Uint8Array|null} [data] SignOutput data\n         */\n\n        /**\n         * Constructs a new SignOutput.\n         * @memberof ethereum\n         * @classdesc Represents a SignOutput.\n         * @implements ISignOutput\n         * @constructor\n         * @param {ethereum.ISignOutput=} [properties] Properties to set\n         */\n        function SignOutput(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * SignOutput encoded.\n         * @member {Uint8Array} encoded\n         * @memberof ethereum.SignOutput\n         * @instance\n         */\n        SignOutput.prototype.encoded = $util.newBuffer([]);\n\n        /**\n         * SignOutput v.\n         * @member {number} v\n         * @memberof ethereum.SignOutput\n         * @instance\n         */\n        SignOutput.prototype.v = 0;\n\n        /**\n         * SignOutput r.\n         * @member {Uint8Array} r\n         * @memberof ethereum.SignOutput\n         * @instance\n         */\n        SignOutput.prototype.r = $util.newBuffer([]);\n\n        /**\n         * SignOutput s.\n         * @member {Uint8Array} s\n         * @memberof ethereum.SignOutput\n         * @instance\n         */\n        SignOutput.prototype.s = $util.newBuffer([]);\n\n        /**\n         * SignOutput data.\n         * @member {Uint8Array} data\n         * @memberof ethereum.SignOutput\n         * @instance\n         */\n        SignOutput.prototype.data = $util.newBuffer([]);\n\n        /**\n         * Encodes the specified SignOutput message. Does not implicitly {@link ethereum.SignOutput.verify|verify} messages.\n         * @function encode\n         * @memberof ethereum.SignOutput\n         * @static\n         * @param {ethereum.ISignOutput} message SignOutput message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        SignOutput.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.encoded != null && Object.hasOwnProperty.call(message, \"encoded\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encoded);\n            if (message.v != null && Object.hasOwnProperty.call(message, \"v\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.v);\n            if (message.r != null && Object.hasOwnProperty.call(message, \"r\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.r);\n            if (message.s != null && Object.hasOwnProperty.call(message, \"s\"))\n                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.s);\n            if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.data);\n            return writer;\n        };\n\n        /**\n         * Decodes a SignOutput message from the specified reader or buffer.\n         * @function decode\n         * @memberof ethereum.SignOutput\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ethereum.SignOutput} SignOutput\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        SignOutput.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ethereum.SignOutput();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.encoded = reader.bytes();\n                    break;\n                case 2:\n                    message.v = reader.uint32();\n                    break;\n                case 3:\n                    message.r = reader.bytes();\n                    break;\n                case 4:\n                    message.s = reader.bytes();\n                    break;\n                case 5:\n                    message.data = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        return SignOutput;\n    })();\n\n    return ethereum;\n})();\n\nexport { $root as default };\n"],"names":[],"sourceRoot":"","x_google_ignoreList":[]}