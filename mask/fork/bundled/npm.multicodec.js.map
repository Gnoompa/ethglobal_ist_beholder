{"version":3,"file":"bundled/npm.multicodec.js","mappings":"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","sources":["webpack://mask-network/./node_modules/.pnpm/multicodec@0.5.7/node_modules/multicodec/src/constants.js","webpack://mask-network/./node_modules/.pnpm/multicodec@0.5.7/node_modules/multicodec/src/index.js","webpack://mask-network/./node_modules/.pnpm/multicodec@0.5.7/node_modules/multicodec/src/int-table.js","webpack://mask-network/./node_modules/.pnpm/multicodec@0.5.7/node_modules/multicodec/src/print.js","webpack://mask-network/./node_modules/.pnpm/multicodec@0.5.7/node_modules/multicodec/src/util.js","webpack://mask-network/./node_modules/.pnpm/multicodec@0.5.7/node_modules/multicodec/src/varint-table.js","webpack://mask-network/./node_modules/.pnpm/multicodec@1.0.4/node_modules/multicodec/src/constants.js","webpack://mask-network/./node_modules/.pnpm/multicodec@1.0.4/node_modules/multicodec/src/index.js","webpack://mask-network/./node_modules/.pnpm/multicodec@1.0.4/node_modules/multicodec/src/int-table.js","webpack://mask-network/./node_modules/.pnpm/multicodec@1.0.4/node_modules/multicodec/src/print.js","webpack://mask-network/./node_modules/.pnpm/multicodec@1.0.4/node_modules/multicodec/src/util.js","webpack://mask-network/./node_modules/.pnpm/multicodec@1.0.4/node_modules/multicodec/src/varint-table.js"],"sourcesContent":["'use strict'\n\nconst table = require('./base-table.json')\n\n// map for codecConstant -> code\nconst constants = {}\n\nfor (const [name, code] of Object.entries(table)) {\n  constants[name.toUpperCase().replace(/-/g, '_')] = code\n}\n\nmodule.exports = Object.freeze(constants)\n","/**\n * Implementation of the multicodec specification.\n *\n * @module multicodec\n * @example\n * const multicodec = require('multicodec')\n *\n * const prefixedProtobuf = multicodec.addPrefix('protobuf', protobufBuffer)\n * // prefixedProtobuf 0x50...\n *\n */\n'use strict'\n\nconst varint = require('varint')\nconst intTable = require('./int-table')\nconst codecNameToCodeVarint = require('./varint-table')\nconst util = require('./util')\n\nexports = module.exports\n\n/**\n * Prefix a buffer with a multicodec-packed.\n *\n * @param {string|number} multicodecStrOrCode\n * @param {Buffer} data\n * @returns {Buffer}\n */\nexports.addPrefix = (multicodecStrOrCode, data) => {\n  let prefix\n\n  if (Buffer.isBuffer(multicodecStrOrCode)) {\n    prefix = util.varintBufferEncode(multicodecStrOrCode)\n  } else {\n    if (codecNameToCodeVarint[multicodecStrOrCode]) {\n      prefix = codecNameToCodeVarint[multicodecStrOrCode]\n    } else {\n      throw new Error('multicodec not recognized')\n    }\n  }\n  return Buffer.concat([prefix, data])\n}\n\n/**\n * Decapsulate the multicodec-packed prefix from the data.\n *\n * @param {Buffer} data\n * @returns {Buffer}\n */\nexports.rmPrefix = (data) => {\n  varint.decode(data)\n  return data.slice(varint.decode.bytes)\n}\n\n/**\n * Get the codec of the prefixed data.\n * @param {Buffer} prefixedData\n * @returns {string}\n */\nexports.getCodec = (prefixedData) => {\n  const code = varint.decode(prefixedData)\n  const codecName = intTable.get(code)\n  if (codecName === undefined) {\n    throw new Error(`Code ${code} not found`)\n  }\n  return codecName\n}\n\n/**\n * Get the name of the codec.\n * @param {number} codec\n * @returns {string}\n */\nexports.getName = (codec) => {\n  return intTable.get(codec)\n}\n\n/**\n * Get the code of the codec\n * @param {string} name\n * @returns {number}\n */\nexports.getNumber = (name) => {\n  const code = codecNameToCodeVarint[name]\n  if (code === undefined) {\n    throw new Error('Codec `' + name + '` not found')\n  }\n  return util.varintBufferDecode(code)[0]\n}\n\n/**\n * Get the code of the prefixed data.\n * @param {Buffer} prefixedData\n * @returns {number}\n */\nexports.getCode = (prefixedData) => {\n  return varint.decode(prefixedData)\n}\n\n/**\n * Get the code as varint of a codec name.\n * @param {string} codecName\n * @returns {Buffer}\n */\nexports.getCodeVarint = (codecName) => {\n  const code = codecNameToCodeVarint[codecName]\n  if (code === undefined) {\n    throw new Error('Codec `' + codecName + '` not found')\n  }\n  return code\n}\n\n/**\n * Get the varint of a code.\n * @param {Number} code\n * @returns {Array.<number>}\n */\nexports.getVarint = (code) => {\n  return varint.encode(code)\n}\n\n// Make the constants top-level constants\nconst constants = require('./constants')\nObject.assign(exports, constants)\n\n// Human friendly names for printing, e.g. in error messages\nexports.print = require('./print')\n","'use strict'\nconst baseTable = require('./base-table.json')\n\n// map for hexString -> codecName\nconst nameTable = new Map()\n\nfor (const encodingName in baseTable) {\n  const code = baseTable[encodingName]\n  nameTable.set(code, encodingName)\n}\n\nmodule.exports = Object.freeze(nameTable)\n","'use strict'\n\nconst table = require('./base-table.json')\n\n// map for code -> print friendly name\nconst tableByCode = {}\n\nfor (const [name, code] of Object.entries(table)) {\n  if (tableByCode[code] === undefined) tableByCode[code] = name\n}\n\nmodule.exports = Object.freeze(tableByCode)\n","'use strict'\nconst varint = require('varint')\n\nmodule.exports = {\n  numberToBuffer,\n  bufferToNumber,\n  varintBufferEncode,\n  varintBufferDecode,\n  varintEncode\n}\n\nfunction bufferToNumber (buf) {\n  return parseInt(buf.toString('hex'), 16)\n}\n\nfunction numberToBuffer (num) {\n  let hexString = num.toString(16)\n  if (hexString.length % 2 === 1) {\n    hexString = '0' + hexString\n  }\n  return Buffer.from(hexString, 'hex')\n}\n\nfunction varintBufferEncode (input) {\n  return Buffer.from(varint.encode(bufferToNumber(input)))\n}\n\nfunction varintBufferDecode (input) {\n  return numberToBuffer(varint.decode(input))\n}\n\nfunction varintEncode (num) {\n  return Buffer.from(varint.encode(num))\n}\n","'use strict'\n\nconst baseTable = require('./base-table.json')\nconst varintEncode = require('./util').varintEncode\n\n// map for codecName -> codeVarintBuffer\nconst varintTable = {}\n\nfor (const encodingName in baseTable) {\n  const code = baseTable[encodingName]\n  varintTable[encodingName] = varintEncode(code)\n}\n\nmodule.exports = Object.freeze(varintTable)\n","'use strict'\n\nconst table = require('./base-table.json')\n\n// map for codecConstant -> code\nconst constants = {}\n\nfor (const [name, code] of Object.entries(table)) {\n  constants[name.toUpperCase().replace(/-/g, '_')] = code\n}\n\nmodule.exports = Object.freeze(constants)\n","/**\n * Implementation of the multicodec specification.\n *\n * @module multicodec\n * @example\n * const multicodec = require('multicodec')\n *\n * const prefixedProtobuf = multicodec.addPrefix('protobuf', protobufBuffer)\n * // prefixedProtobuf 0x50...\n *\n */\n'use strict'\n\nconst { Buffer } = require('buffer')\nconst varint = require('varint')\nconst intTable = require('./int-table')\nconst codecNameToCodeVarint = require('./varint-table')\nconst util = require('./util')\n\nexports = module.exports\n\n/**\n * Prefix a buffer with a multicodec-packed.\n *\n * @param {string|number} multicodecStrOrCode\n * @param {Buffer} data\n * @returns {Buffer}\n */\nexports.addPrefix = (multicodecStrOrCode, data) => {\n  let prefix\n\n  if (Buffer.isBuffer(multicodecStrOrCode)) {\n    prefix = util.varintBufferEncode(multicodecStrOrCode)\n  } else {\n    if (codecNameToCodeVarint[multicodecStrOrCode]) {\n      prefix = codecNameToCodeVarint[multicodecStrOrCode]\n    } else {\n      throw new Error('multicodec not recognized')\n    }\n  }\n  return Buffer.concat([prefix, data])\n}\n\n/**\n * Decapsulate the multicodec-packed prefix from the data.\n *\n * @param {Buffer} data\n * @returns {Buffer}\n */\nexports.rmPrefix = (data) => {\n  varint.decode(data)\n  return data.slice(varint.decode.bytes)\n}\n\n/**\n * Get the codec of the prefixed data.\n * @param {Buffer} prefixedData\n * @returns {string}\n */\nexports.getCodec = (prefixedData) => {\n  const code = varint.decode(prefixedData)\n  const codecName = intTable.get(code)\n  if (codecName === undefined) {\n    throw new Error(`Code ${code} not found`)\n  }\n  return codecName\n}\n\n/**\n * Get the name of the codec.\n * @param {number} codec\n * @returns {string}\n */\nexports.getName = (codec) => {\n  return intTable.get(codec)\n}\n\n/**\n * Get the code of the codec\n * @param {string} name\n * @returns {number}\n */\nexports.getNumber = (name) => {\n  const code = codecNameToCodeVarint[name]\n  if (code === undefined) {\n    throw new Error('Codec `' + name + '` not found')\n  }\n  return util.varintBufferDecode(code)[0]\n}\n\n/**\n * Get the code of the prefixed data.\n * @param {Buffer} prefixedData\n * @returns {number}\n */\nexports.getCode = (prefixedData) => {\n  return varint.decode(prefixedData)\n}\n\n/**\n * Get the code as varint of a codec name.\n * @param {string} codecName\n * @returns {Buffer}\n */\nexports.getCodeVarint = (codecName) => {\n  const code = codecNameToCodeVarint[codecName]\n  if (code === undefined) {\n    throw new Error('Codec `' + codecName + '` not found')\n  }\n  return code\n}\n\n/**\n * Get the varint of a code.\n * @param {Number} code\n * @returns {Array.<number>}\n */\nexports.getVarint = (code) => {\n  return varint.encode(code)\n}\n\n// Make the constants top-level constants\nconst constants = require('./constants')\nObject.assign(exports, constants)\n\n// Human friendly names for printing, e.g. in error messages\nexports.print = require('./print')\n","'use strict'\nconst baseTable = require('./base-table.json')\n\n// map for hexString -> codecName\nconst nameTable = new Map()\n\nfor (const encodingName in baseTable) {\n  const code = baseTable[encodingName]\n  nameTable.set(code, encodingName)\n}\n\nmodule.exports = Object.freeze(nameTable)\n","'use strict'\n\nconst table = require('./base-table.json')\n\n// map for code -> print friendly name\nconst tableByCode = {}\n\nfor (const [name, code] of Object.entries(table)) {\n  if (tableByCode[code] === undefined) tableByCode[code] = name\n}\n\nmodule.exports = Object.freeze(tableByCode)\n","'use strict'\nconst varint = require('varint')\nconst { Buffer } = require('buffer')\n\nmodule.exports = {\n  numberToBuffer,\n  bufferToNumber,\n  varintBufferEncode,\n  varintBufferDecode,\n  varintEncode\n}\n\nfunction bufferToNumber (buf) {\n  return parseInt(buf.toString('hex'), 16)\n}\n\nfunction numberToBuffer (num) {\n  let hexString = num.toString(16)\n  if (hexString.length % 2 === 1) {\n    hexString = '0' + hexString\n  }\n  return Buffer.from(hexString, 'hex')\n}\n\nfunction varintBufferEncode (input) {\n  return Buffer.from(varint.encode(bufferToNumber(input)))\n}\n\nfunction varintBufferDecode (input) {\n  return numberToBuffer(varint.decode(input))\n}\n\nfunction varintEncode (num) {\n  return Buffer.from(varint.encode(num))\n}\n","'use strict'\n\nconst baseTable = require('./base-table.json')\nconst varintEncode = require('./util').varintEncode\n\n// map for codecName -> codeVarintBuffer\nconst varintTable = {}\n\nfor (const encodingName in baseTable) {\n  const code = baseTable[encodingName]\n  varintTable[encodingName] = varintEncode(code)\n}\n\nmodule.exports = Object.freeze(varintTable)\n"],"names":[],"sourceRoot":"","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11]}