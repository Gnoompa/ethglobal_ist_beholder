{"version":3,"file":"bundled/npm-ns.ethereumjs.util.js","mappings":";;;;;;;AAAa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB,GAAG,yBAAyB,GAAG,2BAA2B,GAAG,qBAAqB,GAAG,mBAAmB,GAAG,oBAAoB,GAAG,wBAAwB,GAAG,uBAAuB,GAAG,uBAAuB,GAAG,oBAAoB,GAAG,qBAAqB,GAAG,sBAAsB,GAAG,wBAAwB,GAAG,uBAAuB,GAAG,8BAA8B,GAAG,yBAAyB,GAAG,sBAAsB,GAAG,eAAe;AAC3c,cAAc,mBAAO,CAAC,KAAiB;AACvC,iBAAiB,mBAAO,CAAC,IAA8B;AACvD,oBAAoB,mBAAO,CAAC,KAAiC;AAC7D,gBAAgB,mBAAO,CAAC,KAA6B;AACrD,gBAAgB,mBAAO,CAAC,KAAS;AACjC,oBAAoB,mBAAO,CAAC,KAAa;AACzC,kBAAkB,mBAAO,CAAC,KAAW;AACrC,mBAAmB,mBAAO,CAAC,IAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAwC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,GAAG;AAC9B;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA,WAAW,MAAM;AACjB;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,MAAM,SAAS,MAAM;AACjE;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,MAAM,SAAS,MAAM;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,oBAAoB;AACpB,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;;;;;;;;;AC9TX;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe;AACf,kBAAkB,mBAAO,CAAC,KAAW;AACrC,gBAAgB,mBAAO,CAAC,KAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA,eAAe;;;;;;;;AClHF;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB;AACzB,iBAAiB,mBAAO,CAAC,KAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,IAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;;;;;;;;ACvKZ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B,GAAG,8BAA8B,GAAG,mBAAmB,GAAG,mBAAmB,GAAG,mBAAmB,GAAG,+BAA+B,GAAG,gBAAgB,GAAG,cAAc,GAAG,aAAa,GAAG,oBAAoB,GAAG,kBAAkB,GAAG,kBAAkB,GAAG,mBAAmB,GAAG,sBAAsB,GAAG,sBAAsB,GAAG,mBAAmB,GAAG,gBAAgB,GAAG,sBAAsB,GAAG,kBAAkB,GAAG,mBAAmB,GAAG,sBAAsB,GAAG,qBAAqB,GAAG,aAAa,GAAG,mBAAmB,GAAG,gBAAgB;AACpjB,kBAAkB,mBAAO,CAAC,KAAW;AACrC,mBAAmB,mBAAO,CAAC,IAAY;AACvC;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA,6DAA6D,EAAE;AAC/D;AACA,gBAAgB,eAAe;AAC/B;AACA,gBAAgB;AAChB;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA,QAAQ,MAAM;AACd,eAAe,MAAM;AACrB;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA,0IAA0I,EAAE;AAC5I;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,EAAE;AAClF;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,eAAe,cAAc,MAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,eAAe,cAAc,MAAM;AACnC;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,MAAM;AAC5B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,MAAM;AAC5B;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,MAAM;AACd,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,GAAG,wCAAwC,kBAAkB;AAC5F;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,2BAA2B;;;;;;;;AChWd;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mCAAmC,GAAG,wBAAwB,GAAG,qBAAqB,GAAG,uBAAuB,GAAG,2BAA2B,GAAG,6BAA6B,GAAG,sBAAsB,GAAG,wBAAwB,GAAG,kBAAkB,GAAG,6BAA6B,GAAG,uBAAuB,GAAG,0BAA0B,GAAG,mBAAmB,GAAG,kBAAkB;AACzX,iBAAiB,mBAAO,CAAC,IAAQ;AACjC,oBAAoB,mBAAO,CAAC,KAAiC;AAC7D;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,uBAAuB;AACvB,6BAA6B;AAC7B;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,wBAAwB;AACxB,mCAAmC;;;;;;;;;ACrDtB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB,GAAG,qBAAqB,GAAG,sBAAsB,GAAG,yBAAyB;AACnG,mBAAmB,mBAAO,CAAC,IAAY;AACvC;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA,wFAAwF,MAAM;AAC9F;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA,SAAS,MAAM;AACf,uEAAuE,MAAM;AAC7E;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA,8EAA8E,MAAM;AACpF;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA,wEAAwE,MAAM;AAC9E;AACA;AACA;AACA,sBAAsB;;;;;;;;AC/CT;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,GAAG,sBAAsB,GAAG,iBAAiB,GAAG,mBAAmB,GAAG,qBAAqB,GAAG,eAAe,GAAG,qBAAqB,GAAG,gBAAgB,GAAG,iBAAiB,GAAG,0BAA0B,GAAG,WAAW;AACtO;AACA;AACA;AACA,aAAa,mBAAO,CAAC,KAAa;AAClC;AACA;AACA;AACA,aAAa,mBAAO,CAAC,KAAS;AAC9B;AACA;AACA;AACA,aAAa,mBAAO,CAAC,KAAW;AAChC;AACA;AACA;AACA,aAAa,mBAAO,CAAC,KAAW;AAChC;AACA;AACA;AACA,aAAa,mBAAO,CAAC,KAAc;AACnC;AACA;AACA;AACA,aAAa,mBAAO,CAAC,KAAa;AAClC;AACA;AACA;AACA,aAAa,mBAAO,CAAC,KAAS;AAC9B;AACA;AACA;AACA,wCAA8B;AAC9B;AACA;AACA;AACA,aAAa,mBAAO,CAAC,KAAS;AAC9B;AACA;AACA;AACA,aAAa,mBAAO,CAAC,KAAqB;AAC1C,iBAAiB,mBAAO,CAAC,IAAY;AACrC,sDAAqD,EAAE,qCAAqC,yCAAyC,EAAC;AACtI,6CAA4C,EAAE,qCAAqC,gCAAgC,EAAC;AACpH,4CAA2C,EAAE,qCAAqC,+BAA+B,EAAC;AAClH,iDAAgD,EAAE,qCAAqC,oCAAoC,EAAC;AAC5H,2CAA0C,EAAE,qCAAqC,8BAA8B,EAAC;AAChH,iDAAgD,EAAE,qCAAqC,oCAAoC,EAAC;AAC5H,+CAA8C,EAAE,qCAAqC,kCAAkC,EAAC;AACxH,6CAA4C,EAAE,qCAAqC,gCAAgC,EAAC;AACpH,kDAAiD,EAAE,qCAAqC,qCAAqC,EAAC;AAC9H,2CAA0C,EAAE,qCAAqC,8BAA8B,EAAC;AAChH,aAAa,mBAAO,CAAC,KAAQ;;;;;;;;;ACpEhB;AACb;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,GAAG,eAAe,GAAG,iBAAiB,GAAG,gBAAgB,GAAG,eAAe,GAAG,0BAA0B,GAAG,qBAAqB,GAAG,iBAAiB,GAAG,sBAAsB,GAAG,qBAAqB;AACxN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,WAAW;AACjG;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,WAAW;AAC7F;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,SAAS;AACtF;AACA;AACA,gBAAgB,EAAE;AAClB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,WAAW;AACpG;AACA,WAAW,MAAM;AACjB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2GAA2G,gBAAgB;AAC3H;AACA;AACA,yGAAyG,cAAc;AACvH;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB,gBAAgB,uDAAuD;AACvE;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA,kCAAkC,EAAE;AACpC;AACA,gBAAgB,IAAI;AACpB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa,eAAe,GAAG,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,cAAc;AACrG;AACA;AACA,yFAAyF,cAAc;AACvG;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA,8EAA8E,aAAa;AAC3F;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;;;;;;;AC7LN;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;;;;;;;;AC3CC;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B,GAAG,wBAAwB,GAAG,kBAAkB,GAAG,oBAAoB,GAAG,gBAAgB,GAAG,iBAAiB,GAAG,cAAc;AAC1J,iBAAiB,mBAAO,CAAC,IAA8B;AACvD,oBAAoB,mBAAO,CAAC,KAAiC;AAC7D,gBAAgB,mBAAO,CAAC,KAAS;AACjC,oBAAoB,mBAAO,CAAC,KAAa;AACzC,kBAAkB,mBAAO,CAAC,KAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,6BAA6B;AAChH,cAAc,MAAM;AACpB,cAAc,MAAM;AACpB;AACA;AACA;AACA,aAAa;AACb;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,MAAM;AAC5B;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,MAAM;AAC1C;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA,oCAAoC,MAAM;AAC1C;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,MAAM,yCAAyC,eAAe;AACjF,WAAW,MAAM,8BAA8B,MAAM;AACrD;AACA,2BAA2B;;;;;;;;AC9Jd;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,GAAG,kBAAkB,GAAG,eAAe,GAAG,oBAAoB,GAAG,iBAAiB;AACrG,cAAc,mBAAO,CAAC,KAAgB;AACtC,oBAAoB,mBAAO,CAAC,KAAa;AACzC,iBAAiB;AACjB,oBAAoB;AACpB,eAAe;AACf,kBAAkB;AAClB;AACA;AACA;AACA;AACA,CAAC,IAAI,0CAA0C;AAC/C,mBAAmB;;;;;;;;ACdN;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,GAAG,kBAAkB;AACnC,gBAAgB,mBAAO,CAAC,KAAS;AACjC,mBAAmB,mBAAO,CAAC,IAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC,kBAAkB,KAAK;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,MAAM;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;;;;;;;AC/CD;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB;AACnB;AACA,mBAAmB;;;;;;;;;ACJN;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB,kBAAkB,mBAAO,CAAC,KAAW;AACrC,gBAAgB,mBAAO,CAAC,KAAS;AACjC,gBAAgB,mBAAO,CAAC,KAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kGAAkG;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,uBAAuB;AACnG;AACA;AACA,+CAA+C,wCAAwC;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yCAAyC;AACzD;AACA,cAAc,MAAM;AACpB;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;;;;;;;;ACrFL;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB,GAAG,yBAAyB,GAAG,2BAA2B,GAAG,qBAAqB,GAAG,mBAAmB,GAAG,oBAAoB,GAAG,wBAAwB,GAAG,uBAAuB,GAAG,uBAAuB,GAAG,oBAAoB,GAAG,qBAAqB,GAAG,sBAAsB,GAAG,wBAAwB,GAAG,uBAAuB,GAAG,8BAA8B,GAAG,yBAAyB,GAAG,sBAAsB,GAAG,eAAe;AAC3c,cAAc,mBAAO,CAAC,KAAiB;AACvC,iBAAiB,mBAAO,CAAC,KAA8B;AACvD,oBAAoB,mBAAO,CAAC,KAAiC;AAC7D,gBAAgB,mBAAO,CAAC,KAA6B;AACrD,gBAAgB,mBAAO,CAAC,KAAS;AACjC,oBAAoB,mBAAO,CAAC,KAAa;AACzC,kBAAkB,mBAAO,CAAC,KAAW;AACrC,mBAAmB,mBAAO,CAAC,KAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAwC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,GAAG;AAC9B;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA,WAAW,MAAM;AACjB;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,MAAM,SAAS,MAAM;AACjE;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,MAAM,SAAS,MAAM;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,oBAAoB;AACpB,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;;;;;;;;;AC9TX;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe;AACf,kBAAkB,mBAAO,CAAC,KAAW;AACrC,gBAAgB,mBAAO,CAAC,KAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA,eAAe;;;;;;;;AClHF;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB;AACzB,iBAAiB,mBAAO,CAAC,KAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,IAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;;;;;;;;ACvKZ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B,GAAG,8BAA8B,GAAG,mBAAmB,GAAG,mBAAmB,GAAG,mBAAmB,GAAG,+BAA+B,GAAG,gBAAgB,GAAG,cAAc,GAAG,aAAa,GAAG,oBAAoB,GAAG,kBAAkB,GAAG,kBAAkB,GAAG,mBAAmB,GAAG,sBAAsB,GAAG,sBAAsB,GAAG,mBAAmB,GAAG,gBAAgB,GAAG,sBAAsB,GAAG,kBAAkB,GAAG,mBAAmB,GAAG,sBAAsB,GAAG,qBAAqB,GAAG,aAAa,GAAG,mBAAmB,GAAG,gBAAgB;AACpjB,kBAAkB,mBAAO,CAAC,KAAW;AACrC,mBAAmB,mBAAO,CAAC,KAAY;AACvC;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA,6DAA6D,EAAE;AAC/D;AACA,gBAAgB,eAAe;AAC/B;AACA,gBAAgB;AAChB;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA,QAAQ,MAAM;AACd,eAAe,MAAM;AACrB;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA,0IAA0I,EAAE;AAC5I;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,EAAE;AAClF;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,eAAe,cAAc,MAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,eAAe,cAAc,MAAM;AACnC;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,MAAM;AAC5B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,MAAM;AAC5B;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,MAAM;AACd,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,GAAG,wCAAwC,kBAAkB;AAC5F;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,2BAA2B;;;;;;;;AChWd;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mCAAmC,GAAG,wBAAwB,GAAG,qBAAqB,GAAG,uBAAuB,GAAG,2BAA2B,GAAG,6BAA6B,GAAG,sBAAsB,GAAG,wBAAwB,GAAG,kBAAkB,GAAG,6BAA6B,GAAG,uBAAuB,GAAG,0BAA0B,GAAG,mBAAmB,GAAG,kBAAkB;AACzX,iBAAiB,mBAAO,CAAC,IAAQ;AACjC,oBAAoB,mBAAO,CAAC,KAAiC;AAC7D;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,uBAAuB;AACvB,6BAA6B;AAC7B;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,wBAAwB;AACxB,mCAAmC;;;;;;;;ACrDtB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B,GAAG,sBAAsB,GAAG,6BAA6B,GAAG,sBAAsB,GAAG,qBAAqB;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,6BAA6B,qBAAqB;AAClD;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACvFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB,GAAG,qBAAqB,GAAG,sBAAsB,GAAG,yBAAyB;AACnG,mBAAmB,mBAAO,CAAC,KAAY;AACvC;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA,wFAAwF,MAAM;AAC9F;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA,SAAS,MAAM;AACf,uEAAuE,MAAM;AAC7E;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA,8EAA8E,MAAM;AACpF;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA,wEAAwE,MAAM;AAC9E;AACA;AACA;AACA,sBAAsB;;;;;;;;AC/CT;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,GAAG,sBAAsB,GAAG,iBAAiB,GAAG,mBAAmB,GAAG,qBAAqB,GAAG,eAAe,GAAG,qBAAqB,GAAG,gBAAgB,GAAG,iBAAiB,GAAG,0BAA0B;AACxN;AACA;AACA;AACA,aAAa,mBAAO,CAAC,KAAa;AAClC;AACA;AACA;AACA,aAAa,mBAAO,CAAC,KAAS;AAC9B;AACA;AACA;AACA,aAAa,mBAAO,CAAC,KAAW;AAChC;AACA;AACA;AACA,aAAa,mBAAO,CAAC,KAAW;AAChC;AACA;AACA;AACA,aAAa,mBAAO,CAAC,KAAc;AACnC;AACA;AACA;AACA,aAAa,mBAAO,CAAC,KAAa;AAClC;AACA;AACA;AACA,aAAa,mBAAO,CAAC,KAAS;AAC9B;AACA;AACA;AACA,aAAa,mBAAO,CAAC,KAAS;AAC9B;AACA;AACA;AACA,aAAa,mBAAO,CAAC,KAAY;AACjC;AACA;AACA;AACA,aAAa,mBAAO,CAAC,KAAqB;AAC1C,iBAAiB,mBAAO,CAAC,KAAY;AACrC,sDAAqD,EAAE,qCAAqC,yCAAyC,EAAC;AACtI,6CAA4C,EAAE,qCAAqC,gCAAgC,EAAC;AACpH,4CAA2C,EAAE,qCAAqC,+BAA+B,EAAC;AAClH,iDAAgD,EAAE,qCAAqC,oCAAoC,EAAC;AAC5H,2CAA0C,EAAE,qCAAqC,8BAA8B,EAAC;AAChH,iDAAgD,EAAE,qCAAqC,oCAAoC,EAAC;AAC5H,+CAA8C,EAAE,qCAAqC,kCAAkC,EAAC;AACxH,6CAA4C,EAAE,qCAAqC,gCAAgC,EAAC;AACpH,kDAAiD,EAAE,qCAAqC,qCAAqC,EAAC;AAC9H,2CAA0C,EAAE,qCAAqC,8BAA8B,EAAC;AAChH,aAAa,mBAAO,CAAC,KAAQ;AAC7B,aAAa,mBAAO,CAAC,IAAY;;;;;;;;;ACrEpB;AACb;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,GAAG,eAAe,GAAG,iBAAiB,GAAG,gBAAgB,GAAG,eAAe,GAAG,0BAA0B,GAAG,qBAAqB,GAAG,iBAAiB,GAAG,sBAAsB,GAAG,qBAAqB;AACxN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,WAAW;AACjG;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,WAAW;AAC7F;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,SAAS;AACtF;AACA;AACA,gBAAgB,EAAE;AAClB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,WAAW;AACpG;AACA,WAAW,MAAM;AACjB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2GAA2G,gBAAgB;AAC3H;AACA;AACA,yGAAyG,cAAc;AACvH;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB,gBAAgB,uDAAuD;AACvE;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA,kCAAkC,EAAE;AACpC;AACA,gBAAgB,IAAI;AACpB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa,eAAe,GAAG,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,cAAc;AACrG;AACA;AACA,yFAAyF,cAAc;AACvG;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA,8EAA8E,aAAa;AAC3F;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;;;;;;;AC7LN;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;;;;;;;AC3CC;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,GAAG,yBAAyB;AAC/C,qBAAqB,mBAAO,CAAC,KAAY;AACzC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;;;;;;;;AC/BN;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B,GAAG,wBAAwB,GAAG,kBAAkB,GAAG,oBAAoB,GAAG,gBAAgB,GAAG,iBAAiB,GAAG,cAAc;AAC1J,iBAAiB,mBAAO,CAAC,KAA8B;AACvD,oBAAoB,mBAAO,CAAC,KAAiC;AAC7D,gBAAgB,mBAAO,CAAC,KAAS;AACjC,oBAAoB,mBAAO,CAAC,KAAa;AACzC,kBAAkB,mBAAO,CAAC,KAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,cAAc,MAAM;AACpB;AACA;AACA;AACA,aAAa;AACb;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,MAAM;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,MAAM;AAC1C;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA,oCAAoC,MAAM;AAC1C;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,MAAM,yCAAyC,eAAe;AACjF,WAAW,MAAM,8BAA8B,MAAM;AACrD;AACA,2BAA2B;;;;;;;;AChKd;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,GAAG,kBAAkB;AACnC,gBAAgB,mBAAO,CAAC,KAAS;AACjC,mBAAmB,mBAAO,CAAC,KAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC,kBAAkB,KAAK;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,MAAM;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;;;;;;;AC/CD;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB;AACnB;AACA,mBAAmB;;;;;;;;;ACJN;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB,kBAAkB,mBAAO,CAAC,KAAW;AACrC,gBAAgB,mBAAO,CAAC,KAAS;AACjC,gBAAgB,mBAAO,CAAC,KAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kGAAkG;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,uBAAuB;AACnG;AACA;AACA,+CAA+C,wCAAwC;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yCAAyC;AACzD;AACA,cAAc,MAAM;AACpB;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB","sources":["webpack://mask-network/./node_modules/.pnpm/@ethereumjs+util@8.0.5/node_modules/@ethereumjs/util/dist/account.js","webpack://mask-network/./node_modules/.pnpm/@ethereumjs+util@8.0.5/node_modules/@ethereumjs/util/dist/address.js","webpack://mask-network/./node_modules/.pnpm/@ethereumjs+util@8.0.5/node_modules/@ethereumjs/util/dist/asyncEventEmitter.js","webpack://mask-network/./node_modules/.pnpm/@ethereumjs+util@8.0.5/node_modules/@ethereumjs/util/dist/bytes.js","webpack://mask-network/./node_modules/.pnpm/@ethereumjs+util@8.0.5/node_modules/@ethereumjs/util/dist/constants.js","webpack://mask-network/./node_modules/.pnpm/@ethereumjs+util@8.0.5/node_modules/@ethereumjs/util/dist/helpers.js","webpack://mask-network/./node_modules/.pnpm/@ethereumjs+util@8.0.5/node_modules/@ethereumjs/util/dist/index.js","webpack://mask-network/./node_modules/.pnpm/@ethereumjs+util@8.0.5/node_modules/@ethereumjs/util/dist/internal.js","webpack://mask-network/./node_modules/.pnpm/@ethereumjs+util@8.0.5/node_modules/@ethereumjs/util/dist/lock.js","webpack://mask-network/./node_modules/.pnpm/@ethereumjs+util@8.0.5/node_modules/@ethereumjs/util/dist/signature.js","webpack://mask-network/./node_modules/.pnpm/@ethereumjs+util@8.0.5/node_modules/@ethereumjs/util/dist/ssz.js","webpack://mask-network/./node_modules/.pnpm/@ethereumjs+util@8.0.5/node_modules/@ethereumjs/util/dist/types.js","webpack://mask-network/./node_modules/.pnpm/@ethereumjs+util@8.0.5/node_modules/@ethereumjs/util/dist/units.js","webpack://mask-network/./node_modules/.pnpm/@ethereumjs+util@8.0.5/node_modules/@ethereumjs/util/dist/withdrawal.js","webpack://mask-network/./node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/account.js","webpack://mask-network/./node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/address.js","webpack://mask-network/./node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/asyncEventEmitter.js","webpack://mask-network/./node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/bytes.js","webpack://mask-network/./node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/constants.js","webpack://mask-network/./node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/encoding.js","webpack://mask-network/./node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/helpers.js","webpack://mask-network/./node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/index.js","webpack://mask-network/./node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/internal.js","webpack://mask-network/./node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/lock.js","webpack://mask-network/./node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/provider.js","webpack://mask-network/./node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/signature.js","webpack://mask-network/./node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/types.js","webpack://mask-network/./node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/units.js","webpack://mask-network/./node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/withdrawal.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.accountBodyToRLP = exports.accountBodyToSlim = exports.accountBodyFromSlim = exports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;\nconst rlp_1 = require(\"@ethereumjs/rlp\");\nconst keccak_1 = require(\"ethereum-cryptography/keccak\");\nconst secp256k1_1 = require(\"ethereum-cryptography/secp256k1\");\nconst utils_1 = require(\"ethereum-cryptography/utils\");\nconst bytes_1 = require(\"./bytes\");\nconst constants_1 = require(\"./constants\");\nconst helpers_1 = require(\"./helpers\");\nconst internal_1 = require(\"./internal\");\nconst _0n = BigInt(0);\nclass Account {\n    /**\n     * This constructor assigns and validates the values.\n     * Use the static factory methods to assist in creating an Account from varying data types.\n     */\n    constructor(nonce = _0n, balance = _0n, storageRoot = constants_1.KECCAK256_RLP, codeHash = constants_1.KECCAK256_NULL) {\n        this.nonce = nonce;\n        this.balance = balance;\n        this.storageRoot = storageRoot;\n        this.codeHash = codeHash;\n        this._validate();\n    }\n    static fromAccountData(accountData) {\n        const { nonce, balance, storageRoot, codeHash } = accountData;\n        return new Account(nonce !== undefined ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(nonce)) : undefined, balance !== undefined ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(balance)) : undefined, storageRoot !== undefined ? (0, bytes_1.toBuffer)(storageRoot) : undefined, codeHash !== undefined ? (0, bytes_1.toBuffer)(codeHash) : undefined);\n    }\n    static fromRlpSerializedAccount(serialized) {\n        const values = (0, bytes_1.arrToBufArr)(rlp_1.RLP.decode(Uint8Array.from(serialized)));\n        if (!Array.isArray(values)) {\n            throw new Error('Invalid serialized account input. Must be array');\n        }\n        return this.fromValuesArray(values);\n    }\n    static fromValuesArray(values) {\n        const [nonce, balance, storageRoot, codeHash] = values;\n        return new Account((0, bytes_1.bufferToBigInt)(nonce), (0, bytes_1.bufferToBigInt)(balance), storageRoot, codeHash);\n    }\n    _validate() {\n        if (this.nonce < _0n) {\n            throw new Error('nonce must be greater than zero');\n        }\n        if (this.balance < _0n) {\n            throw new Error('balance must be greater than zero');\n        }\n        if (this.storageRoot.length !== 32) {\n            throw new Error('storageRoot must have a length of 32');\n        }\n        if (this.codeHash.length !== 32) {\n            throw new Error('codeHash must have a length of 32');\n        }\n    }\n    /**\n     * Returns a Buffer Array of the raw Buffers for the account, in order.\n     */\n    raw() {\n        return [\n            (0, bytes_1.bigIntToUnpaddedBuffer)(this.nonce),\n            (0, bytes_1.bigIntToUnpaddedBuffer)(this.balance),\n            this.storageRoot,\n            this.codeHash,\n        ];\n    }\n    /**\n     * Returns the RLP serialization of the account as a `Buffer`.\n     */\n    serialize() {\n        return Buffer.from(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)(this.raw())));\n    }\n    /**\n     * Returns a `Boolean` determining if the account is a contract.\n     */\n    isContract() {\n        return !this.codeHash.equals(constants_1.KECCAK256_NULL);\n    }\n    /**\n     * Returns a `Boolean` determining if the account is empty complying to the definition of\n     * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n     * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n     */\n    isEmpty() {\n        return this.balance === _0n && this.nonce === _0n && this.codeHash.equals(constants_1.KECCAK256_NULL);\n    }\n}\nexports.Account = Account;\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\nconst isValidAddress = function (hexAddress) {\n    try {\n        (0, helpers_1.assertIsString)(hexAddress);\n    }\n    catch (e) {\n        return false;\n    }\n    return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);\n};\nexports.isValidAddress = isValidAddress;\n/**\n * Returns a checksummed address.\n *\n * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not\n * backwards compatible to the original widely adopted checksum format standard introduced in\n * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.\n * Usage of this EIP is therefore discouraged unless you have a very targeted use case.\n */\nconst toChecksumAddress = function (hexAddress, eip1191ChainId) {\n    (0, helpers_1.assertIsHexString)(hexAddress);\n    const address = (0, internal_1.stripHexPrefix)(hexAddress).toLowerCase();\n    let prefix = '';\n    if (eip1191ChainId !== undefined) {\n        const chainId = (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(eip1191ChainId));\n        prefix = chainId.toString() + '0x';\n    }\n    const buf = Buffer.from(prefix + address, 'utf8');\n    const hash = (0, utils_1.bytesToHex)((0, keccak_1.keccak256)(buf));\n    let ret = '0x';\n    for (let i = 0; i < address.length; i++) {\n        if (parseInt(hash[i], 16) >= 8) {\n            ret += address[i].toUpperCase();\n        }\n        else {\n            ret += address[i];\n        }\n    }\n    return ret;\n};\nexports.toChecksumAddress = toChecksumAddress;\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\nconst isValidChecksumAddress = function (hexAddress, eip1191ChainId) {\n    return (0, exports.isValidAddress)(hexAddress) && (0, exports.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;\n};\nexports.isValidChecksumAddress = isValidChecksumAddress;\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\nconst generateAddress = function (from, nonce) {\n    (0, helpers_1.assertIsBuffer)(from);\n    (0, helpers_1.assertIsBuffer)(nonce);\n    if ((0, bytes_1.bufferToBigInt)(nonce) === BigInt(0)) {\n        // in RLP we want to encode null in the case of zero nonce\n        // read the RLP documentation for an answer if you dare\n        return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([from, null])))).slice(-20);\n    }\n    // Only take the lower 160bits of the hash\n    return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([from, nonce])))).slice(-20);\n};\nexports.generateAddress = generateAddress;\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\nconst generateAddress2 = function (from, salt, initCode) {\n    (0, helpers_1.assertIsBuffer)(from);\n    (0, helpers_1.assertIsBuffer)(salt);\n    (0, helpers_1.assertIsBuffer)(initCode);\n    if (from.length !== 20) {\n        throw new Error('Expected from to be of length 20');\n    }\n    if (salt.length !== 32) {\n        throw new Error('Expected salt to be of length 32');\n    }\n    const address = (0, keccak_1.keccak256)(Buffer.concat([Buffer.from('ff', 'hex'), from, salt, (0, keccak_1.keccak256)(initCode)]));\n    return (0, bytes_1.toBuffer)(address).slice(-20);\n};\nexports.generateAddress2 = generateAddress2;\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\nconst isValidPrivate = function (privateKey) {\n    return secp256k1_1.utils.isValidPrivateKey(privateKey);\n};\nexports.isValidPrivate = isValidPrivate;\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nconst isValidPublic = function (publicKey, sanitize = false) {\n    (0, helpers_1.assertIsBuffer)(publicKey);\n    if (publicKey.length === 64) {\n        // Convert to SEC1 for secp256k1\n        // Automatically checks whether point is on curve\n        try {\n            secp256k1_1.Point.fromHex(Buffer.concat([Buffer.from([4]), publicKey]));\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    if (!sanitize) {\n        return false;\n    }\n    try {\n        secp256k1_1.Point.fromHex(publicKey);\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n};\nexports.isValidPublic = isValidPublic;\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nconst pubToAddress = function (pubKey, sanitize = false) {\n    (0, helpers_1.assertIsBuffer)(pubKey);\n    if (sanitize && pubKey.length !== 64) {\n        pubKey = Buffer.from(secp256k1_1.Point.fromHex(pubKey).toRawBytes(false).slice(1));\n    }\n    if (pubKey.length !== 64) {\n        throw new Error('Expected pubKey to be of length 64');\n    }\n    // Only take the lower 160bits of the hash\n    return Buffer.from((0, keccak_1.keccak256)(pubKey)).slice(-20);\n};\nexports.pubToAddress = pubToAddress;\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nconst privateToPublic = function (privateKey) {\n    (0, helpers_1.assertIsBuffer)(privateKey);\n    // skip the type flag and use the X, Y points\n    return Buffer.from(secp256k1_1.Point.fromPrivateKey(privateKey).toRawBytes(false).slice(1));\n};\nexports.privateToPublic = privateToPublic;\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nconst privateToAddress = function (privateKey) {\n    return (0, exports.publicToAddress)((0, exports.privateToPublic)(privateKey));\n};\nexports.privateToAddress = privateToAddress;\n/**\n * Converts a public key to the Ethereum format.\n */\nconst importPublic = function (publicKey) {\n    (0, helpers_1.assertIsBuffer)(publicKey);\n    if (publicKey.length !== 64) {\n        publicKey = Buffer.from(secp256k1_1.Point.fromHex(publicKey).toRawBytes(false).slice(1));\n    }\n    return publicKey;\n};\nexports.importPublic = importPublic;\n/**\n * Returns the zero address.\n */\nconst zeroAddress = function () {\n    const addressLength = 20;\n    const addr = (0, bytes_1.zeros)(addressLength);\n    return (0, bytes_1.bufferToHex)(addr);\n};\nexports.zeroAddress = zeroAddress;\n/**\n * Checks if a given address is the zero address.\n */\nconst isZeroAddress = function (hexAddress) {\n    try {\n        (0, helpers_1.assertIsString)(hexAddress);\n    }\n    catch (e) {\n        return false;\n    }\n    const zeroAddr = (0, exports.zeroAddress)();\n    return zeroAddr === hexAddress;\n};\nexports.isZeroAddress = isZeroAddress;\nfunction accountBodyFromSlim(body) {\n    const [nonce, balance, storageRoot, codeHash] = body;\n    return [\n        nonce,\n        balance,\n        (0, bytes_1.arrToBufArr)(storageRoot).length === 0 ? constants_1.KECCAK256_RLP : storageRoot,\n        (0, bytes_1.arrToBufArr)(codeHash).length === 0 ? constants_1.KECCAK256_NULL : codeHash,\n    ];\n}\nexports.accountBodyFromSlim = accountBodyFromSlim;\nconst emptyUint8Arr = new Uint8Array(0);\nfunction accountBodyToSlim(body) {\n    const [nonce, balance, storageRoot, codeHash] = body;\n    return [\n        nonce,\n        balance,\n        (0, bytes_1.arrToBufArr)(storageRoot).equals(constants_1.KECCAK256_RLP) ? emptyUint8Arr : storageRoot,\n        (0, bytes_1.arrToBufArr)(codeHash).equals(constants_1.KECCAK256_NULL) ? emptyUint8Arr : codeHash,\n    ];\n}\nexports.accountBodyToSlim = accountBodyToSlim;\n/**\n * Converts a slim account (per snap protocol spec) to the RLP encoded version of the account\n * @param body Array of 4 Buffer-like items to represent the account\n * @returns RLP encoded version of the account\n */\nfunction accountBodyToRLP(body, couldBeSlim = true) {\n    const accountBody = couldBeSlim ? accountBodyFromSlim(body) : body;\n    return (0, bytes_1.arrToBufArr)(rlp_1.RLP.encode(accountBody));\n}\nexports.accountBodyToRLP = accountBodyToRLP;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Address = void 0;\nconst account_1 = require(\"./account\");\nconst bytes_1 = require(\"./bytes\");\n/**\n * Handling and generating Ethereum addresses\n */\nclass Address {\n    constructor(buf) {\n        if (buf.length !== 20) {\n            throw new Error('Invalid address length');\n        }\n        this.buf = buf;\n    }\n    /**\n     * Returns the zero address.\n     */\n    static zero() {\n        return new Address((0, bytes_1.zeros)(20));\n    }\n    /**\n     * Returns an Address object from a hex-encoded string.\n     * @param str - Hex-encoded address\n     */\n    static fromString(str) {\n        if (!(0, account_1.isValidAddress)(str)) {\n            throw new Error('Invalid address');\n        }\n        return new Address((0, bytes_1.toBuffer)(str));\n    }\n    /**\n     * Returns an address for a given public key.\n     * @param pubKey The two points of an uncompressed key\n     */\n    static fromPublicKey(pubKey) {\n        if (!Buffer.isBuffer(pubKey)) {\n            throw new Error('Public key should be Buffer');\n        }\n        const buf = (0, account_1.pubToAddress)(pubKey);\n        return new Address(buf);\n    }\n    /**\n     * Returns an address for a given private key.\n     * @param privateKey A private key must be 256 bits wide\n     */\n    static fromPrivateKey(privateKey) {\n        if (!Buffer.isBuffer(privateKey)) {\n            throw new Error('Private key should be Buffer');\n        }\n        const buf = (0, account_1.privateToAddress)(privateKey);\n        return new Address(buf);\n    }\n    /**\n     * Generates an address for a newly created contract.\n     * @param from The address which is creating this new address\n     * @param nonce The nonce of the from account\n     */\n    static generate(from, nonce) {\n        if (typeof nonce !== 'bigint') {\n            throw new Error('Expected nonce to be a bigint');\n        }\n        return new Address((0, account_1.generateAddress)(from.buf, (0, bytes_1.bigIntToBuffer)(nonce)));\n    }\n    /**\n     * Generates an address for a contract created using CREATE2.\n     * @param from The address which is creating this new address\n     * @param salt A salt\n     * @param initCode The init code of the contract being created\n     */\n    static generate2(from, salt, initCode) {\n        if (!Buffer.isBuffer(salt)) {\n            throw new Error('Expected salt to be a Buffer');\n        }\n        if (!Buffer.isBuffer(initCode)) {\n            throw new Error('Expected initCode to be a Buffer');\n        }\n        return new Address((0, account_1.generateAddress2)(from.buf, salt, initCode));\n    }\n    /**\n     * Is address equal to another.\n     */\n    equals(address) {\n        return this.buf.equals(address.buf);\n    }\n    /**\n     * Is address zero.\n     */\n    isZero() {\n        return this.equals(Address.zero());\n    }\n    /**\n     * True if address is in the address range defined\n     * by EIP-1352\n     */\n    isPrecompileOrSystemAddress() {\n        const address = (0, bytes_1.bufferToBigInt)(this.buf);\n        const rangeMin = BigInt(0);\n        const rangeMax = BigInt('0xffff');\n        return address >= rangeMin && address <= rangeMax;\n    }\n    /**\n     * Returns hex encoding of address.\n     */\n    toString() {\n        return '0x' + this.buf.toString('hex');\n    }\n    /**\n     * Returns Buffer representation of address.\n     */\n    toBuffer() {\n        return Buffer.from(this.buf);\n    }\n}\nexports.Address = Address;\n","\"use strict\";\n/**\n * Ported to Typescript from original implementation below:\n * https://github.com/ahultgren/async-eventemitter -- MIT licensed\n *\n * Type Definitions based on work by: patarapolw <https://github.com/patarapolw> -- MIT licensed\n * that was contributed to Definitely Typed below:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/async-eventemitter\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AsyncEventEmitter = void 0;\nconst events_1 = require(\"events\");\nasync function runInSeries(context, tasks, data) {\n    let error;\n    for await (const task of tasks) {\n        try {\n            if (task.length < 2) {\n                //sync\n                task.call(context, data);\n            }\n            else {\n                await new Promise((resolve, reject) => {\n                    task.call(context, data, (error) => {\n                        if (error) {\n                            reject(error);\n                        }\n                        else {\n                            resolve();\n                        }\n                    });\n                });\n            }\n        }\n        catch (e) {\n            error = e;\n        }\n    }\n    if (error) {\n        throw error;\n    }\n}\nclass AsyncEventEmitter extends events_1.EventEmitter {\n    emit(event, ...args) {\n        let [data, callback] = args;\n        const self = this;\n        let listeners = self._events[event] ?? [];\n        // Optional data argument\n        if (callback === undefined && typeof data === 'function') {\n            callback = data;\n            data = undefined;\n        }\n        // Special treatment of internal newListener and removeListener events\n        if (event === 'newListener' || event === 'removeListener') {\n            data = {\n                event: data,\n                fn: callback,\n            };\n            callback = undefined;\n        }\n        // A single listener is just a function not an array...\n        listeners = Array.isArray(listeners) ? listeners : [listeners];\n        runInSeries(self, listeners.slice(), data).then(callback).catch(callback);\n        return self.listenerCount(event) > 0;\n    }\n    once(event, listener) {\n        const self = this;\n        let g;\n        if (typeof listener !== 'function') {\n            throw new TypeError('listener must be a function');\n        }\n        // Hack to support set arity\n        if (listener.length >= 2) {\n            g = function (e, next) {\n                self.removeListener(event, g);\n                void listener(e, next);\n            };\n        }\n        else {\n            g = function (e) {\n                self.removeListener(event, g);\n                void listener(e, g);\n            };\n        }\n        self.on(event, g);\n        return self;\n    }\n    first(event, listener) {\n        let listeners = this._events[event] ?? [];\n        // Contract\n        if (typeof listener !== 'function') {\n            throw new TypeError('listener must be a function');\n        }\n        // Listeners are not always an array\n        if (!Array.isArray(listeners)) {\n            ;\n            this._events[event] = listeners = [listeners];\n        }\n        listeners.unshift(listener);\n        return this;\n    }\n    before(event, target, listener) {\n        return this.beforeOrAfter(event, target, listener);\n    }\n    after(event, target, listener) {\n        return this.beforeOrAfter(event, target, listener, 'after');\n    }\n    beforeOrAfter(event, target, listener, beforeOrAfter) {\n        let listeners = this._events[event] ?? [];\n        let i;\n        let index;\n        const add = beforeOrAfter === 'after' ? 1 : 0;\n        // Contract\n        if (typeof listener !== 'function') {\n            throw new TypeError('listener must be a function');\n        }\n        if (typeof target !== 'function') {\n            throw new TypeError('target must be a function');\n        }\n        // Listeners are not always an array\n        if (!Array.isArray(listeners)) {\n            ;\n            this._events[event] = listeners = [listeners];\n        }\n        index = listeners.length;\n        for (i = listeners.length; i--;) {\n            if (listeners[i] === target) {\n                index = i + add;\n                break;\n            }\n        }\n        listeners.splice(index, 0, listener);\n        return this;\n    }\n    on(event, listener) {\n        return super.on(event, listener);\n    }\n    addListener(event, listener) {\n        return super.addListener(event, listener);\n    }\n    prependListener(event, listener) {\n        return super.prependListener(event, listener);\n    }\n    prependOnceListener(event, listener) {\n        return super.prependOnceListener(event, listener);\n    }\n    removeAllListeners(event) {\n        return super.removeAllListeners(event);\n    }\n    removeListener(event, listener) {\n        return super.removeListener(event, listener);\n    }\n    eventNames() {\n        return super.eventNames();\n    }\n    listeners(event) {\n        return super.listeners(event);\n    }\n    listenerCount(event) {\n        return super.listenerCount(event);\n    }\n    getMaxListeners() {\n        return super.getMaxListeners();\n    }\n    setMaxListeners(maxListeners) {\n        return super.setMaxListeners(maxListeners);\n    }\n}\nexports.AsyncEventEmitter = AsyncEventEmitter;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.intToUnpaddedBuffer = exports.bigIntToUnpaddedBuffer = exports.bigIntToHex = exports.bufArrToArr = exports.arrToBufArr = exports.validateNoLeadingZeroes = exports.baToJSON = exports.toUtf8 = exports.short = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToInt = exports.bigIntToBuffer = exports.bufferToBigInt = exports.bufferToHex = exports.toBuffer = exports.unpadHexString = exports.unpadArray = exports.unpadBuffer = exports.setLengthRight = exports.setLengthLeft = exports.zeros = exports.intToBuffer = exports.intToHex = void 0;\nconst helpers_1 = require(\"./helpers\");\nconst internal_1 = require(\"./internal\");\n/**\n * Converts a `Number` into a hex `String`\n * @param {Number} i\n * @return {String}\n */\nconst intToHex = function (i) {\n    if (!Number.isSafeInteger(i) || i < 0) {\n        throw new Error(`Received an invalid integer type: ${i}`);\n    }\n    return `0x${i.toString(16)}`;\n};\nexports.intToHex = intToHex;\n/**\n * Converts an `Number` to a `Buffer`\n * @param {Number} i\n * @return {Buffer}\n */\nconst intToBuffer = function (i) {\n    const hex = (0, exports.intToHex)(i);\n    return Buffer.from((0, internal_1.padToEven)(hex.slice(2)), 'hex');\n};\nexports.intToBuffer = intToBuffer;\n/**\n * Returns a buffer filled with 0s.\n * @param bytes the number of bytes the buffer should be\n */\nconst zeros = function (bytes) {\n    return Buffer.allocUnsafe(bytes).fill(0);\n};\nexports.zeros = zeros;\n/**\n * Pads a `Buffer` with zeros till it has `length` bytes.\n * Truncates the beginning or end of input if its length exceeds `length`.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @param right whether to start padding form the left or right\n * @return (Buffer)\n */\nconst setLength = function (msg, length, right) {\n    const buf = (0, exports.zeros)(length);\n    if (right) {\n        if (msg.length < length) {\n            msg.copy(buf);\n            return buf;\n        }\n        return msg.slice(0, length);\n    }\n    else {\n        if (msg.length < length) {\n            msg.copy(buf, length - msg.length);\n            return buf;\n        }\n        return msg.slice(-length);\n    }\n};\n/**\n * Left Pads a `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @return (Buffer)\n */\nconst setLengthLeft = function (msg, length) {\n    (0, helpers_1.assertIsBuffer)(msg);\n    return setLength(msg, length, false);\n};\nexports.setLengthLeft = setLengthLeft;\n/**\n * Right Pads a `Buffer` with trailing zeros till it has `length` bytes.\n * it truncates the end if it exceeds.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @return (Buffer)\n */\nconst setLengthRight = function (msg, length) {\n    (0, helpers_1.assertIsBuffer)(msg);\n    return setLength(msg, length, true);\n};\nexports.setLengthRight = setLengthRight;\n/**\n * Trims leading zeros from a `Buffer`, `String` or `Number[]`.\n * @param a (Buffer|Array|String)\n * @return (Buffer|Array|String)\n */\nconst stripZeros = function (a) {\n    let first = a[0];\n    while (a.length > 0 && first.toString() === '0') {\n        a = a.slice(1);\n        first = a[0];\n    }\n    return a;\n};\n/**\n * Trims leading zeros from a `Buffer`.\n * @param a (Buffer)\n * @return (Buffer)\n */\nconst unpadBuffer = function (a) {\n    (0, helpers_1.assertIsBuffer)(a);\n    return stripZeros(a);\n};\nexports.unpadBuffer = unpadBuffer;\n/**\n * Trims leading zeros from an `Array` (of numbers).\n * @param a (number[])\n * @return (number[])\n */\nconst unpadArray = function (a) {\n    (0, helpers_1.assertIsArray)(a);\n    return stripZeros(a);\n};\nexports.unpadArray = unpadArray;\n/**\n * Trims leading zeros from a hex-prefixed `String`.\n * @param a (String)\n * @return (String)\n */\nconst unpadHexString = function (a) {\n    (0, helpers_1.assertIsHexString)(a);\n    a = (0, internal_1.stripHexPrefix)(a);\n    return ('0x' + stripZeros(a));\n};\nexports.unpadHexString = unpadHexString;\n/**\n * Attempts to turn a value into a `Buffer`.\n * Inputs supported: `Buffer`, `String` (hex-prefixed), `Number`, null/undefined, `BigInt` and other objects\n * with a `toArray()` or `toBuffer()` method.\n * @param v the value\n */\nconst toBuffer = function (v) {\n    if (v === null || v === undefined) {\n        return Buffer.allocUnsafe(0);\n    }\n    if (Buffer.isBuffer(v)) {\n        return Buffer.from(v);\n    }\n    if (Array.isArray(v) || v instanceof Uint8Array) {\n        return Buffer.from(v);\n    }\n    if (typeof v === 'string') {\n        if (!(0, internal_1.isHexString)(v)) {\n            throw new Error(`Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${v}`);\n        }\n        return Buffer.from((0, internal_1.padToEven)((0, internal_1.stripHexPrefix)(v)), 'hex');\n    }\n    if (typeof v === 'number') {\n        return (0, exports.intToBuffer)(v);\n    }\n    if (typeof v === 'bigint') {\n        if (v < BigInt(0)) {\n            throw new Error(`Cannot convert negative bigint to buffer. Given: ${v}`);\n        }\n        let n = v.toString(16);\n        if (n.length % 2)\n            n = '0' + n;\n        return Buffer.from(n, 'hex');\n    }\n    if (v.toArray) {\n        // converts a BN to a Buffer\n        return Buffer.from(v.toArray());\n    }\n    if (v.toBuffer) {\n        return Buffer.from(v.toBuffer());\n    }\n    throw new Error('invalid type');\n};\nexports.toBuffer = toBuffer;\n/**\n * Converts a `Buffer` into a `0x`-prefixed hex `String`.\n * @param buf `Buffer` object to convert\n */\nconst bufferToHex = function (buf) {\n    buf = (0, exports.toBuffer)(buf);\n    return '0x' + buf.toString('hex');\n};\nexports.bufferToHex = bufferToHex;\n/**\n * Converts a {@link Buffer} to a {@link bigint}\n */\nfunction bufferToBigInt(buf) {\n    const hex = (0, exports.bufferToHex)(buf);\n    if (hex === '0x') {\n        return BigInt(0);\n    }\n    return BigInt(hex);\n}\nexports.bufferToBigInt = bufferToBigInt;\n/**\n * Converts a {@link bigint} to a {@link Buffer}\n */\nfunction bigIntToBuffer(num) {\n    return (0, exports.toBuffer)('0x' + num.toString(16));\n}\nexports.bigIntToBuffer = bigIntToBuffer;\n/**\n * Converts a `Buffer` to a `Number`.\n * @param buf `Buffer` object to convert\n * @throws If the input number exceeds 53 bits.\n */\nconst bufferToInt = function (buf) {\n    const res = Number(bufferToBigInt(buf));\n    if (!Number.isSafeInteger(res))\n        throw new Error('Number exceeds 53 bits');\n    return res;\n};\nexports.bufferToInt = bufferToInt;\n/**\n * Interprets a `Buffer` as a signed integer and returns a `BigInt`. Assumes 256-bit numbers.\n * @param num Signed integer value\n */\nconst fromSigned = function (num) {\n    return BigInt.asIntN(256, bufferToBigInt(num));\n};\nexports.fromSigned = fromSigned;\n/**\n * Converts a `BigInt` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.\n * @param num\n */\nconst toUnsigned = function (num) {\n    return bigIntToBuffer(BigInt.asUintN(256, num));\n};\nexports.toUnsigned = toUnsigned;\n/**\n * Adds \"0x\" to a given `String` if it does not already start with \"0x\".\n */\nconst addHexPrefix = function (str) {\n    if (typeof str !== 'string') {\n        return str;\n    }\n    return (0, internal_1.isHexPrefixed)(str) ? str : '0x' + str;\n};\nexports.addHexPrefix = addHexPrefix;\n/**\n * Shortens a string  or buffer's hex string representation to maxLength (default 50).\n *\n * Examples:\n *\n * Input:  '657468657265756d000000000000000000000000000000000000000000000000'\n * Output: '657468657265756d0000000000000000000000000000000000'\n */\nfunction short(buffer, maxLength = 50) {\n    const bufferStr = Buffer.isBuffer(buffer) ? buffer.toString('hex') : buffer;\n    if (bufferStr.length <= maxLength) {\n        return bufferStr;\n    }\n    return bufferStr.slice(0, maxLength) + '';\n}\nexports.short = short;\n/**\n * Returns the utf8 string representation from a hex string.\n *\n * Examples:\n *\n * Input 1: '657468657265756d000000000000000000000000000000000000000000000000'\n * Input 2: '657468657265756d'\n * Input 3: '000000000000000000000000000000000000000000000000657468657265756d'\n *\n * Output (all 3 input variants): 'ethereum'\n *\n * Note that this method is not intended to be used with hex strings\n * representing quantities in both big endian or little endian notation.\n *\n * @param string Hex string, should be `0x` prefixed\n * @return Utf8 string\n */\nconst toUtf8 = function (hex) {\n    const zerosRegexp = /^(00)+|(00)+$/g;\n    hex = (0, internal_1.stripHexPrefix)(hex);\n    if (hex.length % 2 !== 0) {\n        throw new Error('Invalid non-even hex string input for toUtf8() provided');\n    }\n    const bufferVal = Buffer.from(hex.replace(zerosRegexp, ''), 'hex');\n    return bufferVal.toString('utf8');\n};\nexports.toUtf8 = toUtf8;\n/**\n * Converts a `Buffer` or `Array` to JSON.\n * @param ba (Buffer|Array)\n * @return (Array|String|null)\n */\nconst baToJSON = function (ba) {\n    if (Buffer.isBuffer(ba)) {\n        return `0x${ba.toString('hex')}`;\n    }\n    else if (ba instanceof Array) {\n        const array = [];\n        for (let i = 0; i < ba.length; i++) {\n            array.push((0, exports.baToJSON)(ba[i]));\n        }\n        return array;\n    }\n};\nexports.baToJSON = baToJSON;\n/**\n * Checks provided Buffers for leading zeroes and throws if found.\n *\n * Examples:\n *\n * Valid values: 0x1, 0x, 0x01, 0x1234\n * Invalid values: 0x0, 0x00, 0x001, 0x0001\n *\n * Note: This method is useful for validating that RLP encoded integers comply with the rule that all\n * integer values encoded to RLP must be in the most compact form and contain no leading zero bytes\n * @param values An object containing string keys and Buffer values\n * @throws if any provided value is found to have leading zero bytes\n */\nconst validateNoLeadingZeroes = function (values) {\n    for (const [k, v] of Object.entries(values)) {\n        if (v !== undefined && v.length > 0 && v[0] === 0) {\n            throw new Error(`${k} cannot have leading zeroes, received: ${v.toString('hex')}`);\n        }\n    }\n};\nexports.validateNoLeadingZeroes = validateNoLeadingZeroes;\nfunction arrToBufArr(arr) {\n    if (!Array.isArray(arr)) {\n        return Buffer.from(arr);\n    }\n    return arr.map((a) => arrToBufArr(a));\n}\nexports.arrToBufArr = arrToBufArr;\nfunction bufArrToArr(arr) {\n    if (!Array.isArray(arr)) {\n        return Uint8Array.from(arr ?? []);\n    }\n    return arr.map((a) => bufArrToArr(a));\n}\nexports.bufArrToArr = bufArrToArr;\n/**\n * Converts a {@link bigint} to a `0x` prefixed hex string\n */\nconst bigIntToHex = (num) => {\n    return '0x' + num.toString(16);\n};\nexports.bigIntToHex = bigIntToHex;\n/**\n * Convert value from bigint to an unpadded Buffer\n * (useful for RLP transport)\n * @param value value to convert\n */\nfunction bigIntToUnpaddedBuffer(value) {\n    return (0, exports.unpadBuffer)(bigIntToBuffer(value));\n}\nexports.bigIntToUnpaddedBuffer = bigIntToUnpaddedBuffer;\nfunction intToUnpaddedBuffer(value) {\n    return (0, exports.unpadBuffer)((0, exports.intToBuffer)(value));\n}\nexports.intToUnpaddedBuffer = intToUnpaddedBuffer;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MAX_WITHDRAWALS_PER_PAYLOAD = exports.RLP_EMPTY_STRING = exports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.SECP256K1_ORDER_DIV_2 = exports.SECP256K1_ORDER = exports.MAX_INTEGER_BIGINT = exports.MAX_INTEGER = exports.MAX_UINT64 = void 0;\nconst buffer_1 = require(\"buffer\");\nconst secp256k1_1 = require(\"ethereum-cryptography/secp256k1\");\n/**\n * 2^64-1\n */\nexports.MAX_UINT64 = BigInt('0xffffffffffffffff');\n/**\n * The max integer that the evm can handle (2^256-1)\n */\nexports.MAX_INTEGER = BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\n/**\n * The max integer that the evm can handle (2^256-1) as a bigint\n * 2^256-1 equals to 340282366920938463463374607431768211455\n * We use literal value instead of calculated value for compatibility issue.\n */\nexports.MAX_INTEGER_BIGINT = BigInt('115792089237316195423570985008687907853269984665640564039457584007913129639935');\nexports.SECP256K1_ORDER = secp256k1_1.CURVE.n;\nexports.SECP256K1_ORDER_DIV_2 = secp256k1_1.CURVE.n / BigInt(2);\n/**\n * 2^256\n */\nexports.TWO_POW256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');\n/**\n * Keccak-256 hash of null\n */\nexports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';\n/**\n * Keccak-256 hash of null\n */\nexports.KECCAK256_NULL = buffer_1.Buffer.from(exports.KECCAK256_NULL_S, 'hex');\n/**\n * Keccak-256 of an RLP of an empty array\n */\nexports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';\n/**\n * Keccak-256 of an RLP of an empty array\n */\nexports.KECCAK256_RLP_ARRAY = buffer_1.Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');\n/**\n * Keccak-256 hash of the RLP of null\n */\nexports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';\n/**\n * Keccak-256 hash of the RLP of null\n */\nexports.KECCAK256_RLP = buffer_1.Buffer.from(exports.KECCAK256_RLP_S, 'hex');\n/**\n *  RLP encoded empty string\n */\nexports.RLP_EMPTY_STRING = buffer_1.Buffer.from([0x80]);\nexports.MAX_WITHDRAWALS_PER_PAYLOAD = 16;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assertIsString = exports.assertIsArray = exports.assertIsBuffer = exports.assertIsHexString = void 0;\nconst internal_1 = require(\"./internal\");\n/**\n * Throws if a string is not hex prefixed\n * @param {string} input string to check hex prefix of\n */\nconst assertIsHexString = function (input) {\n    if (!(0, internal_1.isHexString)(input)) {\n        const msg = `This method only supports 0x-prefixed hex strings but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsHexString = assertIsHexString;\n/**\n * Throws if input is not a buffer\n * @param {Buffer} input value to check\n */\nconst assertIsBuffer = function (input) {\n    if (!Buffer.isBuffer(input)) {\n        const msg = `This method only supports Buffer but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsBuffer = assertIsBuffer;\n/**\n * Throws if input is not an array\n * @param {number[]} input value to check\n */\nconst assertIsArray = function (input) {\n    if (!Array.isArray(input)) {\n        const msg = `This method only supports number arrays but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsArray = assertIsArray;\n/**\n * Throws if input is not a string\n * @param {string} input value to check\n */\nconst assertIsString = function (input) {\n    if (typeof input !== 'string') {\n        const msg = `This method only supports strings but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsString = assertIsString;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toAscii = exports.stripHexPrefix = exports.padToEven = exports.isHexString = exports.isHexPrefixed = exports.getKeys = exports.getBinarySize = exports.fromUtf8 = exports.fromAscii = exports.arrayContainsArray = exports.ssz = void 0;\n/**\n * Constants\n */\n__exportStar(require(\"./constants\"), exports);\n/**\n * Units helpers\n */\n__exportStar(require(\"./units\"), exports);\n/**\n * Account class and helper functions\n */\n__exportStar(require(\"./account\"), exports);\n/**\n * Address type\n */\n__exportStar(require(\"./address\"), exports);\n/**\n * Withdrawal type\n */\n__exportStar(require(\"./withdrawal\"), exports);\n/**\n * ECDSA signature\n */\n__exportStar(require(\"./signature\"), exports);\n/**\n * Utilities for manipulating Buffers, byte arrays, etc.\n */\n__exportStar(require(\"./bytes\"), exports);\n/**\n * SSZ containers\n */\nexports.ssz = require(\"./ssz\");\n/**\n * Helpful TypeScript types\n */\n__exportStar(require(\"./types\"), exports);\n/**\n * Export ethjs-util methods\n */\n__exportStar(require(\"./asyncEventEmitter\"), exports);\nvar internal_1 = require(\"./internal\");\nObject.defineProperty(exports, \"arrayContainsArray\", { enumerable: true, get: function () { return internal_1.arrayContainsArray; } });\nObject.defineProperty(exports, \"fromAscii\", { enumerable: true, get: function () { return internal_1.fromAscii; } });\nObject.defineProperty(exports, \"fromUtf8\", { enumerable: true, get: function () { return internal_1.fromUtf8; } });\nObject.defineProperty(exports, \"getBinarySize\", { enumerable: true, get: function () { return internal_1.getBinarySize; } });\nObject.defineProperty(exports, \"getKeys\", { enumerable: true, get: function () { return internal_1.getKeys; } });\nObject.defineProperty(exports, \"isHexPrefixed\", { enumerable: true, get: function () { return internal_1.isHexPrefixed; } });\nObject.defineProperty(exports, \"isHexString\", { enumerable: true, get: function () { return internal_1.isHexString; } });\nObject.defineProperty(exports, \"padToEven\", { enumerable: true, get: function () { return internal_1.padToEven; } });\nObject.defineProperty(exports, \"stripHexPrefix\", { enumerable: true, get: function () { return internal_1.stripHexPrefix; } });\nObject.defineProperty(exports, \"toAscii\", { enumerable: true, get: function () { return internal_1.toAscii; } });\n__exportStar(require(\"./lock\"), exports);\n","\"use strict\";\n/*\nThe MIT License\n\nCopyright (c) 2016 Nick Dodson. nickdodson.com\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isHexString = exports.getKeys = exports.fromAscii = exports.fromUtf8 = exports.toAscii = exports.arrayContainsArray = exports.getBinarySize = exports.padToEven = exports.stripHexPrefix = exports.isHexPrefixed = void 0;\n/**\n * Returns a `Boolean` on whether or not the a `String` starts with '0x'\n * @param str the string input value\n * @return a boolean if it is or is not hex prefixed\n * @throws if the str input is not a string\n */\nfunction isHexPrefixed(str) {\n    if (typeof str !== 'string') {\n        throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof str}`);\n    }\n    return str[0] === '0' && str[1] === 'x';\n}\nexports.isHexPrefixed = isHexPrefixed;\n/**\n * Removes '0x' from a given `String` if present\n * @param str the string value\n * @returns the string without 0x prefix\n */\nconst stripHexPrefix = (str) => {\n    if (typeof str !== 'string')\n        throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof str}`);\n    return isHexPrefixed(str) ? str.slice(2) : str;\n};\nexports.stripHexPrefix = stripHexPrefix;\n/**\n * Pads a `String` to have an even length\n * @param value\n * @return output\n */\nfunction padToEven(value) {\n    let a = value;\n    if (typeof a !== 'string') {\n        throw new Error(`[padToEven] value must be type 'string', received ${typeof a}`);\n    }\n    if (a.length % 2)\n        a = `0${a}`;\n    return a;\n}\nexports.padToEven = padToEven;\n/**\n * Get the binary size of a string\n * @param str\n * @returns the number of bytes contained within the string\n */\nfunction getBinarySize(str) {\n    if (typeof str !== 'string') {\n        throw new Error(`[getBinarySize] method requires input type 'string', received ${typeof str}`);\n    }\n    return Buffer.byteLength(str, 'utf8');\n}\nexports.getBinarySize = getBinarySize;\n/**\n * Returns TRUE if the first specified array contains all elements\n * from the second one. FALSE otherwise.\n *\n * @param superset\n * @param subset\n *\n */\nfunction arrayContainsArray(superset, subset, some) {\n    if (Array.isArray(superset) !== true) {\n        throw new Error(`[arrayContainsArray] method requires input 'superset' to be an array, got type '${typeof superset}'`);\n    }\n    if (Array.isArray(subset) !== true) {\n        throw new Error(`[arrayContainsArray] method requires input 'subset' to be an array, got type '${typeof subset}'`);\n    }\n    return subset[some === true ? 'some' : 'every']((value) => superset.indexOf(value) >= 0);\n}\nexports.arrayContainsArray = arrayContainsArray;\n/**\n * Should be called to get ascii from its hex representation\n *\n * @param string in hex\n * @returns ascii string representation of hex value\n */\nfunction toAscii(hex) {\n    let str = '';\n    let i = 0;\n    const l = hex.length;\n    if (hex.substring(0, 2) === '0x')\n        i = 2;\n    for (; i < l; i += 2) {\n        const code = parseInt(hex.substr(i, 2), 16);\n        str += String.fromCharCode(code);\n    }\n    return str;\n}\nexports.toAscii = toAscii;\n/**\n * Should be called to get hex representation (prefixed by 0x) of utf8 string\n *\n * @param string\n * @param optional padding\n * @returns hex representation of input string\n */\nfunction fromUtf8(stringValue) {\n    const str = Buffer.from(stringValue, 'utf8');\n    return `0x${padToEven(str.toString('hex')).replace(/^0+|0+$/g, '')}`;\n}\nexports.fromUtf8 = fromUtf8;\n/**\n * Should be called to get hex representation (prefixed by 0x) of ascii string\n *\n * @param  string\n * @param  optional padding\n * @returns  hex representation of input string\n */\nfunction fromAscii(stringValue) {\n    let hex = '';\n    for (let i = 0; i < stringValue.length; i++) {\n        const code = stringValue.charCodeAt(i);\n        const n = code.toString(16);\n        hex += n.length < 2 ? `0${n}` : n;\n    }\n    return `0x${hex}`;\n}\nexports.fromAscii = fromAscii;\n/**\n * Returns the keys from an array of objects.\n * @example\n * ```js\n * getKeys([{a: '1', b: '2'}, {a: '3', b: '4'}], 'a') => ['1', '3']\n *````\n * @param  params\n * @param  key\n * @param  allowEmpty\n * @returns output just a simple array of output keys\n */\nfunction getKeys(params, key, allowEmpty) {\n    if (!Array.isArray(params)) {\n        throw new Error(`[getKeys] method expects input 'params' to be an array, got ${typeof params}`);\n    }\n    if (typeof key !== 'string') {\n        throw new Error(`[getKeys] method expects input 'key' to be type 'string', got ${typeof params}`);\n    }\n    const result = [];\n    for (let i = 0; i < params.length; i++) {\n        let value = params[i][key];\n        if (allowEmpty === true && !value) {\n            value = '';\n        }\n        else if (typeof value !== 'string') {\n            throw new Error(`invalid abi - expected type 'string', received ${typeof value}`);\n        }\n        result.push(value);\n    }\n    return result;\n}\nexports.getKeys = getKeys;\n/**\n * Is the string a hex string.\n *\n * @param  value\n * @param  length\n * @returns  output the string is a hex string\n */\nfunction isHexString(value, length) {\n    if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/))\n        return false;\n    if (typeof length !== 'undefined' && length > 0 && value.length !== 2 + 2 * length)\n        return false;\n    return true;\n}\nexports.isHexString = isHexString;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Lock = void 0;\n// Based on https://github.com/jsoendermann/semaphore-async-await/blob/master/src/Semaphore.ts\nclass Lock {\n    constructor() {\n        this.permits = 1;\n        this.promiseResolverQueue = [];\n    }\n    /**\n     * Returns a promise used to wait for a permit to become available. This method should be awaited on.\n     * @returns  A promise that gets resolved when execution is allowed to proceed.\n     */\n    async acquire() {\n        if (this.permits > 0) {\n            this.permits -= 1;\n            return Promise.resolve(true);\n        }\n        // If there is no permit available, we return a promise that resolves once the semaphore gets\n        // signaled enough times that permits is equal to one.\n        return new Promise((resolver) => this.promiseResolverQueue.push(resolver));\n    }\n    /**\n     * Increases the number of permits by one. If there are other functions waiting, one of them will\n     * continue to execute in a future iteration of the event loop.\n     */\n    release() {\n        this.permits += 1;\n        if (this.permits > 1 && this.promiseResolverQueue.length > 0) {\n            // eslint-disable-next-line no-console\n            console.warn('Lock.permits should never be > 0 when there is someone waiting.');\n        }\n        else if (this.permits === 1 && this.promiseResolverQueue.length > 0) {\n            // If there is someone else waiting, immediately consume the permit that was released\n            // at the beginning of this function and let the waiting function resume.\n            this.permits -= 1;\n            const nextResolver = this.promiseResolverQueue.shift();\n            if (nextResolver) {\n                nextResolver(true);\n            }\n        }\n    }\n}\nexports.Lock = Lock;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toCompactSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;\nconst keccak_1 = require(\"ethereum-cryptography/keccak\");\nconst secp256k1_1 = require(\"ethereum-cryptography/secp256k1\");\nconst bytes_1 = require(\"./bytes\");\nconst constants_1 = require(\"./constants\");\nconst helpers_1 = require(\"./helpers\");\n/**\n * Returns the ECDSA signature of a message hash.\n *\n * If `chainId` is provided assume an EIP-155-style signature and calculate the `v` value\n * accordingly, otherwise return a \"static\" `v` just derived from the `recovery` bit\n */\nfunction ecsign(msgHash, privateKey, chainId) {\n    const [signature, recovery] = (0, secp256k1_1.signSync)(msgHash, privateKey, { recovered: true, der: false });\n    const r = Buffer.from(signature.slice(0, 32));\n    const s = Buffer.from(signature.slice(32, 64));\n    const v = chainId === undefined\n        ? BigInt(recovery + 27)\n        : BigInt(recovery + 35) + BigInt(chainId) * BigInt(2);\n    return { r, s, v };\n}\nexports.ecsign = ecsign;\nfunction calculateSigRecovery(v, chainId) {\n    if (v === BigInt(0) || v === BigInt(1))\n        return v;\n    if (chainId === undefined) {\n        return v - BigInt(27);\n    }\n    return v - (chainId * BigInt(2) + BigInt(35));\n}\nfunction isValidSigRecovery(recovery) {\n    return recovery === BigInt(0) || recovery === BigInt(1);\n}\n/**\n * ECDSA public key recovery from signature.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Recovered public key\n */\nconst ecrecover = function (msgHash, v, r, s, chainId) {\n    const signature = Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(s, 32)], 64);\n    const recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error('Invalid signature v value');\n    }\n    const senderPubKey = (0, secp256k1_1.recoverPublicKey)(msgHash, signature, Number(recovery));\n    return Buffer.from(senderPubKey.slice(1));\n};\nexports.ecrecover = ecrecover;\n/**\n * Convert signature parameters into the format of `eth_sign` RPC method.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Signature\n */\nconst toRpcSig = function (v, r, s, chainId) {\n    const recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error('Invalid signature v value');\n    }\n    // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin\n    return (0, bytes_1.bufferToHex)(Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(s, 32), (0, bytes_1.toBuffer)(v)]));\n};\nexports.toRpcSig = toRpcSig;\n/**\n * Convert signature parameters into the format of Compact Signature Representation (EIP-2098).\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Signature\n */\nconst toCompactSig = function (v, r, s, chainId) {\n    const recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error('Invalid signature v value');\n    }\n    let ss = s;\n    if ((v > BigInt(28) && v % BigInt(2) === BigInt(1)) || v === BigInt(1) || v === BigInt(28)) {\n        ss = Buffer.from(s);\n        ss[0] |= 0x80;\n    }\n    return (0, bytes_1.bufferToHex)(Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(ss, 32)]));\n};\nexports.toCompactSig = toCompactSig;\n/**\n * Convert signature format of the `eth_sign` RPC method to signature parameters\n *\n * NOTE: For an extracted `v` value < 27 (see Geth bug https://github.com/ethereum/go-ethereum/issues/2053)\n * `v + 27` is returned for the `v` value\n * NOTE: After EIP1559, `v` could be `0` or `1` but this function assumes\n * it's a signed message (EIP-191 or EIP-712) adding `27` at the end. Remove if needed.\n */\nconst fromRpcSig = function (sig) {\n    const buf = (0, bytes_1.toBuffer)(sig);\n    let r;\n    let s;\n    let v;\n    if (buf.length >= 65) {\n        r = buf.slice(0, 32);\n        s = buf.slice(32, 64);\n        v = (0, bytes_1.bufferToBigInt)(buf.slice(64));\n    }\n    else if (buf.length === 64) {\n        // Compact Signature Representation (https://eips.ethereum.org/EIPS/eip-2098)\n        r = buf.slice(0, 32);\n        s = buf.slice(32, 64);\n        v = BigInt((0, bytes_1.bufferToInt)(buf.slice(32, 33)) >> 7);\n        s[0] &= 0x7f;\n    }\n    else {\n        throw new Error('Invalid signature length');\n    }\n    // support both versions of `eth_sign` responses\n    if (v < 27) {\n        v = v + BigInt(27);\n    }\n    return {\n        v,\n        r,\n        s,\n    };\n};\nexports.fromRpcSig = fromRpcSig;\n/**\n * Validate a ECDSA signature.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one\n */\nconst isValidSignature = function (v, r, s, homesteadOrLater = true, chainId) {\n    if (r.length !== 32 || s.length !== 32) {\n        return false;\n    }\n    if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {\n        return false;\n    }\n    const rBigInt = (0, bytes_1.bufferToBigInt)(r);\n    const sBigInt = (0, bytes_1.bufferToBigInt)(s);\n    if (rBigInt === BigInt(0) ||\n        rBigInt >= constants_1.SECP256K1_ORDER ||\n        sBigInt === BigInt(0) ||\n        sBigInt >= constants_1.SECP256K1_ORDER) {\n        return false;\n    }\n    if (homesteadOrLater && sBigInt >= constants_1.SECP256K1_ORDER_DIV_2) {\n        return false;\n    }\n    return true;\n};\nexports.isValidSignature = isValidSignature;\n/**\n * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.\n * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`\n * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key\n * used to produce the signature.\n */\nconst hashPersonalMessage = function (message) {\n    (0, helpers_1.assertIsBuffer)(message);\n    const prefix = Buffer.from(`\\u0019Ethereum Signed Message:\\n${message.length}`, 'utf-8');\n    return Buffer.from((0, keccak_1.keccak256)(Buffer.concat([prefix, message])));\n};\nexports.hashPersonalMessage = hashPersonalMessage;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Withdrawals = exports.Withdrawal = exports.Bytes20 = exports.UintBigInt64 = exports.UintNum64 = void 0;\nconst ssz_1 = require(\"@chainsafe/ssz\");\nconst constants_1 = require(\"./constants\");\nexports.UintNum64 = new ssz_1.UintNumberType(8);\nexports.UintBigInt64 = new ssz_1.UintBigintType(8);\nexports.Bytes20 = new ssz_1.ByteVectorType(20);\nexports.Withdrawal = new ssz_1.ContainerType({\n    index: exports.UintBigInt64,\n    validatorIndex: exports.UintBigInt64,\n    address: exports.Bytes20,\n    amount: exports.UintBigInt64,\n}, { typeName: 'Withdrawal', jsonCase: 'eth2' });\nexports.Withdrawals = new ssz_1.ListCompositeType(exports.Withdrawal, constants_1.MAX_WITHDRAWALS_PER_PAYLOAD);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toType = exports.TypeOutput = void 0;\nconst bytes_1 = require(\"./bytes\");\nconst internal_1 = require(\"./internal\");\n/**\n * Type output options\n */\nvar TypeOutput;\n(function (TypeOutput) {\n    TypeOutput[TypeOutput[\"Number\"] = 0] = \"Number\";\n    TypeOutput[TypeOutput[\"BigInt\"] = 1] = \"BigInt\";\n    TypeOutput[TypeOutput[\"Buffer\"] = 2] = \"Buffer\";\n    TypeOutput[TypeOutput[\"PrefixedHexString\"] = 3] = \"PrefixedHexString\";\n})(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));\nfunction toType(input, outputType) {\n    if (input === null) {\n        return null;\n    }\n    if (input === undefined) {\n        return undefined;\n    }\n    if (typeof input === 'string' && !(0, internal_1.isHexString)(input)) {\n        throw new Error(`A string must be provided with a 0x-prefix, given: ${input}`);\n    }\n    else if (typeof input === 'number' && !Number.isSafeInteger(input)) {\n        throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)');\n    }\n    const output = (0, bytes_1.toBuffer)(input);\n    switch (outputType) {\n        case TypeOutput.Buffer:\n            return output;\n        case TypeOutput.BigInt:\n            return (0, bytes_1.bufferToBigInt)(output);\n        case TypeOutput.Number: {\n            const bigInt = (0, bytes_1.bufferToBigInt)(output);\n            if (bigInt > BigInt(Number.MAX_SAFE_INTEGER)) {\n                throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)');\n            }\n            return Number(bigInt);\n        }\n        case TypeOutput.PrefixedHexString:\n            return (0, bytes_1.bufferToHex)(output);\n        default:\n            throw new Error('unknown outputType');\n    }\n}\nexports.toType = toType;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GWEI_TO_WEI = void 0;\n/** Easy conversion from Gwei to wei */\nexports.GWEI_TO_WEI = BigInt(1000000000);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Withdrawal = void 0;\nconst address_1 = require(\"./address\");\nconst bytes_1 = require(\"./bytes\");\nconst types_1 = require(\"./types\");\n/**\n * Representation of EIP-4895 withdrawal data\n */\nclass Withdrawal {\n    /**\n     * This constructor assigns and validates the values.\n     * Use the static factory methods to assist in creating a Withdrawal object from varying data types.\n     * Its amount is in Gwei to match CL representation and for eventual ssz withdrawalsRoot\n     */\n    constructor(index, validatorIndex, address, \n    /**\n     * withdrawal amount in Gwei to match the CL repesentation and eventually ssz withdrawalsRoot\n     */\n    amount) {\n        this.index = index;\n        this.validatorIndex = validatorIndex;\n        this.address = address;\n        this.amount = amount;\n    }\n    static fromWithdrawalData(withdrawalData) {\n        const { index: indexData, validatorIndex: validatorIndexData, address: addressData, amount: amountData, } = withdrawalData;\n        const index = (0, types_1.toType)(indexData, types_1.TypeOutput.BigInt);\n        const validatorIndex = (0, types_1.toType)(validatorIndexData, types_1.TypeOutput.BigInt);\n        const address = new address_1.Address((0, types_1.toType)(addressData, types_1.TypeOutput.Buffer));\n        const amount = (0, types_1.toType)(amountData, types_1.TypeOutput.BigInt);\n        return new Withdrawal(index, validatorIndex, address, amount);\n    }\n    static fromValuesArray(withdrawalArray) {\n        if (withdrawalArray.length !== 4) {\n            throw Error(`Invalid withdrawalArray length expected=4 actual=${withdrawalArray.length}`);\n        }\n        const [index, validatorIndex, address, amount] = withdrawalArray;\n        return Withdrawal.fromWithdrawalData({ index, validatorIndex, address, amount });\n    }\n    /**\n     * Convert a withdrawal to a buffer array\n     * @param withdrawal the withdrawal to convert\n     * @returns buffer array of the withdrawal\n     */\n    static toBufferArray(withdrawal) {\n        const { index, validatorIndex, address, amount } = withdrawal;\n        const indexBuffer = (0, types_1.toType)(index, types_1.TypeOutput.BigInt) === BigInt(0)\n            ? Buffer.alloc(0)\n            : (0, types_1.toType)(index, types_1.TypeOutput.Buffer);\n        const validatorIndexBuffer = (0, types_1.toType)(validatorIndex, types_1.TypeOutput.BigInt) === BigInt(0)\n            ? Buffer.alloc(0)\n            : (0, types_1.toType)(validatorIndex, types_1.TypeOutput.Buffer);\n        let addressBuffer;\n        if (address instanceof address_1.Address) {\n            addressBuffer = address.buf;\n        }\n        else {\n            addressBuffer = (0, types_1.toType)(address, types_1.TypeOutput.Buffer);\n        }\n        const amountBuffer = (0, types_1.toType)(amount, types_1.TypeOutput.BigInt) === BigInt(0)\n            ? Buffer.alloc(0)\n            : (0, types_1.toType)(amount, types_1.TypeOutput.Buffer);\n        return [indexBuffer, validatorIndexBuffer, addressBuffer, amountBuffer];\n    }\n    raw() {\n        return Withdrawal.toBufferArray(this);\n    }\n    toValue() {\n        return {\n            index: this.index,\n            validatorIndex: this.validatorIndex,\n            address: this.address.buf,\n            amount: this.amount,\n        };\n    }\n    toJSON() {\n        return {\n            index: (0, bytes_1.bigIntToHex)(this.index),\n            validatorIndex: (0, bytes_1.bigIntToHex)(this.validatorIndex),\n            address: '0x' + this.address.buf.toString('hex'),\n            amount: (0, bytes_1.bigIntToHex)(this.amount),\n        };\n    }\n}\nexports.Withdrawal = Withdrawal;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.accountBodyToRLP = exports.accountBodyToSlim = exports.accountBodyFromSlim = exports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;\nconst rlp_1 = require(\"@ethereumjs/rlp\");\nconst keccak_1 = require(\"ethereum-cryptography/keccak\");\nconst secp256k1_1 = require(\"ethereum-cryptography/secp256k1\");\nconst utils_1 = require(\"ethereum-cryptography/utils\");\nconst bytes_1 = require(\"./bytes\");\nconst constants_1 = require(\"./constants\");\nconst helpers_1 = require(\"./helpers\");\nconst internal_1 = require(\"./internal\");\nconst _0n = BigInt(0);\nclass Account {\n    /**\n     * This constructor assigns and validates the values.\n     * Use the static factory methods to assist in creating an Account from varying data types.\n     */\n    constructor(nonce = _0n, balance = _0n, storageRoot = constants_1.KECCAK256_RLP, codeHash = constants_1.KECCAK256_NULL) {\n        this.nonce = nonce;\n        this.balance = balance;\n        this.storageRoot = storageRoot;\n        this.codeHash = codeHash;\n        this._validate();\n    }\n    static fromAccountData(accountData) {\n        const { nonce, balance, storageRoot, codeHash } = accountData;\n        return new Account(nonce !== undefined ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(nonce)) : undefined, balance !== undefined ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(balance)) : undefined, storageRoot !== undefined ? (0, bytes_1.toBuffer)(storageRoot) : undefined, codeHash !== undefined ? (0, bytes_1.toBuffer)(codeHash) : undefined);\n    }\n    static fromRlpSerializedAccount(serialized) {\n        const values = (0, bytes_1.arrToBufArr)(rlp_1.RLP.decode(Uint8Array.from(serialized)));\n        if (!Array.isArray(values)) {\n            throw new Error('Invalid serialized account input. Must be array');\n        }\n        return this.fromValuesArray(values);\n    }\n    static fromValuesArray(values) {\n        const [nonce, balance, storageRoot, codeHash] = values;\n        return new Account((0, bytes_1.bufferToBigInt)(nonce), (0, bytes_1.bufferToBigInt)(balance), storageRoot, codeHash);\n    }\n    _validate() {\n        if (this.nonce < _0n) {\n            throw new Error('nonce must be greater than zero');\n        }\n        if (this.balance < _0n) {\n            throw new Error('balance must be greater than zero');\n        }\n        if (this.storageRoot.length !== 32) {\n            throw new Error('storageRoot must have a length of 32');\n        }\n        if (this.codeHash.length !== 32) {\n            throw new Error('codeHash must have a length of 32');\n        }\n    }\n    /**\n     * Returns a Buffer Array of the raw Buffers for the account, in order.\n     */\n    raw() {\n        return [\n            (0, bytes_1.bigIntToUnpaddedBuffer)(this.nonce),\n            (0, bytes_1.bigIntToUnpaddedBuffer)(this.balance),\n            this.storageRoot,\n            this.codeHash,\n        ];\n    }\n    /**\n     * Returns the RLP serialization of the account as a `Buffer`.\n     */\n    serialize() {\n        return Buffer.from(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)(this.raw())));\n    }\n    /**\n     * Returns a `Boolean` determining if the account is a contract.\n     */\n    isContract() {\n        return !this.codeHash.equals(constants_1.KECCAK256_NULL);\n    }\n    /**\n     * Returns a `Boolean` determining if the account is empty complying to the definition of\n     * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n     * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n     */\n    isEmpty() {\n        return this.balance === _0n && this.nonce === _0n && this.codeHash.equals(constants_1.KECCAK256_NULL);\n    }\n}\nexports.Account = Account;\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\nconst isValidAddress = function (hexAddress) {\n    try {\n        (0, helpers_1.assertIsString)(hexAddress);\n    }\n    catch (e) {\n        return false;\n    }\n    return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);\n};\nexports.isValidAddress = isValidAddress;\n/**\n * Returns a checksummed address.\n *\n * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not\n * backwards compatible to the original widely adopted checksum format standard introduced in\n * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.\n * Usage of this EIP is therefore discouraged unless you have a very targeted use case.\n */\nconst toChecksumAddress = function (hexAddress, eip1191ChainId) {\n    (0, helpers_1.assertIsHexString)(hexAddress);\n    const address = (0, internal_1.stripHexPrefix)(hexAddress).toLowerCase();\n    let prefix = '';\n    if (eip1191ChainId !== undefined) {\n        const chainId = (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(eip1191ChainId));\n        prefix = chainId.toString() + '0x';\n    }\n    const buf = Buffer.from(prefix + address, 'utf8');\n    const hash = (0, utils_1.bytesToHex)((0, keccak_1.keccak256)(buf));\n    let ret = '0x';\n    for (let i = 0; i < address.length; i++) {\n        if (parseInt(hash[i], 16) >= 8) {\n            ret += address[i].toUpperCase();\n        }\n        else {\n            ret += address[i];\n        }\n    }\n    return ret;\n};\nexports.toChecksumAddress = toChecksumAddress;\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\nconst isValidChecksumAddress = function (hexAddress, eip1191ChainId) {\n    return (0, exports.isValidAddress)(hexAddress) && (0, exports.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;\n};\nexports.isValidChecksumAddress = isValidChecksumAddress;\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\nconst generateAddress = function (from, nonce) {\n    (0, helpers_1.assertIsBuffer)(from);\n    (0, helpers_1.assertIsBuffer)(nonce);\n    if ((0, bytes_1.bufferToBigInt)(nonce) === BigInt(0)) {\n        // in RLP we want to encode null in the case of zero nonce\n        // read the RLP documentation for an answer if you dare\n        return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([from, null])))).slice(-20);\n    }\n    // Only take the lower 160bits of the hash\n    return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([from, nonce])))).slice(-20);\n};\nexports.generateAddress = generateAddress;\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\nconst generateAddress2 = function (from, salt, initCode) {\n    (0, helpers_1.assertIsBuffer)(from);\n    (0, helpers_1.assertIsBuffer)(salt);\n    (0, helpers_1.assertIsBuffer)(initCode);\n    if (from.length !== 20) {\n        throw new Error('Expected from to be of length 20');\n    }\n    if (salt.length !== 32) {\n        throw new Error('Expected salt to be of length 32');\n    }\n    const address = (0, keccak_1.keccak256)(Buffer.concat([Buffer.from('ff', 'hex'), from, salt, (0, keccak_1.keccak256)(initCode)]));\n    return (0, bytes_1.toBuffer)(address).slice(-20);\n};\nexports.generateAddress2 = generateAddress2;\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\nconst isValidPrivate = function (privateKey) {\n    return secp256k1_1.secp256k1.utils.isValidPrivateKey(privateKey);\n};\nexports.isValidPrivate = isValidPrivate;\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nconst isValidPublic = function (publicKey, sanitize = false) {\n    (0, helpers_1.assertIsBuffer)(publicKey);\n    if (publicKey.length === 64) {\n        // Convert to SEC1 for secp256k1\n        // Automatically checks whether point is on curve\n        try {\n            secp256k1_1.secp256k1.ProjectivePoint.fromHex(Buffer.concat([Buffer.from([4]), publicKey]));\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    if (!sanitize) {\n        return false;\n    }\n    try {\n        secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicKey);\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n};\nexports.isValidPublic = isValidPublic;\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nconst pubToAddress = function (pubKey, sanitize = false) {\n    (0, helpers_1.assertIsBuffer)(pubKey);\n    if (sanitize && pubKey.length !== 64) {\n        pubKey = Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromHex(pubKey).toRawBytes(false).slice(1));\n    }\n    if (pubKey.length !== 64) {\n        throw new Error('Expected pubKey to be of length 64');\n    }\n    // Only take the lower 160bits of the hash\n    return Buffer.from((0, keccak_1.keccak256)(pubKey)).slice(-20);\n};\nexports.pubToAddress = pubToAddress;\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nconst privateToPublic = function (privateKey) {\n    (0, helpers_1.assertIsBuffer)(privateKey);\n    // skip the type flag and use the X, Y points\n    return Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(false).slice(1));\n};\nexports.privateToPublic = privateToPublic;\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nconst privateToAddress = function (privateKey) {\n    return (0, exports.publicToAddress)((0, exports.privateToPublic)(privateKey));\n};\nexports.privateToAddress = privateToAddress;\n/**\n * Converts a public key to the Ethereum format.\n */\nconst importPublic = function (publicKey) {\n    (0, helpers_1.assertIsBuffer)(publicKey);\n    if (publicKey.length !== 64) {\n        publicKey = Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicKey).toRawBytes(false).slice(1));\n    }\n    return publicKey;\n};\nexports.importPublic = importPublic;\n/**\n * Returns the zero address.\n */\nconst zeroAddress = function () {\n    const addressLength = 20;\n    const addr = (0, bytes_1.zeros)(addressLength);\n    return (0, bytes_1.bufferToHex)(addr);\n};\nexports.zeroAddress = zeroAddress;\n/**\n * Checks if a given address is the zero address.\n */\nconst isZeroAddress = function (hexAddress) {\n    try {\n        (0, helpers_1.assertIsString)(hexAddress);\n    }\n    catch (e) {\n        return false;\n    }\n    const zeroAddr = (0, exports.zeroAddress)();\n    return zeroAddr === hexAddress;\n};\nexports.isZeroAddress = isZeroAddress;\nfunction accountBodyFromSlim(body) {\n    const [nonce, balance, storageRoot, codeHash] = body;\n    return [\n        nonce,\n        balance,\n        (0, bytes_1.arrToBufArr)(storageRoot).length === 0 ? constants_1.KECCAK256_RLP : storageRoot,\n        (0, bytes_1.arrToBufArr)(codeHash).length === 0 ? constants_1.KECCAK256_NULL : codeHash,\n    ];\n}\nexports.accountBodyFromSlim = accountBodyFromSlim;\nconst emptyUint8Arr = new Uint8Array(0);\nfunction accountBodyToSlim(body) {\n    const [nonce, balance, storageRoot, codeHash] = body;\n    return [\n        nonce,\n        balance,\n        (0, bytes_1.arrToBufArr)(storageRoot).equals(constants_1.KECCAK256_RLP) ? emptyUint8Arr : storageRoot,\n        (0, bytes_1.arrToBufArr)(codeHash).equals(constants_1.KECCAK256_NULL) ? emptyUint8Arr : codeHash,\n    ];\n}\nexports.accountBodyToSlim = accountBodyToSlim;\n/**\n * Converts a slim account (per snap protocol spec) to the RLP encoded version of the account\n * @param body Array of 4 Buffer-like items to represent the account\n * @returns RLP encoded version of the account\n */\nfunction accountBodyToRLP(body, couldBeSlim = true) {\n    const accountBody = couldBeSlim ? accountBodyFromSlim(body) : body;\n    return (0, bytes_1.arrToBufArr)(rlp_1.RLP.encode(accountBody));\n}\nexports.accountBodyToRLP = accountBodyToRLP;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Address = void 0;\nconst account_1 = require(\"./account\");\nconst bytes_1 = require(\"./bytes\");\n/**\n * Handling and generating Ethereum addresses\n */\nclass Address {\n    constructor(buf) {\n        if (buf.length !== 20) {\n            throw new Error('Invalid address length');\n        }\n        this.buf = buf;\n    }\n    /**\n     * Returns the zero address.\n     */\n    static zero() {\n        return new Address((0, bytes_1.zeros)(20));\n    }\n    /**\n     * Returns an Address object from a hex-encoded string.\n     * @param str - Hex-encoded address\n     */\n    static fromString(str) {\n        if (!(0, account_1.isValidAddress)(str)) {\n            throw new Error('Invalid address');\n        }\n        return new Address((0, bytes_1.toBuffer)(str));\n    }\n    /**\n     * Returns an address for a given public key.\n     * @param pubKey The two points of an uncompressed key\n     */\n    static fromPublicKey(pubKey) {\n        if (!Buffer.isBuffer(pubKey)) {\n            throw new Error('Public key should be Buffer');\n        }\n        const buf = (0, account_1.pubToAddress)(pubKey);\n        return new Address(buf);\n    }\n    /**\n     * Returns an address for a given private key.\n     * @param privateKey A private key must be 256 bits wide\n     */\n    static fromPrivateKey(privateKey) {\n        if (!Buffer.isBuffer(privateKey)) {\n            throw new Error('Private key should be Buffer');\n        }\n        const buf = (0, account_1.privateToAddress)(privateKey);\n        return new Address(buf);\n    }\n    /**\n     * Generates an address for a newly created contract.\n     * @param from The address which is creating this new address\n     * @param nonce The nonce of the from account\n     */\n    static generate(from, nonce) {\n        if (typeof nonce !== 'bigint') {\n            throw new Error('Expected nonce to be a bigint');\n        }\n        return new Address((0, account_1.generateAddress)(from.buf, (0, bytes_1.bigIntToBuffer)(nonce)));\n    }\n    /**\n     * Generates an address for a contract created using CREATE2.\n     * @param from The address which is creating this new address\n     * @param salt A salt\n     * @param initCode The init code of the contract being created\n     */\n    static generate2(from, salt, initCode) {\n        if (!Buffer.isBuffer(salt)) {\n            throw new Error('Expected salt to be a Buffer');\n        }\n        if (!Buffer.isBuffer(initCode)) {\n            throw new Error('Expected initCode to be a Buffer');\n        }\n        return new Address((0, account_1.generateAddress2)(from.buf, salt, initCode));\n    }\n    /**\n     * Is address equal to another.\n     */\n    equals(address) {\n        return this.buf.equals(address.buf);\n    }\n    /**\n     * Is address zero.\n     */\n    isZero() {\n        return this.equals(Address.zero());\n    }\n    /**\n     * True if address is in the address range defined\n     * by EIP-1352\n     */\n    isPrecompileOrSystemAddress() {\n        const address = (0, bytes_1.bufferToBigInt)(this.buf);\n        const rangeMin = BigInt(0);\n        const rangeMax = BigInt('0xffff');\n        return address >= rangeMin && address <= rangeMax;\n    }\n    /**\n     * Returns hex encoding of address.\n     */\n    toString() {\n        return '0x' + this.buf.toString('hex');\n    }\n    /**\n     * Returns Buffer representation of address.\n     */\n    toBuffer() {\n        return Buffer.from(this.buf);\n    }\n}\nexports.Address = Address;\n","\"use strict\";\n/**\n * Ported to Typescript from original implementation below:\n * https://github.com/ahultgren/async-eventemitter -- MIT licensed\n *\n * Type Definitions based on work by: patarapolw <https://github.com/patarapolw> -- MIT licensed\n * that was contributed to Definitely Typed below:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/async-eventemitter\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AsyncEventEmitter = void 0;\nconst events_1 = require(\"events\");\nasync function runInSeries(context, tasks, data) {\n    let error;\n    for await (const task of tasks) {\n        try {\n            if (task.length < 2) {\n                //sync\n                task.call(context, data);\n            }\n            else {\n                await new Promise((resolve, reject) => {\n                    task.call(context, data, (error) => {\n                        if (error) {\n                            reject(error);\n                        }\n                        else {\n                            resolve();\n                        }\n                    });\n                });\n            }\n        }\n        catch (e) {\n            error = e;\n        }\n    }\n    if (error) {\n        throw error;\n    }\n}\nclass AsyncEventEmitter extends events_1.EventEmitter {\n    emit(event, ...args) {\n        let [data, callback] = args;\n        const self = this;\n        let listeners = self._events[event] ?? [];\n        // Optional data argument\n        if (callback === undefined && typeof data === 'function') {\n            callback = data;\n            data = undefined;\n        }\n        // Special treatment of internal newListener and removeListener events\n        if (event === 'newListener' || event === 'removeListener') {\n            data = {\n                event: data,\n                fn: callback,\n            };\n            callback = undefined;\n        }\n        // A single listener is just a function not an array...\n        listeners = Array.isArray(listeners) ? listeners : [listeners];\n        runInSeries(self, listeners.slice(), data).then(callback).catch(callback);\n        return self.listenerCount(event) > 0;\n    }\n    once(event, listener) {\n        const self = this;\n        let g;\n        if (typeof listener !== 'function') {\n            throw new TypeError('listener must be a function');\n        }\n        // Hack to support set arity\n        if (listener.length >= 2) {\n            g = function (e, next) {\n                self.removeListener(event, g);\n                void listener(e, next);\n            };\n        }\n        else {\n            g = function (e) {\n                self.removeListener(event, g);\n                void listener(e, g);\n            };\n        }\n        self.on(event, g);\n        return self;\n    }\n    first(event, listener) {\n        let listeners = this._events[event] ?? [];\n        // Contract\n        if (typeof listener !== 'function') {\n            throw new TypeError('listener must be a function');\n        }\n        // Listeners are not always an array\n        if (!Array.isArray(listeners)) {\n            ;\n            this._events[event] = listeners = [listeners];\n        }\n        listeners.unshift(listener);\n        return this;\n    }\n    before(event, target, listener) {\n        return this.beforeOrAfter(event, target, listener);\n    }\n    after(event, target, listener) {\n        return this.beforeOrAfter(event, target, listener, 'after');\n    }\n    beforeOrAfter(event, target, listener, beforeOrAfter) {\n        let listeners = this._events[event] ?? [];\n        let i;\n        let index;\n        const add = beforeOrAfter === 'after' ? 1 : 0;\n        // Contract\n        if (typeof listener !== 'function') {\n            throw new TypeError('listener must be a function');\n        }\n        if (typeof target !== 'function') {\n            throw new TypeError('target must be a function');\n        }\n        // Listeners are not always an array\n        if (!Array.isArray(listeners)) {\n            ;\n            this._events[event] = listeners = [listeners];\n        }\n        index = listeners.length;\n        for (i = listeners.length; i--;) {\n            if (listeners[i] === target) {\n                index = i + add;\n                break;\n            }\n        }\n        listeners.splice(index, 0, listener);\n        return this;\n    }\n    on(event, listener) {\n        return super.on(event, listener);\n    }\n    addListener(event, listener) {\n        return super.addListener(event, listener);\n    }\n    prependListener(event, listener) {\n        return super.prependListener(event, listener);\n    }\n    prependOnceListener(event, listener) {\n        return super.prependOnceListener(event, listener);\n    }\n    removeAllListeners(event) {\n        return super.removeAllListeners(event);\n    }\n    removeListener(event, listener) {\n        return super.removeListener(event, listener);\n    }\n    eventNames() {\n        return super.eventNames();\n    }\n    listeners(event) {\n        return super.listeners(event);\n    }\n    listenerCount(event) {\n        return super.listenerCount(event);\n    }\n    getMaxListeners() {\n        return super.getMaxListeners();\n    }\n    setMaxListeners(maxListeners) {\n        return super.setMaxListeners(maxListeners);\n    }\n}\nexports.AsyncEventEmitter = AsyncEventEmitter;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.intToUnpaddedBuffer = exports.bigIntToUnpaddedBuffer = exports.bigIntToHex = exports.bufArrToArr = exports.arrToBufArr = exports.validateNoLeadingZeroes = exports.baToJSON = exports.toUtf8 = exports.short = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToInt = exports.bigIntToBuffer = exports.bufferToBigInt = exports.bufferToHex = exports.toBuffer = exports.unpadHexString = exports.unpadArray = exports.unpadBuffer = exports.setLengthRight = exports.setLengthLeft = exports.zeros = exports.intToBuffer = exports.intToHex = void 0;\nconst helpers_1 = require(\"./helpers\");\nconst internal_1 = require(\"./internal\");\n/**\n * Converts a `Number` into a hex `String`\n * @param {Number} i\n * @return {String}\n */\nconst intToHex = function (i) {\n    if (!Number.isSafeInteger(i) || i < 0) {\n        throw new Error(`Received an invalid integer type: ${i}`);\n    }\n    return `0x${i.toString(16)}`;\n};\nexports.intToHex = intToHex;\n/**\n * Converts an `Number` to a `Buffer`\n * @param {Number} i\n * @return {Buffer}\n */\nconst intToBuffer = function (i) {\n    const hex = (0, exports.intToHex)(i);\n    return Buffer.from((0, internal_1.padToEven)(hex.slice(2)), 'hex');\n};\nexports.intToBuffer = intToBuffer;\n/**\n * Returns a buffer filled with 0s.\n * @param bytes the number of bytes the buffer should be\n */\nconst zeros = function (bytes) {\n    return Buffer.allocUnsafe(bytes).fill(0);\n};\nexports.zeros = zeros;\n/**\n * Pads a `Buffer` with zeros till it has `length` bytes.\n * Truncates the beginning or end of input if its length exceeds `length`.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @param right whether to start padding form the left or right\n * @return (Buffer)\n */\nconst setLength = function (msg, length, right) {\n    const buf = (0, exports.zeros)(length);\n    if (right) {\n        if (msg.length < length) {\n            msg.copy(buf);\n            return buf;\n        }\n        return msg.slice(0, length);\n    }\n    else {\n        if (msg.length < length) {\n            msg.copy(buf, length - msg.length);\n            return buf;\n        }\n        return msg.slice(-length);\n    }\n};\n/**\n * Left Pads a `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @return (Buffer)\n */\nconst setLengthLeft = function (msg, length) {\n    (0, helpers_1.assertIsBuffer)(msg);\n    return setLength(msg, length, false);\n};\nexports.setLengthLeft = setLengthLeft;\n/**\n * Right Pads a `Buffer` with trailing zeros till it has `length` bytes.\n * it truncates the end if it exceeds.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @return (Buffer)\n */\nconst setLengthRight = function (msg, length) {\n    (0, helpers_1.assertIsBuffer)(msg);\n    return setLength(msg, length, true);\n};\nexports.setLengthRight = setLengthRight;\n/**\n * Trims leading zeros from a `Buffer`, `String` or `Number[]`.\n * @param a (Buffer|Array|String)\n * @return (Buffer|Array|String)\n */\nconst stripZeros = function (a) {\n    let first = a[0];\n    while (a.length > 0 && first.toString() === '0') {\n        a = a.slice(1);\n        first = a[0];\n    }\n    return a;\n};\n/**\n * Trims leading zeros from a `Buffer`.\n * @param a (Buffer)\n * @return (Buffer)\n */\nconst unpadBuffer = function (a) {\n    (0, helpers_1.assertIsBuffer)(a);\n    return stripZeros(a);\n};\nexports.unpadBuffer = unpadBuffer;\n/**\n * Trims leading zeros from an `Array` (of numbers).\n * @param a (number[])\n * @return (number[])\n */\nconst unpadArray = function (a) {\n    (0, helpers_1.assertIsArray)(a);\n    return stripZeros(a);\n};\nexports.unpadArray = unpadArray;\n/**\n * Trims leading zeros from a hex-prefixed `String`.\n * @param a (String)\n * @return (String)\n */\nconst unpadHexString = function (a) {\n    (0, helpers_1.assertIsHexString)(a);\n    a = (0, internal_1.stripHexPrefix)(a);\n    return ('0x' + stripZeros(a));\n};\nexports.unpadHexString = unpadHexString;\n/**\n * Attempts to turn a value into a `Buffer`.\n * Inputs supported: `Buffer`, `String` (hex-prefixed), `Number`, null/undefined, `BigInt` and other objects\n * with a `toArray()` or `toBuffer()` method.\n * @param v the value\n */\nconst toBuffer = function (v) {\n    if (v === null || v === undefined) {\n        return Buffer.allocUnsafe(0);\n    }\n    if (Buffer.isBuffer(v)) {\n        return Buffer.from(v);\n    }\n    if (Array.isArray(v) || v instanceof Uint8Array) {\n        return Buffer.from(v);\n    }\n    if (typeof v === 'string') {\n        if (!(0, internal_1.isHexString)(v)) {\n            throw new Error(`Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${v}`);\n        }\n        return Buffer.from((0, internal_1.padToEven)((0, internal_1.stripHexPrefix)(v)), 'hex');\n    }\n    if (typeof v === 'number') {\n        return (0, exports.intToBuffer)(v);\n    }\n    if (typeof v === 'bigint') {\n        if (v < BigInt(0)) {\n            throw new Error(`Cannot convert negative bigint to buffer. Given: ${v}`);\n        }\n        let n = v.toString(16);\n        if (n.length % 2)\n            n = '0' + n;\n        return Buffer.from(n, 'hex');\n    }\n    if (v.toArray) {\n        // converts a BN to a Buffer\n        return Buffer.from(v.toArray());\n    }\n    if (v.toBuffer) {\n        return Buffer.from(v.toBuffer());\n    }\n    throw new Error('invalid type');\n};\nexports.toBuffer = toBuffer;\n/**\n * Converts a `Buffer` into a `0x`-prefixed hex `String`.\n * @param buf `Buffer` object to convert\n */\nconst bufferToHex = function (buf) {\n    buf = (0, exports.toBuffer)(buf);\n    return '0x' + buf.toString('hex');\n};\nexports.bufferToHex = bufferToHex;\n/**\n * Converts a {@link Buffer} to a {@link bigint}\n */\nfunction bufferToBigInt(buf) {\n    const hex = (0, exports.bufferToHex)(buf);\n    if (hex === '0x') {\n        return BigInt(0);\n    }\n    return BigInt(hex);\n}\nexports.bufferToBigInt = bufferToBigInt;\n/**\n * Converts a {@link bigint} to a {@link Buffer}\n */\nfunction bigIntToBuffer(num) {\n    return (0, exports.toBuffer)('0x' + num.toString(16));\n}\nexports.bigIntToBuffer = bigIntToBuffer;\n/**\n * Converts a `Buffer` to a `Number`.\n * @param buf `Buffer` object to convert\n * @throws If the input number exceeds 53 bits.\n */\nconst bufferToInt = function (buf) {\n    const res = Number(bufferToBigInt(buf));\n    if (!Number.isSafeInteger(res))\n        throw new Error('Number exceeds 53 bits');\n    return res;\n};\nexports.bufferToInt = bufferToInt;\n/**\n * Interprets a `Buffer` as a signed integer and returns a `BigInt`. Assumes 256-bit numbers.\n * @param num Signed integer value\n */\nconst fromSigned = function (num) {\n    return BigInt.asIntN(256, bufferToBigInt(num));\n};\nexports.fromSigned = fromSigned;\n/**\n * Converts a `BigInt` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.\n * @param num\n */\nconst toUnsigned = function (num) {\n    return bigIntToBuffer(BigInt.asUintN(256, num));\n};\nexports.toUnsigned = toUnsigned;\n/**\n * Adds \"0x\" to a given `String` if it does not already start with \"0x\".\n */\nconst addHexPrefix = function (str) {\n    if (typeof str !== 'string') {\n        return str;\n    }\n    return (0, internal_1.isHexPrefixed)(str) ? str : '0x' + str;\n};\nexports.addHexPrefix = addHexPrefix;\n/**\n * Shortens a string  or buffer's hex string representation to maxLength (default 50).\n *\n * Examples:\n *\n * Input:  '657468657265756d000000000000000000000000000000000000000000000000'\n * Output: '657468657265756d0000000000000000000000000000000000'\n */\nfunction short(buffer, maxLength = 50) {\n    const bufferStr = Buffer.isBuffer(buffer) ? buffer.toString('hex') : buffer;\n    if (bufferStr.length <= maxLength) {\n        return bufferStr;\n    }\n    return bufferStr.slice(0, maxLength) + '';\n}\nexports.short = short;\n/**\n * Returns the utf8 string representation from a hex string.\n *\n * Examples:\n *\n * Input 1: '657468657265756d000000000000000000000000000000000000000000000000'\n * Input 2: '657468657265756d'\n * Input 3: '000000000000000000000000000000000000000000000000657468657265756d'\n *\n * Output (all 3 input variants): 'ethereum'\n *\n * Note that this method is not intended to be used with hex strings\n * representing quantities in both big endian or little endian notation.\n *\n * @param string Hex string, should be `0x` prefixed\n * @return Utf8 string\n */\nconst toUtf8 = function (hex) {\n    const zerosRegexp = /^(00)+|(00)+$/g;\n    hex = (0, internal_1.stripHexPrefix)(hex);\n    if (hex.length % 2 !== 0) {\n        throw new Error('Invalid non-even hex string input for toUtf8() provided');\n    }\n    const bufferVal = Buffer.from(hex.replace(zerosRegexp, ''), 'hex');\n    return bufferVal.toString('utf8');\n};\nexports.toUtf8 = toUtf8;\n/**\n * Converts a `Buffer` or `Array` to JSON.\n * @param ba (Buffer|Array)\n * @return (Array|String|null)\n */\nconst baToJSON = function (ba) {\n    if (Buffer.isBuffer(ba)) {\n        return `0x${ba.toString('hex')}`;\n    }\n    else if (ba instanceof Array) {\n        const array = [];\n        for (let i = 0; i < ba.length; i++) {\n            array.push((0, exports.baToJSON)(ba[i]));\n        }\n        return array;\n    }\n};\nexports.baToJSON = baToJSON;\n/**\n * Checks provided Buffers for leading zeroes and throws if found.\n *\n * Examples:\n *\n * Valid values: 0x1, 0x, 0x01, 0x1234\n * Invalid values: 0x0, 0x00, 0x001, 0x0001\n *\n * Note: This method is useful for validating that RLP encoded integers comply with the rule that all\n * integer values encoded to RLP must be in the most compact form and contain no leading zero bytes\n * @param values An object containing string keys and Buffer values\n * @throws if any provided value is found to have leading zero bytes\n */\nconst validateNoLeadingZeroes = function (values) {\n    for (const [k, v] of Object.entries(values)) {\n        if (v !== undefined && v.length > 0 && v[0] === 0) {\n            throw new Error(`${k} cannot have leading zeroes, received: ${v.toString('hex')}`);\n        }\n    }\n};\nexports.validateNoLeadingZeroes = validateNoLeadingZeroes;\nfunction arrToBufArr(arr) {\n    if (!Array.isArray(arr)) {\n        return Buffer.from(arr);\n    }\n    return arr.map((a) => arrToBufArr(a));\n}\nexports.arrToBufArr = arrToBufArr;\nfunction bufArrToArr(arr) {\n    if (!Array.isArray(arr)) {\n        return Uint8Array.from(arr ?? []);\n    }\n    return arr.map((a) => bufArrToArr(a));\n}\nexports.bufArrToArr = bufArrToArr;\n/**\n * Converts a {@link bigint} to a `0x` prefixed hex string\n */\nconst bigIntToHex = (num) => {\n    return '0x' + num.toString(16);\n};\nexports.bigIntToHex = bigIntToHex;\n/**\n * Convert value from bigint to an unpadded Buffer\n * (useful for RLP transport)\n * @param value value to convert\n */\nfunction bigIntToUnpaddedBuffer(value) {\n    return (0, exports.unpadBuffer)(bigIntToBuffer(value));\n}\nexports.bigIntToUnpaddedBuffer = bigIntToUnpaddedBuffer;\nfunction intToUnpaddedBuffer(value) {\n    return (0, exports.unpadBuffer)((0, exports.intToBuffer)(value));\n}\nexports.intToUnpaddedBuffer = intToUnpaddedBuffer;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MAX_WITHDRAWALS_PER_PAYLOAD = exports.RLP_EMPTY_STRING = exports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.SECP256K1_ORDER_DIV_2 = exports.SECP256K1_ORDER = exports.MAX_INTEGER_BIGINT = exports.MAX_INTEGER = exports.MAX_UINT64 = void 0;\nconst buffer_1 = require(\"buffer\");\nconst secp256k1_1 = require(\"ethereum-cryptography/secp256k1\");\n/**\n * 2^64-1\n */\nexports.MAX_UINT64 = BigInt('0xffffffffffffffff');\n/**\n * The max integer that the evm can handle (2^256-1)\n */\nexports.MAX_INTEGER = BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\n/**\n * The max integer that the evm can handle (2^256-1) as a bigint\n * 2^256-1 equals to 340282366920938463463374607431768211455\n * We use literal value instead of calculated value for compatibility issue.\n */\nexports.MAX_INTEGER_BIGINT = BigInt('115792089237316195423570985008687907853269984665640564039457584007913129639935');\nexports.SECP256K1_ORDER = secp256k1_1.secp256k1.CURVE.n;\nexports.SECP256K1_ORDER_DIV_2 = secp256k1_1.secp256k1.CURVE.n / BigInt(2);\n/**\n * 2^256\n */\nexports.TWO_POW256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');\n/**\n * Keccak-256 hash of null\n */\nexports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';\n/**\n * Keccak-256 hash of null\n */\nexports.KECCAK256_NULL = buffer_1.Buffer.from(exports.KECCAK256_NULL_S, 'hex');\n/**\n * Keccak-256 of an RLP of an empty array\n */\nexports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';\n/**\n * Keccak-256 of an RLP of an empty array\n */\nexports.KECCAK256_RLP_ARRAY = buffer_1.Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');\n/**\n * Keccak-256 hash of the RLP of null\n */\nexports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';\n/**\n * Keccak-256 hash of the RLP of null\n */\nexports.KECCAK256_RLP = buffer_1.Buffer.from(exports.KECCAK256_RLP_S, 'hex');\n/**\n *  RLP encoded empty string\n */\nexports.RLP_EMPTY_STRING = buffer_1.Buffer.from([0x80]);\nexports.MAX_WITHDRAWALS_PER_PAYLOAD = 16;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.compactBytesToNibbles = exports.bytesToNibbles = exports.nibblesToCompactBytes = exports.nibblesToBytes = exports.hasTerminator = void 0;\n// Reference: https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/\n/**\n *\n * @param s byte sequence\n * @returns boolean indicating if input hex nibble sequence has terminator indicating leaf-node\n *          terminator is represented with 16 because a nibble ranges from 0 - 15(f)\n */\nconst hasTerminator = (nibbles) => {\n    return nibbles.length > 0 && nibbles[nibbles.length - 1] === 16;\n};\nexports.hasTerminator = hasTerminator;\nconst nibblesToBytes = (nibbles, bytes) => {\n    for (let bi = 0, ni = 0; ni < nibbles.length; bi += 1, ni += 2) {\n        bytes[bi] = (nibbles[ni] << 4) | nibbles[ni + 1];\n    }\n};\nexports.nibblesToBytes = nibblesToBytes;\nconst nibblesToCompactBytes = (nibbles) => {\n    let terminator = 0;\n    if ((0, exports.hasTerminator)(nibbles)) {\n        terminator = 1;\n        // Remove the terminator from the sequence\n        nibbles = nibbles.subarray(0, nibbles.length - 1);\n    }\n    const buf = new Uint8Array(nibbles.length / 2 + 1);\n    // Shift the terminator info into the first nibble of buf[0]\n    buf[0] = terminator << 5;\n    // If odd length, then add that flag into the first nibble and put the odd nibble to\n    // second part of buf[0] which otherwise will be left padded with a 0\n    if ((nibbles.length & 1) === 1) {\n        buf[0] |= 1 << 4;\n        buf[0] |= nibbles[0];\n        nibbles = nibbles.subarray(1);\n    }\n    // create bytes out of the rest even nibbles\n    (0, exports.nibblesToBytes)(nibbles, buf.subarray(1));\n    return buf;\n};\nexports.nibblesToCompactBytes = nibblesToCompactBytes;\nconst bytesToNibbles = (str) => {\n    const l = str.length * 2 + 1;\n    const nibbles = new Uint8Array(l);\n    for (let i = 0; i < str.length; i++) {\n        const b = str[i];\n        nibbles[i * 2] = b / 16;\n        nibbles[i * 2 + 1] = b % 16;\n    }\n    // This will get removed from calling function if the first nibble\n    // indicates that terminator is not present\n    nibbles[l - 1] = 16;\n    return nibbles;\n};\nexports.bytesToNibbles = bytesToNibbles;\nconst compactBytesToNibbles = (compact) => {\n    if (compact.length === 0) {\n        return compact;\n    }\n    let base = (0, exports.bytesToNibbles)(compact);\n    // delete terminator flag if terminator flag was not in first nibble\n    if (base[0] < 2) {\n        base = base.subarray(0, base.length - 1);\n    }\n    // chop the terminator nibble and the even padding (if there is one)\n    // i.e.  chop 2 left nibbles when even else 1 when odd\n    const chop = 2 - (base[0] & 1);\n    return base.subarray(chop);\n};\nexports.compactBytesToNibbles = compactBytesToNibbles;\n/**\n * A test helper to generates compact path for a subset of key bytes\n *\n * TODO: Commenting the code for now as this seems to be helper function\n * (from geth codebase )\n *\n */\n//\n//\n// export const getPathTo = (tillBytes: number, key: Buffer) => {\n//   const hexNibbles = bytesToNibbles(key).subarray(0, tillBytes)\n//   // Remove the terminator if its there, although it would be there only if tillBytes >= key.length\n//   // This seems to be a test helper to generate paths so correctness of this isn't necessary\n//   hexNibbles[hexNibbles.length - 1] = 0\n//   const compactBytes = nibblesToCompactBytes(hexNibbles)\n//   return [Buffer.from(compactBytes)]\n// }\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assertIsString = exports.assertIsArray = exports.assertIsBuffer = exports.assertIsHexString = void 0;\nconst internal_1 = require(\"./internal\");\n/**\n * Throws if a string is not hex prefixed\n * @param {string} input string to check hex prefix of\n */\nconst assertIsHexString = function (input) {\n    if (!(0, internal_1.isHexString)(input)) {\n        const msg = `This method only supports 0x-prefixed hex strings but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsHexString = assertIsHexString;\n/**\n * Throws if input is not a buffer\n * @param {Buffer} input value to check\n */\nconst assertIsBuffer = function (input) {\n    if (!Buffer.isBuffer(input)) {\n        const msg = `This method only supports Buffer but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsBuffer = assertIsBuffer;\n/**\n * Throws if input is not an array\n * @param {number[]} input value to check\n */\nconst assertIsArray = function (input) {\n    if (!Array.isArray(input)) {\n        const msg = `This method only supports number arrays but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsArray = assertIsArray;\n/**\n * Throws if input is not a string\n * @param {string} input value to check\n */\nconst assertIsString = function (input) {\n    if (typeof input !== 'string') {\n        const msg = `This method only supports strings but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsString = assertIsString;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toAscii = exports.stripHexPrefix = exports.padToEven = exports.isHexString = exports.isHexPrefixed = exports.getKeys = exports.getBinarySize = exports.fromUtf8 = exports.fromAscii = exports.arrayContainsArray = void 0;\n/**\n * Constants\n */\n__exportStar(require(\"./constants\"), exports);\n/**\n * Units helpers\n */\n__exportStar(require(\"./units\"), exports);\n/**\n * Account class and helper functions\n */\n__exportStar(require(\"./account\"), exports);\n/**\n * Address type\n */\n__exportStar(require(\"./address\"), exports);\n/**\n * Withdrawal type\n */\n__exportStar(require(\"./withdrawal\"), exports);\n/**\n * ECDSA signature\n */\n__exportStar(require(\"./signature\"), exports);\n/**\n * Utilities for manipulating Buffers, byte arrays, etc.\n */\n__exportStar(require(\"./bytes\"), exports);\n/**\n * Helpful TypeScript types\n */\n__exportStar(require(\"./types\"), exports);\n/**\n * Helper function for working with compact encoding\n */\n__exportStar(require(\"./encoding\"), exports);\n/**\n * Export ethjs-util methods\n */\n__exportStar(require(\"./asyncEventEmitter\"), exports);\nvar internal_1 = require(\"./internal\");\nObject.defineProperty(exports, \"arrayContainsArray\", { enumerable: true, get: function () { return internal_1.arrayContainsArray; } });\nObject.defineProperty(exports, \"fromAscii\", { enumerable: true, get: function () { return internal_1.fromAscii; } });\nObject.defineProperty(exports, \"fromUtf8\", { enumerable: true, get: function () { return internal_1.fromUtf8; } });\nObject.defineProperty(exports, \"getBinarySize\", { enumerable: true, get: function () { return internal_1.getBinarySize; } });\nObject.defineProperty(exports, \"getKeys\", { enumerable: true, get: function () { return internal_1.getKeys; } });\nObject.defineProperty(exports, \"isHexPrefixed\", { enumerable: true, get: function () { return internal_1.isHexPrefixed; } });\nObject.defineProperty(exports, \"isHexString\", { enumerable: true, get: function () { return internal_1.isHexString; } });\nObject.defineProperty(exports, \"padToEven\", { enumerable: true, get: function () { return internal_1.padToEven; } });\nObject.defineProperty(exports, \"stripHexPrefix\", { enumerable: true, get: function () { return internal_1.stripHexPrefix; } });\nObject.defineProperty(exports, \"toAscii\", { enumerable: true, get: function () { return internal_1.toAscii; } });\n__exportStar(require(\"./lock\"), exports);\n__exportStar(require(\"./provider\"), exports);\n","\"use strict\";\n/*\nThe MIT License\n\nCopyright (c) 2016 Nick Dodson. nickdodson.com\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isHexString = exports.getKeys = exports.fromAscii = exports.fromUtf8 = exports.toAscii = exports.arrayContainsArray = exports.getBinarySize = exports.padToEven = exports.stripHexPrefix = exports.isHexPrefixed = void 0;\n/**\n * Returns a `Boolean` on whether or not the a `String` starts with '0x'\n * @param str the string input value\n * @return a boolean if it is or is not hex prefixed\n * @throws if the str input is not a string\n */\nfunction isHexPrefixed(str) {\n    if (typeof str !== 'string') {\n        throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof str}`);\n    }\n    return str[0] === '0' && str[1] === 'x';\n}\nexports.isHexPrefixed = isHexPrefixed;\n/**\n * Removes '0x' from a given `String` if present\n * @param str the string value\n * @returns the string without 0x prefix\n */\nconst stripHexPrefix = (str) => {\n    if (typeof str !== 'string')\n        throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof str}`);\n    return isHexPrefixed(str) ? str.slice(2) : str;\n};\nexports.stripHexPrefix = stripHexPrefix;\n/**\n * Pads a `String` to have an even length\n * @param value\n * @return output\n */\nfunction padToEven(value) {\n    let a = value;\n    if (typeof a !== 'string') {\n        throw new Error(`[padToEven] value must be type 'string', received ${typeof a}`);\n    }\n    if (a.length % 2)\n        a = `0${a}`;\n    return a;\n}\nexports.padToEven = padToEven;\n/**\n * Get the binary size of a string\n * @param str\n * @returns the number of bytes contained within the string\n */\nfunction getBinarySize(str) {\n    if (typeof str !== 'string') {\n        throw new Error(`[getBinarySize] method requires input type 'string', received ${typeof str}`);\n    }\n    return Buffer.byteLength(str, 'utf8');\n}\nexports.getBinarySize = getBinarySize;\n/**\n * Returns TRUE if the first specified array contains all elements\n * from the second one. FALSE otherwise.\n *\n * @param superset\n * @param subset\n *\n */\nfunction arrayContainsArray(superset, subset, some) {\n    if (Array.isArray(superset) !== true) {\n        throw new Error(`[arrayContainsArray] method requires input 'superset' to be an array, got type '${typeof superset}'`);\n    }\n    if (Array.isArray(subset) !== true) {\n        throw new Error(`[arrayContainsArray] method requires input 'subset' to be an array, got type '${typeof subset}'`);\n    }\n    return subset[some === true ? 'some' : 'every']((value) => superset.indexOf(value) >= 0);\n}\nexports.arrayContainsArray = arrayContainsArray;\n/**\n * Should be called to get ascii from its hex representation\n *\n * @param string in hex\n * @returns ascii string representation of hex value\n */\nfunction toAscii(hex) {\n    let str = '';\n    let i = 0;\n    const l = hex.length;\n    if (hex.substring(0, 2) === '0x')\n        i = 2;\n    for (; i < l; i += 2) {\n        const code = parseInt(hex.substr(i, 2), 16);\n        str += String.fromCharCode(code);\n    }\n    return str;\n}\nexports.toAscii = toAscii;\n/**\n * Should be called to get hex representation (prefixed by 0x) of utf8 string\n *\n * @param string\n * @param optional padding\n * @returns hex representation of input string\n */\nfunction fromUtf8(stringValue) {\n    const str = Buffer.from(stringValue, 'utf8');\n    return `0x${padToEven(str.toString('hex')).replace(/^0+|0+$/g, '')}`;\n}\nexports.fromUtf8 = fromUtf8;\n/**\n * Should be called to get hex representation (prefixed by 0x) of ascii string\n *\n * @param  string\n * @param  optional padding\n * @returns  hex representation of input string\n */\nfunction fromAscii(stringValue) {\n    let hex = '';\n    for (let i = 0; i < stringValue.length; i++) {\n        const code = stringValue.charCodeAt(i);\n        const n = code.toString(16);\n        hex += n.length < 2 ? `0${n}` : n;\n    }\n    return `0x${hex}`;\n}\nexports.fromAscii = fromAscii;\n/**\n * Returns the keys from an array of objects.\n * @example\n * ```js\n * getKeys([{a: '1', b: '2'}, {a: '3', b: '4'}], 'a') => ['1', '3']\n *````\n * @param  params\n * @param  key\n * @param  allowEmpty\n * @returns output just a simple array of output keys\n */\nfunction getKeys(params, key, allowEmpty) {\n    if (!Array.isArray(params)) {\n        throw new Error(`[getKeys] method expects input 'params' to be an array, got ${typeof params}`);\n    }\n    if (typeof key !== 'string') {\n        throw new Error(`[getKeys] method expects input 'key' to be type 'string', got ${typeof params}`);\n    }\n    const result = [];\n    for (let i = 0; i < params.length; i++) {\n        let value = params[i][key];\n        if (allowEmpty === true && !value) {\n            value = '';\n        }\n        else if (typeof value !== 'string') {\n            throw new Error(`invalid abi - expected type 'string', received ${typeof value}`);\n        }\n        result.push(value);\n    }\n    return result;\n}\nexports.getKeys = getKeys;\n/**\n * Is the string a hex string.\n *\n * @param  value\n * @param  length\n * @returns  output the string is a hex string\n */\nfunction isHexString(value, length) {\n    if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/))\n        return false;\n    if (typeof length !== 'undefined' && length > 0 && value.length !== 2 + 2 * length)\n        return false;\n    return true;\n}\nexports.isHexString = isHexString;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Lock = void 0;\n// Based on https://github.com/jsoendermann/semaphore-async-await/blob/master/src/Semaphore.ts\nclass Lock {\n    constructor() {\n        this.permits = 1;\n        this.promiseResolverQueue = [];\n    }\n    /**\n     * Returns a promise used to wait for a permit to become available. This method should be awaited on.\n     * @returns  A promise that gets resolved when execution is allowed to proceed.\n     */\n    async acquire() {\n        if (this.permits > 0) {\n            this.permits -= 1;\n            return Promise.resolve(true);\n        }\n        // If there is no permit available, we return a promise that resolves once the semaphore gets\n        // signaled enough times that permits is equal to one.\n        return new Promise((resolver) => this.promiseResolverQueue.push(resolver));\n    }\n    /**\n     * Increases the number of permits by one. If there are other functions waiting, one of them will\n     * continue to execute in a future iteration of the event loop.\n     */\n    release() {\n        this.permits += 1;\n        if (this.permits > 1 && this.promiseResolverQueue.length > 0) {\n            // eslint-disable-next-line no-console\n            console.warn('Lock.permits should never be > 0 when there is someone waiting.');\n        }\n        else if (this.permits === 1 && this.promiseResolverQueue.length > 0) {\n            // If there is someone else waiting, immediately consume the permit that was released\n            // at the beginning of this function and let the waiting function resume.\n            this.permits -= 1;\n            const nextResolver = this.promiseResolverQueue.shift();\n            if (nextResolver) {\n                nextResolver(true);\n            }\n        }\n    }\n}\nexports.Lock = Lock;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getProvider = exports.fetchFromProvider = void 0;\nconst micro_ftch_1 = require(\"micro-ftch\");\nconst fetchFromProvider = async (url, params) => {\n    const res = await (0, micro_ftch_1.default)(url, {\n        headers: {\n            'content-type': 'application/json',\n        },\n        type: 'json',\n        data: {\n            method: params.method,\n            params: params.params,\n            jsonrpc: '2.0',\n            id: 1,\n        },\n    });\n    return res.result;\n};\nexports.fetchFromProvider = fetchFromProvider;\nconst getProvider = (provider) => {\n    if (typeof provider === 'string') {\n        return provider;\n    }\n    else if (provider?.connection?.url !== undefined) {\n        return provider.connection.url;\n    }\n    else {\n        throw new Error('Must provide valid provider URL or Web3Provider');\n    }\n};\nexports.getProvider = getProvider;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toCompactSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;\nconst keccak_1 = require(\"ethereum-cryptography/keccak\");\nconst secp256k1_1 = require(\"ethereum-cryptography/secp256k1\");\nconst bytes_1 = require(\"./bytes\");\nconst constants_1 = require(\"./constants\");\nconst helpers_1 = require(\"./helpers\");\n/**\n * Returns the ECDSA signature of a message hash.\n *\n * If `chainId` is provided assume an EIP-155-style signature and calculate the `v` value\n * accordingly, otherwise return a \"static\" `v` just derived from the `recovery` bit\n */\nfunction ecsign(msgHash, privateKey, chainId) {\n    const sig = secp256k1_1.secp256k1.sign(msgHash, privateKey);\n    const buf = sig.toCompactRawBytes();\n    const r = Buffer.from(buf.slice(0, 32));\n    const s = Buffer.from(buf.slice(32, 64));\n    const v = chainId === undefined\n        ? BigInt(sig.recovery + 27)\n        : BigInt(sig.recovery + 35) + BigInt(chainId) * BigInt(2);\n    return { r, s, v };\n}\nexports.ecsign = ecsign;\nfunction calculateSigRecovery(v, chainId) {\n    if (v === BigInt(0) || v === BigInt(1))\n        return v;\n    if (chainId === undefined) {\n        return v - BigInt(27);\n    }\n    return v - (chainId * BigInt(2) + BigInt(35));\n}\nfunction isValidSigRecovery(recovery) {\n    return recovery === BigInt(0) || recovery === BigInt(1);\n}\n/**\n * ECDSA public key recovery from signature.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Recovered public key\n */\nconst ecrecover = function (msgHash, v, r, s, chainId) {\n    const signature = Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(s, 32)], 64);\n    const recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error('Invalid signature v value');\n    }\n    const sig = secp256k1_1.secp256k1.Signature.fromCompact(signature).addRecoveryBit(Number(recovery));\n    const senderPubKey = sig.recoverPublicKey(msgHash);\n    return Buffer.from(senderPubKey.toRawBytes(false).slice(1));\n};\nexports.ecrecover = ecrecover;\n/**\n * Convert signature parameters into the format of `eth_sign` RPC method.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Signature\n */\nconst toRpcSig = function (v, r, s, chainId) {\n    const recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error('Invalid signature v value');\n    }\n    // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin\n    return (0, bytes_1.bufferToHex)(Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(s, 32), (0, bytes_1.toBuffer)(v)]));\n};\nexports.toRpcSig = toRpcSig;\n/**\n * Convert signature parameters into the format of Compact Signature Representation (EIP-2098).\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Signature\n */\nconst toCompactSig = function (v, r, s, chainId) {\n    const recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error('Invalid signature v value');\n    }\n    let ss = s;\n    if ((v > BigInt(28) && v % BigInt(2) === BigInt(1)) || v === BigInt(1) || v === BigInt(28)) {\n        ss = Buffer.from(s);\n        ss[0] |= 0x80;\n    }\n    return (0, bytes_1.bufferToHex)(Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(ss, 32)]));\n};\nexports.toCompactSig = toCompactSig;\n/**\n * Convert signature format of the `eth_sign` RPC method to signature parameters\n *\n * NOTE: For an extracted `v` value < 27 (see Geth bug https://github.com/ethereum/go-ethereum/issues/2053)\n * `v + 27` is returned for the `v` value\n * NOTE: After EIP1559, `v` could be `0` or `1` but this function assumes\n * it's a signed message (EIP-191 or EIP-712) adding `27` at the end. Remove if needed.\n */\nconst fromRpcSig = function (sig) {\n    const buf = (0, bytes_1.toBuffer)(sig);\n    let r;\n    let s;\n    let v;\n    if (buf.length >= 65) {\n        r = buf.slice(0, 32);\n        s = buf.slice(32, 64);\n        v = (0, bytes_1.bufferToBigInt)(buf.slice(64));\n    }\n    else if (buf.length === 64) {\n        // Compact Signature Representation (https://eips.ethereum.org/EIPS/eip-2098)\n        r = buf.slice(0, 32);\n        s = buf.slice(32, 64);\n        v = BigInt((0, bytes_1.bufferToInt)(buf.slice(32, 33)) >> 7);\n        s[0] &= 0x7f;\n    }\n    else {\n        throw new Error('Invalid signature length');\n    }\n    // support both versions of `eth_sign` responses\n    if (v < 27) {\n        v = v + BigInt(27);\n    }\n    return {\n        v,\n        r,\n        s,\n    };\n};\nexports.fromRpcSig = fromRpcSig;\n/**\n * Validate a ECDSA signature.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one\n */\nconst isValidSignature = function (v, r, s, homesteadOrLater = true, chainId) {\n    if (r.length !== 32 || s.length !== 32) {\n        return false;\n    }\n    if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {\n        return false;\n    }\n    const rBigInt = (0, bytes_1.bufferToBigInt)(r);\n    const sBigInt = (0, bytes_1.bufferToBigInt)(s);\n    if (rBigInt === BigInt(0) ||\n        rBigInt >= constants_1.SECP256K1_ORDER ||\n        sBigInt === BigInt(0) ||\n        sBigInt >= constants_1.SECP256K1_ORDER) {\n        return false;\n    }\n    if (homesteadOrLater && sBigInt >= constants_1.SECP256K1_ORDER_DIV_2) {\n        return false;\n    }\n    return true;\n};\nexports.isValidSignature = isValidSignature;\n/**\n * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.\n * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`\n * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key\n * used to produce the signature.\n */\nconst hashPersonalMessage = function (message) {\n    (0, helpers_1.assertIsBuffer)(message);\n    const prefix = Buffer.from(`\\u0019Ethereum Signed Message:\\n${message.length}`, 'utf-8');\n    return Buffer.from((0, keccak_1.keccak256)(Buffer.concat([prefix, message])));\n};\nexports.hashPersonalMessage = hashPersonalMessage;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toType = exports.TypeOutput = void 0;\nconst bytes_1 = require(\"./bytes\");\nconst internal_1 = require(\"./internal\");\n/**\n * Type output options\n */\nvar TypeOutput;\n(function (TypeOutput) {\n    TypeOutput[TypeOutput[\"Number\"] = 0] = \"Number\";\n    TypeOutput[TypeOutput[\"BigInt\"] = 1] = \"BigInt\";\n    TypeOutput[TypeOutput[\"Buffer\"] = 2] = \"Buffer\";\n    TypeOutput[TypeOutput[\"PrefixedHexString\"] = 3] = \"PrefixedHexString\";\n})(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));\nfunction toType(input, outputType) {\n    if (input === null) {\n        return null;\n    }\n    if (input === undefined) {\n        return undefined;\n    }\n    if (typeof input === 'string' && !(0, internal_1.isHexString)(input)) {\n        throw new Error(`A string must be provided with a 0x-prefix, given: ${input}`);\n    }\n    else if (typeof input === 'number' && !Number.isSafeInteger(input)) {\n        throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)');\n    }\n    const output = (0, bytes_1.toBuffer)(input);\n    switch (outputType) {\n        case TypeOutput.Buffer:\n            return output;\n        case TypeOutput.BigInt:\n            return (0, bytes_1.bufferToBigInt)(output);\n        case TypeOutput.Number: {\n            const bigInt = (0, bytes_1.bufferToBigInt)(output);\n            if (bigInt > BigInt(Number.MAX_SAFE_INTEGER)) {\n                throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)');\n            }\n            return Number(bigInt);\n        }\n        case TypeOutput.PrefixedHexString:\n            return (0, bytes_1.bufferToHex)(output);\n        default:\n            throw new Error('unknown outputType');\n    }\n}\nexports.toType = toType;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GWEI_TO_WEI = void 0;\n/** Easy conversion from Gwei to wei */\nexports.GWEI_TO_WEI = BigInt(1000000000);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Withdrawal = void 0;\nconst address_1 = require(\"./address\");\nconst bytes_1 = require(\"./bytes\");\nconst types_1 = require(\"./types\");\n/**\n * Representation of EIP-4895 withdrawal data\n */\nclass Withdrawal {\n    /**\n     * This constructor assigns and validates the values.\n     * Use the static factory methods to assist in creating a Withdrawal object from varying data types.\n     * Its amount is in Gwei to match CL representation and for eventual ssz withdrawalsRoot\n     */\n    constructor(index, validatorIndex, address, \n    /**\n     * withdrawal amount in Gwei to match the CL repesentation and eventually ssz withdrawalsRoot\n     */\n    amount) {\n        this.index = index;\n        this.validatorIndex = validatorIndex;\n        this.address = address;\n        this.amount = amount;\n    }\n    static fromWithdrawalData(withdrawalData) {\n        const { index: indexData, validatorIndex: validatorIndexData, address: addressData, amount: amountData, } = withdrawalData;\n        const index = (0, types_1.toType)(indexData, types_1.TypeOutput.BigInt);\n        const validatorIndex = (0, types_1.toType)(validatorIndexData, types_1.TypeOutput.BigInt);\n        const address = new address_1.Address((0, types_1.toType)(addressData, types_1.TypeOutput.Buffer));\n        const amount = (0, types_1.toType)(amountData, types_1.TypeOutput.BigInt);\n        return new Withdrawal(index, validatorIndex, address, amount);\n    }\n    static fromValuesArray(withdrawalArray) {\n        if (withdrawalArray.length !== 4) {\n            throw Error(`Invalid withdrawalArray length expected=4 actual=${withdrawalArray.length}`);\n        }\n        const [index, validatorIndex, address, amount] = withdrawalArray;\n        return Withdrawal.fromWithdrawalData({ index, validatorIndex, address, amount });\n    }\n    /**\n     * Convert a withdrawal to a buffer array\n     * @param withdrawal the withdrawal to convert\n     * @returns buffer array of the withdrawal\n     */\n    static toBufferArray(withdrawal) {\n        const { index, validatorIndex, address, amount } = withdrawal;\n        const indexBuffer = (0, types_1.toType)(index, types_1.TypeOutput.BigInt) === BigInt(0)\n            ? Buffer.alloc(0)\n            : (0, types_1.toType)(index, types_1.TypeOutput.Buffer);\n        const validatorIndexBuffer = (0, types_1.toType)(validatorIndex, types_1.TypeOutput.BigInt) === BigInt(0)\n            ? Buffer.alloc(0)\n            : (0, types_1.toType)(validatorIndex, types_1.TypeOutput.Buffer);\n        let addressBuffer;\n        if (address instanceof address_1.Address) {\n            addressBuffer = address.buf;\n        }\n        else {\n            addressBuffer = (0, types_1.toType)(address, types_1.TypeOutput.Buffer);\n        }\n        const amountBuffer = (0, types_1.toType)(amount, types_1.TypeOutput.BigInt) === BigInt(0)\n            ? Buffer.alloc(0)\n            : (0, types_1.toType)(amount, types_1.TypeOutput.Buffer);\n        return [indexBuffer, validatorIndexBuffer, addressBuffer, amountBuffer];\n    }\n    raw() {\n        return Withdrawal.toBufferArray(this);\n    }\n    toValue() {\n        return {\n            index: this.index,\n            validatorIndex: this.validatorIndex,\n            address: this.address.buf,\n            amount: this.amount,\n        };\n    }\n    toJSON() {\n        return {\n            index: (0, bytes_1.bigIntToHex)(this.index),\n            validatorIndex: (0, bytes_1.bigIntToHex)(this.validatorIndex),\n            address: '0x' + this.address.buf.toString('hex'),\n            amount: (0, bytes_1.bigIntToHex)(this.amount),\n        };\n    }\n}\nexports.Withdrawal = Withdrawal;\n"],"names":[],"sourceRoot":"","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28]}