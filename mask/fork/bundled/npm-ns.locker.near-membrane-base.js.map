{"version":3,"file":"bundled/npm-ns.locker.near-membrane-base.js","mappings":";;;;;;;;;;;;;;AAA8L;AAC9L;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oDAAoD,qFAAa,KAAK,+EAAW,KAAK;;AAEtF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;;AAEnC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wDAAwD;AACxD;AACA;;AAEA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,uGAAuG;AACvG;;AAEA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC;AACpC;AACA,IAAI,iBAAiB;;AAErB,gFAAgF;AAChF;;AAEA,iEAAiE;AACjE;;AAEA,wDAAwD;AACxD;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI,eAAe;AACnB;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI,eAAe;;AAEnB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,2DAA2D;;AAE3D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gDAAgD;AAChD;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,kKAAkK;AAClK,QAAQ;;AAER;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM,sBAAsB;;AAE5B,6DAA6D;AAC7D,iFAAiF;AACjF;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ,aAAa,YAAY;AACjC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAU;;;AAGV;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA,oCAAoC,kDAAkD,GAAG;AACzF,UAAU;AACV;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET,MAAM;;AAEN;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA,QAAQ;;AAER,MAAM;AACN,IAAI;;AAEJ,mBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD,YAAY;AACZ;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,QAAQ;AACR;;AAEA;AACA,6CAA6C;AAC7C,MAAM;;AAEN;AACA,4CAA4C;AAC5C,MAAM;;AAEN;AACA,sCAAsC;AACtC,MAAM;;AAEN;AACA,4CAA4C;AAC5C,MAAM;;AAEN;AACA,IAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;;AAGA,gCAAgC;AAChC,MAAM;;AAEN;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,MAAM;AACN;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,oBAAoB,YAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;;AAGA;AACA,SAAS;AACT,QAAQ;AACR;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC,oCAAoC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;;;AAGV;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC,oCAAoC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;;;AAGV;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC,oCAAoC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;;;AAGV;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC,oCAAoC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;;;AAGV;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC,oCAAoC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;;;AAGV;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC,oCAAoC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;;;AAGV;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;;AAE7C;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA,8CAA8C,iBAAiB,GAAG,OAAO;AACzE;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,YAAY;AACtC,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,+DAA+D;;AAE/D;AACA,wDAAwD,0CAA0C;AAClG;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA;;AAEA,+BAA+B,MAAK,GAAG,CAAuD;AAC9F;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA,4JAA4J;AAC5J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8HAA8H;;AAE9H;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA,2FAA2F;;AAE3F;AACA;;AAEA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU,gBAAgB;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,YAAY,WAAW,YAAY;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2IAA2I;;AAE3I;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;;AAEA,OAAO;;AAEP;AACA,uFAAuF;AACvF,QAAQ;;AAER;AACA,6GAA6G;AAC7G,QAAQ;;AAER;AACA,4GAA4G;AAC5G,QAAQ;;AAER;AACA,+GAA+G;AAC/G,QAAQ;;AAER;AACA;AACA,4FAA4F;AAC5F,QAAQ;;AAER;AACA;AACA,4FAA4F;AAC5F,QAAQ;;AAER;AACA;AACA,uGAAuG;AACvG,QAAQ;;AAER;AACA;AACA,uGAAuG;AACvG,QAAQ;AACR,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yFAAyF;AACzF;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;;;AAGR;AACA;AACA;;AAEA;;AAEA;AACA,uDAAuD;AACvD;;AAEA;AACA;AACA,UAAU;AACV;;;AAGA;AACA;AACA;AACA,SAAS;AACT;AACA,QAAQ;AACR;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,QAAQ;;;AAGR;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,UAAU;AACV;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,4EAA4E;AAC5E;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2CAA2C;;AAE3C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb,YAAY;AACZ;AACA;AACA;;;AAGA;AACA;AACA,QAAQ;;;AAGR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;AACV;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;;AAEA;AACA;AACA,UAAU;AACV;;;AAGA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uFAAuF;AACvF,YAAY;;AAEZ;AACA,UAAU;;;AAGV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;;AAGA;AACA,QAAQ;;;AAGR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV,4BAA4B;;AAE5B;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA,YAAY;AACZ;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW;AACX,UAAU;AACV;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,UAAU;AACV;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,MAAM;AACN;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,QAAQ;AACR;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM,eAAe;;AAErB;AACA;AACA;AACA;AACA,QAAQ,QAAQ;AAChB;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,QAAQ,QAAQ;AAChB;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,QAAQ,QAAQ;AAChB;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM,eAAe;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,wFAAwF;AACxF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;;AAGN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR;AACA;;;AAGA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;;;AAGR;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,QAAQ,YAAY;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;;;AAGR;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,QAAQ,YAAY;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;;;AAGR;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;;;AAGR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;;;AAGA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,UAAU,QAAQ,YAAY;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0DAA0D;AAC1D,UAAU;AACV;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,oBAAoB,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,kCAAkC;AAClC;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,kCAAkC;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,WAAW,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;;AAEA,SAAS;AACT;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA,2DAA2D;AAC3D,UAAU;AACV;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB,QAAQ;;AAER;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC;AACxC,QAAQ;;AAER;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;;AAEA,6BAA6B,YAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;;AAE9D;AACA;AACA;AACA;AACA;;AAEA,iDAAiD;AACjD;AACA,GAAG,uBAAuB,EAAE;;AAE5B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,gBAAgB,6EAAS;AACzB,MAAM;;;AAGN;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM,EAAE,oFAAY;AACpB;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,gBAAgB,wEAAI;AACpB,IAAI,wEAAI;AACR,IAAI,wEAAI;AACR,IAAI,wEAAI;AACR,IAAI,wEAAI;AACR,IAAI,wEAAI;AACR,iYAAiY,wEAAI;AACrY,sMAAsM,wEAAI;AAC1M;AACA,eAAe,wEAAI;AACnB,IAAI,wEAAI;AACR,IAAI,wEAAI;AACR,IAAI,wEAAI;AACR,IAAI,wEAAI;AACR,IAAI,wEAAI;AACR,iZAAiZ,wEAAI;AACrZ,2MAA2M,wEAAI;AAC/M,4IAA4I,wEAAI;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM,oFAAY,CAAC,kFAAc;;AAEjC;AACA;AACA;AACA;AACA,QAAQ,oFAAY,CAAC,kFAAc;AACnC;;AAEA,MAAM,oFAAY;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM,QAAQ,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,sFAAc;AACpC;AACA;AACA,QAAQ;AACR,uBAAuB,6EAAS;AAChC;;AAEA,6BAA6B,YAAY;AACzC;AACA,0DAA0D;AAC1D;AACA;AACA;;AAEA,6BAA6B,oFAAY;AACzC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM,oFAAY;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,mDAAmD,mFAAW;;AAE9D;AACA,kBAAkB,sFAAc;;AAEhC;AACA;AACA,IAAI,WAAW,YAAY;AAC3B,+BAA+B;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oFAAY;AACtC;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,sFAAc;;AAEhC;AACA;AACA,IAAI,WAAW,YAAY;AAC3B,+BAA+B;AAC/B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI,kCAAkC,YAAY;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEmM","sources":["webpack://mask-network/./node_modules/.pnpm/@locker+near-membrane-base@0.11.10/node_modules/@locker/near-membrane-base/dist/index.mjs"],"sourcesContent":["import { toSafeWeakMap, WeakMapCtor, TypeErrorCtor, ErrorCtor, ObjectAssign, noop, ReflectApply, ArrayProtoPush, ReflectOwnKeys, ArrayCtor, toSafeArray } from '@locker/near-membrane-shared';\n/**\n * This file contains an exportable (portable) function `init()` used to initialize\n * one side of a membrane on any realm. The only prerequisite is the ability to\n * evaluate the sourceText of the `init()` function there. Once evaluated, the\n * function will return a set of values that can be used to wire up the side of\n * the membrane with another existing `init()` function from another realm, in\n * which case they will exchange callable functions that are required to connect\n * the two realms via the membrane.\n *\n * About the mechanics of the membrane, there are few important considerations:\n *\n * 1. Pointers are the way to pass reference to object and functions.\n * 2. A dedicated symbol (LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL) is needed\n *    to represent the absence of a value.\n * 3. The realm that owns the object or function is responsible for projecting\n *    the proxy onto the other side (via callablePushTarget), which returns a\n *    Pointer that can be used by the realm to pass the reference to the same\n *    proxy over and over again.\n * 4. The realm that owns the proxy (after the other side projects it into it)\n *    will hold a Pointer alongside the proxy to signal what original object or\n *    function should the foreign operation operates, it is always the first\n *    argument of the foreign callable for proxies, and the other side can use\n *    it via `selectedTarget!`.\n */\n\nconst proxyTargetToLazyPropertyDescriptorStateMap = toSafeWeakMap(new WeakMapCtor()); // istanbul ignore next\n\nfunction createMembraneMarshall(globalObject) {\n  var _ref, _ref2, _ReflectApply, _globalThisRef$BigInt, _globalThisRef$BigUin;\n\n  /* eslint-disable prefer-object-spread */\n  const ArrayCtor = Array;\n  const ArrayBufferCtor = ArrayBuffer;\n  const ErrorCtor = Error;\n  const NumberCtor = Number;\n  const ObjectCtor = Object;\n  const ProxyCtor = Proxy;\n  const ReflectRef = Reflect;\n  const RegExpCtor = RegExp;\n  const StringCtor = String;\n  const SymbolCtor = Symbol;\n  const TypeErrorCtor = TypeError; // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow\n\n  const WeakMapCtor = WeakMap;\n  const WeakSetCtor = WeakSet;\n  const {\n    for: SymbolFor,\n    toStringTag: SymbolToStringTag\n  } = SymbolCtor;\n  const {\n    // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow\n    apply: ReflectApply,\n    construct: ReflectConstruct,\n    defineProperty: ReflectDefineProperty,\n    deleteProperty: ReflectDeleteProperty,\n    get: ReflectGet,\n    getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor,\n    getPrototypeOf: ReflectGetPrototypeOf,\n    has: ReflectHas,\n    isExtensible: ReflectIsExtensible,\n    ownKeys: ReflectOwnKeys,\n    preventExtensions: ReflectPreventExtensions,\n    set: ReflectSet,\n    // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow\n    setPrototypeOf: ReflectSetPrototypeOf\n  } = ReflectRef;\n  const {\n    assign: ObjectAssign,\n    defineProperties: ObjectDefineProperties,\n    freeze: ObjectFreeze,\n    getOwnPropertyDescriptor: ObjectGetOwnPropertyDescriptor,\n    getOwnPropertyDescriptors: ObjectGetOwnPropertyDescriptors,\n    isFrozen: ObjectIsFrozen,\n    isSealed: ObjectIsSealed,\n    keys: ObjectKeys,\n    prototype: ObjectProto,\n    seal: ObjectSeal\n  } = ObjectCtor;\n  const {\n    hasOwnProperty: ObjectProtoHasOwnProperty,\n    propertyIsEnumerable: ObjectProtoPropertyIsEnumerable,\n    toString: ObjectProtoToString\n  } = ObjectProto;\n  const {\n    hasOwn: OriginalObjectHasOwn\n  } = ObjectCtor;\n  const {\n    __defineGetter__: ObjectProtoDefineGetter,\n    __defineSetter__: ObjectProtoDefineSetter,\n    __lookupGetter__: ObjectProtoLookupGetter,\n    __lookupSetter__: ObjectProtoLookupSetter\n  } = ObjectProto;\n  const ObjectHasOwn = typeof OriginalObjectHasOwn === 'function' ? OriginalObjectHasOwn : (object, key) => ReflectApply(ObjectProtoHasOwnProperty, object, [key]);\n  const globalThisRef = (_ref = (_ref2 = globalObject != null ? globalObject : // Support for globalThis was added in Chrome 71.\n  // https://caniuse.com/mdn-javascript_builtins_globalthisfor\n  typeof globalThis !== 'undefined' ? globalThis : undefined) != null ? _ref2 : // However, environments like Android emulators are running Chrome 69.\n  // eslint-disable-next-line no-restricted-globals\n  typeof self !== 'undefined' ? self : undefined) != null ? _ref : ( // See https://mathiasbynens.be/notes/globalthis for more details.\n  ReflectDefineProperty(ObjectProto, 'globalThis', {\n    __proto__: null,\n    configurable: true,\n\n    get() {\n      ReflectDeleteProperty(ObjectProto, 'globalThis'); // Safari 12 on iOS 12.1 has a `this` of `undefined` so we\n      // fallback to `self`.\n      // eslint-disable-next-line no-restricted-globals\n\n      return this != null ? this : self;\n    }\n\n  }), globalThis);\n  const IS_IN_SHADOW_REALM = typeof globalObject !== 'object' || globalObject === null;\n  const LOCKER_DEBUG_MODE_SYMBOL = !IS_IN_SHADOW_REALM ? SymbolFor('@@lockerDebugMode') : undefined;\n  const LOCKER_IDENTIFIER_MARKER = '$LWS';\n  const LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL = !IS_IN_SHADOW_REALM ? SymbolFor('@@lockerNearMembraneSerializedValue') : undefined;\n  const LOCKER_NEAR_MEMBRANE_SYMBOL = !IS_IN_SHADOW_REALM ? SymbolFor('@@lockerNearMembrane') : undefined;\n  const LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL = SymbolFor('@@lockerNearMembraneUndefinedValue'); // The default stack trace limit in Chrome is 10.\n  // Set to 20 to account for stack trace filtering.\n\n  const LOCKER_STACK_TRACE_LIMIT = 20; // This package is bundled by third-parties that have their own build time\n  // replacement logic. Instead of customizing each build system to be aware\n  // of this package we implement a two phase debug mode by performing small\n  // runtime checks to determine phase one, our code is unminified, and\n  // phase two, the user opted-in to custom devtools formatters. Phase one\n  // is used for light weight initialization time debug while phase two is\n  // reserved for post initialization runtime.\n\n  const LOCKER_UNMINIFIED_FLAG = `${() =>\n  /* $LWS */\n  1}`.includes('*'); // Indicate whether debug support is available.\n\n  const LOCKER_DEBUGGABLE_FLAG = LOCKER_UNMINIFIED_FLAG && !IS_IN_SHADOW_REALM; // BigInt is not supported in Safari 13.1.\n  // https://caniuse.com/bigint\n\n  const FLAGS_REG_EXP = IS_IN_SHADOW_REALM ? /\\w*$/ : undefined; // Minification safe reference to the private `BoundaryProxyHandler`\n  // 'serializedValue' property name.\n\n  let MINIFICATION_SAFE_SERIALIZED_VALUE_PROPERTY_NAME; // Minification safe references to the private `BoundaryProxyHandler`\n  // 'apply' and 'construct' trap variant's property names.\n\n  let MINIFICATION_SAFE_TRAP_PROPERTY_NAMES;\n  const SUPPORTS_BIG_INT = typeof BigInt === 'function';\n  const {\n    isArray: isArrayOrThrowForRevoked\n  } = ArrayCtor;\n  const {\n    includes: ArrayProtoIncludes,\n    indexOf: ArrayProtoIndexOf,\n    slice: ArrayProtoSlice\n  } = ArrayCtor.prototype;\n  const {\n    isView: ArrayBufferIsView\n  } = ArrayBufferCtor;\n  const BigIntProtoValueOf = SUPPORTS_BIG_INT ? BigInt.prototype.valueOf : undefined;\n  const {\n    valueOf: BooleanProtoValueOf\n  } = Boolean.prototype;\n  const {\n    toString: ErrorProtoToString\n  } = ErrorCtor.prototype;\n  const {\n    bind: FunctionProtoBind,\n    toString: FunctionProtoToString\n  } = Function.prototype;\n  const {\n    stringify: JSONStringify\n  } = JSON;\n  const {\n    isInteger: NumberIsInteger\n  } = NumberCtor;\n  const {\n    valueOf: NumberProtoValueOf\n  } = NumberCtor.prototype;\n  const {\n    revocable: ProxyRevocable\n  } = ProxyCtor;\n  const {\n    prototype: RegExpProto\n  } = RegExpCtor;\n  const {\n    exec: RegExpProtoExec,\n    test: RegExpProtoTest,\n    toString: RegExProtoToString\n  } = RegExpProto; // Edge 15 does not support RegExp.prototype.flags.\n  // https://caniuse.com/mdn-javascript_builtins_regexp_flags\n\n  const RegExpProtoFlagsGetter = IS_IN_SHADOW_REALM ? (_ReflectApply = ReflectApply(ObjectProtoLookupGetter, RegExpProto, ['flags'])) != null ? _ReflectApply : function flags() {\n    const string = ReflectApply(RegExProtoToString, this, []);\n    return ReflectApply(RegExpProtoExec, FLAGS_REG_EXP, [string])[0];\n  } : undefined;\n  const RegExpProtoSourceGetter = ReflectApply(ObjectProtoLookupGetter, RegExpProto, ['source']);\n  const {\n    replace: StringProtoReplace,\n    slice: StringProtoSlice,\n    valueOf: StringProtoValueOf\n  } = StringCtor.prototype;\n  const {\n    toString: SymbolProtoToString,\n    valueOf: SymbolProtoValueOf\n  } = SymbolCtor.prototype;\n  const BigInt64ArrayProto = (_globalThisRef$BigInt = globalThisRef.BigInt64Array) == null ? void 0 : _globalThisRef$BigInt.prototype;\n  const BigUint64ArrayProto = (_globalThisRef$BigUin = globalThisRef.BigUint64Array) == null ? void 0 : _globalThisRef$BigUin.prototype;\n  const {\n    prototype: Float32ArrayProto\n  } = Float32Array;\n  const {\n    prototype: Float64ArrayProto\n  } = Float64Array;\n  const {\n    prototype: Int8ArrayProto\n  } = Int8Array;\n  const {\n    prototype: Int16ArrayProto\n  } = Int16Array;\n  const {\n    prototype: Int32ArrayProto\n  } = Int32Array;\n  const {\n    prototype: Uint8ArrayProto\n  } = Uint8Array;\n  const {\n    prototype: Uint16ArrayProto\n  } = Uint16Array;\n  const {\n    prototype: Uint32ArrayProto\n  } = Uint32Array; // eslint-disable-next-line no-proto\n\n  const TypedArrayProto = Uint8ArrayProto.__proto__;\n  const TypedArrayProtoLengthGetter = ReflectApply(ObjectProtoLookupGetter, TypedArrayProto, ['length']);\n  const {\n    prototype: WeakMapProto\n  } = WeakMapCtor;\n  const {\n    delete: WeakMapProtoDelete,\n    has: WeakMapProtoHas,\n    set: WeakMapProtoSet,\n    [SymbolToStringTag]: WeakMapProtoSymbolToStringTag\n  } = WeakMapProto;\n  const {\n    prototype: WeakSetProto\n  } = WeakSetCtor;\n  const {\n    add: WeakSetProtoAdd,\n    has: WeakSetProtoHas,\n    delete: WeakSetProtoDelete,\n    [SymbolToStringTag]: WeakSetProtoSymbolToStringTag\n  } = WeakSetProto;\n  const consoleObject = !IS_IN_SHADOW_REALM && typeof console === 'object' && console !== null ? console : undefined;\n  const consoleInfo = consoleObject == null ? void 0 : consoleObject.info;\n  const localEval = IS_IN_SHADOW_REALM ? eval : undefined; // Install flags to ensure things are installed once per realm.\n\n  let installedErrorPrepareStackTraceFlag = false;\n  let installedPropertyDescriptorMethodWrappersFlag = false;\n\n  function alwaysFalse() {\n    return false;\n  }\n\n  const installErrorPrepareStackTrace = LOCKER_UNMINIFIED_FLAG ? () => {\n    if (installedErrorPrepareStackTraceFlag) {\n      return;\n    }\n\n    installedErrorPrepareStackTraceFlag = true; // Feature detect the V8 stack trace API.\n    // https://v8.dev/docs/stack-trace-api\n\n    const CallSite = (() => {\n      try {\n        var _callSites$;\n\n        ErrorCtor.prepareStackTrace = (_error, callSites) => callSites;\n\n        const callSites = new ErrorCtor().stack;\n        ReflectDeleteProperty(ErrorCtor, 'prepareStackTrace');\n        return isArrayOrThrowForRevoked(callSites) && callSites.length > 0 ? (_callSites$ = callSites[0]) == null ? void 0 : _callSites$.constructor : undefined; // eslint-disable-next-line no-empty\n      } catch (_unused) {}\n\n      return undefined;\n    })();\n\n    if (typeof CallSite !== 'function') {\n      return;\n    }\n\n    const {\n      getEvalOrigin: CallSiteProtoGetEvalOrigin,\n      getFunctionName: CallSiteProtoGetFunctionName,\n      toString: CallSiteProtoToString\n    } = CallSite.prototype; // A regexp to detect call sites containing LOCKER_IDENTIFIER_MARKER.\n\n    const lockerFunctionNameMarkerRegExp = new RegExpCtor(`${// Escape regexp special characters in LOCKER_IDENTIFIER_MARKER.\n    ReflectApply(StringProtoReplace, LOCKER_IDENTIFIER_MARKER, [/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&']) // Function name references in call sites also contain\n    // the name of the class they belong to,\n    // e.g. myClassName.myFunctionName.\n    }(?=\\\\.|$)`);\n\n    const formatStackTrace = function formatStackTrace(error, callSites) {\n      // Based on V8's default stack trace formatting:\n      // https://chromium.googlesource.com/v8/v8.git/+/refs/heads/main/src/execution/messages.cc#371\n      let stackTrace = '';\n\n      try {\n        stackTrace = ReflectApply(ErrorProtoToString, error, []);\n      } catch (_unused2) {\n        stackTrace = '<error>';\n      }\n\n      let consecutive = false;\n\n      for (let i = 0, {\n        length\n      } = callSites; i < length; i += 1) {\n        const callSite = callSites[i];\n        const funcName = ReflectApply(CallSiteProtoGetFunctionName, callSite, []);\n        let isMarked = false;\n\n        if (typeof funcName === 'string' && funcName !== 'eval' && ReflectApply(RegExpProtoTest, lockerFunctionNameMarkerRegExp, [funcName])) {\n          isMarked = true;\n        }\n\n        if (!isMarked) {\n          const evalOrigin = ReflectApply(CallSiteProtoGetEvalOrigin, callSite, []);\n\n          if (typeof evalOrigin === 'string' && ReflectApply(RegExpProtoTest, lockerFunctionNameMarkerRegExp, [evalOrigin])) {\n            isMarked = true;\n          }\n        } // Only write a single LWS entry per consecutive LWS stacks.\n\n\n        if (isMarked) {\n          if (!consecutive) {\n            consecutive = true;\n            stackTrace += '\\n    at LWS';\n          }\n\n          continue;\n        } else {\n          consecutive = false;\n        }\n\n        try {\n          stackTrace += `\\n    at ${ReflectApply(CallSiteProtoToString, callSite, [])}`; // eslint-disable-next-line no-empty\n        } catch (_unused3) {}\n      }\n\n      return stackTrace;\n    };\n\n    try {\n      // Error.prepareStackTrace cannot be a bound or proxy wrapped\n      // function, so to obscure its source we wrap the call to\n      // formatStackTrace().\n      ErrorCtor.prepareStackTrace = function prepareStackTrace(error, callSites) {\n        return formatStackTrace(error, callSites);\n      }; // eslint-disable-next-line no-empty\n\n    } catch (_unused4) {}\n\n    try {\n      const {\n        stackTraceLimit\n      } = ErrorCtor;\n\n      if (typeof stackTraceLimit !== 'number' || stackTraceLimit < LOCKER_STACK_TRACE_LIMIT) {\n        ErrorCtor.stackTraceLimit = LOCKER_STACK_TRACE_LIMIT;\n      } // eslint-disable-next-line no-empty\n\n    } catch (_unused5) {}\n  } : noop;\n\n  function noop() {// No-operation.\n  }\n\n  const serializeBigIntObject = IS_IN_SHADOW_REALM ? bigIntObject => // Section 21.2.3 Properties of the BigInt Prototype Object\n  // https://tc39.es/ecma262/#thisbigintvalue\n  // Step 2: If Type(value) is Object and value has a [[BigIntData]] internal slot, then\n  //     a. Assert: Type(value.[[BigIntData]]) is BigInt.\n  ReflectApply(BigIntProtoValueOf, bigIntObject, []) : noop;\n  const serializeBooleanObject = IS_IN_SHADOW_REALM ? booleanObject => // Section 20.3.3 Properties of the Boolean Prototype Object\n  // https://tc39.es/ecma262/#thisbooleanvalue\n  // Step 2: If Type(value) is Object and value has a [[BooleanData]] internal slot, then\n  //     a. Let b be value.[[BooleanData]].\n  //     b. Assert: Type(b) is Boolean.\n  ReflectApply(BooleanProtoValueOf, booleanObject, []) : noop;\n  const serializeNumberObject = IS_IN_SHADOW_REALM ? numberObject => // 21.1.3 Properties of the Number Prototype Object\n  // https://tc39.es/ecma262/#thisnumbervalue\n  // Step 2: If Type(value) is Object and value has a [[NumberData]] internal slot, then\n  //     a. Let n be value.[[NumberData]].\n  //     b. Assert: Type(n) is Number.\n  ReflectApply(NumberProtoValueOf, numberObject, []) : noop;\n  const serializeRegExp = IS_IN_SHADOW_REALM ? value => {\n    // 22.2.5.12 get RegExp.prototype.source\n    // https://tc39.es/ecma262/#sec-get-regexp.prototype.source\n    // Step 3: If R does not have an [[OriginalSource]] internal slot, then\n    //     a. If SameValue(R, %RegExp.prototype%) is true, return \"(?:)\".\n    //     b. Otherwise, throw a TypeError exception.\n    if (value !== RegExpProto) {\n      const source = ReflectApply(RegExpProtoSourceGetter, value, []);\n      return JSONStringify({\n        __proto__: null,\n        flags: ReflectApply(RegExpProtoFlagsGetter, value, []),\n        source\n      });\n    }\n\n    return undefined;\n  } : noop;\n  const serializeStringObject = IS_IN_SHADOW_REALM ? stringObject => // 22.1.3 Properties of the String Prototype Object\n  // https://tc39.es/ecma262/#thisstringvalue\n  // Step 2: If Type(value) is Object and value has a [[StringData]] internal slot, then\n  //     a. Let s be value.[[StringData]].\n  //     b. Assert: Type(s) is String.\n  ReflectApply(StringProtoValueOf, stringObject, []) : noop;\n  const serializeSymbolObject = IS_IN_SHADOW_REALM ? symbolObject => // 20.4.3 Properties of the Symbol Prototype Object\n  // https://tc39.es/ecma262/#thissymbolvalue\n  // Step 2: If Type(value) is Object and value has a [[SymbolData]] internal slot, then\n  //     a. Let s be value.[[SymbolData]].\n  //     b. Assert: Type(s) is Symbol.\n  ReflectApply(SymbolProtoValueOf, symbolObject, []) : noop;\n  const serializeTargetByBrand = IS_IN_SHADOW_REALM ? target => {\n    const brand = ReflectApply(ObjectProtoToString, target, []);\n\n    switch (brand) {\n      // The brand checks below represent boxed primitives of\n      // `ESGlobalKeys` in packages/near-membrane-base/src/intrinsics.ts\n      // which are not remapped or reflective.\n      case '[object Boolean]':\n        return serializeBooleanObject(target);\n\n      case '[object Number]':\n        return serializeNumberObject(target);\n\n      case '[object RegExp]':\n        return serializeRegExp(target);\n\n      case '[object String]':\n        return serializeStringObject(target);\n\n      case '[object Object]':\n        try {\n          // Symbol.prototype[@@toStringTag] is defined by default so\n          // must have been removed.\n          // https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag\n          return serializeSymbolObject(target); // eslint-disable-next-line no-empty\n        } catch (_unused6) {}\n\n        if (SUPPORTS_BIG_INT) {\n          // BigInt.prototype[@@toStringTag] is defined by default so\n          // must have been removed.\n          // https://tc39.es/ecma262/#sec-bigint.prototype-@@tostringtag\n          try {\n            return serializeBigIntObject(target); // eslint-disable-next-line no-empty\n          } catch (_unused7) {}\n        }\n\n      // eslint-disable-next-line no-fallthrough\n\n      default:\n        return undefined;\n    }\n  } : noop;\n  const serializeTargetByTrialAndError = IS_IN_SHADOW_REALM ? target => {\n    // The serialization attempts below represent boxed primitives of\n    // `ESGlobalKeys` in packages/near-membrane-base/src/intrinsics.ts\n    // which are not remapped or reflective.\n    try {\n      // Symbol.prototype[@@toStringTag] is defined by default so\n      // attempted before others.\n      // https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag\n      return serializeSymbolObject(target); // eslint-disable-next-line no-empty\n    } catch (_unused8) {}\n\n    if (SUPPORTS_BIG_INT) {\n      // BigInt.prototype[@@toStringTag] is defined by default so\n      // attempted before others.\n      // https://tc39.es/ecma262/#sec-bigint.prototype-@@tostringtag\n      try {\n        return serializeBigIntObject(target); // eslint-disable-next-line no-empty\n      } catch (_unused9) {}\n    }\n\n    try {\n      return serializeBooleanObject(target); // eslint-disable-next-line no-empty\n    } catch (_unused10) {}\n\n    try {\n      return serializeNumberObject(target); // eslint-disable-next-line no-empty\n    } catch (_unused11) {}\n\n    try {\n      return serializeRegExp(target); // eslint-disable-next-line no-empty\n    } catch (_unused12) {}\n\n    try {\n      return serializeStringObject(target); // eslint-disable-next-line no-empty\n    } catch (_unused13) {}\n\n    return undefined;\n  } : noop;\n\n  function toSafeTemplateStringValue(value) {\n    if (typeof value === 'string') {\n      return value;\n    }\n\n    try {\n      if (typeof value === 'object' && value !== null) {\n        const result = ReflectApply(ObjectProtoToString, value, []);\n        return result === '[object Symbol]' ? ReflectApply(SymbolProtoToString, value, []) : result;\n      }\n\n      if (typeof value === 'function') {\n        return ReflectApply(FunctionProtoToString, value, []);\n      } // Attempt to coerce `value` to a string with the String() constructor.\n      // Section 22.1.1.1 String ( value )\n      // https://tc39.es/ecma262/#sec-string-constructor-string-value\n\n\n      return StringCtor(value); // eslint-disable-next-line no-empty\n    } catch (_unused14) {}\n\n    return '[Object Unknown]';\n  } // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow\n\n\n  function toSafeWeakMap(weakMap) {\n    ReflectSetPrototypeOf(weakMap, null);\n    weakMap.delete = WeakMapProtoDelete;\n    weakMap.has = WeakMapProtoHas;\n    weakMap.set = WeakMapProtoSet;\n    weakMap[SymbolToStringTag] = WeakMapProtoSymbolToStringTag;\n    ReflectSetPrototypeOf(weakMap, WeakMapProto);\n    return weakMap;\n  }\n\n  function toSafeWeakSet(weakSet) {\n    ReflectSetPrototypeOf(weakSet, null);\n    weakSet.add = WeakSetProtoAdd;\n    weakSet.delete = WeakSetProtoDelete;\n    weakSet.has = WeakSetProtoHas;\n    weakSet[SymbolToStringTag] = WeakSetProtoSymbolToStringTag;\n    ReflectSetPrototypeOf(weakSet, WeakSetProto);\n    return weakSet;\n  }\n\n  return function createHooksCallback(color, foreignCallableHooksCallback, options) {\n    if (IS_IN_SHADOW_REALM) {\n      options = undefined;\n    }\n\n    const {\n      distortionCallback,\n      instrumentation,\n      liveTargetCallback // eslint-disable-next-line prefer-object-spread\n\n    } = ObjectAssign({\n      __proto__: null\n    }, options);\n    const LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG = // In the future we can preface the LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG\n    // definition with a LOCKER_UNMINIFIED_FLAG check to have instrumentation\n    // removed in minified production builds.\n    !IS_IN_SHADOW_REALM && typeof instrumentation === 'object' && instrumentation !== null;\n    const arityToApplyTrapNameRegistry = {\n      // Populated in the returned connector function below.\n      __proto__: null,\n      0: undefined,\n      1: undefined,\n      2: undefined,\n      3: undefined,\n      4: undefined,\n      n: undefined\n    };\n    const arityToConstructTrapNameRegistry = {\n      // Populated in the returned connector function below.\n      __proto__: null,\n      0: undefined,\n      1: undefined,\n      2: undefined,\n      3: undefined,\n      4: undefined,\n      n: undefined\n    };\n    const localProxyTargetToLazyPropertyDescriptorStateMap = toSafeWeakMap(new WeakMapCtor());\n    const proxyTargetToPointerMap = toSafeWeakMap(new WeakMapCtor());\n    const startActivity = LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG ? instrumentation.startActivity : undefined;\n    let foreignCallablePushErrorTarget;\n    let foreignCallablePushTarget;\n    let foreignCallableApply;\n    let foreignCallableConstruct;\n    let foreignCallableDefineProperty;\n    let foreignCallableDeleteProperty;\n    let foreignCallableGet;\n    let foreignCallableGetOwnPropertyDescriptor;\n    let foreignCallableGetPrototypeOf;\n    let foreignCallableHas;\n    let foreignCallableIsExtensible;\n    let foreignCallableOwnKeys;\n    let foreignCallablePreventExtensions;\n    let foreignCallableSet;\n    let foreignCallableSetPrototypeOf;\n    let foreignCallableDebugInfo;\n    let foreignCallableGetPropertyValue;\n    let foreignCallableGetLazyPropertyDescriptorStateByTarget;\n    let foreignCallableGetTargetIntegrityTraits;\n    let foreignCallableGetToStringTagOfTarget;\n    let foreignCallableInstallErrorPrepareStackTrace;\n    let foreignCallableIsTargetLive;\n    let foreignCallableIsTargetRevoked;\n    let foreignCallableSerializeTarget;\n    let foreignCallableSetLazyPropertyDescriptorStateByTarget;\n    let foreignCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors;\n    let foreignCallableBatchGetPrototypeOfWhenHasNoOwnProperty;\n    let foreignCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor;\n    let fastForeignTargetPointers;\n    let foreignPointerBigInt64ArrayProto;\n    let foreignPointerBigUint64ArrayProto;\n    let foreignPointerFloat32ArrayProto;\n    let foreignPointerFloat64ArrayProto;\n    let foreignPointerInt8ArrayProto;\n    let foreignPointerInt16ArrayProto;\n    let foreignPointerInt32ArrayProto;\n    let foreignPointerObjectProto;\n    let foreignPointerTypedArrayProto;\n    let foreignPointerUint8ArrayProto;\n    let foreignPointerUint16ArrayProto;\n    let foreignPointerUint32ArrayProto;\n    let selectedTarget;\n    let useFastForeignTargetPath = IS_IN_SHADOW_REALM;\n    let useFastForeignTargetPathForTypedArrays = IS_IN_SHADOW_REALM;\n    let nearMembraneSymbolFlag = false;\n    let lastProxyTrapCalled = 0;\n    const activateLazyOwnPropertyDefinition = IS_IN_SHADOW_REALM ? (target, key, state) => {\n      state[key] = false;\n      const foreignTargetPointer = getTransferablePointer(target);\n      let safeDesc;\n\n      try {\n        foreignCallableGetOwnPropertyDescriptor(foreignTargetPointer, key, (_key, configurable, enumerable, writable, valuePointer, getterPointer, setterPointer) => {\n          safeDesc = createDescriptorFromMeta(configurable, enumerable, writable, valuePointer, getterPointer, setterPointer);\n        });\n      } catch (error) {\n        var _selectedTarget;\n\n        const errorToThrow = (_selectedTarget = selectedTarget) != null ? _selectedTarget : error;\n        selectedTarget = undefined;\n        throw errorToThrow;\n      }\n\n      if (safeDesc) {\n        ReflectDefineProperty(target, key, safeDesc);\n      } else {\n        ReflectDeleteProperty(target, key);\n      }\n    } : noop;\n    let checkDebugMode = LOCKER_DEBUGGABLE_FLAG ? () => {\n      try {\n        if (ObjectHasOwn(globalThisRef, LOCKER_DEBUG_MODE_SYMBOL)) {\n          checkDebugMode = () => true;\n\n          installErrorPrepareStackTrace();\n          foreignCallableInstallErrorPrepareStackTrace();\n        }\n      } catch (_unused15) {\n        checkDebugMode = alwaysFalse;\n      }\n\n      return false;\n    } : alwaysFalse;\n    const clearFastForeignTargetPointers = IS_IN_SHADOW_REALM ? () => {\n      fastForeignTargetPointers = toSafeWeakSet(new WeakSetCtor());\n    } : noop;\n\n    function copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget(foreignTargetPointer, shadowTarget) {\n      let activity;\n\n      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n        activity = startActivity('copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget');\n      }\n\n      let protoPointerOrNull;\n\n      try {\n        protoPointerOrNull = foreignCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors(foreignTargetPointer, (...descriptorTuples) => {\n          const descriptors = {};\n\n          for (let i = 0, {\n            length\n          } = descriptorTuples; i < length; i += 7) {\n            const key = descriptorTuples[i];\n            descriptors[key] = createDescriptorFromMeta(descriptorTuples[i + 1], // configurable\n            descriptorTuples[i + 2], // enumerable\n            descriptorTuples[i + 3], // writable\n            descriptorTuples[i + 4], // valuePointer\n            descriptorTuples[i + 5], // getterPointer\n            descriptorTuples[i + 6] // setterPointer\n            );\n          } // Use `ObjectDefineProperties()` instead of individual\n          // `ReflectDefineProperty()` calls for better performance.\n\n\n          ObjectDefineProperties(shadowTarget, descriptors);\n        });\n      } catch (error) {\n        var _selectedTarget2;\n\n        const errorToThrow = (_selectedTarget2 = selectedTarget) != null ? _selectedTarget2 : error;\n        selectedTarget = undefined;\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity.error(errorToThrow);\n        }\n\n        throw errorToThrow;\n      }\n\n      let proto;\n\n      if (typeof protoPointerOrNull === 'function') {\n        protoPointerOrNull();\n        proto = selectedTarget;\n        selectedTarget = undefined;\n      } else {\n        proto = null;\n      }\n\n      ReflectSetPrototypeOf(shadowTarget, proto);\n\n      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n        activity.stop();\n      }\n    }\n\n    function createApplyOrConstructTrapForZeroOrMoreArgs(proxyTrapEnum) {\n      const isApplyTrap = proxyTrapEnum & 1\n      /* ProxyHandlerTraps.Apply */\n      ;\n      const activityName = `Reflect.${isApplyTrap ? 'apply' : 'construct'}()`;\n      const arityToApplyOrConstructTrapNameRegistry = isApplyTrap ? arityToApplyTrapNameRegistry : arityToConstructTrapNameRegistry;\n      const foreignCallableApplyOrConstruct = isApplyTrap ? foreignCallableApply : foreignCallableConstruct;\n      return function applyOrConstructTrap(shadowTarget, thisArgOrArgs, argsOrNewTarget) {\n        lastProxyTrapCalled = proxyTrapEnum;\n        const args = isApplyTrap ? argsOrNewTarget : thisArgOrArgs;\n        const {\n          length\n        } = args;\n\n        if (length !== 0) {\n          var _arityToApplyOrConstr;\n\n          return this[(_arityToApplyOrConstr = arityToApplyOrConstructTrapNameRegistry[length]) != null ? _arityToApplyOrConstr : arityToApplyOrConstructTrapNameRegistry.n](shadowTarget, thisArgOrArgs, argsOrNewTarget);\n        }\n\n        let activity;\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity = startActivity(activityName);\n        } // @ts-ignore: Prevent private property access error.\n\n\n        const {\n          foreignTargetPointer\n        } = this;\n        const thisArgOrNewTarget = isApplyTrap ? thisArgOrArgs : argsOrNewTarget;\n        let pointerOrPrimitive;\n\n        try {\n          pointerOrPrimitive = foreignCallableApplyOrConstruct(foreignTargetPointer, // Inline getTransferableValue().\n          typeof thisArgOrNewTarget === 'object' && thisArgOrNewTarget !== null || typeof thisArgOrNewTarget === 'function' ? getTransferablePointer(thisArgOrNewTarget) : // Intentionally ignoring `document.all`.\n          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n          typeof thisArgOrNewTarget === 'undefined' ? undefined : thisArgOrNewTarget);\n        } catch (error) {\n          var _selectedTarget3;\n\n          const errorToThrow = (_selectedTarget3 = selectedTarget) != null ? _selectedTarget3 : error;\n          selectedTarget = undefined;\n\n          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n            activity.error(errorToThrow);\n          }\n\n          throw errorToThrow;\n        }\n\n        let result;\n\n        if (typeof pointerOrPrimitive === 'function') {\n          pointerOrPrimitive();\n          result = selectedTarget;\n          selectedTarget = undefined;\n        } else {\n          result = pointerOrPrimitive;\n        }\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity.stop();\n        }\n\n        return result;\n      };\n    }\n\n    function createApplyOrConstructTrapForOneOrMoreArgs(proxyTrapEnum) {\n      const isApplyTrap = proxyTrapEnum & 1\n      /* ProxyHandlerTraps.Apply */\n      ;\n      const activityName = `Reflect.${isApplyTrap ? 'apply' : 'construct'}(1)`;\n      const arityToApplyOrConstructTrapNameRegistry = isApplyTrap ? arityToApplyTrapNameRegistry : arityToConstructTrapNameRegistry;\n      const foreignCallableApplyOrConstruct = isApplyTrap ? foreignCallableApply : foreignCallableConstruct;\n      return function applyOrConstructTrapForOneOrMoreArgs(shadowTarget, thisArgOrArgs, argsOrNewTarget) {\n        lastProxyTrapCalled = proxyTrapEnum;\n        const args = isApplyTrap ? argsOrNewTarget : thisArgOrArgs;\n        const {\n          length\n        } = args;\n\n        if (length !== 1) {\n          var _arityToApplyOrConstr2;\n\n          return this[(_arityToApplyOrConstr2 = arityToApplyOrConstructTrapNameRegistry[length]) != null ? _arityToApplyOrConstr2 : arityToApplyOrConstructTrapNameRegistry.n](shadowTarget, thisArgOrArgs, argsOrNewTarget);\n        }\n\n        let activity;\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity = startActivity(activityName);\n        } // @ts-ignore: Prevent private property access error.\n\n\n        const {\n          foreignTargetPointer\n        } = this;\n        const thisArgOrNewTarget = isApplyTrap ? thisArgOrArgs : argsOrNewTarget;\n        let pointerOrPrimitive;\n\n        try {\n          const {\n            0: arg0\n          } = args;\n          pointerOrPrimitive = foreignCallableApplyOrConstruct(foreignTargetPointer, // Inline getTransferableValue().\n          typeof thisArgOrNewTarget === 'object' && thisArgOrNewTarget !== null || typeof thisArgOrNewTarget === 'function' ? getTransferablePointer(thisArgOrNewTarget) : // Intentionally ignoring `document.all`.\n          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n          typeof thisArgOrNewTarget === 'undefined' ? undefined : thisArgOrNewTarget, // Inline getTransferableValue().\n          typeof arg0 === 'object' && arg0 !== null || typeof arg0 === 'function' ? getTransferablePointer(arg0) : // Intentionally ignoring `document.all`.\n          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n          typeof arg0 === 'undefined' ? undefined : arg0);\n        } catch (error) {\n          var _selectedTarget4;\n\n          const errorToThrow = (_selectedTarget4 = selectedTarget) != null ? _selectedTarget4 : error;\n          selectedTarget = undefined;\n\n          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n            activity.error(errorToThrow);\n          }\n\n          throw errorToThrow;\n        }\n\n        let result;\n\n        if (typeof pointerOrPrimitive === 'function') {\n          pointerOrPrimitive();\n          result = selectedTarget;\n          selectedTarget = undefined;\n        } else {\n          result = pointerOrPrimitive;\n        }\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity.stop();\n        }\n\n        return result;\n      };\n    }\n\n    function createApplyOrConstructTrapForTwoOrMoreArgs(proxyTrapEnum) {\n      const isApplyTrap = proxyTrapEnum & 1\n      /* ProxyHandlerTraps.Apply */\n      ;\n      const activityName = `Reflect.${isApplyTrap ? 'apply' : 'construct'}(2)`;\n      const arityToApplyOrConstructTrapNameRegistry = isApplyTrap ? arityToApplyTrapNameRegistry : arityToConstructTrapNameRegistry;\n      const foreignCallableApplyOrConstruct = isApplyTrap ? foreignCallableApply : foreignCallableConstruct;\n      return function applyOrConstructTrapForTwoOrMoreArgs(shadowTarget, thisArgOrArgs, argsOrNewTarget) {\n        lastProxyTrapCalled = proxyTrapEnum;\n        const args = isApplyTrap ? argsOrNewTarget : thisArgOrArgs;\n        const {\n          length\n        } = args;\n\n        if (length !== 2) {\n          var _arityToApplyOrConstr3;\n\n          return this[(_arityToApplyOrConstr3 = arityToApplyOrConstructTrapNameRegistry[length]) != null ? _arityToApplyOrConstr3 : arityToApplyOrConstructTrapNameRegistry.n](shadowTarget, thisArgOrArgs, argsOrNewTarget);\n        }\n\n        let activity;\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity = startActivity(activityName);\n        } // @ts-ignore: Prevent private property access error.\n\n\n        const {\n          foreignTargetPointer\n        } = this;\n        const thisArgOrNewTarget = isApplyTrap ? thisArgOrArgs : argsOrNewTarget;\n        let pointerOrPrimitive;\n\n        try {\n          const {\n            0: arg0,\n            1: arg1\n          } = args;\n          pointerOrPrimitive = foreignCallableApplyOrConstruct(foreignTargetPointer, // Inline getTransferableValue().\n          typeof thisArgOrNewTarget === 'object' && thisArgOrNewTarget !== null || typeof thisArgOrNewTarget === 'function' ? getTransferablePointer(thisArgOrNewTarget) : // Intentionally ignoring `document.all`.\n          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n          typeof thisArgOrNewTarget === 'undefined' ? undefined : thisArgOrNewTarget, // Inline getTransferableValue().\n          typeof arg0 === 'object' && arg0 !== null || typeof arg0 === 'function' ? getTransferablePointer(arg0) : // Intentionally ignoring `document.all`.\n          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n          typeof arg0 === 'undefined' ? undefined : arg0, // Inline getTransferableValue().\n          typeof arg1 === 'object' && arg1 !== null || typeof arg1 === 'function' ? getTransferablePointer(arg1) : // Intentionally ignoring `document.all`.\n          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n          typeof arg1 === 'undefined' ? undefined : arg1);\n        } catch (error) {\n          var _selectedTarget5;\n\n          const errorToThrow = (_selectedTarget5 = selectedTarget) != null ? _selectedTarget5 : error;\n          selectedTarget = undefined;\n\n          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n            activity.error(errorToThrow);\n          }\n\n          throw errorToThrow;\n        }\n\n        let result;\n\n        if (typeof pointerOrPrimitive === 'function') {\n          pointerOrPrimitive();\n          result = selectedTarget;\n          selectedTarget = undefined;\n        } else {\n          result = pointerOrPrimitive;\n        }\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity.stop();\n        }\n\n        return result;\n      };\n    }\n\n    function createApplyOrConstructTrapForThreeOrMoreArgs(proxyTrapEnum) {\n      const isApplyTrap = proxyTrapEnum & 1\n      /* ProxyHandlerTraps.Apply */\n      ;\n      const activityName = `Reflect.${isApplyTrap ? 'apply' : 'construct'}(3)`;\n      const arityToApplyOrConstructTrapNameRegistry = isApplyTrap ? arityToApplyTrapNameRegistry : arityToConstructTrapNameRegistry;\n      const foreignCallableApplyOrConstruct = isApplyTrap ? foreignCallableApply : foreignCallableConstruct;\n      return function applyOrConstructTrapForTwoOrMoreArgs(shadowTarget, thisArgOrArgs, argsOrNewTarget) {\n        lastProxyTrapCalled = proxyTrapEnum;\n        const args = isApplyTrap ? argsOrNewTarget : thisArgOrArgs;\n        const {\n          length\n        } = args;\n\n        if (length !== 3) {\n          var _arityToApplyOrConstr4;\n\n          return this[(_arityToApplyOrConstr4 = arityToApplyOrConstructTrapNameRegistry[length]) != null ? _arityToApplyOrConstr4 : arityToApplyOrConstructTrapNameRegistry.n](shadowTarget, thisArgOrArgs, argsOrNewTarget);\n        }\n\n        let activity;\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity = startActivity(activityName);\n        } // @ts-ignore: Prevent private property access error.\n\n\n        const {\n          foreignTargetPointer\n        } = this;\n        const thisArgOrNewTarget = isApplyTrap ? thisArgOrArgs : argsOrNewTarget;\n        let pointerOrPrimitive;\n\n        try {\n          const {\n            0: arg0,\n            1: arg1,\n            2: arg2\n          } = args;\n          pointerOrPrimitive = foreignCallableApplyOrConstruct(foreignTargetPointer, // Inline getTransferableValue().\n          typeof thisArgOrNewTarget === 'object' && thisArgOrNewTarget !== null || typeof thisArgOrNewTarget === 'function' ? getTransferablePointer(thisArgOrNewTarget) : // Intentionally ignoring `document.all`.\n          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n          typeof thisArgOrNewTarget === 'undefined' ? undefined : thisArgOrNewTarget, // Inline getTransferableValue().\n          typeof arg0 === 'object' && arg0 !== null || typeof arg0 === 'function' ? getTransferablePointer(arg0) : // Intentionally ignoring `document.all`.\n          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n          typeof arg0 === 'undefined' ? undefined : arg0, // Inline getTransferableValue().\n          typeof arg1 === 'object' && arg1 !== null || typeof arg1 === 'function' ? getTransferablePointer(arg1) : // Intentionally ignoring `document.all`.\n          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n          typeof arg1 === 'undefined' ? undefined : arg1, // Inline getTransferableValue().\n          typeof arg2 === 'object' && arg2 !== null || typeof arg2 === 'function' ? getTransferablePointer(arg2) : // Intentionally ignoring `document.all`.\n          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n          typeof arg2 === 'undefined' ? undefined : arg2);\n        } catch (error) {\n          var _selectedTarget6;\n\n          const errorToThrow = (_selectedTarget6 = selectedTarget) != null ? _selectedTarget6 : error;\n          selectedTarget = undefined;\n\n          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n            activity.error(errorToThrow);\n          }\n\n          throw errorToThrow;\n        }\n\n        let result;\n\n        if (typeof pointerOrPrimitive === 'function') {\n          pointerOrPrimitive();\n          result = selectedTarget;\n          selectedTarget = undefined;\n        } else {\n          result = pointerOrPrimitive;\n        }\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity.stop();\n        }\n\n        return result;\n      };\n    }\n\n    function createApplyOrConstructTrapForFourOrMoreArgs(proxyTrapEnum) {\n      const isApplyTrap = proxyTrapEnum & 1\n      /* ProxyHandlerTraps.Apply */\n      ;\n      const activityName = `Reflect.${isApplyTrap ? 'apply' : 'construct'}(4)`;\n      const arityToApplyOrConstructTrapNameRegistry = isApplyTrap ? arityToApplyTrapNameRegistry : arityToConstructTrapNameRegistry;\n      const foreignCallableApplyOrConstruct = isApplyTrap ? foreignCallableApply : foreignCallableConstruct;\n      return function applyOrConstructTrapForTwoOrMoreArgs(shadowTarget, thisArgOrArgs, argsOrNewTarget) {\n        lastProxyTrapCalled = proxyTrapEnum;\n        const args = isApplyTrap ? argsOrNewTarget : thisArgOrArgs;\n        const {\n          length\n        } = args;\n\n        if (length !== 4) {\n          var _arityToApplyOrConstr5;\n\n          return this[(_arityToApplyOrConstr5 = arityToApplyOrConstructTrapNameRegistry[length]) != null ? _arityToApplyOrConstr5 : arityToApplyOrConstructTrapNameRegistry.n](shadowTarget, thisArgOrArgs, argsOrNewTarget);\n        }\n\n        let activity;\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity = startActivity(activityName);\n        } // @ts-ignore: Prevent private property access error.\n\n\n        const {\n          foreignTargetPointer\n        } = this;\n        const thisArgOrNewTarget = isApplyTrap ? thisArgOrArgs : argsOrNewTarget;\n        let pointerOrPrimitive;\n\n        try {\n          const {\n            0: arg0,\n            1: arg1,\n            2: arg2,\n            3: arg3\n          } = args;\n          pointerOrPrimitive = foreignCallableApplyOrConstruct(foreignTargetPointer, // Inline getTransferableValue().\n          typeof thisArgOrNewTarget === 'object' && thisArgOrNewTarget !== null || typeof thisArgOrNewTarget === 'function' ? getTransferablePointer(thisArgOrNewTarget) : // Intentionally ignoring `document.all`.\n          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n          typeof thisArgOrNewTarget === 'undefined' ? undefined : thisArgOrNewTarget, // Inline getTransferableValue().\n          typeof arg0 === 'object' && arg0 !== null || typeof arg0 === 'function' ? getTransferablePointer(arg0) : // Intentionally ignoring `document.all`.\n          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n          typeof arg0 === 'undefined' ? undefined : arg0, // Inline getTransferableValue().\n          typeof arg1 === 'object' && arg1 !== null || typeof arg1 === 'function' ? getTransferablePointer(arg1) : // Intentionally ignoring `document.all`.\n          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n          typeof arg1 === 'undefined' ? undefined : arg1, // Inline getTransferableValue().\n          typeof arg2 === 'object' && arg2 !== null || typeof arg2 === 'function' ? getTransferablePointer(arg2) : // Intentionally ignoring `document.all`.\n          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n          typeof arg2 === 'undefined' ? undefined : arg2, // Inline getTransferableValue().\n          typeof arg3 === 'object' && arg3 !== null || typeof arg3 === 'function' ? getTransferablePointer(arg3) : // Intentionally ignoring `document.all`.\n          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n          typeof arg3 === 'undefined' ? undefined : arg3);\n        } catch (error) {\n          var _selectedTarget7;\n\n          const errorToThrow = (_selectedTarget7 = selectedTarget) != null ? _selectedTarget7 : error;\n          selectedTarget = undefined;\n\n          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n            activity.error(errorToThrow);\n          }\n\n          throw errorToThrow;\n        }\n\n        let result;\n\n        if (typeof pointerOrPrimitive === 'function') {\n          pointerOrPrimitive();\n          result = selectedTarget;\n          selectedTarget = undefined;\n        } else {\n          result = pointerOrPrimitive;\n        }\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity.stop();\n        }\n\n        return result;\n      };\n    }\n\n    function createApplyOrConstructTrapForFiveOrMoreArgs(proxyTrapEnum) {\n      const isApplyTrap = proxyTrapEnum & 1\n      /* ProxyHandlerTraps.Apply */\n      ;\n      const activityName = `Reflect.${isApplyTrap ? 'apply' : 'construct'}(5)`;\n      const arityToApplyOrConstructTrapNameRegistry = isApplyTrap ? arityToApplyTrapNameRegistry : arityToConstructTrapNameRegistry;\n      const foreignCallableApplyOrConstruct = isApplyTrap ? foreignCallableApply : foreignCallableConstruct;\n      return function applyOrConstructTrapForTwoOrMoreArgs(shadowTarget, thisArgOrArgs, argsOrNewTarget) {\n        lastProxyTrapCalled = proxyTrapEnum;\n        const args = isApplyTrap ? argsOrNewTarget : thisArgOrArgs;\n        const {\n          length\n        } = args;\n\n        if (length !== 5) {\n          var _arityToApplyOrConstr6;\n\n          return this[(_arityToApplyOrConstr6 = arityToApplyOrConstructTrapNameRegistry[length]) != null ? _arityToApplyOrConstr6 : arityToApplyOrConstructTrapNameRegistry.n](shadowTarget, thisArgOrArgs, argsOrNewTarget);\n        }\n\n        let activity;\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity = startActivity(activityName);\n        } // @ts-ignore: Prevent private property access error.\n\n\n        const {\n          foreignTargetPointer\n        } = this;\n        const thisArgOrNewTarget = isApplyTrap ? thisArgOrArgs : argsOrNewTarget;\n        let pointerOrPrimitive;\n\n        try {\n          const {\n            0: arg0,\n            1: arg1,\n            2: arg2,\n            3: arg3,\n            4: arg4\n          } = args;\n          pointerOrPrimitive = foreignCallableApplyOrConstruct(foreignTargetPointer, // Inline getTransferableValue().\n          typeof thisArgOrNewTarget === 'object' && thisArgOrNewTarget !== null || typeof thisArgOrNewTarget === 'function' ? getTransferablePointer(thisArgOrNewTarget) : // Intentionally ignoring `document.all`.\n          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n          typeof thisArgOrNewTarget === 'undefined' ? undefined : thisArgOrNewTarget, // Inline getTransferableValue().\n          typeof arg0 === 'object' && arg0 !== null || typeof arg0 === 'function' ? getTransferablePointer(arg0) : // Intentionally ignoring `document.all`.\n          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n          typeof arg0 === 'undefined' ? undefined : arg0, // Inline getTransferableValue().\n          typeof arg1 === 'object' && arg1 !== null || typeof arg1 === 'function' ? getTransferablePointer(arg1) : // Intentionally ignoring `document.all`.\n          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n          typeof arg1 === 'undefined' ? undefined : arg1, // Inline getTransferableValue().\n          typeof arg2 === 'object' && arg2 !== null || typeof arg2 === 'function' ? getTransferablePointer(arg2) : // Intentionally ignoring `document.all`.\n          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n          typeof arg2 === 'undefined' ? undefined : arg2, // Inline getTransferableValue().\n          typeof arg3 === 'object' && arg3 !== null || typeof arg3 === 'function' ? getTransferablePointer(arg3) : // Intentionally ignoring `document.all`.\n          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n          typeof arg3 === 'undefined' ? undefined : arg3, // Inline getTransferableValue().\n          typeof arg4 === 'object' && arg4 !== null || typeof arg4 === 'function' ? getTransferablePointer(arg4) : // Intentionally ignoring `document.all`.\n          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n          typeof arg4 === 'undefined' ? undefined : arg4);\n        } catch (error) {\n          var _selectedTarget8;\n\n          const errorToThrow = (_selectedTarget8 = selectedTarget) != null ? _selectedTarget8 : error;\n          selectedTarget = undefined;\n\n          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n            activity.error(errorToThrow);\n          }\n\n          throw errorToThrow;\n        }\n\n        let result;\n\n        if (typeof pointerOrPrimitive === 'function') {\n          pointerOrPrimitive();\n          result = selectedTarget;\n          selectedTarget = undefined;\n        } else {\n          result = pointerOrPrimitive;\n        }\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity.stop();\n        }\n\n        return result;\n      };\n    }\n\n    function createApplyOrConstructTrapForAnyNumberOfArgs(proxyTrapEnum) {\n      const isApplyTrap = proxyTrapEnum & 1\n      /* ProxyHandlerTraps.Apply */\n      ;\n      const nativeMethodName = isApplyTrap ? 'apply' : 'construct';\n      const foreignCallableApplyOrConstruct = isApplyTrap ? foreignCallableApply : foreignCallableConstruct;\n      return function applyOrConstructTrapForAnyNumberOfArgs(_shadowTarget, thisArgOrArgs, argsOrNewTarget) {\n        lastProxyTrapCalled = proxyTrapEnum; // @ts-ignore: Prevent private property access error.\n\n        const {\n          foreignTargetPointer\n        } = this;\n        const args = isApplyTrap ? argsOrNewTarget : thisArgOrArgs;\n        const {\n          length\n        } = args;\n        let activity;\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity = startActivity(`Reflect.${nativeMethodName}(${length})`);\n        }\n\n        const thisArgOrNewTarget = isApplyTrap ? thisArgOrArgs : argsOrNewTarget;\n        let combinedOffset = 2;\n        const combinedArgs = new ArrayCtor(length + combinedOffset);\n        combinedArgs[0] = foreignTargetPointer;\n        let pointerOrPrimitive;\n\n        try {\n          combinedArgs[1] = typeof thisArgOrNewTarget === 'object' && thisArgOrNewTarget !== null || typeof thisArgOrNewTarget === 'function' ? getTransferablePointer(thisArgOrNewTarget) : // Intentionally ignoring `document.all`.\n          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n          typeof thisArgOrNewTarget === 'undefined' ? undefined : thisArgOrNewTarget;\n\n          for (let i = 0; i < length; i += 1) {\n            const arg = args[i]; // Inlining `getTransferableValue()`.\n\n            combinedArgs[combinedOffset++] = typeof arg === 'object' && arg !== null || typeof arg === 'function' ? getTransferablePointer(arg) : // Intentionally ignoring `document.all`.\n            // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n            // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n            typeof arg === 'undefined' ? undefined : arg;\n          }\n\n          pointerOrPrimitive = ReflectApply(foreignCallableApplyOrConstruct, undefined, combinedArgs);\n        } catch (error) {\n          var _selectedTarget9;\n\n          const errorToThrow = (_selectedTarget9 = selectedTarget) != null ? _selectedTarget9 : error;\n          selectedTarget = undefined;\n\n          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n            activity.error(errorToThrow);\n          }\n\n          throw errorToThrow;\n        }\n\n        let result;\n\n        if (typeof pointerOrPrimitive === 'function') {\n          pointerOrPrimitive();\n          result = selectedTarget;\n          selectedTarget = undefined;\n        } else {\n          result = pointerOrPrimitive;\n        }\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity.stop();\n        }\n\n        return result;\n      };\n    }\n\n    function createDescriptorFromMeta(configurable, enumerable, writable, valuePointerOrPrimitive, getterPointerOrPrimitive, setterPointerOrPrimitive) {\n      const safeDesc = {\n        __proto__: null\n      };\n\n      if (configurable !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL) {\n        safeDesc.configurable = configurable;\n      }\n\n      if (enumerable !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL) {\n        safeDesc.enumerable = enumerable;\n      }\n\n      if (writable !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL) {\n        safeDesc.writable = writable;\n      }\n\n      if (getterPointerOrPrimitive !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL) {\n        if (typeof getterPointerOrPrimitive === 'function') {\n          getterPointerOrPrimitive();\n          safeDesc.get = selectedTarget;\n          selectedTarget = undefined;\n        } else {\n          safeDesc.get = undefined;\n        }\n      }\n\n      if (setterPointerOrPrimitive !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL) {\n        if (typeof setterPointerOrPrimitive === 'function') {\n          setterPointerOrPrimitive();\n          safeDesc.set = selectedTarget;\n          selectedTarget = undefined;\n        } else {\n          safeDesc.set = undefined;\n        }\n      }\n\n      if (valuePointerOrPrimitive !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL) {\n        if (typeof valuePointerOrPrimitive === 'function') {\n          valuePointerOrPrimitive();\n          safeDesc.value = selectedTarget;\n          selectedTarget = undefined;\n        } else {\n          safeDesc.value = valuePointerOrPrimitive;\n        }\n      }\n\n      return safeDesc;\n    }\n\n    function createPointer(originalTarget) {\n      const pointer = () => {\n        // assert: selectedTarget is undefined\n        selectedTarget = originalTarget;\n      };\n\n      return pointer;\n    }\n\n    const disableFastForeignTargetPointers = IS_IN_SHADOW_REALM ? () => {\n      useFastForeignTargetPath = false;\n      useFastForeignTargetPathForTypedArrays = false;\n      clearFastForeignTargetPointers();\n    } : noop;\n    const getLazyPropertyDescriptorStateByTarget = IS_IN_SHADOW_REALM ? target => {\n      let state = localProxyTargetToLazyPropertyDescriptorStateMap.get(target);\n\n      if (state === undefined) {\n        const statePointerOrUndefined = foreignCallableGetLazyPropertyDescriptorStateByTarget(getTransferablePointer(target));\n\n        if (typeof statePointerOrUndefined === 'function') {\n          statePointerOrUndefined();\n          state = selectedTarget;\n          selectedTarget = undefined;\n\n          if (state) {\n            localProxyTargetToLazyPropertyDescriptorStateMap.set(target, state);\n          }\n        }\n      }\n\n      return state;\n    } : noop;\n    const isForeignPointerOfObjectProto = IS_IN_SHADOW_REALM ? // eslint-disable-next-line no-return-assign\n    foreignTargetPointer => foreignTargetPointer === (foreignPointerObjectProto === undefined ? foreignPointerObjectProto = getTransferablePointer(ObjectProto) : foreignPointerObjectProto) : alwaysFalse;\n    const isForeignPointerOfTypedArrayProto = IS_IN_SHADOW_REALM ? // eslint-disable-next-line no-return-assign\n    foreignTargetPointer => foreignTargetPointer === (foreignPointerFloat32ArrayProto === undefined ? foreignPointerFloat32ArrayProto = getTransferablePointer(Float32ArrayProto) : foreignPointerFloat32ArrayProto) || foreignTargetPointer === (foreignPointerFloat64ArrayProto === undefined ? foreignPointerFloat64ArrayProto = getTransferablePointer(Float64ArrayProto) : foreignPointerFloat64ArrayProto) || foreignTargetPointer === (foreignPointerInt8ArrayProto === undefined ? foreignPointerInt8ArrayProto = getTransferablePointer(Int8ArrayProto) : foreignPointerInt8ArrayProto) || foreignTargetPointer === (foreignPointerInt16ArrayProto === undefined ? foreignPointerInt16ArrayProto = getTransferablePointer(Int16ArrayProto) : foreignPointerInt16ArrayProto) || foreignTargetPointer === (foreignPointerInt32ArrayProto === undefined ? foreignPointerInt32ArrayProto = getTransferablePointer(Int32ArrayProto) : foreignPointerInt32ArrayProto) || foreignTargetPointer === (foreignPointerUint8ArrayProto === undefined ? foreignPointerUint8ArrayProto = getTransferablePointer(Uint8ArrayProto) : foreignPointerUint8ArrayProto) || foreignTargetPointer === (foreignPointerUint16ArrayProto === undefined ? foreignPointerUint16ArrayProto = getTransferablePointer(Uint16ArrayProto) : foreignPointerUint16ArrayProto) || foreignTargetPointer === (foreignPointerUint32ArrayProto === undefined ? foreignPointerUint32ArrayProto = getTransferablePointer(Uint32ArrayProto) : foreignPointerUint32ArrayProto) || foreignTargetPointer === (foreignPointerTypedArrayProto === undefined ? foreignPointerTypedArrayProto = getTransferablePointer(TypedArrayProto) : foreignPointerTypedArrayProto) || foreignTargetPointer === (foreignPointerBigInt64ArrayProto === undefined ? foreignPointerBigInt64ArrayProto = BigInt64ArrayProto ? getTransferablePointer(BigInt64ArrayProto) : noop : foreignPointerBigInt64ArrayProto) || foreignTargetPointer === (foreignPointerBigUint64ArrayProto === undefined ? foreignPointerBigUint64ArrayProto = BigUint64ArrayProto ? getTransferablePointer(BigUint64ArrayProto) : noop : foreignPointerBigUint64ArrayProto) : alwaysFalse;\n\n    function getTransferablePointer(originalTarget, foreignCallablePusher = foreignCallablePushTarget) {\n      let proxyPointer = proxyTargetToPointerMap.get(originalTarget);\n\n      if (proxyPointer) {\n        return proxyPointer;\n      }\n\n      let distortionTarget;\n\n      if (distortionCallback) {\n        distortionTarget = distortionCallback(originalTarget); // If a distortion entry is found, it must be a valid proxy target.\n\n        if (distortionTarget !== originalTarget && typeof distortionTarget !== typeof originalTarget) {\n          throw new TypeErrorCtor(`Invalid distortion ${toSafeTemplateStringValue(originalTarget)}.`);\n        }\n      } else {\n        distortionTarget = originalTarget;\n      }\n\n      let isPossiblyRevoked = true;\n      let targetFunctionArity = 0;\n      let targetFunctionName = '';\n      let targetTypedArrayLength = 0;\n      let targetTraits = 16\n      /* TargetTraits.IsObject */\n      ;\n\n      if (typeof distortionTarget === 'function') {\n        isPossiblyRevoked = false;\n        targetFunctionArity = 0;\n        targetTraits = 4\n        /* TargetTraits.IsFunction */\n        ;\n\n        try {\n          // Detect arrow functions.\n          if (!('prototype' in distortionTarget)) {\n            targetTraits |= 8\n            /* TargetTraits.IsArrowFunction */\n            ;\n          }\n\n          const safeLengthDesc = ReflectGetOwnPropertyDescriptor(originalTarget, 'length');\n\n          if (safeLengthDesc) {\n            ReflectSetPrototypeOf(safeLengthDesc, null);\n            const {\n              value: safeLengthDescValue\n            } = safeLengthDesc;\n\n            if (typeof safeLengthDescValue === 'number') {\n              targetFunctionArity = safeLengthDescValue;\n            }\n          }\n\n          const safeNameDesc = false ? ReflectGetOwnPropertyDescriptor(originalTarget, 'name') : undefined;\n          if (safeNameDesc) ;\n        } catch (_unused16) {\n          isPossiblyRevoked = true;\n        }\n      } else if (ArrayBufferIsView(distortionTarget)) {\n        isPossiblyRevoked = false;\n        targetTraits = 2\n        /* TargetTraits.IsArrayBufferView */\n        ;\n\n        try {\n          targetTypedArrayLength = ReflectApply(TypedArrayProtoLengthGetter, distortionTarget, []);\n          targetTraits |= 32\n          /* TargetTraits.IsTypedArray */\n          ; // eslint-disable-next-line no-empty\n        } catch (_unused17) {\n          // Could be a DataView object or a revoked proxy.\n          isPossiblyRevoked = true;\n        }\n      }\n\n      if (isPossiblyRevoked) {\n        try {\n          if (isArrayOrThrowForRevoked(distortionTarget)) {\n            targetTraits = 1\n            /* TargetTraits.IsArray */\n            ;\n          }\n        } catch (_unused18) {\n          targetTraits = 64\n          /* TargetTraits.Revoked */\n          ;\n        }\n      }\n\n      proxyPointer = foreignCallablePusher(createPointer(distortionTarget), targetTraits, targetFunctionArity, targetFunctionName, targetTypedArrayLength); // The WeakMap is populated with the original target rather then the\n      // distorted one while the pointer always uses the distorted one.\n      // TODO: This mechanism poses another issue, which is that the return\n      // value of selectedTarget! can never be used to call across the\n      // membrane because that will cause a wrapping around the potential\n      // distorted value instead of the original value. This is not fatal,\n      // but implies that for every distorted value where are two proxies\n      // that are not ===, which is weird. Guaranteeing this is not easy\n      // because it means auditing the code.\n\n      proxyTargetToPointerMap.set(originalTarget, proxyPointer);\n      return proxyPointer;\n    }\n\n    const installPropertyDescriptorMethodWrappers = IS_IN_SHADOW_REALM ? unforgeableGlobalThisKeys => {\n      if (installedPropertyDescriptorMethodWrappersFlag) {\n        return;\n      }\n\n      installedPropertyDescriptorMethodWrappersFlag = true; // We wrap property descriptor methods to activate lazy\n      // descriptors and/or workaround browser bugs. The following\n      // methods are wrapped:\n      //   Object.getOwnPropertyDescriptors()\n      //   Object.getOwnPropertyDescriptor()\n      //   Reflect.defineProperty()\n      //   Reflect.getOwnPropertyDescriptor()\n      //   Object.prototype.__defineGetter__()\n      //   Object.prototype.__defineSetter__()\n      //   Object.prototype.__lookupGetter__()\n      //   Object.prototype.__lookupSetter__()\n      //\n      // Chromium based browsers have a bug that nulls the result\n      // of `window` getters in detached iframes when the property\n      // descriptor of `window.window` is retrieved.\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=1305302\n      //\n      // Methods may be poisoned when they interact with the `window`\n      // object and retrieve property descriptors, like 'window',\n      // that contain the `window` object itself. The following\n      // built-in methods are susceptible to this issue:\n      //     console.log(window);\n      //     Object.getOwnPropertyDescriptors(window);\n      //     Object.getOwnPropertyDescriptor(window, 'window');\n      //     Reflect.getOwnPropertyDescriptor(window, 'window');\n      //     window.__lookupGetter__('window');\n      //     window.__lookupSetter__('window');\n      //\n      // We side step issues with `console` by mapping it to the\n      // primary realm's `console`. Since we're already wrapping\n      // property descriptor methods to activate lazy descriptors\n      // we use the wrapper to workaround the `window` getter\n      // nulling bug.\n\n      const shouldFixChromeBug = isArrayOrThrowForRevoked(unforgeableGlobalThisKeys) && unforgeableGlobalThisKeys.length > 0; // Lazily populated by `getUnforgeableGlobalThisGetter()`;\n\n      const keyToGlobalThisGetterRegistry = shouldFixChromeBug ? {\n        __proto__: null\n      } : undefined;\n      const getFixedDescriptor = shouldFixChromeBug ? (target, key) => ReflectApply(ArrayProtoIncludes, unforgeableGlobalThisKeys, [key]) ? {\n        configurable: false,\n        enumerable: ReflectApply(ObjectProtoPropertyIsEnumerable, target, [key]),\n        get: getUnforgeableGlobalThisGetter(key),\n        set: undefined\n      } : ReflectGetOwnPropertyDescriptor(target, key) : undefined;\n      const getUnforgeableGlobalThisGetter = shouldFixChromeBug ? key => {\n        let globalThisGetter = keyToGlobalThisGetterRegistry[key];\n\n        if (globalThisGetter === undefined) {\n          // Wrap `unboundGlobalThisGetter` in bound function\n          // to obscure the getter source as \"[native code]\".\n          globalThisGetter = ReflectApply(FunctionProtoBind, unboundGlobalThisGetter, []); // Preserve identity continuity of getters.\n\n          keyToGlobalThisGetterRegistry[key] = globalThisGetter;\n        }\n\n        return globalThisGetter;\n      } : undefined;\n      const lookupFixedGetter = shouldFixChromeBug ? (target, key) => ReflectApply(ArrayProtoIncludes, unforgeableGlobalThisKeys, [key]) ? getUnforgeableGlobalThisGetter(key) : ReflectApply(ObjectProtoLookupGetter, target, [key]) : undefined;\n      const lookupFixedSetter = shouldFixChromeBug ? (target, key) => ReflectApply(ArrayProtoIncludes, unforgeableGlobalThisKeys, [key]) ? undefined : ReflectApply(ObjectProtoLookupSetter, target, [key]) : undefined;\n      const unboundGlobalThisGetter = shouldFixChromeBug ? () => globalThisRef : undefined;\n\n      const wrapDefineAccessOrProperty = originalFunc => {\n        const {\n          length: originalFuncLength\n        } = originalFunc; // `__defineGetter__()` and `__defineSetter__()` have\n        // function lengths of 2 while `Reflect.defineProperty()`\n        // has a function length of 3.\n\n        const useThisArgAsTarget = originalFuncLength === 2;\n        return new ProxyCtor(originalFunc, {\n          apply(_originalFunc, thisArg, args) {\n            if (args.length >= originalFuncLength) {\n              const target = useThisArgAsTarget ? thisArg : args[0];\n\n              if (typeof target === 'object' && target !== null || typeof target === 'function') {\n                const key = useThisArgAsTarget ? args[0] : args[1];\n                const state = getLazyPropertyDescriptorStateByTarget(target);\n\n                if (state != null && state[key]) {\n                  // Activate the descriptor by triggering\n                  // its getter.\n                  // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n                  target[key];\n                }\n              }\n            }\n\n            return ReflectApply(originalFunc, thisArg, args);\n          }\n\n        });\n      };\n\n      const wrapLookupAccessor = (originalFunc, lookupFixedAccessor) => new ProxyCtor(originalFunc, {\n        apply(_originalFunc, thisArg, args) {\n          if (args.length && (typeof thisArg === 'object' && thisArg !== null || typeof thisArg === 'function')) {\n            const {\n              0: key\n            } = args;\n            const state = getLazyPropertyDescriptorStateByTarget(thisArg);\n\n            if (state != null && state[key]) {\n              // Activate the descriptor by triggering\n              // its getter.\n              // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n              thisArg[key];\n            }\n\n            if (shouldFixChromeBug && thisArg === globalThisRef) {\n              return lookupFixedAccessor(thisArg, key);\n            }\n          }\n\n          return ReflectApply(originalFunc, thisArg, args);\n        }\n\n      });\n\n      const wrapGetOwnPropertyDescriptor = originalFunc => new ProxyCtor(originalFunc, {\n        apply(_originalFunc, thisArg, args) {\n          if (args.length > 1) {\n            const {\n              0: target,\n              1: key\n            } = args;\n\n            if (typeof target === 'object' && target !== null || typeof target === 'function') {\n              const state = getLazyPropertyDescriptorStateByTarget(target);\n\n              if (state != null && state[key]) {\n                // Activate the descriptor by triggering\n                // its getter.\n                // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n                target[key];\n              }\n\n              if (shouldFixChromeBug && target === globalThisRef) {\n                return getFixedDescriptor(target, key);\n              }\n            }\n          }\n\n          return ReflectApply(originalFunc, thisArg, args);\n        }\n\n      });\n\n      const wrapGetOwnPropertyDescriptors = originalFunc => new ProxyCtor(originalFunc, {\n        apply(_originalFunc, thisArg, args) {\n          const target = args.length ? args[0] : undefined;\n\n          if (!(typeof target === 'object' && target !== null || typeof target === 'function')) {\n            // Defer to native method to throw exception.\n            return ReflectApply(originalFunc, thisArg, args);\n          }\n\n          const state = getLazyPropertyDescriptorStateByTarget(target);\n          const isFixingChromeBug = target === globalThisRef && shouldFixChromeBug;\n          const unsafeDescMap = isFixingChromeBug ? // Create an empty property descriptor map\n          // to populate with curated descriptors.\n          {} : // Since this is not a global object it is\n          // safe to use the native method.\n          ReflectApply(originalFunc, thisArg, args);\n\n          if (!isFixingChromeBug && state === undefined) {\n            // Exit early if the target is not a global\n            // object and there are no lazy descriptors.\n            return unsafeDescMap;\n          }\n\n          const ownKeys = ReflectOwnKeys(isFixingChromeBug ? target : unsafeDescMap);\n\n          for (let i = 0, {\n            length\n          } = ownKeys; i < length; i += 1) {\n            const ownKey = ownKeys[i];\n            const isLazyProp = !!(state != null && state[ownKey]);\n\n            if (isLazyProp) {\n              // Activate the descriptor by triggering\n              // its getter.\n              // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n              target[ownKey];\n            }\n\n            if (isLazyProp || isFixingChromeBug) {\n              const unsafeDesc = isFixingChromeBug ? getFixedDescriptor(target, ownKey) : ReflectGetOwnPropertyDescriptor(target, ownKey); // Update the descriptor map entry.\n\n              if (unsafeDesc) {\n                unsafeDescMap[ownKey] = unsafeDesc;\n              } else if (!isFixingChromeBug) {\n                ReflectDeleteProperty(unsafeDescMap, ownKey);\n              }\n            }\n          }\n\n          return unsafeDescMap;\n        }\n\n      });\n\n      try {\n        ReflectRef.defineProperty = wrapDefineAccessOrProperty(ReflectDefineProperty); // eslint-disable-next-line no-empty\n      } catch (_unused19) {}\n\n      try {\n        ReflectRef.getOwnPropertyDescriptor = wrapGetOwnPropertyDescriptor(ReflectGetOwnPropertyDescriptor); // eslint-disable-next-line no-empty\n      } catch (_unused20) {}\n\n      try {\n        ObjectCtor.getOwnPropertyDescriptor = wrapGetOwnPropertyDescriptor(ObjectGetOwnPropertyDescriptor); // eslint-disable-next-line no-empty\n      } catch (_unused21) {}\n\n      try {\n        ObjectCtor.getOwnPropertyDescriptors = wrapGetOwnPropertyDescriptors(ObjectGetOwnPropertyDescriptors); // eslint-disable-next-line no-empty\n      } catch (_unused22) {}\n\n      try {\n        // eslint-disable-next-line @typescript-eslint/naming-convention, no-restricted-properties, no-underscore-dangle\n        ObjectProto.__defineGetter__ = wrapDefineAccessOrProperty(ObjectProtoDefineGetter); // eslint-disable-next-line no-empty\n      } catch (_unused23) {}\n\n      try {\n        // eslint-disable-next-line @typescript-eslint/naming-convention, no-restricted-properties, no-underscore-dangle\n        ObjectProto.__defineSetter__ = wrapDefineAccessOrProperty(ObjectProtoDefineSetter); // eslint-disable-next-line no-empty\n      } catch (_unused24) {}\n\n      try {\n        // eslint-disable-next-line @typescript-eslint/naming-convention, no-underscore-dangle\n        ObjectProto.__lookupGetter__ = wrapLookupAccessor(ObjectProtoLookupGetter, lookupFixedGetter); // eslint-disable-next-line no-empty\n      } catch (_unused25) {}\n\n      try {\n        // eslint-disable-next-line @typescript-eslint/naming-convention, no-underscore-dangle\n        ObjectProto.__lookupSetter__ = wrapLookupAccessor(ObjectProtoLookupSetter, lookupFixedSetter); // eslint-disable-next-line no-empty\n      } catch (_unused26) {}\n    } : noop;\n\n    function lookupForeignDescriptor(foreignTargetPointer, shadowTarget, key) {\n      let activity;\n\n      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n        activity = startActivity('lookupForeignDescriptor');\n      }\n\n      let protoPointerOrNull;\n      let safeDesc;\n\n      try {\n        protoPointerOrNull = foreignCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor(foreignTargetPointer, key, (_key, configurable, enumerable, writable, valuePointerOrPrimitive, getterPointerOrPrimitive, setterPointerOrPrimitive) => {\n          safeDesc = {\n            __proto__: null,\n            foreign: true\n          };\n\n          if (configurable !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL) {\n            safeDesc.configurable = configurable;\n          }\n\n          if (enumerable !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL) {\n            safeDesc.enumerable = enumerable;\n          }\n\n          if (writable !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL) {\n            safeDesc.writable = writable;\n          }\n\n          if (getterPointerOrPrimitive !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL) {\n            if (typeof getterPointerOrPrimitive === 'function') {\n              getterPointerOrPrimitive();\n              safeDesc.get = selectedTarget;\n              selectedTarget = undefined;\n            } else {\n              safeDesc.get = undefined;\n            }\n          }\n\n          if (setterPointerOrPrimitive !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL) {\n            if (typeof setterPointerOrPrimitive === 'function') {\n              setterPointerOrPrimitive();\n              safeDesc.set = selectedTarget;\n              selectedTarget = undefined;\n            } else {\n              safeDesc.set = undefined;\n            }\n          }\n\n          if (valuePointerOrPrimitive !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL) {\n            if (typeof valuePointerOrPrimitive === 'function') {\n              valuePointerOrPrimitive();\n              safeDesc.value = selectedTarget;\n              selectedTarget = undefined;\n            } else {\n              safeDesc.value = valuePointerOrPrimitive;\n            }\n          }\n\n          if (configurable === false) {\n            // Update the descriptor to non-configurable on\n            // the shadow target.\n            ReflectDefineProperty(shadowTarget, key, safeDesc);\n          }\n        });\n      } catch (error) {\n        var _selectedTarget10;\n\n        const errorToThrow = (_selectedTarget10 = selectedTarget) != null ? _selectedTarget10 : error;\n        selectedTarget = undefined;\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity.error(errorToThrow);\n        }\n\n        throw errorToThrow;\n      }\n\n      if (safeDesc === undefined) {\n        // Avoiding calling the has trap for any proto chain operation,\n        // instead we implement the regular logic here in this trap.\n        let currentObject;\n\n        if (typeof protoPointerOrNull === 'function') {\n          protoPointerOrNull();\n          currentObject = selectedTarget;\n          selectedTarget = undefined;\n        } else {\n          currentObject = null;\n        }\n\n        while (currentObject) {\n          safeDesc = ReflectGetOwnPropertyDescriptor(currentObject, key);\n\n          if (safeDesc) {\n            ReflectSetPrototypeOf(safeDesc, null);\n            break;\n          }\n\n          currentObject = ReflectGetPrototypeOf(currentObject);\n        }\n\n        if (safeDesc) {\n          var _ref3;\n\n          const {\n            get: getter,\n            set: setter,\n            value: localValue\n          } = safeDesc;\n          const possibleProxy = (_ref3 = getter != null ? getter : setter) != null ? _ref3 : localValue;\n          safeDesc.foreign = (typeof possibleProxy === 'object' && possibleProxy !== null || typeof possibleProxy === 'function') && proxyTargetToPointerMap.get(possibleProxy) !== undefined;\n        }\n      }\n\n      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n        activity.stop();\n      }\n\n      return safeDesc;\n    }\n\n    function passthruForeignTraversedSet(foreignTargetPointer, shadowTarget, key, value, receiver) {\n      const safeDesc = lookupForeignDescriptor(foreignTargetPointer, shadowTarget, key); // Following the specification steps for\n      // OrdinarySetWithOwnDescriptor ( O, P, V, Receiver, ownDesc ).\n      // https://tc39.es/ecma262/#sec-ordinarysetwithowndescriptor\n\n      if (safeDesc) {\n        if ('get' in safeDesc || 'set' in safeDesc) {\n          const {\n            set: setter\n          } = safeDesc;\n\n          if (setter) {\n            if (safeDesc.foreign) {\n              foreignCallableApply(getTransferablePointer(setter), // Inline getTransferableValue().\n              typeof receiver === 'object' && receiver !== null || typeof receiver === 'function' ? getTransferablePointer(receiver) : // Intentionally ignoring `document.all`.\n              // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n              // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n              typeof receiver === 'undefined' ? undefined : receiver, // Inline getTransferableValue().\n              typeof value === 'object' && value !== null || typeof value === 'function' ? getTransferablePointer(value) : // Intentionally ignoring `document.all`.\n              // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n              // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n              typeof value === 'undefined' ? undefined : value);\n            } else {\n              // Even though the setter function exists, we can't\n              // use `ReflectSet()` because there might be a\n              // distortion for that setter function, in which\n              // case we must resolve the local setter and call\n              // it instead.\n              ReflectApply(setter, receiver, [value]);\n            } // If there is a setter, it either throw or we can assume\n            // the value was set.\n\n\n            return true;\n          }\n\n          return false;\n        }\n\n        if (safeDesc.writable === false) {\n          return false;\n        }\n      } // Exit early if receiver is not object like.\n\n\n      if (!(typeof receiver === 'object' && receiver !== null || typeof receiver === 'function')) {\n        return false;\n      }\n\n      const safeReceiverDesc = ReflectGetOwnPropertyDescriptor(receiver, key);\n\n      if (safeReceiverDesc) {\n        ReflectSetPrototypeOf(safeReceiverDesc, null); // Exit early for accessor descriptors or non-writable data\n        // descriptors.\n\n        if ('get' in safeReceiverDesc || 'set' in safeReceiverDesc || safeReceiverDesc.writable === false) {\n          return false;\n        } // Setting the descriptor with only a value entry should not\n        // affect existing descriptor traits.\n\n\n        ReflectDefineProperty(receiver, key, {\n          __proto__: null,\n          value\n        });\n        return true;\n      } // `ReflectDefineProperty()` and `ReflectSet()` both are expected\n      // to return `false` when attempting to add a new property if the\n      // receiver is not extensible.\n\n\n      return ReflectDefineProperty(receiver, key, {\n        __proto__: null,\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      });\n    }\n\n    function pushErrorAcrossBoundary(error) {\n      if (LOCKER_DEBUGGABLE_FLAG) {\n        checkDebugMode();\n      } // Inline getTransferableValue().\n\n\n      if (typeof error === 'object' && error !== null || typeof error === 'function') {\n        const foreignErrorPointer = getTransferablePointer(error, foreignCallablePushErrorTarget);\n        foreignErrorPointer();\n      }\n\n      return error;\n    }\n\n    function pushTarget(foreignTargetPointer, foreignTargetTraits, foreignTargetFunctionArity, foreignTargetFunctionName, foreignTargetTypedArrayLength) {\n      const {\n        proxy\n      } = new BoundaryProxyHandler(foreignTargetPointer, foreignTargetTraits, foreignTargetFunctionArity, foreignTargetFunctionName, foreignTargetTypedArrayLength);\n      proxyTargetToPointerMap.set(proxy, foreignTargetPointer);\n      return createPointer(proxy);\n    }\n\n    const setLazyPropertyDescriptorStateByTarget = IS_IN_SHADOW_REALM ? (target, state) => {\n      localProxyTargetToLazyPropertyDescriptorStateMap.set(target, state);\n      foreignCallableSetLazyPropertyDescriptorStateByTarget(getTransferablePointer(target), getTransferablePointer(state));\n    } : noop;\n\n    class BoundaryProxyHandler {\n      constructor(foreignTargetPointer, foreignTargetTraits, foreignTargetFunctionArity, foreignTargetFunctionName, foreignTargetTypedArrayLength) {\n        let shadowTarget;\n        const isForeignTargetArray = foreignTargetTraits & 1\n        /* TargetTraits.IsArray */\n        ;\n        const isForeignTargetFunction = foreignTargetTraits & 4\n        /* TargetTraits.IsFunction */\n        ;\n\n        if (isForeignTargetFunction) {\n          // This shadow target is never invoked. It's needed to avoid\n          // proxy trap invariants. Because it's not invoked the code\n          // does not need to be instrumented for code coverage.\n          //\n          // istanbul ignore next\n          shadowTarget = foreignTargetTraits & 8\n          /* TargetTraits.IsArrowFunction */\n          ? () => {} : function () {};\n        } else if (isForeignTargetArray) {\n          shadowTarget = [];\n        } else {\n          shadowTarget = {};\n        }\n\n        const {\n          proxy,\n          revoke\n        } = ProxyRevocable(shadowTarget, this);\n        this.foreignTargetPointer = foreignTargetPointer;\n        this.foreignTargetTraits = foreignTargetTraits;\n        this.foreignTargetTypedArrayLength = foreignTargetTypedArrayLength; // Define in the BoundaryProxyHandler constructor so it is bound\n        // to the BoundaryProxyHandler instance.\n\n        this.nonConfigurableDescriptorCallback = (key, configurable, enumerable, writable, valuePointer, getterPointer, setterPointer) => {\n          // Update the descriptor to non-configurable on the shadow\n          // target.\n          ReflectDefineProperty(this.shadowTarget, key, createDescriptorFromMeta(configurable, enumerable, writable, valuePointer, getterPointer, setterPointer));\n        };\n\n        this.proxy = proxy;\n        this.revoke = revoke;\n        this.serializedValue = undefined;\n        this.shadowTarget = shadowTarget;\n        this.staticToStringTag = 'Object'; // Define traps.\n\n        if (isForeignTargetFunction) {\n          var _arityToApplyTrapName, _arityToConstructTrap;\n\n          this.apply = this[(_arityToApplyTrapName = arityToApplyTrapNameRegistry[foreignTargetFunctionArity]) != null ? _arityToApplyTrapName : arityToApplyTrapNameRegistry.n];\n          this.construct = this[(_arityToConstructTrap = arityToConstructTrapNameRegistry[foreignTargetFunctionArity]) != null ? _arityToConstructTrap : arityToConstructTrapNameRegistry.n];\n        }\n\n        this.defineProperty = BoundaryProxyHandler.defaultDefinePropertyTrap;\n        this.deleteProperty = BoundaryProxyHandler.defaultDeletePropertyTrap;\n        this.isExtensible = BoundaryProxyHandler.defaultIsExtensibleTrap;\n        this.getOwnPropertyDescriptor = BoundaryProxyHandler.defaultGetOwnPropertyDescriptorTrap;\n        this.getPrototypeOf = BoundaryProxyHandler.defaultGetPrototypeOfTrap;\n        this.get = foreignTargetTraits & 32\n        /* TargetTraits.IsTypedArray */\n        ? BoundaryProxyHandler.hybridGetTrapForTypedArray : BoundaryProxyHandler.defaultGetTrap;\n        this.has = BoundaryProxyHandler.defaultHasTrap;\n        this.ownKeys = BoundaryProxyHandler.defaultOwnKeysTrap;\n        this.preventExtensions = BoundaryProxyHandler.defaultPreventExtensionsTrap;\n        this.setPrototypeOf = BoundaryProxyHandler.defaultSetPrototypeOfTrap;\n        this.set = BoundaryProxyHandler.defaultSetTrap;\n\n        if (foreignTargetTraits & 64\n        /* TargetTraits.Revoked */\n        ) {\n          // Future optimization: Hoping proxies with frozen handlers\n          // can be faster.\n          ObjectFreeze(this);\n          this.revoke();\n        } else if (IS_IN_SHADOW_REALM) {\n          if (isForeignTargetArray || foreignTargetTraits & 2\n          /* TargetTraits.IsArrayBufferView */\n          ) {\n            this.makeProxyLive();\n          }\n        } else {\n          if (foreignTargetTraits & 16\n          /* TargetTraits.IsObject */\n          ) {\n            // Lazily define serializedValue.\n            let cachedSerializedValue = LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL;\n            const {\n              serializedValue\n            } = this;\n\n            if (MINIFICATION_SAFE_SERIALIZED_VALUE_PROPERTY_NAME === undefined) {\n              // A minification safe way to get the 'serializedValue'\n              // property name.\n              ({\n                0: MINIFICATION_SAFE_SERIALIZED_VALUE_PROPERTY_NAME\n              } = ObjectKeys({\n                serializedValue\n              }));\n            }\n\n            ReflectApply(ObjectProtoDefineGetter, this, [MINIFICATION_SAFE_SERIALIZED_VALUE_PROPERTY_NAME, () => {\n              if (cachedSerializedValue === LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL) {\n                cachedSerializedValue = foreignCallableSerializeTarget(this.foreignTargetPointer);\n              }\n\n              return cachedSerializedValue;\n            }]);\n          } // Future optimization: Hoping proxies with frozen handlers\n          // can be faster. If local mutations are not trapped, then\n          // freezing the handler is ok because it is not expecting to\n          // change in the future.\n\n\n          ObjectFreeze(this);\n        }\n      } // Internal shadow realm side utilities:\n\n\n      makeProxyLive() {\n        // Replace pending traps with live traps that can work with the\n        // target without taking snapshots.\n        this.deleteProperty = BoundaryProxyHandler.passthruDeletePropertyTrap;\n        this.defineProperty = BoundaryProxyHandler.passthruDefinePropertyTrap;\n        this.preventExtensions = BoundaryProxyHandler.passthruPreventExtensionsTrap;\n        this.set = BoundaryProxyHandler.passthruSetTrap;\n        this.setPrototypeOf = BoundaryProxyHandler.passthruSetPrototypeOfTrap; // Future optimization: Hoping proxies with frozen handlers can\n        // be faster.\n\n        ObjectFreeze(this);\n      }\n\n      makeProxyStatic() {\n        // Reset all traps except apply and construct for static proxies\n        // since the proxy target is the shadow target and all operations\n        // are going to be applied to it rather than the real target.\n        this.defineProperty = BoundaryProxyHandler.staticDefinePropertyTrap;\n        this.deleteProperty = BoundaryProxyHandler.staticDeletePropertyTrap;\n        this.get = BoundaryProxyHandler.staticGetTrap;\n        this.getOwnPropertyDescriptor = BoundaryProxyHandler.staticGetOwnPropertyDescriptorTrap;\n        this.getPrototypeOf = BoundaryProxyHandler.staticGetPrototypeOfTrap;\n        this.has = BoundaryProxyHandler.staticHasTrap;\n        this.isExtensible = BoundaryProxyHandler.staticIsExtensibleTrap;\n        this.ownKeys = BoundaryProxyHandler.staticOwnKeysTrap;\n        this.preventExtensions = BoundaryProxyHandler.staticPreventExtensionsTrap;\n        this.set = BoundaryProxyHandler.staticSetTrap;\n        this.setPrototypeOf = BoundaryProxyHandler.staticSetPrototypeOfTrap;\n        const {\n          foreignTargetPointer,\n          foreignTargetTraits,\n          shadowTarget\n        } = this;\n\n        if (useFastForeignTargetPath) {\n          fastForeignTargetPointers.delete(foreignTargetPointer);\n        } // We don't wrap `foreignCallableGetTargetIntegrityTraits()`\n        // in a try-catch because it cannot throw.\n\n\n        const targetIntegrityTraits = foreignCallableGetTargetIntegrityTraits(foreignTargetPointer);\n\n        if (targetIntegrityTraits & 8\n        /* TargetIntegrityTraits.Revoked */\n        ) {\n          // Future optimization: Hoping proxies with frozen\n          // handlers can be faster.\n          ObjectFreeze(this); // the target is a revoked proxy, in which case we revoke\n          // this proxy as well.\n\n          this.revoke();\n          return;\n        } // A proxy can revoke itself when traps are triggered and break\n        // the membrane, therefore we need protection.\n\n\n        try {\n          copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget(foreignTargetPointer, shadowTarget);\n        } catch (_unused27) {\n          // We don't wrap `foreignCallableIsTargetRevoked()` in a\n          // try-catch because it cannot throw.\n          if (foreignCallableIsTargetRevoked(foreignTargetPointer)) {\n            // Future optimization: Hoping proxies with frozen\n            // handlers can be faster.\n            ObjectFreeze(this);\n            this.revoke();\n            return;\n          }\n        }\n\n        if (foreignTargetTraits & 16\n        /* TargetTraits.IsObject */\n        && !(SymbolToStringTag in shadowTarget)) {\n          let toStringTag = 'Object';\n\n          try {\n            toStringTag = foreignCallableGetToStringTagOfTarget(foreignTargetPointer); // eslint-disable-next-line no-empty\n          } catch (_unused28) {}\n\n          this.staticToStringTag = toStringTag;\n        } // Preserve the semantics of the target.\n\n\n        if (targetIntegrityTraits & 4\n        /* TargetIntegrityTraits.IsFrozen */\n        ) {\n          ObjectFreeze(shadowTarget);\n        } else {\n          if (targetIntegrityTraits & 2\n          /* TargetIntegrityTraits.IsSealed */\n          ) {\n            ObjectSeal(shadowTarget);\n          } else if (targetIntegrityTraits & 1\n          /* TargetIntegrityTraits.IsNotExtensible */\n          ) {\n            ReflectPreventExtensions(shadowTarget);\n          }\n\n          if (LOCKER_UNMINIFIED_FLAG) {\n            // We don't wrap `foreignCallableDebugInfo()` in a try-catch\n            // because it cannot throw.\n            foreignCallableDebugInfo('Mutations on the membrane of an object originating ' + 'outside of the sandbox will not be reflected on ' + 'the object itself:', foreignTargetPointer);\n          }\n        } // Future optimization: Hoping proxies with frozen handlers can\n        // be faster.\n\n\n        ObjectFreeze(this);\n      } // Passthru traps:\n\n\n      static passthruDefinePropertyTrap(_shadowTarget, key, unsafePartialDesc) {\n        lastProxyTrapCalled = 4\n        /* ProxyHandlerTraps.DefineProperty */\n        ;\n        let activity;\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity = startActivity('Reflect.defineProperty');\n        }\n\n        const {\n          foreignTargetPointer,\n          nonConfigurableDescriptorCallback\n        } = this;\n        const safePartialDesc = unsafePartialDesc;\n        ReflectSetPrototypeOf(safePartialDesc, null);\n        const {\n          get: getter,\n          set: setter,\n          value\n        } = safePartialDesc;\n        const valuePointerOrPrimitive = 'value' in safePartialDesc ? // Inline getTransferableValue().\n        typeof value === 'object' && value !== null || typeof value === 'function' ? getTransferablePointer(value) : // Intentionally ignoring `document.all`.\n        // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n        typeof value === 'undefined' ? undefined : value : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL;\n        const getterPointerOrUndefinedSymbol = 'get' in safePartialDesc ? // Inline getTransferableValue().\n        typeof getter === 'function' ? getTransferablePointer(getter) : getter : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL;\n        const setterPointerOrUndefinedSymbol = 'set' in safePartialDesc ? // Inline getTransferableValue().\n        typeof setter === 'function' ? getTransferablePointer(setter) : setter : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL;\n        let result = false;\n\n        try {\n          result = foreignCallableDefineProperty(foreignTargetPointer, key, 'configurable' in safePartialDesc ? !!safePartialDesc.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL, 'enumerable' in safePartialDesc ? !!safePartialDesc.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL, 'writable' in safePartialDesc ? !!safePartialDesc.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL, valuePointerOrPrimitive, getterPointerOrUndefinedSymbol, setterPointerOrUndefinedSymbol, nonConfigurableDescriptorCallback);\n        } catch (error) {\n          var _selectedTarget11;\n\n          const errorToThrow = (_selectedTarget11 = selectedTarget) != null ? _selectedTarget11 : error;\n          selectedTarget = undefined;\n\n          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n            activity.error(errorToThrow);\n          }\n\n          throw errorToThrow;\n        }\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity.stop();\n        }\n\n        if (useFastForeignTargetPath && result && (typeof getterPointerOrUndefinedSymbol === 'function' || typeof setterPointerOrUndefinedSymbol === 'function')) {\n          fastForeignTargetPointers.delete(foreignTargetPointer);\n        }\n\n        return result;\n      }\n\n      static passthruDeletePropertyTrap(_shadowTarget, key) {\n        lastProxyTrapCalled = 8\n        /* ProxyHandlerTraps.DeleteProperty */\n        ;\n        let activity;\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity = startActivity('Reflect.deleteProperty');\n        }\n\n        let result = false;\n\n        try {\n          result = foreignCallableDeleteProperty(this.foreignTargetPointer, key);\n        } catch (error) {\n          var _selectedTarget12;\n\n          const errorToThrow = (_selectedTarget12 = selectedTarget) != null ? _selectedTarget12 : error;\n          selectedTarget = undefined;\n\n          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n            activity.error(errorToThrow);\n          }\n\n          throw errorToThrow;\n        }\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity.stop();\n        }\n\n        return result;\n      }\n\n      static passthruGetPrototypeOfTrap(_shadowTarget) {\n        lastProxyTrapCalled = 64\n        /* ProxyHandlerTraps.GetPrototypeOf */\n        ;\n        let activity;\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity = startActivity('Reflect.getPrototypeOf');\n        }\n\n        let protoPointerOrNull;\n\n        try {\n          protoPointerOrNull = foreignCallableGetPrototypeOf(this.foreignTargetPointer);\n        } catch (error) {\n          var _selectedTarget13;\n\n          const errorToThrow = (_selectedTarget13 = selectedTarget) != null ? _selectedTarget13 : error;\n          selectedTarget = undefined;\n\n          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n            activity.error(errorToThrow);\n          }\n\n          throw errorToThrow;\n        }\n\n        let proto;\n\n        if (typeof protoPointerOrNull === 'function') {\n          protoPointerOrNull();\n          proto = selectedTarget;\n          selectedTarget = undefined;\n        } else {\n          proto = null;\n        }\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity.stop();\n        }\n\n        return proto;\n      }\n\n      static passthruIsExtensibleTrap(_shadowTarget) {\n        lastProxyTrapCalled = 256\n        /* ProxyHandlerTraps.IsExtensible */\n        ;\n        let activity;\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity = startActivity('Reflect.isExtensible');\n        }\n\n        const {\n          shadowTarget\n        } = this;\n        let result = false; // Check if already locked.\n\n        if (ReflectIsExtensible(shadowTarget)) {\n          const {\n            foreignTargetPointer\n          } = this;\n\n          try {\n            result = foreignCallableIsExtensible(foreignTargetPointer);\n          } catch (error) {\n            var _selectedTarget14;\n\n            const errorToThrow = (_selectedTarget14 = selectedTarget) != null ? _selectedTarget14 : error;\n            selectedTarget = undefined;\n\n            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n              activity.error(errorToThrow);\n            }\n\n            throw errorToThrow;\n          }\n\n          if (!result) {\n            copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget(foreignTargetPointer, shadowTarget);\n            ReflectPreventExtensions(shadowTarget);\n          }\n        }\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity.stop();\n        }\n\n        return result;\n      }\n\n      static passthruOwnKeysTrap(_shadowTarget) {\n        lastProxyTrapCalled = 512\n        /* ProxyHandlerTraps.OwnKeys */\n        ;\n        let activity;\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity = startActivity('Reflect.ownKeys');\n        }\n\n        let ownKeys;\n\n        try {\n          foreignCallableOwnKeys(this.foreignTargetPointer, (...args) => {\n            ownKeys = args;\n          });\n        } catch (error) {\n          var _selectedTarget15;\n\n          const errorToThrow = (_selectedTarget15 = selectedTarget) != null ? _selectedTarget15 : error;\n          selectedTarget = undefined;\n\n          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n            activity.error(errorToThrow);\n          }\n\n          throw errorToThrow;\n        }\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity.stop();\n        }\n\n        return ownKeys || [];\n      }\n\n      static passthruGetOwnPropertyDescriptorTrap(_shadowTarget, key) {\n        lastProxyTrapCalled = 32\n        /* ProxyHandlerTraps.GetOwnPropertyDescriptor */\n        ;\n        let activity;\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity = startActivity('Reflect.getOwnPropertyDescriptor');\n        }\n\n        const {\n          foreignTargetPointer,\n          shadowTarget\n        } = this;\n        let safeDesc;\n\n        try {\n          foreignCallableGetOwnPropertyDescriptor(foreignTargetPointer, key, (_key, configurable, enumerable, writable, valuePointer, getterPointer, setterPointer) => {\n            safeDesc = createDescriptorFromMeta(configurable, enumerable, writable, valuePointer, getterPointer, setterPointer);\n\n            if (safeDesc.configurable === false) {\n              // Update the descriptor to non-configurable on\n              // the shadow target.\n              ReflectDefineProperty(shadowTarget, key, safeDesc);\n            }\n          });\n        } catch (error) {\n          var _selectedTarget16;\n\n          const errorToThrow = (_selectedTarget16 = selectedTarget) != null ? _selectedTarget16 : error;\n          selectedTarget = undefined;\n\n          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n            activity.error(errorToThrow);\n          }\n\n          throw errorToThrow;\n        }\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity.stop();\n        }\n\n        return safeDesc;\n      }\n\n      static passthruPreventExtensionsTrap(_shadowTarget) {\n        lastProxyTrapCalled = 1024\n        /* ProxyHandlerTraps.PreventExtensions */\n        ;\n        let activity;\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity = startActivity('Reflect.preventExtensions');\n        }\n\n        const {\n          foreignTargetPointer,\n          shadowTarget\n        } = this;\n        let result = true;\n\n        if (ReflectIsExtensible(shadowTarget)) {\n          let resultEnum = 0\n          /* PreventExtensionsResult.None */\n          ;\n\n          try {\n            resultEnum = foreignCallablePreventExtensions(foreignTargetPointer);\n          } catch (error) {\n            var _selectedTarget17;\n\n            const errorToThrow = (_selectedTarget17 = selectedTarget) != null ? _selectedTarget17 : error;\n            selectedTarget = undefined;\n\n            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n              activity.error(errorToThrow);\n            }\n\n            throw errorToThrow;\n          } // If the target is a proxy it might reject the\n          // preventExtension call, in which case we should not\n          // attempt to lock down the shadow target.\n\n\n          if (!(resultEnum & 1\n          /* PreventExtensionsResult.Extensible */\n          )) {\n            copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget(foreignTargetPointer, shadowTarget);\n            ReflectPreventExtensions(shadowTarget);\n          }\n\n          result = !(resultEnum & 2\n          /* PreventExtensionsResult.False */\n          );\n        }\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity.stop();\n        }\n\n        return result;\n      }\n\n      static passthruSetPrototypeOfTrap(_shadowTarget, proto) {\n        lastProxyTrapCalled = 4096\n        /* ProxyHandlerTraps.SetPrototypeOf */\n        ;\n        let activity;\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity = startActivity('Reflect.setPrototypeOf');\n        }\n\n        const {\n          foreignTargetPointer\n        } = this;\n        const transferableProto = proto ? getTransferablePointer(proto) : proto;\n        let result = false;\n\n        try {\n          result = foreignCallableSetPrototypeOf(foreignTargetPointer, transferableProto);\n        } catch (error) {\n          var _selectedTarget18;\n\n          const errorToThrow = (_selectedTarget18 = selectedTarget) != null ? _selectedTarget18 : error;\n          selectedTarget = undefined;\n\n          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n            activity.error(errorToThrow);\n          }\n\n          throw errorToThrow;\n        }\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity.stop();\n        }\n\n        if (useFastForeignTargetPath && result) {\n          fastForeignTargetPointers.delete(foreignTargetPointer);\n        }\n\n        return result;\n      }\n\n      static passthruSetTrap(_shadowTarget, key, value, receiver) {\n        lastProxyTrapCalled = 2048\n        /* ProxyHandlerTraps.Set */\n        ;\n        const {\n          foreignTargetPointer,\n          proxy,\n          shadowTarget\n        } = this; // Intentionally ignoring `document.all`.\n        // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n\n        if (typeof value === 'undefined') {\n          value = undefined;\n        }\n\n        if (typeof receiver === 'undefined') {\n          receiver = proxy;\n        }\n\n        const isFastPath = proxy === receiver;\n        let activity;\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity = startActivity(isFastPath ? 'Reflect.set' : 'passthruForeignTraversedSet');\n        }\n\n        let result = false;\n\n        try {\n          result = isFastPath ? foreignCallableSet(foreignTargetPointer, key, // Inline getTransferableValue().\n          typeof value === 'object' && value !== null || typeof value === 'function' ? getTransferablePointer(value) : value, LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL) : passthruForeignTraversedSet(foreignTargetPointer, shadowTarget, key, value, receiver);\n        } catch (error) {\n          var _selectedTarget19;\n\n          const errorToThrow = (_selectedTarget19 = selectedTarget) != null ? _selectedTarget19 : error;\n          selectedTarget = undefined;\n\n          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n            activity.error(errorToThrow);\n          }\n\n          throw errorToThrow;\n        }\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity.stop();\n        }\n\n        return result;\n      }\n\n    } // Logic implementation of all traps.\n    // Hybrid traps:\n    // (traps that operate on their shadowTarget, proxy, and foreignTargetPointer):\n\n\n    BoundaryProxyHandler.hybridGetTrap = IS_IN_SHADOW_REALM ? function (_shadowTarget, key, receiver) {\n      let activity;\n\n      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n        activity = startActivity('hybridGetTrap');\n      }\n\n      const {\n        foreignTargetPointer,\n        foreignTargetTraits,\n        proxy,\n        shadowTarget\n      } = this;\n      let safeDesc;\n      let result;\n\n      if (useFastForeignTargetPath && fastForeignTargetPointers.has(foreignTargetPointer)) {\n        let pointerOrPrimitive;\n\n        try {\n          pointerOrPrimitive = foreignCallableGetPropertyValue(foreignTargetPointer, key);\n        } catch (error) {\n          var _selectedTarget20;\n\n          const errorToThrow = (_selectedTarget20 = selectedTarget) != null ? _selectedTarget20 : error;\n          selectedTarget = undefined;\n\n          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n            activity.error(errorToThrow);\n          }\n\n          throw errorToThrow;\n        }\n\n        if (typeof pointerOrPrimitive === 'function') {\n          pointerOrPrimitive();\n          result = selectedTarget;\n          selectedTarget = undefined;\n        } else {\n          result = pointerOrPrimitive;\n        }\n      } else {\n        safeDesc = lookupForeignDescriptor(foreignTargetPointer, shadowTarget, key);\n\n        if (safeDesc) {\n          const {\n            get: getter,\n            value: localValue\n          } = safeDesc;\n\n          if (getter) {\n            if (safeDesc.foreign) {\n              const foreignGetterPointer = getTransferablePointer(getter);\n              const transferableReceiver = proxy === receiver ? foreignTargetPointer : // Inline getTransferableValue().\n              typeof receiver === 'object' && receiver !== null || typeof receiver === 'function' ? getTransferablePointer(receiver) : receiver;\n              let pointerOrPrimitive;\n\n              try {\n                pointerOrPrimitive = foreignCallableApply(foreignGetterPointer, transferableReceiver);\n              } catch (error) {\n                var _selectedTarget21;\n\n                const errorToThrow = (_selectedTarget21 = selectedTarget) != null ? _selectedTarget21 : error;\n                selectedTarget = undefined;\n\n                if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                  activity.error(errorToThrow);\n                }\n\n                throw errorToThrow;\n              }\n\n              if (typeof pointerOrPrimitive === 'function') {\n                pointerOrPrimitive();\n                result = selectedTarget;\n                selectedTarget = undefined;\n              } else {\n                result = pointerOrPrimitive;\n              }\n            } else {\n              // Even though the getter function exists,\n              // we can't use `ReflectGet()` because there\n              // might be a distortion for that getter function,\n              // in which case we must resolve the local getter\n              // and call it instead.\n              result = ReflectApply(getter, receiver, []);\n            }\n          } else {\n            result = localValue;\n          }\n        } else {\n          const transferableReceiver = proxy === receiver ? foreignTargetPointer : // Inline getTransferableValue().\n          typeof receiver === 'object' && receiver !== null || typeof receiver === 'function' ? getTransferablePointer(receiver) : receiver;\n          let pointerOrPrimitive;\n\n          try {\n            pointerOrPrimitive = foreignCallableGet(foreignTargetPointer, foreignTargetTraits, key, transferableReceiver);\n          } catch (error) {\n            var _selectedTarget22;\n\n            const errorToThrow = (_selectedTarget22 = selectedTarget) != null ? _selectedTarget22 : error;\n            selectedTarget = undefined;\n\n            if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n              activity.error(errorToThrow);\n            }\n\n            throw errorToThrow;\n          }\n\n          if (typeof pointerOrPrimitive === 'function') {\n            pointerOrPrimitive();\n            result = selectedTarget;\n            selectedTarget = undefined;\n          } else {\n            result = pointerOrPrimitive;\n          }\n        }\n      }\n\n      if (safeDesc === undefined && result === undefined && key === SymbolToStringTag && foreignTargetTraits & 16\n      /* TargetTraits.IsObject */\n      ) {\n        let toStringTag;\n\n        try {\n          toStringTag = foreignCallableGetToStringTagOfTarget(foreignTargetPointer);\n        } catch (error) {\n          var _selectedTarget23;\n\n          const errorToThrow = (_selectedTarget23 = selectedTarget) != null ? _selectedTarget23 : error;\n          selectedTarget = undefined;\n\n          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n            activity.error(errorToThrow);\n          }\n\n          throw errorToThrow;\n        } // The default language toStringTag is \"Object\". If we\n        // receive \"Object\" we return `undefined` to let the\n        // language resolve it naturally without projecting a\n        // value.\n\n\n        if (toStringTag !== 'Object') {\n          result = toStringTag;\n        }\n      }\n\n      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n        activity.stop();\n      }\n\n      return result;\n    } : noop;\n    BoundaryProxyHandler.hybridGetTrapForTypedArray = IS_IN_SHADOW_REALM ? function (_shadowTarget, key, receiver) {\n      let activity;\n\n      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n        activity = startActivity('hybridGetTrapForTypedArray');\n      }\n\n      const {\n        foreignTargetPointer,\n        foreignTargetTypedArrayLength,\n        proxy,\n        shadowTarget\n      } = this;\n      let useFastPath = useFastForeignTargetPathForTypedArrays;\n\n      if (!useFastPath && typeof key === 'string') {\n        const possibleIndex = +key;\n        useFastPath = possibleIndex > -1 && possibleIndex < foreignTargetTypedArrayLength && NumberIsInteger(possibleIndex);\n      }\n\n      let result;\n\n      if (useFastPath) {\n        try {\n          result = foreignCallableGetPropertyValue(foreignTargetPointer, key);\n        } catch (error) {\n          var _selectedTarget24;\n\n          const errorToThrow = (_selectedTarget24 = selectedTarget) != null ? _selectedTarget24 : error;\n          selectedTarget = undefined;\n\n          if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n            activity.error(errorToThrow);\n          }\n\n          throw errorToThrow;\n        }\n      } else {\n        const safeDesc = lookupForeignDescriptor(foreignTargetPointer, shadowTarget, key);\n\n        if (safeDesc) {\n          const {\n            get: getter,\n            value: localValue\n          } = safeDesc;\n\n          if (getter) {\n            if (safeDesc.foreign) {\n              const foreignGetterPointer = getTransferablePointer(getter);\n              const transferableReceiver = proxy === receiver ? foreignTargetPointer : // Inline getTransferableValue().\n              typeof receiver === 'object' && receiver !== null || typeof receiver === 'function' ? getTransferablePointer(receiver) : receiver;\n              let pointerOrPrimitive;\n\n              try {\n                pointerOrPrimitive = foreignCallableApply(foreignGetterPointer, transferableReceiver);\n              } catch (error) {\n                var _selectedTarget25;\n\n                const errorToThrow = (_selectedTarget25 = selectedTarget) != null ? _selectedTarget25 : error;\n                selectedTarget = undefined;\n\n                if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n                  activity.error(errorToThrow);\n                }\n\n                throw errorToThrow;\n              }\n\n              if (typeof pointerOrPrimitive === 'function') {\n                pointerOrPrimitive();\n                result = selectedTarget;\n                selectedTarget = undefined;\n              } else {\n                result = pointerOrPrimitive;\n              }\n            } else {\n              // Even though the getter function exists,\n              // we can't use `ReflectGet()` because there\n              // might be a distortion for that getter function,\n              // in which case we must resolve the local getter\n              // and call it instead.\n              result = ReflectApply(getter, receiver, []);\n            }\n          } else {\n            result = localValue;\n          }\n        }\n      }\n\n      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n        activity.stop();\n      }\n\n      return result;\n    } : noop;\n    BoundaryProxyHandler.hybridHasTrap = IS_IN_SHADOW_REALM ? function (_shadowTarget, key) {\n      let activity;\n\n      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n        activity = startActivity('hybridHasTrap');\n      }\n\n      let trueOrProtoPointerOrNull;\n\n      try {\n        trueOrProtoPointerOrNull = foreignCallableBatchGetPrototypeOfWhenHasNoOwnProperty(this.foreignTargetPointer, key);\n      } catch (error) {\n        var _selectedTarget26;\n\n        const errorToThrow = (_selectedTarget26 = selectedTarget) != null ? _selectedTarget26 : error;\n        selectedTarget = undefined;\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity.error(errorToThrow);\n        }\n\n        throw errorToThrow;\n      }\n\n      let result = false;\n\n      if (trueOrProtoPointerOrNull === true) {\n        result = true;\n      } else {\n        // Avoiding calling the has trap for any proto chain operation,\n        // instead we implement the regular logic here in this trap.\n        let currentObject;\n\n        if (typeof trueOrProtoPointerOrNull === 'function') {\n          trueOrProtoPointerOrNull();\n          currentObject = selectedTarget;\n          selectedTarget = undefined;\n        } else {\n          currentObject = null;\n        }\n\n        while (currentObject) {\n          if (ObjectHasOwn(currentObject, key)) {\n            result = true;\n            break;\n          }\n\n          currentObject = ReflectGetPrototypeOf(currentObject);\n        }\n      }\n\n      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n        activity.stop();\n      }\n\n      return result;\n    } : alwaysFalse;\n    BoundaryProxyHandler.passthruGetTrap = !IS_IN_SHADOW_REALM ? function (_shadowTarget, key, receiver) {\n      // Only allow accessing near-membrane symbol values if the\n      // BoundaryProxyHandler.has trap has been called immediately\n      // before and the symbol does not exist.\n      nearMembraneSymbolFlag && (nearMembraneSymbolFlag = lastProxyTrapCalled === 128\n      /* ProxyHandlerTraps.Has */\n      );\n      lastProxyTrapCalled = 16\n      /* ProxyHandlerTraps.Get */\n      ;\n\n      if (nearMembraneSymbolFlag) {\n        // Exit without performing a [[Get]] for near-membrane\n        // symbols because we know when the nearMembraneSymbolFlag\n        // is on that there is no shadowed symbol value.\n        if (key === LOCKER_NEAR_MEMBRANE_SYMBOL) {\n          return true;\n        }\n\n        if (key === LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL) {\n          return this.serializedValue;\n        }\n      }\n\n      let activity;\n\n      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n        activity = startActivity('Reflect.get');\n      }\n\n      const {\n        foreignTargetPointer,\n        foreignTargetTraits,\n        proxy\n      } = this;\n\n      if (typeof receiver === 'undefined') {\n        receiver = proxy;\n      }\n\n      const transferableReceiver = proxy === receiver ? LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL : // Inline getTransferableValue().\n      typeof receiver === 'object' && receiver !== null || typeof receiver === 'function' ? getTransferablePointer(receiver) : receiver;\n      let pointerOrPrimitive;\n\n      try {\n        pointerOrPrimitive = foreignCallableGet(foreignTargetPointer, foreignTargetTraits, key, transferableReceiver);\n      } catch (error) {\n        var _selectedTarget27;\n\n        const errorToThrow = (_selectedTarget27 = selectedTarget) != null ? _selectedTarget27 : error;\n        selectedTarget = undefined;\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity.error(errorToThrow);\n        }\n\n        throw errorToThrow;\n      }\n\n      let result;\n\n      if (typeof pointerOrPrimitive === 'function') {\n        pointerOrPrimitive();\n        result = selectedTarget;\n        selectedTarget = undefined;\n      } else {\n        result = pointerOrPrimitive;\n      }\n\n      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n        activity.stop();\n      }\n\n      return result;\n    } : noop;\n    BoundaryProxyHandler.passthruHasTrap = !IS_IN_SHADOW_REALM ? function (_shadowTarget, key) {\n      lastProxyTrapCalled = 128\n      /* ProxyHandlerTraps.Has */\n      ;\n      let activity;\n\n      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n        activity = startActivity('Reflect.has');\n      }\n\n      let result;\n\n      try {\n        result = foreignCallableHas(this.foreignTargetPointer, key);\n      } catch (error) {\n        var _selectedTarget28;\n\n        const errorToThrow = (_selectedTarget28 = selectedTarget) != null ? _selectedTarget28 : error;\n        selectedTarget = undefined;\n\n        if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n          activity.error(errorToThrow);\n        }\n\n        throw errorToThrow;\n      } // The near-membrane symbol flag is on if the symbol does not\n      // exist on the object or its [[Prototype]].\n\n\n      nearMembraneSymbolFlag = !result && (key === LOCKER_NEAR_MEMBRANE_SYMBOL || key === LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL);\n\n      if (LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG) {\n        activity.stop();\n      }\n\n      return result;\n    } : alwaysFalse; // Pending traps:\n\n    BoundaryProxyHandler.pendingDefinePropertyTrap = IS_IN_SHADOW_REALM ? function (shadowTarget, key, unsafePartialDesc) {\n      const {\n        foreignTargetPointer,\n        foreignTargetTraits\n      } = this; // We don't wrap `foreignCallableIsTargetLive()` in a\n      // try-catch because it cannot throw.\n\n      if (foreignCallableIsTargetLive(foreignTargetPointer, foreignTargetTraits)) {\n        this.makeProxyLive();\n      } else {\n        if (useFastForeignTargetPath) {\n          if (isForeignPointerOfObjectProto(foreignTargetPointer)) {\n            disableFastForeignTargetPointers();\n          } else if (isForeignPointerOfTypedArrayProto(foreignTargetPointer)) {\n            useFastForeignTargetPathForTypedArrays = false;\n          }\n        }\n\n        this.makeProxyStatic();\n      }\n\n      return this.defineProperty(shadowTarget, key, unsafePartialDesc);\n    } : alwaysFalse;\n    BoundaryProxyHandler.pendingDeletePropertyTrap = IS_IN_SHADOW_REALM ? function (shadowTarget, key) {\n      // We don't wrap `foreignCallableIsTargetLive()` in a\n      // try-catch because it cannot throw.\n      if (foreignCallableIsTargetLive(this.foreignTargetPointer, this.foreignTargetTraits)) {\n        this.makeProxyLive();\n      } else {\n        this.makeProxyStatic();\n      }\n\n      return this.deleteProperty(shadowTarget, key);\n    } : alwaysFalse;\n    BoundaryProxyHandler.pendingPreventExtensionsTrap = IS_IN_SHADOW_REALM ? function (shadowTarget) {\n      // We don't wrap `foreignCallableIsTargetLive()` in a\n      // try-catch because it cannot throw.\n      if (foreignCallableIsTargetLive(this.foreignTargetPointer, this.foreignTargetTraits)) {\n        this.makeProxyLive();\n      } else {\n        this.makeProxyStatic();\n      }\n\n      return this.preventExtensions(shadowTarget);\n    } : alwaysFalse;\n    BoundaryProxyHandler.pendingSetPrototypeOfTrap = IS_IN_SHADOW_REALM ? function (shadowTarget, proto) {\n      const {\n        foreignTargetPointer,\n        foreignTargetTraits\n      } = this; // We don't wrap `foreignCallableIsTargetLive()` in a\n      // try-catch because it cannot throw.\n\n      if (foreignCallableIsTargetLive(foreignTargetPointer, foreignTargetTraits)) {\n        this.makeProxyLive();\n      } else {\n        if (useFastForeignTargetPath) {\n          if (isForeignPointerOfObjectProto(foreignTargetPointer)) {\n            disableFastForeignTargetPointers();\n          } else if (isForeignPointerOfTypedArrayProto(foreignTargetPointer)) {\n            useFastForeignTargetPathForTypedArrays = false;\n          }\n        }\n\n        this.makeProxyStatic();\n      }\n\n      return this.setPrototypeOf(shadowTarget, proto);\n    } : alwaysFalse;\n    BoundaryProxyHandler.pendingSetTrap = IS_IN_SHADOW_REALM ? function (shadowTarget, key, value, receiver) {\n      const {\n        foreignTargetPointer,\n        foreignTargetTraits\n      } = this; // We don't wrap `foreignCallableIsTargetLive()` in a\n      // try-catch because it cannot throw.\n\n      if (foreignCallableIsTargetLive(foreignTargetPointer, foreignTargetTraits)) {\n        this.makeProxyLive();\n      } else {\n        if (useFastForeignTargetPath) {\n          if (isForeignPointerOfObjectProto(foreignTargetPointer)) {\n            disableFastForeignTargetPointers();\n          } else if (isForeignPointerOfTypedArrayProto(foreignTargetPointer)) {\n            useFastForeignTargetPathForTypedArrays = false;\n          }\n        }\n\n        this.makeProxyStatic();\n      }\n\n      return this.set(shadowTarget, key, value, receiver);\n    } : alwaysFalse; //  Static traps:\n\n    BoundaryProxyHandler.staticDefinePropertyTrap = IS_IN_SHADOW_REALM ? ReflectDefineProperty : alwaysFalse;\n    BoundaryProxyHandler.staticDeletePropertyTrap = IS_IN_SHADOW_REALM ? ReflectDeleteProperty : alwaysFalse;\n    BoundaryProxyHandler.staticGetOwnPropertyDescriptorTrap = IS_IN_SHADOW_REALM ? ReflectGetOwnPropertyDescriptor : noop;\n    BoundaryProxyHandler.staticGetPrototypeOfTrap = IS_IN_SHADOW_REALM ? ReflectGetPrototypeOf : () => null;\n    BoundaryProxyHandler.staticGetTrap = IS_IN_SHADOW_REALM ? function (shadowTarget, key, receiver) {\n      const {\n        foreignTargetTraits,\n        staticToStringTag\n      } = this;\n      const result = ReflectGet(shadowTarget, key, receiver);\n\n      if (result === undefined && key === SymbolToStringTag && foreignTargetTraits & 16\n      /* TargetTraits.IsObject */\n      && // The default language toStringTag is \"Object\". If we\n      // receive \"Object\" we return `undefined` to let the\n      // language resolve it naturally without projecting a\n      // value.\n      staticToStringTag !== 'Object' && !(key in shadowTarget)) {\n        return staticToStringTag;\n      }\n\n      return result;\n    } : noop;\n    BoundaryProxyHandler.staticHasTrap = IS_IN_SHADOW_REALM ? ReflectHas : alwaysFalse;\n    BoundaryProxyHandler.staticIsExtensibleTrap = IS_IN_SHADOW_REALM ? ReflectIsExtensible : alwaysFalse;\n    BoundaryProxyHandler.staticOwnKeysTrap = IS_IN_SHADOW_REALM ? ReflectOwnKeys : () => [];\n    BoundaryProxyHandler.staticPreventExtensionsTrap = IS_IN_SHADOW_REALM ? ReflectPreventExtensions : alwaysFalse;\n    BoundaryProxyHandler.staticSetPrototypeOfTrap = IS_IN_SHADOW_REALM ? ReflectSetPrototypeOf : alwaysFalse;\n    BoundaryProxyHandler.staticSetTrap = IS_IN_SHADOW_REALM ? ReflectSet : alwaysFalse; // Default traps:\n    // Pending traps are needed for the shadow realm side of the membrane\n    // to avoid leaking mutation operations on the primary realm side.\n\n    BoundaryProxyHandler.defaultDefinePropertyTrap = IS_IN_SHADOW_REALM ? BoundaryProxyHandler.pendingDefinePropertyTrap : BoundaryProxyHandler.passthruDefinePropertyTrap;\n    BoundaryProxyHandler.defaultDeletePropertyTrap = IS_IN_SHADOW_REALM ? BoundaryProxyHandler.pendingDeletePropertyTrap : BoundaryProxyHandler.passthruDeletePropertyTrap;\n    BoundaryProxyHandler.defaultGetOwnPropertyDescriptorTrap = BoundaryProxyHandler.passthruGetOwnPropertyDescriptorTrap;\n    BoundaryProxyHandler.defaultGetPrototypeOfTrap = BoundaryProxyHandler.passthruGetPrototypeOfTrap;\n    BoundaryProxyHandler.defaultGetTrap = IS_IN_SHADOW_REALM ? BoundaryProxyHandler.hybridGetTrap : BoundaryProxyHandler.passthruGetTrap;\n    BoundaryProxyHandler.defaultHasTrap = IS_IN_SHADOW_REALM ? BoundaryProxyHandler.hybridHasTrap : BoundaryProxyHandler.passthruHasTrap;\n    BoundaryProxyHandler.defaultIsExtensibleTrap = BoundaryProxyHandler.passthruIsExtensibleTrap;\n    BoundaryProxyHandler.defaultOwnKeysTrap = BoundaryProxyHandler.passthruOwnKeysTrap;\n    BoundaryProxyHandler.defaultPreventExtensionsTrap = IS_IN_SHADOW_REALM ? BoundaryProxyHandler.pendingPreventExtensionsTrap : BoundaryProxyHandler.passthruPreventExtensionsTrap;\n    BoundaryProxyHandler.defaultSetTrap = IS_IN_SHADOW_REALM ? BoundaryProxyHandler.pendingSetTrap : BoundaryProxyHandler.passthruSetTrap;\n    BoundaryProxyHandler.defaultSetPrototypeOfTrap = IS_IN_SHADOW_REALM ? BoundaryProxyHandler.pendingSetPrototypeOfTrap : BoundaryProxyHandler.passthruSetPrototypeOfTrap;\n\n    if (IS_IN_SHADOW_REALM) {\n      clearFastForeignTargetPointers();\n    } // Export callable hooks to a foreign realm.\n\n\n    foreignCallableHooksCallback( // globalThisPointer\n    // When crossing, should be mapped to the foreign globalThis\n    createPointer(globalThisRef), // getSelectedTarget\n    !IS_IN_SHADOW_REALM ? () => {\n      const result = selectedTarget;\n      selectedTarget = undefined;\n      return result;\n    } : noop, // getTransferableValue\n    value => {\n      if (typeof value === 'object' && value !== null || typeof value === 'function') {\n        return getTransferablePointer(value);\n      } // Intentionally ignoring `document.all`.\n      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n\n\n      return typeof value === 'undefined' ? undefined : value;\n    }, // callableGetPropertyValuePointer: this callable function allows\n    // the foreign realm to access a linkable pointer for a property value.\n    // In order to do that, the foreign side must provide a pointer and\n    // a key access the value in order to produce a pointer\n    (targetPointer, key) => {\n      targetPointer();\n      const target = selectedTarget;\n      selectedTarget = undefined;\n      const value = target == null ? void 0 : target[key]; // Intentionally ignoring `document.all`.\n      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n\n      return createPointer(typeof value === 'undefined' ? undefined : value);\n    }, // callableEvaluate\n    IS_IN_SHADOW_REALM ? sourceText => {\n      let result;\n\n      try {\n        result = localEval(sourceText);\n      } catch (error) {\n        throw pushErrorAcrossBoundary(error);\n      } // Inline getTransferableValue().\n\n\n      return typeof result === 'object' && result !== null || typeof result === 'function' ? getTransferablePointer(result) : result;\n    } : noop, // callableLinkPointers: this callable function allows the foreign\n    // realm to define a linkage between two values across the membrane.\n    (targetPointer, newPointer) => {\n      targetPointer();\n      const target = selectedTarget;\n      selectedTarget = undefined;\n\n      if (typeof target === 'object' && target !== null || typeof target === 'function') {\n        proxyTargetToPointerMap.set(target, newPointer);\n      }\n    }, // callablePushErrorTarget\n    LOCKER_DEBUGGABLE_FLAG ? (foreignTargetPointer, foreignTargetTraits, foreignTargetFunctionArity, foreignTargetFunctionName, foreignTargetTypedArrayLength) => {\n      const pointer = pushTarget(foreignTargetPointer, foreignTargetTraits, foreignTargetFunctionArity, foreignTargetFunctionName, foreignTargetTypedArrayLength);\n\n      const pointerWrapper = () => {\n        checkDebugMode();\n        return pointer();\n      };\n\n      return pointerWrapper;\n    } : pushTarget, // callablePushTarget: This function can be used by a foreign realm\n    // to install a proxy into this realm that correspond to an object\n    // from the foreign realm. It returns a Pointer that can be used by\n    // the foreign realm to pass back a reference to this realm when\n    // passing arguments or returning from a foreign callable invocation.\n    // This function is extremely important to understand the mechanics\n    // of this membrane.\n    pushTarget, // callableApply\n    (targetPointer, thisArgPointerOrUndefined, ...args) => {\n      targetPointer();\n      const func = selectedTarget;\n      selectedTarget = undefined;\n      let thisArg;\n\n      if (typeof thisArgPointerOrUndefined === 'function') {\n        thisArgPointerOrUndefined();\n        thisArg = selectedTarget;\n        selectedTarget = undefined;\n      }\n\n      for (let i = 0, {\n        length\n      } = args; i < length; i += 1) {\n        const pointerOrPrimitive = args[i];\n\n        if (typeof pointerOrPrimitive === 'function') {\n          pointerOrPrimitive();\n          args[i] = selectedTarget;\n          selectedTarget = undefined;\n        }\n      }\n\n      let result;\n\n      try {\n        result = ReflectApply(func, thisArg, args);\n      } catch (error) {\n        throw pushErrorAcrossBoundary(error);\n      } // Inline getTransferableValue().\n\n\n      return typeof result === 'object' && result !== null || typeof result === 'function' ? getTransferablePointer(result) : // Intentionally ignoring `document.all`.\n      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n      typeof result === 'undefined' ? undefined : result;\n    }, // callableConstruct\n    (targetPointer, newTargetPointerOrUndefined, ...args) => {\n      targetPointer();\n      const constructor = selectedTarget;\n      selectedTarget = undefined;\n      let newTarget;\n\n      if (typeof newTargetPointerOrUndefined === 'function') {\n        newTargetPointerOrUndefined();\n        newTarget = selectedTarget;\n        selectedTarget = undefined;\n      }\n\n      for (let i = 0, {\n        length\n      } = args; i < length; i += 1) {\n        const pointerOrPrimitive = args[i];\n\n        if (typeof pointerOrPrimitive === 'function') {\n          pointerOrPrimitive();\n          args[i] = selectedTarget;\n          selectedTarget = undefined;\n        }\n      }\n\n      let result;\n\n      try {\n        result = ReflectConstruct(constructor, args, newTarget);\n      } catch (error) {\n        throw pushErrorAcrossBoundary(error);\n      } // Inline getTransferableValue().\n\n\n      return typeof result === 'object' && result !== null || typeof result === 'function' ? getTransferablePointer(result) : // Intentionally ignoring `document.all`.\n      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n      typeof result === 'undefined' ? undefined : result;\n    }, // callableDefineProperty\n    (targetPointer, key, configurable, enumerable, writable, valuePointer, getterPointer, setterPointer, foreignCallableNonConfigurableDescriptorCallback) => {\n      targetPointer();\n      const target = selectedTarget;\n      selectedTarget = undefined;\n      const safePartialDesc = createDescriptorFromMeta(configurable, enumerable, writable, valuePointer, getterPointer, setterPointer);\n      let result = false;\n\n      try {\n        result = ReflectDefineProperty(target, key, safePartialDesc);\n      } catch (error) {\n        throw pushErrorAcrossBoundary(error);\n      }\n\n      if (result && configurable === false) {\n        let safeDesc;\n\n        try {\n          safeDesc = ReflectGetOwnPropertyDescriptor(target, key);\n        } catch (error) {\n          throw pushErrorAcrossBoundary(error);\n        }\n\n        if (safeDesc) {\n          ReflectSetPrototypeOf(safeDesc, null);\n\n          if (safeDesc.configurable === false) {\n            const {\n              get: getter,\n              set: setter,\n              value\n            } = safeDesc;\n            foreignCallableNonConfigurableDescriptorCallback(key, false, // configurable\n            'enumerable' in safeDesc ? safeDesc.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL, 'writable' in safeDesc ? safeDesc.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL, 'value' in safeDesc ? // Inline getTransferableValue().\n            typeof value === 'object' && value !== null || typeof value === 'function' ? getTransferablePointer(value) : value : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL, 'get' in safeDesc ? // Inline getTransferableValue().\n            typeof getter === 'function' ? getTransferablePointer(getter) : getter : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL, 'set' in safeDesc ? // Inline getTransferableValue().\n            typeof setter === 'function' ? getTransferablePointer(setter) : setter : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL);\n          }\n        }\n      }\n\n      return result;\n    }, // callableDeleteProperty\n    (targetPointer, key) => {\n      targetPointer();\n      const target = selectedTarget;\n      selectedTarget = undefined;\n\n      try {\n        return ReflectDeleteProperty(target, key);\n      } catch (error) {\n        throw pushErrorAcrossBoundary(error);\n      }\n    }, // callableGet\n    (targetPointer, targetTraits, key, receiverPointerOrPrimitive) => {\n      targetPointer();\n      const target = selectedTarget;\n      selectedTarget = undefined;\n      let receiver;\n\n      if (typeof receiverPointerOrPrimitive === 'function') {\n        receiverPointerOrPrimitive();\n        receiver = selectedTarget;\n        selectedTarget = undefined;\n      } else {\n        receiver = receiverPointerOrPrimitive === LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL ? target : receiverPointerOrPrimitive;\n      }\n\n      let result;\n\n      try {\n        result = ReflectGet(target, key, receiver);\n      } catch (error) {\n        throw pushErrorAcrossBoundary(error);\n      } // Inline getTransferableValue().\n\n\n      if (typeof result === 'object' && result !== null || typeof result === 'function') {\n        return getTransferablePointer(result);\n      }\n\n      if (result === undefined && key === SymbolToStringTag && targetTraits & 16\n      /* TargetTraits.IsObject */\n      ) {\n        try {\n          if (!(key in target)) {\n            // Section 19.1.3.6 Object.prototype.toString()\n            // https://tc39.github.io/ecma262/#sec-object.prototype.tostring\n            const brand = ReflectApply(ObjectProtoToString, target, []); // The default language toStringTag is \"Object\". If\n            // we receive \"[object Object]\" we return `undefined`\n            // to let the language resolve it naturally without\n            // projecting a value.\n\n            if (brand !== '[object Object]') {\n              result = ReflectApply(StringProtoSlice, brand, [8, -1]);\n            }\n          }\n        } catch (error) {\n          throw pushErrorAcrossBoundary(error);\n        }\n      } // Intentionally ignoring `document.all`.\n      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n\n\n      return typeof result === 'undefined' ? undefined : result;\n    }, // callableGetOwnPropertyDescriptor\n    (targetPointer, key, foreignCallableDescriptorCallback) => {\n      targetPointer();\n      const target = selectedTarget;\n      selectedTarget = undefined;\n      let safeDesc;\n\n      try {\n        safeDesc = ReflectGetOwnPropertyDescriptor(target, key);\n      } catch (error) {\n        throw pushErrorAcrossBoundary(error);\n      }\n\n      if (safeDesc) {\n        ReflectSetPrototypeOf(safeDesc, null);\n        const {\n          get: getter,\n          set: setter,\n          value\n        } = safeDesc;\n        foreignCallableDescriptorCallback(key, 'configurable' in safeDesc ? safeDesc.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL, 'enumerable' in safeDesc ? safeDesc.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL, 'writable' in safeDesc ? safeDesc.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL, 'value' in safeDesc ? // Inline getTransferableValue().\n        typeof value === 'object' && value !== null || typeof value === 'function' ? getTransferablePointer(value) : // Intentionally ignoring `document.all`.\n        // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n        typeof value === 'undefined' ? undefined : value : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL, 'get' in safeDesc ? // Inline getTransferableValue().\n        typeof getter === 'function' ? getTransferablePointer(getter) : getter : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL, 'set' in safeDesc ? // Inline getTransferableValue().\n        typeof setter === 'function' ? getTransferablePointer(setter) : setter : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL);\n      }\n    }, // callableGetPrototypeOf\n    targetPointer => {\n      targetPointer();\n      const target = selectedTarget;\n      selectedTarget = undefined;\n      let proto;\n\n      try {\n        proto = ReflectGetPrototypeOf(target);\n      } catch (error) {\n        throw pushErrorAcrossBoundary(error);\n      } // Intentionally ignoring `document.all`.\n      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n\n\n      if (typeof proto === 'undefined') {\n        return null;\n      }\n\n      return proto ? getTransferablePointer(proto) : proto;\n    }, // callableHas\n    (targetPointer, key) => {\n      targetPointer();\n      const target = selectedTarget;\n      selectedTarget = undefined;\n\n      try {\n        return key in target;\n      } catch (error) {\n        throw pushErrorAcrossBoundary(error);\n      }\n    }, // callableIsExtensible\n    targetPointer => {\n      targetPointer();\n      const target = selectedTarget;\n      selectedTarget = undefined;\n\n      try {\n        return ReflectIsExtensible(target);\n      } catch (error) {\n        throw pushErrorAcrossBoundary(error);\n      }\n    }, // callableOwnKeys\n    (targetPointer, foreignCallableKeysCallback) => {\n      targetPointer();\n      const target = selectedTarget;\n      selectedTarget = undefined;\n      let ownKeys;\n\n      try {\n        ownKeys = ReflectOwnKeys(target);\n      } catch (error) {\n        throw pushErrorAcrossBoundary(error);\n      }\n\n      ReflectApply(foreignCallableKeysCallback, undefined, ownKeys);\n    }, // callablePreventExtensions\n    targetPointer => {\n      targetPointer();\n      const target = selectedTarget;\n      selectedTarget = undefined;\n      let result = 2\n      /* PreventExtensionsResult.False */\n      ;\n\n      try {\n        if (ReflectPreventExtensions(target)) {\n          result = 4\n          /* PreventExtensionsResult.True */\n          ;\n        } else if (ReflectIsExtensible(target)) {\n          result |= 1\n          /* PreventExtensionsResult.Extensible */\n          ;\n        }\n      } catch (error) {\n        throw pushErrorAcrossBoundary(error);\n      }\n\n      return result;\n    }, // callableSet\n    (targetPointer, key, valuePointerOrPrimitive, receiverPointerOrPrimitive) => {\n      targetPointer();\n      const target = selectedTarget;\n      selectedTarget = undefined;\n      let value;\n\n      if (typeof valuePointerOrPrimitive === 'function') {\n        valuePointerOrPrimitive();\n        value = selectedTarget;\n        selectedTarget = undefined;\n      } else {\n        value = valuePointerOrPrimitive;\n      }\n\n      let receiver;\n\n      if (typeof receiverPointerOrPrimitive === 'function') {\n        receiverPointerOrPrimitive();\n        receiver = selectedTarget;\n        selectedTarget = undefined;\n      } else {\n        receiver = receiverPointerOrPrimitive === LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL ? target : receiverPointerOrPrimitive;\n      }\n\n      try {\n        return ReflectSet(target, key, value, receiver);\n      } catch (error) {\n        throw pushErrorAcrossBoundary(error);\n      }\n    }, // callableSetPrototypeOf\n    (targetPointer, protoPointerOrNull = null) => {\n      targetPointer();\n      const target = selectedTarget;\n      selectedTarget = undefined;\n      let proto;\n\n      if (typeof protoPointerOrNull === 'function') {\n        protoPointerOrNull();\n        proto = selectedTarget;\n        selectedTarget = undefined;\n      } else {\n        proto = null;\n      }\n\n      try {\n        return ReflectSetPrototypeOf(target, proto);\n      } catch (error) {\n        throw pushErrorAcrossBoundary(error);\n      }\n    }, // callableDebugInfo\n    LOCKER_DEBUGGABLE_FLAG ? (...args) => {\n      if (checkDebugMode()) {\n        for (let i = 0, {\n          length\n        } = args; i < length; i += 1) {\n          const pointerOrPrimitive = args[i];\n\n          if (typeof pointerOrPrimitive === 'function') {\n            pointerOrPrimitive();\n            args[i] = selectedTarget;\n            selectedTarget = undefined;\n          }\n        }\n\n        try {\n          ReflectApply(consoleInfo, consoleObject, args); // eslint-disable-next-line no-empty\n        } catch (_unused29) {}\n      }\n    } : noop, // callableDefineProperties\n    IS_IN_SHADOW_REALM ? (targetPointer, ...descriptorTuples) => {\n      targetPointer();\n      const target = selectedTarget;\n      selectedTarget = undefined;\n\n      for (let i = 0, {\n        length\n      } = descriptorTuples; i < length; i += 7) {\n        // We don't use `ObjectDefineProperties()` here because it\n        // will throw an exception if it fails to define one of its\n        // properties.\n        ReflectDefineProperty(target, descriptorTuples[i], createDescriptorFromMeta(descriptorTuples[i + 1], // configurable\n        descriptorTuples[i + 2], // enumerable\n        descriptorTuples[i + 3], // writable\n        descriptorTuples[i + 4], // valuePointer\n        descriptorTuples[i + 5], // getterPointer\n        descriptorTuples[i + 6] // setterPointer\n        ));\n      }\n    } : noop, // callableGetLazyPropertyDescriptorStateByTarget\n    !IS_IN_SHADOW_REALM ? targetPointer => {\n      targetPointer();\n      const target = selectedTarget;\n      selectedTarget = undefined; // We don't wrap the weak map `get()` call in a try-catch\n      // because we know `target` is an object.\n\n      const state = proxyTargetToLazyPropertyDescriptorStateMap.get(target);\n      return state ? getTransferablePointer(state) : state;\n    } : noop, // callableGetPropertyValue\n    !IS_IN_SHADOW_REALM ? (targetPointer, index) => {\n      targetPointer();\n      const target = selectedTarget;\n      selectedTarget = undefined;\n\n      try {\n        return target[index];\n      } catch (error) {\n        throw pushErrorAcrossBoundary(error);\n      }\n    } : noop, // callableGetTargetIntegrityTraits\n    !IS_IN_SHADOW_REALM ? targetPointer => {\n      targetPointer();\n      const target = selectedTarget;\n      selectedTarget = undefined; // A target may be a proxy that is revoked or throws in its\n      // \"isExtensible\" trap.\n\n      try {\n        if (!ReflectIsExtensible(target)) {\n          if (ObjectIsFrozen(target)) {\n            return 4\n            /* TargetIntegrityTraits.IsFrozen */\n            & 2\n            /* TargetIntegrityTraits.IsSealed */\n            & 1\n            /* TargetIntegrityTraits.IsNotExtensible */\n            ;\n          }\n\n          if (ObjectIsSealed(target)) {\n            return 2\n            /* TargetIntegrityTraits.IsSealed */\n            & 1\n            /* TargetIntegrityTraits.IsNotExtensible */\n            ;\n          }\n\n          return 1\n          /* TargetIntegrityTraits.IsNotExtensible */\n          ;\n        }\n      } catch (_unused30) {\n        try {\n          isArrayOrThrowForRevoked(target);\n        } catch (_unused31) {\n          return 8\n          /* TargetIntegrityTraits.Revoked */\n          ;\n        }\n      }\n\n      return 0\n      /* TargetIntegrityTraits.None */\n      ;\n    } : () => 0\n    /* TargetIntegrityTraits.None */\n    , // callableGetToStringTagOfTarget\n    targetPointer => {\n      targetPointer();\n      const target = selectedTarget;\n      selectedTarget = undefined;\n\n      try {\n        // Section 19.1.3.6 Object.prototype.toString()\n        // https://tc39.github.io/ecma262/#sec-object.prototype.tostring\n        const brand = ReflectApply(ObjectProtoToString, target, []);\n        return brand === '[object Object]' ? 'Object' : ReflectApply(StringProtoSlice, brand, [8, -1]);\n      } catch (error) {\n        throw pushErrorAcrossBoundary(error);\n      }\n    }, // callableInstallErrorPrepareStackTrace\n    installErrorPrepareStackTrace, // callableInstallLazyPropertyDescriptors\n    IS_IN_SHADOW_REALM ? (targetPointer, ...ownKeysAndUnforgeableGlobalThisKeys) => {\n      const sliceIndex = ReflectApply(ArrayProtoIndexOf, ownKeysAndUnforgeableGlobalThisKeys, [LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL]);\n      let ownKeys;\n      let unforgeableGlobalThisKeys;\n\n      if (sliceIndex === -1) {\n        ownKeys = ownKeysAndUnforgeableGlobalThisKeys;\n      } else {\n        ownKeys = ReflectApply(ArrayProtoSlice, ownKeysAndUnforgeableGlobalThisKeys, [0, sliceIndex]);\n        unforgeableGlobalThisKeys = ReflectApply(ArrayProtoSlice, ownKeysAndUnforgeableGlobalThisKeys, [sliceIndex + 1]);\n      }\n\n      targetPointer();\n      const target = selectedTarget;\n      selectedTarget = undefined;\n      let state = getLazyPropertyDescriptorStateByTarget(target);\n\n      if (state === undefined) {\n        state = {\n          __proto__: null\n        };\n        setLazyPropertyDescriptorStateByTarget(target, state);\n      }\n\n      for (let i = 0, {\n        length\n      } = ownKeys; i < length; i += 1) {\n        const ownKey = ownKeys[i];\n        state[ownKey] = true;\n        ReflectDefineProperty(target, ownKey, // The role of this descriptor is to serve as a\n        // bouncer. When either a getter or a setter is\n        // invoked the descriptor will be replaced with\n        // the descriptor from the foreign side and the\n        // get/set operation will carry on from there.\n        {\n          __proto__: null,\n          // We DO explicitly set configurability in the\n          // off chance that the property doesn't exist.\n          configurable: true,\n\n          // We DON'T explicitly set enumerability to\n          // defer to the enumerability of the existing\n          // property. In the off chance the property\n          // doesn't exist the property will be defined\n          // as non-enumerable.\n          get() {\n            activateLazyOwnPropertyDefinition(target, ownKey, state);\n            return target[ownKey];\n          },\n\n          set(value) {\n            activateLazyOwnPropertyDefinition(target, ownKey, state);\n            ReflectSet(target, ownKey, value);\n          }\n\n        });\n      }\n\n      installPropertyDescriptorMethodWrappers(unforgeableGlobalThisKeys);\n    } : noop, // callableIsTargetLive\n    !IS_IN_SHADOW_REALM && liveTargetCallback ? (targetPointer, targetTraits) => {\n      targetPointer();\n      const target = selectedTarget;\n      selectedTarget = undefined;\n\n      if (target !== ObjectProto && target !== RegExpProto) {\n        try {\n          return liveTargetCallback(target, targetTraits); // eslint-disable-next-line no-empty\n        } catch (_unused32) {}\n      }\n\n      return false;\n    } : alwaysFalse, // callableIsTargetRevoked\n    !IS_IN_SHADOW_REALM ? targetPointer => {\n      targetPointer();\n      const target = selectedTarget;\n      selectedTarget = undefined;\n\n      try {\n        isArrayOrThrowForRevoked(target);\n        return false; //  eslint-disable-next-line no-empty\n      } catch (_unused33) {}\n\n      return true;\n    } : alwaysFalse, // callableSerializeTarget\n    IS_IN_SHADOW_REALM ? targetPointer => {\n      targetPointer();\n      const target = selectedTarget;\n      selectedTarget = undefined;\n\n      try {\n        return SymbolToStringTag in target ? serializeTargetByTrialAndError(target) : // Fast path.\n        serializeTargetByBrand(target); // eslint-disable-next-line no-empty\n      } catch (_unused34) {}\n\n      return undefined;\n    } : noop, // callableSetLazyPropertyDescriptorStateByTarget\n    !IS_IN_SHADOW_REALM ? (targetPointer, statePointer) => {\n      targetPointer();\n      const target = selectedTarget;\n      selectedTarget = undefined;\n      statePointer();\n      const state = selectedTarget;\n      selectedTarget = undefined; // We don't wrap the weak map `set()` call in a try-catch\n      // because we know `target` is an object.\n\n      proxyTargetToLazyPropertyDescriptorStateMap.set(target, state);\n    } : noop, // callableTrackAsFastTarget\n    !IS_IN_SHADOW_REALM ? targetPointer => {\n      targetPointer();\n      const target = selectedTarget;\n      selectedTarget = undefined;\n\n      if (useFastForeignTargetPath) {\n        fastForeignTargetPointers.add(getTransferablePointer(target));\n      }\n    } : noop, // callableBatchGetPrototypeOfAndGetOwnPropertyDescriptors\n    (targetPointer, foreignCallableDescriptorsCallback) => {\n      targetPointer();\n      const target = selectedTarget;\n      selectedTarget = undefined;\n      let unsafeDescMap;\n\n      try {\n        unsafeDescMap = ObjectGetOwnPropertyDescriptors(target);\n      } catch (error) {\n        throw pushErrorAcrossBoundary(error);\n      }\n\n      const ownKeys = ReflectOwnKeys(unsafeDescMap);\n      const {\n        length\n      } = ownKeys;\n      const descriptorTuples = new ArrayCtor(length * 7);\n\n      for (let i = 0, j = 0; i < length; i += 1, j += 7) {\n        const ownKey = ownKeys[i];\n        const safeDesc = unsafeDescMap[ownKey];\n        ReflectSetPrototypeOf(safeDesc, null);\n        const {\n          get: getter,\n          set: setter,\n          value\n        } = safeDesc;\n        descriptorTuples[j] = ownKey;\n        descriptorTuples[j + 1] = 'configurable' in safeDesc ? safeDesc.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL;\n        descriptorTuples[j + 2] = 'enumerable' in safeDesc ? safeDesc.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL;\n        descriptorTuples[j + 3] = 'writable' in safeDesc ? safeDesc.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL;\n        descriptorTuples[j + 4] = 'value' in safeDesc ? // Inline getTransferableValue().\n        typeof value === 'object' && value !== null || typeof value === 'function' ? getTransferablePointer(value) : value : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL;\n        descriptorTuples[j + 5] = 'get' in safeDesc ? // Inline getTransferableValue().\n        typeof getter === 'function' ? getTransferablePointer(getter) : getter : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL;\n        descriptorTuples[j + 6] = 'set' in safeDesc ? // Inline getTransferableValue().\n        typeof setter === 'function' ? getTransferablePointer(setter) : setter : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL;\n      }\n\n      ReflectApply(foreignCallableDescriptorsCallback, undefined, descriptorTuples);\n      let proto;\n\n      try {\n        proto = ReflectGetPrototypeOf(target);\n      } catch (error) {\n        throw pushErrorAcrossBoundary(error);\n      } // Intentionally ignoring `document.all`.\n      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n\n\n      if (typeof proto === 'undefined') {\n        return null;\n      }\n\n      return proto ? getTransferablePointer(proto) : proto;\n    }, // callableBatchGetPrototypeOfWhenHasNoOwnProperty\n    (targetPointer, key) => {\n      targetPointer();\n      const target = selectedTarget;\n      selectedTarget = undefined;\n      let proto;\n\n      try {\n        if (ObjectHasOwn(target, key)) {\n          return true;\n        }\n\n        proto = ReflectGetPrototypeOf(target);\n      } catch (error) {\n        throw pushErrorAcrossBoundary(error);\n      } // Intentionally ignoring `document.all`.\n      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n\n\n      if (typeof proto === 'undefined') {\n        return null;\n      }\n\n      return proto ? getTransferablePointer(proto) : proto;\n    }, // callableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor\n    (targetPointer, key, foreignCallableDescriptorCallback) => {\n      targetPointer();\n      const target = selectedTarget;\n      selectedTarget = undefined;\n      let safeDesc;\n\n      try {\n        safeDesc = ReflectGetOwnPropertyDescriptor(target, key);\n      } catch (error) {\n        throw pushErrorAcrossBoundary(error);\n      }\n\n      if (safeDesc) {\n        ReflectSetPrototypeOf(safeDesc, null);\n        const {\n          get: getter,\n          set: setter,\n          value\n        } = safeDesc;\n        foreignCallableDescriptorCallback(key, 'configurable' in safeDesc ? safeDesc.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL, 'enumerable' in safeDesc ? safeDesc.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL, 'writable' in safeDesc ? safeDesc.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL, 'value' in safeDesc ? // Inline getTransferableValue().\n        typeof value === 'object' && value !== null || typeof value === 'function' ? getTransferablePointer(value) : // Intentionally ignoring `document.all`.\n        // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n        typeof value === 'undefined' ? undefined : value : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL, 'get' in safeDesc ? // Inline getTransferableValue().\n        typeof getter === 'function' ? getTransferablePointer(getter) : getter : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL, 'set' in safeDesc ? // Inline getTransferableValue().\n        typeof setter === 'function' ? getTransferablePointer(setter) : setter : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL);\n        return undefined;\n      }\n\n      let proto;\n\n      try {\n        proto = ReflectGetPrototypeOf(target);\n      } catch (error) {\n        throw pushErrorAcrossBoundary(error);\n      } // Intentionally ignoring `document.all`.\n      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all\n      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n\n\n      if (typeof proto === 'undefined') {\n        return null;\n      }\n\n      return proto ? getTransferablePointer(proto) : proto;\n    });\n    let foreignCallablesHooked = false;\n    return (...hooks) => {\n      if (foreignCallablesHooked) {\n        return;\n      }\n\n      foreignCallablesHooked = true;\n      ({\n        // 0: globalThisPointer,\n        // 1: getSelectedTarget,\n        // 2: getTransferableValue,\n        // 3: callableGetPropertyValuePointer,\n        // 4: callableEvaluate,\n        // 5: callableLinkPointers,\n        6: foreignCallablePushErrorTarget,\n        7: foreignCallablePushTarget,\n        8: foreignCallableApply,\n        9: foreignCallableConstruct,\n        10: foreignCallableDefineProperty,\n        11: foreignCallableDeleteProperty,\n        12: foreignCallableGet,\n        13: foreignCallableGetOwnPropertyDescriptor,\n        14: foreignCallableGetPrototypeOf,\n        15: foreignCallableHas,\n        16: foreignCallableIsExtensible,\n        17: foreignCallableOwnKeys,\n        18: foreignCallablePreventExtensions,\n        19: foreignCallableSet,\n        20: foreignCallableSetPrototypeOf,\n        21: foreignCallableDebugInfo,\n        // 22: callableDefineProperties,\n        23: foreignCallableGetLazyPropertyDescriptorStateByTarget,\n        24: foreignCallableGetPropertyValue,\n        25: foreignCallableGetTargetIntegrityTraits,\n        26: foreignCallableGetToStringTagOfTarget,\n        27: foreignCallableInstallErrorPrepareStackTrace,\n        // 28: callableInstallLazyPropertyDescriptors,\n        29: foreignCallableIsTargetLive,\n        30: foreignCallableIsTargetRevoked,\n        31: foreignCallableSerializeTarget,\n        32: foreignCallableSetLazyPropertyDescriptorStateByTarget,\n        // 33: foreignCallableTrackAsFastTarget,\n        34: foreignCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors,\n        35: foreignCallableBatchGetPrototypeOfWhenHasNoOwnProperty,\n        36: foreignCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor\n      } = hooks);\n      const applyTrapForZeroOrMoreArgs = createApplyOrConstructTrapForZeroOrMoreArgs(1\n      /* ProxyHandlerTraps.Apply */\n      );\n      const applyTrapForOneOrMoreArgs = createApplyOrConstructTrapForOneOrMoreArgs(1\n      /* ProxyHandlerTraps.Apply */\n      );\n      const applyTrapForTwoOrMoreArgs = createApplyOrConstructTrapForTwoOrMoreArgs(1\n      /* ProxyHandlerTraps.Apply */\n      );\n      const applyTrapForThreeOrMoreArgs = createApplyOrConstructTrapForThreeOrMoreArgs(1\n      /* ProxyHandlerTraps.Apply */\n      );\n      const applyTrapForFourOrMoreArgs = createApplyOrConstructTrapForFourOrMoreArgs(1\n      /* ProxyHandlerTraps.Apply */\n      );\n      const applyTrapForFiveOrMoreArgs = createApplyOrConstructTrapForFiveOrMoreArgs(1\n      /* ProxyHandlerTraps.Apply */\n      );\n      const applyTrapForAnyNumberOfArgs = createApplyOrConstructTrapForAnyNumberOfArgs(1\n      /* ProxyHandlerTraps.Apply */\n      );\n      const constructTrapForZeroOrMoreArgs = createApplyOrConstructTrapForZeroOrMoreArgs(2\n      /* ProxyHandlerTraps.Construct */\n      );\n      const constructTrapForOneOrMoreArgs = createApplyOrConstructTrapForOneOrMoreArgs(2\n      /* ProxyHandlerTraps.Construct */\n      );\n      const constructTrapForTwoOrMoreArgs = createApplyOrConstructTrapForTwoOrMoreArgs(2\n      /* ProxyHandlerTraps.Construct */\n      );\n      const constructTrapForThreeOrMoreArgs = createApplyOrConstructTrapForThreeOrMoreArgs(2\n      /* ProxyHandlerTraps.Construct */\n      );\n      const constructTrapForFourOrMoreArgs = createApplyOrConstructTrapForFourOrMoreArgs(2\n      /* ProxyHandlerTraps.Construct */\n      );\n      const constructTrapForFiveOrMoreArgs = createApplyOrConstructTrapForFiveOrMoreArgs(2\n      /* ProxyHandlerTraps.Construct */\n      );\n      const constructTrapForAnyNumberOfArgs = createApplyOrConstructTrapForAnyNumberOfArgs(2\n      /* ProxyHandlerTraps.Construct */\n      );\n\n      if (MINIFICATION_SAFE_TRAP_PROPERTY_NAMES === undefined) {\n        // A minification safe way to get the 'apply' and 'construct'\n        // trap property names.\n        MINIFICATION_SAFE_TRAP_PROPERTY_NAMES = ObjectKeys({\n          applyTrapForZeroOrMoreArgs,\n          applyTrapForOneOrMoreArgs,\n          applyTrapForTwoOrMoreArgs,\n          applyTrapForThreeOrMoreArgs,\n          applyTrapForFourOrMoreArgs,\n          applyTrapForFiveOrMoreArgs,\n          applyTrapForAnyNumberOfArgs,\n          constructTrapForZeroOrMoreArgs,\n          constructTrapForOneOrMoreArgs,\n          constructTrapForTwoOrMoreArgs,\n          constructTrapForThreeOrMoreArgs,\n          constructTrapForFourOrMoreArgs,\n          constructTrapForFiveOrMoreArgs,\n          constructTrapForAnyNumberOfArgs\n        });\n      }\n\n      arityToApplyTrapNameRegistry[0] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES[0];\n      arityToApplyTrapNameRegistry[1] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES[1];\n      arityToApplyTrapNameRegistry[2] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES[2];\n      arityToApplyTrapNameRegistry[3] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES[3];\n      arityToApplyTrapNameRegistry[4] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES[4];\n      arityToApplyTrapNameRegistry[5] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES[5];\n      arityToApplyTrapNameRegistry.n = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES[6];\n      arityToConstructTrapNameRegistry[0] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES[7];\n      arityToConstructTrapNameRegistry[1] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES[8];\n      arityToConstructTrapNameRegistry[2] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES[9];\n      arityToConstructTrapNameRegistry[3] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES[10];\n      arityToConstructTrapNameRegistry[4] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES[11];\n      arityToConstructTrapNameRegistry[5] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES[12];\n      arityToConstructTrapNameRegistry.n = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES[13];\n      const {\n        prototype: BoundaryProxyHandlerProto\n      } = BoundaryProxyHandler;\n      BoundaryProxyHandlerProto[arityToApplyTrapNameRegistry[0]] = applyTrapForZeroOrMoreArgs;\n      BoundaryProxyHandlerProto[arityToApplyTrapNameRegistry[1]] = applyTrapForOneOrMoreArgs;\n      BoundaryProxyHandlerProto[arityToApplyTrapNameRegistry[2]] = applyTrapForTwoOrMoreArgs;\n      BoundaryProxyHandlerProto[arityToApplyTrapNameRegistry[3]] = applyTrapForThreeOrMoreArgs;\n      BoundaryProxyHandlerProto[arityToApplyTrapNameRegistry[4]] = applyTrapForFourOrMoreArgs;\n      BoundaryProxyHandlerProto[arityToApplyTrapNameRegistry[5]] = applyTrapForFiveOrMoreArgs;\n      BoundaryProxyHandlerProto[arityToApplyTrapNameRegistry.n] = applyTrapForAnyNumberOfArgs;\n      BoundaryProxyHandlerProto[arityToConstructTrapNameRegistry[0]] = constructTrapForZeroOrMoreArgs;\n      BoundaryProxyHandlerProto[arityToConstructTrapNameRegistry[1]] = constructTrapForOneOrMoreArgs;\n      BoundaryProxyHandlerProto[arityToConstructTrapNameRegistry[2]] = constructTrapForTwoOrMoreArgs;\n      BoundaryProxyHandlerProto[arityToConstructTrapNameRegistry[3]] = constructTrapForThreeOrMoreArgs;\n      BoundaryProxyHandlerProto[arityToConstructTrapNameRegistry[4]] = constructTrapForFourOrMoreArgs;\n      BoundaryProxyHandlerProto[arityToConstructTrapNameRegistry[5]] = constructTrapForFiveOrMoreArgs;\n      BoundaryProxyHandlerProto[arityToConstructTrapNameRegistry.n] = constructTrapForAnyNumberOfArgs;\n      ReflectSetPrototypeOf(BoundaryProxyHandlerProto, null); // Future optimization: Hoping proxies with frozen handlers can be faster.\n\n      ObjectFreeze(BoundaryProxyHandlerProto);\n    };\n  };\n  /* eslint-enable prefer-object-spread */\n}\n\nconst createMembraneMarshallSourceInStrictMode = `\n'use strict';\n(${createMembraneMarshall})`;\n\nfunction createBlueConnector(globalObject) {\n  if (typeof globalObject !== 'object' || globalObject === null) {\n    throw new TypeErrorCtor('Missing globalObject.');\n  }\n\n  return createMembraneMarshall(globalObject);\n}\n\nfunction createRedConnector(evaluator) {\n  if (typeof evaluator !== 'function') {\n    throw new TypeErrorCtor('Missing evaluator function.');\n  }\n\n  return evaluator(createMembraneMarshallSourceInStrictMode)();\n}\n\nconst LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL = Symbol.for('@@lockerNearMembraneUndefinedValue');\n\nclass VirtualEnvironment {\n  constructor(options) {\n    if (options === undefined) {\n      throw new ErrorCtor('Missing required VirtualEnvironment options.');\n    } // prettier-ignore\n\n\n    const {\n      blueConnector,\n      distortionCallback,\n      instrumentation,\n      liveTargetCallback,\n      redConnector // eslint-disable-next-line prefer-object-spread\n\n    } = ObjectAssign({\n      __proto__: null\n    }, options);\n    let blueHooks;\n    const blueConnect = blueConnector('blue', (...hooks) => {\n      blueHooks = hooks;\n    }, {\n      distortionCallback,\n      instrumentation,\n      liveTargetCallback\n    });\n    const {\n      0: blueGlobalThisPointer,\n      1: blueGetSelectedTarget,\n      2: blueGetTransferableValue,\n      3: blueCallableGetPropertyValuePointer,\n      // 4: blueCallableEvaluate,\n      5: blueCallableLinkPointers,\n      6: blueCallablePushErrorTarget,\n      7: blueCallablePushTarget,\n      8: blueCallableApply,\n      9: blueCallableConstruct,\n      10: blueCallableDefineProperty,\n      11: blueCallableDeleteProperty,\n      12: blueCallableGet,\n      13: blueCallableGetOwnPropertyDescriptor,\n      14: blueCallableGetPrototypeOf,\n      15: blueCallableHas,\n      16: blueCallableIsExtensible,\n      17: blueCallableOwnKeys,\n      18: blueCallablePreventExtensions,\n      19: blueCallableSet,\n      20: blueCallableSetPrototypeOf,\n      21: blueCallableDebugInfo,\n      // 22: blueCallableDefineProperties,\n      23: blueCallableGetLazyPropertyDescriptorStateByTarget,\n      24: blueCallableGetPropertyValue,\n      25: blueCallableGetTargetIntegrityTraits,\n      26: blueCallableGetToStringTagOfTarget,\n      27: blueCallableInstallErrorPrepareStackTrace,\n      // 28: blueCallableInstallLazyPropertyDescriptors,\n      29: blueCallableIsTargetLive,\n      30: blueCallableIsTargetRevoked,\n      31: blueCallableSerializeTarget,\n      32: blueCallableSetLazyPropertyDescriptorStateByTarget,\n      // 33: blueTrackAsFastTarget,\n      34: blueCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors,\n      35: blueCallableBatchGetPrototypeOfWhenHasNoOwnProperty,\n      36: blueCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor\n    } = blueHooks;\n    let redHooks;\n    const redConnect = redConnector('red', (...hooks) => {\n      redHooks = hooks;\n    });\n    const {\n      0: redGlobalThisPointer,\n      // 1: redGetSelectedTarget,\n      // 2: redGetTransferableValue,\n      3: redCallableGetPropertyValuePointer,\n      4: redCallableEvaluate,\n      5: redCallableLinkPointers,\n      6: redCallablePushErrorTarget,\n      7: redCallablePushTarget,\n      8: redCallableApply,\n      9: redCallableConstruct,\n      10: redCallableDefineProperty,\n      11: redCallableDeleteProperty,\n      12: redCallableGet,\n      13: redCallableGetOwnPropertyDescriptor,\n      14: redCallableGetPrototypeOf,\n      15: redCallableHas,\n      16: redCallableIsExtensible,\n      17: redCallableOwnKeys,\n      18: redCallablePreventExtensions,\n      19: redCallableSet,\n      20: redCallableSetPrototypeOf,\n      21: redCallableDebugInfo,\n      22: redCallableDefineProperties,\n      23: redCallableGetLazyPropertyDescriptorStateByTarget,\n      24: redCallableGetPropertyValue,\n      25: redCallableGetTargetIntegrityTraits,\n      26: redCallableGetToStringTagOfTarget,\n      27: redCallableInstallErrorPrepareStackTrace,\n      28: redCallableInstallLazyPropertyDescriptors,\n      29: redCallableIsTargetLive,\n      30: redCallableIsTargetRevoked,\n      31: redCallableSerializeTarget,\n      32: redCallableSetLazyPropertyDescriptorStateByTarget,\n      33: redCallableTrackAsFastTarget,\n      34: redCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors,\n      35: redCallableBatchGetPrototypeOfWhenHasNoOwnProperty,\n      36: redCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor\n    } = redHooks;\n    blueConnect(noop, // redGlobalThisPointer,\n    noop, // redGetSelectedTarget,\n    noop, // redGetTransferableValue,\n    noop, // redCallableGetPropertyValuePointer,\n    noop, // redCallableEvaluate,\n    noop, // redCallableLinkPointers,\n    redCallablePushErrorTarget, redCallablePushTarget, redCallableApply, redCallableConstruct, redCallableDefineProperty, redCallableDeleteProperty, redCallableGet, redCallableGetOwnPropertyDescriptor, redCallableGetPrototypeOf, redCallableHas, redCallableIsExtensible, redCallableOwnKeys, redCallablePreventExtensions, redCallableSet, redCallableSetPrototypeOf, redCallableDebugInfo, noop, // redCallableDefineProperties,\n    redCallableGetLazyPropertyDescriptorStateByTarget, redCallableGetPropertyValue, redCallableGetTargetIntegrityTraits, redCallableGetToStringTagOfTarget, redCallableInstallErrorPrepareStackTrace, noop, // redCallableInstallLazyPropertyDescriptors,\n    redCallableIsTargetLive, redCallableIsTargetRevoked, redCallableSerializeTarget, redCallableSetLazyPropertyDescriptorStateByTarget, redCallableTrackAsFastTarget, redCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors, redCallableBatchGetPrototypeOfWhenHasNoOwnProperty, redCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor);\n    redConnect(noop, // blueGlobalThisPointer,\n    noop, // blueGetSelectedTarget,\n    noop, // blueGetTransferableValue,\n    noop, // blueCallableGetPropertyValuePointer,\n    noop, // blueCallableEvaluate,\n    noop, // blueCallableLinkPointers,\n    blueCallablePushErrorTarget, blueCallablePushTarget, blueCallableApply, blueCallableConstruct, blueCallableDefineProperty, blueCallableDeleteProperty, blueCallableGet, blueCallableGetOwnPropertyDescriptor, blueCallableGetPrototypeOf, blueCallableHas, blueCallableIsExtensible, blueCallableOwnKeys, blueCallablePreventExtensions, blueCallableSet, blueCallableSetPrototypeOf, blueCallableDebugInfo, noop, // blueCallableDefineProperties,\n    blueCallableGetLazyPropertyDescriptorStateByTarget, blueCallableGetPropertyValue, blueCallableGetTargetIntegrityTraits, blueCallableGetToStringTagOfTarget, blueCallableInstallErrorPrepareStackTrace, noop, // blueCallableInstallLazyPropertyDescriptors,\n    blueCallableIsTargetLive, blueCallableIsTargetRevoked, blueCallableSerializeTarget, blueCallableSetLazyPropertyDescriptorStateByTarget, noop, // blueCallableTrackAsFastTarget,\n    blueCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors, blueCallableBatchGetPrototypeOfWhenHasNoOwnProperty, blueCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor);\n    this.blueGlobalThisPointer = blueGlobalThisPointer;\n    this.blueGetSelectedTarget = blueGetSelectedTarget;\n    this.blueGetTransferableValue = blueGetTransferableValue;\n    this.blueCallableGetPropertyValuePointer = blueCallableGetPropertyValuePointer;\n    this.blueCallableLinkPointers = blueCallableLinkPointers;\n    this.redGlobalThisPointer = redGlobalThisPointer;\n    this.redCallableGetPropertyValuePointer = redCallableGetPropertyValuePointer;\n    this.redCallableEvaluate = redCallableEvaluate;\n    this.redCallableLinkPointers = redCallableLinkPointers;\n    this.redCallableSetPrototypeOf = redCallableSetPrototypeOf;\n    this.redCallableDefineProperties = redCallableDefineProperties;\n    this.redCallableInstallLazyPropertyDescriptors = redCallableInstallLazyPropertyDescriptors;\n    this.redCallableTrackAsFastTarget = redCallableTrackAsFastTarget;\n  }\n\n  evaluate(sourceText) {\n    try {\n      const bluePointerOrPrimitiveValue = this.redCallableEvaluate(sourceText);\n\n      if (typeof bluePointerOrPrimitiveValue === 'function') {\n        bluePointerOrPrimitiveValue();\n        return this.blueGetSelectedTarget();\n      }\n\n      return bluePointerOrPrimitiveValue;\n    } catch (error) {\n      var _this$blueGetSelected;\n\n      throw (_this$blueGetSelected = this.blueGetSelectedTarget()) != null ? _this$blueGetSelected : error;\n    }\n  }\n\n  lazyRemapProperties(target, ownKeys, unforgeableGlobalThisKeys) {\n    if (typeof target === 'object' && target !== null || typeof target === 'function') {\n      const args = [this.blueGetTransferableValue(target)];\n      ReflectApply(ArrayProtoPush, args, ownKeys);\n\n      if (unforgeableGlobalThisKeys != null && unforgeableGlobalThisKeys.length) {\n        // Use `LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL` to delimit\n        // `ownKeys` and `unforgeableGlobalThisKeys`.\n        args[args.length] = LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL;\n        ReflectApply(ArrayProtoPush, args, unforgeableGlobalThisKeys);\n      }\n\n      ReflectApply(this.redCallableInstallLazyPropertyDescriptors, undefined, args);\n    }\n  }\n\n  link(...keys) {\n    let bluePointer = this.blueGlobalThisPointer;\n    let redPointer = this.redGlobalThisPointer;\n\n    for (let i = 0, {\n      length\n    } = keys; i < length; i += 1) {\n      const key = keys[i];\n      bluePointer = this.blueCallableGetPropertyValuePointer(bluePointer, key);\n      redPointer = this.redCallableGetPropertyValuePointer(redPointer, key);\n      this.redCallableLinkPointers(redPointer, bluePointer);\n      this.blueCallableLinkPointers(bluePointer, redPointer);\n    }\n  }\n\n  remapProperties(target, unsafeBlueDescMap) {\n    if (typeof target === 'object' && target !== null || typeof target === 'function') {\n      const targetPointer = this.blueGetTransferableValue(target);\n      const ownKeys = ReflectOwnKeys(unsafeBlueDescMap);\n      const {\n        length\n      } = ownKeys;\n      const args = new ArrayCtor(1 + length * 7);\n      args[0] = targetPointer;\n\n      for (let i = 0, j = 1; i < length; i += 1, j += 7) {\n        const ownKey = ownKeys[i];\n        const unsafeBlueDesc = unsafeBlueDescMap[ownKey]; // Avoid poisoning by only installing own properties from unsafeBlueDescMap.\n        // We don't use a toSafeDescriptor() style helper since that mutates\n        // the unsafeBlueDesc.\n        // eslint-disable-next-line prefer-object-spread\n\n        const safeBlueDesc = ObjectAssign({\n          __proto__: null\n        }, unsafeBlueDesc);\n        args[j] = ownKey;\n        args[j + 1] = 'configurable' in safeBlueDesc ? !!safeBlueDesc.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL;\n        args[j + 2] = 'enumerable' in safeBlueDesc ? !!safeBlueDesc.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL;\n        args[j + 3] = 'writable' in safeBlueDesc ? !!safeBlueDesc.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL;\n        args[j + 4] = 'value' in safeBlueDesc ? this.blueGetTransferableValue(safeBlueDesc.value) : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL;\n        args[j + 5] = 'get' in safeBlueDesc ? this.blueGetTransferableValue(safeBlueDesc.get) : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL;\n        args[j + 6] = 'set' in safeBlueDesc ? this.blueGetTransferableValue(safeBlueDesc.set) : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL;\n      }\n\n      ReflectApply(this.redCallableDefineProperties, this, args);\n    }\n  }\n\n  remapProto(target, proto) {\n    if (typeof target === 'object' && target !== null || typeof target === 'function') {\n      const foreignTargetPointer = this.blueGetTransferableValue(target);\n      const transferableProto = proto ? this.blueGetTransferableValue(proto) : proto;\n      this.redCallableSetPrototypeOf(foreignTargetPointer, transferableProto);\n    }\n  }\n\n  trackAsFastTarget(target) {\n    if (typeof target === 'object' && target !== null || typeof target === 'function') {\n      this.redCallableTrackAsFastTarget(this.blueGetTransferableValue(target));\n    }\n  }\n\n}\n/**\n * This list must be in sync with ecma-262, anything new added to the global object\n * should be considered, to decide whether or not they need remapping. The default\n * behavior, if missing form the following list, is to be remapped, which is safer.\n *\n * Note: remapped means the functionality is provided by the blue realm, rather than\n * the red one. This helps with the identity discontinuity issue, e.g.: all Set objects\n * have the same identity because it is always derived from the outer realm's Set.\n *\n * Note 1: We have identified 3 types of intrinsics\n * A: primitives driven intrinsics\n * B: syntax driven intrinsics (they usually have a imperative form as well)\n * C: imperative only intrinsics\n *\n * While A is not remapped, it is safe, and works fast that way, and C is remapped to\n * preserve the identity of all produced objects from the same realm, B is really\n * problematic, and requires a lot more work to guarantee that objects from both sides\n * can be considered equivalents (without identity discontinuity).\n */\n\n\nconst ESGlobalKeys = [// *** 19.1 Value Properties of the Global Object\n'globalThis', 'Infinity', 'NaN', 'undefined', // *** 19.2 Function Properties of the Global Object\n// 'eval', // dangerous & Reflective\n'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', // *** 19.3 Constructor Properties of the Global Object\n// 'AggregateError', // Reflective\n// 'Array', // Reflective\n// 'ArrayBuffer', // Remapped\n'BigInt', // 'BigInt64Array', // Remapped\n// 'BigUint64Array', // Remapped\n'Boolean', // 'DataView', // Remapped\n// 'Date', // Remapped\n// 'Error', // Reflective\n// 'EvalError', // Reflective\n'FinalizationRegistry', // 'Float32Array', // Remapped\n// 'Float64Array', // Remapped\n// 'Function', // dangerous & Reflective\n// 'Int8Array', // Remapped\n// 'Int16Array', // Remapped\n// 'Int32Array', // Remapped\n// 'Map', // Remapped\n'Number', // 'Object', // Reflective\n// Allow blue `Promise` constructor to overwrite the Red one so that promises\n// created by the `Promise` constructor or APIs like `fetch` will work.\n// 'Promise', // Remapped\n// 'Proxy', // Reflective\n// 'RangeError', // Reflective\n// 'ReferenceError', // Reflective\n'RegExp', // 'Set', // Remapped\n// 'SharedArrayBuffer', // Remapped\n'String', 'Symbol', // 'SyntaxError', // Reflective\n// 'TypeError', // Reflective\n// 'Uint8Array', // Remapped\n// 'Uint8ClampedArray', // Remapped\n// 'Uint16Array', // Remapped\n// 'Uint32Array', // Remapped\n// 'URIError', // Reflective\n// 'WeakMap', // Remapped\n// 'WeakSet', // Remapped\n'WeakRef', // *** 18.4 Other Properties of the Global Object\n// 'Atomics', // Remapped\n// 'JSON', // Remapped\n'Math', 'Reflect', // *** Annex B\n'escape', 'unescape' // *** ECMA-402\n// 'Intl',  // Remapped\n]; // These are foundational things that should never be wrapped but are equivalent\n// TODO: revisit this list.\n\nconst ReflectiveIntrinsicObjectNames = ['AggregateError', 'Array', 'Error', 'EvalError', 'Function', 'Object', 'Proxy', 'RangeError', 'ReferenceError', 'SyntaxError', 'TypeError', 'URIError', 'eval', 'globalThis'];\nconst ESGlobalsAndReflectiveIntrinsicObjectNames = toSafeArray([...ESGlobalKeys, ...ReflectiveIntrinsicObjectNames]);\n\nfunction assignFilteredGlobalDescriptorsFromPropertyDescriptorMap(descMap, source) {\n  const ownKeys = ReflectOwnKeys(source);\n\n  for (let i = 0, {\n    length\n  } = ownKeys; i < length; i += 1) {\n    const ownKey = ownKeys[i]; // Avoid overriding ECMAScript global names that correspond to\n    // global intrinsics. This guarantee that those entries will be\n    // ignored if present in the source property descriptor map.\n\n    if (!ESGlobalsAndReflectiveIntrinsicObjectNames.includes(ownKey)) {\n      const unsafeDesc = source[ownKey];\n\n      if (unsafeDesc) {\n        // Avoid poisoning by only installing own properties from\n        // unsafeDesc. We don't use a toSafeDescriptor() style helper\n        // since that mutates the unsafeBlueDesc.\n        // eslint-disable-next-line prefer-object-spread\n        descMap[ownKey] = ObjectAssign({\n          __proto__: null\n        }, unsafeDesc);\n      }\n    }\n  }\n\n  return descMap;\n}\n\nfunction getFilteredGlobalOwnKeys(source) {\n  const result = [];\n  let resultOffset = 0;\n  const ownKeys = ReflectOwnKeys(source);\n\n  for (let i = 0, {\n    length\n  } = ownKeys; i < length; i += 1) {\n    const ownKey = ownKeys[i]; // Avoid overriding ECMAScript global names that correspond to global\n    // intrinsics. This guarantees that those entries will be ignored if\n    // present in the source object.\n\n    if (!ESGlobalsAndReflectiveIntrinsicObjectNames.includes(ownKey)) {\n      result[resultOffset++] = ownKey;\n    }\n  }\n\n  return result;\n}\n\nfunction linkIntrinsics(env, globalObject) {\n  // Remap intrinsics that are realm agnostic.\n  for (let i = 0, {\n    length\n  } = ReflectiveIntrinsicObjectNames; i < length; i += 1) {\n    const globalName = ReflectiveIntrinsicObjectNames[i];\n    const reflectiveValue = globalObject[globalName];\n\n    if (reflectiveValue) {\n      // Proxy.prototype is undefined.\n      if (reflectiveValue.prototype) {\n        env.link(globalName, 'prototype');\n      } else {\n        env.link(globalName);\n      }\n    }\n  }\n}\n\nexport { VirtualEnvironment, assignFilteredGlobalDescriptorsFromPropertyDescriptorMap, createBlueConnector, createMembraneMarshall, createRedConnector, getFilteredGlobalOwnKeys, linkIntrinsics };\n"],"names":[],"sourceRoot":"","x_google_ignoreList":[0]}