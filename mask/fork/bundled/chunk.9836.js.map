{"version":3,"file":"bundled/chunk.9836.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAO;AACP,gDAAgD,iBAAiB;AACjE;AACA;AACO;AACP,mEAAmE,gBAAgB;AACnF;AACA;AACA;AACA;AACA;AACA,KAAK,SAAS,8BAA8B;AAC5C;;;ACZO;;;ACAiD;AACZ;AACL;AAChC;AACP;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA,0BAA0B,OAAO;AACjC;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA,+BAA+B,YAAY,KAAK,sBAAU;AAC1D;;;AC5BO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACdwD;AACjB;AACA;AACJ;AAC5B;AACP,SAAS,WAAW,CAAC,YAAY,mBAAmB,YAAY;AAChE;AACA;AACA,iCAAiC,YAAY;AAC7C,oBAAoB,sBAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW,0BAA0B,QAAQ;AAC3D;AACA;AACA;AACA,aAAa,WAAW,wBAAwB,QAAQ;AACxD;AACA;AACA;AACA;AACA;;;ACzBuC;AACL;AAC3B;AACP,0BAA0B,UAAU;AACpC;AACA;AACA,0EAA0E,OAAO;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACdmC;AACA;AACI;AACK;;;ACHC;AACP;;;;;;;;;;;ACDG;AAEQ;AAE1C,eAAeE,KAAKC,WAAgC;IACvD,MAAMC,WAAW,MAAMC,MAAMJ,iCAAeA,EAAE;QAC1CK,QAAQ;QACRC,MAAMC,WAAWC,IAAI,CAAC,MAAMC,YAAYP;IAC5C;IACAA,YAAYQ,YAAY,CAAC,MAAMP,SAASQ,IAAI;AAChD;AAEA,eAAeF,YAAYP,WAAgC;IACvD,MAAMU,UAAU,IAAIC;IACpB,MAAMX,YAAYY,aAAa,CAACZ,YAAYa,IAAI;IAChD,MAAMC,MAAM,CAACC,MAAuCC,OAAiBD,KAAKD,GAAG,CAACE,MAAM;YAAEC,QAAQ;YAAMC,QAAQ;QAAM;IAClH,OAAOrB,qCAAMA,CAAC;QACVa,QAAQb,MAAM,CAACG,YAAYmB,MAAM,CAACC,QAAQ;QAC1CN,IAAId,aAAa;QACjBc,IAAId,aAAa;QACjBU,QAAQb,MAAM,CAACG,YAAYqB,QAAQ;QACnCX,QAAQb,MAAM,CAACG,YAAYsB,MAAM;QACjCR,IAAId,aAAa;QACjBA,YAAYuB,IAAI,CAACC,GAAG,CAAC,CAACC,MAAQ;gBAACX,IAAIW,KAAK;gBAASX,IAAIW,KAAK;aAAS;QACnEf,QAAQb,MAAM,CAACG,YAAY0B,SAAS;QACpCZ,IAAId,aAAa;KACpB;AACL;;;;;;;AC3BmC;AACF;AAC0B;AAClB;AAGkB;AACW;AAC5B;AACF;AAES;AAEjD,MAAMqC;IACFC,SAA0B;IAC1B,OAAOC,QAAgE,CAAC,EAAC;IAEzEC,OAAO;QACH,IAAI,IAAI,CAACF,QAAQ,EAAE;QACnB,oBAAoB;QACpB,IAAI,CAACA,QAAQ,GAAG,CAACV,0BAAe,IAAIA,eAAM,EAAGY,IAAI,CAAC;YAC9CE,MAAM;YACNC,MAAM;YACNC,UAAU;QACd;IACJ;IAEA,MAAMC,eAAeC,OAA0B,EAAE;QAC7C,IAAI,CAACN,IAAI;QACT,MAAMO,aAAaD,QAAQE,GAAG,GAAGlB,0BAAUA,CAACgB,QAAQE,GAAG,IAAIC;QAC3D,MAAMC,UAAU,MAAMrB,MAAiB,CAACkB,YAAY;YAChDI,OAAOL,QAAQK,KAAK;YACpBC,MAAMzB,0BAAOA,CAACmB,QAAQO,IAAI,IAAI,6BAA6BP,QAAQO,IAAI;YACvEC,UAAU;QACd;QACA,MAAMtD,cAAc,MAAM,IAAI,CAACuD,WAAW,CAACL,SAAS;QACpDb,aAAaE,KAAK,CAACvC,YAAYwD,EAAE,CAAC,GAAGxD;QACrC,MAAM,IAAI,CAACsC,QAAQ,CAACmB,YAAY,CAACC,IAAI,CAAC1D;QACtC,OAAOA,YAAYwD,EAAE;IACzB;IAEA,MAAMG,kBAAkBL,QAA6B,EAAE;QACnD,IAAI,CAACd,IAAI;QACT,IAAIoB,aAAa;QACjB,IAAIN,SAASO,MAAM,EAAE;YACjBD,aAAa3B,8BAAYA;QAC7B;QACA,MAAM6B,kBAAkBC,KAAKC,SAAS,CAAC;YACnChD,MAAMsC,SAAStC,IAAI;YACnBiD,MAAMX,SAASW,IAAI;YACnBC,UAAUhC,0BAAQA,CAACN,OAAO;YAC1BuC,MAAM,CAAC,EAAEP,WAAW,CAAC,EAAEN,SAASc,IAAI,CAAC,CAAC;YACtCC,QAAQ,MAAMjC,qCAAiBA,CAACkB,SAASN,GAAG;YAC5CsB,WAAW,IAAIC,OAAOC,WAAW;QACrC;QACA,MAAMC,OAAO,MAAM1C,8BAASA,CAACC,8BAAYA;QACzC,MAAM0C,WAAWD,KAAKE,OAAO,CAAC,gBAAgBb;QAC9C,MAAMjD,OAAOiB,0BAAUA,CAAC4C;QACxB,MAAM1E,cAAc,MAAM,IAAI,CAACuD,WAAW,CAAC1C,MAAM;QACjD,MAAM,IAAI,CAACyB,QAAQ,CAACmB,YAAY,CAACC,IAAI,CAAC1D;QACtC,OAAOA,YAAYwD,EAAE;IACzB;IAEA,OAAOoB,OAAOpB,EAA6B,EAAE;QACzC,IAAI,CAAChB,IAAI;QACT,WAAW,MAAMqC,YAAY,IAAI,CAACvC,QAAQ,CAACmB,YAAY,CAACmB,MAAM,CAACvC,aAAaE,KAAK,CAACiB,GAAG,EAAE,IAAInD,cAAe;YACtG,MAAMwE,SAASC,WAAW;QAC9B;IACJ;IAEA,MAAMvB,YAAY1C,IAAgB,EAAEwC,IAAY,EAAE;QAC9C,IAAI,CAACb,IAAI;QACT,MAAMxC,cAAc,MAAM,IAAI,CAACsC,QAAQ,CAACyC,iBAAiB,CAAC;YAAElE;QAAK,GAAGsB,6BAAKA;QACzEnC,YAAYgF,MAAM,CAAC,gBAAgB3B;QACnC,MAAMtD,IAAIA,CAACC;QACX,OAAOA;IACX;AACJ;AAEA,8CAAe,IAAIqC,cAAcA,EAAA;;;;;;;AC/EN;AACQ;AACwB;AAClB;AACqB;AACN;AAEP;AAEjD,SAAS8C;IACL,OAAOD,sBAAMA,CAAC;QACVxC,MAAM;QACNC,MAAM;QACNC,UAAU;QACVwC,SAAS;YACLC,eAAe;QACnB;IACJ;AACJ;AAEA,MAAMC;IACF,OAAOC,eAAe,OAAM;IAC5BC,OAAuB;IAEvBhD,OAAO;QACH,IAAI,IAAI,CAACgD,MAAM,EAAE;QACjB,IAAI,CAACA,MAAM,GAAGL;IAClB;IAEA,MAAMtC,eAAeC,OAA0B,EAAE;QAC7C,MAAMC,aAAaD,QAAQE,GAAG,GAAGlB,0BAAUA,CAACgB,QAAQE,GAAG,IAAIC;QAC3D,MAAMC,UAAU,MAAMrB,MAAiB,CAACkB,YAAY;YAChDI,OAAOL,QAAQK,KAAK;YACpBC,MAAMzB,0BAAOA,CAACmB,QAAQO,IAAI,IAAI,6BAA6BP,QAAQO,IAAI;YACvEC,UAAU;QACd;QACA,OAAO,IAAI,CAACC,WAAW,CAACL,SAAS;IACrC;IAEA,8CAA8C;IAC9C,OAAO0B,OAAOpB,EAAU,EAAE;QACtB,MAAM;IACV;IAEA,MAAMG,kBAAkBL,QAA6B,EAAE;QACnD,MAAMM,aAAa;QACnB,MAAME,kBAAkBC,KAAKC,SAAS,CAAC;YACnChD,MAAMsC,SAAStC,IAAI;YACnBiD,MAAMX,SAASW,IAAI;YACnBC,UAAUhC,0BAAQA,CAACuD,IAAI;YACvBtB,MAAMc,wBAAMA,CAACrB,YAAY,UAAU;gBAAEQ,MAAMd,SAASc,IAAI;YAAC;YACzDC,QAAQ,MAAMjC,qCAAiBA,CAACkB,SAASN,GAAG;YAC5CsB,WAAW,IAAIC,OAAOC,WAAW;QACrC;QACA,MAAMvE,WAAW,MAAMC,MAAM8B,8BAAYA;QACzC,MAAMyC,OAAO,MAAMxE,SAASwE,IAAI;QAChC,MAAMC,WAAWD,KACZE,OAAO,CAAC,WAAWW,UAAUC,YAAY,EACzCZ,OAAO,CAAC,gBAAgB,CAAC,KAAK,EAAEW,UAAUC,YAAY,CAAC,CAAC,EACxDZ,OAAO,CAAC,gBAAgBb;QAC7B,MAAMjD,OAAOiB,0BAAUA,CAAC4C;QACxB,OAAO,IAAI,CAACnB,WAAW,CAAC1C,MAAM;IAClC;IAEA,MAAM0C,YAAY1C,IAAgB,EAAEwC,IAAY,EAAE;QAC9C,IAAI,CAACb,IAAI;QACT,MAAMkD,OAAO,MAAM,IAAI,CAACF,MAAM,CAACG,GAAG,CAAC9E;QACnC,OAAO6E,KAAKE,GAAG,CAACxE,QAAQ;IAC5B;AACJ;AAEA,2CAAe,IAAIkE,WAAWA,EAAA;;;;;ACvE8E;AAC1E;AACN;AAE5B,MAAMS,eAAgD;IAClD,CAAC7D,qBAAQA,CAACN,OAAO,CAAC,EAAEiE,OAAOA;IAC3B,CAAC3D,qBAAQA,CAACuD,IAAI,CAAC,EAAEK,IAAIA;AACzB;AAEO,eAAejD,eAAeqB,QAAkB,EAAEpB,OAA0B;IAC/E,OAAOiD,YAAY,CAAC7B,SAAS,EAAErB,eAAeC;AAClD;AAEO,gBAAgB8B,OAAOV,QAAkB,EAAEV,EAAU;IACxD,WAAW,MAAMwC,WAAWD,YAAY,CAAC7B,SAAS,CAACU,MAAM,CAACpB,IAAK;QAC3D,MAAMwC;IACV;AACJ;AAEO,eAAerC,kBAAkBO,QAAkB,EAAEZ,QAA6B;IACrF,OAAOyC,YAAY,CAAC7B,SAAS,EAAEP,kBAAkBL;AACrD;AAEgF;;;;;;;;;;;;;;ACvB9C;AAC8C;AAEzE,eAAevB,UAClBuE,KAAwB,EACxB9D,IAAkB,EAClBM,OAA6B;IAE7B,MAAM7C,WAAW,MAAMC,yDAAKA,CAACoG,OAAO9D,MAAM6D,6EAAeA,CAACvD;IAC1D,IAAI,CAAC7C,SAASsG,EAAE,EAAE,MAAM,IAAIC,MAAM;IAClC,OAAOvG,SAASwE,IAAI;AACxB;;;;;;;;ACXA,QAAQ,kBAAkB;;AAE1B;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wBAAwB;;;;;;;;;;;;;ACjCxB,iEAAe,EAAE,EAAC;;;;;;;;;ACAN;;AAEZ;AACA;AACA;AACA;AACA,yCAAyC,qBAAqB;AAC9D;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa;AACb;AACA,gEAAgE;AAChE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;ACpCa;;AAEb;AACA,eAAe,sBAAsB;AACrC,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,mBAAmB;AAC9B,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;ACpEY;AACZ,mBAAmB,mBAAO,CAAC,KAAa;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAA6B;AAC7C;AACA;AACA,wFAAwF,YAAoB;AAC5G;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC5BY;;AAEZ;AACA,aAAa,oBAAoB;AACjC,aAAa,oBAAoB;AACjC,aAAa,qBAAqB;AAClC;;AAEA;AACA,2CAAwC;;;;;;;;;ACT5B;;AAEZ,aAAa,mBAAO,CAAC,KAAS;;AAE9B;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,gCAAgC;AAC3C,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,gCAAgC;AAC3C,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;AC9BA;AACY;;AAEZ,QAAQ,0BAA0B,EAAE,mBAAO,CAAC,KAAc;AAC1D,QAAQ,0BAA0B,EAAE,mBAAO,CAAC,KAAc;AAC1D,cAAc,iCAA6B,GAAG,uBAAuB;AACrE,QAAQ,uBAAuB,EAAE,mBAAO,CAAC,KAAS;AAClD,kBAAkB,mBAAO,CAAC,KAAY;AACtC,gCAAgC,mBAAO,CAAC,KAA8B;AACtE,QAAQ,yBAAyB,EAAE,mBAAO,CAAC,IAAO;AAClD,YAAY,mBAAO,CAAC,KAAQ;;AAE5B;AACA,aAAa,2BAA2B;AACxC,aAAa,+BAA+B;AAC5C,aAAa,oCAAoC;AACjD;;AAEA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,oBAAoB;AAC/B,WAAW,iBAAiB;AAC5B,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,eAAe,uBAAuB;AACtC;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA,2BAA2B;AAC3B,eAAe,aAAa;AAC5B;AACA;;AAEA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B,aAAa,aAAa;AAC1B,eAAe;AACf;AACA,qCAAqC;AACrC,eAAe,aAAa;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,kBAAkB;AAC/B,aAAa,aAAa;AAC1B;AACA,8BAA8B;AAC9B,kCAAkC,4BAA4B;AAC9D;;AAEA;AACA,aAAa,kBAAkB;AAC/B,aAAa,aAAa;AAC1B;AACA,6BAA6B;AAC7B,kCAAkC,2BAA2B;AAC7D;;AAEA;AACA,aAAa,kBAAkB;AAC/B,aAAa,aAAa;AAC1B;AACA,6BAA6B;AAC7B,kCAAkC,2BAA2B;AAC7D;;AAEA;AACA,aAAa,kBAAkB;AAC/B,aAAa,aAAa;AAC1B;AACA,gCAAgC;AAChC,kCAAkC,8BAA8B;AAChE;;AAEA;AACA,aAAa,kBAAkB;AAC/B,aAAa,aAAa;AAC1B;AACA,iCAAiC;AACjC,kCAAkC,+BAA+B;AACjE;AACA;;AAEA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,cAAc;AACjD;;AAEA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,oDAAoD;AAC/D,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,mBAAmB;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,SAAS;AACvB,cAAc,KAAK;AACnB,WAAW,6BAA6B;AACxC,aAAa;AACb;AACA;AACA;AACA;AACA,oBAAoB,KAAK;AACzB;;AAEA;AACA;AACA;AACA,cAAc,SAAS;AACvB,cAAc,KAAK;AACnB,WAAW,8BAA8B;AACzC,aAAa;AACb;AACA;AACA,oCAAoC,KAAK;AACzC;;AAEA;AACA,WAAW,KAAK;AAChB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,kBAAkB;AAC7B,WAAW,aAAa;AACxB;AACA;;AAEA;AACA,WAAW,kBAAkB;AAC7B,WAAW,aAAa;AACxB;AACA;;AAEA;AACA,WAAW,kBAAkB;AAC7B,WAAW,aAAa;AACxB;AACA;;AAEA;AACA,WAAW,kBAAkB;AAC7B,WAAW,aAAa;AACxB;AACA;;AAEA;AACA,WAAW,kBAAkB;AAC7B,WAAW,aAAa;AACxB;AACA;;AAEA;;;;;;;;;ACtXY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;AC5BL;;AAEZ,QAAQ,2BAA2B,EAAE,mBAAO,CAAC,KAAS;AACtD;AACA,QAAQ,6CAA6C,EAAE,mBAAO,CAAC,KAAU;;AAEzE;AACA,aAAa,iCAAiC;AAC9C,aAAa,+BAA+B;AAC5C;;AAEA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,cAAc;AACzB,aAAa;AACb;AACA,4CAA4C;AAC5C;AACA;;AAEA,UAAU,mBAAmB;;AAE7B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA,WAAW,kBAAkB;AAC7B,WAAW,cAAc;AACzB;AACA,oCAAoC;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB,aAAa,cAAc;AAC3B;AACA;AACA;AACA,yCAAyC,YAAY;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;AC9IA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;ACpBa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;ACTY;;AAEZ;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,KAAW;AACvB,iBAAiB,mBAAO,CAAC,KAAgB;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AChBY;;AAEZ,QAAQ,+BAA+B,EAAE,mBAAO,CAAC,KAAO;;AAExD;AACA,WAAW,oBAAoB;AAC/B,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;AACA,oCAAoC,kBAAkB;AACtD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA,+BAA+B;AAC/B;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;;AC/BY;;AAEZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,KAAK;AAClB;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,WAAW,kCAAkC;AAC7C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,aAAa,GAAG,aAAa;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,SAAS,EAAE,iBAAiB;AAC1C;AACA,SAAS,EAAE,KAAK,EAAE,KAAK;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC9LY;;AAEZ;AACA;AACA;AACA;AACA,WAAW,8BAA8B;AACzC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;AClBa;AACb,uBAAuB,mBAAO,CAAC,KAAc;;AAE7C,OAAO,gBAAgB;AACvB,OAAO,sBAAsB;AAC7B;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qFAAqF;AACrF,eAAe;;AAEf;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0BAA0B,UAAU;AACpC;;AAEA;AACA;;;;;;;;AC1KA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,QAAQ;AACnB,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;ACjKY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,aAAa,uCAA6B;AAC1C,aAAa,oCAA6B;AAC1C,aAAa,oCAA6B;AAC1C,cAAc,qCAA8B;AAC5C;AACA;;;;;;;;;AChBa;;AAEb;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,sCAAsC;AACtC,YAAY,qBAAM,oBAAoB,OAAO,qBAAM;AACnD;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,CAAC,kBAAe;AAChB;;AAEA,eAAe;AACf,eAAe;AACf,gBAAgB;;;;;;;;ACxBhB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;;AAEA;AACA;;;;;;;;ACtBA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;;AAEA;AACA;;;;;;;;AC5BA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7BA;AACA,YAAY,mBAAO,CAAC,KAAa;AACjC,YAAY,mBAAO,CAAC,KAAa;AACjC,oBAAoB,mBAAO,CAAC,KAAa;AACzC;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxBA;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;;AAEsC;AACtC,iEAAe,sCAAY,EAAC;;;;;;;;;;;;ACP5B,mEAAmE,EAAE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,KAAK;;;;;;;;;;;;;;;;;;;;ACtEpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;;ACvMqC;AACrC;AACA;AACA;AACA,mBAAmB,MAAM;AACzB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;;ACzB2D;AAC3D;AACO;AACP,mBAAmB,SAAS;AAC5B;AACA;AACO;AACP,mBAAmB,SAAS;AAC5B;AACA;AACO;AACP,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1B8B;AACQ;;AAEtC;AACA;;AAEA;AACA;AACA,aAAa,qDAAqD;AAClE;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,cAAc,2DAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kDAAW,CAAC,iDAAU;AAC9B,QAAQ,kDAAW,CAAC,iDAAU;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA;AACA,kDAAkD;AAClD;AACA,SAAS,2DAAG;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8BAA8B;AAC3C;AACA;AACA;;AAEO;AACA;;AAEP;AACA;AACA,WAAW,GAAG;AACd,aAAa;AACb;AACO,yBAAyB,mDAAY;;AAE5C;AACA;AACA,WAAW,aAAa;AACxB,aAAa;AACb;AACO,yBAAyB,mDAAY;;;;;;;;;;;;;;;;;;;;;;;ACpH5C;AACkC;AACgB;AACf;AACI;;AAEvC;AACA;AACA,aAAa,qDAAqD;AAClE;AACA;AACA;AACA,aAAa,oCAAoC;AACjD;AACA;AACA,aAAa,2CAA2C;AACxD;;AAEA;AACA;AACA;AACA,sDAAsD,iBAAiB;AACvE;AACA;AACA,WAAW,KAAK;AAChB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,cAAc,uDAAG;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,kDAAK,CAAC,iDAAI;AAClB,QAAQ,kDAAK,CAAC,iDAAI;AAClB,QAAQ,kDAAK,CAAC,iDAAI;AAClB,QAAQ,kDAAK,CAAC,iDAAI;AAClB;AACA;;AAEA;AACA;AACA,gCAAgC,KAAK,4BAA4B;AACjE;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA,sBAAsB,6DAAM;AAC5B;AACA,QAAQ,kDAAK,CAAC,iDAAI;AAClB,QAAQ,kDAAK,CAAC,iDAAI;AAClB,QAAQ,kDAAK,CAAC,iDAAI;AAClB,QAAQ,kDAAK,CAAC,iDAAI;AAClB,QAAQ,kDAAK,CAAC,iDAAI;AAClB,QAAQ,kDAAK,CAAC,iDAAI;AAClB,QAAQ,kDAAK,CAAC,iDAAI;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA,+BAA+B,2DAAmB;AAClD;AACA,aAAa,YAAY;AACzB,aAAa,QAAQ;AACrB;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA,uBAAuB,iDAAI;AAC3B;AACA,4BAA4B,iDAAI;AAChC;AACA,gCAAgC,iDAAI,WAAW;AAC/C;AACA,kCAAkC,iDAAI;AACtC;AACA;AACA;AACA,qBAAqB,kDAAK,CAAC,iDAAI;AAC/B;AACA,gCAAgC,iDAAI;AACpC;AACA,qCAAqC,iDAAI;AACzC;AACA,yCAAyC,iDAAI,WAAW;AACxD,8BAA8B,OAAO;AACrC;AACA,wCAAwC,iDAAI;AAC5C;AACA;AACA;AACA,4BAA4B,6DAAM,YAAY,sBAAsB;AACpE,yBAAyB,kDAAK,CAAC,iDAAI;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8BAA8B;AAC3C;AACA;;AAEA;AACA;AACA,yBAAyB,uDAAG;;AAErB;AACA;;AAEP;AACA;AACA,WAAW,GAAG;AACd,aAAa;AACb;AACO,yBAAyB,wDAAgB;;AAEhD;AACA;AACA,WAAW,aAAa;AACxB,aAAa;AACb;AACO;AACP;AACA,iDAAiD,sDAAsD;AACvG,SAAS,wDAAgB;AACzB;;AAEA;AACA;AACA,WAAW,GAAG;AACd,aAAa;AACb;AACO;AACuB;AAC9B;;AAEA;AACA;AACA,WAAW,aAAa;AACxB,aAAa;AACb;AACO;AACP;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/OA;;AAEA;AACA,aAAa,iCAAiC;AAC9C;;AAEA;AACA,aAAa,iCAAiC;AAC9C;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;;AAEA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA,aAAa,WAAW;AACxB;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,8DAA8D,SAAS;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,8DAA8D,SAAS;AACvE;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,8DAA8D,SAAS;AACvE;;AAEA;AACA,MAAM;AACN,yFAAyF,SAAS;AAClG;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACO;AACP;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA,aAAa,iBAAiB;AAC9B;;AAEA;AACA;AACA,KAAK;;AAEL;AACA,8EAA8E,SAAS;AACvF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN,6BAA6B;AAC7B;AACA,QAAQ;AACR;AACA;AACA;AACA,OAAO;AACP;AACA,MAAM;AACN,sFAAsF,SAAS;AAC/F;AACA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;;AChMA;AACA;AACA;;AAEA;AACA,aAAa,iCAAiC;AAC9C;;AAEA;AACA,aAAa,iCAAiC;AAC9C;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,WAAW;AACtB,aAAa;AACb;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,YAAY;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,WAAW;AACtB,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrNsC;;AAEtC;AACA,aAAa,8BAA8B;AAC3C,aAAa,8BAA8B;AAC3C;;AAEA;AACA;;AAEA,MAAM,gBAAW;;AAEjB;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,gBAAW;AACnC,wBAAwB,gBAAW;;AAEnC;AACA;;AAEA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,KAAK;AAChB,WAAW,UAAU;AACrB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa;AACb;AACA;AACA;AACA,iBAAiB,mBAAG;AACpB;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,cAAc,mBAAG;AACjB;AACA;AACA;AACA,gBAAgB,mBAAG;AACnB,UAAU;AACV,gBAAgB,mBAAG;AACnB;AACA;AACA,MAAM,kBAAkB,KAAK;AAC7B,kDAAkD,UAAU;AAC5D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,KAAK;AAChB,aAAa;AACb;AACO;AACP;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA,aAAa,QAAQ;AACrB;;AAEA;AACA;AACA,iBAAiB,gBAAW;AAC5B,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,UAAU;AACrB,aAAa;AACb;AACO;AACP,mBAAmB,0BAA0B;AAC7C;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,KAAK;AAChB,aAAa;AACb;AACO;AACP,kBAAkB,oCAAoC;AACtD;;;ACxOsC;AACK;AACA;AAC0B;;AAErE;AACA;AACA,aAAa,qDAAqD;AAClE;;AAEA;AACA,aAAa,8BAA8B;AAC3C,aAAa,8BAA8B;AAC3C;;AAEO,MAAM,QAAI;AACV;;AAEP;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP,EAAE,QAAQ;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,SAAS,UAAU;AACnB;;AAEA;AACA,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACO;AACP,cAAc,UAAU;;AAExB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,mBAAG;AACvB,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEoD;;;;;;;;;;;;;;;;;ACnF1B;AAC4B;AACH;AACA;AACnD;AACA,6CAAgB;AAChB,qCAAqC,gEAAS;AAC9C;AACA;AACA,6CAAgB;AAChB,qCAAqC,6DAAM;AAC3C;AACA;AACA,6CAAgB;AAChB,qCAAqC,6DAAM;AAC3C;AACA;AACA,6CAAgB;AAChB;AACA;AACA;AACA,6CAAgB;AAChB;AACA;AACA;AACA,6CAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,wCAAwC,KAAK;AAC7C;AACA,QAAQ,0CAAa,IAAI,KAAK,YAAY,wCAAW;AACrD,gBAAgB,kCAAK,IAAI,KAAK;AAC9B;AACA,yBAAyB,kCAAK;AAC9B,eAAe,kCAAK,IAAI,KAAK;AAC7B;AACA,KAAK;AACL;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3DO;AACA;AACP;AACA;;;ACHuC;AACK;AACU;AACD;AACG;AACQ;AACd;AACI;AACH;AACnD;AACA;AACA,YAAY,oBAAK;AACjB;AACA;AACA,yCAAyC,oBAAK;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,yBAAyB,gBAAgB;AACzC;AACA,SAAS,MAAM;AACf;AACA;AACA;AACA;AACA,0BAA0B,gBAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA,mBAAmB,wBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gBAAgB;AACzC;AACA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0BAA0B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,0BAA0B,qBAAa,CAAC,gBAAS,YAAY,IAAI;AACjE;AACA,2CAA2C,WAAW;AACtD;AACA;AACA,6CAA6C,WAAW;AACxD;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACO;AACP;AACA,0BAA0B,qBAAa;AACvC,+BAA+B,wBAAQ;AACvC;AACA,+CAA+C,WAAW;AAC1D;AACA;AACA,iDAAiD,WAAW;AAC5D;AACA;AACA,+BAA+B,mBAAM;AACrC,uCAAuC,WAAW;AAClD;AACA;AACA;AACA,6BAA6B,eAAG;AAChC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,2BAA2B,mBAAM;AACjC,mCAAmC,0BAA0B;AAC7D;AACA,gCAAgC,wBAAQ;AACxC;AACA,2CAA2C,0BAA0B;AACrE;AACA;AACA,6CAA6C,0BAA0B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,uCAAuC,gEAAgE;AACvG;AACA;AACA,yCAAyC,gEAAgE;AACzG;AACA,+BAA+B,kEAAkE;AACjG;;;;;;;;;;;;;AC1MoD;AACpD;AACA;AACA;AACA;AACA,wBAAwB,IAAI,GAAG,KAAK;AACpC;AACA;AACA,2BAA2B,KAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS,KAAK,IAAI,EAAE,aAAa;AAC/C;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA,aAAa,IAAI,GAAG,QAAQ;AAC5B;AACA,oCAAoC,IAAI,GAAG,QAAQ;AACnD;AACA;AACA;AACA,+BAA+B,IAAI,QAAQ,QAAQ;AACnD,8BAA8B,IAAI,OAAO,QAAQ;AACjD,2BAA2B,IAAI;AAC/B,6BAA6B,IAAI;AACjC,uBAAuB,IAAI;AAC3B,yBAAyB,IAAI;AAC7B,oCAAoC,IAAI;AACxC,iCAAiC,IAAI;AACrC,mCAAmC,IAAI;AACvC;AACO;AACP,mBAAmB,wEAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oDAAoD,cAAc;AAClE;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;ACvDA;AACqE;AACtD;AACf;AACA,eAAe,iFAAyB;AACxC;AACA;AACA;AACA,WAAW,iFAAyB;AACpC;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA,yCAAyC,qBAAqB;AAC9D;AACA;AACe,8DAA8D;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACxBsD;AAC/C;AACP,WAAW,gBAAS;AACpB;AACO;AACP,WAAW,gBAAS,YAAY,EAAE;AAClC;;;;;ACNwD;AACjB;AAChC;AACP;AACA;AACA;AACA,uBAAuB,uCAAuC;AAC9D,cAAc,eAAG,QAAQ,aAAa;AACtC;AACA;AACA;AACA;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA,4BAA4B,aAAa;AACzC;AACA;AACO;AACP,oBAAoB,aAAa;AACjC;AACA,QAAQ,eAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA,yBAAyB,WAAW;AACpC;AACA;AACO;AACP;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA,mBAAmB,eAAG;AACtB;AACA;;;AClDwD;AACjD,SAAS,oBAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA,+BAA+B,aAAa;AAC5C;AACA;AACA;AACA;AACO,SAAS,iBAAM;AACtB;AACA,oBAAoB,aAAa;AACjC,mBAAmB,aAAa;AAChC,YAAY,aAAa;AACzB,aAAa,aAAa;AAC1B;AACA;AACA,qBAAqB,aAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,WAAW;AAC7C;AACA;AACA;AACA;AACO,SAAS,iBAAM;AACtB;AACA,oBAAoB,WAAW;AAC/B,mBAAmB,WAAW;AAC9B,YAAY,WAAW;AACvB,aAAa,WAAW;AACxB;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;;;;;AC1DwC;AACM;AACP;AAChC,MAAM,QAAI;AACV;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,mBAAmB,SAAiB;AACpC;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,UAAM;AACtB;AACA;AACA;AACA;AACA;AACA,sBAAsB,MAAc;AACpC;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA,0BAA0B,UAAW;AACrC;AACO,SAAS,UAAM;AACtB;AACA;AACA,kBAAkB,UAAW;AAC7B;AACA;AACA;AACA;AACA;AACA,eAAe,MAAc;AAC7B;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACtFA;;AAEA;AACA,sBAAsB,KAAK,QAAQ,KAAK;AACxC;;AAEA,wGAAwG,EAAE;;AAE1G,+BAA+B,IAAI;;AAEnC;AACA;AACA,KAAK,UAAU,GAAG,EAAE,KAAK,UAAU;AACnC,KAAK,UAAU,GAAG,EAAE,KAAK,GAAG,IAAI,UAAU;AAC1C,KAAK,UAAU,GAAG,EAAE,MAAM,GAAG,OAAO,UAAU,EAAE,IAAI;AACpD,KAAK,UAAU,GAAG,EAAE,SAAS,UAAU,EAAE,IAAI,GAAG,GAAG,OAAO,UAAU,EAAE,IAAI;AAC1E,KAAK,UAAU,GAAG,EAAE,SAAS,UAAU,EAAE,IAAI,GAAG,GAAG,OAAO,UAAU,EAAE,IAAI;AAC1E,KAAK,UAAU,GAAG,EAAE,SAAS,UAAU,EAAE,IAAI,GAAG,GAAG,OAAO,UAAU,EAAE,IAAI;AAC1E,KAAK,UAAU,GAAG,EAAE,SAAS,UAAU,EAAE,IAAI,GAAG,GAAG,OAAO,UAAU,EAAE,IAAI;AAC1E,aAAa,UAAU,EAAE,IAAI,GAAG,GAAG,OAAO,UAAU,EAAE,IAAI;AAC1D,iBAAiB,GAAG;AACpB;;AAEA;AACA,mCAAmC,GAAG,SAAS,GAAG;AAClD,+BAA+B,GAAG;AAClC,+BAA+B,GAAG;;AAElC;AACA;AACA,oBAAoB,iBAAiB,EAAE,GAAG,EAAE,iBAAiB,OAAO,iBAAiB,EAAE,GAAG,EAAE,iBAAiB;;AAE7G,2EAA2E,iBAAiB,EAAE,GAAG,EAAE,iBAAiB;AACpH,2EAA2E,iBAAiB,EAAE,GAAG,EAAE,iBAAiB;;AAEpH,+CAAe,OAAO,EAAC;;;ACnCQ;;AAExB;AACP,QAAQ,QAAO,EAAE,YAAY;AAC7B;;AAEO;AACP,QAAQ,QAAO,KAAK,YAAY;AAChC;;AAEO;AACP,QAAQ,QAAO,KAAK,YAAY;AAChC;;AAEO;AACP;AACA;;;;;;;;;;;;AChBA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACe;AACf,wCAAwC;AACxC;AACA;AACA;AACA;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;;;;;;;;;;;;ACRe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7BO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACbuD;AACvD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,eAAe,6EAAY;AAC3B;AACA;AACA;;;;;;;;;;;;;;ACrByC;AACc;AACvD;AACA;AACA;AACO;AACP;AACA;AACA;AACA,mBAAmB,+DAAW;AAC9B;AACA;AACA;AACA;AACA;AACA,WAAW,6EAAY;AACvB;;;;;;;;;;;;AChBA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChBoC;AACmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,iBAAiB,+DAAK;AACtB;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA,eAAe,6EAAY;AAC3B;AACA;AACA,kCAAkC,YAAY,EAAE,OAAO,IAAI;AAC3D;;;;;;;;;;;;;ACnBoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,iBAAiB,+DAAK;AACtB;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACT4C;AACF;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA,CAAC;AACD;AACA,gBAAgB,+DAAW;AAC3B,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,SAAS,gEAAK;AACd;AACA;AACA;AACA,OAAO,gEAAK;AACZ;AACA,iEAAe,KAAK,EAAC","sources":["webpack://mask-network/./node_modules/.pnpm/@dimensiondev+common-protocols@1.6.0-20210723072221-8f46a92/node_modules/@dimensiondev/common-protocols/esm/attachment/utils.js","webpack://mask-network/./node_modules/.pnpm/@dimensiondev+common-protocols@1.6.0-20210723072221-8f46a92/node_modules/@dimensiondev/common-protocols/esm/attachment/types.js","webpack://mask-network/./node_modules/.pnpm/@dimensiondev+common-protocols@1.6.0-20210723072221-8f46a92/node_modules/@dimensiondev/common-protocols/esm/attachment/encoder.js","webpack://mask-network/./node_modules/.pnpm/@dimensiondev+common-protocols@1.6.0-20210723072221-8f46a92/node_modules/@dimensiondev/common-protocols/esm/utils.js","webpack://mask-network/./node_modules/.pnpm/@dimensiondev+common-protocols@1.6.0-20210723072221-8f46a92/node_modules/@dimensiondev/common-protocols/esm/attachment/payload.js","webpack://mask-network/./node_modules/.pnpm/@dimensiondev+common-protocols@1.6.0-20210723072221-8f46a92/node_modules/@dimensiondev/common-protocols/esm/attachment/decoder.js","webpack://mask-network/./node_modules/.pnpm/@dimensiondev+common-protocols@1.6.0-20210723072221-8f46a92/node_modules/@dimensiondev/common-protocols/esm/attachment/index.js","webpack://mask-network/./node_modules/.pnpm/@dimensiondev+common-protocols@1.6.0-20210723072221-8f46a92/node_modules/@dimensiondev/common-protocols/esm/index.js","webpack://mask-network/./packages/plugins/FileService/src/Worker/remote-signing.ts","webpack://mask-network/./packages/plugins/FileService/src/Worker/arweave.ts","webpack://mask-network/./packages/plugins/FileService/src/Worker/ipfs.ts","webpack://mask-network/./packages/plugins/FileService/src/Worker/service.ts","webpack://mask-network/./packages/web3-providers/src/helpers/fetchText.ts","webpack://mask-network/./node_modules/.pnpm/any-signal@3.0.0/node_modules/any-signal/index.js","webpack://mask-network/./node_modules/.pnpm/arconnect@0.4.2/node_modules/arconnect/index.es.js","webpack://mask-network/./node_modules/.pnpm/browser-readablestream-to-it@1.0.3/node_modules/browser-readablestream-to-it/index.js","webpack://mask-network/./node_modules/.pnpm/err-code@3.0.1/node_modules/err-code/index.js","webpack://mask-network/./node_modules/.pnpm/ipfs-utils@9.0.14/node_modules/ipfs-utils/src/env.js","webpack://mask-network/./node_modules/.pnpm/ipfs-utils@9.0.14/node_modules/ipfs-utils/src/fetch.browser.js","webpack://mask-network/./node_modules/.pnpm/ipfs-utils@9.0.14/node_modules/ipfs-utils/src/files/url-source.js","webpack://mask-network/./node_modules/.pnpm/ipfs-utils@9.0.14/node_modules/ipfs-utils/src/http.js","webpack://mask-network/./node_modules/.pnpm/ipfs-utils@9.0.14/node_modules/ipfs-utils/src/http/error.js","webpack://mask-network/./node_modules/.pnpm/ipfs-utils@9.0.14/node_modules/ipfs-utils/src/http/fetch.browser.js","webpack://mask-network/./node_modules/.pnpm/is-electron@2.2.1/node_modules/is-electron/index.js","webpack://mask-network/./node_modules/.pnpm/is-plain-obj@2.1.0/node_modules/is-plain-obj/index.js","webpack://mask-network/./node_modules/.pnpm/iso-url@1.2.1/node_modules/iso-url/index.js","webpack://mask-network/./node_modules/.pnpm/iso-url@1.2.1/node_modules/iso-url/src/relative.js","webpack://mask-network/./node_modules/.pnpm/iso-url@1.2.1/node_modules/iso-url/src/url-browser.js","webpack://mask-network/./node_modules/.pnpm/it-all@1.0.6/node_modules/it-all/index.js","webpack://mask-network/./node_modules/.pnpm/merge-options@3.0.4/node_modules/merge-options/index.js","webpack://mask-network/./node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js","webpack://mask-network/./node_modules/.pnpm/native-fetch@3.0.0_node-fetch@2.7.0/node_modules/native-fetch/src/index.js","webpack://mask-network/./node_modules/.pnpm/node-fetch@2.7.0/node_modules/node-fetch/browser.js","webpack://mask-network/./node_modules/.pnpm/stream-to-it@0.2.4/node_modules/stream-to-it/source.js","webpack://mask-network/./node_modules/.pnpm/varint@6.0.0/node_modules/varint/decode.js","webpack://mask-network/./node_modules/.pnpm/varint@6.0.0/node_modules/varint/encode.js","webpack://mask-network/./node_modules/.pnpm/varint@6.0.0/node_modules/varint/index.js","webpack://mask-network/./node_modules/.pnpm/varint@6.0.0/node_modules/varint/length.js","webpack://mask-network/ignored|/Users/macbook/Documents/projects/mask/node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src|ipfs-utils/src/files/glob-source.js","webpack://mask-network/./node_modules/.pnpm/merge-options@3.0.4/node_modules/merge-options/index.mjs","webpack://mask-network/./node_modules/.pnpm/parse-duration@1.0.2/node_modules/parse-duration/index.mjs","webpack://mask-network/./node_modules/.pnpm/@chainsafe+is-ip@2.0.1/node_modules/@chainsafe/is-ip/lib/parser.js","webpack://mask-network/./node_modules/.pnpm/@chainsafe+is-ip@2.0.1/node_modules/@chainsafe/is-ip/lib/parse.js","webpack://mask-network/./node_modules/.pnpm/@chainsafe+is-ip@2.0.1/node_modules/@chainsafe/is-ip/lib/is-ip.js","webpack://mask-network/./node_modules/.pnpm/@ipld+dag-cbor@9.0.0/node_modules/@ipld/dag-cbor/src/index.js","webpack://mask-network/./node_modules/.pnpm/@ipld+dag-json@10.0.1/node_modules/@ipld/dag-json/src/index.js","webpack://mask-network/./node_modules/.pnpm/@ipld+dag-pb@4.0.2/node_modules/@ipld/dag-pb/src/pb-decode.js","webpack://mask-network/./node_modules/.pnpm/@ipld+dag-pb@4.0.2/node_modules/@ipld/dag-pb/src/pb-encode.js","webpack://mask-network/./node_modules/.pnpm/@ipld+dag-pb@4.0.2/node_modules/@ipld/dag-pb/src/util.js","webpack://mask-network/./node_modules/.pnpm/@ipld+dag-pb@4.0.2/node_modules/@ipld/dag-pb/src/index.js","webpack://mask-network/./node_modules/.pnpm/@libp2p+logger@2.0.7/node_modules/@libp2p/logger/dist/src/index.js","webpack://mask-network/./node_modules/.pnpm/@libp2p+interface-peer-id@2.0.1/node_modules/@libp2p/interface-peer-id/dist/src/index.js","webpack://mask-network/./node_modules/.pnpm/@libp2p+peer-id@2.0.3/node_modules/@libp2p/peer-id/dist/src/index.js","webpack://mask-network/./node_modules/.pnpm/@multiformats+multiaddr-to-uri@9.0.1_undici@5.23.0/node_modules/@multiformats/multiaddr-to-uri/dist/src/index.js","webpack://mask-network/./node_modules/.pnpm/blob-to-it@2.0.2/node_modules/blob-to-it/dist/src/index.js","webpack://mask-network/./node_modules/.pnpm/browser-readablestream-to-it@2.0.2/node_modules/browser-readablestream-to-it/dist/src/index.js","webpack://mask-network/./node_modules/.pnpm/dag-jose@4.0.0/node_modules/dag-jose/lib/utils.js","webpack://mask-network/./node_modules/.pnpm/dag-jose@4.0.0/node_modules/dag-jose/lib/signing.js","webpack://mask-network/./node_modules/.pnpm/dag-jose@4.0.0/node_modules/dag-jose/lib/encryption.js","webpack://mask-network/./node_modules/.pnpm/dag-jose@4.0.0/node_modules/dag-jose/lib/index.js","webpack://mask-network/./node_modules/.pnpm/ip-regex@5.0.0/node_modules/ip-regex/index.js","webpack://mask-network/./node_modules/.pnpm/is-ip@4.0.0/node_modules/is-ip/index.js","webpack://mask-network/./node_modules/.pnpm/it-all@2.0.1/node_modules/it-all/dist/src/index.js","webpack://mask-network/./node_modules/.pnpm/it-first@2.0.1/node_modules/it-first/dist/src/index.js","webpack://mask-network/./node_modules/.pnpm/it-last@2.0.1/node_modules/it-last/dist/src/index.js","webpack://mask-network/./node_modules/.pnpm/it-map@2.0.1/node_modules/it-map/dist/src/index.js","webpack://mask-network/./node_modules/.pnpm/it-peekable@2.0.1/node_modules/it-peekable/dist/src/index.js","webpack://mask-network/./node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/equals.js","webpack://mask-network/./node_modules/.pnpm/uint8arrays@4.0.3/node_modules/uint8arrays/dist/src/alloc.js","webpack://mask-network/./node_modules/.pnpm/uint8arrays@4.0.3/node_modules/uint8arrays/dist/src/concat.js","webpack://mask-network/./node_modules/.pnpm/uint8arrays@4.0.3/node_modules/uint8arrays/dist/src/equals.js","webpack://mask-network/./node_modules/.pnpm/uint8arrays@4.0.3/node_modules/uint8arrays/dist/src/from-string.js","webpack://mask-network/./node_modules/.pnpm/uint8arrays@4.0.3/node_modules/uint8arrays/dist/src/to-string.js","webpack://mask-network/./node_modules/.pnpm/uint8arrays@4.0.3/node_modules/uint8arrays/dist/src/util/as-uint8array.js","webpack://mask-network/./node_modules/.pnpm/uint8arrays@4.0.3/node_modules/uint8arrays/dist/src/util/bases.js"],"sourcesContent":["export async function checksum(block) {\n    const hashed = await crypto.subtle.digest({ name: \"SHA-256\" }, block);\n    return new Uint8Array(hashed);\n}\nexport async function loadKey(passphrase, salt) {\n    const key = await crypto.subtle.importKey(\"raw\", passphrase, { name: \"PBKDF2\" }, false, [\"deriveBits\", \"deriveKey\"]);\n    return crypto.subtle.deriveKey({\n        name: \"PBKDF2\",\n        salt,\n        iterations: 1000,\n        hash: \"SHA-256\",\n    }, key, { name: \"AES-GCM\", length: 128 }, true, [\"encrypt\", \"decrypt\"]);\n}\n","export const MAGIC_HEADER = new TextEncoder().encode(\"MASKBOOK-ATTACHMENT\");\n","import { encode as encodePack } from \"@msgpack/msgpack\";\nimport { checksum, loadKey } from \"./utils\";\nimport { MAGIC_HEADER } from \"./types\";\nexport async function encode(passphrase, input) {\n    let algorithm, salt, block, keyHash;\n    if (passphrase === undefined) {\n        block = input.block;\n    }\n    else {\n        keyHash = await checksum(passphrase);\n        salt = crypto.getRandomValues(new Uint8Array(8));\n        const key = await loadKey(passphrase, salt);\n        const iv = crypto.getRandomValues(new Uint8Array(12));\n        algorithm = { name: \"AES-GCM\", iv, tagLength: 128 };\n        const encrypted = await crypto.subtle.encrypt(algorithm, key, input.block);\n        block = new Uint8Array(encrypted);\n    }\n    const payload = {\n        version: 0,\n        mime: input.mime,\n        metadata: input.metadata,\n        algorithm,\n        salt,\n        keyHash,\n        block,\n        blockHash: await checksum(block),\n    };\n    return Uint8Array.from([...MAGIC_HEADER, ...encodePack(payload)]);\n}\n","export function bufferEqual(buf1, buf2) {\n    if (buf1 === buf2) {\n        return true;\n    }\n    else if (buf1.byteLength !== buf2.byteLength) {\n        return false;\n    }\n    let i = buf1.byteLength;\n    while (i--) {\n        if (buf1[i] !== buf2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n","import { decode as decodePack } from \"@msgpack/msgpack\";\nimport { MAGIC_HEADER } from \"./types\";\nimport { bufferEqual } from \"../utils\";\nimport { checksum } from \"./utils\";\nexport async function getPayload(passphrase, encoded) {\n    if (!bufferEqual(MAGIC_HEADER, encoded.slice(0, MAGIC_HEADER.length))) {\n        throw new Error(\"unexpected magic header.\");\n    }\n    const buffer = encoded.slice(MAGIC_HEADER.length);\n    const payload = decodePack(buffer);\n    if (payload.version !== 0) {\n        throw new Error(\"unexpected file version.\");\n    }\n    else if (payload.mime.length === 0) {\n        throw new Error(\"unexpected `.mime`.\");\n    }\n    else if (!bufferEqual(payload.blockHash, await checksum(payload.block))) {\n        throw new Error(\"unexpected `blockHash`.\");\n    }\n    else if (passphrase && payload.keyHash) {\n        if (!bufferEqual(payload.keyHash, await checksum(passphrase))) {\n            throw new Error(\"unexpected `keyHash`.\");\n        }\n    }\n    return payload;\n}\n","import { getPayload } from \"./payload\";\nimport { loadKey } from \"./utils\";\nexport async function decode(passphrase, encoded) {\n    const payload = await getPayload(passphrase, encoded);\n    let block = payload.block;\n    if (passphrase && payload.algorithm && payload.salt) {\n        const data = await crypto.subtle.decrypt(payload.algorithm, await loadKey(passphrase, payload.salt), payload.block);\n        block = new Uint8Array(data);\n    }\n    return {\n        mime: payload.mime,\n        metadata: payload.metadata,\n        block,\n    };\n}\n","export { encode } from \"./encoder\";\nexport { decode } from \"./decoder\";\nexport { getPayload } from \"./payload\";\nexport { loadKey, checksum } from \"./utils\";\n","import * as Attachment_1 from \"./attachment\";\nexport { Attachment_1 as Attachment };\n","import { encode } from '@msgpack/msgpack'\nimport type Transaction from 'arweave/web/lib/transaction.js'\nimport { ARWEAVE_SIGNING } from '../constants.js'\n\nexport async function sign(transaction: Transaction.default) {\n    const response = await fetch(ARWEAVE_SIGNING, {\n        method: 'POST',\n        body: Uint8Array.from(await makeRequest(transaction)),\n    })\n    transaction.setSignature(await response.json())\n}\n\nasync function makeRequest(transaction: Transaction.default) {\n    const encoder = new TextEncoder()\n    await transaction.prepareChunks(transaction.data)\n    const get = (base: { get: typeof transaction.get }, name: string) => base.get(name, { decode: true, string: false })\n    return encode([\n        encoder.encode(transaction.format.toString()),\n        get(transaction, 'owner'),\n        get(transaction, 'target'),\n        encoder.encode(transaction.quantity),\n        encoder.encode(transaction.reward),\n        get(transaction, 'last_tx'),\n        transaction.tags.map((tag) => [get(tag, 'name'), get(tag, 'value')]),\n        encoder.encode(transaction.data_size),\n        get(transaction, 'data_root'),\n    ])\n}\n","import { isEmpty } from 'lodash-es'\nimport Arweave from 'arweave/web'\nimport { Attachment } from '@dimensiondev/common-protocols'\nimport { encodeText } from '@masknet/kit'\nimport type Transaction from 'arweave/web/lib/transaction.js'\nimport type { JWKInterface } from 'arweave/web/lib/wallet.js'\nimport { fetchText } from '@masknet/web3-providers/helpers'\nimport { LANDING_PAGE, MESON_PREFIX, Provider } from '../constants.js'\nimport { sign } from './remote-signing.js'\nimport TOKEN from './arweave-token.json'\nimport type { ProviderAgent, LandingPageMetadata, AttachmentOptions } from '../types.js'\nimport { makeFileKeySigned } from '../helpers.js'\n\nclass ArweaveAgent implements ProviderAgent {\n    instance!: Arweave.default\n    static stage: Record<Transaction.default['id'], Transaction.default> = {}\n\n    init() {\n        if (this.instance) return\n        // Note: ESM interop\n        this.instance = (Arweave.default || Arweave).init({\n            host: 'arweave.net',\n            port: 443,\n            protocol: 'https',\n        })\n    }\n\n    async makeAttachment(options: AttachmentOptions) {\n        this.init()\n        const passphrase = options.key ? encodeText(options.key) : undefined\n        const encoded = await Attachment.encode(passphrase, {\n            block: options.block,\n            mime: isEmpty(options.type) ? 'application/octet-stream' : options.type,\n            metadata: null,\n        })\n        const transaction = await this.makePayload(encoded, 'application/octet-stream')\n        ArweaveAgent.stage[transaction.id] = transaction\n        await this.instance.transactions.post(transaction)\n        return transaction.id\n    }\n\n    async uploadLandingPage(metadata: LandingPageMetadata) {\n        this.init()\n        let linkPrefix = 'https://arweave.net'\n        if (metadata.useCDN) {\n            linkPrefix = MESON_PREFIX\n        }\n        const encodedMetadata = JSON.stringify({\n            name: metadata.name,\n            size: metadata.size,\n            provider: Provider.Arweave,\n            link: `${linkPrefix}/${metadata.txId}`,\n            signed: await makeFileKeySigned(metadata.key),\n            createdAt: new Date().toISOString(),\n        })\n        const text = await fetchText(LANDING_PAGE)\n        const replaced = text.replace('__METADATA__', encodedMetadata)\n        const data = encodeText(replaced)\n        const transaction = await this.makePayload(data, 'text/html')\n        await this.instance.transactions.post(transaction)\n        return transaction.id\n    }\n\n    async *upload(id: Transaction.default['id']) {\n        this.init()\n        for await (const uploader of this.instance.transactions.upload(ArweaveAgent.stage[id], new Uint8Array())) {\n            yield uploader.pctComplete\n        }\n    }\n\n    async makePayload(data: Uint8Array, type: string) {\n        this.init()\n        const transaction = await this.instance.createTransaction({ data }, TOKEN as JWKInterface)\n        transaction.addTag('Content-Type', type)\n        await sign(transaction)\n        return transaction\n    }\n}\n\nexport default new ArweaveAgent()\n","import urlcat from 'urlcat'\nimport { isEmpty } from 'lodash-es'\nimport { Attachment } from '@dimensiondev/common-protocols'\nimport { encodeText } from '@masknet/kit'\nimport { create, type IPFSHTTPClient } from 'ipfs-http-client'\nimport { LANDING_PAGE, Provider } from '../constants.js'\nimport type { ProviderAgent, LandingPageMetadata, AttachmentOptions } from '../types.js'\nimport { makeFileKeySigned } from '../helpers.js'\n\nfunction createClient(): IPFSHTTPClient {\n    return create({\n        host: 'ipfs.infura.io',\n        port: 5001,\n        protocol: 'https',\n        headers: {\n            authorization: 'Basic MkRZaG10eThyM21DOWl5dE5tdG9ZdkdmWkxiOmM5YjVlOTRmNjM1OTdiMGEyNmJhY2RlNmI3NTgxOTgx',\n        },\n    })\n}\n\nclass IPFSAgent implements ProviderAgent {\n    static providerName = 'IPFS'\n    client!: IPFSHTTPClient\n\n    init() {\n        if (this.client) return\n        this.client = createClient()\n    }\n\n    async makeAttachment(options: AttachmentOptions) {\n        const passphrase = options.key ? encodeText(options.key) : undefined\n        const encoded = await Attachment.encode(passphrase, {\n            block: options.block,\n            mime: isEmpty(options.type) ? 'application/octet-stream' : options.type,\n            metadata: null,\n        })\n        return this.makePayload(encoded, 'application/octet-stream')\n    }\n\n    // currently not native support progress track\n    async *upload(id: string) {\n        yield 100\n    }\n\n    async uploadLandingPage(metadata: LandingPageMetadata) {\n        const linkPrefix = 'https://mask.infura-ipfs.io/ipfs'\n        const encodedMetadata = JSON.stringify({\n            name: metadata.name,\n            size: metadata.size,\n            provider: Provider.IPFS,\n            link: urlcat(linkPrefix, '/:txId', { txId: metadata.txId }),\n            signed: await makeFileKeySigned(metadata.key),\n            createdAt: new Date().toISOString(),\n        })\n        const response = await fetch(LANDING_PAGE)\n        const text = await response.text()\n        const replaced = text\n            .replace('Arweave', IPFSAgent.providerName)\n            .replace('Over Arweave', `Over ${IPFSAgent.providerName}`)\n            .replace('__METADATA__', encodedMetadata)\n        const data = encodeText(replaced)\n        return this.makePayload(data, 'text/html')\n    }\n\n    async makePayload(data: Uint8Array, type: string) {\n        this.init()\n        const file = await this.client.add(data)\n        return file.cid.toString()\n    }\n}\n\nexport default new IPFSAgent()\n","import { type AttachmentOptions, type LandingPageMetadata, Provider, type ProviderAgent } from '../types.js'\nimport arweave from './arweave.js'\nimport ipfs from './ipfs.js'\n\nconst allProviders: Record<Provider, ProviderAgent> = {\n    [Provider.Arweave]: arweave,\n    [Provider.IPFS]: ipfs,\n}\n\nexport async function makeAttachment(provider: Provider, options: AttachmentOptions) {\n    return allProviders[provider]?.makeAttachment(options)\n}\n\nexport async function* upload(provider: Provider, id: string) {\n    for await (const percent of allProviders[provider].upload(id)) {\n        yield percent\n    }\n}\n\nexport async function uploadLandingPage(provider: Provider, metadata: LandingPageMetadata) {\n    return allProviders[provider]?.uploadLandingPage(metadata)\n}\n\nexport { deleteFile, getAllFiles, renameFile, setFileInfo } from './database.js'\n","import { fetch } from './fetch.js'\nimport { getNextFetchers, type NextFetchersOptions } from './getNextFetchers.js'\n\nexport async function fetchText(\n    input: RequestInfo | URL,\n    init?: RequestInit,\n    options?: NextFetchersOptions,\n): Promise<string> {\n    const response = await fetch(input, init, getNextFetchers(options))\n    if (!response.ok) throw new Error('Failed to fetch as Text.')\n    return response.text()\n}\n","const { AbortController } = globalThis\n\n/**\n * Takes an array of AbortSignals and returns a single signal.\n * If any signals are aborted, the returned signal will be aborted.\n * @param {Array<AbortSignal>} signals\n * @returns {AbortSignal}\n */\nfunction anySignal (signals) {\n  const controller = new AbortController()\n\n  function onAbort () {\n    controller.abort()\n\n    for (const signal of signals) {\n      if (!signal || !signal.removeEventListener) continue\n      signal.removeEventListener('abort', onAbort)\n    }\n  }\n\n  for (const signal of signals) {\n    if (!signal || !signal.addEventListener) continue\n    if (signal.aborted) {\n      onAbort()\n      break\n    }\n    signal.addEventListener('abort', onAbort)\n  }\n\n  return controller.signal\n}\n\nmodule.exports = anySignal\nmodule.exports.anySignal = anySignal\n","export default {};\n","'use strict'\n\n/**\n * Turns a browser readable stream into an async iterable. Async iteration over\n * returned iterable will lock give stream, preventing any other consumer from\n * acquiring a reader. The lock will be released if iteration loop is broken. To\n * prevent stream cancelling optional `{ preventCancel: true }` could be passed\n * as a second argument.\n * @template T\n * @param {ReadableStream<T>} stream\n * @param {Object} [options]\n * @param {boolean} [options.preventCancel=boolean]\n * @returns {AsyncIterable<T>}\n */\nasync function * browserReadableStreamToIt (stream, options = {}) {\n  const reader = stream.getReader()\n\n  try {\n    while (true) {\n      const result = await reader.read()\n\n      if (result.done) {\n        return\n      }\n\n      yield result.value\n    }\n  } finally {\n    if (options.preventCancel !== true) {\n      reader.cancel()\n    }\n\n    reader.releaseLock()\n  }\n}\n\nmodule.exports = browserReadableStreamToIt\n","'use strict';\n\n/**\n * @typedef {{ [key: string]: any }} Extensions\n * @typedef {Error} Err\n * @property {string} message\n */\n\n/**\n *\n * @param {Error} obj\n * @param {Extensions} props\n * @returns {Error & Extensions}\n */\nfunction assign(obj, props) {\n    for (const key in props) {\n        Object.defineProperty(obj, key, {\n            value: props[key],\n            enumerable: true,\n            configurable: true,\n        });\n    }\n\n    return obj;\n}\n\n/**\n *\n * @param {any} err - An Error\n * @param {string|Extensions} code - A string code or props to set on the error\n * @param {Extensions} [props] - Props to set on the error\n * @returns {Error & Extensions}\n */\nfunction createError(err, code, props) {\n    if (!err || typeof err === 'string') {\n        throw new TypeError('Please pass an Error to err-code');\n    }\n\n    if (!props) {\n        props = {};\n    }\n\n    if (typeof code === 'object') {\n        props = code;\n        code = '';\n    }\n\n    if (code) {\n        props.code = code;\n    }\n\n    try {\n        return assign(err, props);\n    } catch (_) {\n        props.message = err.message;\n        props.stack = err.stack;\n\n        const ErrClass = function () {};\n\n        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));\n\n        // @ts-ignore\n        const output = assign(new ErrClass(), props);\n\n        return output;\n    }\n}\n\nmodule.exports = createError;\n","'use strict'\nconst isElectron = require('is-electron')\n\nconst IS_ENV_WITH_DOM = typeof window === 'object' && typeof document === 'object' && document.nodeType === 9\n// @ts-ignore\nconst IS_ELECTRON = isElectron()\nconst IS_BROWSER = IS_ENV_WITH_DOM && !IS_ELECTRON\nconst IS_ELECTRON_MAIN = IS_ELECTRON && !IS_ENV_WITH_DOM\nconst IS_ELECTRON_RENDERER = IS_ELECTRON && IS_ENV_WITH_DOM\nconst IS_NODE = typeof require === 'function' && typeof process !== 'undefined' && typeof process.release !== 'undefined' && process.release.name === 'node' && !IS_ELECTRON\n// @ts-ignore - we either ignore worker scope or dom scope\nconst IS_WEBWORKER = typeof importScripts === 'function' && typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope\nconst IS_TEST = typeof process !== 'undefined' && typeof process.env !== 'undefined' && process.env.NODE_ENV === 'test'\nconst IS_REACT_NATIVE = typeof navigator !== 'undefined' && navigator.product === 'ReactNative'\n\nmodule.exports = {\n  isTest: IS_TEST,\n  isElectron: IS_ELECTRON,\n  isElectronMain: IS_ELECTRON_MAIN,\n  isElectronRenderer: IS_ELECTRON_RENDERER,\n  isNode: IS_NODE,\n  /**\n   * Detects browser main thread  **NOT** web worker or service worker\n   */\n  isBrowser: IS_BROWSER,\n  isWebWorker: IS_WEBWORKER,\n  isEnvWithDom: IS_ENV_WITH_DOM,\n  isReactNative: IS_REACT_NATIVE\n}\n","'use strict'\n\n/**\n * @typedef {globalThis.Headers} Headers\n * @typedef {globalThis.Request} Request\n * @typedef {globalThis.Response} Response\n */\n\n// use window.fetch if it is available, fall back to node-fetch if not\nmodule.exports = require('native-fetch')\n","'use strict'\n\nconst HTTP = require('../http')\n\n/**\n *\n * @param {string} url\n * @param {import(\"../types\").HTTPOptions} [options]\n * @returns {{ path: string; content?: AsyncIterable<Uint8Array> }}\n */\nconst urlSource = (url, options) => {\n  return {\n    path: decodeURIComponent(new URL(url).pathname.split('/').pop() || ''),\n    content: readURLContent(url, options)\n  }\n}\n\n/**\n *\n * @param {string} url\n * @param {import(\"../types\").HTTPOptions} [options]\n * @returns {AsyncIterable<Uint8Array>}\n */\nasync function * readURLContent (url, options) {\n  const http = new HTTP()\n  const response = await http.get(url, options)\n\n  yield * response.iterator()\n}\n\nmodule.exports = urlSource\n","/* eslint-disable no-undef */\n'use strict'\n\nconst { fetch, Request, Headers } = require('./http/fetch')\nconst { TimeoutError, HTTPError } = require('./http/error')\nconst merge = require('merge-options').bind({ ignoreUndefined: true })\nconst { URL, URLSearchParams } = require('iso-url')\nconst anySignal = require('any-signal')\nconst browserReableStreamToIt = require('browser-readablestream-to-it')\nconst { isBrowser, isWebWorker } = require('./env')\nconst all = require('it-all')\n\n/**\n * @typedef {import('stream').Readable} NodeReadableStream\n * @typedef {import('./types').HTTPOptions} HTTPOptions\n * @typedef {import('./types').ExtendedResponse} ExtendedResponse\n */\n\n/**\n * @template TResponse\n * @param {Promise<TResponse>} promise\n * @param {number | undefined} ms\n * @param {AbortController} abortController\n * @returns {Promise<TResponse>}\n */\nconst timeout = (promise, ms, abortController) => {\n  if (ms === undefined) {\n    return promise\n  }\n\n  const start = Date.now()\n\n  const timedOut = () => {\n    const time = Date.now() - start\n\n    return time >= ms\n  }\n\n  return new Promise((resolve, reject) => {\n    const timeoutID = setTimeout(() => {\n      if (timedOut()) {\n        reject(new TimeoutError())\n        abortController.abort()\n      }\n    }, ms)\n\n    /**\n     * @param {(value: any) => void } next\n     */\n    const after = (next) => {\n      /**\n       * @param {any} res\n       */\n      const fn = (res) => {\n        clearTimeout(timeoutID)\n\n        if (timedOut()) {\n          reject(new TimeoutError())\n          return\n        }\n\n        next(res)\n      }\n      return fn\n    }\n\n    promise\n      .then(after(resolve), after(reject))\n  })\n}\n\nconst defaults = {\n  throwHttpErrors: true,\n  credentials: 'same-origin'\n}\n\nclass HTTP {\n  /**\n   *\n   * @param {HTTPOptions} options\n   */\n  constructor (options = {}) {\n    /** @type {HTTPOptions} */\n    this.opts = merge(defaults, options)\n  }\n\n  /**\n   * Fetch\n   *\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   * @returns {Promise<ExtendedResponse>}\n   */\n  async fetch (resource, options = {}) {\n    /** @type {HTTPOptions} */\n    const opts = merge(this.opts, options)\n    // @ts-expect-error\n    const headers = new Headers(opts.headers)\n\n    // validate resource type\n    // @ts-expect-error\n    if (typeof resource !== 'string' && !(resource instanceof URL || resource instanceof Request)) {\n      throw new TypeError('`resource` must be a string, URL, or Request')\n    }\n\n    const url = new URL(resource.toString(), opts.base)\n\n    const {\n      searchParams,\n      transformSearchParams,\n      json\n    } = opts\n\n    if (searchParams) {\n      if (typeof transformSearchParams === 'function') {\n        // @ts-ignore\n        url.search = transformSearchParams(new URLSearchParams(opts.searchParams))\n      } else {\n        // @ts-ignore\n        url.search = new URLSearchParams(opts.searchParams)\n      }\n    }\n\n    if (json) {\n      opts.body = JSON.stringify(opts.json)\n      headers.set('content-type', 'application/json')\n    }\n\n    const abortController = new AbortController()\n    // @ts-ignore\n    const signal = anySignal([abortController.signal, opts.signal])\n\n    if (globalThis.ReadableStream != null && opts.body instanceof globalThis.ReadableStream && (isBrowser || isWebWorker)) {\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1387483\n      opts.body = new Blob(await all(browserReableStreamToIt(opts.body)))\n    }\n\n    /** @type {ExtendedResponse} */\n    // @ts-expect-error additional fields are assigned below\n    const response = await timeout(\n      fetch(\n        url.toString(),\n        {\n          ...opts,\n          signal,\n          // @ts-expect-error non-browser fetch implementations may take extra options\n          timeout: undefined,\n          headers,\n\n          // https://fetch.spec.whatwg.org/#dom-requestinit-duplex\n          // https://github.com/whatwg/fetch/issues/1254\n          duplex: 'half'\n        }\n      ),\n      opts.timeout,\n      abortController\n    )\n\n    if (!response.ok && opts.throwHttpErrors) {\n      if (opts.handleError) {\n        await opts.handleError(response)\n      }\n      throw new HTTPError(response)\n    }\n\n    response.iterator = async function * () {\n      yield * fromStream(response.body)\n    }\n\n    response.ndjson = async function * () {\n      for await (const chunk of ndjson(response.iterator())) {\n        if (options.transform) {\n          yield options.transform(chunk)\n        } else {\n          yield chunk\n        }\n      }\n    }\n\n    return response\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   */\n  post (resource, options = {}) {\n    return this.fetch(resource, { ...options, method: 'POST' })\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   */\n  get (resource, options = {}) {\n    return this.fetch(resource, { ...options, method: 'GET' })\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   */\n  put (resource, options = {}) {\n    return this.fetch(resource, { ...options, method: 'PUT' })\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   */\n  delete (resource, options = {}) {\n    return this.fetch(resource, { ...options, method: 'DELETE' })\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   */\n  options (resource, options = {}) {\n    return this.fetch(resource, { ...options, method: 'OPTIONS' })\n  }\n}\n\n/**\n * Parses NDJSON chunks from an iterator\n *\n * @param {AsyncIterable<Uint8Array>} source\n * @returns {AsyncIterable<any>}\n */\nconst ndjson = async function * (source) {\n  const decoder = new TextDecoder()\n  let buf = ''\n\n  for await (const chunk of source) {\n    buf += decoder.decode(chunk, { stream: true })\n    const lines = buf.split(/\\r?\\n/)\n\n    for (let i = 0; i < lines.length - 1; i++) {\n      const l = lines[i].trim()\n      if (l.length > 0) {\n        yield JSON.parse(l)\n      }\n    }\n    buf = lines[lines.length - 1]\n  }\n  buf += decoder.decode()\n  buf = buf.trim()\n  if (buf.length !== 0) {\n    yield JSON.parse(buf)\n  }\n}\n\n/**\n * Stream to AsyncIterable\n *\n * @template TChunk\n * @param {ReadableStream<TChunk> | NodeReadableStream | null} source\n * @returns {AsyncIterable<TChunk>}\n */\nconst fromStream = (source) => {\n  if (isAsyncIterable(source)) {\n    return source\n  }\n\n  // Workaround for https://github.com/node-fetch/node-fetch/issues/766\n  if (isNodeReadableStream(source)) {\n    const iter = source[Symbol.asyncIterator]()\n    return {\n      [Symbol.asyncIterator] () {\n        return {\n          next: iter.next.bind(iter),\n          return (value) {\n            source.destroy()\n            if (typeof iter.return === 'function') {\n              return iter.return()\n            }\n            return Promise.resolve({ done: true, value })\n          }\n        }\n      }\n    }\n  }\n\n  if (isWebReadableStream(source)) {\n    const reader = source.getReader()\n    return (async function * () {\n      try {\n        while (true) {\n          // Read from the stream\n          const { done, value } = await reader.read()\n          // Exit if we're done\n          if (done) return\n          // Else yield the chunk\n          if (value) {\n            yield value\n          }\n        }\n      } finally {\n        reader.releaseLock()\n      }\n    })()\n  }\n\n  throw new TypeError('Body can\\'t be converted to AsyncIterable')\n}\n\n/**\n * Check if it's an AsyncIterable\n *\n * @template {unknown} TChunk\n * @template {any} Other\n * @param {Other|AsyncIterable<TChunk>} value\n * @returns {value is AsyncIterable<TChunk>}\n */\nconst isAsyncIterable = (value) => {\n  return typeof value === 'object' &&\n  value !== null &&\n  typeof /** @type {any} */(value)[Symbol.asyncIterator] === 'function'\n}\n\n/**\n * Check for web readable stream\n *\n * @template {unknown} TChunk\n * @template {any} Other\n * @param {Other|ReadableStream<TChunk>} value\n * @returns {value is ReadableStream<TChunk>}\n */\nconst isWebReadableStream = (value) => {\n  return value && typeof /** @type {any} */(value).getReader === 'function'\n}\n\n/**\n * @param {any} value\n * @returns {value is NodeReadableStream}\n */\nconst isNodeReadableStream = (value) =>\n  Object.prototype.hasOwnProperty.call(value, 'readable') &&\n  Object.prototype.hasOwnProperty.call(value, 'writable')\n\nHTTP.HTTPError = HTTPError\nHTTP.TimeoutError = TimeoutError\nHTTP.streamToAsyncIterator = fromStream\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n */\nHTTP.post = (resource, options) => new HTTP(options).post(resource, options)\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n */\nHTTP.get = (resource, options) => new HTTP(options).get(resource, options)\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n */\nHTTP.put = (resource, options) => new HTTP(options).put(resource, options)\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n */\nHTTP.delete = (resource, options) => new HTTP(options).delete(resource, options)\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n */\nHTTP.options = (resource, options) => new HTTP(options).options(resource, options)\n\nmodule.exports = HTTP\n","'use strict'\n\nclass TimeoutError extends Error {\n  constructor (message = 'Request timed out') {\n    super(message)\n    this.name = 'TimeoutError'\n  }\n}\nexports.TimeoutError = TimeoutError\n\nclass AbortError extends Error {\n  constructor (message = 'The operation was aborted.') {\n    super(message)\n    this.name = 'AbortError'\n  }\n}\nexports.AbortError = AbortError\n\nclass HTTPError extends Error {\n  /**\n   * @param {Response} response\n   */\n  constructor (response) {\n    super(response.statusText)\n    this.name = 'HTTPError'\n    this.response = response\n  }\n}\nexports.HTTPError = HTTPError\n","'use strict'\n\nconst { TimeoutError, AbortError } = require('./error')\n// @ts-expect-error\nconst { Response, Request, Headers, default: fetch } = require('../fetch')\n\n/**\n * @typedef {import('../types').FetchOptions} FetchOptions\n * @typedef {import('../types').ProgressFn} ProgressFn\n */\n\n/**\n * Fetch with progress\n *\n * @param {string | Request} url\n * @param {FetchOptions} [options]\n * @returns {Promise<ResponseWithURL>}\n */\nconst fetchWithProgress = (url, options = {}) => {\n  const request = new XMLHttpRequest()\n  request.open(options.method || 'GET', url.toString(), true)\n\n  const { timeout, headers } = options\n\n  if (timeout && timeout > 0 && timeout < Infinity) {\n    request.timeout = timeout\n  }\n\n  if (options.overrideMimeType != null) {\n    request.overrideMimeType(options.overrideMimeType)\n  }\n\n  if (headers) {\n    for (const [name, value] of new Headers(headers)) {\n      request.setRequestHeader(name, value)\n    }\n  }\n\n  if (options.signal) {\n    options.signal.onabort = () => request.abort()\n  }\n\n  if (options.onUploadProgress) {\n    request.upload.onprogress = options.onUploadProgress\n  }\n\n  // Note: Need to use `arraybuffer` here instead of `blob` because `Blob`\n  // instances coming from JSDOM are not compatible with `Response` from\n  // node-fetch (which is the setup we get when testing with jest because\n  // it uses JSDOM which does not provide a global fetch\n  // https://github.com/jsdom/jsdom/issues/1724)\n  request.responseType = 'arraybuffer'\n\n  return new Promise((resolve, reject) => {\n    /**\n     * @param {Event} event\n     */\n    const handleEvent = (event) => {\n      switch (event.type) {\n        case 'error': {\n          resolve(Response.error())\n          break\n        }\n        case 'load': {\n          resolve(\n            new ResponseWithURL(request.responseURL, request.response, {\n              status: request.status,\n              statusText: request.statusText,\n              headers: parseHeaders(request.getAllResponseHeaders())\n            })\n          )\n          break\n        }\n        case 'timeout': {\n          reject(new TimeoutError())\n          break\n        }\n        case 'abort': {\n          reject(new AbortError())\n          break\n        }\n        default: {\n          break\n        }\n      }\n    }\n    request.onerror = handleEvent\n    request.onload = handleEvent\n    request.ontimeout = handleEvent\n    request.onabort = handleEvent\n\n    // @ts-expect-error options.body can be a node readable stream, which isn't compatible with XHR, but this\n    // file is a browser override so you won't get a node readable stream so ignore the error\n    request.send(options.body)\n  })\n}\n\nconst fetchWithStreaming = fetch\n\n/**\n * @param {string | Request} url\n * @param {FetchOptions} options\n */\nconst fetchWith = (url, options = {}) =>\n  (options.onUploadProgress != null)\n    ? fetchWithProgress(url, options)\n    : fetchWithStreaming(url, options)\n\n/**\n * Parse Headers from a XMLHttpRequest\n *\n * @param {string} input\n * @returns {Headers}\n */\nconst parseHeaders = (input) => {\n  const headers = new Headers()\n  for (const line of input.trim().split(/[\\r\\n]+/)) {\n    const index = line.indexOf(': ')\n    if (index > 0) {\n      headers.set(line.slice(0, index), line.slice(index + 1))\n    }\n  }\n\n  return headers\n}\n\nclass ResponseWithURL extends Response {\n  /**\n   * @param {string} url\n   * @param {BodyInit} body\n   * @param {ResponseInit} options\n   */\n  constructor (url, body, options) {\n    super(body, options)\n    Object.defineProperty(this, 'url', { value: url })\n  }\n}\n\nmodule.exports = {\n  fetch: fetchWith,\n  Request,\n  Headers\n}\n","// https://github.com/electron/electron/issues/2288\nfunction isElectron() {\n    // Renderer process\n    if (typeof window !== 'undefined' && typeof window.process === 'object' && window.process.type === 'renderer') {\n        return true;\n    }\n\n    // Main process\n    if (typeof process !== 'undefined' && typeof process.versions === 'object' && !!process.versions.electron) {\n        return true;\n    }\n\n    // Detect the user agent when the `nodeIntegration` option is set to false\n    if (typeof navigator === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent.indexOf('Electron') >= 0) {\n        return true;\n    }\n\n    return false;\n}\n\nmodule.exports = isElectron;\n","'use strict';\n\nmodule.exports = value => {\n\tif (Object.prototype.toString.call(value) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tconst prototype = Object.getPrototypeOf(value);\n\treturn prototype === null || prototype === Object.prototype;\n};\n","'use strict'\n\nconst {\n  URLWithLegacySupport,\n  format,\n  URLSearchParams,\n  defaultBase\n} = require('./src/url')\nconst relative = require('./src/relative')\n\nmodule.exports = {\n  URL: URLWithLegacySupport,\n  URLSearchParams,\n  format,\n  relative,\n  defaultBase\n}\n","'use strict'\n\nconst { URLWithLegacySupport, format } = require('./url')\n\n/**\n * @param {string | undefined} url\n * @param {any} [location]\n * @param {any} [protocolMap]\n * @param {any} [defaultProtocol]\n */\nmodule.exports = (url, location = {}, protocolMap = {}, defaultProtocol) => {\n  let protocol = location.protocol\n    ? location.protocol.replace(':', '')\n    : 'http'\n\n  // Check protocol map\n  protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ':'\n  let urlParsed\n\n  try {\n    urlParsed = new URLWithLegacySupport(url)\n  } catch (err) {\n    urlParsed = {}\n  }\n\n  const base = Object.assign({}, location, {\n    protocol: protocol || urlParsed.protocol,\n    host: location.host || urlParsed.host\n  })\n\n  return new URLWithLegacySupport(url, format(base)).toString()\n}\n","'use strict'\n\nconst isReactNative =\n    typeof navigator !== 'undefined' &&\n    navigator.product === 'ReactNative'\n\nfunction getDefaultBase () {\n  if (isReactNative) {\n    return 'http://localhost'\n  }\n  // in some environments i.e. cloudflare workers location is not available\n  if (!self.location) {\n    return ''\n  }\n\n  return self.location.protocol + '//' + self.location.host\n}\n\nconst URL = self.URL\nconst defaultBase = getDefaultBase()\n\nclass URLWithLegacySupport {\n  constructor (url = '', base = defaultBase) {\n    this.super = new URL(url, base)\n    this.path = this.pathname + this.search\n    this.auth =\n            this.username && this.password\n              ? this.username + ':' + this.password\n              : null\n\n    this.query =\n            this.search && this.search.startsWith('?')\n              ? this.search.slice(1)\n              : null\n  }\n\n  get hash () {\n    return this.super.hash\n  }\n\n  get host () {\n    return this.super.host\n  }\n\n  get hostname () {\n    return this.super.hostname\n  }\n\n  get href () {\n    return this.super.href\n  }\n\n  get origin () {\n    return this.super.origin\n  }\n\n  get password () {\n    return this.super.password\n  }\n\n  get pathname () {\n    return this.super.pathname\n  }\n\n  get port () {\n    return this.super.port\n  }\n\n  get protocol () {\n    return this.super.protocol\n  }\n\n  get search () {\n    return this.super.search\n  }\n\n  get searchParams () {\n    return this.super.searchParams\n  }\n\n  get username () {\n    return this.super.username\n  }\n\n  set hash (hash) {\n    this.super.hash = hash\n  }\n\n  set host (host) {\n    this.super.host = host\n  }\n\n  set hostname (hostname) {\n    this.super.hostname = hostname\n  }\n\n  set href (href) {\n    this.super.href = href\n  }\n\n  set password (password) {\n    this.super.password = password\n  }\n\n  set pathname (pathname) {\n    this.super.pathname = pathname\n  }\n\n  set port (port) {\n    this.super.port = port\n  }\n\n  set protocol (protocol) {\n    this.super.protocol = protocol\n  }\n\n  set search (search) {\n    this.super.search = search\n  }\n\n  set username (username) {\n    this.super.username = username\n  }\n\n  /**\n   * @param {any} o\n   */\n  static createObjectURL (o) {\n    return URL.createObjectURL(o)\n  }\n\n  /**\n   * @param {string} o\n   */\n  static revokeObjectURL (o) {\n    URL.revokeObjectURL(o)\n  }\n\n  toJSON () {\n    return this.super.toJSON()\n  }\n\n  toString () {\n    return this.super.toString()\n  }\n\n  format () {\n    return this.toString()\n  }\n}\n\n/**\n * @param {string | import('url').UrlObject} obj\n */\nfunction format (obj) {\n  if (typeof obj === 'string') {\n    const url = new URL(obj)\n\n    return url.toString()\n  }\n\n  if (!(obj instanceof URL)) {\n    const userPass =\n            // @ts-ignore its not supported in node but we normalise\n            obj.username && obj.password\n              // @ts-ignore its not supported in node but we normalise\n              ? `${obj.username}:${obj.password}@`\n              : ''\n    const auth = obj.auth ? obj.auth + '@' : ''\n    const port = obj.port ? ':' + obj.port : ''\n    const protocol = obj.protocol ? obj.protocol + '//' : ''\n    const host = obj.host || ''\n    const hostname = obj.hostname || ''\n    const search = obj.search || (obj.query ? '?' + obj.query : '')\n    const hash = obj.hash || ''\n    const pathname = obj.pathname || ''\n    // @ts-ignore - path is not supported in node but we normalise\n    const path = obj.path || pathname + search\n\n    return `${protocol}${userPass || auth}${\n            host || hostname + port\n        }${path}${hash}`\n  }\n}\n\nmodule.exports = {\n  URLWithLegacySupport,\n  URLSearchParams: self.URLSearchParams,\n  defaultBase,\n  format\n}\n","'use strict'\n\n/**\n * Collects all values from an (async) iterable into an array and returns it.\n *\n * @template T\n * @param {AsyncIterable<T>|Iterable<T>} source\n */\nconst all = async (source) => {\n  const arr = []\n\n  for await (const entry of source) {\n    arr.push(entry)\n  }\n\n  return arr\n}\n\nmodule.exports = all\n","'use strict';\nconst isOptionObject = require('is-plain-obj');\n\nconst {hasOwnProperty} = Object.prototype;\nconst {propertyIsEnumerable} = Object;\nconst defineProperty = (object, name, value) => Object.defineProperty(object, name, {\n\tvalue,\n\twritable: true,\n\tenumerable: true,\n\tconfigurable: true\n});\n\nconst globalThis = this;\nconst defaultMergeOptions = {\n\tconcatArrays: false,\n\tignoreUndefined: false\n};\n\nconst getEnumerableOwnPropertyKeys = value => {\n\tconst keys = [];\n\n\tfor (const key in value) {\n\t\tif (hasOwnProperty.call(value, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\n\t/* istanbul ignore else  */\n\tif (Object.getOwnPropertySymbols) {\n\t\tconst symbols = Object.getOwnPropertySymbols(value);\n\n\t\tfor (const symbol of symbols) {\n\t\t\tif (propertyIsEnumerable.call(value, symbol)) {\n\t\t\t\tkeys.push(symbol);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn keys;\n};\n\nfunction clone(value) {\n\tif (Array.isArray(value)) {\n\t\treturn cloneArray(value);\n\t}\n\n\tif (isOptionObject(value)) {\n\t\treturn cloneOptionObject(value);\n\t}\n\n\treturn value;\n}\n\nfunction cloneArray(array) {\n\tconst result = array.slice(0, 0);\n\n\tgetEnumerableOwnPropertyKeys(array).forEach(key => {\n\t\tdefineProperty(result, key, clone(array[key]));\n\t});\n\n\treturn result;\n}\n\nfunction cloneOptionObject(object) {\n\tconst result = Object.getPrototypeOf(object) === null ? Object.create(null) : {};\n\n\tgetEnumerableOwnPropertyKeys(object).forEach(key => {\n\t\tdefineProperty(result, key, clone(object[key]));\n\t});\n\n\treturn result;\n}\n\n/**\n * @param {*} merged already cloned\n * @param {*} source something to merge\n * @param {string[]} keys keys to merge\n * @param {Object} config Config Object\n * @returns {*} cloned Object\n */\nconst mergeKeys = (merged, source, keys, config) => {\n\tkeys.forEach(key => {\n\t\tif (typeof source[key] === 'undefined' && config.ignoreUndefined) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Do not recurse into prototype chain of merged\n\t\tif (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {\n\t\t\tdefineProperty(merged, key, merge(merged[key], source[key], config));\n\t\t} else {\n\t\t\tdefineProperty(merged, key, clone(source[key]));\n\t\t}\n\t});\n\n\treturn merged;\n};\n\n/**\n * @param {*} merged already cloned\n * @param {*} source something to merge\n * @param {Object} config Config Object\n * @returns {*} cloned Object\n *\n * see [Array.prototype.concat ( ...arguments )](http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat)\n */\nconst concatArrays = (merged, source, config) => {\n\tlet result = merged.slice(0, 0);\n\tlet resultIndex = 0;\n\n\t[merged, source].forEach(array => {\n\t\tconst indices = [];\n\n\t\t// `result.concat(array)` with cloning\n\t\tfor (let k = 0; k < array.length; k++) {\n\t\t\tif (!hasOwnProperty.call(array, k)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tindices.push(String(k));\n\n\t\t\tif (array === merged) {\n\t\t\t\t// Already cloned\n\t\t\t\tdefineProperty(result, resultIndex++, array[k]);\n\t\t\t} else {\n\t\t\t\tdefineProperty(result, resultIndex++, clone(array[k]));\n\t\t\t}\n\t\t}\n\n\t\t// Merge non-index keys\n\t\tresult = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter(key => !indices.includes(key)), config);\n\t});\n\n\treturn result;\n};\n\n/**\n * @param {*} merged already cloned\n * @param {*} source something to merge\n * @param {Object} config Config Object\n * @returns {*} cloned Object\n */\nfunction merge(merged, source, config) {\n\tif (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {\n\t\treturn concatArrays(merged, source, config);\n\t}\n\n\tif (!isOptionObject(source) || !isOptionObject(merged)) {\n\t\treturn clone(source);\n\t}\n\n\treturn mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);\n}\n\nmodule.exports = function (...options) {\n\tconst config = merge(clone(defaultMergeOptions), (this !== globalThis && this) || {}, defaultMergeOptions);\n\tlet merged = {_: {}};\n\n\tfor (const option of options) {\n\t\tif (option === undefined) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!isOptionObject(option)) {\n\t\t\tthrow new TypeError('`' + option + '` is not an Option Object');\n\t\t}\n\n\t\tmerged = merge(merged, {_: option}, config);\n\t}\n\n\treturn merged._;\n};\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","'use strict'\n\nif (globalThis.fetch && globalThis.Headers && globalThis.Request && globalThis.Response) {\n  module.exports = {\n    default: globalThis.fetch,\n    Headers: globalThis.Headers,\n    Request: globalThis.Request,\n    Response: globalThis.Response\n  }\n} else {\n  module.exports = {\n    default: require('node-fetch').default,\n    Headers: require('node-fetch').Headers,\n    Request: require('node-fetch').Request,\n    Response: require('node-fetch').Response\n  }\n}\n","\"use strict\";\n\n// ref: https://github.com/tc39/proposal-global\nvar getGlobal = function () {\n\t// the only reliable means to get the global object is\n\t// `Function('return this')()`\n\t// However, this causes CSP violations in Chrome apps.\n\tif (typeof self !== 'undefined') { return self; }\n\tif (typeof window !== 'undefined') { return window; }\n\tif (typeof global !== 'undefined') { return global; }\n\tthrow new Error('unable to locate global object');\n}\n\nvar globalObject = getGlobal();\n\nmodule.exports = exports = globalObject.fetch;\n\n// Needed for TypeScript and Webpack.\nif (globalObject.fetch) {\n\texports.default = globalObject.fetch.bind(globalObject);\n}\n\nexports.Headers = globalObject.Headers;\nexports.Request = globalObject.Request;\nexports.Response = globalObject.Response;\n","module.exports = readable => {\n  // Node.js stream\n  if (readable[Symbol.asyncIterator]) return readable\n\n  // Browser ReadableStream\n  if (readable.getReader) {\n    return (async function * () {\n      const reader = readable.getReader()\n\n      try {\n        while (true) {\n          const { done, value } = await reader.read()\n          if (done) return\n          yield value\n        }\n      } finally {\n        reader.releaseLock()\n      }\n    })()\n  }\n\n  throw new Error('unknown stream')\n}\n","module.exports = read\n\nvar MSB = 0x80\n  , REST = 0x7F\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length\n\n  do {\n    if (counter >= l || shift > 49) {\n      read.bytes = 0\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++]\n    res += shift < 28\n      ? (b & REST) << shift\n      : (b & REST) * Math.pow(2, shift)\n    shift += 7\n  } while (b >= MSB)\n\n  read.bytes = counter - offset\n\n  return res\n}\n","module.exports = encode\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31)\n\nfunction encode(num, out, offset) {\n  if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {\n    encode.bytes = 0\n    throw new RangeError('Could not encode varint')\n  }\n  out = out || []\n  offset = offset || 0\n  var oldOffset = offset\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB\n    num /= 128\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB\n    num >>>= 7\n  }\n  out[offset] = num | 0\n  \n  encode.bytes = offset - oldOffset + 1\n  \n  return out\n}\n","module.exports = {\n    encode: require('./encode.js')\n  , decode: require('./decode.js')\n  , encodingLength: require('./length.js')\n}\n","\nvar N1 = Math.pow(2,  7)\nvar N2 = Math.pow(2, 14)\nvar N3 = Math.pow(2, 21)\nvar N4 = Math.pow(2, 28)\nvar N5 = Math.pow(2, 35)\nvar N6 = Math.pow(2, 42)\nvar N7 = Math.pow(2, 49)\nvar N8 = Math.pow(2, 56)\nvar N9 = Math.pow(2, 63)\n\nmodule.exports = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n}\n","/* (ignored) */","/**\n * Thin ESM wrapper for CJS named exports.\n *\n * Ref: https://redfin.engineering/node-modules-at-war-why-commonjs-and-es-modules-cant-get-along-9617135eeca1\n */\n\nimport mergeOptions from './index.js';\nexport default mergeOptions;\n","let durationRE = /(-?(?:\\d+\\.?\\d*|\\d*\\.?\\d+)(?:e[-+]?\\d+)?)\\s*([\\p{L}]*)/uig\r\n\r\n\r\n/**\r\n * conversion ratios\r\n */\r\n\r\nparse.nanosecond =\r\nparse.ns = 1 / 1e6\r\n\r\nparse['s'] =\r\nparse['s'] =\r\nparse.us =\r\nparse.microsecond = 1 / 1e3\r\n\r\nparse.millisecond =\r\nparse.ms =\r\nparse[''] = 1\r\n\r\nparse.second =\r\nparse.sec =\r\nparse.s = parse.ms * 1000\r\n\r\nparse.minute =\r\nparse.min =\r\nparse.m = parse.s * 60\r\n\r\nparse.hour =\r\nparse.hr =\r\nparse.h = parse.m * 60\r\n\r\nparse.day =\r\nparse.d = parse.h * 24\r\n\r\nparse.week =\r\nparse.wk =\r\nparse.w = parse.d * 7\r\n\r\nparse.month =\r\nparse.b =\r\nparse.d * (365.25 / 12)\r\n\r\nparse.year =\r\nparse.yr =\r\nparse.y = parse.d * 365.25\r\n\r\n/**\r\n * convert `str` to ms\r\n *\r\n * @param {String} str\r\n * @param {String} format\r\n * @return {Number}\r\n */\r\n\r\nfunction parse(str='', format='ms'){\r\n  var result = null\r\n  // ignore commas/placeholders\r\n  str = (str+'').replace(/(\\d)[,_](\\d)/g, '$1$2')\r\n  str.replace(durationRE, function(_, n, units){\r\n    units = unitRatio(units)\r\n    if (units) result = (result || 0) + parseFloat(n, 10) * units\r\n  })\r\n\r\n  return result && (result / (unitRatio(format) || 1))\r\n}\r\n\r\nfunction unitRatio(str) {\r\n  return parse[str] || parse[str.toLowerCase().replace(/s$/, '')]\r\n}\r\n\r\nexport default parse\r\n","/* eslint-disable @typescript-eslint/no-unsafe-return */\nexport class Parser {\n    index = 0;\n    input = \"\";\n    new(input) {\n        this.index = 0;\n        this.input = input;\n        return this;\n    }\n    /** Run a parser, and restore the pre-parse state if it fails. */\n    readAtomically(fn) {\n        const index = this.index;\n        const result = fn();\n        if (result === undefined) {\n            this.index = index;\n        }\n        return result;\n    }\n    /** Run a parser, but fail if the entire input wasn't consumed. Doesn't run atomically. */\n    parseWith(fn) {\n        const result = fn();\n        if (this.index !== this.input.length) {\n            return undefined;\n        }\n        return result;\n    }\n    /** Peek the next character from the input */\n    peekChar() {\n        if (this.index >= this.input.length) {\n            return undefined;\n        }\n        return this.input[this.index];\n    }\n    /** Read the next character from the input */\n    readChar() {\n        if (this.index >= this.input.length) {\n            return undefined;\n        }\n        return this.input[this.index++];\n    }\n    /** Read the next character from the input if it matches the target. */\n    readGivenChar(target) {\n        return this.readAtomically(() => {\n            const char = this.readChar();\n            if (char !== target) {\n                return undefined;\n            }\n            return char;\n        });\n    }\n    /**\n     * Helper for reading separators in an indexed loop. Reads the separator\n     * character iff index > 0, then runs the parser. When used in a loop,\n     * the separator character will only be read on index > 0 (see\n     * readIPv4Addr for an example)\n     */\n    readSeparator(sep, index, inner) {\n        return this.readAtomically(() => {\n            if (index > 0) {\n                if (this.readGivenChar(sep) === undefined) {\n                    return undefined;\n                }\n            }\n            return inner();\n        });\n    }\n    /**\n     * Read a number off the front of the input in the given radix, stopping\n     * at the first non-digit character or eof. Fails if the number has more\n     * digits than max_digits or if there is no number.\n     */\n    readNumber(radix, maxDigits, allowZeroPrefix, maxBytes) {\n        return this.readAtomically(() => {\n            let result = 0;\n            let digitCount = 0;\n            const leadingChar = this.peekChar();\n            if (leadingChar === undefined) {\n                return undefined;\n            }\n            const hasLeadingZero = leadingChar === \"0\";\n            const maxValue = 2 ** (8 * maxBytes) - 1;\n            // eslint-disable-next-line no-constant-condition\n            while (true) {\n                const digit = this.readAtomically(() => {\n                    const char = this.readChar();\n                    if (char === undefined) {\n                        return undefined;\n                    }\n                    const num = Number.parseInt(char, radix);\n                    if (Number.isNaN(num)) {\n                        return undefined;\n                    }\n                    return num;\n                });\n                if (digit === undefined) {\n                    break;\n                }\n                result *= radix;\n                result += digit;\n                if (result > maxValue) {\n                    return undefined;\n                }\n                digitCount += 1;\n                if (maxDigits !== undefined) {\n                    if (digitCount > maxDigits) {\n                        return undefined;\n                    }\n                }\n            }\n            if (digitCount === 0) {\n                return undefined;\n            }\n            else if (!allowZeroPrefix && hasLeadingZero && digitCount > 1) {\n                return undefined;\n            }\n            else {\n                return result;\n            }\n        });\n    }\n    /** Read an IPv4 address. */\n    readIPv4Addr() {\n        return this.readAtomically(() => {\n            const out = new Uint8Array(4);\n            for (let i = 0; i < out.length; i++) {\n                const ix = this.readSeparator(\".\", i, () => this.readNumber(10, 3, false, 1));\n                if (ix === undefined) {\n                    return undefined;\n                }\n                out[i] = ix;\n            }\n            return out;\n        });\n    }\n    /** Read an IPv6 Address. */\n    readIPv6Addr() {\n        /**\n         * Read a chunk of an IPv6 address into `groups`. Returns the number\n         * of groups read, along with a bool indicating if an embedded\n         * trailing IPv4 address was read. Specifically, read a series of\n         * colon-separated IPv6 groups (0x0000 - 0xFFFF), with an optional\n         * trailing embedded IPv4 address.\n         */\n        const readGroups = (groups) => {\n            for (let i = 0; i < groups.length / 2; i++) {\n                const ix = i * 2;\n                // Try to read a trailing embedded IPv4 address. There must be at least 4 groups left.\n                if (i < groups.length - 3) {\n                    const ipv4 = this.readSeparator(\":\", i, () => this.readIPv4Addr());\n                    if (ipv4 !== undefined) {\n                        groups[ix] = ipv4[0];\n                        groups[ix + 1] = ipv4[1];\n                        groups[ix + 2] = ipv4[2];\n                        groups[ix + 3] = ipv4[3];\n                        return [ix + 4, true];\n                    }\n                }\n                const group = this.readSeparator(\":\", i, () => this.readNumber(16, 4, true, 2));\n                if (group === undefined) {\n                    return [ix, false];\n                }\n                groups[ix] = group >> 8;\n                groups[ix + 1] = group & 255;\n            }\n            return [groups.length, false];\n        };\n        return this.readAtomically(() => {\n            // Read the front part of the address; either the whole thing, or up to the first ::\n            const head = new Uint8Array(16);\n            const [headSize, headIp4] = readGroups(head);\n            if (headSize === 16) {\n                return head;\n            }\n            // IPv4 part is not allowed before `::`\n            if (headIp4) {\n                return undefined;\n            }\n            // Read `::` if previous code parsed less than 8 groups.\n            // `::` indicates one or more groups of 16 bits of zeros.\n            if (this.readGivenChar(\":\") === undefined) {\n                return undefined;\n            }\n            if (this.readGivenChar(\":\") === undefined) {\n                return undefined;\n            }\n            // Read the back part of the address. The :: must contain at least one\n            // set of zeroes, so our max length is 7.\n            const tail = new Uint8Array(14);\n            const limit = 16 - (headSize + 2);\n            const [tailSize] = readGroups(tail.subarray(0, limit));\n            // Concat the head and tail of the IP address\n            head.set(tail.subarray(0, tailSize), 16 - tailSize);\n            return head;\n        });\n    }\n    /** Read an IP Address, either IPv4 or IPv6. */\n    readIPAddr() {\n        return this.readIPv4Addr() ?? this.readIPv6Addr();\n    }\n}\n","import { Parser } from \"./parser.js\";\n// See https://stackoverflow.com/questions/166132/maximum-length-of-the-textual-representation-of-an-ipv6-address\nconst MAX_IPV6_LENGTH = 45;\nconst MAX_IPV4_LENGTH = 15;\nconst parser = new Parser();\n/** Parse `input` into IPv4 bytes. */\nexport function parseIPv4(input) {\n    if (input.length > MAX_IPV4_LENGTH) {\n        return undefined;\n    }\n    return parser.new(input).parseWith(() => parser.readIPv4Addr());\n}\n/** Parse `input` into IPv6 bytes. */\nexport function parseIPv6(input) {\n    if (input.length > MAX_IPV6_LENGTH) {\n        return undefined;\n    }\n    return parser.new(input).parseWith(() => parser.readIPv6Addr());\n}\n/** Parse `input` into IPv4 or IPv6 bytes. */\nexport function parseIP(input) {\n    if (input.length > MAX_IPV6_LENGTH) {\n        return undefined;\n    }\n    return parser.new(input).parseWith(() => parser.readIPAddr());\n}\n","import { parseIP, parseIPv4, parseIPv6 } from \"./parse.js\";\n/** Check if `input` is IPv4. */\nexport function isIPv4(input) {\n    return Boolean(parseIPv4(input));\n}\n/** Check if `input` is IPv6. */\nexport function isIPv6(input) {\n    return Boolean(parseIPv6(input));\n}\n/** Check if `input` is IPv4 or IPv6. */\nexport function isIP(input) {\n    return Boolean(parseIP(input));\n}\n/**\n * @returns `6` if `input` is IPv6, `4` if `input` is IPv4, or `undefined` if `input` is neither.\n */\nexport function ipVersion(input) {\n    if (isIPv4(input)) {\n        return 4;\n    }\n    else if (isIPv6(input)) {\n        return 6;\n    }\n    else {\n        return undefined;\n    }\n}\n","import * as cborg from 'cborg'\nimport { CID } from 'multiformats/cid'\n\n// https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692\nconst CID_CBOR_TAG = 42\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n\n/**\n * cidEncoder will receive all Objects during encode, it needs to filter out\n * anything that's not a CID and return `null` for that so it's encoded as\n * normal.\n *\n * @param {any} obj\n * @returns {cborg.Token[]|null}\n */\nfunction cidEncoder (obj) {\n  if (obj.asCID !== obj && obj['/'] !== obj.bytes) {\n    return null // any other kind of object\n  }\n  const cid = CID.asCID(obj)\n  /* c8 ignore next 4 */\n  // very unlikely case, and it'll probably throw a recursion error in cborg\n  if (!cid) {\n    return null\n  }\n  const bytes = new Uint8Array(cid.bytes.byteLength + 1)\n  bytes.set(cid.bytes, 1) // prefix is 0x00, for historical reasons\n  return [\n    new cborg.Token(cborg.Type.tag, CID_CBOR_TAG),\n    new cborg.Token(cborg.Type.bytes, bytes)\n  ]\n}\n\n// eslint-disable-next-line jsdoc/require-returns-check\n/**\n * Intercept all `undefined` values from an object walk and reject the entire\n * object if we find one.\n *\n * @returns {null}\n */\nfunction undefinedEncoder () {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded')\n}\n\n/**\n * Intercept all `number` values from an object walk and reject the entire\n * object if we find something that doesn't fit the IPLD data model (NaN &\n * Infinity).\n *\n * @param {number} num\n * @returns {null}\n */\nfunction numberEncoder (num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  return null\n}\n\nconst encodeOptions = {\n  float64: true,\n  typeEncoders: {\n    Object: cidEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {CID}\n */\nfunction cidDecoder (bytes) {\n  if (bytes[0] !== 0) {\n    throw new Error('Invalid CID for CBOR tag 42; expected leading 0x00')\n  }\n  return CID.decode(bytes.subarray(1)) // ignore leading 0x00\n}\n\nconst decodeOptions = {\n  allowIndefinite: false,\n  coerceUndefinedToNull: true,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true, // this will lead to BigInt for ints outside of\n  // safe-integer range, which may surprise users\n  strict: true,\n  useMaps: false,\n  rejectDuplicateMapKeys: true,\n  /** @type {import('cborg').TagDecoder[]} */\n  tags: []\n}\ndecodeOptions.tags[CID_CBOR_TAG] = cidDecoder\n\nexport const name = 'dag-cbor'\nexport const code = 0x71\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = (node) => cborg.encode(node, encodeOptions)\n\n/**\n * @template T\n * @param {ByteView<T>} data\n * @returns {T}\n */\nexport const decode = (data) => cborg.decode(data, decodeOptions)\n","/* eslint max-depth: [\"error\", 7] */\nimport { CID } from 'multiformats'\nimport { base64 } from 'multiformats/bases/base64'\nimport { Token, Type } from 'cborg'\nimport * as cborgJson from 'cborg/json'\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n/**\n * @template T\n * @typedef {import('multiformats').ToString<T>} ToString\n */\n/**\n * @typedef {import('cborg/interface').DecodeTokenizer} DecodeTokenizer\n */\n\n/**\n * cidEncoder will receive all Objects during encode, it needs to filter out\n * anything that's not a CID and return `null` for that so it's encoded as\n * normal. Encoding a CID means replacing it with a `{\"/\":\"<CidString>}`\n * object as per the DAG-JSON spec.\n *\n * @param {any} obj\n * @returns {Token[]|null}\n */\nfunction cidEncoder (obj) {\n  if (obj.asCID !== obj && obj['/'] !== obj.bytes) {\n    return null // any other kind of object\n  }\n  const cid = CID.asCID(obj)\n  /* c8 ignore next 4 */\n  // very unlikely case, and it'll probably throw a recursion error in cborg\n  if (!cid) {\n    return null\n  }\n  const cidString = cid.toString()\n\n  return [\n    new Token(Type.map, Infinity, 1),\n    new Token(Type.string, '/', 1), // key\n    new Token(Type.string, cidString, cidString.length), // value\n    new Token(Type.break, undefined, 1)\n  ]\n}\n\n/**\n * bytesEncoder will receive all Uint8Arrays (and friends) during encode, it\n * needs to replace it with a `{\"/\":{\"bytes\":\"Base64ByteString\"}}` object as\n * per the DAG-JSON spec.\n *\n * @param {Uint8Array} bytes\n * @returns {Token[]|null}\n */\nfunction bytesEncoder (bytes) {\n  const bytesString = base64.encode(bytes).slice(1) // no mbase prefix\n  return [\n    new Token(Type.map, Infinity, 1),\n    new Token(Type.string, '/', 1), // key\n    new Token(Type.map, Infinity, 1), // value\n    new Token(Type.string, 'bytes', 5), // inner key\n    new Token(Type.string, bytesString, bytesString.length), // inner value\n    new Token(Type.break, undefined, 1),\n    new Token(Type.break, undefined, 1)\n  ]\n}\n\n// eslint-disable-next-line jsdoc/require-returns-check\n/**\n * Intercept all `undefined` values from an object walk and reject the entire\n * object if we find one.\n *\n * @returns {null}\n */\nfunction undefinedEncoder () {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded')\n}\n\n/**\n * Intercept all `number` values from an object walk and reject the entire\n * object if we find something that doesn't fit the IPLD data model (NaN &\n * Infinity).\n *\n * @param {number} num\n * @returns {null}\n */\nfunction numberEncoder (num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  return null // process with standard number encoder\n}\n\nconst encodeOptions = {\n  typeEncoders: {\n    Object: cidEncoder,\n    Uint8Array: bytesEncoder, // TODO: all the typedarrays\n    Buffer: bytesEncoder, // TODO: all the typedarrays\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n}\n\n/**\n * @implements {DecodeTokenizer}\n */\nclass DagJsonTokenizer extends cborgJson.Tokenizer {\n  /**\n   * @param {Uint8Array} data\n   * @param {object} [options]\n   */\n  constructor (data, options) {\n    super(data, options)\n    /** @type {Token[]} */\n    this.tokenBuffer = []\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  done () {\n    return this.tokenBuffer.length === 0 && super.done()\n  }\n\n  /**\n   * @returns {Token}\n   */\n  _next () {\n    if (this.tokenBuffer.length > 0) {\n      // @ts-ignore https://github.com/Microsoft/TypeScript/issues/30406\n      return this.tokenBuffer.pop()\n    }\n    return super.next()\n  }\n\n  /**\n   * Implements rules outlined in https://github.com/ipld/specs/pull/356\n   *\n   * @returns {Token}\n   */\n  next () {\n    const token = this._next()\n\n    if (token.type === Type.map) {\n      const keyToken = this._next()\n      if (keyToken.type === Type.string && keyToken.value === '/') {\n        const valueToken = this._next()\n        if (valueToken.type === Type.string) { // *must* be a CID\n          const breakToken = this._next() // swallow the end-of-map token\n          if (breakToken.type !== Type.break) {\n            throw new Error('Invalid encoded CID form')\n          }\n          this.tokenBuffer.push(valueToken) // CID.parse will pick this up after our tag token\n          return new Token(Type.tag, 42, 0)\n        }\n        if (valueToken.type === Type.map) {\n          const innerKeyToken = this._next()\n          if (innerKeyToken.type === Type.string && innerKeyToken.value === 'bytes') {\n            const innerValueToken = this._next()\n            if (innerValueToken.type === Type.string) { // *must* be Bytes\n              for (let i = 0; i < 2; i++) {\n                const breakToken = this._next() // swallow two end-of-map tokens\n                if (breakToken.type !== Type.break) {\n                  throw new Error('Invalid encoded Bytes form')\n                }\n              }\n              const bytes = base64.decode(`m${innerValueToken.value}`)\n              return new Token(Type.bytes, bytes, innerValueToken.value.length)\n            }\n            this.tokenBuffer.push(innerValueToken) // bail\n          }\n          this.tokenBuffer.push(innerKeyToken) // bail\n        }\n        this.tokenBuffer.push(valueToken) // bail\n      }\n      this.tokenBuffer.push(keyToken) // bail\n    }\n    return token\n  }\n}\n\nconst decodeOptions = {\n  allowIndefinite: false,\n  allowUndefined: false,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true, // this will lead to BigInt for ints outside of\n  // safe-integer range, which may surprise users\n  strict: true,\n  useMaps: false,\n  rejectDuplicateMapKeys: true,\n  /** @type {import('cborg').TagDecoder[]} */\n  tags: []\n}\n\n// we're going to get TAG(42)STRING(\"bafy...\") from the tokenizer so we only need\n// to deal with the STRING(\"bafy...\") at this point\ndecodeOptions.tags[42] = CID.parse\n\nexport const name = 'dag-json'\nexport const code = 0x0129\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = (node) => cborgJson.encode(node, encodeOptions)\n\n/**\n * @template T\n * @param {ByteView<T>} data\n * @returns {T}\n */\nexport const decode = (data) => {\n  // the tokenizer is stateful so we need a single instance of it\n  const options = Object.assign(decodeOptions, { tokenizer: new DagJsonTokenizer(data, decodeOptions) })\n  return cborgJson.decode(data, options)\n}\n\n/**\n * @template T\n * @param {T} node\n * @returns {ToString<T>}\n */\nexport const format = (node) => utf8Decoder.decode(encode(node))\nexport { format as stringify }\nconst utf8Decoder = new TextDecoder()\n\n/**\n * @template T\n * @param {ToString<T>} data\n * @returns {T}\n */\nexport const parse = (data) => decode(utf8Encoder.encode(data))\nconst utf8Encoder = new TextEncoder()\n","const textDecoder = new TextDecoder()\n\n/**\n * @typedef {import('./interface').RawPBLink} RawPBLink\n */\n\n/**\n * @typedef {import('./interface').RawPBNode} RawPBNode\n */\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {[number, number]}\n */\nfunction decodeVarint (bytes, offset) {\n  let v = 0\n\n  for (let shift = 0; ; shift += 7) {\n    /* c8 ignore next 3 */\n    if (shift >= 64) {\n      throw new Error('protobuf: varint overflow')\n    }\n    /* c8 ignore next 3 */\n    if (offset >= bytes.length) {\n      throw new Error('protobuf: unexpected end of data')\n    }\n\n    const b = bytes[offset++]\n    v += shift < 28 ? (b & 0x7f) << shift : (b & 0x7f) * (2 ** shift)\n    if (b < 0x80) {\n      break\n    }\n  }\n  return [v, offset]\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {[Uint8Array, number]}\n */\nfunction decodeBytes (bytes, offset) {\n  let byteLen\n  ;[byteLen, offset] = decodeVarint(bytes, offset)\n  const postOffset = offset + byteLen\n\n  /* c8 ignore next 3 */\n  if (byteLen < 0 || postOffset < 0) {\n    throw new Error('protobuf: invalid length')\n  }\n  /* c8 ignore next 3 */\n  if (postOffset > bytes.length) {\n    throw new Error('protobuf: unexpected end of data')\n  }\n\n  return [bytes.subarray(offset, postOffset), postOffset]\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} index\n * @returns {[number, number, number]}\n */\nfunction decodeKey (bytes, index) {\n  let wire\n  ;[wire, index] = decodeVarint(bytes, index)\n  // [wireType, fieldNum, newIndex]\n  return [wire & 0x7, wire >> 3, index]\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {RawPBLink}\n */\nfunction decodeLink (bytes) {\n  /** @type {RawPBLink} */\n  const link = {}\n  const l = bytes.length\n  let index = 0\n\n  while (index < l) {\n    let wireType, fieldNum\n    ;[wireType, fieldNum, index] = decodeKey(bytes, index)\n\n    if (fieldNum === 1) {\n      if (link.Hash) {\n        throw new Error('protobuf: (PBLink) duplicate Hash section')\n      }\n      if (wireType !== 2) {\n        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`)\n      }\n      if (link.Name !== undefined) {\n        throw new Error('protobuf: (PBLink) invalid order, found Name before Hash')\n      }\n      if (link.Tsize !== undefined) {\n        throw new Error('protobuf: (PBLink) invalid order, found Tsize before Hash')\n      }\n\n      [link.Hash, index] = decodeBytes(bytes, index)\n    } else if (fieldNum === 2) {\n      if (link.Name !== undefined) {\n        throw new Error('protobuf: (PBLink) duplicate Name section')\n      }\n      if (wireType !== 2) {\n        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`)\n      }\n      if (link.Tsize !== undefined) {\n        throw new Error('protobuf: (PBLink) invalid order, found Tsize before Name')\n      }\n\n      let byts\n      ;[byts, index] = decodeBytes(bytes, index)\n      link.Name = textDecoder.decode(byts)\n    } else if (fieldNum === 3) {\n      if (link.Tsize !== undefined) {\n        throw new Error('protobuf: (PBLink) duplicate Tsize section')\n      }\n      if (wireType !== 0) {\n        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`)\n      }\n\n      [link.Tsize, index] = decodeVarint(bytes, index)\n    } else {\n      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`)\n    }\n  }\n\n  /* c8 ignore next 3 */\n  if (index > l) {\n    throw new Error('protobuf: (PBLink) unexpected end of data')\n  }\n\n  return link\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {RawPBNode}\n */\nexport function decodeNode (bytes) {\n  const l = bytes.length\n  let index = 0\n  /** @type {RawPBLink[]|void} */\n  let links\n  let linksBeforeData = false\n  /** @type {Uint8Array|void} */\n  let data\n\n  while (index < l) {\n    let wireType, fieldNum\n    ;[wireType, fieldNum, index] = decodeKey(bytes, index)\n\n    if (wireType !== 2) {\n      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`)\n    }\n\n    if (fieldNum === 1) {\n      if (data) {\n        throw new Error('protobuf: (PBNode) duplicate Data section')\n      }\n\n      [data, index] = decodeBytes(bytes, index)\n      if (links) {\n        linksBeforeData = true\n      }\n    } else if (fieldNum === 2) {\n      if (linksBeforeData) { // interleaved Links/Data/Links\n        throw new Error('protobuf: (PBNode) duplicate Links section')\n      } else if (!links) {\n        links = []\n      }\n      let byts\n      ;[byts, index] = decodeBytes(bytes, index)\n      links.push(decodeLink(byts))\n    } else {\n      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`)\n    }\n  }\n\n  /* c8 ignore next 3 */\n  if (index > l) {\n    throw new Error('protobuf: (PBNode) unexpected end of data')\n  }\n\n  /** @type {RawPBNode} */\n  const node = {}\n  if (data) {\n    node.Data = data\n  }\n  node.Links = links || []\n  return node\n}\n","const textEncoder = new TextEncoder()\nconst maxInt32 = 2 ** 32\nconst maxUInt32 = 2 ** 31\n\n/**\n * @typedef {import('./interface').RawPBLink} RawPBLink\n */\n\n/**\n * @typedef {import('./interface').RawPBNode} RawPBNode\n */\n\n// the encoders work backward from the end of the bytes array\n\n/**\n * encodeLink() is passed a slice of the parent byte array that ends where this\n * link needs to end, so it packs to the right-most part of the passed `bytes`\n *\n * @param {RawPBLink} link\n * @param {Uint8Array} bytes\n * @returns {number}\n */\nfunction encodeLink (link, bytes) {\n  let i = bytes.length\n\n  if (typeof link.Tsize === 'number') {\n    if (link.Tsize < 0) {\n      throw new Error('Tsize cannot be negative')\n    }\n    if (!Number.isSafeInteger(link.Tsize)) {\n      throw new Error('Tsize too large for encoding')\n    }\n    i = encodeVarint(bytes, i, link.Tsize) - 1\n    bytes[i] = 0x18\n  }\n\n  if (typeof link.Name === 'string') {\n    const nameBytes = textEncoder.encode(link.Name)\n    i -= nameBytes.length\n    bytes.set(nameBytes, i)\n    i = encodeVarint(bytes, i, nameBytes.length) - 1\n    bytes[i] = 0x12\n  }\n\n  if (link.Hash) {\n    i -= link.Hash.length\n    bytes.set(link.Hash, i)\n    i = encodeVarint(bytes, i, link.Hash.length) - 1\n    bytes[i] = 0xa\n  }\n\n  return bytes.length - i\n}\n\n/**\n * Encodes a PBNode into a new byte array of precisely the correct size\n *\n * @param {RawPBNode} node\n * @returns {Uint8Array}\n */\nexport function encodeNode (node) {\n  const size = sizeNode(node)\n  const bytes = new Uint8Array(size)\n  let i = size\n\n  if (node.Data) {\n    i -= node.Data.length\n    bytes.set(node.Data, i)\n    i = encodeVarint(bytes, i, node.Data.length) - 1\n    bytes[i] = 0xa\n  }\n\n  if (node.Links) {\n    for (let index = node.Links.length - 1; index >= 0; index--) {\n      const size = encodeLink(node.Links[index], bytes.subarray(0, i))\n      i -= size\n      i = encodeVarint(bytes, i, size) - 1\n      bytes[i] = 0x12\n    }\n  }\n\n  return bytes\n}\n\n/**\n * work out exactly how many bytes this link takes up\n *\n * @param {RawPBLink} link\n * @returns\n */\nfunction sizeLink (link) {\n  let n = 0\n\n  if (link.Hash) {\n    const l = link.Hash.length\n    n += 1 + l + sov(l)\n  }\n\n  if (typeof link.Name === 'string') {\n    const l = textEncoder.encode(link.Name).length\n    n += 1 + l + sov(l)\n  }\n\n  if (typeof link.Tsize === 'number') {\n    n += 1 + sov(link.Tsize)\n  }\n\n  return n\n}\n\n/**\n * Work out exactly how many bytes this node takes up\n *\n * @param {RawPBNode} node\n * @returns {number}\n */\nfunction sizeNode (node) {\n  let n = 0\n\n  if (node.Data) {\n    const l = node.Data.length\n    n += 1 + l + sov(l)\n  }\n\n  if (node.Links) {\n    for (const link of node.Links) {\n      const l = sizeLink(link)\n      n += 1 + l + sov(l)\n    }\n  }\n\n  return n\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @param {number} v\n * @returns {number}\n */\nfunction encodeVarint (bytes, offset, v) {\n  offset -= sov(v)\n  const base = offset\n\n  while (v >= maxUInt32) {\n    bytes[offset++] = (v & 0x7f) | 0x80\n    v /= 128\n  }\n\n  while (v >= 128) {\n    bytes[offset++] = (v & 0x7f) | 0x80\n    v >>>= 7\n  }\n\n  bytes[offset] = v\n\n  return base\n}\n\n/**\n * size of varint\n *\n * @param {number} x\n * @returns {number}\n */\nfunction sov (x) {\n  if (x % 2 === 0) {\n    x++\n  }\n  return Math.floor((len64(x) + 6) / 7)\n}\n\n/**\n * golang math/bits, how many bits does it take to represent this integer?\n *\n * @param {number} x\n * @returns {number}\n */\nfunction len64 (x) {\n  let n = 0\n  if (x >= maxInt32) {\n    x = Math.floor(x / maxInt32)\n    n = 32\n  }\n  if (x >= (1 << 16)) {\n    x >>>= 16\n    n += 16\n  }\n  if (x >= (1 << 8)) {\n    x >>>= 8\n    n += 8\n  }\n  return n + len8tab[x]\n}\n\n// golang math/bits\nconst len8tab = [\n  0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,\n  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8\n]\n","import { CID } from 'multiformats/cid'\n\n/**\n * @typedef {import('./interface').PBLink} PBLink\n * @typedef {import('./interface').PBNode} PBNode\n */\n\nconst pbNodeProperties = ['Data', 'Links']\nconst pbLinkProperties = ['Hash', 'Name', 'Tsize']\n\nconst textEncoder = new TextEncoder()\n\n/**\n * @param {PBLink} a\n * @param {PBLink} b\n * @returns {number}\n */\nfunction linkComparator (a, b) {\n  if (a === b) {\n    return 0\n  }\n\n  const abuf = a.Name ? textEncoder.encode(a.Name) : []\n  const bbuf = b.Name ? textEncoder.encode(b.Name) : []\n\n  let x = abuf.length\n  let y = bbuf.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (abuf[i] !== bbuf[i]) {\n      x = abuf[i]\n      y = bbuf[i]\n      break\n    }\n  }\n\n  return x < y ? -1 : y < x ? 1 : 0\n}\n\n/**\n * @param {any} node\n * @param {string[]} properties\n * @returns {boolean}\n */\nfunction hasOnlyProperties (node, properties) {\n  return !Object.keys(node).some((p) => !properties.includes(p))\n}\n\n/**\n * Converts a CID, or a PBLink-like object to a PBLink\n *\n * @param {any} link\n * @returns {PBLink}\n */\nfunction asLink (link) {\n  if (typeof link.asCID === 'object') {\n    const Hash = CID.asCID(link)\n    if (!Hash) {\n      throw new TypeError('Invalid DAG-PB form')\n    }\n    return { Hash }\n  }\n\n  if (typeof link !== 'object' || Array.isArray(link)) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  const pbl = {}\n\n  if (link.Hash) {\n    let cid = CID.asCID(link.Hash)\n    try {\n      if (!cid) {\n        if (typeof link.Hash === 'string') {\n          cid = CID.parse(link.Hash)\n        } else if (link.Hash instanceof Uint8Array) {\n          cid = CID.decode(link.Hash)\n        }\n      }\n    } catch (/** @type {any} */ e) {\n      throw new TypeError(`Invalid DAG-PB form: ${e.message}`)\n    }\n\n    if (cid) {\n      pbl.Hash = cid\n    }\n  }\n\n  if (!pbl.Hash) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  if (typeof link.Name === 'string') {\n    pbl.Name = link.Name\n  }\n\n  if (typeof link.Tsize === 'number') {\n    pbl.Tsize = link.Tsize\n  }\n\n  return pbl\n}\n\n/**\n * @param {any} node\n * @returns {PBNode}\n */\nexport function prepare (node) {\n  if (node instanceof Uint8Array || typeof node === 'string') {\n    node = { Data: node }\n  }\n\n  if (typeof node !== 'object' || Array.isArray(node)) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  /** @type {PBNode} */\n  const pbn = {}\n\n  if (node.Data !== undefined) {\n    if (typeof node.Data === 'string') {\n      pbn.Data = textEncoder.encode(node.Data)\n    } else if (node.Data instanceof Uint8Array) {\n      pbn.Data = node.Data\n    } else {\n      throw new TypeError('Invalid DAG-PB form')\n    }\n  }\n\n  if (node.Links !== undefined) {\n    if (Array.isArray(node.Links)) {\n      pbn.Links = node.Links.map(asLink)\n      pbn.Links.sort(linkComparator)\n    } else {\n      throw new TypeError('Invalid DAG-PB form')\n    }\n  } else {\n    pbn.Links = []\n  }\n\n  return pbn\n}\n\n/**\n * @param {PBNode} node\n */\nexport function validate (node) {\n  /*\n  type PBLink struct {\n    Hash optional Link\n    Name optional String\n    Tsize optional Int\n  }\n\n  type PBNode struct {\n    Links [PBLink]\n    Data optional Bytes\n  }\n  */\n  // @ts-ignore private property for TS\n  if (!node || typeof node !== 'object' || Array.isArray(node) || node instanceof Uint8Array || (node['/'] && node['/'] === node.bytes)) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  if (!hasOnlyProperties(node, pbNodeProperties)) {\n    throw new TypeError('Invalid DAG-PB form (extraneous properties)')\n  }\n\n  if (node.Data !== undefined && !(node.Data instanceof Uint8Array)) {\n    throw new TypeError('Invalid DAG-PB form (Data must be bytes)')\n  }\n\n  if (!Array.isArray(node.Links)) {\n    throw new TypeError('Invalid DAG-PB form (Links must be a list)')\n  }\n\n  for (let i = 0; i < node.Links.length; i++) {\n    const link = node.Links[i]\n    // @ts-ignore private property for TS\n    if (!link || typeof link !== 'object' || Array.isArray(link) || link instanceof Uint8Array || (link['/'] && link['/'] === link.bytes)) {\n      throw new TypeError('Invalid DAG-PB form (bad link)')\n    }\n\n    if (!hasOnlyProperties(link, pbLinkProperties)) {\n      throw new TypeError('Invalid DAG-PB form (extraneous properties on link)')\n    }\n\n    if (link.Hash === undefined) {\n      throw new TypeError('Invalid DAG-PB form (link must have a Hash)')\n    }\n\n    // @ts-ignore private property for TS\n    if (link.Hash == null || !link.Hash['/'] || link.Hash['/'] !== link.Hash.bytes) {\n      throw new TypeError('Invalid DAG-PB form (link Hash must be a CID)')\n    }\n\n    if (link.Name !== undefined && typeof link.Name !== 'string') {\n      throw new TypeError('Invalid DAG-PB form (link Name must be a string)')\n    }\n\n    if (link.Tsize !== undefined) {\n      if (typeof link.Tsize !== 'number' || link.Tsize % 1 !== 0) {\n        throw new TypeError('Invalid DAG-PB form (link Tsize must be an integer)')\n      }\n      if (link.Tsize < 0) {\n        throw new TypeError('Invalid DAG-PB form (link Tsize cannot be negative)')\n      }\n    }\n\n    if (i > 0 && linkComparator(link, node.Links[i - 1]) === -1) {\n      throw new TypeError('Invalid DAG-PB form (links must be sorted by Name bytes)')\n    }\n  }\n}\n\n/**\n * @param {Uint8Array} data\n * @param {PBLink[]} [links=[]]\n * @returns {PBNode}\n */\nexport function createNode (data, links = []) {\n  return prepare({ Data: data, Links: links })\n}\n\n/**\n * @param {string} name\n * @param {number} size\n * @param {CID} cid\n * @returns {PBLink}\n */\nexport function createLink (name, size, cid) {\n  return asLink({ Hash: cid, Name: name, Tsize: size })\n}\n","import { CID } from 'multiformats/cid'\nimport { decodeNode } from './pb-decode.js'\nimport { encodeNode } from './pb-encode.js'\nimport { prepare, validate, createNode, createLink } from './util.js'\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n\n/**\n * @typedef {import('./interface').PBLink} PBLink\n * @typedef {import('./interface').PBNode} PBNode\n */\n\nexport const name = 'dag-pb'\nexport const code = 0x70\n\n/**\n * @param {PBNode} node\n * @returns {ByteView<PBNode>}\n */\nexport function encode (node) {\n  validate(node)\n\n  const pbn = {}\n  if (node.Links) {\n    pbn.Links = node.Links.map((l) => {\n      const link = {}\n      if (l.Hash) {\n        link.Hash = l.Hash.bytes // cid -> bytes\n      }\n      if (l.Name !== undefined) {\n        link.Name = l.Name\n      }\n      if (l.Tsize !== undefined) {\n        link.Tsize = l.Tsize\n      }\n      return link\n    })\n  }\n  if (node.Data) {\n    pbn.Data = node.Data\n  }\n\n  return encodeNode(pbn)\n}\n\n/**\n * @param {ByteView<PBNode>} bytes\n * @returns {PBNode}\n */\nexport function decode (bytes) {\n  const pbn = decodeNode(bytes)\n\n  const node = {}\n\n  if (pbn.Data) {\n    node.Data = pbn.Data\n  }\n\n  if (pbn.Links) {\n    node.Links = pbn.Links.map((l) => {\n      const link = {}\n      try {\n        link.Hash = CID.decode(l.Hash)\n      } catch (e) {}\n      if (!link.Hash) {\n        throw new Error('Invalid Hash field found in link, expected CID')\n      }\n      if (l.Name !== undefined) {\n        link.Name = l.Name\n      }\n      if (l.Tsize !== undefined) {\n        link.Tsize = l.Tsize\n      }\n      return link\n    })\n  }\n\n  return node\n}\n\nexport { prepare, validate, createNode, createLink }\n","import debug from 'debug';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { base32 } from 'multiformats/bases/base32';\nimport { base64 } from 'multiformats/bases/base64';\n// Add a formatter for converting to a base58 string\ndebug.formatters.b = (v) => {\n    return v == null ? 'undefined' : base58btc.baseEncode(v);\n};\n// Add a formatter for converting to a base32 string\ndebug.formatters.t = (v) => {\n    return v == null ? 'undefined' : base32.baseEncode(v);\n};\n// Add a formatter for converting to a base64 string\ndebug.formatters.m = (v) => {\n    return v == null ? 'undefined' : base64.baseEncode(v);\n};\n// Add a formatter for stringifying peer ids\ndebug.formatters.p = (v) => {\n    return v == null ? 'undefined' : v.toString();\n};\n// Add a formatter for stringifying CIDs\ndebug.formatters.c = (v) => {\n    return v == null ? 'undefined' : v.toString();\n};\n// Add a formatter for stringifying Datastore keys\ndebug.formatters.k = (v) => {\n    return v == null ? 'undefined' : v.toString();\n};\nfunction createDisabledLogger(namespace) {\n    const logger = () => { };\n    logger.enabled = false;\n    logger.color = '';\n    logger.diff = 0;\n    logger.log = () => { };\n    logger.namespace = namespace;\n    logger.destroy = () => true;\n    logger.extend = () => logger;\n    return logger;\n}\nexport function logger(name) {\n    // trace logging is a no-op by default\n    let trace = createDisabledLogger(`${name}:trace`);\n    // look at all the debug names and see if trace logging has explicitly been enabled\n    if (debug.enabled(`${name}:trace`) && debug.names.map(r => r.toString()).find(n => n.includes(':trace')) != null) {\n        trace = debug(`${name}:trace`);\n    }\n    return Object.assign(debug(name), {\n        error: debug(`${name}:error`),\n        trace\n    });\n}\nexport function disable() {\n    debug.disable();\n}\nexport function enable(namespaces) {\n    debug.enable(namespaces);\n}\nexport function enabled(namespaces) {\n    return debug.enabled(namespaces);\n}\n","export const symbol = Symbol.for('@libp2p/peer-id');\nexport function isPeerId(other) {\n    return other != null && Boolean(other[symbol]);\n}\n","import { CID } from 'multiformats/cid';\nimport { bases } from 'multiformats/basics';\nimport { base58btc } from 'multiformats/bases/base58';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { identity } from 'multiformats/hashes/identity';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { CodeError } from '@libp2p/interfaces/errors';\nimport { symbol } from '@libp2p/interface-peer-id';\nconst inspect = Symbol.for('nodejs.util.inspect.custom');\nconst baseDecoder = Object\n    .values(bases)\n    .map(codec => codec.decoder)\n    // @ts-expect-error https://github.com/multiformats/js-multiformats/issues/141\n    .reduce((acc, curr) => acc.or(curr), bases.identity.decoder);\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nconst LIBP2P_KEY_CODE = 0x72;\nconst MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36;\nconst MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;\nclass PeerIdImpl {\n    constructor(init) {\n        this.type = init.type;\n        this.multihash = init.multihash;\n        this.privateKey = init.privateKey;\n        // mark string cache as non-enumerable\n        Object.defineProperty(this, 'string', {\n            enumerable: false,\n            writable: true\n        });\n    }\n    get [Symbol.toStringTag]() {\n        return `PeerId(${this.toString()})`;\n    }\n    get [symbol]() {\n        return true;\n    }\n    toString() {\n        if (this.string == null) {\n            this.string = base58btc.encode(this.multihash.bytes).slice(1);\n        }\n        return this.string;\n    }\n    // return self-describing String representation\n    // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n    toCID() {\n        return CID.createV1(LIBP2P_KEY_CODE, this.multihash);\n    }\n    toBytes() {\n        return this.multihash.bytes;\n    }\n    /**\n     * Returns Multiaddr as a JSON string\n     */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * Checks the equality of `this` peer against a given PeerId\n     */\n    equals(id) {\n        if (id instanceof Uint8Array) {\n            return uint8ArrayEquals(this.multihash.bytes, id);\n        }\n        else if (typeof id === 'string') {\n            return peerIdFromString(id).equals(this);\n        }\n        else if (id?.multihash?.bytes != null) {\n            return uint8ArrayEquals(this.multihash.bytes, id.multihash.bytes);\n        }\n        else {\n            throw new Error('not valid Id');\n        }\n    }\n    /**\n     * Returns PeerId as a human-readable string\n     * https://nodejs.org/api/util.html#utilinspectcustom\n     *\n     * @example\n     * ```js\n     * import { peerIdFromString } from '@libp2p/peer-id'\n     *\n     * console.info(peerIdFromString('QmFoo'))\n     * // 'PeerId(QmFoo)'\n     * ```\n     */\n    [inspect]() {\n        return `PeerId(${this.toString()})`;\n    }\n}\nclass RSAPeerIdImpl extends PeerIdImpl {\n    constructor(init) {\n        super({ ...init, type: 'RSA' });\n        this.type = 'RSA';\n        this.publicKey = init.publicKey;\n    }\n}\nclass Ed25519PeerIdImpl extends PeerIdImpl {\n    constructor(init) {\n        super({ ...init, type: 'Ed25519' });\n        this.type = 'Ed25519';\n        this.publicKey = init.multihash.digest;\n    }\n}\nclass Secp256k1PeerIdImpl extends PeerIdImpl {\n    constructor(init) {\n        super({ ...init, type: 'secp256k1' });\n        this.type = 'secp256k1';\n        this.publicKey = init.multihash.digest;\n    }\n}\nexport function createPeerId(init) {\n    if (init.type === 'RSA') {\n        return new RSAPeerIdImpl(init);\n    }\n    if (init.type === 'Ed25519') {\n        return new Ed25519PeerIdImpl(init);\n    }\n    if (init.type === 'secp256k1') {\n        return new Secp256k1PeerIdImpl(init);\n    }\n    throw new CodeError('Type must be \"RSA\", \"Ed25519\" or \"secp256k1\"', 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromPeerId(other) {\n    if (other.type === 'RSA') {\n        return new RSAPeerIdImpl(other);\n    }\n    if (other.type === 'Ed25519') {\n        return new Ed25519PeerIdImpl(other);\n    }\n    if (other.type === 'secp256k1') {\n        return new Secp256k1PeerIdImpl(other);\n    }\n    throw new CodeError('Not a PeerId', 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromString(str, decoder) {\n    decoder = decoder ?? baseDecoder;\n    if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {\n        // identity hash ed25519/secp256k1 key or sha2-256 hash of\n        // rsa public key - base58btc encoded either way\n        const multihash = Digest.decode(base58btc.decode(`z${str}`));\n        if (str.startsWith('12D')) {\n            return new Ed25519PeerIdImpl({ multihash });\n        }\n        else if (str.startsWith('16U')) {\n            return new Secp256k1PeerIdImpl({ multihash });\n        }\n        else {\n            return new RSAPeerIdImpl({ multihash });\n        }\n    }\n    return peerIdFromBytes(baseDecoder.decode(str));\n}\nexport function peerIdFromBytes(buf) {\n    try {\n        const multihash = Digest.decode(buf);\n        if (multihash.code === identity.code) {\n            if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n                return new Ed25519PeerIdImpl({ multihash });\n            }\n            else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n                return new Secp256k1PeerIdImpl({ multihash });\n            }\n        }\n        if (multihash.code === sha256.code) {\n            return new RSAPeerIdImpl({ multihash });\n        }\n    }\n    catch {\n        return peerIdFromCID(CID.decode(buf));\n    }\n    throw new Error('Supplied PeerID CID is invalid');\n}\nexport function peerIdFromCID(cid) {\n    if (cid == null || cid.multihash == null || cid.version == null || (cid.version === 1 && cid.code !== LIBP2P_KEY_CODE)) {\n        throw new Error('Supplied PeerID CID is invalid');\n    }\n    const multihash = cid.multihash;\n    if (multihash.code === sha256.code) {\n        return new RSAPeerIdImpl({ multihash: cid.multihash });\n    }\n    else if (multihash.code === identity.code) {\n        if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n            return new Ed25519PeerIdImpl({ multihash: cid.multihash });\n        }\n        else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n            return new Secp256k1PeerIdImpl({ multihash: cid.multihash });\n        }\n    }\n    throw new Error('Supplied PeerID CID is invalid');\n}\n/**\n * @param publicKey - A marshalled public key\n * @param privateKey - A marshalled private key\n */\nexport async function peerIdFromKeys(publicKey, privateKey) {\n    if (publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n        return new Ed25519PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey });\n    }\n    if (publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n        return new Secp256k1PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey });\n    }\n    return new RSAPeerIdImpl({ multihash: await sha256.digest(publicKey), publicKey, privateKey });\n}\n","import { Multiaddr } from '@multiformats/multiaddr';\nconst reduceValue = (_, v) => v;\nconst tcpUri = (str, port, parts, opts) => {\n    // return tcp when explicitly requested\n    if ((opts != null) && opts.assumeHttp === false)\n        return `tcp://${str}:${port}`;\n    // check if tcp is the last protocol in multiaddr\n    let protocol = 'tcp';\n    let explicitPort = `:${port}`;\n    const last = parts[parts.length - 1];\n    if (last.protocol === 'tcp') {\n        // assume http and produce clean urls\n        protocol = port === '443' ? 'https' : 'http';\n        explicitPort = port === '443' || port === '80' ? '' : explicitPort;\n    }\n    return `${protocol}://${str}${explicitPort}`;\n};\nconst Reducers = {\n    ip4: reduceValue,\n    ip6: (str, content, i, parts) => (parts.length === 1 && parts[0].protocol === 'ip6'\n        ? content\n        : `[${content}]`),\n    tcp: (str, content, i, parts, opts) => (parts.some(p => ['http', 'https', 'ws', 'wss'].includes(p.protocol))\n        ? `${str}:${content}`\n        : tcpUri(str, content, parts, opts)),\n    udp: (str, content) => `udp://${str}:${content}`,\n    dnsaddr: reduceValue,\n    dns4: reduceValue,\n    dns6: reduceValue,\n    ipfs: (str, content) => `${str}/ipfs/${content}`,\n    p2p: (str, content) => `${str}/p2p/${content}`,\n    http: str => `http://${str}`,\n    https: str => `https://${str}`,\n    ws: str => `ws://${str}`,\n    wss: str => `wss://${str}`,\n    'p2p-websocket-star': str => `${str}/p2p-websocket-star`,\n    'p2p-webrtc-star': str => `${str}/p2p-webrtc-star`,\n    'p2p-webrtc-direct': str => `${str}/p2p-webrtc-direct`\n};\nexport function multiaddrToUri(multiaddr, opts) {\n    const ma = new Multiaddr(multiaddr);\n    const parts = multiaddr.toString().split('/').slice(1);\n    return ma\n        .tuples()\n        .map(tuple => ({\n        protocol: parts.shift() ?? '',\n        content: (tuple[1] != null) ? parts.shift() ?? '' : ''\n    }))\n        .reduce((str, part, i, parts) => {\n        const reduce = Reducers[part.protocol];\n        if (reduce == null) {\n            throw new Error(`Unsupported protocol ${part.protocol}`);\n        }\n        return reduce(str, part.content, i, parts, opts);\n    }, '');\n}\n","/* eslint-env browser */\nimport browserReadableStreamToIt from 'browser-readablestream-to-it';\nexport default function blobToIt(blob) {\n    if (typeof blob.stream === 'function') {\n        return browserReadableStreamToIt(blob.stream());\n    }\n    // firefox < 69 does not support blob.stream()\n    // @ts-expect-error - response.body is optional, but in practice it's a stream.\n    return browserReadableStreamToIt(new Response(blob).body);\n}\n","/**\n * Turns a browser readable stream into an async iterable. Async iteration over\n * returned iterable will lock give stream, preventing any other consumer from\n * acquiring a reader. The lock will be released if iteration loop is broken. To\n * prevent stream cancelling optional `{ preventCancel: true }` could be passed\n * as a second argument.\n */\nexport default async function* browserReadableStreamToIt(stream, options = {}) {\n    const reader = stream.getReader();\n    try {\n        while (true) {\n            const result = await reader.read();\n            if (result.done) {\n                return;\n            }\n            yield result.value;\n        }\n    }\n    finally {\n        if (options.preventCancel !== true) {\n            await reader.cancel();\n        }\n        reader.releaseLock();\n    }\n}\n","import { base64url } from 'multiformats/bases/base64';\nexport function toBase64url(b) {\n    return base64url.encode(b).slice(1);\n}\nexport function fromBase64url(s) {\n    return base64url.decode(`u${s}`);\n}\n","import { fromBase64url, toBase64url } from './utils.js';\nimport { CID } from 'multiformats/cid';\nexport function fromSplit(split) {\n    const [protectedHeader, payload, signature] = split;\n    return {\n        payload,\n        signatures: [{ protected: protectedHeader, signature }],\n        link: CID.decode(fromBase64url(payload)),\n    };\n}\nfunction encodeSignature(signature) {\n    const encoded = {\n        signature: fromBase64url(signature.signature),\n    };\n    if (signature.header)\n        encoded.header = signature.header;\n    if (signature.protected)\n        encoded.protected = fromBase64url(signature.protected);\n    return encoded;\n}\nexport function encode(jws) {\n    const payload = fromBase64url(jws.payload);\n    try {\n        CID.decode(payload);\n    }\n    catch (e) {\n        throw new Error('Not a valid DagJWS');\n    }\n    return {\n        payload,\n        signatures: jws.signatures.map(encodeSignature),\n    };\n}\nfunction decodeSignature(encoded) {\n    const sign = {\n        signature: toBase64url(encoded.signature),\n    };\n    if (encoded.header)\n        sign.header = encoded.header;\n    if (encoded.protected)\n        sign.protected = toBase64url(encoded.protected);\n    return sign;\n}\nexport function decode(encoded) {\n    const decoded = {\n        payload: toBase64url(encoded.payload),\n        signatures: encoded.signatures.map(decodeSignature),\n    };\n    decoded.link = CID.decode(new Uint8Array(encoded.payload));\n    return decoded;\n}\n","import { fromBase64url, toBase64url } from './utils.js';\nexport function fromSplit(split) {\n    const [protectedHeader, encrypted_key, iv, ciphertext, tag] = split;\n    const jwe = {\n        ciphertext,\n        iv,\n        protected: protectedHeader,\n        tag,\n    };\n    if (encrypted_key)\n        jwe.recipients = [{ encrypted_key }];\n    return jwe;\n}\nfunction encodeRecipient(recipient) {\n    const encRec = {};\n    if (recipient.encrypted_key)\n        encRec.encrypted_key = fromBase64url(recipient.encrypted_key);\n    if (recipient.header)\n        encRec.header = recipient.header;\n    return encRec;\n}\nexport function encode(jwe) {\n    const encJwe = {\n        ciphertext: fromBase64url(jwe.ciphertext),\n        protected: fromBase64url(jwe.protected),\n        iv: fromBase64url(jwe.iv),\n        tag: fromBase64url(jwe.tag),\n    };\n    if (jwe.aad)\n        encJwe.aad = fromBase64url(jwe.aad);\n    if (jwe.recipients)\n        encJwe.recipients = jwe.recipients.map(encodeRecipient);\n    if (jwe.unprotected)\n        encJwe.unprotected = jwe.unprotected;\n    return encJwe;\n}\nfunction decodeRecipient(encoded) {\n    const recipient = {};\n    if (encoded.encrypted_key)\n        recipient.encrypted_key = toBase64url(encoded.encrypted_key);\n    if (encoded.header)\n        recipient.header = encoded.header;\n    return recipient;\n}\nexport function decode(encoded) {\n    const jwe = {\n        ciphertext: toBase64url(encoded.ciphertext),\n        protected: toBase64url(encoded.protected),\n        iv: toBase64url(encoded.iv),\n        tag: toBase64url(encoded.tag),\n    };\n    if (encoded.aad)\n        jwe.aad = toBase64url(encoded.aad);\n    if (encoded.recipients)\n        jwe.recipients = encoded.recipients.map(decodeRecipient);\n    if (encoded.unprotected)\n        jwe.unprotected = encoded.unprotected;\n    return jwe;\n}\n","import * as signing from './signing.js';\nimport * as encryption from './encryption.js';\nimport * as cbor from '@ipld/dag-cbor';\nexport const name = 'dag-jose';\nexport const code = 133;\nfunction isDagJWS(jose) {\n    return ('payload' in jose &&\n        typeof jose.payload === 'string' &&\n        'signatures' in jose &&\n        Array.isArray(jose.signatures));\n}\nfunction isEncodedJWS(jose) {\n    return ('payload' in jose &&\n        jose.payload instanceof Uint8Array &&\n        'signatures' in jose &&\n        Array.isArray(jose.signatures));\n}\nfunction isEncodedJWE(jose) {\n    return ('ciphertext' in jose &&\n        jose.ciphertext instanceof Uint8Array &&\n        'iv' in jose &&\n        jose.iv instanceof Uint8Array &&\n        'protected' in jose &&\n        jose.protected instanceof Uint8Array &&\n        'tag' in jose &&\n        jose.tag instanceof Uint8Array);\n}\nfunction isDagJWE(jose) {\n    return ('ciphertext' in jose &&\n        typeof jose.ciphertext === 'string' &&\n        'iv' in jose &&\n        typeof jose.iv === 'string' &&\n        'protected' in jose &&\n        typeof jose.protected === 'string' &&\n        'tag' in jose &&\n        typeof jose.tag === 'string');\n}\nexport function toGeneral(jose) {\n    if (typeof jose === 'string') {\n        const split = jose.split('.');\n        if (split.length === 3) {\n            return signing.fromSplit(split);\n        }\n        else if (split.length === 5) {\n            return encryption.fromSplit(split);\n        }\n        throw new Error('Not a valid JOSE string');\n    }\n    if (isDagJWS(jose) || isDagJWE(jose)) {\n        return jose;\n    }\n    throw new Error('Not a valid unencoded JOSE object');\n}\nexport function encode(obj) {\n    if (typeof obj === 'string') {\n        obj = toGeneral(obj);\n    }\n    let encodedJose;\n    if (isDagJWS(obj)) {\n        encodedJose = signing.encode(obj);\n    }\n    else if (isDagJWE(obj)) {\n        encodedJose = encryption.encode(obj);\n    }\n    else {\n        throw new Error('Not a valid JOSE object');\n    }\n    return new Uint8Array(cbor.encode(encodedJose));\n}\nexport function decode(data) {\n    let encoded;\n    try {\n        encoded = cbor.decode(data);\n    }\n    catch (e) {\n        throw new Error('Not a valid DAG-JOSE object');\n    }\n    if (isEncodedJWS(encoded)) {\n        return signing.decode(encoded);\n    }\n    else if (isEncodedJWE(encoded)) {\n        return encryption.decode(encoded);\n    }\n    else {\n        throw new Error('Not a valid DAG-JOSE object');\n    }\n}\n","const word = '[a-fA-F\\\\d:]';\n\nconst boundry = options => options && options.includeBoundaries\n\t? `(?:(?<=\\\\s|^)(?=${word})|(?<=${word})(?=\\\\s|$))`\n\t: '';\n\nconst v4 = '(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}';\n\nconst v6segment = '[a-fA-F\\\\d]{1,4}';\n\nconst v6 = `\n(?:\n(?:${v6segment}:){7}(?:${v6segment}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:${v6segment}:){6}(?:${v4}|:${v6segment}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:${v6segment}:){5}(?::${v4}|(?::${v6segment}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:${v6segment}:){4}(?:(?::${v6segment}){0,1}:${v4}|(?::${v6segment}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:${v6segment}:){3}(?:(?::${v6segment}){0,2}:${v4}|(?::${v6segment}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:${v6segment}:){2}(?:(?::${v6segment}){0,3}:${v4}|(?::${v6segment}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:${v6segment}:){1}(?:(?::${v6segment}){0,4}:${v4}|(?::${v6segment}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::${v6segment}){0,5}:${v4}|(?::${v6segment}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n`.replace(/\\s*\\/\\/.*$/gm, '').replace(/\\n/g, '').trim();\n\n// Pre-compile only the exact regexes because adding a global flag make regexes stateful\nconst v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);\nconst v4exact = new RegExp(`^${v4}$`);\nconst v6exact = new RegExp(`^${v6}$`);\n\nconst ipRegex = options => options && options.exact\n\t? v46Exact\n\t: new RegExp(`(?:${boundry(options)}${v4}${boundry(options)})|(?:${boundry(options)}${v6}${boundry(options)})`, 'g');\n\nipRegex.v4 = options => options && options.exact ? v4exact : new RegExp(`${boundry(options)}${v4}${boundry(options)}`, 'g');\nipRegex.v6 = options => options && options.exact ? v6exact : new RegExp(`${boundry(options)}${v6}${boundry(options)}`, 'g');\n\nexport default ipRegex;\n","import ipRegex from 'ip-regex';\n\nexport function isIP(string) {\n\treturn ipRegex({exact: true}).test(string);\n}\n\nexport function isIPv6(string) {\n\treturn ipRegex.v6({exact: true}).test(string);\n}\n\nexport function isIPv4(string) {\n\treturn ipRegex.v4({exact: true}).test(string);\n}\n\nexport function ipVersion(string) {\n\treturn isIP(string) ? (isIPv6(string) ? 6 : 4) : undefined;\n}\n","/**\n * Collects all values from an (async) iterable and returns them as an array\n */\nexport default async function all(source) {\n    const arr = [];\n    for await (const entry of source) {\n        arr.push(entry);\n    }\n    return arr;\n}\n","/**\n * Returns the first result from an (async) iterable, unless empty, in which\n * case returns `undefined`\n */\nexport default async function first(source) {\n    for await (const entry of source) { // eslint-disable-line no-unreachable-loop\n        return entry;\n    }\n    return undefined;\n}\n","/**\n * Returns the last item of an (async) iterable, unless empty, in which case\n * return `undefined`\n */\nexport default async function last(source) {\n    let res;\n    for await (const entry of source) {\n        res = entry;\n    }\n    return res;\n}\n","/**\n * Takes an (async) iterable and returns one with each item mapped by the passed\n * function\n */\nexport default async function* map(source, func) {\n    for await (const val of source) {\n        yield func(val);\n    }\n}\n","export default function peekableIterator(iterable) {\n    // @ts-expect-error\n    const [iterator, symbol] = iterable[Symbol.asyncIterator] != null\n        // @ts-expect-error\n        ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator]\n        // @ts-expect-error\n        : [iterable[Symbol.iterator](), Symbol.iterator];\n    const queue = [];\n    // @ts-expect-error\n    return {\n        peek: () => {\n            return iterator.next();\n        },\n        push: (value) => {\n            queue.push(value);\n        },\n        next: () => {\n            if (queue.length > 0) {\n                return {\n                    done: false,\n                    value: queue.shift()\n                };\n            }\n            return iterator.next();\n        },\n        [symbol]() {\n            return this;\n        }\n    };\n}\n","export function equals(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (a.byteLength !== b.byteLength) {\n    return false;\n  }\n  for (let i = 0; i < a.byteLength; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}","import { asUint8Array } from './util/as-uint8array.js';\n/**\n * Returns a `Uint8Array` of the requested size. Referenced memory will\n * be initialized to 0.\n */\nexport function alloc(size = 0) {\n    if (globalThis.Buffer?.alloc != null) {\n        return asUint8Array(globalThis.Buffer.alloc(size));\n    }\n    return new Uint8Array(size);\n}\n/**\n * Where possible returns a Uint8Array of the requested size that references\n * uninitialized memory. Only use if you are certain you will immediately\n * overwrite every value in the returned `Uint8Array`.\n */\nexport function allocUnsafe(size = 0) {\n    if (globalThis.Buffer?.allocUnsafe != null) {\n        return asUint8Array(globalThis.Buffer.allocUnsafe(size));\n    }\n    return new Uint8Array(size);\n}\n","import { allocUnsafe } from './alloc.js';\nimport { asUint8Array } from './util/as-uint8array.js';\n/**\n * Returns a new Uint8Array created by concatenating the passed ArrayLikes\n */\nexport function concat(arrays, length) {\n    if (length == null) {\n        length = arrays.reduce((acc, curr) => acc + curr.length, 0);\n    }\n    const output = allocUnsafe(length);\n    let offset = 0;\n    for (const arr of arrays) {\n        output.set(arr, offset);\n        offset += arr.length;\n    }\n    return asUint8Array(output);\n}\n","/**\n * Returns true if the two passed Uint8Arrays have the same content\n */\nexport function equals(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (a.byteLength !== b.byteLength) {\n        return false;\n    }\n    for (let i = 0; i < a.byteLength; i++) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n","import bases from './util/bases.js';\nimport { asUint8Array } from './util/as-uint8array.js';\n/**\n * Create a `Uint8Array` from the passed string\n *\n * Supports `utf8`, `utf-8`, `hex`, and any encoding supported by the multiformats module.\n *\n * Also `ascii` which is similar to node's 'binary' encoding.\n */\nexport function fromString(string, encoding = 'utf8') {\n    const base = bases[encoding];\n    if (base == null) {\n        throw new Error(`Unsupported encoding \"${encoding}\"`);\n    }\n    if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {\n        return asUint8Array(globalThis.Buffer.from(string, 'utf-8'));\n    }\n    // add multibase prefix\n    return base.decoder.decode(`${base.prefix}${string}`); // eslint-disable-line @typescript-eslint/restrict-template-expressions\n}\n","import bases from './util/bases.js';\n/**\n * Turns a `Uint8Array` into a string.\n *\n * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.\n *\n * Also `ascii` which is similar to node's 'binary' encoding.\n */\nexport function toString(array, encoding = 'utf8') {\n    const base = bases[encoding];\n    if (base == null) {\n        throw new Error(`Unsupported encoding \"${encoding}\"`);\n    }\n    if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {\n        return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString('utf8');\n    }\n    // strip multibase prefix\n    return base.encoder.encode(array).substring(1);\n}\n","/**\n * To guarantee Uint8Array semantics, convert nodejs Buffers\n * into vanilla Uint8Arrays\n */\nexport function asUint8Array(buf) {\n    if (globalThis.Buffer != null) {\n        return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n    }\n    return buf;\n}\n","import { bases } from 'multiformats/basics';\nimport { allocUnsafe } from '../alloc.js';\nfunction createCodec(name, prefix, encode, decode) {\n    return {\n        name,\n        prefix,\n        encoder: {\n            name,\n            prefix,\n            encode\n        },\n        decoder: {\n            decode\n        }\n    };\n}\nconst string = createCodec('utf8', 'u', (buf) => {\n    const decoder = new TextDecoder('utf8');\n    return 'u' + decoder.decode(buf);\n}, (str) => {\n    const encoder = new TextEncoder();\n    return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', (buf) => {\n    let string = 'a';\n    for (let i = 0; i < buf.length; i++) {\n        string += String.fromCharCode(buf[i]);\n    }\n    return string;\n}, (str) => {\n    str = str.substring(1);\n    const buf = allocUnsafe(str.length);\n    for (let i = 0; i < str.length; i++) {\n        buf[i] = str.charCodeAt(i);\n    }\n    return buf;\n});\nconst BASES = {\n    utf8: string,\n    'utf-8': string,\n    hex: bases.base16,\n    latin1: ascii,\n    ascii: ascii,\n    binary: ascii,\n    ...bases\n};\nexport default BASES;\n"],"names":["encode","ARWEAVE_SIGNING","sign","transaction","response","fetch","method","body","Uint8Array","from","makeRequest","setSignature","json","encoder","TextEncoder","prepareChunks","data","get","base","name","decode","string","format","toString","quantity","reward","tags","map","tag","data_size","isEmpty","Arweave","Attachment","encodeText","fetchText","LANDING_PAGE","MESON_PREFIX","Provider","TOKEN","makeFileKeySigned","ArweaveAgent","instance","stage","init","default","host","port","protocol","makeAttachment","options","passphrase","key","undefined","encoded","block","mime","type","metadata","makePayload","id","transactions","post","uploadLandingPage","linkPrefix","useCDN","encodedMetadata","JSON","stringify","size","provider","link","txId","signed","createdAt","Date","toISOString","text","replaced","replace","upload","uploader","pctComplete","createTransaction","addTag","urlcat","create","createClient","headers","authorization","IPFSAgent","providerName","client","IPFS","file","add","cid","arweave","ipfs","allProviders","percent","deleteFile","getAllFiles","renameFile","setFileInfo","getNextFetchers","input","ok","Error"],"sourceRoot":"","x_google_ignoreList":[13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74]}