{"version":3,"file":"bundled/chunk.npm.parse-domain.js","mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACO,gBAAgB;AAChB,kBAAkB;AAClB,kBAAkB;AAClB,mBAAmB;AACnB,sBAAsB;AACtB,uBAAuB;;;ACNa;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,QAAmB;AACjD,kCAAkC,SAAoB;AACtD;AACA;AACA,qCAAqC,QAAmB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACvBA;AACyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD;AAC5C;AACP;AACA;AACA;AACA;AACA,CAAC,wDAAwD;AACzD;AACA;AACA;AACA,oCAAoC,eAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO,2BAA2B,QAAQ,4CAA4C,kBAAkB;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,MAAM,2BAA2B,QAAQ,qCAAqC,iBAAiB;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,MAAM,0BAA0B,QAAQ,4CAA4C,iBAAiB;AAChI;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,MAAM,gCAAgC,iBAAiB,cAAc,OAAO;AACvG;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5HO;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACpB2C;AACiC;AACrE;AACP,qBAAqB,cAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA,oBAAoB,2BAA2B;AAC/C;AACA;AACA,iBAAiB,IAAe;AAChC;AACA;AACA;AACA,iBAAiB,IAAe;AAChC;AACA;AACA;AACA;AACA,iBAAiB,KAAgB;AACjC;AACA;AACA;AACA;AACA,iBAAiB,EAAa;AAC9B,wCAAwC,cAAc;AACtD,4EAA4E,EAAE;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7C4D;AACV;AACa;AACjB;AACvC;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,+BAA+B,QAAQ;AACvC,oCAAoC,sBAAsB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sBAAsB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iGAAiG,SAAS,CAAC,qBAAS;AACpH,yGAAyG,SAAS,CAAC,uBAAW;AAC9H,sBAAsB,gBAAgB;AACtC,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mHAAmH;AAC9I","sources":["webpack://mask-network/./node_modules/.pnpm/parse-domain@3.0.3/node_modules/parse-domain/build-esm/src/trie/characters.js","webpack://mask-network/./node_modules/.pnpm/parse-domain@3.0.3/node_modules/parse-domain/build-esm/src/trie/look-up.js","webpack://mask-network/./node_modules/.pnpm/parse-domain@3.0.3/node_modules/parse-domain/build-esm/src/sanitize.js","webpack://mask-network/./node_modules/.pnpm/parse-domain@3.0.3/node_modules/parse-domain/build-esm/src/trie/nodes.js","webpack://mask-network/./node_modules/.pnpm/parse-domain@3.0.3/node_modules/parse-domain/build-esm/src/trie/parse-trie.js","webpack://mask-network/./node_modules/.pnpm/parse-domain@3.0.3/node_modules/parse-domain/build-esm/src/parse-domain.js"],"sourcesContent":["// UP, SAME, DOWN, RESET should not be special regex characters in a character class.\nexport const UP = \"<\"; // one level up\nexport const SAME = \",\"; // same level\nexport const DOWN = \">\"; // one level down\nexport const RESET = \"|\"; // reset level index and start new\nexport const WILDCARD = \"*\"; // as defined by publicsuffix.org\nexport const EXCEPTION = \"!\"; // as defined by publicsuffix.org\n","import * as characters from \"./characters\";\nexport const lookUpTldsInTrie = (labels, trie) => {\n    const labelsToCheck = labels.slice();\n    const tlds = [];\n    let node = trie;\n    while (labelsToCheck.length !== 0) {\n        const label = labelsToCheck.pop();\n        const labelLowerCase = label.toLowerCase();\n        if (node.children.has(characters.WILDCARD)) {\n            if (node.children.has(characters.EXCEPTION + labelLowerCase)) {\n                break;\n            }\n            node = node.children.get(characters.WILDCARD);\n        }\n        else {\n            if (node.children.has(labelLowerCase) === false) {\n                break;\n            }\n            node = node.children.get(labelLowerCase);\n        }\n        tlds.unshift(label);\n    }\n    return tlds;\n};\n","// eslint-disable-next-line import/default\nimport isIp from \"is-ip\";\n// See https://en.wikipedia.org/wiki/Domain_name\n// See https://tools.ietf.org/html/rfc1034\nconst LABEL_SEPARATOR = \".\";\nconst LABEL_ROOT = \"\";\nconst LABEL_LENGTH_MIN = 1;\nconst LABEL_LENGTH_MAX = 63;\nconst DOMAIN_LENGTH_MAX = 253;\nexport var ValidationErrorType;\n(function (ValidationErrorType) {\n    ValidationErrorType[\"NoHostname\"] = \"NO_HOSTNAME\";\n    ValidationErrorType[\"DomainMaxLength\"] = \"DOMAIN_MAX_LENGTH\";\n    ValidationErrorType[\"LabelMinLength\"] = \"LABEL_MIN_LENGTH\";\n    ValidationErrorType[\"LabelMaxLength\"] = \"LABEL_MAX_LENGTH\";\n    ValidationErrorType[\"LabelInvalidCharacter\"] = \"LABEL_INVALID_CHARACTER\";\n})(ValidationErrorType || (ValidationErrorType = {}));\nexport var SanitizationResultType;\n(function (SanitizationResultType) {\n    SanitizationResultType[\"ValidIp\"] = \"VALID_IP\";\n    SanitizationResultType[\"ValidDomain\"] = \"VALID_DOMAIN\";\n    SanitizationResultType[\"Error\"] = \"ERROR\";\n})(SanitizationResultType || (SanitizationResultType = {}));\nconst createNoHostnameError = (input) => {\n    return {\n        type: ValidationErrorType.NoHostname,\n        message: `The given input ${String(input)} does not look like a hostname.`,\n        column: 1,\n    };\n};\nconst createDomainMaxLengthError = (domain) => {\n    const length = domain.length;\n    return {\n        type: ValidationErrorType.DomainMaxLength,\n        message: `Domain \"${domain}\" is too long. Domain is ${length} octets long but should not be longer than ${DOMAIN_LENGTH_MAX}.`,\n        column: length,\n    };\n};\nconst createLabelMinLengthError = (label, column) => {\n    const length = label.length;\n    return {\n        type: ValidationErrorType.LabelMinLength,\n        message: `Label \"${label}\" is too short. Label is ${length} octets long but should be at least ${LABEL_LENGTH_MIN}.`,\n        column,\n    };\n};\nconst createLabelMaxLengthError = (label, column) => {\n    const length = label.length;\n    return {\n        type: ValidationErrorType.LabelMaxLength,\n        message: `Label \"${label}\" is too long. Label is ${length} octets long but should not be longer than ${LABEL_LENGTH_MAX}.`,\n        column,\n    };\n};\nconst createLabelInvalidCharacterError = (label, invalidCharacter, column) => {\n    return {\n        type: ValidationErrorType.LabelInvalidCharacter,\n        message: `Label \"${label}\" contains invalid character \"${invalidCharacter}\" at column ${column}.`,\n        column,\n    };\n};\nexport const sanitize = (input) => {\n    // Extra check for non-TypeScript users\n    if (typeof input !== \"string\") {\n        return {\n            type: SanitizationResultType.Error,\n            errors: [createNoHostnameError(input)],\n        };\n    }\n    const inputTrimmed = input.trim();\n    // IPv6 addresses are surrounded by square brackets in URLs\n    // See https://tools.ietf.org/html/rfc3986#section-3.2.2\n    const inputTrimmedAsIp = inputTrimmed.replace(/^\\[|]$/g, \"\");\n    const ipVersion = isIp.version(inputTrimmedAsIp);\n    if (ipVersion !== undefined) {\n        return {\n            type: SanitizationResultType.ValidIp,\n            ip: inputTrimmedAsIp,\n            ipVersion,\n        };\n    }\n    if (inputTrimmed.length > DOMAIN_LENGTH_MAX) {\n        return {\n            type: SanitizationResultType.Error,\n            errors: [createDomainMaxLengthError(inputTrimmed)],\n        };\n    }\n    const labels = inputTrimmed.split(LABEL_SEPARATOR);\n    const lastLabel = labels[labels.length - 1];\n    // If the last label is the special root label, ignore it\n    if (lastLabel === LABEL_ROOT) {\n        labels.pop();\n    }\n    const labelValidationErrors = [];\n    let column = 1;\n    for (const label of labels) {\n        // According to https://tools.ietf.org/html/rfc6761 labels should\n        // only contain ASCII letters, digits and hyphens (LDH).\n        const invalidCharacter = /[^\\d\\-a-z]/iu.exec(label);\n        if (invalidCharacter) {\n            labelValidationErrors.push(createLabelInvalidCharacterError(label, invalidCharacter[0], invalidCharacter.index + 1));\n        }\n        else if (\n        // We can use .length here to check for the octet size because\n        // label can only contain ASCII LDH characters at this point.\n        label.length < LABEL_LENGTH_MIN) {\n            labelValidationErrors.push(createLabelMinLengthError(label, column));\n        }\n        else if (label.length > LABEL_LENGTH_MAX) {\n            labelValidationErrors.push(createLabelMaxLengthError(label, column));\n        }\n        column += label.length + LABEL_SEPARATOR.length;\n    }\n    if (labelValidationErrors.length > 0) {\n        return {\n            type: SanitizationResultType.Error,\n            errors: labelValidationErrors,\n        };\n    }\n    return {\n        type: SanitizationResultType.ValidDomain,\n        domain: inputTrimmed,\n        labels,\n    };\n};\n","export const NODE_TYPE_ROOT = Symbol(\"ROOT\");\nexport const NODE_TYPE_CHILD = Symbol(\"CHILD\");\nexport const createRootNode = () => {\n    return {\n        type: NODE_TYPE_ROOT,\n        children: new Map(),\n    };\n};\nexport const createOrGetChild = (parent, label) => {\n    let child = parent.children.get(label);\n    if (child === undefined) {\n        child = {\n            type: NODE_TYPE_CHILD,\n            label,\n            children: new Map(),\n            parent,\n        };\n        parent.children.set(label, child);\n    }\n    return child;\n};\n","import * as characters from \"./characters\";\nimport { createRootNode, createOrGetChild, NODE_TYPE_ROOT, } from \"./nodes\";\nexport const parseTrie = (serializedTrie) => {\n    const rootNode = createRootNode();\n    let domain = \"\";\n    let parentNode = rootNode;\n    // Type assertion necessary here due to a TypeScript unsoundness\n    // https://github.com/microsoft/TypeScript/issues/9998#issuecomment-235963457\n    let node = rootNode;\n    const addDomain = () => {\n        node = createOrGetChild(parentNode, domain);\n        domain = \"\";\n    };\n    for (let i = 0; i < serializedTrie.length; i++) {\n        const char = serializedTrie.charAt(i);\n        switch (char) {\n            case characters.SAME: {\n                addDomain();\n                continue;\n            }\n            case characters.DOWN: {\n                addDomain();\n                parentNode = node;\n                continue;\n            }\n            case characters.RESET: {\n                addDomain();\n                parentNode = rootNode;\n                continue;\n            }\n            case characters.UP: {\n                if (parentNode.type === NODE_TYPE_ROOT) {\n                    throw new Error(`Error in serialized trie at position ${i}: Cannot go up, current parent node is already root`);\n                }\n                addDomain();\n                parentNode = parentNode.parent;\n                continue;\n            }\n        }\n        domain += char;\n    }\n    if (domain !== \"\") {\n        addDomain();\n    }\n    return rootNode;\n};\n","import { icannTrie, privateTrie } from \"./serialized-tries\";\nimport { lookUpTldsInTrie } from \"./trie/look-up\";\nimport { sanitize, SanitizationResultType, } from \"./sanitize\";\nimport { parseTrie } from \"./trie/parse-trie\";\nexport const RESERVED_TOP_LEVEL_DOMAINS = [\n    \"localhost\",\n    \"local\",\n    \"example\",\n    \"invalid\",\n    \"test\",\n];\nexport var ParseResultType;\n(function (ParseResultType) {\n    /**\n     * This parse result is returned in case the given hostname does not adhere to [RFC 1034](https://tools.ietf.org/html/rfc1034).\n     */\n    ParseResultType[\"Invalid\"] = \"INVALID\";\n    /**\n     * This parse result is returned if the given hostname was an IPv4 or IPv6.\n     */\n    ParseResultType[\"Ip\"] = \"IP\";\n    /**\n     * This parse result is returned when the given hostname\n     * - is the root domain (the empty string `\"\"`)\n     * - belongs to the top-level domain `localhost`, `local`, `example`, `invalid` or `test`\n     */\n    ParseResultType[\"Reserved\"] = \"RESERVED\";\n    /**\n     * This parse result is returned when the given hostname is valid and does not belong to a reserved top-level domain, but is not listed in the public suffix list.\n     */\n    ParseResultType[\"NotListed\"] = \"NOT_LISTED\";\n    /**\n     * This parse result is returned when the given hostname belongs to a top-level domain that is listed in the public suffix list.\n     */\n    ParseResultType[\"Listed\"] = \"LISTED\";\n})(ParseResultType || (ParseResultType = {}));\nconst getAtIndex = (array, index) => {\n    return index >= 0 && index < array.length ? array[index] : undefined;\n};\nconst splitLabelsIntoDomains = (labels, index) => {\n    return {\n        subDomains: labels.slice(0, Math.max(0, index)),\n        domain: getAtIndex(labels, index),\n        topLevelDomains: labels.slice(index + 1),\n    };\n};\nlet parsedIcannTrie;\nlet parsedPrivateTrie;\n/**\n * Splits the given hostname in topLevelDomains, a domain and subDomains.\n */\nexport const parseDomain = (hostname) => {\n    const sanitizationResult = sanitize(hostname);\n    if (sanitizationResult.type === SanitizationResultType.Error) {\n        return {\n            type: ParseResultType.Invalid,\n            hostname,\n            errors: sanitizationResult.errors,\n        };\n    }\n    if (sanitizationResult.type === SanitizationResultType.ValidIp) {\n        return {\n            type: ParseResultType.Ip,\n            hostname: sanitizationResult.ip,\n            ipVersion: sanitizationResult.ipVersion,\n        };\n    }\n    const { labels, domain } = sanitizationResult;\n    if (hostname === \"\" ||\n        RESERVED_TOP_LEVEL_DOMAINS.includes(labels[labels.length - 1])) {\n        return {\n            type: ParseResultType.Reserved,\n            hostname: domain,\n            labels,\n        };\n    }\n    // Parse the serialized trie lazily\n    parsedIcannTrie = parsedIcannTrie !== null && parsedIcannTrie !== void 0 ? parsedIcannTrie : parseTrie(icannTrie);\n    parsedPrivateTrie = parsedPrivateTrie !== null && parsedPrivateTrie !== void 0 ? parsedPrivateTrie : parseTrie(privateTrie);\n    const icannTlds = lookUpTldsInTrie(labels, parsedIcannTrie);\n    const privateTlds = lookUpTldsInTrie(labels, parsedPrivateTrie);\n    if (icannTlds.length === 0 && privateTlds.length === 0) {\n        return {\n            type: ParseResultType.NotListed,\n            hostname: domain,\n            labels,\n        };\n    }\n    const indexOfPublicSuffixDomain = labels.length - Math.max(privateTlds.length, icannTlds.length) - 1;\n    const indexOfIcannDomain = labels.length - icannTlds.length - 1;\n    return Object.assign({ type: ParseResultType.Listed, hostname: domain, labels, icann: splitLabelsIntoDomains(labels, indexOfIcannDomain) }, splitLabelsIntoDomains(labels, indexOfPublicSuffixDomain));\n};\n"],"names":[],"sourceRoot":"","x_google_ignoreList":[0,1,2,3,4,5]}