{"version":3,"file":"bundled/chunk.npm-ns.scamsniffer.detector.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3I0C;AAC1C;AACA;AACO;AACP;AACO;AACP;AACA;AACO,yCAAyC,IAAI;AAC7C;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,0CAA0C,gCAAgC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,mCAAmC;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACO;AACP,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,mCAAmC;AAC/C;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA,kBAAkB;AAClB,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,gCAAgC,2BAA2B;AAC3D;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,wBAAwB,MAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9NmD;AACM;AACpB;AACuB;AAChC;AAC4C;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,iBAAiB,aAAe;AAChC;AACA;AACA,wBAAwB,oCAAW;AACnC;AACA,aAAa,oCAAe;AAC5B,oBAAoB,gDAAgD;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oCAAe;AAC5B,aAAa,oCAAe;AAC5B,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA,gCAAgC,MAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+BAA+B;AAC3C,YAAY,yBAAyB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8BAAK;AAC3B;AACA;AACA;AACA,uDAAuD;AACvD,YAAY,gDAAgD;AAC5D,YAAY,2EAA2E;AACvF;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,OAAO;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,4BAA0B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,gCAAgC,6BAA6B;AAC7D;AACA,mDAAmD,iBAAiB;AACpE;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,iBAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,gCAAgC,6BAA6B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8BAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,wCAAwC;AAC1D;AACA,wBAAwB,oBAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2BAA2B;AAC3C,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8BAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,eAAe,eAAe,SAAS,GAAG,QAAQ;AAClF,8BAA8B,8BAAK;AACnC;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,gCAAgC;AAChC,4CAA4C;AACnD;AACA;AACO,gDAAgD;AACvD;AACA;AACA,KAAK;AACL;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,8BAAK;AACnB;AACA;AACA;AACA,mDAAmD;AACnD;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;AC1uBwE;AAChD","sources":["webpack://mask-network/./node_modules/.pnpm/@scamsniffer+detector@0.0.21_@swc+core@1.3.81_jest@28.1.3_typescript@5.3.0-beta/node_modules/@scamsniffer/detector/dist/esnext/src/characters.js","webpack://mask-network/./node_modules/.pnpm/@scamsniffer+detector@0.0.21_@swc+core@1.3.81_jest@28.1.3_typescript@5.3.0-beta/node_modules/@scamsniffer/detector/dist/esnext/src/confusables.js","webpack://mask-network/./node_modules/.pnpm/@scamsniffer+detector@0.0.21_@swc+core@1.3.81_jest@28.1.3_typescript@5.3.0-beta/node_modules/@scamsniffer/detector/dist/esnext/src/detector.js","webpack://mask-network/./node_modules/.pnpm/@scamsniffer+detector@0.0.21_@swc+core@1.3.81_jest@28.1.3_typescript@5.3.0-beta/node_modules/@scamsniffer/detector/dist/esnext/src/index.js"],"sourcesContent":["/** Confusables and their mapped alphanumerics supported by this library */\nexport const characters = new Map([\n    //   [\" \", \" \"],\n    [\"0\", \"⓿\"],\n    [\"1\", \"11⓵➊⑴¹𝟏𝟙１𝟷𝟣⒈𝟭1➀₁①❶⥠\"],\n    [\"2\", \"⓶⒉⑵➋ƻ²ᒿ𝟚２𝟮𝟤ᒾ𝟸Ƨ𝟐②ᴤ₂➁❷ᘝƨ\"],\n    [\"3\", \"³ȝჳⳌꞫ𝟑ℨ𝟛𝟯𝟥Ꝫ➌ЗȜ⓷ӠƷ３𝟹⑶⒊ʒʓǯǮƺ𝕴ᶾзᦡ➂③₃ᶚᴣᴟ❸ҘҙӬӡӭӟӞ\"],\n    [\"4\", \"𝟰𝟺𝟦𝟒➍ҶᏎ𝟜ҷ⓸ҸҹӴӵᶣ４чㄩ⁴➃₄④❹Ӌ⑷⒋\"],\n    [\"5\", \"𝟱⓹➎Ƽ𝟓𝟻𝟝𝟧５➄₅⑤⁵❺ƽ⑸⒌\"],\n    [\"6\", \"Ⳓ🄇𝟼Ꮾ𝟲𝟞𝟨𝟔➏⓺Ϭϭ⁶б６ᧈ⑥➅₆❻⑹⒍\"],\n    [\"7\", \"𝟕𝟟𝟩𝟳𝟽🄈⓻𐓒➐７⁷⑦₇❼➆⑺⒎\"],\n    [\"8\", \"𐌚🄉➑⓼８𝟠𝟪৪⁸₈𝟴➇⑧❽𝟾𝟖⑻⒏\"],\n    [\"9\", \"൭Ꝯ𝝑𝞋𝟅🄊𝟡𝟵Ⳋ⓽➒੧৭୨９𝟫𝟿𝟗⁹₉Գ➈⑨❾⑼⒐\"],\n    [\"10\", \"⓾❿➉➓🔟⑩⑽⒑\"],\n    [\"11\", \"⑪⑾⒒⓫\"],\n    [\"12\", \"⑫⑿⒓⓬\"],\n    [\"13\", \"⑬⒀⒔⓭\"],\n    [\"14\", \"⑭⒁⒕⓮\"],\n    [\"15\", \"⑮⒂⒖⓯\"],\n    [\"16\", \"⑯⒃⒗⓰\"],\n    [\"17\", \"⑰⒄⒘⓱\"],\n    [\"18\", \"⑱⒅⒙⓲\"],\n    [\"19\", \"⑲⒆⒚⓳\"],\n    [\"20\", \"⑳⒇⒛⓴\"],\n    [\"ae\", \"æ\"],\n    [\"OE\", \"Œ\"],\n    [\"oe\", \"œ\"],\n    [\"pi\", \"ᒆ\"],\n    [\"Nj\", \"ǋ\"],\n    [\"AE\", \"ᴁ\"],\n    [\n        \"A\",\n        \"𝑨𝔄ᗄ𝖠𝗔ꓯ𝞐🄐🄰Ꭿ𐊠𝕬𝜜𝐴ꓮᎪ𝚨ꭺ𝝖🅐Å∀🇦₳🅰𝒜𝘈𝐀𝔸дǺᗅⒶＡΑᾋᗩĂÃÅǍȀȂĀȺĄʌΛλƛᴀᴬДАልÄₐᕱªǞӒΆẠẢẦẨẬẮẰẲẴẶᾸᾹᾺΆᾼᾈᾉᾊᾌᾍᾎᾏἈἉἊἋἌἍἎἏḀȦǠӐÀÁÂẤẪ𝛢𝓐𝙰𝘼ᗩ\",\n    ],\n    [\n        \"a\",\n        \"∂⍺ⓐձǟᵃᶏ⒜аɒａαȃȁคǎმäɑāɐąᾄẚạảǡầẵḁȧӑӓãåάὰάăẩằẳặᾀᾁᾂᾃᾅᾆᾰᾱᾲᾳᾴᶐᾶᾷἀἁἂἃἄἅἆἇᾇậắàáâấẫǻⱥ𝐚𝑎𝒂𝒶𝓪𝔞𝕒𝖆𝖺𝗮𝘢𝙖𝚊𝛂𝛼𝜶𝝰𝞪⍶\",\n    ],\n    [\n        \"B\",\n        \"🄑𝔙𝖁ꞵ𝛃𝛽𝜷𝝱𝞫Ᏸ𐌁𝑩𝕭🄱𐊡𝖡𝘽ꓐ𝗕𝘉𝜝𐊂𝚩𝐁𝛣𝝗𝐵𝙱𝔹Ᏼᏼ𝞑Ꞵ𝔅🅑฿𝓑ᗿᗾᗽ🅱ⒷＢвϐᗷƁ乃ßცჩ๖βɮБՅ๒ᙖʙᴮᵇጌḄℬΒВẞḂḆɃദᗹᗸᵝᙞᙟᙝᛒᙗᙘᴃ🇧\",\n    ],\n    [\"b\", \"ꮟᏏ𝐛𝘣𝒷𝔟𝓫𝖇𝖻𝑏𝙗𝕓𝒃𝗯𝚋♭ᑳᒈｂᖚᕹᕺⓑḃḅҍъḇƃɓƅᖯƄЬᑲþƂ⒝ЪᶀᑿᒀᒂᒁᑾьƀҌѢѣᔎ\"],\n    [\"C\", \"ꞆႠ℃🄒ᏟⲤ🄲ꓚ𐊢𐌂🅲𐐕🅒☾ČÇⒸＣↃƇᑕㄈ¢८↻ĈϾՇȻᙅᶜ⒞ĆҀĊ©टƆℂℭϹС匚ḈҪʗᑖᑡᑢᑣᑤᑥⅭ𝐂𝐶𝑪𝒞𝓒𝕮𝖢𝗖𝘊𝘾ᔍ\"],\n    [\n        \"c\",\n        \"🝌ｃⅽ𝐜𝑐𝒄𝒸𝓬𝔠𝕔𝖈𝖼𝗰𝘤𝙘𝚌ᴄϲⲥсꮯ𐐽ⲥ𐐽ꮯĉｃⓒćčċçҁƈḉȼↄсርᴄϲҫ꒝ςɽϛ𝙲ᑦ᧚𝐜𝑐𝒄𝒸𝓬𝔠𝕔𝖈𝖼𝗰𝘤𝙘𝚌₵🇨ᥴᒼⅽ\",\n    ],\n    [\"D\", \"🄓Ꭰ🄳𝔡𝖉𝔻𝗗𝘋𝙳𝐷𝓓𝐃𝑫𝕯𝖣𝔇𝘿ꭰⅅ𝒟ꓓ🅳🅓ⒹＤƉᗪƊÐԺᴅᴰↁḊĐÞⅮᗞᑯĎḌḐḒḎᗫᗬᗟᗠᶛᴆ🇩\"],\n    [\"d\", \"Ꮷ𝔡𝖉ᑯꓒ𝓭ᵭ₫ԃⓓｄḋďḍḑḓḏđƌɖɗᵈ⒟ԁⅾᶁԀᑺᑻᑼᑽᒄᑰᑱᶑ𝕕𝖽𝑑𝘥𝒅𝙙𝐝𝗱𝚍ⅆ𝒹ʠժ\"],\n    [\n        \"E\",\n        \"£ᙓ⋿∃ⴺꓱ𝐄𝐸𝔈𝕰𝖤𝘌𝙴𝛦𝜠ꭼ🄔🄴𝙀𝔼𐊆𝚬ꓰ𝝚𝞔𝓔𝑬𝗘🅴🅔ⒺΈＥƎἝᕮƐモЄᴇᴱᵉÉ乇ЁɆꂅ€ÈℰΕЕⴹᎬĒĔĖĘĚÊËԐỀẾỄỂẼḔḖẺȄȆẸỆȨḜḘḚἘἙἚἛἜῈΈӖὲέЀϵ🇪\",\n    ],\n    [\n        \"e\",\n        \"əәⅇꬲꞓ⋴𝛆𝛜𝜀𝜖𝜺𝝐𝝴𝞊𝞮𝟄ⲉꮛ𐐩ꞒⲈ⍷𝑒𝓮𝕖𝖊𝘦𝗲𝚎𝙚𝒆𝔢𝖾𝐞Ҿҿⓔｅ⒠èᧉéᶒêɘἔềếễ૯ǝєεēҽɛểẽḕḗĕėëẻěȅȇẹệȩɇₑęḝḙḛ℮еԑѐӗᥱёἐἑἒἓἕℯ\",\n    ],\n    [\"F\", \"ᖵꘘꓞꟻᖷ𝐅𝐹𝑭𝔽𝕱𝖥𝗙𝙁𝙵𝟊℉🄕🄵𐊇𝔉𝘍𐊥ꓝꞘ🅵🅕𝓕ⒻＦғҒᖴƑԲϝቻḞℱϜ₣🇫Ⅎ\"],\n    [\"f\", \"𝐟ᵮ𝑓𝒇𝒻𝓯𝔣𝕗𝖿𝗳𝙛𝚏ꬵꞙẝ𝖋ⓕｆƒḟʃբᶠ⒡ſꊰʄ∱ᶂ𝘧\"],\n    [\"G\", \"𝗚𝘎🄖ꓖᏳ🄶Ꮐᏻ𝔾𝓖𝑮𝕲ꮐ𝒢𝙂𝖦𝙶𝔊𝐺𝐆🅶🅖ⒼＧɢƓʛĢᘜᴳǴĠԌĜḠĞǦǤԍ₲🇬⅁\"],\n    [\"g\", \"ᶃᶢⓖｇǵĝḡğġǧģց૭ǥɠﻭﻮᵍ⒢ℊɡᧁ𝐠𝑔𝒈𝓰𝔤𝕘𝖌𝗀𝗴𝘨𝙜𝚐\"],\n    [\n        \"H\",\n        \"Ἤ🄗𝆦🄷𝜢ꓧ𝘏𝐻𝝜𝖧𐋏𝗛ꮋℍᎻℌⲎ𝑯𝞖🅷🅗ዞǶԋⒽＨĤᚺḢḦȞḤḨḪĦⱧҢңҤῊΉῌἨἩἪἫἭἮἯᾘᾙᾚᾛᾜᾝᾞᾟӉӈҥΉн卄♓𝓗ℋН𝐇𝙃𝙷ʜ𝛨Η𝚮ᕼӇᴴᵸ🇭\",\n    ],\n    [\"h\", \"ꞕ৸𝕳ꚕᏲℏӊԊꜧᏂҺ⒣ђⓗｈĥḣḧȟḥḩḫẖħⱨհһከኩኪካɦℎ𝐡𝒉𝒽𝓱𝔥𝕙𝖍𝗁𝗵𝘩𝙝𝚑իʰᑋᗁɧんɥ\"],\n    [\n        \"I\",\n        \"ⲒἿ🄘🄸ЇꀤᏆ🅸🅘إﺇٳأﺃٲٵⒾＩ៸ÌÍÎĨĪĬİÏḮỈǏȈȊỊĮḬƗェエῘῙῚΊἸἹἺἻἼἽἾⅠΪΊɪᶦᑊᥣ𝛪𝐈𝙄𝙸𝓵𝙡𝐼ᴵ𝚰𝑰🇮\",\n    ],\n    [\n        \"i\",\n        \"⍳ℹⅈ𝑖𝒊𝒾ı𝚤ɩιιͺ𝛊𝜄𝜾𝞲ꙇӏꭵᎥⓘｉìíîĩīĭïḯỉǐȉȋịḭῐῑῒΐῖῗἰἱἲⅰⅼ∣ⵏ￨׀ا١۱ߊᛁἳἴἵɨіὶίᶖ𝔦𝚒𝝸𝗂𝐢𝕚𝖎𝗶𝘪𝙞ίⁱᵢ𝓲⒤\",\n    ],\n    [\"J\", \"𝐉𝐽𝑱𝒥𝓙𝔍𝕁𝕵𝖩𝗝𝘑𝙅𝙹ꞲͿꓙ🄙🄹🅹🅙ⒿＪЈʝᒍנﾌĴʆวلյʖᴊᴶﻝጋɈⱼՂๅႱįᎫȷ丿ℐℑᒘᒙᒚᒛᒴᒵᒎᒏ🇯\"],\n    [\"j\", \"𝚥ꭻⅉⓙｊϳʲ⒥ɉĵǰјڶᶨ𝒿𝘫𝗷𝑗𝙟𝔧𝒋𝗃𝓳𝕛𝚓𝖏𝐣\"],\n    [\"K\", \"𝐊ꝄꝀ𝐾𝑲𝓚𝕶𝖪𝙺𝚱𝝟🄚𝗞🄺𝜥𝘒ꓗ𝙆𝕂Ⲕ𝔎𝛫Ꮶ𝞙𝒦🅺🅚₭ⓀＫĸḰќƘкҠκқҟӄʞҚКҡᴋᴷᵏ⒦ᛕЌጕḲΚKҜҝҞĶḴǨⱩϗӃ🇰\"],\n    [\"k\", \"ⓚꝁｋḱǩḳķḵƙⱪᶄ𝐤𝘬𝗄𝕜𝜅𝜘𝜿𝝒𝝹𝞌𝞳𝙠𝚔𝑘𝒌ϰ𝛋𝛞𝟆𝗸𝓴𝓀\"],\n    [\n        \"L\",\n        \"𝐋𝐿𝔏𝕃𝕷𝖫𝗟𝘓𝙇ﴼ🄛🄻𐐛Ⳑ𝑳𝙻𐑃𝓛ⳑꮮᏞꓡ🅻🅛ﺈ└ⓁւＬĿᒪ乚ՆʟꓶιԼᴸˡĹረḶₗΓլĻᄂⅬℒⱢᥧᥨᒻᒶᒷᶫﺎᒺᒹᒸᒫ⎳ㄥŁⱠﺄȽ🇱\",\n    ],\n    [\"l\", \"ⓛｌŀĺľḷḹļӀℓḽḻłﾚɭƚɫⱡ|Ɩ⒧ʅǀוןΙІ｜ᶩӏ𝓘𝕀𝖨𝗜𝘐𝐥𝑙𝒍𝓁𝔩𝕝𝖑𝗅𝗹𝘭𝚕𝜤𝝞ı𝚤ɩι𝛊𝜄𝜾𝞲\"],\n    [\"M\", \"ꮇ🄜🄼𐌑𐊰ꓟⲘᎷ🅼🅜ⓂＭмṂ൱ᗰ州ᘻო๓♏ʍᙏᴍᴹᵐ⒨ḾМṀ௱ⅯℳΜϺᛖӍӎ𝐌𝑀𝑴𝓜𝔐𝕄𝕸𝖬𝗠𝘔𝙈𝙼𝚳𝛭𝜧𝝡𝞛🇲\"],\n    [\"m\", \"₥ᵯ𝖒𝐦𝗆𝔪𝕞𝓂ⓜｍനᙢ൩ḿṁⅿϻṃጠɱ៳ᶆ𝙢𝓶𝚖𝑚𝗺᧕᧗\"],\n    [\n        \"N\",\n        \"𝇙𝇚𝇜🄝𝆧𝙉🄽ℕꓠ𝛮𝝢𝙽𝚴𝑵𝑁Ⲛ𝐍𝒩𝞜𝗡𝘕𝜨𝓝𝖭🅽₦🅝ЙЍⓃҋ៷ＮᴎɴƝᑎ几иՈռИהЛπᴺᶰŃ刀ክṄⁿÑПΝᴨոϖǸŇṆŅṊṈทŊӢӣӤӥћѝйᥢҊᴻ🇳\",\n    ],\n    [\n        \"n\",\n        \"ոռח𝒏𝓷𝙣𝑛𝖓𝔫𝗇𝚗𝗻ᥒⓝήｎǹᴒńñᾗηṅňṇɲņṋṉղຖՌƞŋ⒩ภกɳпŉлԉȠἠἡῃդᾐᾑᾒᾓᾔᾕᾖῄῆῇῂἢἣἤἥἦἧὴήበቡቢባቤብቦȵ𝛈𝜂𝜼𝝶𝞰𝕟𝘯𝐧𝓃ᶇᵰᥥ∩\",\n    ],\n    [\n        \"O\",\n        \"𝜽⭘🔿ꭴ⭕⏺🄁🄀Ꭴ𝚯𝚹𝛩𝛳𝜣𝜭𝝝𝝧𝞗𝞡ⴱᎾᏫ⍬𝞱𝝷𝛉𝟎𝜃θ𝟘𝑂𝑶𝓞𝔒𝕆𝕺𝗢𝘖𝙊𝛰㈇ꄲ🄞🔾🄾𐊒𝟬ꓳⲞ𐐄𐊫𐓂𝞞🅞⍥◯ⵁ⊖０⊝𝝤Ѳϴ𝚶𝜪ѺӦӨӪΌʘ𝐎ǑÒŎÓÔÕȌȎㇿ❍ⓄＯὋロ❤૦⊕ØФԾΘƠᴼᵒ⒪ŐÖₒ¤◊Φ〇ΟОՕଠഠ௦סỒỐỖỔṌȬṎŌṐṒȮȰȪỎỜỚỠỞỢỌỘǪǬǾƟⵔ߀៰⍜⎔⎕⦰⦱⦲⦳⦴⦵⦶⦷⦸⦹⦺⦻⦼⦽⦾⦿⧀⧁⧂⧃ὈὉὊὌὍ\",\n    ],\n    [\n        \"o\",\n        \"ంಂംං૦௦۵ℴ𝑜𝒐𝖔ꬽ𝝄𝛔𝜎𝝈𝞂ჿ𝚘০୦ዐ𝛐𝗈𝞼ဝⲟ𝙤၀𐐬𝔬𐓪𝓸🇴⍤○ϙ🅾𝒪𝖮𝟢𝟶𝙾𝘰𝗼𝕠𝜊𝐨𝝾𝞸ᐤⓞѳ᧐ᥲðｏఠᦞՓòөӧóºōôǒȏŏồốȍỗổõσṍȭṏὄṑṓȯȫ๏ᴏőöѻоዐǭȱ০୦٥౦೦൦๐໐οօᴑ०੦ỏơờớỡởợọộǫøǿɵծὀὁόὸόὂὃὅ\",\n    ],\n    [\"P\", \"🄟🄿ꓑ𝚸𝙿𝞠𝙋ꮲⲢ𝒫𝝦𝑃𝑷𝗣𝐏𐊕𝜬𝘗𝓟𝖯𝛲Ꮲ🅟Ҏ🅿ⓅＰƤᑭ尸Ṗրφքᴘᴾᵖ⒫ṔｱקРየᴩⱣℙΡῬᑸᑶᑷᑹᑬᑮ🇵₱\"],\n    [\"p\", \"ⲣҏ℗ⓟｐṕṗƥᵽῥρрƿǷῤ⍴𝓹𝓅𝐩𝑝𝒑𝔭𝕡𝖕𝗉𝗽𝘱𝙥𝚙𝛒𝝆𝞺𝜌𝞀\"],\n    [\"Q\", \"🅀🄠Ꝗ🆀🅠ⓆＱℚⵕԚ𝐐𝑄𝑸𝒬𝓠𝚀𝘘𝙌𝖰𝕼𝔔𝗤🇶\"],\n    [\"q\", \"𝓆ꝗ𝗾ⓠｑգ⒬۹զᑫɋɊԛ𝗊𝑞𝘲𝕢𝚚𝒒𝖖𝐪𝔮𝓺𝙦\"],\n    [\"R\", \"℞🄡℟ꭱᏒ𐒴ꮢᎡꓣ🆁🅡ⓇＲᴙȒʀᖇя尺ŔЯરƦᴿዪṚɌʁℛℜℝṘŘȐṜŖṞⱤ𝐑𝑅𝑹𝓡𝕽𝖱𝗥𝘙𝙍𝚁ᚱ🇷ᴚ\"],\n    [\"r\", \"𝚛ꭇᣴℾ𝚪𝛤𝜞𝝘𝞒ⲄГᎱᒥꭈⲅꮁⓡｒŕṙřȑȓṛṝŗгՐɾᥬṟɍʳ⒭ɼѓᴦᶉ𝐫𝑟𝒓𝓇𝓻𝔯𝕣𝖗𝗋𝗿𝘳𝙧ᵲґᵣ\"],\n    [\"S\", \"🅂🄪🄢ꇙ𝓢𝗦Ꮪ𝒮Ꮥ𝚂𝐒ꓢ𝖲𝔖𝙎𐊖𝕾𐐠𝘚𝕊𝑆𝑺🆂🅢ⓈＳṨŞֆՏȘˢ⒮ЅṠŠŚṤŜṦṢടᔕᔖᔢᔡᔣᔤ\"],\n    [\"s\", \"ᣵⓢꜱ𐑈ꮪｓśṥŝṡšṧʂṣṩѕşșȿᶊక𝐬𝑠𝒔𝓈𝓼𝔰𝕤𝖘𝗌𝘀𝘴𝙨𝚜ގ🇸\"],\n    [\n        \"T\",\n        \"🅃🄣七ፒ𝜯🆃𐌕𝚻𝛵𝕋𝕿𝑻𐊱𐊗𝖳𝙏🝨𝝩𝞣𝚃𝘛𝑇ꓔ⟙𝐓Ⲧ𝗧⊤𝔗Ꭲꭲ𝒯🅣⏇⏉ⓉＴтҬҭƬイŦԵτᴛᵀｲፕϮŤ⊥ƮΤТ下ṪṬȚŢṰṮ丅丁ᐪ𝛕𝜏𝝉𝞃𝞽𝓣ㄒ🇹ጥ\",\n    ],\n    [\"t\", \"ⓣｔṫẗťṭțȶ੮էʇ†ţṱṯƭŧᵗ⒯ʈեƫ𝐭𝑡𝒕𝓉𝓽𝔱𝕥𝖙𝗍𝘁𝘵𝙩𝚝ナ\"],\n    [\n        \"U\",\n        \"🅄Џ🄤ሀꓴ𐓎꒤🆄🅤ŨŬŮᑗᑘǓǕǗǙⓊＵȖᑌ凵ƱմԱꓵЦŪՄƲᙀᵁᵘ⒰ŰપÜՍÙÚÛṸṺǛỦȔƯỪỨỮỬỰỤṲŲṶṴɄᥩᑧ∪ᘮ⋃𝐔𝑈𝑼𝒰𝓤𝔘𝕌𝖀𝖴𝗨𝘜𝙐𝚄🇺\",\n    ],\n    [\n        \"u\",\n        \"𝘂𝘶𝙪𝚞ꞟꭎꭒ𝛖𝜐𝝊𝞄𝞾𐓶ὺύⓤｕùũūừṷṹŭǖữᥙǚǜὗυΰนսʊǘǔúůᴜűųยûṻцሁüᵾᵤµʋủȕȗưứửựụṳṵʉῠῡῢΰῦῧὐὑϋύὒὓὔὕὖᥔ𝐮𝑢𝒖𝓊𝓾𝔲𝕦𝖚𝗎ᶙ\",\n    ],\n    [\"V\", \"𝑉𝒱𝕍𝗩🄥🅅ꓦ𝑽𝖵𝘝Ꮩ𝚅𝙑𝐕🆅🅥ⓋＶᐯѴᵛ⒱۷ṾⅴⅤṼ٧ⴸѶᐺᐻ🇻𝓥\"],\n    [\"v\", \"∨⌄⋁ⅴ𝐯𝑣𝒗𝓋𝔳𝕧𝖛𝗏ꮩሀⓥｖ𝜐𝝊ṽṿ౮งѵעᴠνטᵥѷ៴ᘁ𝙫𝚟𝛎𝜈𝝂𝝼𝞶𝘷𝘃𝓿\"],\n    [\"W\", \"𝐖𝑊𝓦𝔚𝕎𝖂𝖶𝗪𝙒𝚆🄦🅆ᏔᎳ𝑾ꓪ𝒲𝘞🆆Ⓦ🅦ｗＷẂᾧᗯᥕ山ѠຟచաЩШώщฬшᙎᵂʷ⒲ฝሠẄԜẀŴẆẈധᘺѿᙡƜ₩🇼\"],\n    [\"w\", \"𝐰ꝡ𝑤𝒘𝓌𝔀𝔴𝕨𝖜𝗐𝘄𝘸𝙬𝚠աẁꮃẃⓦ⍵ŵẇẅẘẉⱳὼὠὡὢὣωὤὥὦὧῲῳῴῶῷⱲѡԝᴡώᾠᾡᾢᾣᾤᾥᾦɯ𝝕𝟉𝞏\"],\n    [\n        \"X\",\n        \"ꭓꭕ𝛘𝜒𝝌𝞆𝟀ⲭ🞨𝑿𝛸🄧🞩🞪🅇🞫🞬𐌗Ⲭꓫ𝖃𝞦𝘟𐊐𝚾𝝬𝜲Ꭓ𐌢𝖷𝑋𝕏𝔛𐊴𝗫🆇🅧❌Ⓧ𝓧ＸẊ᙭χㄨ𝒳ӾჯӼҳЖΧҲᵡˣ⒳אሸẌꊼⅩХ╳᙮ᕁᕽⅹᚷⵝ𝙓𝚇乂𝐗🇽\",\n    ],\n    [\"x\", \"᙮ⅹ𝑥𝒙𝓍𝔵𝕩𝖝𝗑𝘅ᕁᕽⓧｘхẋ×ₓ⤫⤬⨯ẍᶍ𝙭ӽ𝘹𝐱𝚡⨰ﾒ𝔁\"],\n    [\n        \"Y\",\n        \"𝒴🄨𝓨𝔜𝖄𝖸𝘠𝙔𝚼𝛶𝝪𝞤УᎩᎽⲨ𝚈𝑌𝗬𝐘ꓬ𝒀𝜰𐊲🆈🅨ⓎＹὛƳㄚʏ⅄ϔ￥¥ՎϓγץӲЧЎሃŸɎϤΥϒҮỲÝŶỸȲẎỶỴῨῩῪΎὙὝὟΫΎӮӰҰұ𝕐🇾\",\n    ],\n    [\"y\", \"𝐲𝑦𝒚𝓎𝔂𝔶𝕪𝖞𝗒𝘆𝘺𝙮𝚢ʏỿꭚγℽ𝛄𝛾𝜸𝝲𝞬🅈ᎽᎩⓨｙỳýŷỹȳẏÿỷуყẙỵƴɏᵞɣʸᶌү⒴ӳӱӯўУʎ\"],\n    [\"Z\", \"🄩🅉ꓜ𝗭𝐙☡Ꮓ𝘡🆉🅩ⓏＺẔƵ乙ẐȤᶻ⒵ŹℤΖŻŽẒⱫ🇿\"],\n    [\"z\", \"𝑍𝒁𝒵𝓩𝖹𝙕𝚉𝚭𝛧𝜡𝝛𝞕ᵶꮓ𝐳𝑧𝒛𝓏𝔃𝔷𝕫𝖟𝗓𝘇𝘻𝙯𝚣ⓩｚźẑżžẓẕƶȥɀᴢጊʐⱬᶎʑᙆ\"],\n]);\n","import { characters } from \"./characters\";\n/* eslint-disable max-len, no-misleading-character-class, no-control-regex */\n/** @copyright Mathias Bynens <https://mathiasbynens.be/>. MIT license. */\nexport const regexSymbolWithCombiningMarks = /([\\0-\\u02FF\\u0370-\\u1AAF\\u1B00-\\u1DBF\\u1E00-\\u20CF\\u2100-\\uD7FF\\uE000-\\uFE1F\\uFE30-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])([\\u0300-\\u036F\\u1AB0-\\u1AFF\\u1DC0-\\u1DFF\\u20D0-\\u20FF\\uFE20-\\uFE2F]+)/g;\n/** @copyright Mathias Bynens <https://mathiasbynens.be/>. MIT license. */\nexport const regexLineBreakCombiningMarks = /[\\0-\\x08\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\u0300-\\u034E\\u0350-\\u035B\\u0363-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u061C\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D4-\\u08E1\\u08E3-\\u0903\\u093A-\\u093C\\u093E-\\u094F\\u0951-\\u0957\\u0962\\u0963\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u0A01-\\u0A03\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AE2\\u0AE3\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0C00-\\u0C03\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81-\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D01-\\u0D03\\u0D3E-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D82\\u0D83\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u180B-\\u180D\\u1885\\u1886\\u18A9\\u1920-\\u192B\\u1930-\\u193B\\u1A17-\\u1A1B\\u1A7F\\u1AB0-\\u1ABE\\u1B00-\\u1B04\\u1B34-\\u1B44\\u1B6B-\\u1B73\\u1B80-\\u1B82\\u1BA1-\\u1BAD\\u1BE6-\\u1BF3\\u1C24-\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE8\\u1CED\\u1CF2-\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF5\\u1DFB-\\u1DFF\\u200C\\u200E\\u200F\\u202A-\\u202E\\u2066-\\u206F\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3035\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA823-\\uA827\\uA880\\uA881\\uA8B4-\\uA8C5\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA953\\uA980-\\uA983\\uA9B3-\\uA9C0\\uAA29-\\uAA36\\uAA43\\uAA4C\\uAA4D\\uAAEB-\\uAAEF\\uAAF5\\uAAF6\\uABE3-\\uABEA\\uABEC\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFFF9-\\uFFFB]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD804[\\uDC00-\\uDC02\\uDC38-\\uDC46\\uDC7F-\\uDC82\\uDCB0-\\uDCBA\\uDD00-\\uDD02\\uDD27-\\uDD34\\uDD73\\uDD80-\\uDD82\\uDDB3-\\uDDC0\\uDDCA-\\uDDCC\\uDE2C-\\uDE37\\uDE3E\\uDEDF-\\uDEEA\\uDF00-\\uDF03\\uDF3C\\uDF3E-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF57\\uDF62\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC35-\\uDC46\\uDCB0-\\uDCC3\\uDDAF-\\uDDB5\\uDDB8-\\uDDC0\\uDDDC\\uDDDD\\uDE30-\\uDE40\\uDEAB-\\uDEB7]|\\uD807[\\uDC2F-\\uDC36\\uDC38-\\uDC3F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF51-\\uDF7E\\uDF8F-\\uDF92]|\\uD82F[\\uDC9D\\uDC9E\\uDCA0-\\uDCA3]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uDB40[\\uDC01\\uDC20-\\uDC7F\\uDD00-\\uDDEF]/g;\n/* eslint-enable max-len, no-misleading-character-class, no-control-regex */\n/** Skippable characters that are not confusables */\nexport const checkLNPRegex = /^(?:[~`!@#%^&*(){}[\\];:\"'<,.>?/\\\\|_+=-]|[a-zA-Z0-9\\s])+$/;\nexport function checkLNP(str) {\n    return checkLNPRegex.test(str);\n}\n/**\n * Utility function to call 2 other functions which remove Combining Marks/Invisible characters\n * @param str The text to clean.\n */\nexport function clean(str) {\n    return str\n        .replace(regexLineBreakCombiningMarks, \"\")\n        .replace(regexSymbolWithCombiningMarks, \"$1\")\n        .replace(/[\\u200B-\\u200D\\uFEFF\\u2063]/g, \"\");\n}\nexport function compareTwoStringsV1(first, second) {\n    first = first.replace(/\\s+/g, \"\");\n    second = second.replace(/\\s+/g, \"\");\n    if (first === second)\n        return 1; // identical or empty\n    if (first.length < 2 || second.length < 2)\n        return 0; // if either is a 0-letter or 1-letter string\n    let firstBigrams = new Map();\n    for (let i = 0; i < first.length - 1; i++) {\n        const bigram = first.substring(i, i + 2);\n        const count = firstBigrams.has(bigram) ? firstBigrams.get(bigram) + 1 : 1;\n        firstBigrams.set(bigram, count);\n    }\n    let intersectionSize = 0;\n    for (let i = 0; i < second.length - 1; i++) {\n        const bigram = second.substring(i, i + 2);\n        const count = firstBigrams.has(bigram) ? firstBigrams.get(bigram) : 0;\n        if (count > 0) {\n            firstBigrams.set(bigram, count - 1);\n            intersectionSize++;\n        }\n    }\n    return (2.0 * intersectionSize) / (first.length + second.length - 2);\n}\nexport function compareTwoStrings(fst, snd) {\n    var i, j, k, map, match, ref, ref1, sub;\n    if (fst.length < 2 || snd.length < 2) {\n        return 0;\n    }\n    map = new Map();\n    for (i = j = 0, ref = fst.length - 2; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {\n        sub = fst.substr(i, 2);\n        if (map.has(sub)) {\n            map.set(sub, map.get(sub) + 1);\n        }\n        else {\n            map.set(sub, 1);\n        }\n    }\n    match = 0;\n    for (i = k = 0, ref1 = snd.length - 2; 0 <= ref1 ? k <= ref1 : k >= ref1; i = 0 <= ref1 ? ++k : --k) {\n        sub = snd.substr(i, 2);\n        if (map.get(sub) > 0) {\n            match++;\n            map.set(sub, map.get(sub) - 1);\n        }\n    }\n    return (2.0 * match) / (fst.length + snd.length - 2);\n}\n;\n/** The current cache of all the supported alphabet characters  */\nexport const alphabetMap = new Map();\n/** The current cache of all the supported confusable characters */\nexport const confusablesMap = new Map();\nfor (const [base, alts] of characters.entries()) {\n    alphabetMap.set(base, [...alts]);\n    for (const char of alts) {\n        confusablesMap.set(char, base);\n    }\n}\n/**\n * Removes confusable unicode characters from a string.\n * @param str The text to remove confusables from.\n */\nexport function remove(str) {\n    let founded = new Set();\n    if (checkLNP(str))\n        return {\n            replaced: founded.size,\n            newContent: str,\n        };\n    ;\n    let newStr = \"\";\n    for (const char of clean(str)) {\n        let hitWord = confusablesMap.get(char);\n        if (hitWord) {\n            founded.add(hitWord);\n            // console.log(\"char\", {\n            //   char,\n            //   hitWord,\n            // });\n            // founded++;\n        }\n        newStr += hitWord || char;\n    }\n    return {\n        replaced: founded.size,\n        newContent: newStr,\n    };\n}\n/**\n * Randomly mixes up a string with random confusable characters.\n * @param str The text to obfuscate.\n */\nexport function obfuscate(str) {\n    let newStr = \"\";\n    for (const char of str) {\n        const charMap = alphabetMap.get(char);\n        newStr += charMap\n            ? charMap[Math.floor(Math.random() * charMap.length)]\n            : char;\n    }\n    return newStr;\n}\nexport async function fixWordsIfHasUnicode(content, callToActionsKeywords) {\n    const { newContent: fixedWords, replaced } = remove(content.toLowerCase());\n    const confusable = fixedWords !== content && replaced > 5;\n    let newText = content;\n    if (confusable) {\n        try {\n            const totalWords = fixedWords.split(\"\\n\").map((_) => _.split(\" \"));\n            // const { issues } = await spellCheckDocument(\n            //   {\n            //     uri: \"\",\n            //     text: fixedWords.toLowerCase(),\n            //   },\n            //   {},\n            //   {}\n            // );\n            // console.log(issues);\n            const toFixWords = [];\n            const allWords = [];\n            for (let index = 0; index < totalWords.length; index++) {\n                const linewords = totalWords[index];\n                for (let c = 0; c < linewords.length; c++) {\n                    const totalWord = linewords[c].toLowerCase();\n                    const matchSimWord = callToActionsKeywords.find((cWord) => {\n                        //  const sim = compareTwoStrings(totalWord, cWord);\n                        //  console.log({\n                        //    sim,\n                        //    totalWord,\n                        //    cWord,\n                        //  });\n                        return (totalWord.length === cWord.length &&\n                            compareTwoStrings(totalWord, cWord)) > 0.41;\n                    });\n                    // const hasIssue =\n                    //   issues.find((issue) => totalWord.includes(issue.text)) &&\n                    //   matchSimWord;\n                    if (matchSimWord) {\n                        // toFixWords.push(totalWord);\n                        allWords.push(matchSimWord);\n                    }\n                    else {\n                        allWords.push(totalWord.toLowerCase());\n                    }\n                }\n                allWords.push(\"\\n\");\n            }\n            newText = allWords.join(\" \");\n            // console.log(toFixWords);\n            // const all = await suggestionsForWords(toFixWords, {\n            //   numSuggestions: 1,\n            // });\n            // let index = 0;\n            // for await (const res of all) {\n            //   if (res.suggestions.length) {\n            //     newText = newText.replace(\n            //       `${index}_placeholder`,\n            //       res.suggestions[0].word\n            //     );\n            //     index++;\n            //   }\n            // }\n            // console.log(newText);\n        }\n        catch (error) {\n            console.log(\"error\");\n        }\n    }\n    return {\n        confusable,\n        content: newText,\n    };\n}\nasync function test() {\n    const words = `let's break it down ↓\nhow to throw an event in any ᴏɴᴄʏʙᴇʀ space`;\n    //   const fixedWords = remove(words);\n    //   const allWords = await Promise.all(\n    //     fixedWords.split(\" \").map(async (word) => {\n    //       const suggest = await suggestionsForWord(word);\n    //       if (suggest.suggestions.length) {\n    //         return suggest.suggestions[0].word;\n    //       } else {\n    //         return word;\n    //       }\n    //     })\n    //   );\n    //   console.log(allWords.join(' '));\n    const start = Date.now();\n    console.log(await fixWordsIfHasUnicode(words, [\n        \"Airdrop\",\n        \"Mint\",\n        \"minting\",\n        \"Supply\",\n        \"GIVEAWAY\",\n        \"claim\",\n    ]), Date.now() - start);\n}\n// test();\n","import builtInDatabase from \"./database/lite.json\";\nimport metamaskDatabase from \"./database/whitelist.json\";\nimport fetch from \"isomorphic-fetch\";\nimport { parseDomain, ParseResultType } from \"parse-domain\";\nimport urlParser from \"url\";\nimport { fixWordsIfHasUnicode, compareTwoStrings } from \"./confusables\";\nconst TOKEN_ENDPOINT = \"https://cdn.jsdelivr.net/gh/scamsniffer/explorer-database@main/data/v1\";\n// const TOKEN_ENDPOINT =\n//   \"https://raw.githubusercontent.com/scamsniffer/explorer-database/main/data/v1\";\nconst REPORT_ENDPOINT = \"https://api.scamsniffer.io/report\";\nconst REPORT_ENDPOINT_DEV = \"http://localhost/report\";\nconst remoteDatabase = \"https://raw.githubusercontent.com/scamsniffer/scamsniffer/main/database/generated/lite.json\";\nconst blackListDatabase = \"https://raw.githubusercontent.com/scamsniffer/scam-database/main/blacklist/all.json\";\nconst miniumWordsLength = 5;\nexport class DataCache {\n    constructor(fetchFunction, minutesToLive = 10) {\n        this.millisecondsToLive = minutesToLive * 60 * 1000;\n        this.fetchFunction = fetchFunction;\n        this.cache = null;\n        this.getData = this.getData.bind(this);\n        this.resetCache = this.resetCache.bind(this);\n        this.isCacheExpired = this.isCacheExpired.bind(this);\n        this.fetchDate = new Date(0);\n    }\n    isCacheExpired() {\n        return (this.fetchDate.getTime() + this.millisecondsToLive < new Date().getTime());\n    }\n    getData() {\n        if (!this.cache || this.isCacheExpired()) {\n            return this.fetchFunction().then((data) => {\n                this.cache = data;\n                this.fetchDate = new Date();\n                return data;\n            });\n        }\n        else {\n            // console.log(\"cache hit\");\n            return Promise.resolve(this.cache);\n        }\n    }\n    resetCache() {\n        this.fetchDate = new Date(0);\n    }\n}\nexport function getTopDomainFromUrl(url) {\n    let topDomain = null;\n    let domainName = null;\n    let topLevelDomainsName = [];\n    let subDomainsName = [];\n    const host = urlParser.parse(url).host;\n    if (host === null)\n        return null;\n    const parseResult = parseDomain(host);\n    switch (parseResult.type) {\n        case ParseResultType.Listed: {\n            const { hostname, domain, topLevelDomains, subDomains } = parseResult;\n            // if (url.indexOf(\"io-0x13d8faf4a690f5aed2c529.in\") > -1)\n            //   console.log(\"parseResult\", parseResult);\n            if (subDomains)\n                subDomainsName = subDomains;\n            topDomain = [domain].concat(topLevelDomains).join(\".\");\n            if (domain)\n                domainName = domain;\n            if (topLevelDomains)\n                topLevelDomainsName = topLevelDomains;\n            break;\n        }\n        case ParseResultType.Reserved:\n        case ParseResultType.NotListed: {\n            const { hostname } = parseResult;\n            break;\n        }\n        // default:\n        //   throw new Error(`${host} is an ip address or invalid domain`);\n    }\n    return {\n        topDomain,\n        domainName,\n        subDomainsName,\n        topLevelDomainsName,\n        host,\n    };\n}\nfunction getTopDomain(url) {\n    const host = urlParser.parse(url).host;\n    return {\n        topDomain: host,\n    };\n}\nfunction includeName(name, projectName) {\n    name = name.toLowerCase();\n    projectName = projectName.toLowerCase();\n    return (name.length > miniumWordsLength &&\n        projectName.length > miniumWordsLength &&\n        (name.includes(projectName) || projectName.includes(name)));\n}\n//  _.twitterUsername.length > miniumWordsLength && userId.includes(_.twitterUsername)\nfunction includeNameCheck(findName, name) {\n    findName = findName.toLowerCase();\n    name = name.toLowerCase();\n    return name.length > miniumWordsLength && findName.includes(name);\n}\nfunction compareName(name, name2) {\n    name = name.toLowerCase();\n    name2 = name2.toLowerCase();\n    // LossLess Labs (Shujin) match Lossless\n    const diffLimit = 4;\n    const diff = Math.abs(name2.length - name.length);\n    return (name.length > miniumWordsLength &&\n        name2.length > miniumWordsLength &&\n        name.includes(name2) &&\n        diff < diffLimit);\n}\n// adidas Originals\n// adidas Originals Into the Metaverse\nfunction matchNameInWords(nickName, projectName) {\n    const words = nickName.split(\" \");\n    return (words.length > 1 &&\n        projectName.toLowerCase().includes(nickName.toLowerCase()));\n}\nfunction compareUserId(id, id2) {\n    return id.toLowerCase() === id2.toLowerCase();\n}\nfunction compareText(keyword, fullText) {\n    return (keyword &&\n        keyword.length > miniumWordsLength &&\n        compareName(fullText, keyword));\n}\nfunction verifyProjectMeta(project, post) {\n    const { twitterUsername, externalUrl } = project;\n    const { userId, links, content } = post;\n    if (!userId)\n        return true;\n    if (!twitterUsername)\n        return true;\n    let isSame = compareUserId(twitterUsername, userId);\n    // TODO verify links\n    // if (isSame) {\n    //     const domainDetail = getTopDomain(externalUrl);\n    //     if (domainDetail && domainDetail.topDomain) {\n    //         const domain = domainDetail.topDomain;\n    //         const hasOfficialLinks = links.filter((link) => {\n    //             return link.indexOf(domain) > -1;\n    //         });\n    //         isSame = hasOfficialLinks.length !== 0 && links.length > 0;\n    //         console.log(\"isSame\", hasOfficialLinks);\n    //     }\n    // }\n    return isSame;\n}\nasync function computeCallToScore(text, callToActionsKeywords) {\n    let start = Date.now();\n    let result = null;\n    result = await fixWordsIfHasUnicode(text, callToActionsKeywords);\n    const comparText = result ? result.content : text;\n    const txtWords = comparText\n        .split(\"\\n\")\n        .map((_) => _.split(\" \"))\n        .reduce((all, words) => {\n        words.forEach((w) => all.add(w.toLowerCase().replace(new RegExp(\",\", \"g\"), \"\").split(\".\").join(\"\")));\n        return all;\n    }, new Set());\n    const matchWords = [];\n    const callActionScore = callToActionsKeywords\n        .map((keyword) => {\n        const isMatch = txtWords.has(keyword.toLowerCase());\n        if (isMatch) {\n            matchWords.push(keyword.toLowerCase());\n        }\n        return isMatch ? 2 : 0;\n    })\n        .reduce((totalScore, score) => totalScore + score, 0);\n    return {\n        txtWords,\n        callActionScore,\n        matchWords,\n    };\n}\nfunction getDomain(url) {\n    const regex = /(?:[\\w-]+\\.)+[\\w-]+/;\n    const result = regex.exec(url);\n    return result && result[0];\n}\nasync function getDomainMeta(domains) {\n    const req = await fetch(`https://whois.scamsniffer.io/?` + domains[0]);\n    const res = await req.json();\n    return res;\n}\nasync function _detectScam(post, database, options = {}) {\n    const { nickname, content, userId, links, pageDetails } = post;\n    const { ProjectList: allProjects, commonWords, BlackList, callToActionsKeywords, } = database;\n    // short links\n    let outLinks = links.filter((link) => {\n        return (!link.includes(\"twitter.com/\") &&\n            !link.includes(\"t.co/\") &&\n            !link.includes(\"bit.ly/\"));\n    });\n    // links\n    if (outLinks.length === 0) {\n        console.error('no links');\n        return null;\n    }\n    let matchType = \"unknown\";\n    const flags = {\n        checkName: true,\n        checkUserId: true,\n        checkBySim: true,\n        checkContent: false,\n        checkPage: true,\n        checkSubdomain: true,\n    };\n    if (userId) {\n        const twitterInBlackList = BlackList.twitter.find((id) => id.includes(`${userId}:`));\n        if (twitterInBlackList) {\n            const [twitter, projectSlug] = twitterInBlackList.split(\":\");\n            const project = allProjects.find((_) => _.slug === projectSlug);\n            if (project) {\n                return {\n                    ...project,\n                    matchType: \"twitter_in_black_list\",\n                    post,\n                };\n            }\n        }\n    }\n    let matchProject = null;\n    let callActionScore = 0;\n    let callActionTest = null;\n    if (content) {\n        callActionTest = await computeCallToScore(content, callToActionsKeywords);\n        callActionScore = callActionTest.callActionScore;\n    }\n    const fuzzyTwitterCheck = content && callActionScore != 0;\n    const hasContext = content ? true : false;\n    let fuzzyCheckResult = null;\n    if (fuzzyTwitterCheck) {\n        const skipCheck = nickname && userId\n            ? commonWords.find((word) => nickname.includes(word) || userId.includes(word))\n            : false;\n        if (skipCheck) {\n            return null;\n        }\n        // check nick name\n        if (nickname && flags.checkName) {\n            // full match\n            matchProject = allProjects.find((_) => _.name === nickname);\n            matchType = \"name_full_match\";\n            if (!matchProject && userId) {\n                matchProject = allProjects.find((_) => _.twitterUsername && includeNameCheck(userId, _.twitterUsername));\n                matchType = \"userId_match_twitter\";\n            }\n            if (!matchProject) {\n                matchProject = allProjects.find((_) => compareName(nickname, _.name));\n                matchType = \"nickname_match_name\";\n            }\n            if (!matchProject) {\n                // careful\n                matchProject = allProjects.find((_) => matchNameInWords(nickname, _.name));\n                matchType = \"nickname_match_name_words\";\n            }\n            if (matchProject && matchProject.twitterUsername && userId) {\n                const verified = verifyProjectMeta(matchProject, post);\n                if (!verified) {\n                    fuzzyCheckResult = {\n                        matchProject,\n                        matchType,\n                        post,\n                        callActionTest,\n                    };\n                }\n            }\n        }\n        // check userId\n        if (userId && flags.checkUserId && !fuzzyCheckResult) {\n            const matchProject = allProjects.find((_) => _.twitterUsername && includeName(userId, _.twitterUsername));\n            matchType = \"userId_match_twitter_name\";\n            if (matchProject && matchProject.twitterUsername && userId) {\n                const verified = verifyProjectMeta(matchProject, post);\n                if (!verified) {\n                    fuzzyCheckResult = {\n                        matchProject,\n                        matchType,\n                        post,\n                        callActionTest,\n                    };\n                }\n            }\n        }\n    }\n    if (flags.checkPage && pageDetails) {\n        let metaUrl = pageDetails.canonicalLink;\n        if (!metaUrl) {\n            const ogUrl = pageDetails.metaHeads[\"og:url\"];\n            if (ogUrl) {\n                metaUrl = ogUrl;\n            }\n        }\n        if (metaUrl) {\n            const siteDomain = getTopDomainFromUrl(links[0]);\n            const metaDomain = getTopDomainFromUrl(metaUrl);\n            if (metaDomain &&\n                siteDomain &&\n                siteDomain.topDomain !== metaDomain.topDomain) {\n                const matchProject = allProjects.find((_) => _.externalUrl &&\n                    metaDomain.topDomain &&\n                    _.externalUrl.includes(metaDomain.topDomain));\n                if (matchProject) {\n                    return {\n                        ...matchProject,\n                        matchType: \"check_page_hit\",\n                        post,\n                        callActionTest,\n                    };\n                }\n            }\n        }\n    }\n    if (flags.checkBySim) {\n        const whitelistDomainList = metamaskDatabase.whitelist;\n        const uniqueDomains = [];\n        outLinks.forEach((link) => {\n            const domainDetail = getTopDomainFromUrl(link);\n            if (domainDetail && domainDetail.domainName && domainDetail.topDomain) {\n                const isInWhiteList = whitelistDomainList.find((topDomain) => domainDetail.topDomain === topDomain);\n                if (!uniqueDomains.find((_) => _.topDomain === domainDetail.topDomain) &&\n                    !isInWhiteList)\n                    uniqueDomains.push({\n                        domainName: domainDetail.domainName,\n                        topDomain: domainDetail.topDomain,\n                        subDomainsName: domainDetail.subDomainsName\n                            ? domainDetail.subDomainsName\n                            : [],\n                    });\n                if (isInWhiteList) {\n                }\n            }\n        });\n        const projectsWithDomain = [];\n        const scoreLimit = 10;\n        const similarProjects = allProjects\n            .map((_) => {\n            let score = 0;\n            let matchItems = [];\n            let simLimit = 0.65;\n            const projectName = _.name;\n            // const projectDomain = _.externalUrl && getDomain(_.externalUrl);\n            if (_.domainDetail) {\n                // console.log('has index')\n            }\n            const projectDomainDetail = _.domainDetail\n                ? _.domainDetail\n                : _.externalUrl && getTopDomainFromUrl(_.externalUrl);\n            const compareItems = [];\n            if (projectDomainDetail)\n                projectsWithDomain.push({\n                    project: _,\n                    domain: projectDomainDetail,\n                });\n            if (nickname) {\n                compareItems.push([_.name, nickname, 1]);\n            }\n            if (_.twitterUsername && userId) {\n                compareItems.push([_.twitterUsername, userId, 1]);\n            }\n            const nameInContent = content && content.split(\" \").includes(_.name);\n            if (nameInContent) {\n                score += 5;\n            }\n            let hasSimLink = false;\n            let isSame = false;\n            uniqueDomains.forEach((domain) => {\n                if (!isSame) {\n                    isSame =\n                        projectDomainDetail &&\n                            projectDomainDetail.topDomain === domain.topDomain\n                            ? true\n                            : false;\n                }\n                if (projectDomainDetail && projectDomainDetail.domainName) {\n                    compareItems.push([\n                        domain.domainName,\n                        projectDomainDetail.domainName,\n                        2,\n                    ]);\n                    if (projectDomainDetail.topDomain) {\n                        compareItems.push([\n                            domain.domainName,\n                            projectDomainDetail.topDomain,\n                            2,\n                        ]);\n                    }\n                    if (projectDomainDetail.subDomainsName) {\n                        if (projectDomainDetail.subDomainsName[0] != \"www\")\n                            compareItems.push([\n                                domain.domainName,\n                                projectDomainDetail.subDomainsName[0],\n                                2,\n                            ]);\n                    }\n                    // if (domain.subDomainsName.length) {\n                    //   const firstSubDomain = domain.subDomainsName[0];\n                    //   if (firstSubDomain != \"www\") {\n                    //     compareItems.push([\n                    //       firstSubDomain,\n                    //       projectDomainDetail.domainName,\n                    //       2,\n                    //     ]);\n                    //   }\n                    // }\n                }\n                if (projectName)\n                    compareItems.push([\n                        domain.domainName,\n                        projectName.toLowerCase(),\n                        1,\n                    ]);\n            });\n            for (let index = 0; index < compareItems.length; index++) {\n                const [string1, string2, type] = compareItems[index];\n                const sim = (string1 && string2 && compareTwoStrings(string1, string2)) || 0;\n                score += sim > simLimit ? 5 : 0;\n                if (sim > simLimit && simLimit <= 1)\n                    matchItems.push({\n                        item: compareItems[index],\n                        sim,\n                    });\n                if (type == 2)\n                    hasSimLink = true;\n            }\n            return {\n                hasSimLink: isSame ? false : hasSimLink,\n                matchItems,\n                uniqueDomains,\n                project: _,\n                score: isSame ? 0 : score,\n            };\n        })\n            .filter((_) => _.score > scoreLimit)\n            .sort((a, b) => b.score - a.score);\n        if (similarProjects.length && (fuzzyTwitterCheck || options.onlyLink)) {\n            matchProject = similarProjects[0].project;\n            matchType = \"check_by_sim\";\n            const verified = verifyProjectMeta(matchProject, post);\n            if (similarProjects[0].hasSimLink && !verified) {\n                fuzzyCheckResult = {\n                    matchProject,\n                    matchType,\n                    post,\n                    callActionTest,\n                };\n            }\n        }\n        const checkDomain = projectsWithDomain.length;\n        if (checkDomain) {\n            const simThreshold = 0.65;\n            const domainRegLimit = options.registerDays || 10;\n            const simRegLimit = options.registerDaysSim || 30;\n            const simDayLimit = options.simDayLimit || 0.8;\n            const domainResult = fuzzyCheckResult\n                ? [\n                    {\n                        linkDomain: uniqueDomains[0],\n                        contain: false,\n                        sim: 0.6,\n                        projectWithDomain: {\n                            domain: fuzzyCheckResult.matchProject.domainDetail,\n                            project: fuzzyCheckResult.matchProject,\n                        },\n                    },\n                ]\n                : uniqueDomains.map((linkDomain) => {\n                    const domainInProjectList = projectsWithDomain.find((_) => _.domain.topDomain === linkDomain.topDomain);\n                    const highSimilarProjects = domainInProjectList\n                        ? []\n                        : projectsWithDomain\n                            .map((projectWithDomain) => {\n                            const subDomains = projectWithDomain.domain.subDomainsName;\n                            let aString = projectWithDomain.domain.domainName;\n                            const bString = linkDomain.domainName;\n                            const simSizeThreshold = 4;\n                            let sim = 0;\n                            let contain = false;\n                            function checkMatchItems(aString, bString) {\n                                if (aString) {\n                                    let canDoSimTest = bString.length > simSizeThreshold &&\n                                        aString.length > simSizeThreshold;\n                                    contain = canDoSimTest && bString.includes(aString);\n                                    sim = canDoSimTest\n                                        ? compareTwoStrings(aString, bString)\n                                        : 0;\n                                }\n                                // if (projectWithDomain.project.slug === \"otherdeed\") {\n                                //   console.log(\"project\", [aString, bString, sim, contain]);\n                                // }\n                            }\n                            if (aString) {\n                                checkMatchItems(aString, bString);\n                            }\n                            // subdomain-case  eg. murakamiflowers.kaikaikiki.com\n                            if (sim < simThreshold && subDomains && subDomains.length) {\n                                // if (projectWithDomain.project.slug === \"premint\") {\n                                //   console.log(\"compare subdomain\", sim, simThreshold);\n                                // }\n                                let aString = subDomains[0];\n                                let projectName = projectWithDomain.project.name.replace(new RegExp(\".\", \"\"), \"\");\n                                let subdomainInName = projectName\n                                    .toLowerCase()\n                                    .includes(aString);\n                                if (aString != \"www\" && subdomainInName) {\n                                    checkMatchItems(aString, bString);\n                                }\n                            }\n                            // subdomain case  eg. nfttrader.io-0x13d8faf4a690f5aed2c529.in match nfttrader.io\n                            const projectDomainName = projectWithDomain.domain.domainName;\n                            if (sim < simThreshold &&\n                                linkDomain.subDomainsName.length) {\n                                let linkSub = linkDomain.subDomainsName[0];\n                                if (linkSub != \"www\" && projectDomainName) {\n                                    checkMatchItems(projectDomainName, linkSub);\n                                }\n                            }\n                            return {\n                                contain,\n                                projectWithDomain,\n                                sim,\n                            };\n                        })\n                            .sort((a, b) => b.sim - a.sim)\n                            .filter((_) => _.sim > simThreshold || _.contain);\n                    return highSimilarProjects[0]\n                        ? {\n                            linkDomain,\n                            contain: highSimilarProjects[0].contain,\n                            sim: highSimilarProjects[0].sim,\n                            projectWithDomain: highSimilarProjects[0].projectWithDomain,\n                        }\n                        : null;\n                });\n            let similarProject = null;\n            let creationDaysOfDomain = -1;\n            let domainMeta = null;\n            for (let index = 0; index < domainResult.length; index++) {\n                const domainSim = domainResult[index];\n                if (!domainSim)\n                    continue;\n                if (!domainSim.linkDomain)\n                    continue;\n                // full match xxx.com xxx.io\n                const isFullyMatch = domainSim.sim === 1;\n                // contain match cc-xxx.com xxx.io\n                const simAndMatch = domainSim.contain && domainSim.sim > 0.7;\n                // const hasContainAndSim = ;\n                const isCommonWords = commonWords.includes(domainSim.linkDomain.domainName);\n                if (isFullyMatch || simAndMatch) {\n                    if (hasContext) {\n                        // in twitter context\n                        if (fuzzyTwitterCheck)\n                            similarProject = domainSim;\n                    }\n                    else {\n                        similarProject = domainSim;\n                    }\n                    if (!isCommonWords) {\n                        continue;\n                    }\n                }\n                try {\n                    domainMeta = options.skipDomainMeta\n                        ? null\n                        : await getDomainMeta([domainSim.linkDomain.topDomain]);\n                    if (!domainMeta)\n                        continue;\n                    const domainDetail = domainMeta.data;\n                    if (!domainDetail) {\n                        console.log(\"domainMeta\", domainMeta);\n                        continue;\n                    }\n                    const createDate = domainDetail.creationDate || domainDetail.updatedDate;\n                    creationDaysOfDomain = createDate\n                        ? Math.floor((Date.now() - new Date(createDate).getTime()) / 1000 / 86400)\n                        : -1;\n                    const isRecentRegister = creationDaysOfDomain != -1 &&\n                        creationDaysOfDomain <\n                            (domainSim.sim > simDayLimit ? simRegLimit : domainRegLimit);\n                    if (isRecentRegister) {\n                        similarProject = domainSim;\n                        if (hasContext && !fuzzyTwitterCheck)\n                            similarProject = null;\n                        break;\n                    }\n                    else {\n                        // console.log(\"not recent\", domainMeta);\n                    }\n                }\n                catch (er) {\n                    console.error(\"check failed\", er);\n                }\n            }\n            if (similarProject) {\n                const matchProject = similarProject.projectWithDomain.project;\n                const matchType = \"match_by_domain_sim_days:\" +\n                    creationDaysOfDomain +\n                    \":sim:\" +\n                    similarProject.sim.toFixed(2);\n                return {\n                    ...matchProject,\n                    matchType,\n                    post,\n                    callActionTest,\n                    domainMeta: domainMeta ? domainMeta.data : null,\n                };\n            }\n        }\n    }\n    return null;\n}\nasync function fetchScamDatabase() {\n    const req = await fetch(blackListDatabase);\n    return await req.json();\n}\n// 5 minutes ttl\nconst fetchScamDatabaseWithCache = new DataCache(fetchScamDatabase, 5);\nasync function checkIsInBlacklist(type, value) {\n    let isHit = false;\n    try {\n        const database = await fetchScamDatabaseWithCache.getData();\n        isHit = database[type].includes(value);\n    }\n    catch (e) { }\n    return isHit;\n}\nexport class Detector {\n    constructor({ onlyBuiltIn = true, databaseUrl = null }) {\n        this.onlyBuiltIn = onlyBuiltIn;\n        this.database = builtInDatabase;\n        this.databaseUrl = databaseUrl || remoteDatabase;\n        this.lastFetch = null;\n        this.fetching = false;\n        this.buildIndex();\n    }\n    async buildIndex() {\n        const { ProjectList: allProjects } = this.database;\n        for (let index = 0; index < allProjects.length; index++) {\n            const allProject = allProjects[index];\n            if (allProject.domainDetail) {\n                continue;\n            }\n            const domainDetail = allProject.externalUrl && getTopDomainFromUrl(allProject.externalUrl);\n            if (domainDetail) {\n                allProject.domainDetail = domainDetail;\n            }\n        }\n    }\n    async update() {\n        if (this.fetching)\n            return;\n        if (this.lastFetch) {\n            const timeLeft = Date.now() - this.lastFetch;\n            if (timeLeft < 1000 * 60 * 5) {\n                return;\n            }\n        }\n        this.fetching = true;\n        try {\n            const req = await fetch(this.databaseUrl);\n            const remoteData = await req.json();\n            this.database = remoteData;\n            await this.buildIndex();\n        }\n        catch (e) {\n            console.error(\"fetch from remote failed\", e);\n        }\n        this.fetching = false;\n        this.lastFetch = Date.now();\n    }\n    async detectScam(post, options = {}) {\n        try {\n            if (!this.onlyBuiltIn)\n                this.update();\n            return await _detectScam(post, this.database, options);\n        }\n        catch (e) {\n            console.error(\"error\", e);\n        }\n        return null;\n    }\n    async checkUrlInBlacklist(url) {\n        const domain = getTopDomainFromUrl(url);\n        if (!domain || domain === null)\n            return false;\n        if (domain.host === null)\n            return false;\n        return await checkIsInBlacklist(\"domains\", domain.host);\n    }\n    async checkNFTToken(contract, tokenId) {\n        let result = null;\n        try {\n            const dataPath = `${TOKEN_ENDPOINT}/collections/${contract}/${tokenId}.json`;\n            const req = await fetch(dataPath);\n            const response = (await req.json());\n            const { chain_activity } = response;\n            result = {\n                firstTime: chain_activity.firstTime,\n                receivers: chain_activity.receivers,\n            };\n        }\n        catch (e) { }\n        return result;\n    }\n}\nexport const detector = new Detector({});\nexport async function detectScam(post, options = {}) {\n    return detector.detectScam(post, options);\n}\nexport async function detectScamByUrl(url, options = {}) {\n    return detector.detectScam({\n        links: [url],\n    }, options);\n}\nconst REPORT_CACHE = [];\nconst CACHE_SIZE = 100;\nexport async function reportScam(result) {\n    const API_ENDPOINT = typeof process !== \"undefined\" && process.env.DEV\n        ? REPORT_ENDPOINT_DEV\n        : REPORT_ENDPOINT;\n    const postId = result.post.id;\n    if (REPORT_CACHE.length > CACHE_SIZE) {\n        REPORT_CACHE.shift();\n    }\n    if (postId && REPORT_CACHE.includes(postId)) {\n        return;\n    }\n    try {\n        await fetch(API_ENDPOINT, {\n            mode: \"cors\",\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json; charset=UTF-8\",\n                Accept: \"application/json\",\n            },\n            body: JSON.stringify(result),\n        });\n    }\n    catch (error) { }\n    if (postId)\n        REPORT_CACHE.push(postId);\n}\n","export { reportScam, detectScam, detector, Detector } from './detector';\nexport * from './types';\n"],"names":[],"sourceRoot":"","x_google_ignoreList":[0,1,2,3]}