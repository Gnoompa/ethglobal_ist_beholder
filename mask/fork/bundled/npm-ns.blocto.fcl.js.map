{"version":3,"file":"bundled/npm-ns.blocto.fcl.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAwC;AACA;AACA;AACwO;AACiO;AAC/b;AACC;AACd;AACI;AACqB;AACS;AAC8E;AAClH;AACU;AACN;AACP;AAC6C;;AAE7E;AACA,yBAAyB,4DAAQ,EAAE,4EAAwB,UAAU,8DAAU;AAC/E;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,2DAAM;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAM;AAC5B;AACA;AACA;AACA,sBAAsB,2DAAM;AAC5B;AACA,QAAQ,6DAAG;AACX;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR,wBAAwB,2DAAM;AAC9B,qBAAqB,6DAAG;AACxB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,EAAE,2EAAS;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA,SAAS,2DAAM;AACf;AACA;AACA;AACA;AACA;AACA,GAAG,QAAQ;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+DAAM;AACN;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,iDAAiD,+DAAM;AACvD;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,2DAAO,EAAE,0CAAG;AACxC;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ,EAAE,2EAAS,yCAAyC,KAAK;AACzD;AACA;AACA,gBAAgB,kDAAc;AAC9B,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,EAAE,2EAAS,yCAAyC,KAAK;AACzD,EAAE,2EAAS,sCAAsC,KAAK;AACtD,4CAA4C,+DAAM;AAClD;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE,2EAAS;AACX;AACA,EAAE,2EAAS;AACX;AACA,EAAE,2EAAS,4CAA4C,SAAS;AAChE;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,EAAE,qEAAW,iDAAiD,SAAS;AACvE,EAAE,qEAAW,wDAAwD,SAAS;AAC9E,EAAE,qEAAW,iDAAiD,UAAU;AACxE,EAAE,qEAAW,wDAAwD,UAAU;AAC/E,EAAE,qEAAW,qEAAqE,UAAU;AAC5F;AACA;AACA;AACA;AACA;AACA,QAAQ,qEAAW,+GAA+G,sBAAsB;AACxJ,QAAQ,qEAAW,4HAA4H,sBAAsB;AACrK;AACA;AACA,QAAQ,qEAAW,2EAA2E,SAAS,sCAAsC,sBAAsB;AACnK;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,EAAE,2EAAS;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2EAAS,mIAAmI,yBAAyB;AAC7K;AACA;AACA,QAAQ,2EAAS,2FAA2F,0BAA0B,WAAW,uCAAuC,UAAU,QAAQ;AAC1M,QAAQ,2EAAS,iGAAiG,0BAA0B,WAAW,uCAAuC,UAAU,QAAQ;AAChN,wDAAwD,0EAAU;AAClE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE,2EAAS,sBAAsB,KAAK;AACtC;AACA,EAAE,2EAAS,oBAAoB,KAAK;AACpC;AACA,EAAE,2EAAS,sCAAsC,KAAK,GAAG,mBAAmB;AAC5E;AACA,EAAE,2EAAS,gDAAgD,KAAK,GAAG,SAAS;AAC5E;AACA,EAAE,2EAAS,8CAA8C,KAAK,GAAG,SAAS;AAC1E;AACA,EAAE,2EAAS,wBAAwB,8DAAU,4BAA4B,KAAK,0EAA0E,iGAAiG;AACzP;AACA,EAAE,2EAAS,OAAO,8DAAU,6BAA6B,KAAK,4EAA4E,iGAAiG;AAC3O;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,yBAAyB;AACrC,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA,SAAS,8DAAU,mCAAmC;AACtD;AACA,EAAE,4DAAQ,EAAE,8DAAU,gBAAgB,4DAAQ,kFAAkF,6DAAS,oBAAoB,8DAAU;AACvK;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0EAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,eAAe;AACf,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0EAAU;AAC7B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,eAAe;AACf,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0EAAU;AAC7B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,oDAAoD,aAAa;AACjE;AACA;AACA;;AAEA;AACA,SAAS,yDAAU;AACnB;AACA;AACA,0BAA0B,0EAAU;AACpC,4BAA4B,0EAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,0EAAU;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4FAA4F;AAC5F;AACA;AACA;AACA,+BAA+B;AAC/B,4BAA4B;AAC5B;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,KAAK;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE,2EAAS;AACX;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,EAAE,2EAAS;AACX;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qCAAqC;AACxE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,2EAAS;AACX;AACA,GAAG;AACH;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gKAAgK,EAAE,WAAW,EAAE,QAAQ,EAAE,SAAS,EAAE;AACpM;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,8BAA8B,mBAAmB;AACjD;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,IAAI;AACJ,iCAAiC,qCAAqC;AACtE,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gFAAgF,IAAI,eAAe,MAAM;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,eAAe,8DAAG;AAClB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oCAAoC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oCAAoC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,eAAe,8DAAG;AAClB;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oCAAoC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oCAAoC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,eAAe,8DAAG;AAClB;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oCAAoC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oCAAoC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oCAAoC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,EAAE,2EAAS;AACX;AACA,IAAI,2EAAS;AACb,IAAI,2EAAS,qFAAqF,QAAQ;AAC1G,IAAI,2EAAS,yFAAyF,WAAW;AACjH;AACA,EAAE,2EAAS;AACX,EAAE,2EAAS;AACX,EAAE,2EAAS;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,2EAAS,8EAA8E,oBAAoB;AAC/G;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR,QAAQ,iEAAG;AACX;AACA,2CAA2C,wBAAwB;AACnE,iBAAiB,gEAAM;AACvB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE,2EAAS;AACX;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI,2EAAS;AACb,IAAI,2EAAS;AACb,IAAI,2EAAS,qDAAqD,UAAU;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,YAAY;AACZ,eAAe;AACf;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,MAAM,2EAAS;AACf;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA,IAAI;AACJ,IAAI,iEAAG;AACP,qCAAqC,cAAc;AACnD;AACA,aAAa,gEAAM;AACnB,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0EAAU;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sCAAsC,2DAAM;AAC5C,sCAAsC,2DAAM;AAC5C;AACA,+CAA+C,2DAAM;AACrD,EAAE,2EAAS;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ,yBAAyB,2DAAM;AAC/B,EAAE,2EAAS;AACX,wBAAwB,2DAAM;AAC9B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,kEAAI;AACR;AACA,KAAK;AACL,IAAI;AACJ,IAAI,iEAAG;AACP,gBAAgB,YAAY;AAC5B;AACA,aAAa,gEAAM;AACnB,KAAK;AACL;AACA;AACA;AACA,GAAG,8DAAI;AACP;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH,GAAG,mEAAS;AACZ;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH,GAAG,qEAAW;AACd;AACA;AACA,GAAG;AACH;AACA,6BAA6B,mEAAK;;AAElC;AACA,aAAa,oCAAoC;AACjD;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,UAAU;AACxB,cAAc,UAAU;AACxB,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB,eAAe;AACf;AACA,mBAAmB,wEAAU;AAC7B;AACA;AACA,eAAe;AACf;AACA,kBAAkB,wEAAU;AAC5B;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,wCAAwC;AACrD,aAAa,+CAA+C;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,8DAAI;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sBAAsB;AACnD;AACA;AACA,0BAA0B,2DAAM;AAChC;AACA;AACA;AACA;AACA,GAAG;AACH,GAAG,mEAAS;AACZ;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH,GAAG,qEAAW;AACd;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,0BAA0B,2DAAM;AAChC;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,0BAA0B,2DAAM;AAChC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,+BAA+B,mEAAK;AACpC;AACA;AACA;AACA;AACA,uCAAuC,2DAAM;AAC7C;AACA;AACA,IAAI,iEAAG;AACP;AACA;AACA,mEAAmE;AACnE,uDAAuD;AACvD;AACA,aAAa,gEAAM;AACnB,KAAK;AACL;AACA;AACA;AACA;AACA,EAAE,2EAAS;AACX,EAAE,2EAAS;AACX;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa,sBAAsB;AACnC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,UAAU,kEAAI;AACd,UAAU;AACV,UAAU,iEAAG;AACb,sBAAsB,YAAY;AAClC;AACA,mBAAmB,gEAAM;AACzB,WAAW;AACX,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM,iEAAG;AACT,kBAAkB,YAAY;AAC9B;AACA,eAAe,gEAAM;AACrB,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM,kEAAI;AACV,MAAM;AACN,MAAM,iEAAG;AACT,kBAAkB,OAAO;AACzB;AACA,eAAe,gEAAM;AACrB,OAAO;AACP,MAAM;AACN;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,EAAE,kEAAI;AACN;AACA;AACA;AACA;AACA,wBAAwB;AACxB,qBAAqB;AACrB,6BAA6B;AAC7B,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0EAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA,eAAe,mEAAK;AACpB,mBAAmB,mEAAS;AAC5B;AACA;AACA;AACA,uBAAuB,qEAAW;AAClC;AACA;AACA;AACA;AACA,GAAG;AACH,eAAe,kEAAI;AACnB;;AAEA;AACA;AACA,aAAa,sBAAsB;AACnC;AACA;AACA;AACA,SAAS,kEAAI;AACb;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,IAAI;AACJ,SAAS,+DAAG,CAAC,0EAAU,QAAQ,kDAAW;AAC1C;AACA;AACA,EAAE,2EAAS;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,+BAA+B;AAC5C;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE,2EAAS;AACX;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,yBAAyB;AACrC,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,8DAAU;AAClC,WAAW,8DAAU,mCAAmC;AACxD;AACA,IAAI,4DAAQ,EAAE,mEAAe,gBAAgB,4DAAQ,wEAAwE,6DAAS;AACtI;AACA,IAAI,gEAAY;AAChB;AACA,IAAI,6DAAS;AACb;AACA,IAAI,sEAAkB,sDAAsD,8DAAU;AACtF;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA,cAAc,0EAAU;AACxB;AACA;AACA;;AAEA,6CAA6C,yDAAM;AACnD,4CAA4C,yDAAM;AAClD;AACA,6BAA6B,yDAAM;AACnC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,EAAE,2EAAS;AACX,EAAE,2EAAS;AACX,EAAE,2EAAS;AACX,EAAE,2EAAS;AACX,wDAAwD,yDAAM;AAC9D;AACA,WAAW,yDAAM,mCAAmC,6DAAM,+BAA+B,0EAAU;AACnG;AACA,SAAS,6DAAM,+BAA+B,0EAAU;AACxD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iFAAyB;AACtD;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI,2EAAS,gDAAgD,eAAe;AAC5E,IAAI,2EAAS,sBAAsB,0EAAU,+CAA+C,SAAS;AACrG,IAAI,2EAAS;AACb,IAAI,2EAAS;AACb,IAAI,2EAAS;AACb;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI,2EAAS;AACb,IAAI,2EAAS,sBAAsB,0EAAU,iDAAiD,SAAS;AACvG,IAAI,2EAAS;AACb,IAAI,2EAAS;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,2EAAS,8EAA8E,eAAe,GAAG,mBAAmB;AAC9H;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,8BAA8B;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,QAAQ,QAAQ;AAC3B,WAAW,QAAQ;AACnB,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2FAA2F;AAC9G;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0EAAU;AACrC,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ,QAAQ;AAC3B,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA,QAAQ,2FAA2F;AACnG,OAAO;AACP;AACA;AACA;AACA;AACA,kBAAkB,0EAAU;AAC5B;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6DAAG;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,gCAAgC,8DAAQ,wCAAwC,+DAAO;AACvF,wCAAwC,gEAAI,CAAC,uEAAW;AACxD,wBAAwB,iFAAqB;AAC7C;;AAEA;AACA,aAAa,wCAAwC;AACrD;;AAEA;AACA,aAAa,8CAA8C;AAC3D;;AAEA;AACA;AACA;AACA,SAAS,gEAAM,EAAE,gFAAoB,uBAAuB,8DAAM;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,8DAAI;AACP;AACA,GAAG;AACH,GAAG,mEAAS;AACZ;AACA,0BAA0B,iEAAS;AACnC,GAAG;AACH,GAAG,qEAAW;AACd;AACA,GAAG;AACH,GAAG,kEAAU;AACb;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,6CAA6C,iEAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,mEAAK;AACd;;AAEA;AACA;AACA,WAAW,mBAAmB;AAC9B,aAAa;AACb;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,wEAAU;AACrB;AACA;AACA,WAAW,wEAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oDAAoD,kEAAQ;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,iEAAK;AAC1C;AACA,MAAM;AACN,uBAAuB,iEAAK;AAC5B;AACA;AACA,2BAA2B,gEAAM,EAAE,uFAA2B,iDAAiD,8DAAM;AACrH;AACA;AACA;AACA;AACA,GAAG;AACH,GAAG,mEAAS;AACZ;AACA;AACA;AACA;AACA,GAAG;AACH,GAAG,qEAAW;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mEAAK;;AAEhC;AACA,aAAa,kCAAkC;AAC/C;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc,UAAU;AACxB;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA,2BAA2B,wEAAU;AACrC;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,sBAAsB,OAAO;AAC7B;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA,GAAG;AACH;AACA,gBAAgB,mCAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+BAA+B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA,GAAG;AACH;AACA,gBAAgB,mCAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,aAAa,yDAAM;AACnB;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA,IAAI;AACJ,EAAE,qEAAW,8CAA8C,UAAU;AACrE,EAAE,qEAAW,qDAAqD,UAAU;AAC5E,EAAE,qEAAW,yEAAyE,UAAU;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6DAAM;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,EAAE,qEAAW,wDAAwD,UAAU;AAC/E;AACA,EAAE,qEAAW,4EAA4E,UAAU;;AAEnG;AACA;AACA;AACA,GAAG;AACH;AACA,IAAI,iEAAG;AACP;AACA;AACA,4BAA4B;AAC5B,4BAA4B;AAC5B;AACA,aAAa,gEAAM;AACnB,KAAK;AACL;AACA;AACA;AACA;AACA,2CAA2C,kEAAQ;AACnD,MAAM,qEAAW;AACjB,MAAM,qEAAW;AACjB;AACA;AACA;AACA,QAAQ,qEAAW;AACnB;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD,gEAAgE;AAChE;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,EAAE,qEAAW,gDAAgD,SAAS;AACtE,EAAE,qEAAW,qDAAqD,cAAc;AAChF,EAAE,qEAAW,oDAAoD,aAAa;AAC9E,EAAE,qEAAW,uDAAuD,SAAS;AAC7E,EAAE,qEAAW,4DAA4D,cAAc;AACvF,EAAE,qEAAW,2DAA2D,aAAa;AACrF;AACA;AACA;AACA,GAAG;AACH;AACA,wBAAwB,gEAAM,EAAE,sEAAU,OAAO,kEAAQ,uDAAuD,yEAAa,2BAA2B,8DAAM;AAC9J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,gCAAgC,iEAAK;AACrC;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA,IAAI;AACJ,EAAE,qEAAW,gEAAgE,mBAAmB;AAChG,EAAE,qEAAW,uEAAuE,mBAAmB;AACvG,EAAE,qEAAW,oGAAoG,mBAAmB;AACpI;AACA;AACA;AACA;AACA,yBAAyB,6DAAM;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,EAAE,qEAAW,iDAAiD,UAAU;AACxE,EAAE,qEAAW,wDAAwD,UAAU;AAC/E,EAAE,qEAAW,qEAAqE,UAAU;AAC5F;AACA,EAAE,qEAAW,gDAAgD,SAAS;AACtE,EAAE,qEAAW,oDAAoD,aAAa;AAC9E,EAAE,qEAAW,2DAA2D,aAAa;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,YAAY,iEAAG;AACf;AACA;AACA,2CAA2C,4BAA4B,cAAc;AACrF,4CAA4C;AAC5C,4CAA4C;AAC5C;AACA,qBAAqB,gEAAM;AAC3B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,gCAAgC,iEAAK;AACrC;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,EAAE,qEAAW,mCAAmC,YAAY;AAC5D,EAAE,qEAAW,uDAAuD,YAAY;AAChF,EAAE,qEAAW,qCAAqC,cAAc;AAChE,EAAE,qEAAW,yDAAyD,cAAc;AACpF,EAAE,qEAAW,8CAA8C,UAAU;AACrE,EAAE,qEAAW,qDAAqD,UAAU;AAC5E,EAAE,qEAAW,yEAAyE,UAAU;AAChG;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,EAAE,qEAAW,2CAA2C,YAAY;AACpE,EAAE,qEAAW,+DAA+D,YAAY;AACxF,EAAE,qEAAW,8CAA8C,eAAe;AAC1E,EAAE,qEAAW,+DAA+D,eAAe;AAC3F,EAAE,qEAAW,6CAA6C,cAAc;AACxE,EAAE,qEAAW,iEAAiE,cAAc;AAC5F,EAAE,qEAAW,sDAAsD,UAAU;AAC7E,EAAE,qEAAW,6DAA6D,UAAU;AACpF,EAAE,qEAAW,iFAAiF,UAAU;AACxG;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,0CAAG;;AAEb;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa;AACb;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa;AACb;;AAEyS","sources":["webpack://mask-network/./node_modules/.pnpm/@blocto+fcl@1.4.0/node_modules/@blocto/fcl/dist/fcl.module.js"],"sourcesContent":["import { config } from '@onflow/config';\nexport { config } from '@onflow/config';\nimport * as sdk from '@blocto/flow-sdk';\nimport { invariant as invariant$1, arg, encodeMessageFromSignable, config as config$1, resolve, pipe, interaction, createSignableVoucher, send as send$1, getTransactionStatus, decode, block, getEventsAtBlockHeightRange, getAccount, atBlockHeight } from '@blocto/flow-sdk';\nexport { TestUtils, account, arg, args, atBlockHeight, atBlockId, authorization, authorizations, block, build, createSignableVoucher, decode, getAccount, getBlock, getBlockHeader, getCollection, getEvents, getEventsAtBlockHeightRange, getEventsAtBlockIds, getNetworkParameters, getTransaction, getTransactionStatus, invariant, isBad, isOk, limit, param, params, payer, ping, pipe, proposer, ref, script, send, transaction, validator, voucherIntercept, voucherToTxId, why } from '@blocto/flow-sdk';\nimport { log, LEVELS } from '@onflow/util-logger';\nimport { invariant } from '@onflow/util-invariant';\nimport * as t$1 from '@onflow/types';\nimport fetchTransport from 'cross-fetch';\nimport { withPrefix, sansPrefix } from '@onflow/util-address';\nexport { display, sansPrefix, withPrefix } from '@onflow/util-address';\nimport { subscriber, snapshoter, send, spawn, INIT, SUBSCRIBE, UNSUBSCRIBE, UPDATED as UPDATED$2, SNAPSHOT as SNAPSHOT$1 } from '@onflow/util-actor';\nimport * as rlp from '@onflow/rlp';\nimport { Buffer, encode } from '@onflow/rlp';\nimport { uid } from '@onflow/util-uid';\nimport require$$0 from 'buffer';\nexport { template as cadence, template as cdc } from '@onflow/util-template';\n\nasync function getChainIdFromAccessNode() {\n  const response = await sdk.send([sdk.getNetworkParameters()]).then(sdk.decode);\n  return response.chainId;\n}\n\n/**\n * Sets the default chain id to the chain id of the access node\n *\n * @returns {string} The chain id of the access node\n *\n * @example\n * // returns \"testnet\"\n * setChainIdDefault()\n */\nasync function setChainIdDefault() {\n  const network = await getChainIdFromAccessNode();\n  config.put(\"flow.network.default\", network);\n  return network;\n}\n\n/**\n * @description\n * Gets the chain ID if its set, otherwise gets the chain ID from the access node\n *\n * @returns {string} The chain ID of the access node\n * @throws {Error} If the chain ID is not found\n *\n * @example\n * // returns \"testnet\"\n * getChainId()\n */\nasync function getChainId() {\n  let network = await config.get(\"flow.network.default\");\n  if (!network) {\n    network = await setChainIdDefault();\n    if (!network) {\n      network = await config.get(\"flow.network\");\n      if (network) {\n        log.deprecate({\n          pkg: \"FCL\",\n          subject: 'Using the \"flow.network\" configuration key for specifying the flow network',\n          message: \"Configuring flow.network is no longer required\",\n          transition: \"https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/TRANSITIONS.md#0002-deprecate-flow.network-config-key\"\n        });\n      } else {\n        network = await config.get(\"env\");\n        if (network) log.deprecate({\n          pkg: \"FCL\",\n          subject: 'Using the \"env\" configuration key for specifying the flow network',\n          message: \"Configuring to specify flow network is no longer required\",\n          transition: \"https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/TRANSITIONS.md#0001-deprecate-env-config-key\"\n        });\n      }\n    }\n  }\n  invariant(network, \"Error getting chainId from access node. Please configure flow.network instead\");\n  return network;\n}\n\n/**\n * @description\n * Watches the config for changes to access node and updates the chain id accordingly\n *\n * @returns {Function} A function that unsubscribes the listener\n *\n */\nfunction watchForChainIdChanges() {\n  return config.subscribe(function configSubscriber(config) {\n    const nextAccessNode = config?.[\"accessNode.api\"];\n    if (this.prevAccessNode !== nextAccessNode) {\n      setChainIdDefault();\n    }\n    this.prevAccessNode = nextAccessNode;\n  }.bind({}));\n}\n\nfunction isAndroid() {\n  return typeof navigator !== \"undefined\" && /android/i.test(navigator.userAgent);\n}\nfunction isSmallIOS() {\n  return typeof navigator !== \"undefined\" && /iPhone|iPod/.test(navigator.userAgent);\n}\nfunction isLargeIOS() {\n  return typeof navigator !== \"undefined\" && /iPad/.test(navigator.userAgent);\n}\nfunction isIOS() {\n  return isSmallIOS() || isLargeIOS();\n}\nfunction isMobile() {\n  return isAndroid() || isIOS();\n}\n\nconst isServerSide = () => typeof window === \"undefined\";\nconst SESSION_STORAGE = {\n  can: !isServerSide(),\n  get: async key => JSON.parse(sessionStorage.getItem(key)),\n  put: async (key, value) => sessionStorage.setItem(key, JSON.stringify(value))\n};\nconfig({\n  \"discovery.wallet.method.default\": \"IFRAME/RPC\",\n  \"fcl.storage.default\": SESSION_STORAGE\n});\n\n// Set chain id default on access node change\nwatchForChainIdChanges();\nasync function configLens(regex) {\n  return Object.fromEntries(Object.entries(await config().where(regex)).map(_ref => {\n    let [key, value] = _ref;\n    return [key.replace(regex, \"\"), value];\n  }));\n}\n\nconst VERSION = \"1.4.0\" ;\n\nconst is = type => d => typeof d === type;\nconst isRequired = d => d != null;\nconst isObject = is(\"object\");\nconst isString = is(\"string\");\nconst isFunc = is(\"function\");\nconst isNumber = is(\"number\");\n\nfunction normalizeArgs(ax) {\n  if (isFunc(ax)) return ax(sdk.arg, t$1);\n  return [];\n}\n\nasync function httpDocumentResolver(_ref) {\n  let {\n    url\n  } = _ref;\n  invariant(typeof url !== \"undefined\", \"retrieve({ url }) -- url must be defined\");\n  let res;\n  try {\n    res = await fetchTransport(url);\n  } catch (e) {\n    throw new Error(\"httpDocumentResolver Error: Failed to retrieve document.\");\n  }\n  let document = res.ok ? await res.json() : null;\n  return document;\n}\nconst DOCUMENT_RESOLVERS = new Map([[\"http\", httpDocumentResolver], [\"https\", httpDocumentResolver]]);\nasync function retrieve(_ref2) {\n  let {\n    url\n  } = _ref2;\n  invariant(typeof url !== \"undefined\", \"retrieve({ url }) -- url must be defined\");\n  invariant(typeof url === \"string\", \"retrieve({ url }) -- url must be a string\");\n  const documentResolversFromConfig = await config().where(/^document\\.resolver\\./);\n  Object.keys(documentResolversFromConfig).map(key => {\n    const resolverFromConfig = documentResolversFromConfig[key];\n    const resolverProtocol = key.replace(/^document\\.resolver\\./, \"\");\n    DOCUMENT_RESOLVERS.set(resolverProtocol, resolverFromConfig);\n  });\n  const urlParts = /^(.*):\\/\\/([A-Za-z0-9\\-\\.]+)(:[0-9]+)?(.*)$/.exec(url);\n  invariant(urlParts, \"Failed to parse URL\");\n  const protocol = urlParts[1];\n  invariant(urlParts, \"Failed to parse URL protocol\");\n  const resolver = DOCUMENT_RESOLVERS.get(protocol);\n  invariant(resolver, `No resolver found for protcol=${protocol}`);\n  let document = await resolver({\n    url\n  });\n  return document;\n}\n\nfunction normalizeInteractionTemplate(template) {\n  if (template == null) return null;\n  switch (template[\"f_version\"]) {\n    case \"1.0.0\":\n      return template;\n    default:\n      throw new Error(\"normalizeInteractionTemplate Error: Invalid InteractionTemplate\");\n  }\n}\n\n/**\n * @description Fills import addresses in Cadence for network\n * \n * @param {object} params\n * @param {string} params.network - Network to derive Cadence for\n * @param {object} params.template - Interaction Template to derive Cadence from\n * @returns {string} - Cadence\n */\nfunction deriveCadenceByNetwork(_ref) {\n  let {\n    network,\n    template\n  } = _ref;\n  invariant$1(network != undefined, \"deriveCadenceByNetwork({ network }) -- network must be defined\");\n  invariant$1(typeof network === \"string\", \"deriveCadenceByNetwork({ network }) -- network must be a string\");\n  invariant$1(template != undefined, \"generateDependencyPin({ template }) -- template must be defined\");\n  invariant$1(typeof template === \"object\", \"generateDependencyPin({ template }) -- template must be an object\");\n  invariant$1(template.f_type === \"InteractionTemplate\", \"generateDependencyPin({ template }) -- template must be an InteractionTemplate\");\n  template = normalizeInteractionTemplate(template);\n  switch (template.f_version) {\n    case \"1.0.0\":\n      let networkDependencies = Object.keys(template?.data?.dependencies).map(dependencyPlaceholder => {\n        let dependencyNetworkContracts = Object.values(template?.data?.dependencies?.[dependencyPlaceholder]);\n        invariant$1(dependencyNetworkContracts, `deriveCadenceByNetwork -- Could not find contracts for dependency placeholder: ${dependencyPlaceholder}`);\n        invariant$1(dependencyNetworkContracts.length === 0, `deriveCadenceByNetwork -- Could not find contracts for dependency placeholder: ${dependencyPlaceholder}`);\n        let dependencyContract = dependencyNetworkContracts[0];\n        let dependencyContractForNetwork = dependencyContract?.[network];\n        invariant$1(dependencyContractForNetwork, `deriveCadenceByNetwork -- Could not find ${network} network information for dependency: ${dependencyPlaceholder}`);\n        return [dependencyPlaceholder, dependencyContractForNetwork.address];\n      });\n      return networkDependencies.reduce((cadence, _ref2) => {\n        let [placeholder, address] = _ref2;\n        const regex = new RegExp(\"(\\\\b\" + placeholder + \"\\\\b)\", \"g\");\n        return cadence.replace(regex, address);\n      }, template.data.cadence);\n    default:\n      throw new Error(\"deriveCadenceByNetwork Error: Unsupported template version\");\n  }\n}\n\nasync function deriveDependencies(_ref) {\n  let {\n    template\n  } = _ref;\n  const network = await getChainId();\n  invariant(network, \"FCL configureDependencies Error: Missing configuration value for 'flow.network'\");\n  const derivedDependencies = {};\n  switch (template[\"f_version\"]) {\n    case \"1.0.0\":\n      const dependencyPlaceholderKeys = Object.keys(template?.data?.dependencies);\n      for (let dependencyPlaceholderKey of dependencyPlaceholderKeys) {\n        let dependencyPlaceholder = template?.data?.dependencies[dependencyPlaceholderKey];\n        const dependencyPlaceholderContractsKeys = Object.keys(dependencyPlaceholder);\n        invariant(dependencyPlaceholderContractsKeys.length > 0, `FCL configureDependencies Error: No contracts found in template for placeholder=${dependencyPlaceholderKey}`);\n        const dependencyPlaceholderContract = dependencyPlaceholder[dependencyPlaceholderContractsKeys[0]];\n        const dependency = dependencyPlaceholderContract[network];\n        invariant(dependency, `FCL configureDependencies Error: No dependency information for placeholder=${dependencyPlaceholderKey} contract=${dependencyPlaceholderContractsKeys[0]} network=${network}`);\n        invariant(dependency?.address, `FCL configureDependencies Error: No address information for placeholder=${dependencyPlaceholderKey} contract=${dependencyPlaceholderContractsKeys[0]} network=${network}`);\n        derivedDependencies[dependencyPlaceholderKey] = withPrefix(dependency?.address);\n      }\n      return derivedDependencies;\n    default:\n      throw new Error(\"FCL configureDependencies Error: Unsupported template version\");\n  }\n}\n\nasync function prepTemplateOpts(opts) {\n  if (isString(opts?.template)) {\n    opts.template = await retrieve({\n      url: opts?.template\n    });\n  }\n  let dependencies = {};\n  if (opts?.template) {\n    opts.template = normalizeInteractionTemplate(opts?.template);\n    dependencies = await deriveDependencies({\n      template: opts.template\n    });\n  }\n  const cadence = opts.cadence || deriveCadenceByNetwork({\n    template: opts.template,\n    network: await getChainId()\n  });\n  opts.cadence = cadence;\n  opts.dependencies = dependencies;\n  return opts;\n}\n\nasync function pre(type, opts) {\n  // prettier-ignore\n  invariant(isRequired(opts), `${type}(opts) -- opts is required`);\n  // prettier-ignore\n  invariant(isObject(opts), `${type}(opts) -- opts must be an object`);\n  // prettier-ignore\n  invariant(!(opts.cadence && opts.template), `${type}({ template, cadence }) -- cannot pass both cadence and template`);\n  // prettier-ignore\n  invariant(isRequired(opts.cadence || opts?.template), `${type}({ cadence }) -- cadence is required`);\n  // // prettier-ignore\n  invariant(isString(opts.cadence) || opts?.template, `${type}({ cadence }) -- cadence must be a string`);\n  // prettier-ignore\n  invariant(opts.cadence || (await sdk.config().get(\"flow.network\")), `${type}(opts) -- Required value for \"flow.network\" not defined in config. See: ${\"https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/src/exec/query.md#configuration\"}`);\n  // prettier-ignore\n  invariant(await sdk.config().get(\"accessNode.api\"), `${type}(opts) -- Required value for \"accessNode.api\" not defined in config. See: ${\"https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/src/exec/query.md#configuration\"}`);\n}\nasync function preMutate(opts) {\n  return pre(\"mutate\", opts);\n}\nasync function preQuery(opts) {\n  return pre(\"query\", opts);\n}\n\n/**\n * @description\n * Allows you to submit scripts to query the blockchain.\n *\n *  @param {object} opts - Query Options and configuration\n *  @param {string} opts.cadence - Cadence Script used to query Flow\n *  @param {import(\"../fcl\").ArgsFn} [opts.args] - Arguments passed to cadence script\n *  @param {object} [opts.template] - Interaction Template for a script\n *  @param {number} [opts.limit]   - Compute Limit for Query\n *  @returns {Promise}\n *\n *  @example\n *    const cadence = `\n *      cadence: `\n *        pub fun main(a: Int, b: Int, c: Address): Int {\n *          log(c)\n *          return a + b\n *        }\n *    `.trim()\n *\n *    const args = (arg, t) => [\n *      arg(5, t.Int),\n *      arg(7, t.Int),\n *      arg(\"0xb2db43ad6bc345fec9\", t.Address),\n *    ]\n *\n *    await query({ cadence, args })\n */\nasync function query() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  await preQuery(opts);\n  opts = await prepTemplateOpts(opts);\n  return sdk.config().overload(opts.dependencies || {}, async () =>\n  // prettier-ignore\n  sdk.send([sdk.script(opts.cadence), sdk.args(normalizeArgs(opts.args || [])), opts.limit && typeof opts.limit === \"number\" && sdk.limit(opts.limit)]).then(sdk.decode));\n}\n\nasync function fetchServices(servicesURL, code) {\n  if (servicesURL == null || code == null) return [];\n  const url = new URL(servicesURL);\n  url.searchParams.append(\"code\", code);\n  const resp = await fetch(url, {\n    method: \"GET\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    }\n  }).then(d => d.json());\n  if (Array.isArray(resp)) return resp;\n\n  // Backwards compatibility for First-Gen Wallet Providers\n  const services = [];\n\n  // Convert authorizations into authz services\n  if (Array.isArray(resp.authorizations)) {\n    for (let service of resp.authorizations) {\n      services.push({\n        type: \"authz\",\n        keyId: resp.keyId,\n        ...service\n      });\n    }\n  }\n\n  // Convert Provider info into an authn service\n  if (resp.provider != null) {\n    services.push({\n      type: \"authn\",\n      id: \"wallet-provider#authn\",\n      ...resp.provider\n    });\n  }\n  return services;\n}\n\nfunction mergeServices() {\n  let sx1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let sx2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  // TODO: Make this smarter\n  return [...sx1, ...sx2];\n}\n\nconst SERVICE_PRAGMA = {\n  f_type: \"Service\",\n  f_vsn: \"1.0.0\"\n};\nconst IDENTITY_PRAGMA = {\n  f_type: \"Identity\",\n  f_vsn: \"1.0.0\"\n};\nconst USER_PRAGMA = {\n  f_type: \"USER\",\n  f_vsn: \"1.0.0\"\n};\nconst POLLING_RESPONSE_PRAGMA = {\n  f_type: \"PollingResponse\",\n  f_vsn: \"1.0.0\"\n};\nconst COMPOSITE_SIGNATURE_PRAGMA = {\n  f_type: \"CompositeSignature\",\n  f_vsn: \"1.0.0\"\n};\n\n// {\n//   \"f_type\": \"Service\",\n//   \"f_vsn\": \"1.0.0\",\n//   \"type\": \"authn\",\n//   \"uid\": \"uniqueDedupeKey\",\n//   \"endpoint\": \"https://rawr\",\n//   \"id\": \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\", // wallets internal id for the user\n//   \"identity\": {\n//     \"address\": \"0x____\"\n//   },\n//   \"provider\": {\n//     \"address\": \"0x____\",\n//     \"name\": \"Best Wallet\",\n//     \"description\": \"The Best Wallet\"\n//     \"icon\": \"https://\",\n//   }\n// }\nfunction normalizeAuthn(service) {\n  if (service == null) return null;\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service;\n    default:\n      return {\n        ...SERVICE_PRAGMA,\n        type: service.type,\n        uid: service.id,\n        endpoint: service.authn,\n        id: service.pid,\n        provider: {\n          address: withPrefix(service.addr),\n          name: service.name,\n          icon: service.icon\n        }\n      };\n  }\n}\n\n// {\n//   \"f_type\": \"service\",\n//   \"f_vsn\": \"1.0.0\",\n//   \"type\": \"authz\",\n//   \"uid\": \"uniqueDedupeKey\",\n//   \"endpoint\": \"https://rawr\",\n//   \"method\": \"HTTP/POST\", // HTTP/POST | IFRAME/RPC | HTTP/RPC\n//   \"identity\": {\n//      \"address\": \"0x______\",\n//      \"keyId\": 0,\n//   },\n//   \"data\": {}, // included in body of authz request\n//   \"params\": {}, // included as query params on endpoint url\n// }\nfunction normalizeAuthz(service) {\n  if (service == null) return null;\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service;\n    default:\n      return {\n        ...SERVICE_PRAGMA,\n        type: service.type,\n        uid: service.id,\n        endpoint: service.endpoint,\n        method: service.method,\n        identity: {\n          ...IDENTITY_PRAGMA,\n          address: withPrefix(service.addr),\n          keyId: service.keyId\n        },\n        params: service.params,\n        data: service.data\n      };\n  }\n}\n\n// {\n//   \"f_type\": \"service\",\n//   \"f_vsn\": \"1.0.0\",\n//   \"type\": \"pre-authz\",\n//   \"uid\": \"uniqueDedupeKey\",\n//   \"endpoint\": \"https://rawr\",\n//   \"method\": \"HTTP/POST\", // HTTP/POST | IFRAME/RPC | HTTP/RPC\n//   \"identity\": {\n//      \"address\": \"0x______\",\n//      \"keyId\": 0,\n//   },\n//   \"data\": {}, // included in body of pre-authz request\n//   \"params\": {}, // included as query params on endpoint url\n// }\nfunction normalizePreAuthz(service) {\n  if (service == null) return null;\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service;\n    default:\n      return {\n        ...SERVICE_PRAGMA,\n        type: service.type,\n        uid: service.id,\n        endpoint: service.endpoint,\n        method: service.method,\n        identity: {\n          ...IDENTITY_PRAGMA,\n          address: withPrefix(service.addr),\n          keyId: service.keyId\n        },\n        params: service.params,\n        data: service.data\n      };\n  }\n}\n\n// {\n//    \"f_type\": \"Service\",\n//    \"f_vsn\": \"1.0.0\",\n//    \"type\": \"frame\",\n//    \"endpoint\": \"https://rawr\",\n//    \"data\": {},   // Sent to frame when ready\n//    \"params\": {}, // include in query params on frame\n// }\nfunction normalizeFrame(service) {\n  if (service == null) return null;\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service;\n    default:\n      return {\n        old: service,\n        ...SERVICE_PRAGMA,\n        type: \"frame\",\n        endpoint: service.endpoint,\n        params: service.params || {},\n        data: service.data || {}\n      };\n  }\n}\n\n// {\n//    \"f_type\": \"Service\",\n//    \"f_vsn\": \"1.0.0\",\n//    \"type\": \"back-channel-rpc\",\n//    \"endpoint\": \"https://rawr\",\n//    \"method\": \"HTTP/GET\", // HTTP/GET | HTTP/POST\n//    \"data\": {},           // included in body of rpc\n//    \"params\": {},         // included as query params on endpoint url\n// }\nfunction normalizeBackChannelRpc(service) {\n  if (service == null) return null;\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service;\n    default:\n      return {\n        ...SERVICE_PRAGMA,\n        type: \"back-channel-rpc\",\n        endpoint: service.endpoint,\n        method: service.method,\n        params: service.params || {},\n        data: service.data || {}\n      };\n  }\n}\n\n// {\n//   \"f_type\": \"Service\",\n//   \"f_vsn\": \"1.0.0\",\n//   \"type\": \"open-id\",\n//   \"uid\": \"uniqueDedupeKey\",\n//   \"method: \"data\",\n//   \"data\": {\n//      \"profile\": {\n//        \"name\": \"Bob\",\n//        \"family_name\": \"Builder\",\n//        \"given_name\": \"Robert\",\n//        \"middle_name\": \"the\",\n//        \"nickname\": \"Bob the Builder\",\n//        \"perferred_username\": \"bob\",\n//        \"profile\": \"https://www.bobthebuilder.com/\",\n//        \"picture\": \"https://avatars.onflow.org/avatar/bob\",\n//        \"gender\": \"...\",\n//        \"birthday\": \"2001-01-18\",\n//        \"zoneinfo\": \"America/Vancouver\",\n//        \"locale\": \"en-us\",\n//        \"updated_at\": \"1614970797388\"\n//      },\n//      \"email\": {\n//        \"email\": \"bob@bob.bob\",\n//        \"email_verified\": true\n//      },\n//      \"address\": {\n//        \"address\": \"One Apple Park Way, Cupertino, CA 95014, USA\"\n//      },\n//      \"phone\": {\n//        \"phone_number\": \"+1 (xxx) yyy-zzzz\",\n//        \"phone_number_verified\": true\n//      },\n//      \"social\": {\n//        \"twitter\": \"@_qvvg\",\n//        \"twitter_verified\": true\n//      },\n//   }\n// }\nfunction normalizeOpenId(service) {\n  if (service == null) return null;\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service;\n    default:\n      return null;\n  }\n}\n\n// {\n//   \"f_type\": \"Service\",\n//   \"f_vsn\": \"1.0.0\",\n//   \"type\": \"user-signature\",\n//   \"uid\": \"uniqueDedupeKey\",\n//   \"endpoint\": \"https://rawr\",\n//   \"method\": \"IFRAME/RPC\", // HTTP/POST | IFRAME/RPC | HTTP/RPC\n//   \"id\": \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\", // wallets internal id for the user\n//   \"data\": {}, // included in body of user-signature request\n//   \"params\": {}, // included as query params on endpoint url\n// }\nfunction normalizeUserSignature(service) {\n  if (service == null) return null;\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service;\n    default:\n      throw new Error(\"Invalid user-signature service\");\n  }\n}\n\n// {\n//    \"f_type\": \"Service\",\n//    \"f_vsn\": \"1.0.0\",\n//    type: \"local-view\",\n//    method: \"VIEW/IFRAME\",\n//    endpoint: \"https://woot.org/authz/local\",\n//    data: {},\n//    params: {},\n// }\nfunction normalizeLocalView(resp) {\n  if (resp == null) return null;\n  if (resp.method == null) {\n    resp = {\n      ...resp,\n      type: \"local-view\",\n      method: \"VIEW/IFRAME\"\n    };\n  }\n  switch (resp[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return resp;\n    default:\n      return {\n        ...SERVICE_PRAGMA,\n        type: resp.type || \"local-view\",\n        method: resp.method,\n        endpoint: resp.endpoint,\n        data: resp.data || {},\n        params: resp.params || {}\n      };\n  }\n}\n\n// {\n//   \"f_type\": \"Service\",                    // Its a service!\n//   \"f_vsn\": \"1.0.0\",                       // Follows the v1.0.0 spec for the service\n//   \"type\": \"account-proof\",                // the type of service it is\n//   \"method\": \"DATA\",                       // Its data!\n//   \"uid\": \"awesome-wallet#account-proof\",  // A unique identifier for the service\n//   \"data\": {\n//     \"f_type\": \"account-proof\",\n//     \"f_vsn\": \"1.0.0\",\n//     \"nonce\": \"0A1BC2FF\",                  // Nonce signed by the current account-proof (minimum 32 bytes in total, i.e 64 hex characters)\n//     \"address\": \"0xUSER\",                  // The user's address (8 bytes, i.e 16 hex characters)\n//     \"signature\": CompositeSignature,      // address (sans-prefix), keyId, signature (hex)\n// }\n\nfunction normalizeAccountProof(service) {\n  if (service == null) return null;\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service;\n    default:\n      throw new Error(`FCL Normalizer Error: Invalid account-proof service`);\n  }\n}\n\n// {\n//   \"f_type\": \"Service\",\n//   \"f_vsn\": \"1.0.0\",\n//   \"type\": \"authn-refresh\",\n//   \"uid\": \"uniqueDedupeKey\",\n//   \"endpoint\": \"https://rawr\",\n//   \"method\": \"HTTP/POST\",  // \"HTTP/POST\", // HTTP/POST | IFRAME/RPC | HTTP/RPC\n//   \"id\": \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\", // wallets internal id for the user\n//   \"data\": {}, // included in body of request\n//   \"params\": {}, // included as query params on endpoint url\n// }\nfunction normalizeAuthnRefresh(service) {\n  if (service == null) return null;\n  switch (service[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return service;\n    default:\n      throw new Error(\"Invalid authn-refresh service\");\n  }\n}\n\nconst serviceNormalizers = {\n  \"back-channel-rpc\": normalizeBackChannelRpc,\n  \"pre-authz\": normalizePreAuthz,\n  authz: normalizeAuthz,\n  authn: normalizeAuthn,\n  frame: normalizeFrame,\n  \"open-id\": normalizeOpenId,\n  \"user-signature\": normalizeUserSignature,\n  \"local-view\": normalizeLocalView,\n  \"account-proof\": normalizeAccountProof,\n  \"authn-refresh\": normalizeAuthnRefresh\n};\nfunction normalizeService(service, data) {\n  try {\n    var normalized = serviceNormalizers[service.type](service, data);\n    return normalized;\n  } catch (error) {\n    console.error(`Unrecognized FCL Service Type [${service.type}]`, service, error);\n    return service;\n  }\n}\n\nfunction deriveCompositeId(authn) {\n  return rlp.encode([authn.provider.address || authn.provider.name || \"UNSPECIFIED\", authn.id]).toString(\"hex\");\n}\nfunction normalizeData(data) {\n  data.addr = data.addr ? withPrefix(data.addr) : null;\n  data.paddr = data.paddr ? withPrefix(data.paddr) : null;\n  return data;\n}\nfunction findService(type, services) {\n  return services.find(d => d.type === type);\n}\nasync function buildUser(data) {\n  data = normalizeData(data);\n  var services = mergeServices(data.services || [], await fetchServices(data.hks, data.code)).map(service => normalizeService(service, data));\n  const authn = findService(\"authn\", services);\n  return {\n    ...USER_PRAGMA,\n    addr: withPrefix(data.addr),\n    cid: deriveCompositeId(authn),\n    loggedIn: true,\n    services: services,\n    expiresAt: data.expires\n  };\n}\n\nfunction serviceOfType() {\n  let services = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let type = arguments.length > 1 ? arguments[1] : undefined;\n  return services.find(service => service.type === type);\n}\n\nfunction serviceEndpoint(service) {\n  const url = new URL(service.endpoint);\n  if (window?.location?.origin) {\n    url.searchParams.append(\"l6n\", window.location.origin);\n  }\n  if (service.params != null) {\n    for (let [key, value] of Object.entries(service.params || {})) {\n      url.searchParams.append(key, value);\n    }\n  }\n  return url;\n}\n\nfunction fetchService(service) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const method = opts.method || \"POST\";\n  const body = method === \"GET\" ? undefined : JSON.stringify(opts.data || service.data || {});\n  return fetch(serviceEndpoint(service), {\n    method: method,\n    headers: {\n      ...(service.headers || {}),\n      ...(opts.headers || {}),\n      \"Content-Type\": \"application/json\"\n    },\n    body: body\n  }).then(d => d.json());\n}\n\n// {\n//    \"f_type\": \"PollingResponse\",\n//    \"f_vsn\": \"1.0.0\",\n//    \"status\": \"PENDING\", // PENDING | APPROVED | DECLINED | REDIRECT\n//    \"reason\": null,      // Reason for Declining Transaction\n//    \"data\": null,        // Return value for APPROVED\n//    \"updates\": BackChannelRpc,\n//    \"local\": Frame,\n// }\nfunction normalizePollingResponse(resp) {\n  if (resp == null) return null;\n  switch (resp[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return resp;\n    default:\n      return {\n        ...POLLING_RESPONSE_PRAGMA,\n        status: resp.status ?? \"APPROVED\",\n        reason: resp.reason ?? null,\n        data: resp.compositeSignature || resp.data || {\n          ...resp\n        } || {},\n        updates: normalizeBackChannelRpc(resp.authorizationUpdates),\n        local: normalizeFrame((resp.local || [])[0])\n      };\n  }\n}\n\nconst OPTIONS = {\n  \"HTTP/GET\": \"GET\",\n  \"HTTP/POST\": \"POST\"\n};\nconst serviceMethod = service => {\n  invariant(OPTIONS[service.method], \"Invalid Service Method for type back-channel-rpc\", {\n    service\n  });\n  return OPTIONS[service.method];\n};\nasync function poll(service) {\n  let canContinue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => true;\n  invariant(service, \"Missing Polling Service\", {\n    service\n  });\n  if (!canContinue()) throw new Error(\"Externally Halted\");\n  let resp;\n  try {\n    if (typeof document !== \"undefined\" && document.visibilityState === \"hidden\") {\n      await new Promise(r => setTimeout(r, 500));\n      return poll(service, canContinue);\n    }\n    resp = await fetchService(service, {\n      method: serviceMethod(service)\n    }).then(normalizePollingResponse);\n  } catch (error) {\n    throw error;\n  }\n  switch (resp.status) {\n    case \"APPROVED\":\n      return resp.data;\n    case \"DECLINED\":\n      throw new Error(`Declined: ${resp.reason || \"No reason supplied.\"}`);\n    default:\n      await new Promise(r => setTimeout(r, 500));\n      return poll(resp.updates, canContinue);\n  }\n}\n\nconst FRAME = \"FCL_IFRAME\";\nconst FRAME_STYLES = `\n  position:fixed;\n  top: 0px;\n  right: 0px;\n  bottom: 0px;\n  left: 0px;\n  height: 100%;\n  width: 100vw;\n  display:block;\n  background:rgba(0,0,0,0.25);\n  z-index: 2147483647;\n  box-sizing: border-box;\n  color-scheme: light;\n`;\nfunction renderFrame(src) {\n  invariant(!document.getElementById(FRAME), \"Attempt at triggering multiple Frames\", {\n    src\n  });\n  const $frame = document.createElement(\"iframe\");\n  $frame.src = src;\n  $frame.id = FRAME;\n  $frame.allow = \"usb *; hid *\";\n  $frame.frameBorder = \"0\";\n  $frame.style.cssText = FRAME_STYLES;\n  document.body.append($frame);\n  const unmount = () => {\n    if (document.getElementById(FRAME)) {\n      document.getElementById(FRAME).remove();\n    }\n  };\n  return [$frame.contentWindow, unmount];\n}\n\nconst POP = \"FCL_POP\";\nlet popup = null;\nlet previousUrl$1 = null;\nfunction popupWindow(url, windowName, win, w, h) {\n  const y = win.top.outerHeight / 2 + win.top.screenY - h / 2;\n  const x = win.top.outerWidth / 2 + win.top.screenX - w / 2;\n  const popup = win.open(url, windowName, `toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=${w}, height=${h}, top=${y}, left=${x}`);\n  if (!popup) throw new Error(\"Popup failed to open (was it blocked by a popup blocker?)\");\n  return popup;\n}\nfunction renderPop(src) {\n  if (popup == null || popup?.closed) {\n    popup = popupWindow(src, POP, window, 640, 770);\n  } else if (previousUrl$1 !== src) {\n    popup.location.replace(src);\n    popup.focus();\n  } else {\n    popup.focus();\n  }\n  previousUrl$1 = src;\n  const unmount = () => {\n    if (popup && !popup.closed) {\n      popup.close();\n    }\n    popup = null;\n  };\n  return [popup, unmount];\n}\n\nlet tab$1 = null;\nlet previousUrl = null;\nfunction renderTab(src) {\n  if (tab$1 == null || tab$1?.closed) {\n    tab$1 = window.open(src, \"_blank\");\n    if (!tab$1) throw new Error(\"Tab failed to open (was it blocked by the browser?)\");\n  } else if (previousUrl !== src) {\n    tab$1.location.replace(src);\n    tab$1.focus();\n  } else {\n    tab$1.focus();\n  }\n  previousUrl = src;\n  const unmount = () => {\n    if (tab$1 && !tab$1.closed) {\n      tab$1.close();\n    }\n    tab$1 = null;\n  };\n  return [tab$1, unmount];\n}\n\nconst VIEWS = {\n  \"VIEW/IFRAME\": renderFrame,\n  \"VIEW/POP\": renderPop,\n  \"VIEW/TAB\": renderTab\n};\nasync function execLocal(service) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  try {\n    return VIEWS[service.method](serviceEndpoint(service), opts);\n  } catch (error) {\n    console.error(\"execLocal({service, opts = {}})\", error, {\n      service,\n      opts\n    });\n    throw error;\n  }\n}\n\nasync function execHttpPost(_ref) {\n  let {\n    service,\n    body,\n    config,\n    opts\n  } = _ref;\n  const resp = await fetchService(service, {\n    data: {\n      fclVersion: VERSION,\n      service: {\n        params: service.params,\n        data: service.data,\n        type: service.type\n      },\n      config,\n      ...body\n    }\n  }).then(normalizePollingResponse);\n  if (resp.status === \"APPROVED\") {\n    return resp.data;\n  } else if (resp.status === \"DECLINED\") {\n    throw new Error(`Declined: ${resp.reason || \"No reason supplied.\"}`);\n  } else if (resp.status === \"REDIRECT\") {\n    return resp;\n  } else if (resp.status === \"PENDING\") {\n    var canContinue = true;\n    const [_, unmount] = await execLocal(normalizeLocalView(resp.local));\n    const close = () => {\n      try {\n        unmount();\n        canContinue = false;\n      } catch (error) {\n        console.error(\"Frame Close Error\", error);\n      }\n    };\n    return poll(resp.updates, () => canContinue).then(serviceResponse => {\n      close();\n      return serviceResponse;\n    }).catch(error => {\n      console.error(error);\n      close();\n      throw error;\n    });\n  } else {\n    console.error(`Auto Decline: Invalid Response`, {\n      service,\n      resp\n    });\n    throw new Error(`Auto Decline: Invalid Response`);\n  }\n}\n\nconst CLOSE_EVENT = \"FCL:VIEW:CLOSE\";\nconst READY_EVENT = \"FCL:VIEW:READY\";\nconst RESPONSE_EVENT = \"FCL:VIEW:RESPONSE\";\nconst _ = e => typeof e === \"string\" && e.toLowerCase();\nconst IGNORE = new Set([\"monetizationstart\", \"monetizationpending\", \"monetizationprogress\", \"monetizationstop\"]);\nconst deprecate = (was, want) => console.warn(\"DEPRECATION NOTICE\", `Received ${was}, please use ${want} for this and future versions of FCL`);\nconst buildMessageHandler = _ref => {\n  let {\n    close,\n    send,\n    onReady,\n    onResponse,\n    onMessage\n  } = _ref;\n  return e => {\n    try {\n      if (typeof e.data !== \"object\") return;\n      if (IGNORE.has(e.data.type)) return;\n      if (_(e.data.type) === _(CLOSE_EVENT)) close();\n      if (_(e.data.type) === _(READY_EVENT)) onReady(e, {\n        send,\n        close\n      });\n      if (_(e.data.type) === _(RESPONSE_EVENT)) onResponse(e, {\n        send,\n        close\n      });\n      onMessage(e, {\n        send,\n        close\n      });\n\n      // Backwards Compatible\n      if (_(e.data.type) === _(\"FCL:FRAME:READY\")) {\n        deprecate(e.data.type, READY_EVENT);\n        onReady(e, {\n          send,\n          close\n        });\n      }\n      if (_(e.data.type) === _(\"FCL:FRAME:RESPONSE\")) {\n        deprecate(e.data.type, RESPONSE_EVENT);\n        onResponse(e, {\n          send,\n          close\n        });\n      }\n      if (_(e.data.type) === _(\"FCL:FRAME:CLOSE\")) {\n        deprecate(e.data.type, CLOSE_EVENT);\n        close();\n      }\n      //\n      if (_(e.data.type) === _(\"FCL::CHALLENGE::RESPONSE\")) {\n        deprecate(e.data.type, RESPONSE_EVENT);\n        onResponse(e, {\n          send,\n          close\n        });\n      }\n      if (_(e.data.type) === _(\"FCL::AUTHZ_READY\")) {\n        deprecate(e.data.type, READY_EVENT);\n        onReady(e, {\n          send,\n          close\n        });\n      }\n      if (_(e.data.type) === _(\"FCL::CHALLENGE::CANCEL\")) {\n        deprecate(e.data.type, CLOSE_EVENT);\n        close();\n      }\n      if (_(e.data.type) === _(\"FCL::CANCEL\")) {\n        deprecate(e.data.type, CLOSE_EVENT);\n        close();\n      }\n    } catch (error) {\n      console.error(\"Frame Callback Error\", error);\n      close();\n    }\n  };\n};\n\nconst noop$3 = () => {};\nfunction frame(service) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (service == null) return {\n    send: noop$3,\n    close: noop$3\n  };\n  const onClose = opts.onClose || noop$3;\n  const onMessage = opts.onMessage || noop$3;\n  const onReady = opts.onReady || noop$3;\n  const onResponse = opts.onResponse || noop$3;\n  const handler = buildMessageHandler({\n    close,\n    send,\n    onReady,\n    onResponse,\n    onMessage\n  });\n  window.addEventListener(\"message\", handler);\n  const [$frame, unmount] = renderFrame(serviceEndpoint(service));\n  return {\n    send,\n    close\n  };\n  function close() {\n    try {\n      window.removeEventListener(\"message\", handler);\n      unmount();\n      onClose();\n    } catch (error) {\n      console.error(\"Frame Close Error\", error);\n    }\n  }\n  function send(msg) {\n    try {\n      $frame.postMessage(JSON.parse(JSON.stringify(msg || {})), \"*\");\n    } catch (error) {\n      console.error(\"Frame Send Error\", msg, error);\n    }\n  }\n}\n\nfunction execIframeRPC(_ref) {\n  let {\n    service,\n    body,\n    config,\n    opts\n  } = _ref;\n  return new Promise((resolve, reject) => {\n    const id = uid();\n    const includeOlderJsonRpcCall = opts.includeOlderJsonRpcCall;\n    frame(service, {\n      async onReady(_, _ref2) {\n        let {\n          send\n        } = _ref2;\n        try {\n          send({\n            type: \"FCL:VIEW:READY:RESPONSE\",\n            fclVersion: VERSION,\n            body,\n            service: {\n              params: service.params,\n              data: service.data,\n              type: service.type\n            },\n            config\n          });\n          send({\n            fclVersion: VERSION,\n            type: \"FCL:FRAME:READY:RESPONSE\",\n            body,\n            service: {\n              params: service.params,\n              data: service.data,\n              type: service.type\n            },\n            config,\n            deprecated: {\n              message: \"FCL:FRAME:READY:RESPONSE is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE\"\n            }\n          });\n          if (includeOlderJsonRpcCall) {\n            send({\n              jsonrpc: \"2.0\",\n              id: id,\n              method: \"fcl:sign\",\n              params: [body, service.params],\n              deprecated: {\n                message: \"jsonrpc is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE\"\n              }\n            });\n          }\n        } catch (error) {\n          throw error;\n        }\n      },\n      onResponse(e, _ref3) {\n        let {\n          close\n        } = _ref3;\n        try {\n          if (typeof e.data !== \"object\") return;\n          const resp = normalizePollingResponse(e.data);\n          switch (resp.status) {\n            case \"APPROVED\":\n              resolve(resp.data);\n              close();\n              break;\n            case \"DECLINED\":\n              reject(`Declined: ${resp.reason || \"No reason supplied\"}`);\n              close();\n              break;\n            case \"REDIRECT\":\n              resolve(resp);\n              close();\n              break;\n            default:\n              reject(`Declined: No reason supplied`);\n              close();\n              break;\n          }\n        } catch (error) {\n          console.error(\"execIframeRPC onResponse error\", error);\n          throw error;\n        }\n      },\n      onMessage(e, _ref4) {\n        let {\n          close\n        } = _ref4;\n        try {\n          if (typeof e.data !== \"object\") return;\n          if (e.data.jsonrpc !== \"2.0\") return;\n          if (e.data.id !== id) return;\n          const resp = normalizePollingResponse(e.data.result);\n          switch (resp.status) {\n            case \"APPROVED\":\n              resolve(resp.data);\n              close();\n              break;\n            case \"DECLINED\":\n              reject(`Declined: ${resp.reason || \"No reason supplied\"}`);\n              close();\n              break;\n            case \"REDIRECT\":\n              resolve(resp);\n              close();\n              break;\n            default:\n              reject(`Declined: No reason supplied`);\n              close();\n              break;\n          }\n        } catch (error) {\n          console.error(\"execIframeRPC onMessage error\", error);\n          throw error;\n        }\n      },\n      onClose() {\n        reject(`Declined: Externally Halted`);\n      }\n    });\n  });\n}\n\nconst noop$2 = () => {};\nfunction pop(service) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (service == null) return {\n    send: noop$2,\n    close: noop$2\n  };\n  const onClose = opts.onClose || noop$2;\n  const onMessage = opts.onMessage || noop$2;\n  const onReady = opts.onReady || noop$2;\n  const onResponse = opts.onResponse || noop$2;\n  const handler = buildMessageHandler({\n    close,\n    send,\n    onReady,\n    onResponse,\n    onMessage\n  });\n  window.addEventListener(\"message\", handler);\n  const [$pop, unmount] = renderPop(serviceEndpoint(service));\n  const timer = setInterval(function () {\n    if ($pop && $pop.closed) {\n      close();\n    }\n  }, 500);\n  return {\n    send,\n    close\n  };\n  function close() {\n    try {\n      window.removeEventListener(\"message\", handler);\n      clearInterval(timer);\n      unmount();\n      onClose();\n    } catch (error) {\n      console.error(\"Popup Close Error\", error);\n    }\n  }\n  function send(msg) {\n    try {\n      $pop.postMessage(JSON.parse(JSON.stringify(msg || {})), \"*\");\n    } catch (error) {\n      console.error(\"Popup Send Error\", msg, error);\n    }\n  }\n}\n\nfunction execPopRPC(_ref) {\n  let {\n    service,\n    body,\n    config,\n    opts\n  } = _ref;\n  return new Promise((resolve, reject) => {\n    const id = uid();\n    const {\n      redir,\n      includeOlderJsonRpcCall\n    } = opts;\n    pop(service, {\n      async onReady(_, _ref2) {\n        let {\n          send\n        } = _ref2;\n        try {\n          send({\n            fclVersion: VERSION,\n            type: \"FCL:VIEW:READY:RESPONSE\",\n            body,\n            service: {\n              params: service.params,\n              data: service.data,\n              type: service.type\n            },\n            config\n          });\n          send({\n            fclVersion: VERSION,\n            type: \"FCL:FRAME:READY:RESPONSE\",\n            body,\n            service: {\n              params: service.params,\n              data: service.data,\n              type: service.type\n            },\n            config,\n            deprecated: {\n              message: \"FCL:FRAME:READY:RESPONSE is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE\"\n            }\n          });\n          if (includeOlderJsonRpcCall) {\n            send({\n              jsonrpc: \"2.0\",\n              id: id,\n              method: \"fcl:sign\",\n              params: [body, service.params]\n            });\n          }\n        } catch (error) {\n          throw error;\n        }\n      },\n      onResponse(e, _ref3) {\n        let {\n          close\n        } = _ref3;\n        try {\n          if (typeof e.data !== \"object\") return;\n          const resp = normalizePollingResponse(e.data);\n          switch (resp.status) {\n            case \"APPROVED\":\n              resolve(resp.data);\n              !redir && close();\n              break;\n            case \"DECLINED\":\n              reject(`Declined: ${resp.reason || \"No reason supplied\"}`);\n              close();\n              break;\n            case \"REDIRECT\":\n              resolve(resp);\n              close();\n              break;\n            default:\n              reject(`Declined: No reason supplied`);\n              close();\n              break;\n          }\n        } catch (error) {\n          console.error(\"execPopRPC onResponse error\", error);\n          throw error;\n        }\n      },\n      onMessage(e, _ref4) {\n        let {\n          close\n        } = _ref4;\n        try {\n          if (typeof e.data !== \"object\") return;\n          if (e.data.jsonrpc !== \"2.0\") return;\n          if (e.data.id !== id) return;\n          const resp = normalizePollingResponse(e.data.result);\n          switch (resp.status) {\n            case \"APPROVED\":\n              resolve(resp.data);\n              !redir && close();\n              break;\n            case \"DECLINED\":\n              reject(`Declined: ${resp.reason || \"No reason supplied\"}`);\n              close();\n              break;\n            case \"REDIRECT\":\n              resolve(resp);\n              close();\n              break;\n            default:\n              reject(`Declined: No reason supplied`);\n              close();\n              break;\n          }\n        } catch (error) {\n          console.error(\"execPopRPC onMessage error\", error);\n          throw error;\n        }\n      },\n      onClose() {\n        reject(`Declined: Externally Halted`);\n      }\n    });\n  });\n}\n\nconst noop$1 = () => {};\nfunction tab(service) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (service == null) return {\n    send: noop$1,\n    close: noop$1\n  };\n  const onClose = opts.onClose || noop$1;\n  const onMessage = opts.onMessage || noop$1;\n  const onReady = opts.onReady || noop$1;\n  const onResponse = opts.onResponse || noop$1;\n  const handler = buildMessageHandler({\n    close,\n    send,\n    onReady,\n    onResponse,\n    onMessage\n  });\n  window.addEventListener(\"message\", handler);\n  const [$tab, unmount] = renderTab(serviceEndpoint(service));\n  const timer = setInterval(function () {\n    if ($tab && $tab.closed) {\n      close();\n    }\n  }, 500);\n  return {\n    send,\n    close\n  };\n  function close() {\n    try {\n      window.removeEventListener(\"message\", handler);\n      clearInterval(timer);\n      unmount();\n      onClose();\n    } catch (error) {\n      console.error(\"Tab Close Error\", error);\n    }\n  }\n  function send(msg) {\n    try {\n      $tab.postMessage(JSON.parse(JSON.stringify(msg || {})), \"*\");\n    } catch (error) {\n      console.error(\"Tab Send Error\", msg, error);\n    }\n  }\n}\n\nfunction execTabRPC(_ref) {\n  let {\n    service,\n    body,\n    config,\n    opts\n  } = _ref;\n  return new Promise((resolve, reject) => {\n    const id = uid();\n    const {\n      redir,\n      includeOlderJsonRpcCall\n    } = opts;\n    tab(service, {\n      async onReady(_, _ref2) {\n        let {\n          send\n        } = _ref2;\n        try {\n          send({\n            fclVersion: VERSION,\n            type: \"FCL:VIEW:READY:RESPONSE\",\n            body,\n            service: {\n              params: service.params,\n              data: service.data,\n              type: service.type\n            },\n            config\n          });\n          send({\n            fclVersion: VERSION,\n            type: \"FCL:FRAME:READY:RESPONSE\",\n            body,\n            service: {\n              params: service.params,\n              data: service.data,\n              type: service.type\n            },\n            config,\n            deprecated: {\n              message: \"FCL:FRAME:READY:RESPONSE is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE\"\n            }\n          });\n          if (includeOlderJsonRpcCall) {\n            send({\n              jsonrpc: \"2.0\",\n              id: id,\n              method: \"fcl:sign\",\n              params: [body, service.params]\n            });\n          }\n        } catch (error) {\n          throw error;\n        }\n      },\n      onResponse(e, _ref3) {\n        let {\n          close\n        } = _ref3;\n        try {\n          if (typeof e.data !== \"object\") return;\n          const resp = normalizePollingResponse(e.data);\n          switch (resp.status) {\n            case \"APPROVED\":\n              resolve(resp.data);\n              !redir && close();\n              break;\n            case \"DECLINED\":\n              reject(`Declined: ${resp.reason || \"No reason supplied\"}`);\n              close();\n              break;\n            case \"REDIRECT\":\n              resolve(resp);\n              close();\n              break;\n            default:\n              reject(`Declined: No reason supplied`);\n              close();\n              break;\n          }\n        } catch (error) {\n          console.error(\"execPopRPC onResponse error\", error);\n          throw error;\n        }\n      },\n      onMessage(e, _ref4) {\n        let {\n          close\n        } = _ref4;\n        try {\n          if (typeof e.data !== \"object\") return;\n          if (e.data.jsonrpc !== \"2.0\") return;\n          if (e.data.id !== id) return;\n          const resp = normalizePollingResponse(e.data.result);\n          switch (resp.status) {\n            case \"APPROVED\":\n              resolve(resp.data);\n              !redir && close();\n              break;\n            case \"DECLINED\":\n              reject(`Declined: ${resp.reason || \"No reason supplied\"}`);\n              close();\n              break;\n            case \"REDIRECT\":\n              resolve(resp);\n              close();\n              break;\n            default:\n              reject(`Declined: No reason supplied`);\n              close();\n              break;\n          }\n        } catch (error) {\n          console.error(\"execPopRPC onMessage error\", error);\n          throw error;\n        }\n      },\n      onClose() {\n        reject(`Declined: Externally Halted`);\n      }\n    });\n  });\n}\n\nconst noop = () => {};\nfunction extension(service) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (service == null) return {\n    send: noop,\n    close: noop\n  };\n  const onClose = opts.onClose || noop;\n  const onMessage = opts.onMessage || noop;\n  const onReady = opts.onReady || noop;\n  const onResponse = opts.onResponse || noop;\n  const handler = buildMessageHandler({\n    close,\n    send,\n    onReady,\n    onResponse,\n    onMessage\n  });\n  window.addEventListener(\"message\", handler);\n  send({\n    service\n  });\n  return {\n    send,\n    close\n  };\n  function close() {\n    try {\n      window.removeEventListener(\"message\", handler);\n      onClose();\n    } catch (error) {\n      console.error(\"Ext Close Error\", error);\n    }\n  }\n  function send(msg) {\n    try {\n      window && window.postMessage(JSON.parse(JSON.stringify(msg || {})), \"*\");\n    } catch (error) {\n      console.error(\"Ext Send Error\", msg, error);\n    }\n  }\n}\n\nfunction execExtRPC(_ref) {\n  let {\n    service,\n    body,\n    config,\n    opts\n  } = _ref;\n  return new Promise((resolve, reject) => {\n    extension(service, {\n      async onReady(_, _ref2) {\n        let {\n          send\n        } = _ref2;\n        try {\n          send({\n            fclVersion: VERSION,\n            type: \"FCL:VIEW:READY:RESPONSE\",\n            body,\n            service: {\n              params: service.params,\n              data: service.data,\n              type: service.type\n            },\n            config\n          });\n        } catch (error) {\n          throw error;\n        }\n      },\n      onResponse(e, _ref3) {\n        let {\n          close\n        } = _ref3;\n        try {\n          if (typeof e.data !== \"object\") return;\n          const resp = normalizePollingResponse(e.data);\n          switch (resp.status) {\n            case \"APPROVED\":\n              resolve(resp.data);\n              close();\n              break;\n            case \"DECLINED\":\n              reject(`Declined: ${resp.reason || \"No reason supplied\"}`);\n              close();\n              break;\n            case \"REDIRECT\":\n              resolve(resp);\n              close();\n              break;\n            default:\n              reject(`Declined: No reason supplied`);\n              close();\n              break;\n          }\n        } catch (error) {\n          console.error(\"execExtRPC onResponse error\", error);\n          throw error;\n        }\n      },\n      onClose() {\n        reject(`Declined: Externally Halted`);\n      }\n    });\n  });\n}\n\nconst CORE_STRATEGIES = {\n  \"HTTP/RPC\": execHttpPost,\n  \"HTTP/POST\": execHttpPost,\n  \"IFRAME/RPC\": execIframeRPC,\n  \"POP/RPC\": execPopRPC,\n  \"TAB/RPC\": execTabRPC,\n  \"EXT/RPC\": execExtRPC\n};\nconst supportedPlugins = [\"ServicePlugin\"];\nconst supportedServicePlugins = [\"discovery-service\"];\nconst validateDiscoveryPlugin = servicePlugin => {\n  const {\n    services,\n    serviceStrategy\n  } = servicePlugin;\n  invariant(Array.isArray(services) && services.length, \"Array of Discovery Services is required\");\n  for (const ds of services) {\n    invariant(isRequired(ds.f_type) && ds.f_type === \"Service\", \"Service is required\");\n    invariant(isRequired(ds.type) && ds.type === \"authn\", `Service must be type authn. Received ${ds.type}`);\n    invariant(ds.method in CORE_STRATEGIES || serviceStrategy.method === ds.method, `Service method ${ds.method} is not supported`);\n  }\n  invariant(isRequired(serviceStrategy), \"Service strategy is required\");\n  invariant(isRequired(serviceStrategy.method) && isString(serviceStrategy.method), \"Service strategy method is required\");\n  invariant(isRequired(serviceStrategy.exec) && isFunc(serviceStrategy.exec), \"Service strategy exec function is required\");\n  return {\n    discoveryServices: services,\n    serviceStrategy\n  };\n};\nconst ServiceRegistry = () => {\n  let services = new Set();\n  let strategies = new Map(Object.entries(CORE_STRATEGIES));\n  const add = servicePlugin => {\n    invariant(supportedServicePlugins.includes(servicePlugin.type), `Service Plugin type ${servicePlugin.type} is not supported`);\n    if (servicePlugin.type === \"discovery-service\") {\n      const {\n        discoveryServices,\n        serviceStrategy\n      } = validateDiscoveryPlugin(servicePlugin);\n      setServices(discoveryServices);\n      if (!strategies.has(serviceStrategy.method)) {\n        strategies.set(serviceStrategy.method, serviceStrategy.exec);\n      } else {\n        log({\n          title: `Add Service Plugin`,\n          message: `Service strategy for ${serviceStrategy.method} already exists`,\n          level: LEVELS.warn\n        });\n      }\n    }\n  };\n  const setServices = discoveryServices => services = new Set([...discoveryServices]);\n  const getServices = () => [...services];\n  const getStrategy = method => strategies.get(method);\n  const getStrategies = () => [...strategies.keys()];\n  return Object.freeze({\n    add,\n    getServices,\n    getStrategy,\n    getStrategies\n  });\n};\nconst validatePlugins = plugins => {\n  let pluginsArray;\n  invariant(plugins, \"No plugins supplied\");\n  if (!Array.isArray(plugins)) {\n    pluginsArray = [plugins];\n  } else {\n    pluginsArray = [...plugins];\n  }\n  for (const p of pluginsArray) {\n    invariant(isRequired(p.name), \"Plugin name is required\");\n    invariant(isRequired(p.f_type), \"Plugin f_type is required\");\n    invariant(supportedPlugins.includes(p.f_type), `Plugin type ${p.f_type} is not supported`);\n  }\n  return pluginsArray;\n};\nconst PluginRegistry = () => {\n  const pluginsMap = new Map();\n  const getPlugins = () => pluginsMap;\n  const add = plugins => {\n    const pluginsArray = validatePlugins(plugins);\n    for (const p of pluginsArray) {\n      pluginsMap.set(p.name, p);\n      if (p.f_type === \"ServicePlugin\") {\n        serviceRegistry.add(p);\n      }\n    }\n  };\n  return Object.freeze({\n    add,\n    getPlugins\n  });\n};\nconst serviceRegistry = ServiceRegistry();\nconst pluginRegistry = PluginRegistry();\n\nconst execStrategy = async _ref => {\n  let {\n    service,\n    body,\n    config,\n    opts\n  } = _ref;\n  const strategy = serviceRegistry.getStrategy(service.method);\n  return strategy({\n    service,\n    body,\n    config,\n    opts\n  });\n};\nasync function execService(_ref2) {\n  let {\n    service,\n    msg = {},\n    config = {},\n    opts = {}\n  } = _ref2;\n  msg.data = service.data;\n  const execConfig = {\n    services: await configLens(/^service\\./),\n    app: await configLens(/^app\\.detail\\./),\n    client: {\n      ...config.client,\n      fclVersion: VERSION,\n      fclLibrary: \"https://github.com/onflow/fcl-js\",\n      hostname: window?.location?.hostname ?? null,\n      network: await getChainId()\n    }\n  };\n  try {\n    const res = await execStrategy({\n      service,\n      body: msg,\n      config: execConfig,\n      opts\n    });\n    if (res.status === \"REDIRECT\") {\n      invariant(service.type === res.data.type, \"Cannot shift recursive service type in execService\");\n      return await execService({\n        service: res.data,\n        msg,\n        config: execConfig,\n        opts\n      });\n    } else {\n      return res;\n    }\n  } catch (error) {\n    log({\n      title: `Error on execService ${service?.type}`,\n      message: error,\n      level: LEVELS.error\n    });\n    throw error;\n  }\n}\n\n// {\n//    \"f_type\": \"CompositeSignature\",\n//    \"f_vsn\": \"1.0.0\",\n//    \"addr\": \"_____\",         // sans-prefix\n//    \"signature\": \"adfe1234\", // hex\n//    \"keyId\": 3,\n// }\nfunction normalizeCompositeSignature(resp) {\n  if (resp == null) return null;\n  switch (resp[\"f_vsn\"]) {\n    case \"1.0.0\":\n      return resp;\n    default:\n      return {\n        ...COMPOSITE_SIGNATURE_PRAGMA,\n        addr: sansPrefix(resp.addr || resp.address),\n        signature: resp.signature || resp.sig,\n        keyId: resp.keyId\n      };\n  }\n}\n\nconst makeDiscoveryServices = async () => {\n  const extensionServices = window?.fcl_extensions || [];\n  return [...extensionServices, ...serviceRegistry.getServices()];\n};\nasync function getDiscoveryService(service) {\n  const discoveryAuthnInclude = await config.get(\"discovery.authn.include\", []);\n  const discoveryWalletMethod = await config.first([\"discovery.wallet.method\", \"discovery.wallet.method.default\"]);\n  const method = service?.method ? service.method : discoveryWalletMethod;\n  const endpoint = service?.endpoint ?? (await config.first([\"discovery.wallet\", \"challenge.handshake\"]));\n  invariant(endpoint, `\n    If no service is passed to \"authenticate,\" then \"discovery.wallet\" must be defined in fcl config.\n    See: \"https://docs.onflow.org/fcl/reference/api/#setting-configuration-values\"\n    `);\n  return {\n    ...service,\n    type: \"authn\",\n    endpoint,\n    method,\n    discoveryAuthnInclude\n  };\n}\n\nasync function getServices(_ref) {\n  let {\n    types\n  } = _ref;\n  const endpoint = await config.get(\"discovery.authn.endpoint\");\n  invariant(Boolean(endpoint), `\"discovery.authn.endpoint\" in config must be defined.`);\n  const include = await config.get(\"discovery.authn.include\", []);\n  const url = new URL(endpoint);\n  return fetch(url, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify({\n      type: types,\n      fclVersion: VERSION,\n      include,\n      clientServices: await makeDiscoveryServices(),\n      supportedStrategies: serviceRegistry.getStrategies(),\n      userAgent: window?.navigator?.userAgent,\n      network: await getChainId()\n    })\n  }).then(d => d.json());\n}\n\nconst SERVICE_ACTOR_KEYS = {\n  AUTHN: \"authn\",\n  RESULTS: \"results\",\n  SNAPSHOT: \"SNAPSHOT\",\n  UPDATED: \"UPDATED\",\n  UPDATE_RESULTS: \"UPDATE_RESULTS\"\n};\nconst warn = (fact, msg) => {\n  if (fact) {\n    console.warn(`\n      %cFCL Warning\n      ============================\n      ${msg}\n      For more info, please see the docs: https://docs.onflow.org/fcl/\n      ============================\n      `, \"font-weight:bold;font-family:monospace;\");\n  }\n};\nconst fetchServicesFromDiscovery = async () => {\n  try {\n    const services = await getServices({\n      types: [SERVICE_ACTOR_KEYS.AUTHN]\n    });\n    send(SERVICE_ACTOR_KEYS.AUTHN, SERVICE_ACTOR_KEYS.UPDATE_RESULTS, {\n      results: services\n    });\n  } catch (error) {\n    log({\n      title: `${error.name} Error fetching Discovery API services.`,\n      message: error.message,\n      level: LEVELS.error\n    });\n  }\n};\nconst HANDLERS$3 = {\n  [INIT]: async ctx => {\n    warn(typeof window === \"undefined\", '\"fcl.discovery\" is only available in the browser.');\n    // If you call this before the window is loaded extensions will not be set yet\n    if (document.readyState === 'complete') {\n      fetchServicesFromDiscovery();\n    } else {\n      window.onload = async () => {\n        fetchServicesFromDiscovery();\n      };\n    }\n  },\n  [SERVICE_ACTOR_KEYS.UPDATE_RESULTS]: (ctx, _letter, data) => {\n    ctx.merge(data);\n    ctx.broadcast(SERVICE_ACTOR_KEYS.UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [SUBSCRIBE]: (ctx, letter) => {\n    ctx.subscribe(letter.from);\n    ctx.send(letter.from, SERVICE_ACTOR_KEYS.UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [UNSUBSCRIBE]: (ctx, letter) => ctx.unsubscribe(letter.from),\n  [SERVICE_ACTOR_KEYS.SNAPSHOT]: async (ctx, letter) => letter.reply({\n    ...ctx.all()\n  })\n};\nconst spawnProviders = () => spawn(HANDLERS$3, SERVICE_ACTOR_KEYS.AUTHN);\n\n/**\n * @typedef {import(\"@onflow/typedefs\").Service} Service\n */\n\n/**\n * @callback SubscriptionCallback\n * @returns {Service[]}\n */\n\n/**\n * @description\n * Discovery methods for interacting with Authn.\n * \n * @typedef {object} Authn\n * @property {Function} subscribe - Subscribe to Discovery authn services\n * @property {Function} snapshot - Get the current Discovery authn services spanshot\n * @property {Function} update - Trigger an update of authn services\n */\nconst authn = {\n  /**\n   * @description - Subscribe to Discovery authn services\n   * @param {Function} cb\n   * @returns {SubscriptionCallback}\n   */\n  subscribe: cb => subscriber(SERVICE_ACTOR_KEYS.AUTHN, spawnProviders, cb),\n  /**\n   * @description - Get the current Discovery authn services spanshot\n   * @returns {Service[]}\n   */\n  snapshot: () => snapshoter(SERVICE_ACTOR_KEYS.AUTHN, spawnProviders),\n  /**\n   * @description - Trigger an update of authn services\n   * @returns {void}\n   */\n  update: () => fetchServicesFromDiscovery()\n};\n\nconst discovery = {\n  authn\n};\n\n/**\n * @typedef {import(\"@onflow/typedefs\").CurrentUser} CurrentUser\n * @typedef {import(\"@onflow/typedefs\").CompositeSignature} CompositeSignature\n */\n\nconst isFn = d => typeof d === \"function\";\nconst NAME = \"CURRENT_USER\";\nconst UPDATED$1 = \"CURRENT_USER/UPDATED\";\nconst SNAPSHOT = \"SNAPSHOT\";\nconst SET_CURRENT_USER = \"SET_CURRENT_USER\";\nconst DEL_CURRENT_USER = \"DEL_CURRENT_USER\";\nconst DATA = `{\n  \"f_type\": \"User\",\n  \"f_vsn\": \"1.0.0\",\n  \"addr\":null,\n  \"cid\":null,\n  \"loggedIn\":null,\n  \"expiresAt\":null,\n  \"services\":[]\n}`;\nconst getStoredUser = async storage => {\n  const fallback = JSON.parse(DATA);\n  const stored = await storage.get(NAME);\n  if (stored != null && fallback[\"f_vsn\"] !== stored[\"f_vsn\"]) {\n    storage.removeItem(NAME);\n    return fallback;\n  }\n  return stored || fallback;\n};\nconst HANDLERS$2 = {\n  [INIT]: async ctx => {\n    if (typeof window === \"undefined\") {\n      console.warn(`\n        %cFCL Warning\n        ============================\n        \"currentUser\" is only available in the browser.\n        For more info, please see the docs: https://docs.onflow.org/fcl/\n        ============================\n        `, \"font-weight:bold;font-family:monospace;\");\n    }\n    ctx.merge(JSON.parse(DATA));\n    const storage = await config.first([\"fcl.storage\", \"fcl.storage.default\"]);\n    if (storage.can) {\n      const user = await getStoredUser(storage);\n      if (notExpired(user)) ctx.merge(user);\n    }\n  },\n  [SUBSCRIBE]: (ctx, letter) => {\n    ctx.subscribe(letter.from);\n    ctx.send(letter.from, UPDATED$1, {\n      ...ctx.all()\n    });\n  },\n  [UNSUBSCRIBE]: (ctx, letter) => {\n    ctx.unsubscribe(letter.from);\n  },\n  [SNAPSHOT]: async (ctx, letter) => {\n    letter.reply({\n      ...ctx.all()\n    });\n  },\n  [SET_CURRENT_USER]: async (ctx, letter, data) => {\n    ctx.merge(data);\n    const storage = await config.first([\"fcl.storage\", \"fcl.storage.default\"]);\n    if (storage.can) storage.put(NAME, ctx.all());\n    ctx.broadcast(UPDATED$1, {\n      ...ctx.all()\n    });\n  },\n  [DEL_CURRENT_USER]: async (ctx, letter) => {\n    ctx.merge(JSON.parse(DATA));\n    const storage = await config.first([\"fcl.storage\", \"fcl.storage.default\"]);\n    if (storage.can) storage.put(NAME, ctx.all());\n    ctx.broadcast(UPDATED$1, {\n      ...ctx.all()\n    });\n  }\n};\nconst spawnCurrentUser = () => spawn(HANDLERS$2, NAME);\nfunction notExpired(user) {\n  return user.expiresAt == null || user.expiresAt === 0 || user.expiresAt > Date.now();\n}\nasync function getAccountProofData() {\n  let accountProofDataResolver = await config.get(\"fcl.accountProof.resolver\");\n  if (accountProofDataResolver == null) return;\n  if (!isFn(accountProofDataResolver)) {\n    log({\n      title: \"Account Proof Data Resolver must be a function\",\n      message: `Check fcl.accountProof.resolver configuration.\n                Expected: fcl.accountProof.resolver: async () => { ... }\n                Received: fcl.accountProof.resolver: ${typeof accountProofDataResolver}\n                `,\n      level: LEVELS.warn\n    });\n    return;\n  }\n  const accountProofData = await accountProofDataResolver();\n  if (accountProofData == null) return;\n  invariant(typeof accountProofData.appIdentifier === \"string\", \"appIdentifier must be a string\");\n  invariant(/^[0-9a-f]+$/i.test(accountProofData.nonce), \"Nonce must be a hex string\");\n  return accountProofData;\n}\nconst makeConfig = async _ref => {\n  let {\n    discoveryAuthnInclude\n  } = _ref;\n  return {\n    client: {\n      discoveryAuthnInclude,\n      clientServices: await makeDiscoveryServices(),\n      supportedStrategies: serviceRegistry.getStrategies()\n    }\n  };\n};\n\n/**\n * @description - Authenticate a user\n * @param {object} [opts] - Options\n * @param {object} [opts.service] - Optional service to use for authentication\n * @param {boolean} [opts.redir=false] - Optional flag to allow window to stay open after authentication\n * @returns {Promise<CurrentUser>} - User object\n */\nasync function authenticate$1() {\n  let {\n    service,\n    redir = false\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  if (service && !service?.provider?.is_installed && service?.provider?.requires_install) {\n    window.location.href = service?.provider?.install_link;\n    return;\n  }\n  return new Promise(async (resolve, reject) => {\n    spawnCurrentUser();\n    const opts = {\n      redir\n    };\n    const user = await snapshot();\n    const discoveryService = await getDiscoveryService(service);\n    const refreshService = serviceOfType(user.services, \"authn-refresh\");\n    let accountProofData;\n    if (user.loggedIn) {\n      if (refreshService) {\n        try {\n          const response = await execService({\n            service: refreshService,\n            msg: accountProofData,\n            opts\n          });\n          send(NAME, SET_CURRENT_USER, await buildUser(response));\n        } catch (error) {\n          log({\n            title: `${error.name} Could not refresh wallet authentication.`,\n            message: error.message,\n            level: LEVELS.error\n          });\n        } finally {\n          return resolve(await snapshot());\n        }\n      } else {\n        return resolve(user);\n      }\n    }\n    try {\n      accountProofData = await getAccountProofData();\n    } catch (error) {\n      log({\n        title: `${error.name} On Authentication: Could not resolve account proof data.`,\n        message: error.message,\n        level: LEVELS.error\n      });\n      return reject(error);\n    }\n    try {\n      const response = await execService({\n        service: discoveryService,\n        msg: accountProofData,\n        config: await makeConfig(discoveryService),\n        opts\n      });\n      send(NAME, SET_CURRENT_USER, await buildUser(response));\n    } catch (error) {\n      log({\n        title: `${error} On Authentication`,\n        message: error,\n        level: LEVELS.error\n      });\n    } finally {\n      resolve(await snapshot());\n    }\n  });\n}\n\n/**\n * @description - Unauthenticate a user\n * @returns {void}\n */\nfunction unauthenticate$1() {\n  spawnCurrentUser();\n  send(NAME, DEL_CURRENT_USER);\n}\nconst normalizePreAuthzResponse = authz => ({\n  f_type: \"PreAuthzResponse\",\n  f_vsn: \"1.0.0\",\n  proposer: (authz || {}).proposer,\n  payer: (authz || {}).payer || [],\n  authorization: (authz || {}).authorization || []\n});\nfunction resolvePreAuthz(authz) {\n  const resp = normalizePreAuthzResponse(authz);\n  const axs = [];\n  if (resp.proposer != null) axs.push([\"PROPOSER\", resp.proposer]);\n  for (let az of resp.payer || []) axs.push([\"PAYER\", az]);\n  for (let az of resp.authorization || []) axs.push([\"AUTHORIZER\", az]);\n  var result = axs.map(_ref2 => {\n    let [role, az] = _ref2;\n    return {\n      tempId: [az.identity.address, az.identity.keyId].join(\"|\"),\n      addr: az.identity.address,\n      keyId: az.identity.keyId,\n      signingFunction(signable) {\n        return execService({\n          service: az,\n          msg: signable\n        });\n      },\n      role: {\n        proposer: role === \"PROPOSER\",\n        payer: role === \"PAYER\",\n        authorizer: role === \"AUTHORIZER\"\n      }\n    };\n  });\n  return result;\n}\n\n/**\n * @description\n * Produces the needed authorization details for the current user to submit transactions to Flow\n * It defines a signing function that connects to a user's wallet provider to produce signatures to submit transactions.\n * \n * @param {object} account - Account object\n * @returns {Promise<object>} - Account object with signing function\n */\nasync function authorization(account) {\n  spawnCurrentUser();\n  return {\n    ...account,\n    tempId: \"CURRENT_USER\",\n    async resolve(account, preSignable) {\n      const user = await authenticate$1({\n        redir: true\n      });\n      const authz = serviceOfType(user.services, \"authz\");\n      const preAuthz = serviceOfType(user.services, \"pre-authz\");\n      if (preAuthz) return resolvePreAuthz(await execService({\n        service: preAuthz,\n        msg: preSignable\n      }));\n      if (authz) {\n        let windowRef;\n        if (isMobile() && authz.method === \"WC/RPC\") {\n          windowRef = window.open(\"\", \"_blank\");\n        }\n        return {\n          ...account,\n          tempId: \"CURRENT_USER\",\n          resolve: null,\n          addr: sansPrefix(authz.identity.address),\n          keyId: authz.identity.keyId,\n          sequenceNum: null,\n          signature: null,\n          async signingFunction(signable) {\n            return normalizeCompositeSignature(await execService({\n              service: authz,\n              msg: signable,\n              opts: {\n                includeOlderJsonRpcCall: true,\n                windowRef\n              }\n            }));\n          }\n        };\n      }\n      throw new Error(\"No Authz or PreAuthz Service configured for CURRENT_USER\");\n    }\n  };\n}\n\n/**\n * @description\n * The callback passed to subscribe will be called when the user authenticates and un-authenticates, making it easy to update the UI accordingly.\n * \n * @param {Function} callback - Callback function\n * @returns {Function} - Unsubscribe function\n */\nfunction subscribe(callback) {\n  spawnCurrentUser();\n  const EXIT = \"@EXIT\";\n  const self = spawn(async ctx => {\n    ctx.send(NAME, SUBSCRIBE);\n    while (1) {\n      const letter = await ctx.receive();\n      if (letter.tag === EXIT) {\n        ctx.send(NAME, UNSUBSCRIBE);\n        return;\n      }\n      callback(letter.data);\n    }\n  });\n  return () => send(self, EXIT);\n}\n\n/**\n * @description - Gets the current user\n * @returns {Promise<CurrentUser>} - User object\n */\nfunction snapshot() {\n  spawnCurrentUser();\n  return send(NAME, SNAPSHOT, null, {\n    expectReply: true,\n    timeout: 0\n  });\n}\n\n/**\n * @description - Resolves the current user as an argument\n * @returns {Promise<Function>}\n */\nasync function resolveArgument() {\n  const {\n    addr\n  } = await authenticate$1();\n  return arg(withPrefix(addr), t$1.Address);\n}\nconst makeSignable = msg => {\n  invariant(/^[0-9a-f]+$/i.test(msg), \"Message must be a hex string\");\n  return {\n    message: msg\n  };\n};\n\n/**\n * @description - A method to use allowing the user to personally sign data via FCL Compatible Wallets/Services.\n * @param {string} msg - Message to sign\n * @returns {Promise<CompositeSignature[]>} - Array of CompositeSignatures\n */\nasync function signUserMessage(msg) {\n  spawnCurrentUser();\n  const user = await authenticate$1({\n    redir: true\n  });\n  const signingService = serviceOfType(user.services, \"user-signature\");\n  invariant(signingService, \"Current user must have authorized a signing service.\");\n  try {\n    const response = await execService({\n      service: signingService,\n      msg: makeSignable(msg)\n    });\n    if (Array.isArray(response)) {\n      return response.map(compSigs => normalizeCompositeSignature(compSigs));\n    } else {\n      return [normalizeCompositeSignature(response)];\n    }\n  } catch (error) {\n    return error;\n  }\n}\nlet currentUser = () => {\n  return {\n    authenticate: authenticate$1,\n    unauthenticate: unauthenticate$1,\n    authorization,\n    signUserMessage,\n    subscribe,\n    snapshot,\n    resolveArgument\n  };\n};\ncurrentUser.authenticate = authenticate$1;\ncurrentUser.unauthenticate = unauthenticate$1;\ncurrentUser.authorization = authorization;\ncurrentUser.signUserMessage = signUserMessage;\ncurrentUser.subscribe = subscribe;\ncurrentUser.snapshot = snapshot;\ncurrentUser.resolveArgument = resolveArgument;\n\n/**\n * @description\n * Allows you to submit transactions to the blockchain to potentially mutate the state.\n *\n *  @param {object} opts - Mutation Options and configuration\n *  @param {string} opts.cadence - Cadence Transaction used to mutate Flow\n *  @param {import(\"../fcl\").ArgsFn} [opts.args] - Arguments passed to cadence transaction\n *  @param {object} [opts.template] - Interaction Template for a transaction\n *  @param {number} [opts.limit] - Compute Limit for transaction\n *  @returns {Promise<string>} Transaction Id\n *\n * @example\n *    fcl.mutate({\n *      cadence: `\n *        transaction(a: Int, b: Int, c: Address) {\n *          prepare(acct: AuthAccount) {\n *            log(acct)\n *            log(a)\n *            log(b)\n *            log(c)\n *          }\n *        }\n *      `,\n *      args: (arg, t) => [\n *        arg(6, t.Int),\n *        arg(7, t.Int),\n *        arg(\"0xba1132bc08f82fe2\", t.Address),\n *      ],\n *    })\n *\n *\n *  Options:\n *    type Options = {\n *      template: InteractionTemplate | String // InteractionTemplate or url to one\n *      cadence: String!,\n *      args: (arg, t) => Array<Arg>,\n *      limit: Number,\n *      authz: AuthzFn, // will overload the trinity of signatory roles\n *      proposer: AuthzFn, // will overload the proposer signatory role\n *      payer: AuthzFn, // will overload the payer signatory role\n *      authorizations: [AuthzFn], // an array of authorization functions used as authorizations signatory roles\n *    }\n */\nasync function mutate() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var txid;\n  try {\n    await preMutate(opts);\n    opts = await prepTemplateOpts(opts);\n\n    // Allow for a config to overwrite the authorization function.\n    // prettier-ignore\n    const authz = await sdk.config().get(\"fcl.authz\", currentUser().authorization);\n    txid = sdk.config().overload(opts.dependencies || {}, async () =>\n    // prettier-ignore\n    sdk.send([sdk.transaction(opts.cadence), sdk.args(normalizeArgs(opts.args || [])), opts.limit && isNumber(opts.limit) && sdk.limit(opts.limit),\n    // opts.proposer > opts.authz > authz\n    sdk.proposer(opts.proposer || opts.authz || authz),\n    // opts.payer > opts.authz > authz\n    sdk.payer(opts.payer || opts.authz || authz),\n    // opts.authorizations > [opts.authz > authz]\n    sdk.authorizations(opts.authorizations || [opts.authz || authz])]).then(sdk.decode));\n    return txid;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * @description\n * Listens for messages from FCL\n * \n * @param {string} messageType - Message type\n * @param {Function} cb - Callback function\n * @returns {Function} - Function to remove event listener\n */\nconst onMessageFromFCL = function (messageType) {\n  let cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};\n  const buildData = data => {\n    if (data.deprecated) console.warn(\"DEPRECATION NOTICE\", data.deprecated.message);\n    delete data?.body?.interaction;\n    return data;\n  };\n  const internal = e => {\n    const {\n      data\n    } = e;\n    if (typeof data !== \"object\") return;\n    if (typeof data == null) return;\n    if (data.type !== messageType) return;\n    cb(buildData(data));\n  };\n  window.addEventListener(\"message\", internal);\n  return () => window.removeEventListener(\"message\", internal);\n};\n\n/**\n * @description\n * Sends message to FCL window\n * \n * @param {string} type - Message type\n * @param {object} msg - Message object\n * @returns {void}\n * \n * @example\n * sendMsgToFCL(\"FCL:VIEW:RESPONSE\", {\n *    f_type: \"PollingResponse\",\n *    f_vsn: \"1.0.0\",\n *    status: \"APPROVED\",\n *    reason: null,\n *    data: data,\n *  })\n */\nconst sendMsgToFCL = function (type) {\n  let msg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (window.location !== window.parent.location) {\n    window.parent.postMessage({\n      ...msg,\n      type\n    }, \"*\");\n  } else if (window.opener) {\n    window.opener.postMessage({\n      ...msg,\n      type\n    }, \"*\");\n  } else {\n    throw new Error(\"Unable to communicate with parent FCL instance\");\n  }\n};\n\n/**\n * @description\n * Listens for \"FCL:VIEW:READY:RESPONSE\" and sends \"FCL:VIEW:READY\"\n * \n * @param {Function} cb - Callback function\n * @param {object} msg - Message object\n * @returns {void}\n */\nconst ready = function (cb) {\n  onMessageFromFCL(\"FCL:VIEW:READY:RESPONSE\", cb);\n  sendMsgToFCL(\"FCL:VIEW:READY\");\n};\n\n/**\n * @description\n * Sends \"FCL:VIEW:CLOSE\"\n * \n * @returns {void}\n */\nconst close = () => {\n  sendMsgToFCL(\"FCL:VIEW:CLOSE\");\n};\n\n/**\n * @description\n * Sends \"FCL:VIEW:RESPONSE\" with status \"APPROVED\"\n * \n * @param {object} data - Data object\n * @returns {void}\n */\nconst approve = data => {\n  sendMsgToFCL(\"FCL:VIEW:RESPONSE\", {\n    f_type: \"PollingResponse\",\n    f_vsn: \"1.0.0\",\n    status: \"APPROVED\",\n    reason: null,\n    data: data\n  });\n};\n\n/**\n * @description\n * Sends \"FCL:VIEW:RESPONSE\" with status \"DECLINED\"\n * \n * @param {string} reason - Reason for declining\n * @returns {void}\n */\nconst decline = reason => {\n  sendMsgToFCL(\"FCL:VIEW:RESPONSE\", {\n    f_type: \"PollingResponse\",\n    f_vsn: \"1.0.0\",\n    status: \"DECLINED\",\n    reason: reason,\n    data: null\n  });\n};\n\n/**\n * @description\n * Sends \"FCL:VIEW:RESPONSE\" with status \"REDIRECT\"\n * \n * @param {object} data - Data object\n * @returns {void}\n */\nconst redirect = data => {\n  sendMsgToFCL(\"FCL:VIEW:RESPONSE\", {\n    f_type: \"PollingResponse\",\n    f_vsn: \"1.0.0\",\n    status: \"REDIRECT\",\n    reason: null,\n    data: data\n  });\n};\n\n/**\n * @description\n * Constructs a new CompositeSignature instance.\n *\n * @param {string} addr - Flow Address\n * @param {number} keyId - Key ID\n * @param {string} signature - Signature as a hex string\n */\nfunction CompositeSignature(addr, keyId, signature) {\n  this.f_type = COMPOSITE_SIGNATURE_PRAGMA.f_type;\n  this.f_vsn = COMPOSITE_SIGNATURE_PRAGMA.f_vsn;\n  this.addr = withPrefix(addr);\n  this.keyId = Number(keyId);\n  this.signature = signature;\n}\n\nconst rightPaddedHexBuffer = (value, pad) => Buffer.from(value.padEnd(pad * 2, \"0\"), \"hex\");\nconst leftPaddedHexBuffer = (value, pad) => Buffer.from(value.padStart(pad * 2, \"0\"), \"hex\");\nconst addressBuffer = addr => leftPaddedHexBuffer(addr, 8);\nconst nonceBuffer = nonce => Buffer.from(nonce, \"hex\");\nconst encodeAccountProof = function (_ref) {\n  let {\n    address,\n    nonce,\n    appIdentifier\n  } = _ref;\n  let includeDomainTag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  invariant(address, \"Encode Message For Provable Authn Error: address must be defined\");\n  invariant(nonce, \"Encode Message For Provable Authn Error: nonce must be defined\");\n  invariant(appIdentifier, \"Encode Message For Provable Authn Error: appIdentifier must be defined\");\n  invariant(nonce.length >= 64, \"Encode Message For Provable Authn Error: nonce must be minimum of 32 bytes\");\n  const ACCOUNT_PROOF_DOMAIN_TAG = rightPaddedHexBuffer(Buffer.from(\"FCL-ACCOUNT-PROOF-V0.0\").toString(\"hex\"), 32);\n  if (includeDomainTag) {\n    return Buffer.concat([ACCOUNT_PROOF_DOMAIN_TAG, encode([appIdentifier, addressBuffer(sansPrefix(address)), nonceBuffer(nonce)])]).toString(\"hex\");\n  }\n  return encode([appIdentifier, addressBuffer(sansPrefix(address)), nonceBuffer(nonce)]).toString(\"hex\");\n};\n\nfunction injectExtService(service) {\n  if (service.type === \"authn\" && service.endpoint != null) {\n    if (!Array.isArray(window.fcl_extensions)) {\n      window.fcl_extensions = [];\n    }\n    window.fcl_extensions.push(service);\n  } else {\n    console.warn(\"Authn service is required\");\n  }\n}\n\nvar index$2 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  sendMsgToFCL: sendMsgToFCL,\n  ready: ready,\n  close: close,\n  approve: approve,\n  decline: decline,\n  redirect: redirect,\n  onMessageFromFCL: onMessageFromFCL,\n  encodeMessageFromSignable: encodeMessageFromSignable,\n  CompositeSignature: CompositeSignature,\n  encodeAccountProof: encodeAccountProof,\n  injectExtService: injectExtService\n});\n\nconst ACCOUNT_PROOF = \"ACCOUNT_PROOF\";\nconst USER_SIGNATURE = \"USER_SIGNATURE\";\nconst validateArgs = args => {\n  if (args.appIdentifier) {\n    const {\n      appIdentifier,\n      address,\n      nonce,\n      signatures\n    } = args;\n    invariant(isString(appIdentifier), \"verifyAccountProof({ appIdentifier }) -- appIdentifier must be a string\");\n    invariant(isString(address) && sansPrefix(address).length === 16, \"verifyAccountProof({ address }) -- address must be a valid address\");\n    invariant(/^[0-9a-f]+$/i.test(nonce), \"nonce must be a hex string\");\n    invariant(Array.isArray(signatures) && signatures.every((sig, i, arr) => sig.f_type === \"CompositeSignature\"), \"Must include an Array of CompositeSignatures to verify\");\n    invariant(signatures.map(cs => cs.addr).every((addr, i, arr) => addr === arr[0]), \"User signatures to be verified must be from a single account address\");\n    return true;\n  } else {\n    const {\n      message,\n      address,\n      compSigs\n    } = args;\n    invariant(/^[0-9a-f]+$/i.test(message), \"Signed message must be a hex string\");\n    invariant(isString(address) && sansPrefix(address).length === 16, \"verifyUserSignatures({ address }) -- address must be a valid address\");\n    invariant(Array.isArray(compSigs) && compSigs.every((sig, i, arr) => sig.f_type === \"CompositeSignature\"), \"Must include an Array of CompositeSignatures to verify\");\n    invariant(compSigs.map(cs => cs.addr).every((addr, i, arr) => addr === arr[0]), \"User signatures to be verified must be from a single account address\");\n    return true;\n  }\n};\n\n// TODO: pass in option for contract but we're connected to testnet\n// log address + network -> in sync?\nconst getVerifySignaturesScript = async (sig, opts) => {\n  const verifyFunction = sig === \"ACCOUNT_PROOF\" ? \"verifyAccountProofSignatures\" : \"verifyUserSignatures\";\n  let network = await getChainId();\n  let fclCryptoContract;\n  invariant(opts.fclCryptoContract || network === \"testnet\" || network === \"mainnet\", \"${verifyFunction}({ fclCryptoContract }) -- config.flow.network must be specified (testnet || mainnet) or contract address provided via opts.fclCryptoContract\");\n  if (opts.fclCryptoContract) {\n    fclCryptoContract = opts.fclCryptoContract;\n  } else {\n    fclCryptoContract = network === \"testnet\" ? \"0x74daa6f9c7ef24b1\" : \"0xb4b82a1c9d21d284\";\n  }\n  return `\n      import FCLCrypto from ${fclCryptoContract}\n\n      pub fun main(\n          address: Address, \n          message: String, \n          keyIndices: [Int], \n          signatures: [String]\n      ): Bool {\n        return FCLCrypto.${verifyFunction}(address: address, message: message, keyIndices: keyIndices, signatures: signatures)\n      }\n    `;\n};\n\n/**\n * @description\n * Verify a valid account proof signature or signatures for an account on Flow.\n *\n * @param {string} appIdentifier - A message string in hexadecimal format\n * @param {object} accountProofData - An object consisting of address, nonce, and signatures\n * @param {string} accountProofData.address - A Flow account address\n * @param {string} accountProofData.nonce - A random string in hexadecimal format (minimum 32 bytes in total, i.e 64 hex characters)\n * @param {object[]} accountProofData.signatures - An array of composite signatures to verify\n * @param {object} [opts={}] - Options object\n * @param {string} opts.fclCryptoContract - An optional override Flow account address where the FCLCrypto contract is deployed\n * @returns {Promise<boolean>} - Returns true if the signature is valid, false otherwise\n *\n * @example\n *\n *  const accountProofData = {\n *   address: \"0x123\",\n *   nonce: \"F0123\"\n *   signatures: [{f_type: \"CompositeSignature\", f_vsn: \"1.0.0\", addr: \"0x123\", keyId: 0, signature: \"abc123\"}],\n *  }\n *\n *  const isValid = await fcl.AppUtils.verifyAccountProof(\n *    \"AwesomeAppId\",\n *    accountProofData,\n *    {fclCryptoContract}\n *  )\n */\nasync function verifyAccountProof(appIdentifier, _ref) {\n  let {\n    address,\n    nonce,\n    signatures\n  } = _ref;\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  validateArgs({\n    appIdentifier,\n    address,\n    nonce,\n    signatures\n  });\n  const message = encodeAccountProof({\n    address,\n    nonce,\n    appIdentifier\n  }, false);\n  let signaturesArr = [];\n  let keyIndices = [];\n  for (const el of signatures) {\n    signaturesArr.push(el.signature);\n    keyIndices.push(el.keyId.toString());\n  }\n  return query({\n    cadence: await getVerifySignaturesScript(ACCOUNT_PROOF, opts),\n    args: (arg, t) => [arg(withPrefix(address), t.Address), arg(message, t.String), arg(keyIndices, t.Array(t.Int)), arg(signaturesArr, t.Array(t.String))]\n  });\n}\n\n/**\n * @description\n * Verify a valid signature/s for an account on Flow.\n *\n * @param {string} message - A message string in hexadecimal format\n * @param {Array} compSigs - An array of Composite Signatures\n * @param {string} compSigs[].addr - The account address\n * @param {number} compSigs[].keyId - The account keyId\n * @param {string} compSigs[].signature - The signature to verify\n * @param {object} [opts={}] - Options object\n * @param {string} opts.fclCryptoContract - An optional override of Flow account address where the FCLCrypto contract is deployed\n * @returns {boolean} - Returns true if the signature is valid, false otherwise\n *\n * @example\n *\n *  const isValid = await fcl.AppUtils.verifyUserSignatures(\n *    Buffer.from('FOO').toString(\"hex\"),\n *    [{f_type: \"CompositeSignature\", f_vsn: \"1.0.0\", addr: \"0x123\", keyId: 0, signature: \"abc123\"}],\n *    {fclCryptoContract}\n *  )\n */\nasync function verifyUserSignatures$1(message, compSigs) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const address = withPrefix(compSigs[0].addr);\n  validateArgs({\n    message,\n    address,\n    compSigs\n  });\n  let signaturesArr = [];\n  let keyIndices = [];\n  for (const el of compSigs) {\n    signaturesArr.push(el.signature);\n    keyIndices.push(el.keyId.toString());\n  }\n  return query({\n    cadence: await getVerifySignaturesScript(USER_SIGNATURE, opts),\n    args: (arg, t) => [arg(address, t.Address), arg(message, t.String), arg(keyIndices, t.Array(t.Int)), arg(signaturesArr, t.Array(t.String))]\n  });\n}\n\nvar index$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  verifyAccountProof: verifyAccountProof,\n  verifyUserSignatures: verifyUserSignatures$1\n});\n\n/**\n * Verify a valid signature/s for an account on Flow.\n *\n * @deprecated since version '1.0.0-alpha.0', use AppUtils.verifyUserSignatures instead\n *\n */\nconst verifyUserSignatures = log.deprecate({\n  pkg: \"FCL\",\n  subject: \"fcl.verifyUserSignatures()\",\n  message: \"Please use fcl.AppUtils.verifyUserSignatures()\",\n  callback: function verifyUserSignatures(message, compSigs) {\n    return verifyUserSignatures$1(message, compSigs);\n  }\n});\n\nconst serialize = async function () {\n  let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const resolveFunction = await config$1.first([\"sdk.resolve\"], opts.resolve || resolve);\n  if (Array.isArray(args)) args = await pipe(interaction(), args);\n  return JSON.stringify(createSignableVoucher(await resolveFunction(args)), null, 2);\n};\n\n/**\n * @typedef {import(\"@onflow/typedefs\").Transaction} Transaction\n */\n\n/**\n * @typedef {import(\"@onflow/typedefs\").TransactionStatus} TransactionStatus\n */\n\nconst RATE$1 = 2500;\nconst POLL = \"POLL\";\nconst fetchTxStatus = async transactionId => {\n  return send$1([getTransactionStatus(transactionId)]).then(decode);\n};\nconst isExpired = tx => tx.status === 5;\nconst isSealed = tx => tx.status >= 4;\nconst isExecuted = tx => tx.status >= 3;\nconst isFinalized = tx => tx.status >= 2;\nconst isPending = tx => tx.status >= 1;\nconst isUnknown = tx => tx.status >= 0;\nconst isDiff = (cur, next) => {\n  return JSON.stringify(cur) !== JSON.stringify(next);\n};\nconst HANDLERS$1 = {\n  [INIT]: async ctx => {\n    ctx.sendSelf(POLL);\n  },\n  [SUBSCRIBE]: (ctx, letter) => {\n    ctx.subscribe(letter.from);\n    ctx.send(letter.from, UPDATED$2, ctx.all());\n  },\n  [UNSUBSCRIBE]: (ctx, letter) => {\n    ctx.unsubscribe(letter.from);\n  },\n  [SNAPSHOT$1]: async (ctx, letter) => {\n    letter.reply(ctx.all());\n  },\n  [POLL]: async ctx => {\n    let tx;\n    try {\n      tx = await fetchTxStatus(ctx.self());\n    } catch (e) {\n      return ctx.fatalError(e);\n    }\n    if (!isSealed(tx)) setTimeout(() => ctx.sendSelf(POLL), RATE$1);\n    if (isDiff(ctx.all(), tx)) ctx.broadcast(UPDATED$2, tx);\n    ctx.merge(tx);\n  }\n};\nconst scoped = transactionId => {\n  if (typeof transactionId === \"object\") transactionId = transactionId.transactionId;\n  if (transactionId == null) throw new Error(\"transactionId required\");\n  return transactionId;\n};\nconst spawnTransaction = transactionId => {\n  return spawn(HANDLERS$1, scoped(transactionId));\n};\n\n/**\n * @callback SubscriptionCallback\n * @param {TransactionStatus} txStatus\n * @returns {void}\n */\n\n/**\n * Provides methods for interacting with a transaction\n * \n * @param {string} transactionId - The transaction ID\n * @returns {{\n *    snapshot: function(): Promise<TransactionStatus>,\n *    subscribe: function(SubscriptionCallback): function(): void,\n *    onceFinalized: function(): Promise<TransactionStatus>,\n *    onceExecuted: function(): Promise<TransactionStatus>,\n *    onceSealed: function(): Promise<TransactionStatus>\n * }}\n */\nfunction transaction(transactionId) {\n  function snapshot() {\n    return snapshoter(transactionId, spawnTransaction);\n  }\n  function subscribe(callback) {\n    return subscriber(scoped(transactionId), spawnTransaction, callback);\n  }\n  function once(predicate) {\n    return function innerOnce() {\n      let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      const suppress = opts.suppress || false;\n      return new Promise((resolve, reject) => {\n        const unsub = subscribe((txStatus, error) => {\n          if ((error || txStatus.statusCode) && !suppress) {\n            reject(error || txStatus.errorMessage);\n            unsub();\n          } else if (predicate(txStatus)) {\n            resolve(txStatus);\n            unsub();\n          }\n        });\n      });\n    };\n  }\n  return {\n    snapshot,\n    subscribe,\n    onceFinalized: once(isFinalized),\n    onceExecuted: once(isExecuted),\n    onceSealed: once(isSealed)\n  };\n}\ntransaction.isUnknown = isUnknown;\ntransaction.isPending = isPending;\ntransaction.isFinalized = isFinalized;\ntransaction.isExecuted = isExecuted;\ntransaction.isSealed = isSealed;\ntransaction.isExpired = isExpired;\n\nconst RATE = 10000;\nconst UPDATED = \"UPDATED\";\nconst TICK = \"TICK\";\nconst HIGH_WATER_MARK = \"hwm\";\nconst scheduleTick = async ctx => {\n  return setTimeout(() => ctx.sendSelf(TICK), await config$1().get(\"fcl.eventPollRate\", RATE));\n};\nconst HANDLERS = {\n  [TICK]: async ctx => {\n    if (!ctx.hasSubs()) return;\n    let hwm = ctx.get(HIGH_WATER_MARK);\n    if (hwm == null) {\n      ctx.put(HIGH_WATER_MARK, await block());\n      ctx.put(TICK, await scheduleTick(ctx));\n    } else {\n      let next = await block();\n      ctx.put(HIGH_WATER_MARK, next);\n      if (hwm.height < next.height) {\n        const data = await send$1([getEventsAtBlockHeightRange(ctx.self(), hwm.height + 1, next.height)]).then(decode);\n        for (let d of data) ctx.broadcast(UPDATED, d.data);\n      }\n      ctx.put(TICK, await scheduleTick(ctx));\n    }\n  },\n  [SUBSCRIBE]: async (ctx, letter) => {\n    if (!ctx.hasSubs()) {\n      ctx.put(TICK, await scheduleTick(ctx));\n    }\n    ctx.subscribe(letter.from);\n  },\n  [UNSUBSCRIBE]: (ctx, letter) => {\n    ctx.unsubscribe(letter.from);\n    if (!ctx.hasSubs()) {\n      clearTimeout(ctx.get(TICK));\n      ctx.delete(TICK);\n      ctx.delete(HIGH_WATER_MARK);\n    }\n  }\n};\nconst spawnEvents = key => spawn(HANDLERS, key);\n\n/**\n * @typedef {import(\"@onflow/typedefs\").Event} Event\n */\n\n/**\n * @typedef {object} SubscribeObject\n * @property {Function} subscribe - The subscribe function.\n */\n\n/**\n * @callback SubscriptionCallback\n * @returns {Event}\n */\n\n/**\n * @description - Subscribe to events\n * @param {string} key - A valid event name\n * @returns {SubscribeObject}\n * \n * @example\n * import * as fcl from \"@blocto/fcl\"\n * fcl.events(eventName).subscribe((event) => console.log(event))\n */\nfunction events(key) {\n  return {\n    /**\n     * @description - Subscribe to events\n     * @param {Function} callback - The callback function\n     * @returns {SubscriptionCallback}\n     */\n    subscribe: callback => subscriber(key, spawnEvents, callback)\n  };\n}\n\nvar sha3 = {};\n\nvar sponge = {};\n\nvar permute = {};\n\nvar chi = {};\n\nvar copy = function copy(I, i) {\n  return function (O, o) {\n    var oi = o * 2;\n    var ii = i * 2;\n    O[oi] = I[ii];\n    O[oi + 1] = I[ii + 1];\n  };\n};\nvar copy_1 = copy;\n\n(function (exports) {\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports[\"default\"] = void 0;\n  var _copy = _interopRequireDefault(copy_1);\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      \"default\": obj\n    };\n  }\n  var chi = function chi(_ref) {\n    var A = _ref.A,\n      C = _ref.C;\n    for (var y = 0; y < 25; y += 5) {\n      for (var x = 0; x < 5; x++) {\n        (0, _copy[\"default\"])(A, y + x)(C, x);\n      }\n      for (var _x = 0; _x < 5; _x++) {\n        var xy = (y + _x) * 2;\n        var x1 = (_x + 1) % 5 * 2;\n        var x2 = (_x + 2) % 5 * 2;\n        A[xy] ^= ~C[x1] & C[x2];\n        A[xy + 1] ^= ~C[x1 + 1] & C[x2 + 1];\n      }\n    }\n  };\n  var _default = chi;\n  exports[\"default\"] = _default;\n})(chi);\n\nvar iota = {};\n\nvar roundConstants = {};\n\n(function (exports) {\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports[\"default\"] = void 0;\n  var ROUND_CONSTANTS = new Uint32Array([0, 1, 0, 32898, 2147483648, 32906, 2147483648, 2147516416, 0, 32907, 0, 2147483649, 2147483648, 2147516545, 2147483648, 32777, 0, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 2147483648, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 0, 32778, 2147483648, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 0, 2147483649, 2147483648, 2147516424]);\n  var _default = ROUND_CONSTANTS;\n  exports[\"default\"] = _default;\n})(roundConstants);\n\n(function (exports) {\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports[\"default\"] = void 0;\n  var _roundConstants = _interopRequireDefault(roundConstants);\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      \"default\": obj\n    };\n  }\n  var iota = function iota(_ref) {\n    var A = _ref.A,\n      roundIndex = _ref.roundIndex;\n    var i = roundIndex * 2;\n    A[0] ^= _roundConstants[\"default\"][i];\n    A[1] ^= _roundConstants[\"default\"][i + 1];\n  };\n  var _default = iota;\n  exports[\"default\"] = _default;\n})(iota);\n\nvar rhoPi = {};\n\nvar piShuffles = {};\n\n(function (exports) {\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports[\"default\"] = void 0;\n  var PI_SHUFFLES = [10, 7, 11, 17, 18, 3, 5, 16, 8, 21, 24, 4, 15, 23, 19, 13, 12, 2, 20, 14, 22, 9, 6, 1];\n  var _default = PI_SHUFFLES;\n  exports[\"default\"] = _default;\n})(piShuffles);\n\nvar rhoOffsets = {};\n\n(function (exports) {\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports[\"default\"] = void 0;\n  var RHO_OFFSETS = [1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 2, 14, 27, 41, 56, 8, 25, 43, 62, 18, 39, 61, 20, 44];\n  var _default = RHO_OFFSETS;\n  exports[\"default\"] = _default;\n})(rhoOffsets);\n\n(function (exports) {\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports[\"default\"] = void 0;\n  var _piShuffles = _interopRequireDefault(piShuffles);\n  var _rhoOffsets = _interopRequireDefault(rhoOffsets);\n  var _copy = _interopRequireDefault(copy_1);\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      \"default\": obj\n    };\n  }\n  var rhoPi = function rhoPi(_ref) {\n    var A = _ref.A,\n      C = _ref.C,\n      W = _ref.W;\n    (0, _copy[\"default\"])(A, 1)(W, 0);\n    var H = 0;\n    var L = 0;\n    var Wi = 0;\n    var ri = 32;\n    for (var i = 0; i < 24; i++) {\n      var j = _piShuffles[\"default\"][i];\n      var r = _rhoOffsets[\"default\"][i];\n      (0, _copy[\"default\"])(A, j)(C, 0);\n      H = W[0];\n      L = W[1];\n      ri = 32 - r;\n      Wi = r < 32 ? 0 : 1;\n      W[Wi] = H << r | L >>> ri;\n      W[(Wi + 1) % 2] = L << r | H >>> ri;\n      (0, _copy[\"default\"])(W, 0)(A, j);\n      (0, _copy[\"default\"])(C, 0)(W, 0);\n    }\n  };\n  var _default = rhoPi;\n  exports[\"default\"] = _default;\n})(rhoPi);\n\nvar theta = {};\n\n(function (exports) {\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports[\"default\"] = void 0;\n  var _copy = _interopRequireDefault(copy_1);\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      \"default\": obj\n    };\n  }\n  var theta = function theta(_ref) {\n    var A = _ref.A,\n      C = _ref.C,\n      D = _ref.D,\n      W = _ref.W;\n    var H = 0;\n    var L = 0;\n    for (var x = 0; x < 5; x++) {\n      var x20 = x * 2;\n      var x21 = (x + 5) * 2;\n      var x22 = (x + 10) * 2;\n      var x23 = (x + 15) * 2;\n      var x24 = (x + 20) * 2;\n      C[x20] = A[x20] ^ A[x21] ^ A[x22] ^ A[x23] ^ A[x24];\n      C[x20 + 1] = A[x20 + 1] ^ A[x21 + 1] ^ A[x22 + 1] ^ A[x23 + 1] ^ A[x24 + 1];\n    }\n    for (var _x = 0; _x < 5; _x++) {\n      (0, _copy[\"default\"])(C, (_x + 1) % 5)(W, 0);\n      H = W[0];\n      L = W[1];\n      W[0] = H << 1 | L >>> 31;\n      W[1] = L << 1 | H >>> 31;\n      D[_x * 2] = C[(_x + 4) % 5 * 2] ^ W[0];\n      D[_x * 2 + 1] = C[(_x + 4) % 5 * 2 + 1] ^ W[1];\n      for (var y = 0; y < 25; y += 5) {\n        A[(y + _x) * 2] ^= D[_x * 2];\n        A[(y + _x) * 2 + 1] ^= D[_x * 2 + 1];\n      }\n    }\n  };\n  var _default = theta;\n  exports[\"default\"] = _default;\n})(theta);\n\n(function (exports) {\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports[\"default\"] = void 0;\n  var _chi = _interopRequireDefault(chi);\n  var _iota = _interopRequireDefault(iota);\n  var _rhoPi = _interopRequireDefault(rhoPi);\n  var _theta = _interopRequireDefault(theta);\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      \"default\": obj\n    };\n  }\n  var permute = function permute() {\n    var C = new Uint32Array(10);\n    var D = new Uint32Array(10);\n    var W = new Uint32Array(2);\n    return function (A) {\n      for (var roundIndex = 0; roundIndex < 24; roundIndex++) {\n        (0, _theta[\"default\"])({\n          A: A,\n          C: C,\n          D: D,\n          W: W\n        });\n        (0, _rhoPi[\"default\"])({\n          A: A,\n          C: C,\n          W: W\n        });\n        (0, _chi[\"default\"])({\n          A: A,\n          C: C\n        });\n        (0, _iota[\"default\"])({\n          A: A,\n          roundIndex: roundIndex\n        });\n      }\n      C.fill(0);\n      D.fill(0);\n      W.fill(0);\n    };\n  };\n  var _default = permute;\n  exports[\"default\"] = _default;\n})(permute);\n\n(function (exports) {\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports[\"default\"] = void 0;\n  var _buffer = require$$0;\n  var _permute = _interopRequireDefault(permute);\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      \"default\": obj\n    };\n  }\n  var xorWords = function xorWords(I, O) {\n    for (var i = 0; i < I.length; i += 8) {\n      var o = i / 4;\n      O[o] ^= I[i + 7] << 24 | I[i + 6] << 16 | I[i + 5] << 8 | I[i + 4];\n      O[o + 1] ^= I[i + 3] << 24 | I[i + 2] << 16 | I[i + 1] << 8 | I[i];\n    }\n    return O;\n  };\n  var readWords = function readWords(I, O) {\n    for (var o = 0; o < O.length; o += 8) {\n      var i = o / 4;\n      O[o] = I[i + 1];\n      O[o + 1] = I[i + 1] >>> 8;\n      O[o + 2] = I[i + 1] >>> 16;\n      O[o + 3] = I[i + 1] >>> 24;\n      O[o + 4] = I[i];\n      O[o + 5] = I[i] >>> 8;\n      O[o + 6] = I[i] >>> 16;\n      O[o + 7] = I[i] >>> 24;\n    }\n    return O;\n  };\n  var Sponge = function Sponge(_ref) {\n    var _this = this;\n    var capacity = _ref.capacity,\n      padding = _ref.padding;\n    var keccak = (0, _permute[\"default\"])();\n    var stateSize = 200;\n    var blockSize = capacity / 8;\n    var queueSize = stateSize - capacity / 4;\n    var queueOffset = 0;\n    var state = new Uint32Array(stateSize / 4);\n    var queue = _buffer.Buffer.allocUnsafe(queueSize);\n    this.absorb = function (buffer) {\n      for (var i = 0; i < buffer.length; i++) {\n        queue[queueOffset] = buffer[i];\n        queueOffset += 1;\n        if (queueOffset >= queueSize) {\n          xorWords(queue, state);\n          keccak(state);\n          queueOffset = 0;\n        }\n      }\n      return _this;\n    };\n    this.squeeze = function () {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var output = {\n        buffer: options.buffer || _buffer.Buffer.allocUnsafe(blockSize),\n        padding: options.padding || padding,\n        queue: _buffer.Buffer.allocUnsafe(queue.length),\n        state: new Uint32Array(state.length)\n      };\n      queue.copy(output.queue);\n      for (var i = 0; i < state.length; i++) {\n        output.state[i] = state[i];\n      }\n      output.queue.fill(0, queueOffset);\n      output.queue[queueOffset] |= output.padding;\n      output.queue[queueSize - 1] |= 128;\n      xorWords(output.queue, output.state);\n      for (var offset = 0; offset < output.buffer.length; offset += queueSize) {\n        keccak(output.state);\n        readWords(output.state, output.buffer.slice(offset, offset + queueSize));\n      }\n      return output.buffer;\n    };\n    this.reset = function () {\n      queue.fill(0);\n      state.fill(0);\n      queueOffset = 0;\n      return _this;\n    };\n    return this;\n  };\n  var _default = Sponge;\n  exports[\"default\"] = _default;\n})(sponge);\n\n(function (exports) {\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports[\"default\"] = exports.SHAKE = exports.SHA3Hash = exports.SHA3 = exports.Keccak = void 0;\n  var _buffer = require$$0;\n  var _sponge = _interopRequireDefault(sponge);\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      \"default\": obj\n    };\n  }\n  var createHash = function createHash(_ref) {\n    var allowedSizes = _ref.allowedSizes,\n      defaultSize = _ref.defaultSize,\n      padding = _ref.padding;\n    return function Hash() {\n      var _this = this;\n      var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultSize;\n      if (!this || this.constructor !== Hash) {\n        return new Hash(size);\n      }\n      if (allowedSizes && !allowedSizes.includes(size)) {\n        throw new Error(\"Unsupported hash length\");\n      }\n      var sponge = new _sponge[\"default\"]({\n        capacity: size\n      });\n      this.update = function (input) {\n        var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"utf8\";\n        if (_buffer.Buffer.isBuffer(input)) {\n          sponge.absorb(input);\n          return _this;\n        }\n        if (typeof input === \"string\") {\n          return _this.update(_buffer.Buffer.from(input, encoding));\n        }\n        throw new TypeError(\"Not a string or buffer\");\n      };\n      this.digest = function () {\n        var formatOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"binary\";\n        var options = typeof formatOrOptions === \"string\" ? {\n          format: formatOrOptions\n        } : formatOrOptions;\n        var buffer = sponge.squeeze({\n          buffer: options.buffer,\n          padding: options.padding || padding\n        });\n        if (options.format && options.format !== \"binary\") {\n          return buffer.toString(options.format);\n        }\n        return buffer;\n      };\n      this.reset = function () {\n        sponge.reset();\n        return _this;\n      };\n      return this;\n    };\n  };\n  var Keccak = createHash({\n    allowedSizes: [224, 256, 384, 512],\n    defaultSize: 512,\n    padding: 1\n  });\n  exports.Keccak = Keccak;\n  var SHA3 = createHash({\n    allowedSizes: [224, 256, 384, 512],\n    defaultSize: 512,\n    padding: 6\n  });\n  exports.SHA3 = SHA3;\n  var SHAKE = createHash({\n    allowedSizes: [128, 256],\n    defaultSize: 256,\n    padding: 31\n  });\n  exports.SHAKE = SHAKE;\n  var SHA3Hash = Keccak;\n  exports.SHA3Hash = SHA3Hash;\n  SHA3.SHA3Hash = SHA3Hash;\n  var _default = SHA3;\n  exports[\"default\"] = _default;\n})(sha3);\n\nasync function genHash(utf8String) {\n  const sha = new sha3.SHA3(256);\n  sha.update(Buffer.from(utf8String, \"utf8\"));\n  return sha.digest(\"hex\");\n}\n\n/**\n * @description Generates Interaction Template ID for a given Interaction Template\n *  \n * @param {object} params\n * @param {object} params.template - Interaction Template\n * @returns {Promise<string>} - Interaction Template ID\n */\nasync function generateTemplateId(_ref) {\n  let {\n    template\n  } = _ref;\n  invariant$1(template != undefined, \"generateTemplateId({ template }) -- template must be defined\");\n  invariant$1(typeof template === \"object\", \"generateTemplateId({ template }) -- template must be an object\");\n  invariant$1(typeof template.f_type === \"InteractionTemplate\", \"generateTemplateId({ template }) -- template object must be an InteractionTemplate\");\n  template = normalizeInteractionTemplate(template);\n  switch (template.f_version) {\n    case \"1.0.0\":\n      const templateData = template.data;\n      const messages = await Promise.all(Object.keys(templateData.messages).map(async messageKey => [await genHash(messageKey), await Promise.all(Object.keys(templateData.messages?.[messageKey]?.i18n).map(async i18nkeylanguage => [await genHash(i18nkeylanguage), await genHash(templateData.messages?.[messageKey]?.i18n?.[i18nkeylanguage])]))]));\n      const dependencies = await Promise.all(Object.keys(templateData?.dependencies).map(async dependencyAddressPlaceholder => [await genHash(dependencyAddressPlaceholder), await Promise.all(Object.keys(templateData?.dependencies?.[dependencyAddressPlaceholder]).map(async dependencyContract => [await genHash(dependencyContract), await Promise.all(Object.keys(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]).map(async dependencyContractNetwork => [await genHash(dependencyContractNetwork), [await genHash(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]?.[dependencyContractNetwork].address), await genHash(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]?.[dependencyContractNetwork].contract), await genHash(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]?.[dependencyContractNetwork].fq_address), await genHash(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]?.[dependencyContractNetwork].pin), await genHash(String(templateData?.dependencies?.[dependencyAddressPlaceholder]?.[dependencyContract]?.[dependencyContractNetwork].pin_block_height))]]))]))]));\n      const _arguments = await Promise.all(Object.keys(templateData?.[\"arguments\"]).map(async argumentLabel => [await genHash(argumentLabel), [await genHash(String(templateData?.[\"arguments\"]?.[argumentLabel].index)), await genHash(templateData?.[\"arguments\"]?.[argumentLabel].type), await genHash(templateData?.[\"arguments\"]?.[argumentLabel].balance || \"\"), await Promise.all(Object.keys(templateData?.[\"arguments\"]?.[argumentLabel].messages).map(async argumentMessageKey => [await genHash(argumentMessageKey), await Promise.all(Object.keys(templateData?.[\"arguments\"]?.[argumentLabel].messages?.[argumentMessageKey].i18n).map(async i18nkeylanguage => [await genHash(i18nkeylanguage), await genHash(templateData?.[\"arguments\"]?.[argumentLabel].messages?.[argumentMessageKey].i18n?.[i18nkeylanguage])]))]))]]));\n      const encodedHex = encode([await genHash(\"InteractionTemplate\"), await genHash(\"1.0.0\"), await genHash(templateData?.type), await genHash(templateData?.interface), messages, await genHash(templateData?.cadence), dependencies, _arguments]).toString(\"hex\");\n      return genHash(encodedHex);\n    default:\n      throw new Error(\"generateTemplateId Error: Unsupported template version\");\n  }\n}\n\n/**\n * @description Returns whether a set of auditors have audited a given Interaction Template\n * \n * @param {object} params\n * @param {object} params.template - Interaction Template\n * @param {Array<string>} params.auditors - Array of auditors\n * @param {object} opts\n * @param {string} opts.flowInteractionAuditContract - Flow Interaction Template Audit contract address\n * @returns {Promise<object>} - Object of auditor addresses and audit status\n */\nasync function getInteractionTemplateAudits(_ref) {\n  let {\n    template,\n    auditors\n  } = _ref;\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  invariant$1(template != undefined, \"getInteractionTemplateAudits({ template }) -- template must be defined\");\n  template = normalizeInteractionTemplate(template);\n  invariant$1(template.f_type === \"InteractionTemplate\", \"getInteractionTemplateAudits({ template }) -- template must be an InteractionTemplate\");\n\n  // Recompute ID to be sure it matches\n  let recomputedTemplateID = await generateTemplateId({\n    template\n  });\n  if (recomputedTemplateID !== template.id) {\n    log({\n      title: \"getInteractionTemplateAudits Debug Error\",\n      message: `Could not recompute and match template ID\n                computed: ${recomputedTemplateID}\n                template: ${template.id}\n            `,\n      level: LEVELS.debug\n    });\n    throw new Error(\"getInteractionTemplateAudits Error: Could not recompute and match template ID\");\n  }\n  switch (template.f_version) {\n    case \"1.0.0\":\n      const _auditors = auditors || (await config$1().get(\"flow.auditors\"));\n      invariant$1(_auditors, \"getInteractionTemplateAudits Error: Required configuration for 'fcl.auditors' is not set\");\n      invariant$1(Array.isArray(_auditors), \"getInteractionTemplateAudits Error: Required configuration for 'fcl.auditors' is not an array\");\n      let FlowInteractionAuditContract = opts.flowInteractionAuditContract;\n      if (!FlowInteractionAuditContract) {\n        const fclNetwork = await getChainId();\n        invariant$1(fclNetwork === \"mainnet\" || fclNetwork === \"testnet\", \"getInteractionTemplateAudits Error: Unable to determine address for FlowInteractionTemplateAudit contract. Set configuration for 'fcl.network' to 'mainnet' or 'testnet'\");\n        if (fclNetwork === \"mainnet\") {\n          FlowInteractionAuditContract = \"0xfd100e39d50a13e6\";\n        } else {\n          FlowInteractionAuditContract = \"0xf78bfc12d0a786dc\";\n        }\n      }\n      const audits = await query({\n        cadence: `\n        import FlowInteractionTemplateAudit from ${FlowInteractionAuditContract}\n        pub fun main(templateId: String, auditors: [Address]): {Address:Bool} {\n          return FlowInteractionTemplateAudit.getHasTemplateBeenAuditedByAuditors(templateId: templateId, auditors: auditors)\n        }\n        `,\n        args: (arg, t) => [arg(recomputedTemplateID, t.String), arg(_auditors, t.Array(t.Address))]\n      });\n      return audits;\n    default:\n      throw new Error(\"getInteractionTemplateAudits Error: Unsupported template version\");\n  }\n}\n\nfunction generateImport(_ref) {\n  let {\n    contractName,\n    address\n  } = _ref;\n  return {\n    contractName,\n    address,\n    contract: \"\"\n  };\n}\n\nfunction findImports(cadence) {\n  let imports = [];\n  let importsReg = /import ((\\w|,| )+)* from 0x\\w+/g;\n  let fileImports = cadence.match(importsReg) || [];\n  for (const fileImport of fileImports) {\n    const importLineReg = /import ((\\w+|, |)*) from (0x\\w+)/g;\n    const importLine = importLineReg.exec(fileImport);\n    const contractsReg = /((?:\\w+)+),?/g;\n    const contracts = importLine[1].match(contractsReg) || [];\n    for (const contract of contracts) {\n      imports.push(generateImport({\n        address: importLine[3],\n        contractName: contract.replace(/,/g, \"\")\n      }));\n    }\n  }\n  return imports;\n}\n\n/**\n * @description Produces a dependency pin for a contract at a given block height\n * @param {object} params\n * @param {string} params.address - The address of the account containing the contract\n * @param {string} params.contractName - The name of the contract\n * @param {number} params.blockHeight - The block height to produce the dependency pin for\n * @param {object} opts - Options to pass to the interaction\n * @returns {Promise<string>} - The dependency pin\n */\nasync function generateDependencyPin(_ref) {\n  let {\n    address,\n    contractName,\n    blockHeight\n  } = _ref;\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  invariant$1(address != undefined, \"generateDependencyPin({ address }) -- address must be defined\");\n  invariant$1(contractName != undefined, \"generateDependencyPin({ contractName }) -- contractName must be defined\");\n  invariant$1(blockHeight != undefined, \"generateDependencyPin({ blockHeight }) -- blockHeight must be defined\");\n  invariant$1(typeof address === \"string\", \"generateDependencyPin({ address }) -- address must be a string\");\n  invariant$1(typeof contractName === \"string\", \"generateDependencyPin({ contractName }) -- contractName must be a string\");\n  invariant$1(typeof blockHeight === \"number\", \"generateDependencyPin({ blockHeight }) -- blockHeight must be a number\");\n  let horizon = [generateImport({\n    contractName,\n    address\n  })];\n  for (const horizonImport of horizon) {\n    let account = await send$1([getAccount(await config$1().get(horizonImport.address, horizonImport.address)), atBlockHeight(blockHeight)], opts).then(decode);\n    horizonImport.contract = account.contracts?.[horizonImport.contractName];\n    if (!horizonImport.contract) {\n      console.error(\"Did not find expected contract\", horizonImport, account);\n      throw new Error(\"Did not find expected contract\");\n    }\n    let contractImports = findImports(horizonImport.contract);\n    horizon.push(...contractImports);\n  }\n  let contractHashes = horizon.map(iport => genHash(iport.contract));\n  let contractHashesJoined = contractHashes.join(\"\");\n  return genHash(contractHashesJoined);\n}\n\n/**\n * @description Produces a dependency pin for a contract at latest sealed block\n * @param {object} params\n * @param {string} params.address - The address of the account containing the contract\n * @param {string} params.contractName - The name of the contract\n * @param {object} opts - Options to pass to the interaction\n * @returns {Promise<string>} - The dependency pin\n */\nasync function generateDependencyPinAtLatestSealedBlock(_ref2) {\n  let {\n    address,\n    contractName\n  } = _ref2;\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let latestSealedBlock = await block({\n    sealed: true\n  }, opts);\n  let latestSealedBlockHeight = latestSealedBlock?.height;\n  return generateDependencyPin({\n    address,\n    contractName,\n    blockHeight: latestSealedBlockHeight\n  }, opts);\n}\n\nfunction normalizeInteractionTemplateInterface(templateInterface) {\n  if (templateInterface == null) return null;\n  switch (templateInterface[\"f_version\"]) {\n    case \"1.0.0\":\n      return templateInterface;\n    default:\n      throw new Error(\"normalizeInteractionTemplateInterface Error: Invalid InteractionTemplateInterface\");\n  }\n}\n\n/**\n * @description Generates Interaction Template Interface ID for a given Interaction Template Interface\n * \n * @param {object} params\n * @param {object} params.templateInterface - Interaction Template Interface\n * @returns {Promise<string>} - Interaction Template Interface ID\n */\nasync function generateTemplateInterfaceId(_ref) {\n  let {\n    templateInterface\n  } = _ref;\n  invariant$1(templateInterface != undefined, \"generateTemplateInterfaceId({ templateInterface }) -- templateInterface must be defined\");\n  invariant$1(typeof templateInterface === \"object\", \"generateTemplateInterfaceId({ templateInterface }) -- templateInterface must be an object\");\n  invariant$1(typeof templateInterface.f_type === \"InteractionTemplateInterface\", \"generateTemplateInterfaceId({ templateInterface }) -- templateInterface object must be an InteractionTemplate\");\n  templateInterface = normalizeInteractionTemplateInterface(templateInterface);\n  switch (templateInterface.f_version) {\n    case \"1.0.0\":\n      const interfaceData = templateInterface.data;\n      const encodedHex = encode([await genHash(\"InteractionTemplateInterface\"), await genHash(\"1.0.0\"), await genHash(interfaceData.flip), await Promise.all(Object.keys(interfaceData.arguments).map(async argumentLabel => [await genHash(argumentLabel), await genHash(String(interfaceData.arguments[argumentLabel].index)), await genHash(interfaceData.arguments[argumentLabel].type)]))]).toString(\"hex\");\n      return genHash(encodedHex);\n    default:\n      throw new Error(\"generateTemplateInterfaceId Error: Unsupported templateInterface version\");\n  }\n}\n\n/**\n * @description Checks if an Interaction Template's pins match those generated at a block height\n * \n * @param {object} params\n * @param {object} params.template - Interaction Template to check pins for\n * @param {number} params.blockHeight - Block height to check pins at\n * @param {string} params.network - Network to check pins on\n * @param {object} opts\n * @returns {Promise<boolean>} - Whether or not the pins match\n */\nasync function verifyDependencyPinsSame(_ref) {\n  let {\n    template,\n    blockHeight,\n    network\n  } = _ref;\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  invariant$1(template != undefined, \"generateDependencyPin({ template }) -- template must be defined\");\n  invariant$1(typeof template === \"object\", \"generateDependencyPin({ template }) -- template must be an object\");\n  invariant$1(template.f_type === \"InteractionTemplate\", \"generateDependencyPin({ template }) -- template must be an InteractionTemplate\");\n  template = normalizeInteractionTemplate(template);\n  invariant$1(network != undefined, \"generateDependencyPin({ network }) network must be defined\");\n  invariant$1(blockHeight != undefined, \"generateDependencyPin({ blockHeight }) blockHeight must be defined\");\n  invariant$1(typeof blockHeight === \"number\", \"generateDependencyPin({ blockHeight }) blockHeight must be a number\");\n  switch (template.f_version) {\n    case \"1.0.0\":\n      let templateDependenciesPlaceholderKeys = Object.keys(template.data.dependencies);\n      for (let templateDependencyPlaceholderKey of templateDependenciesPlaceholderKeys) {\n        let templateDependencyPlaceholder = template.data.dependencies[templateDependencyPlaceholderKey];\n        let templateDependencyPlaceholderContractNames = Object.keys(templateDependencyPlaceholder);\n        for (let templateDependencyPlaceholderContractName of templateDependencyPlaceholderContractNames) {\n          let templateDependencyPlaceholderContractNetworks = template.data.dependencies[templateDependencyPlaceholderKey][templateDependencyPlaceholderContractName];\n          let templateDependency = templateDependencyPlaceholderContractNetworks[network];\n          if (typeof templateDependency === \"undefined\") continue;\n          let pin = await generateDependencyPin({\n            address: templateDependency.address,\n            contractName: templateDependency.contract,\n            blockHeight\n          }, opts);\n          if (pin !== templateDependency.pin) {\n            log({\n              title: \"verifyDependencyPinsSame Debug Error\",\n              message: `Could not recompute and match dependency pin.\n                                address: ${templateDependency.address} | contract: ${templateDependency.contract}\n                                computed: ${pin}\n                                template: ${templateDependency.pin}\n                            `,\n              level: LEVELS.debug\n            });\n            return false;\n          }\n        }\n      }\n      return true;\n    default:\n      throw new Error(\"verifyDependencyPinsSame Error: Unsupported template version\");\n  }\n}\n\n/**\n * @description Checks if an Interaction Template's pins match those generated at the latest block height\n * \n * @param {object} params\n * @param {object} params.template - Interaction Template to check pins for\n * @param {string} params.network - Network to check pins on\n * @param {object} opts\n * @returns {Promise<boolean>} - Whether or not the pins match\n */\nasync function verifyDependencyPinsSameAtLatestSealedBlock(_ref2) {\n  let {\n    template,\n    network\n  } = _ref2;\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let latestSealedBlock = await block({\n    sealed: true\n  });\n  let latestSealedBlockHeight = latestSealedBlock?.height;\n  return verifyDependencyPinsSame({\n    template,\n    network,\n    blockHeight: latestSealedBlockHeight\n  }, opts);\n}\n\n/**\n * @description Get Interaction Template argument message\n * \n * @param {object} params\n * @param {string} params.localization [localization=\"en-US\"] - Localization code\n * @param {string} params.messageKey - Message key\n * @param {object} params.template - Interaction Template\n * @returns {string} - Message\n */\nfunction getTemplateMessage(_ref) {\n  let {\n    localization = \"en-US\",\n    messageKey,\n    template\n  } = _ref;\n  invariant$1(messageKey, \"getTemplateMessage({ messageKey }) -- messageKey must be defined\");\n  invariant$1(typeof messageKey === \"string\", \"getTemplateMessage({ messageKey }) -- messageKey must be a string\");\n  invariant$1(localization, \"getTemplateMessage({ localization }) -- localization must be defined\");\n  invariant$1(typeof localization === \"string\", \"getTemplateMessage({ localization }) -- localization must be a string\");\n  invariant$1(template != undefined, \"getTemplateMessage({ template }) -- template must be defined\");\n  invariant$1(typeof template === \"object\", \"getTemplateMessage({ template }) -- template must be an object\");\n  invariant$1(typeof template.f_type === \"InteractionTemplate\", \"getTemplateMessage({ template }) -- template object must be an InteractionTemplate\");\n  const messages = template?.data?.messages;\n  return messages?.[messageKey]?.i18n?.[localization];\n}\n\n/**\n * @description Gets Interaction Template argument message by message key, argument label, and localization\n * \n * @param {object} opts\n * @param {string} opts.localization [localization=\"en-US\"] - Localization to get message for\n * @param {string} opts.argumentLabel - Argument label to get message for\n * @param {string} opts.messageKey - Message key to get message for\n * @param {object} opts.template - Interaction Template to get message from\n * @returns {string} - Message\n */\nfunction getTemplateArgumentMessage(_ref) {\n  let {\n    localization = \"en-US\",\n    argumentLabel,\n    messageKey,\n    template\n  } = _ref;\n  invariant$1(messageKey, \"getTemplateArgumentMessage({ messageKey }) -- messageKey must be defined\");\n  invariant$1(typeof messageKey === \"string\", \"getTemplateArgumentMessage({ messageKey }) -- messageKey must be a string\");\n  invariant$1(argumentLabel, \"getTemplateArgumentMessage({ argumentLabel }) -- argumentLabel must be defined\");\n  invariant$1(typeof messageKey === \"string\", \"getTemplateArgumentMessage({ argumentLabel }) -- argumentLabel must be a string\");\n  invariant$1(localization, \"getTemplateArgumentMessage({ localization }) -- localization must be defined\");\n  invariant$1(typeof localization === \"string\", \"getTemplateArgumentMessage({ localization }) -- localization must be a string\");\n  invariant$1(template != undefined, \"getTemplateArgumentMessage({ template }) -- template must be defined\");\n  invariant$1(typeof template === \"object\", \"getTemplateArgumentMessage({ template }) -- template must be an object\");\n  invariant$1(typeof template.f_type === \"InteractionTemplate\", \"getTemplateArgumentMessage({ template }) -- template object must be an InteractionTemplate\");\n  const args = template?.data?.arguments;\n  return args?.[argumentLabel]?.messages?.[messageKey]?.i18n?.[localization];\n}\n\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  getInteractionTemplateAudits: getInteractionTemplateAudits,\n  generateDependencyPin: generateDependencyPin,\n  generateDependencyPinAtLatestSealedBlock: generateDependencyPinAtLatestSealedBlock,\n  generateTemplateId: generateTemplateId,\n  generateTemplateInterfaceId: generateTemplateInterfaceId,\n  verifyDependencyPinsSame: verifyDependencyPinsSame,\n  verifyDependencyPinsSameAtLatestSealedBlock: verifyDependencyPinsSameAtLatestSealedBlock,\n  deriveCadenceByNetwork: deriveCadenceByNetwork,\n  getTemplateMessage: getTemplateMessage,\n  getTemplateArgumentMessage: getTemplateArgumentMessage\n});\n\nconst authenticate = function () {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return currentUser().authenticate(opts);\n};\nconst unauthenticate = () => currentUser().unauthenticate();\nconst reauthenticate = function () {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  currentUser().unauthenticate();\n  return currentUser().authenticate(opts);\n};\nconst signUp = function () {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return currentUser().authenticate(opts);\n};\nconst logIn = function () {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return currentUser().authenticate(opts);\n};\nconst authz = currentUser().authorization;\nconst t = t$1;\n\n/**\n * @callback ArgsFn\n * @param {ArgFn} arg - Argument function to define a single argument\n * @param {object} t - Cadence Types object used to define the type\n * @returns {any[]}\n */\n\n/**\n * @callback ArgFn\n * @param {any} value - the value of the argument\n * @param {any} type - the cadence type of the value\n * @returns {any}\n */\n\nexport { index$1 as AppUtils, index as InteractionTemplateUtils, VERSION, index$2 as WalletUtils, authenticate, authz, currentUser, discovery, events, getChainId, logIn, mutate, pluginRegistry, query, reauthenticate, serialize, signUp, t, transaction as tx, unauthenticate, verifyUserSignatures };\n"],"names":[],"sourceRoot":"","x_google_ignoreList":[0]}