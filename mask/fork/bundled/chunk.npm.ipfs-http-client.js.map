{"version":3,"file":"bundled/chunk.npm.ipfs-http-client.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;AAEqD;AACiB;AAC5B;AACH;AACE;AACJ;AACsB;AACf;;AAE5C,YAAY,kCAAM;AAClB,cAAc,4BAAS,QAAQ,uBAAuB;;AAEtD,yBAAyB,aAAS,IAAI,eAAW;AACjD,qBAAqB,aAAS,IAAI,eAAW;AAC7C,qBAAqB,aAAS,IAAI,eAAW;;AAE7C;AACA,aAAa,4CAA4C;AACzD,aAAa,4BAA4B;AACzC,aAAa,6CAA6C;AAC1D;;AAEA;AACA,WAAW,8BAA8B;AACzC,aAAa;AACb;AACA,sCAAsC;AACtC;AACA,aAAa,SAAS;AACtB;AACA;;AAEA,qCAAqC,gCAAW;AAChD,kBAAkB,oCAAW;AAC7B,IAAI;AACJ;AACA,IAAI,4CAA4C,gCAAW;AAC3D,kBAAkB,oCAAW;AAC7B;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA,qBAAqB,SAAS,KAAK,KAAK,GAAG,KAAK;AAChD;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA,MAAM,UAAM;AACZ,kBAAkB,gCAAQ;;AAE1B;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,UAAU;AACrB;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI,kBAAkB,KAAK;AAC3B;AACA;AACA;AACA;;AAEA,aAAa,OAAO;AACpB,kBAAkB,cAAc;;AAEhC;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;;AAEA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;;AAEA;AACA;AACA,gBAAgB,iBAAiB;AACjC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,WAAW,iBAAiB;AAC5B;AACA;AACA,qCAAqC,iCAAa;AAClD;;AAEO,qBAAqB,IAAI;AAChC;AACA,aAAa,8BAA8B;AAC3C;AACA,2BAA2B;AAC3B;;AAEA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,eAAe,kBAAkB;AACjC,eAAe,aAAa;AAC5B;AACA,wCAAwC;AACxC;AACA,sBAAsB,SAAS,GAAG,SAAS;AAC3C;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEO,kBAAkB,cAAc;;;;AClNvC;;AAEkC;;AAElC;AACA;AACA,cAAc,6BAA6B;AAC3C;;AAEA;AACA;AACA,aAAa,+CAA+C;AAC5D;;AAEA;AACA;AACA,aAAa,+BAA+B;AAC5C;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;AACA,kBAAkB,MAAM;AACxB;AACA;;;;AC5BA;AACA,WAAW,6BAA6B;AACxC;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;ACd8B;;AAE9B;AACA,WAAW,KAAK;AAChB;AACO;AACP;AACA;AACA;;AAEA,eAAe,+BAA+B,aAAa;AAC3D;;AAEA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU,QAAO;AACjB;;AAEA;AACA;;;ACxEkD;AACA;;AAElD;AACA,WAAW,GAAG;AACd,aAAa;AACb;AACO,8BAA8B,sDAAsD,IAAI;AAC/F;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,YAAY,UAAU;;AAEtB;AACA;AACA;;AAEA;AACA,mBAAmB,YA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","sources":["webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/lib/core.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/lib/configure.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/lib/mode-to-string.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/lib/parse-mtime.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/lib/to-url-search-params.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/bitswap/wantlist.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/bitswap/wantlist-for-peer.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/bitswap/stat.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/bitswap/unwant.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/bitswap/index.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/block/get.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/lib/abort-signal.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/block/put.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/block/rm.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/block/stat.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/block/index.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/bootstrap/add.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/bootstrap/clear.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/bootstrap/list.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/bootstrap/reset.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/bootstrap/rm.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/bootstrap/index.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/config/profiles/apply.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/lib/object-to-camel.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/config/profiles/list.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/config/profiles/index.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/config/get.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/config/get-all.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/config/replace.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/config/set.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/config/index.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/dag/export.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/lib/resolve.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/dag/get.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/dag/import.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/dag/put.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/dag/resolve.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/dag/index.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/dht/response-types.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/dht/map-event.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/dht/find-peer.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/dht/find-provs.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/dht/get.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/dht/provide.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/dht/put.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/dht/query.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/dht/index.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/diag/cmds.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/diag/net.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/diag/sys.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/diag/index.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/files/chmod.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/files/cp.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/files/flush.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/lib/object-to-camel-with-metadata.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/files/ls.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/files/mkdir.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/files/mv.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/files/read.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/files/rm.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/files/stat.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/files/touch.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/files/write.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/files/index.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/key/export.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/key/gen.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/key/import.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/key/info.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/key/list.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/key/rename.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/key/rm.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/key/index.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/log/level.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/log/ls.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/log/tail.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/log/index.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/name/publish.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/name/resolve.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/name/pubsub/cancel.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/name/pubsub/state.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/name/pubsub/subs.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/name/pubsub/index.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/name/index.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/object/data.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/object/get.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/object/links.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/object/new.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/object/put.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/object/stat.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/object/patch/add-link.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/object/patch/append-data.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/object/patch/rm-link.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/object/patch/set-data.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/object/patch/index.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/object/index.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/pin/add-all.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/pin/add.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/pin/ls.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/pin/rm-all.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/pin/rm.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/pin/remote/utils.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/pin/remote/add.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/pin/remote/ls.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/pin/remote/rm.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/pin/remote/rm-all.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/pin/remote/service/utils.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/pin/remote/service/add.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/pin/remote/service/ls.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/pin/remote/service/rm.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/pin/remote/service/index.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/pin/remote/index.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/pin/index.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/lib/http-rpc-wire-format.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/pubsub/ls.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/pubsub/peers.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/pubsub/publish.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/pubsub/subscribe.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/pubsub/unsubscribe.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/pubsub/subscription-tracker.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/pubsub/index.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/refs/local.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/refs/index.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/repo/gc.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/repo/stat.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/repo/version.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/repo/index.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/stats/bw.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/stats/index.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/swarm/addrs.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/swarm/connect.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/swarm/disconnect.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/swarm/local-addrs.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/swarm/peers.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/swarm/index.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/add-all.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/add.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/cat.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/commands.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/dns.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/get-endpoint-config.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/get.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/id.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/is-online.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/ls.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/mount.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/ping.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/resolve.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/start.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/stop.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/version.js","webpack://mask-network/./node_modules/.pnpm/ipfs-http-client@60.0.1_undici@5.23.0/node_modules/ipfs-http-client/src/index.js"],"sourcesContent":["\n/* eslint-env browser */\n\nimport { isMultiaddr } from '@multiformats/multiaddr'\nimport { isBrowser, isWebWorker, isNode } from 'ipfs-utils/src/env.js'\nimport parseDuration from 'parse-duration'\nimport { logger } from '@libp2p/logger'\nimport HTTP from 'ipfs-utils/src/http.js'\nimport mergeOpts from 'merge-options'\nimport { toUrlString } from 'ipfs-core-utils/to-url-string'\nimport getAgent from 'ipfs-core-utils/agent'\n\nconst log = logger('ipfs-http-client:lib:error-handler')\nconst merge = mergeOpts.bind({ ignoreUndefined: true })\n\nconst DEFAULT_PROTOCOL = isBrowser || isWebWorker ? location.protocol : 'http'\nconst DEFAULT_HOST = isBrowser || isWebWorker ? location.hostname : 'localhost'\nconst DEFAULT_PORT = isBrowser || isWebWorker ? location.port : '5001'\n\n/**\n * @typedef {import('ipfs-utils/src/types').HTTPOptions} HTTPOptions\n * @typedef {import('../types').Options} Options\n * @typedef {import('@multiformats/multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @param {Options|URL|Multiaddr|string} [options]\n * @returns {Options}\n */\nconst normalizeOptions = (options = {}) => {\n  let url\n  /** @type {Options} */\n  let opts = {}\n  let agent\n\n  if (typeof options === 'string' || isMultiaddr(options)) {\n    url = new URL(toUrlString(options))\n  } else if (options instanceof URL) {\n    url = options\n  } else if (typeof options.url === 'string' || isMultiaddr(options.url)) {\n    url = new URL(toUrlString(options.url))\n    opts = options\n  } else if (options.url instanceof URL) {\n    url = options.url\n    opts = options\n  } else {\n    opts = options || {}\n\n    const protocol = (opts.protocol || DEFAULT_PROTOCOL).replace(':', '')\n    const host = (opts.host || DEFAULT_HOST).split(':')[0]\n    const port = (opts.port || DEFAULT_PORT)\n\n    url = new URL(`${protocol}://${host}:${port}`)\n  }\n\n  if (opts.apiPath) {\n    url.pathname = opts.apiPath\n  } else if (url.pathname === '/' || url.pathname === undefined) {\n    url.pathname = 'api/v0'\n  }\n\n  if (isNode) {\n    const Agent = getAgent(url)\n\n    agent = opts.agent || new Agent({\n      keepAlive: true,\n      // Similar to browsers which limit connections to six per host\n      maxSockets: 6\n    })\n  }\n\n  return {\n    ...opts,\n    host: url.host,\n    protocol: url.protocol.replace(':', ''),\n    port: Number(url.port),\n    apiPath: url.pathname,\n    url,\n    agent\n  }\n}\n\n/**\n * @param {Response} response\n */\nexport const errorHandler = async (response) => {\n  let msg\n\n  try {\n    if ((response.headers.get('Content-Type') || '').startsWith('application/json')) {\n      const data = await response.json()\n      log(data)\n      msg = data.Message || data.message\n    } else {\n      msg = await response.text()\n    }\n  } catch (/** @type {any} */ err) {\n    log('Failed to parse error response', err)\n    // Failed to extract/parse error message from response\n    msg = err.message\n  }\n\n  /** @type {Error} */\n  let error = new HTTP.HTTPError(response)\n\n  if (msg) {\n    // This is what rs-ipfs returns where there's a timeout\n    if (msg.includes('deadline has elapsed')) {\n      error = new HTTP.TimeoutError()\n    }\n\n    // This is what go-ipfs returns where there's a timeout\n    if (msg && msg.includes('context deadline exceeded')) {\n      error = new HTTP.TimeoutError()\n    }\n  }\n\n  // This also gets returned\n  if (msg && msg.includes('request timed out')) {\n    error = new HTTP.TimeoutError()\n  }\n\n  // If we managed to extract a message from the response, use it\n  if (msg) {\n    error.message = msg\n  }\n\n  throw error\n}\n\nconst KEBAB_REGEX = /[A-Z\\u00C0-\\u00D6\\u00D8-\\u00DE]/g\n\n/**\n * @param {string} str\n */\nconst kebabCase = (str) => {\n  return str.replace(KEBAB_REGEX, function (match) {\n    return '-' + match.toLowerCase()\n  })\n}\n\n/**\n * @param {string | number} value\n */\nconst parseTimeout = (value) => {\n  return typeof value === 'string' ? parseDuration(value) : value\n}\n\nexport class Client extends HTTP {\n  /**\n   * @param {Options|URL|Multiaddr|string} [options]\n   */\n  constructor (options = {}) {\n    const opts = normalizeOptions(options)\n\n    super({\n      timeout: parseTimeout(opts.timeout || 0) || undefined,\n      headers: opts.headers,\n      base: `${opts.url}`,\n      handleError: errorHandler,\n      transformSearchParams: (search) => {\n        const out = new URLSearchParams()\n\n        for (const [key, value] of search) {\n          if (\n            value !== 'undefined' &&\n            value !== 'null' &&\n            key !== 'signal'\n          ) {\n            out.append(kebabCase(key), value)\n          }\n\n          // @ts-expect-error server timeouts are strings\n          if (key === 'timeout' && !isNaN(value)) {\n            out.append(kebabCase(key), value)\n          }\n        }\n\n        return out\n      },\n      // @ts-expect-error this can be a https agent or a http agent\n      agent: opts.agent\n    })\n\n    // @ts-expect-error - cannot delete no-optional fields\n    delete this.get\n    // @ts-expect-error - cannot delete no-optional fields\n    delete this.put\n    // @ts-expect-error - cannot delete no-optional fields\n    delete this.delete\n    // @ts-expect-error - cannot delete no-optional fields\n    delete this.options\n\n    const fetch = this.fetch\n\n    /**\n     * @param {string | Request} resource\n     * @param {HTTPOptions} options\n     */\n    this.fetch = (resource, options = {}) => {\n      if (typeof resource === 'string' && !resource.startsWith('/')) {\n        resource = `${opts.url}/${resource}`\n      }\n\n      return fetch.call(this, resource, merge(options, {\n        method: 'POST'\n      }))\n    }\n  }\n}\n\nexport const HTTPError = HTTP.HTTPError\n","\n/* eslint-env browser */\n\nimport { Client } from './core.js'\n\n// Set default configuration and call create function with them\n/**\n * @typedef { import(\"../types\").Options } Options\n */\n\n/**\n * @template T\n * @typedef {(client: Client, clientOptions: Options) => T} Fn\n */\n\n/**\n * @template T\n * @typedef {(clientOptions: Options) => T} Factory\n */\n\n/**\n * @template T\n * @param {Fn<T>} fn\n * @returns {Factory<T>}\n */\nexport const configure = (fn) => {\n  return (options) => {\n    return fn(new Client(options), options)\n  }\n}\n","\n/**\n * @param {number | string | undefined} mode\n */\nexport function modeToString (mode) {\n  if (mode == null) {\n    return undefined\n  }\n\n  if (typeof mode === 'string') {\n    return mode\n  }\n\n  return mode.toString(8).padStart(4, '0')\n}\n","import errCode from 'err-code'\n\n/**\n * @param {any} input\n */\nexport function parseMtime (input) {\n  if (input == null) {\n    return undefined\n  }\n\n  /** @type {{ secs: number, nsecs?: number } | undefined} */\n  let mtime\n\n  // { secs, nsecs }\n  if (input.secs != null) {\n    mtime = {\n      secs: input.secs,\n      nsecs: input.nsecs\n    }\n  }\n\n  // UnixFS TimeSpec\n  if (input.Seconds != null) {\n    mtime = {\n      secs: input.Seconds,\n      nsecs: input.FractionalNanoseconds\n    }\n  }\n\n  // process.hrtime()\n  if (Array.isArray(input)) {\n    mtime = {\n      secs: input[0],\n      nsecs: input[1]\n    }\n  }\n\n  // Javascript Date\n  if (input instanceof Date) {\n    const ms = input.getTime()\n    const secs = Math.floor(ms / 1000)\n\n    mtime = {\n      secs: secs,\n      nsecs: (ms - (secs * 1000)) * 1000\n    }\n  }\n\n  /*\n  TODO: https://github.com/ipfs/aegir/issues/487\n\n  // process.hrtime.bigint()\n  if (input instanceof BigInt) {\n    const secs = input / BigInt(1e9)\n    const nsecs = input - (secs * BigInt(1e9))\n\n    mtime = {\n      secs: parseInt(secs.toString()),\n      nsecs: parseInt(nsecs.toString())\n    }\n  }\n  */\n\n  if (!Object.prototype.hasOwnProperty.call(mtime, 'secs')) {\n    return undefined\n  }\n\n  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {\n    throw errCode(new Error('mtime-nsecs must be within the range [0,999999999]'), 'ERR_INVALID_MTIME_NSECS')\n  }\n\n  return mtime\n}\n","import { modeToString } from './mode-to-string.js'\nimport { parseMtime } from '../lib/parse-mtime.js'\n\n/**\n * @param {*} params\n * @returns {URLSearchParams}\n */\nexport function toUrlSearchParams ({ arg, searchParams, hashAlg, mtime, mode, ...options } = {}) {\n  if (searchParams) {\n    options = {\n      ...options,\n      ...searchParams\n    }\n  }\n\n  if (hashAlg) {\n    options.hash = hashAlg\n  }\n\n  if (mtime != null) {\n    mtime = parseMtime(mtime)\n\n    options.mtime = mtime.secs\n    options.mtimeNsecs = mtime.nsecs\n  }\n\n  if (mode != null) {\n    options.mode = modeToString(mode)\n  }\n\n  if (options.timeout && !isNaN(options.timeout)) {\n    // server API expects timeouts as strings\n    options.timeout = `${options.timeout}ms`\n  }\n\n  if (arg === undefined || arg === null) {\n    arg = []\n  } else if (!Array.isArray(arg)) {\n    arg = [arg]\n  }\n\n  const urlSearchParams = new URLSearchParams(options)\n\n  arg.forEach((/** @type {any} */ arg) => urlSearchParams.append('arg', arg))\n\n  return urlSearchParams\n}\n","import { CID } from 'multiformats/cid'\nimport { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/bitswap').API<HTTPClientExtraOptions>} BitswapAPI\n */\n\nexport const createWantlist = configure(api => {\n  /**\n   * @type {BitswapAPI[\"wantlist\"]}\n   */\n  async function wantlist (options = {}) {\n    const res = await (await api.post('bitswap/wantlist', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams(options),\n      headers: options.headers\n    })).json()\n\n    return (res.Keys || []).map((/** @type {{ '/': string }} */ k) => CID.parse(k['/']))\n  }\n  return wantlist\n})\n","import { CID } from 'multiformats/cid'\nimport { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/bitswap').API<HTTPClientExtraOptions>} BitswapAPI\n */\n\nexport const createWantlistForPeer = configure(api => {\n  /**\n   * @type {BitswapAPI[\"wantlistForPeer\"]}\n   */\n  async function wantlistForPeer (peerId, options = {}) {\n    const res = await (await api.post('bitswap/wantlist', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        ...options,\n        peer: peerId.toString()\n      }),\n      headers: options.headers\n    })).json()\n\n    return (res.Keys || []).map((/** @type {{ '/': string }} */ k) => CID.parse(k['/']))\n  }\n  return wantlistForPeer\n})\n","import { CID } from 'multiformats/cid'\nimport { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\nimport { peerIdFromString } from '@libp2p/peer-id'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/bitswap').API<HTTPClientExtraOptions>} BitswapAPI\n */\n\nexport const createStat = configure(api => {\n  /**\n   * @type {BitswapAPI[\"stat\"]}\n   */\n  async function stat (options = {}) {\n    const res = await api.post('bitswap/stat', {\n      searchParams: toUrlSearchParams(options),\n      signal: options.signal,\n      headers: options.headers\n    })\n\n    return toCoreInterface(await res.json())\n  }\n  return stat\n})\n\n/**\n * @param {any} res\n */\nfunction toCoreInterface (res) {\n  return {\n    provideBufLen: res.ProvideBufLen,\n    wantlist: (res.Wantlist || []).map((/** @type {{ '/': string }} */ k) => CID.parse(k['/'])),\n    peers: (res.Peers || []).map((/** @type {string} */ str) => peerIdFromString(str)),\n    blocksReceived: BigInt(res.BlocksReceived),\n    dataReceived: BigInt(res.DataReceived),\n    blocksSent: BigInt(res.BlocksSent),\n    dataSent: BigInt(res.DataSent),\n    dupBlksReceived: BigInt(res.DupBlksReceived),\n    dupDataReceived: BigInt(res.DupDataReceived)\n  }\n}\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/bitswap').API<HTTPClientExtraOptions>} BitswapAPI\n */\n\nexport const createUnwant = configure(api => {\n  /**\n   * @type {BitswapAPI[\"unwant\"]}\n   */\n  async function unwant (cid, options = {}) {\n    const res = await api.post('bitswap/unwant', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: cid.toString(),\n        ...options\n      }),\n      headers: options.headers\n    })\n\n    return res.json()\n  }\n  return unwant\n})\n","import { createWantlist } from './wantlist.js'\nimport { createWantlistForPeer } from './wantlist-for-peer.js'\nimport { createStat } from './stat.js'\nimport { createUnwant } from './unwant.js'\n\n/**\n * @param {import('../types').Options} config\n */\nexport function createBitswap (config) {\n  return {\n    wantlist: createWantlist(config),\n    wantlistForPeer: createWantlistForPeer(config),\n    unwant: createUnwant(config),\n    stat: createStat(config)\n  }\n}\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/block').API<HTTPClientExtraOptions>} BlockAPI\n */\n\nexport const createGet = configure(api => {\n  /**\n   * @type {BlockAPI[\"get\"]}\n   */\n  async function get (cid, options = {}) {\n    const res = await api.post('block/get', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: cid.toString(),\n        ...options\n      }),\n      headers: options.headers\n    })\n\n    return new Uint8Array(await res.arrayBuffer())\n  }\n  return get\n})\n","import { anySignal } from 'any-signal'\n\n/**\n * @param {any[]} signals\n * @returns {AbortSignal[]}\n */\nfunction filter (signals) {\n  return signals.filter(Boolean)\n}\n\n/**\n * @param  {...AbortSignal|undefined} signals\n */\nexport function abortSignal (...signals) {\n  return anySignal(filter(signals))\n}\n","import { CID } from 'multiformats/cid'\nimport { multipartRequest } from 'ipfs-core-utils/multipart-request'\nimport { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\nimport { abortSignal } from '../lib/abort-signal.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/block').API<HTTPClientExtraOptions>} BlockAPI\n */\n\nexport const createPut = configure(api => {\n  /**\n   * @type {BlockAPI[\"put\"]}\n   */\n  async function put (data, options = {}) {\n    // allow aborting requests on body errors\n    const controller = new AbortController()\n    const signal = abortSignal(controller.signal, options.signal)\n\n    let res\n    try {\n      const response = await api.post('block/put', {\n        signal: signal,\n        searchParams: toUrlSearchParams(options),\n        ...(\n          await multipartRequest([data], controller, options.headers)\n        )\n      })\n      res = await response.json()\n    } catch (/** @type {any} */ err) {\n      // Retry with \"protobuf\"/\"cbor\" format for go-ipfs\n      // TODO: remove when https://github.com/ipfs/go-cid/issues/75 resolved\n      if (options.format === 'dag-pb') {\n        return put(data, { ...options, format: 'protobuf' })\n      } else if (options.format === 'dag-cbor') {\n        return put(data, { ...options, format: 'cbor' })\n      }\n\n      throw err\n    }\n\n    return CID.parse(res.Key)\n  }\n\n  return put\n})\n","import { CID } from 'multiformats/cid'\nimport { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/block').API<HTTPClientExtraOptions>} BlockAPI\n * @typedef {import('ipfs-core-types/src/block').RmResult} RmResult\n */\n\nexport const createRm = configure(api => {\n  /**\n   * @type {BlockAPI[\"rm\"]}\n   */\n  async function * rm (cid, options = {}) {\n    if (!Array.isArray(cid)) {\n      cid = [cid]\n    }\n\n    const res = await api.post('block/rm', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: cid.map(cid => cid.toString()),\n        'stream-channels': true,\n        ...options\n      }),\n      headers: options.headers\n    })\n\n    for await (const removed of res.ndjson()) {\n      yield toCoreInterface(removed)\n    }\n  }\n\n  return rm\n})\n\n/**\n * @param {*} removed\n */\nfunction toCoreInterface (removed) {\n  /** @type {RmResult} */\n  const out = {\n    cid: CID.parse(removed.Hash)\n  }\n\n  if (removed.Error) {\n    out.error = new Error(removed.Error)\n  }\n\n  return out\n}\n","import { CID } from 'multiformats/cid'\nimport { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/block').API<HTTPClientExtraOptions>} BlockAPI\n */\n\nexport const createStat = configure(api => {\n  /**\n   * @type {BlockAPI[\"stat\"]}\n   */\n  async function stat (cid, options = {}) {\n    const res = await api.post('block/stat', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: cid.toString(),\n        ...options\n      }),\n      headers: options.headers\n    })\n    const data = await res.json()\n\n    return { cid: CID.parse(data.Key), size: data.Size }\n  }\n\n  return stat\n})\n","import { createGet } from './get.js'\nimport { createPut } from './put.js'\nimport { createRm } from './rm.js'\nimport { createStat } from './stat.js'\n\n/**\n * @param {import('../types').Options} config\n */\nexport function createBlock (config) {\n  return {\n    get: createGet(config),\n    put: createPut(config),\n    rm: createRm(config),\n    stat: createStat(config)\n  }\n}\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\nimport { multiaddr } from '@multiformats/multiaddr'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/bootstrap').API<HTTPClientExtraOptions>} BootstrapAPI\n */\n\nexport const createAdd = configure(api => {\n  /**\n   * @type {BootstrapAPI[\"add\"]}\n   */\n  async function add (addr, options = {}) {\n    const res = await api.post('bootstrap/add', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: addr,\n        ...options\n      }),\n      headers: options.headers\n    })\n\n    const { Peers } = await res.json()\n\n    return { Peers: Peers.map((/** @type {string} */ ma) => multiaddr(ma)) }\n  }\n\n  return add\n})\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\nimport { multiaddr } from '@multiformats/multiaddr'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/bootstrap').API<HTTPClientExtraOptions>} BootstrapAPI\n */\n\nexport const createClear = configure(api => {\n  /**\n   * @type {BootstrapAPI[\"clear\"]}\n   */\n  async function clear (options = {}) {\n    const res = await api.post('bootstrap/rm', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        ...options,\n        all: true\n      }),\n      headers: options.headers\n    })\n\n    const { Peers } = await res.json()\n\n    return { Peers: Peers.map((/** @type {string} */ ma) => multiaddr(ma)) }\n  }\n\n  return clear\n})\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\nimport { multiaddr } from '@multiformats/multiaddr'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/bootstrap').API<HTTPClientExtraOptions>} BootstrapAPI\n */\n\nexport const createList = configure(api => {\n  /**\n   * @type {BootstrapAPI[\"list\"]}\n   */\n  async function list (options = {}) {\n    const res = await api.post('bootstrap/list', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams(options),\n      headers: options.headers\n    })\n\n    const { Peers } = await res.json()\n\n    return { Peers: Peers.map((/** @type {string} */ ma) => multiaddr(ma)) }\n  }\n\n  return list\n})\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\nimport { multiaddr } from '@multiformats/multiaddr'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/bootstrap').API<HTTPClientExtraOptions>} BootstrapAPI\n */\n\nexport const createReset = configure(api => {\n  /**\n   * @type {BootstrapAPI[\"reset\"]}\n   */\n  async function reset (options = {}) {\n    const res = await api.post('bootstrap/add', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        ...options,\n        default: true\n      }),\n      headers: options.headers\n    })\n\n    const { Peers } = await res.json()\n\n    return { Peers: Peers.map((/** @type {string} */ ma) => multiaddr(ma)) }\n  }\n\n  return reset\n})\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\nimport { multiaddr } from '@multiformats/multiaddr'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/bootstrap').API<HTTPClientExtraOptions>} BootstrapAPI\n */\n\nexport const createRm = configure(api => {\n  /**\n   * @type {BootstrapAPI[\"rm\"]}\n   */\n  async function rm (addr, options = {}) {\n    const res = await api.post('bootstrap/rm', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: addr,\n        ...options\n      }),\n      headers: options.headers\n    })\n\n    const { Peers } = await res.json()\n\n    return { Peers: Peers.map((/** @type {string} */ ma) => multiaddr(ma)) }\n  }\n\n  return rm\n})\n","import { createAdd } from './add.js'\nimport { createClear } from './clear.js'\nimport { createList } from './list.js'\nimport { createReset } from './reset.js'\nimport { createRm } from './rm.js'\n\n/**\n * @param {import('../types').Options} config\n */\nexport function createBootstrap (config) {\n  return {\n    add: createAdd(config),\n    clear: createClear(config),\n    list: createList(config),\n    reset: createReset(config),\n    rm: createRm(config)\n  }\n}\n","import { configure } from '../../lib/configure.js'\nimport { toUrlSearchParams } from '../../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/config/profiles').API<HTTPClientExtraOptions>} ConfigProfilesAPI\n */\n\nexport const createApply = configure(api => {\n  /**\n   * @type {ConfigProfilesAPI[\"apply\"]}\n   */\n  async function apply (profile, options = {}) {\n    const res = await api.post('config/profile/apply', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: profile,\n        ...options\n      }),\n      headers: options.headers\n    })\n    const data = await res.json()\n\n    return {\n      original: data.OldCfg, updated: data.NewCfg\n    }\n  }\n\n  return apply\n})\n","\n/**\n * Convert object properties to camel case.\n * NOT recursive!\n * e.g.\n * AgentVersion => agentVersion\n * ID => id\n *\n * @param {Record<string, any>} obj\n */\nexport function objectToCamel (obj) {\n  if (obj == null) {\n    return obj\n  }\n\n  const caps = /^[A-Z]+$/\n\n  /** @type {Record<string, any>} */\n  const output = {}\n\n  return Object.keys(obj).reduce((camelObj, k) => {\n    if (caps.test(k)) { // all caps\n      camelObj[k.toLowerCase()] = obj[k]\n    } else if (caps.test(k[0])) { // pascal\n      camelObj[k[0].toLowerCase() + k.slice(1)] = obj[k]\n    } else {\n      camelObj[k] = obj[k]\n    }\n    return camelObj\n  }, output)\n}\n","import { objectToCamel } from '../../lib/object-to-camel.js'\nimport { configure } from '../../lib/configure.js'\nimport { toUrlSearchParams } from '../../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/config/profiles').API<HTTPClientExtraOptions>} ConfigProfilesAPI\n */\n\nexport const createList = configure(api => {\n  /**\n   * @type {ConfigProfilesAPI[\"list\"]}\n   */\n  async function list (options = {}) {\n    const res = await api.post('config/profile/list', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams(options),\n      headers: options.headers\n    })\n\n    const data = await res.json()\n\n    return data.map((/** @type {Record<string, any>} */ profile) => objectToCamel(profile))\n  }\n  return list\n})\n","import { createApply } from './apply.js'\nimport { createList } from './list.js'\n\n/**\n * @param {import('../../types').Options} config\n */\nexport function createProfiles (config) {\n  return {\n    apply: createApply(config),\n    list: createList(config)\n  }\n}\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/config').API<HTTPClientExtraOptions>} ConfigAPI\n */\n\nexport const createGet = configure(api => {\n  /**\n   * @type {ConfigAPI[\"get\"]}\n   */\n  const get = async (key, options = {}) => {\n    if (!key) {\n      throw new Error('key argument is required')\n    }\n\n    const res = await api.post('config', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: key,\n        ...options\n      }),\n      headers: options.headers\n    })\n    const data = await res.json()\n\n    return data.Value\n  }\n\n  return get\n})\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/config').API<HTTPClientExtraOptions>} ConfigAPI\n */\n\nexport const createGetAll = configure(api => {\n  /**\n   * @type {ConfigAPI[\"getAll\"]}\n   */\n  const getAll = async (options = {}) => {\n    const res = await api.post('config/show', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        ...options\n      }),\n      headers: options.headers\n    })\n    const data = await res.json()\n\n    return data\n  }\n\n  return getAll\n})\n","import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { multipartRequest } from 'ipfs-core-utils/multipart-request'\nimport { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\nimport { abortSignal } from '../lib/abort-signal.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/config').API<HTTPClientExtraOptions>} ConfigAPI\n */\n\nexport const createReplace = configure(api => {\n  /**\n   * @type {ConfigAPI[\"replace\"]}\n   */\n  const replace = async (config, options = {}) => {\n    // allow aborting requests on body errors\n    const controller = new AbortController()\n    const signal = abortSignal(controller.signal, options.signal)\n\n    const res = await api.post('config/replace', {\n      signal,\n      searchParams: toUrlSearchParams(options),\n      ...(\n        await multipartRequest([uint8ArrayFromString(JSON.stringify(config))], controller, options.headers)\n      )\n    })\n\n    await res.text()\n  }\n\n  return replace\n})\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/config').API<HTTPClientExtraOptions>} ConfigAPI\n */\n\nexport const createSet = configure(api => {\n  /**\n   * @type {ConfigAPI[\"set\"]}\n   */\n  const set = async (key, value, options = {}) => {\n    if (typeof key !== 'string') {\n      throw new Error('Invalid key type')\n    }\n\n    const params = {\n      ...options,\n      ...encodeParam(key, value)\n    }\n\n    const res = await api.post('config', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams(params),\n      headers: options.headers\n    })\n\n    await res.text()\n  }\n\n  return set\n})\n\n/**\n * @param {*} key\n * @param {*} value\n */\nconst encodeParam = (key, value) => {\n  switch (typeof value) {\n    case 'boolean':\n      return { arg: [key, value.toString()], bool: true }\n    case 'string':\n      return { arg: [key, value] }\n    default:\n      return { arg: [key, JSON.stringify(value)], json: true }\n  }\n}\n","import { createProfiles } from './profiles/index.js'\nimport { createGet } from './get.js'\nimport { createGetAll } from './get-all.js'\nimport { createReplace } from './replace.js'\nimport { createSet } from './set.js'\n\n/**\n * @param {import('../types').Options} config\n */\nexport function createConfig (config) {\n  return {\n    getAll: createGetAll(config),\n    get: createGet(config),\n    set: createSet(config),\n    replace: createReplace(config),\n    profiles: createProfiles(config)\n  }\n}\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/dag').API<HTTPClientExtraOptions>} DAGAPI\n */\n\nexport const createExport = configure(api => {\n  /**\n   * @type {DAGAPI[\"export\"]}\n   */\n  async function * dagExport (root, options = {}) {\n    const res = await api.post('dag/export', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: root.toString()\n      }),\n      headers: options.headers\n    })\n\n    yield * res.iterator()\n  }\n\n  return dagExport\n})\n","import { CID } from 'multiformats/cid'\nimport errCode from 'err-code'\n\n/**\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * Retrieves IPLD Nodes along the `path` that is rooted at `cid`.\n *\n * @param {CID} cid - the CID where the resolving starts\n * @param {string} path - the path that should be resolved\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @param {(cid: CID, options?: AbortOptions) => Promise<Uint8Array>} getBlock\n * @param {AbortOptions} [options]\n */\nexport async function * resolve (cid, path, codecs, getBlock, options) {\n  /**\n   * @param {CID} cid\n   */\n  const load = async (cid) => {\n    const codec = await codecs.getCodec(cid.code)\n    const block = await getBlock(cid, options)\n\n    return codec.decode(block)\n  }\n\n  const parts = path.split('/').filter(Boolean)\n  let value = await load(cid)\n  let lastCid = cid\n\n  // End iteration if there isn't a CID to follow any more\n  while (parts.length) {\n    const key = parts.shift()\n\n    if (!key) {\n      throw errCode(new Error(`Could not resolve path \"${path}\"`), 'ERR_INVALID_PATH')\n    }\n\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      value = value[key]\n\n      yield {\n        value,\n        remainderPath: parts.join('/')\n      }\n    } else {\n      throw errCode(new Error(`no link named \"${key}\" under ${lastCid}`), 'ERR_NO_LINK')\n    }\n\n    const cid = CID.asCID(value)\n\n    if (cid) {\n      lastCid = cid\n      value = await load(value)\n    }\n  }\n\n  yield {\n    value,\n    remainderPath: ''\n  }\n}\n","import { configure } from '../lib/configure.js'\nimport { resolve } from '../lib/resolve.js'\nimport first from 'it-first'\nimport last from 'it-last'\nimport errCode from 'err-code'\nimport { createGet as createBlockGet } from '../block/get.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/dag').API<HTTPClientExtraOptions>} DAGAPI\n */\n\n/**\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @param {import('../types').Options} options\n */\nexport const createGet = (codecs, options) => {\n  const fn = configure((api, opts) => {\n    const getBlock = createBlockGet(opts)\n\n    /**\n     * @type {DAGAPI[\"get\"]}\n     */\n    const get = async (cid, options = {}) => {\n      if (options.path) {\n        const entry = options.localResolve\n          ? await first(resolve(cid, options.path, codecs, getBlock, options))\n          : await last(resolve(cid, options.path, codecs, getBlock, options))\n        /** @type {import('ipfs-core-types/src/dag').GetResult | undefined} - first and last will return undefined when empty */\n        const result = (entry)\n\n        if (!result) {\n          throw errCode(new Error('Not found'), 'ERR_NOT_FOUND')\n        }\n\n        return result\n      }\n\n      const codec = await codecs.getCodec(cid.code)\n      const block = await getBlock(cid, options)\n      const node = codec.decode(block)\n\n      return {\n        value: node,\n        remainderPath: ''\n      }\n    }\n\n    return get\n  })\n\n  return fn(options)\n}\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\nimport { abortSignal } from '../lib/abort-signal.js'\nimport { multipartRequest } from 'ipfs-core-utils/multipart-request'\nimport { CID } from 'multiformats/cid'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/dag').API<HTTPClientExtraOptions>} DAGAPI\n */\n\nexport const createImport = configure(api => {\n  /**\n   * @type {DAGAPI[\"import\"]}\n   */\n  async function * dagImport (source, options = {}) {\n    const controller = new AbortController()\n    const signal = abortSignal(controller.signal, options.signal)\n    const { headers, body } = await multipartRequest(source, controller, options.headers)\n\n    const res = await api.post('dag/import', {\n      signal,\n      headers,\n      body,\n      searchParams: toUrlSearchParams({ 'pin-roots': options.pinRoots })\n    })\n\n    for await (const { Root } of res.ndjson()) {\n      if (Root !== undefined) {\n        const { Cid: { '/': Cid }, PinErrorMsg } = Root\n\n        yield {\n          root: {\n            cid: CID.parse(Cid),\n            pinErrorMsg: PinErrorMsg\n          }\n        }\n      }\n    }\n  }\n\n  return dagImport\n})\n","import { CID } from 'multiformats/cid'\nimport { configure } from '../lib/configure.js'\nimport { multipartRequest } from 'ipfs-core-utils/multipart-request'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\nimport { abortSignal } from '../lib/abort-signal.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/dag').API<HTTPClientExtraOptions>} DAGAPI\n */\n\n/**\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @param {import('../types').Options} options\n */\nexport const createPut = (codecs, options) => {\n  const fn = configure((api) => {\n    /**\n     * @type {DAGAPI[\"put\"]}\n     */\n    const put = async (dagNode, options = {}) => {\n      const settings = {\n        storeCodec: 'dag-cbor',\n        hashAlg: 'sha2-256',\n        ...options\n      }\n\n      let serialized\n\n      if (settings.inputCodec) {\n        // if you supply an inputCodec, we assume you're passing in a raw, encoded\n        // block using that codec, so we'll just pass that on to the server and let\n        // it deal with the decode/encode/store cycle\n        if (!(dagNode instanceof Uint8Array)) {\n          throw new Error('Can only inputCodec on raw bytes that can be decoded')\n        }\n        serialized = dagNode\n      } else {\n        // if you don't supply an inputCodec, we assume you've passed in a JavaScript\n        // object you want to have encoded using storeCodec, so we'll prepare it for\n        // you if we have the codec\n        const storeCodec = await codecs.getCodec(settings.storeCodec)\n        serialized = storeCodec.encode(dagNode)\n        // now we have a serialized form, the server should be told to receive it\n        // in that format\n        settings.inputCodec = settings.storeCodec\n      }\n\n      // allow aborting requests on body errors\n      const controller = new AbortController()\n      const signal = abortSignal(controller.signal, settings.signal)\n\n      const res = await api.post('dag/put', {\n        timeout: settings.timeout,\n        signal,\n        searchParams: toUrlSearchParams(settings),\n        ...(\n          await multipartRequest([serialized], controller, settings.headers)\n        )\n      })\n      const data = await res.json()\n\n      return CID.parse(data.Cid['/'])\n    }\n\n    return put\n  })\n\n  return fn(options)\n}\n","import { CID } from 'multiformats/cid'\nimport { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/dag').API<HTTPClientExtraOptions>} DAGAPI\n */\n\nexport const createResolve = configure(api => {\n  /**\n   * @type {DAGAPI[\"resolve\"]}\n   */\n  const resolve = async (ipfsPath, options = {}) => {\n    const res = await api.post('dag/resolve', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: `${ipfsPath}${options.path ? `/${options.path}`.replace(/\\/[/]+/g, '/') : ''}`,\n        ...options\n      }),\n      headers: options.headers\n    })\n\n    const data = await res.json()\n\n    return { cid: CID.parse(data.Cid['/']), remainderPath: data.RemPath }\n  }\n\n  return resolve\n})\n","import { createExport } from './export.js'\nimport { createGet } from './get.js'\nimport { createImport } from './import.js'\nimport { createPut } from './put.js'\nimport { createResolve } from './resolve.js'\n\n/**\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @param {import('../types').Options} config\n */\nexport function createDag (codecs, config) {\n  return {\n    export: createExport(config),\n    get: createGet(codecs, config),\n    import: createImport(config),\n    put: createPut(codecs, config),\n    resolve: createResolve(config)\n  }\n}\n","\n// Response types are defined here =\n// https://github.com/libp2p/go-libp2p-core/blob/6e566d10f4a5447317a66d64c7459954b969bdab/routing/query.go#L15-L24\nexport const SendingQuery = 0\nexport const PeerResponse = 1\nexport const FinalPeer = 2\nexport const QueryError = 3\nexport const Provider = 4\nexport const Value = 5\nexport const AddingPeer = 6\nexport const DialingPeer = 7\n","import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport {\n  SendingQuery,\n  PeerResponse,\n  FinalPeer,\n  QueryError,\n  Provider,\n  Value,\n  AddingPeer,\n  DialingPeer\n} from './response-types.js'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { peerIdFromString } from '@libp2p/peer-id'\n\n/**\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@multiformats/multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @param {{Type: number, ID: string, Extra: string, Responses: {ID: string, Addrs: string[]}[]}} event\n * @returns {import('ipfs-core-types/src/dht').QueryEvent}\n */\nexport const mapEvent = (event) => {\n  if (event.Type === SendingQuery) {\n    return {\n      name: 'SENDING_QUERY',\n      type: event.Type\n    }\n  }\n\n  if (event.Type === PeerResponse) {\n    return {\n      from: peerIdFromString(event.ID),\n      name: 'PEER_RESPONSE',\n      type: event.Type,\n      // TODO: how to infer this from the go-ipfs response\n      messageType: 0,\n      // TODO: how to infer this from the go-ipfs response\n      messageName: 'PUT_VALUE',\n      closer: (event.Responses || []).map(({ ID, Addrs }) => ({ id: peerIdFromString(ID), multiaddrs: Addrs.map(addr => multiaddr(addr)), protocols: [] })),\n      providers: (event.Responses || []).map(({ ID, Addrs }) => ({ id: peerIdFromString(ID), multiaddrs: Addrs.map(addr => multiaddr(addr)), protocols: [] }))\n      // TODO: how to infer this from the go-ipfs response\n      // record: ???\n    }\n  }\n\n  if (event.Type === FinalPeer) {\n    // dht.query ends with a FinalPeer event with no Responses\n    /** @type {import('@libp2p/interface-peer-info').PeerInfo} */\n    let peer = {\n      // @ts-expect-error go-ipfs does not return this\n      id: event.ID ?? peerIdFromString(event.ID),\n      /** @type {Multiaddr[]} */\n      multiaddrs: [],\n      protocols: []\n    }\n\n    if (event.Responses && event.Responses.length) {\n      // dht.findPeer has the result in the Responses field\n      peer = {\n        id: peerIdFromString(event.Responses[0].ID),\n        multiaddrs: event.Responses[0].Addrs.map(addr => multiaddr(addr)),\n        protocols: []\n      }\n    }\n\n    return {\n      name: 'FINAL_PEER',\n      type: event.Type,\n      peer\n    }\n  }\n\n  if (event.Type === QueryError) {\n    return {\n      name: 'QUERY_ERROR',\n      type: event.Type,\n      error: new Error(event.Extra)\n    }\n  }\n\n  if (event.Type === Provider) {\n    return {\n      name: 'PROVIDER',\n      type: event.Type,\n      providers: event.Responses.map(({ ID, Addrs }) => ({ id: peerIdFromString(ID), multiaddrs: Addrs.map(addr => multiaddr(addr)), protocols: [] }))\n    }\n  }\n\n  if (event.Type === Value) {\n    return {\n      name: 'VALUE',\n      type: event.Type,\n      value: uint8ArrayFromString(event.Extra, 'base64pad')\n    }\n  }\n\n  if (event.Type === AddingPeer) {\n    const peers = event.Responses.map(({ ID }) => peerIdFromString(ID))\n\n    if (!peers.length) {\n      throw new Error('No peer found')\n    }\n\n    return {\n      name: 'ADDING_PEER',\n      type: event.Type,\n      peer: peers[0]\n    }\n  }\n\n  if (event.Type === DialingPeer) {\n    return {\n      name: 'DIALING_PEER',\n      type: event.Type,\n      peer: peerIdFromString(event.ID)\n    }\n  }\n\n  throw new Error('Unknown DHT event type')\n}\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\nimport { mapEvent } from './map-event.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/dht').API<HTTPClientExtraOptions>} DHTAPI\n */\n\nexport const createFindPeer = configure(api => {\n  /**\n   * @type {DHTAPI[\"findPeer\"]}\n   */\n  async function * findPeer (peerId, options = {}) {\n    const res = await api.post('dht/findpeer', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: peerId,\n        ...options\n      }),\n      headers: options.headers\n    })\n\n    for await (const event of res.ndjson()) {\n      yield mapEvent(event)\n    }\n  }\n\n  return findPeer\n})\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\nimport { mapEvent } from './map-event.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/dht').API<HTTPClientExtraOptions>} DHTAPI\n */\n\nexport const createFindProvs = configure(api => {\n  /**\n   * @type {DHTAPI[\"findProvs\"]}\n   */\n  async function * findProvs (cid, options = {}) {\n    const res = await api.post('dht/findprovs', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: cid.toString(),\n        ...options\n      }),\n      headers: options.headers\n    })\n\n    for await (const event of res.ndjson()) {\n      yield mapEvent(event)\n    }\n  }\n\n  return findProvs\n})\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\nimport { mapEvent } from './map-event.js'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/dht').API<HTTPClientExtraOptions>} DHTAPI\n */\n\nexport const createGet = configure(api => {\n  /**\n   * @type {DHTAPI[\"get\"]}\n   */\n  async function * get (key, options = {}) {\n    const res = await api.post('dht/get', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        // arg: base36.encode(key),\n        arg: key instanceof Uint8Array ? uint8ArrayToString(key) : key.toString(),\n        ...options\n      }),\n      headers: options.headers\n    })\n\n    for await (const event of res.ndjson()) {\n      yield mapEvent(event)\n    }\n  }\n\n  return get\n})\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\nimport { mapEvent } from './map-event.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/dht').API<HTTPClientExtraOptions>} DHTAPI\n * @typedef {import('multiformats/cid').CID} CID\n */\n\nexport const createProvide = configure(api => {\n  /**\n   * @type {DHTAPI[\"provide\"]}\n   */\n  async function * provide (cids, options = { recursive: false }) {\n    /** @type {CID[]} */\n    const cidArr = Array.isArray(cids) ? cids : [cids]\n\n    const res = await api.post('dht/provide', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: cidArr.map(cid => cid.toString()),\n        ...options\n      }),\n      headers: options.headers\n    })\n\n    for await (const event of res.ndjson()) {\n      yield mapEvent(event)\n    }\n  }\n\n  return provide\n})\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\nimport { multipartRequest } from 'ipfs-core-utils/multipart-request'\nimport { abortSignal } from '../lib/abort-signal.js'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { mapEvent } from './map-event.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/dht').API<HTTPClientExtraOptions>} DHTAPI\n */\n\nexport const createPut = configure(api => {\n  /**\n   * @type {DHTAPI[\"put\"]}\n   */\n  async function * put (key, value, options = {}) {\n    // allow aborting requests on body errors\n    const controller = new AbortController()\n    const signal = abortSignal(controller.signal, options.signal)\n\n    const res = await api.post('dht/put', {\n      signal,\n      searchParams: toUrlSearchParams({\n        arg: key instanceof Uint8Array ? uint8ArrayToString(key) : key.toString(),\n        ...options\n      }),\n      ...(\n        await multipartRequest([value], controller, options.headers)\n      )\n    })\n\n    for await (const event of res.ndjson()) {\n      yield mapEvent(event)\n    }\n  }\n\n  return put\n})\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\nimport { mapEvent } from './map-event.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/dht').API<HTTPClientExtraOptions>} DHTAPI\n */\n\nexport const createQuery = configure(api => {\n  /**\n   * @type {DHTAPI[\"query\"]}\n   */\n  async function * query (peerId, options = {}) {\n    const res = await api.post('dht/query', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: peerId.toString(),\n        ...options\n      }),\n      headers: options.headers\n    })\n\n    for await (const event of res.ndjson()) {\n      yield mapEvent(event)\n    }\n  }\n\n  return query\n})\n","import { createFindPeer } from './find-peer.js'\nimport { createFindProvs } from './find-provs.js'\nimport { createGet } from './get.js'\nimport { createProvide } from './provide.js'\nimport { createPut } from './put.js'\nimport { createQuery } from './query.js'\n\n/**\n * @param {import('../types').Options} config\n */\nexport function createDht (config) {\n  return {\n    findPeer: createFindPeer(config),\n    findProvs: createFindProvs(config),\n    get: createGet(config),\n    provide: createProvide(config),\n    put: createPut(config),\n    query: createQuery(config)\n  }\n}\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/diag').API<HTTPClientExtraOptions>} DiagAPI\n */\n\nexport const createCmds = configure(api => {\n  /**\n   * @type {DiagAPI[\"cmds\"]}\n   */\n  async function cmds (options = {}) {\n    const res = await api.post('diag/cmds', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams(options),\n      headers: options.headers\n    })\n\n    return res.json()\n  }\n  return cmds\n})\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/diag').API<HTTPClientExtraOptions>} DiagAPI\n */\n\nexport const createNet = configure(api => {\n  /**\n   * @type {DiagAPI[\"net\"]}\n   */\n  async function net (options = {}) {\n    const res = await api.post('diag/net', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams(options),\n      headers: options.headers\n    })\n    return res.json()\n  }\n  return net\n})\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/diag').API<HTTPClientExtraOptions>} DiagAPI\n */\n\nexport const createSys = configure(api => {\n  /**\n   * @type {DiagAPI[\"sys\"]}\n   */\n  async function sys (options = {}) {\n    const res = await api.post('diag/sys', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams(options),\n      headers: options.headers\n    })\n\n    return res.json()\n  }\n  return sys\n})\n","import { createCmds } from './cmds.js'\nimport { createNet } from './net.js'\nimport { createSys } from './sys.js'\n\n/**\n * @param {import('../types').Options} config\n */\nexport function createDiag (config) {\n  return {\n    cmds: createCmds(config),\n    net: createNet(config),\n    sys: createSys(config)\n  }\n}\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/files').API<HTTPClientExtraOptions>} FilesAPI\n */\n\nexport const createChmod = configure(api => {\n  /**\n   * @type {FilesAPI[\"chmod\"]}\n   */\n  async function chmod (path, mode, options = {}) {\n    const res = await api.post('files/chmod', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: path,\n        mode,\n        ...options\n      }),\n      headers: options.headers\n    })\n\n    await res.text()\n  }\n  return chmod\n})\n","import { CID } from 'multiformats/cid'\nimport { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/files').API<HTTPClientExtraOptions>} FilesAPI\n */\n\nexport const createCp = configure(api => {\n  /**\n   * @type {FilesAPI[\"cp\"]}\n   */\n  async function cp (sources, destination, options = {}) {\n    /** @type {import('ipfs-core-types/src/utils').IPFSPath[]} */\n    const sourceArr = Array.isArray(sources) ? sources : [sources]\n\n    const res = await api.post('files/cp', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: sourceArr.concat(destination).map(src => CID.asCID(src) ? `/ipfs/${src}` : src),\n        ...options\n      }),\n      headers: options.headers\n    })\n\n    await res.text()\n  }\n  return cp\n})\n","import { CID } from 'multiformats/cid'\nimport { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/files').API<HTTPClientExtraOptions>} FilesAPI\n */\n\nexport const createFlush = configure(api => {\n  /**\n   * @type {FilesAPI[\"flush\"]}\n   */\n  async function flush (path, options = {}) {\n    if (!path || typeof path !== 'string') {\n      throw new Error('ipfs.files.flush requires a path')\n    }\n\n    const res = await api.post('files/flush', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: path,\n        ...options\n      }),\n      headers: options.headers\n    })\n    const data = await res.json()\n\n    return CID.parse(data.Cid)\n  }\n  return flush\n})\n","import { objectToCamel } from './object-to-camel.js'\n\n/**\n * @param {Record<string, any>} entry\n */\nexport function objectToCamelWithMetadata (entry) {\n  const file = objectToCamel(entry)\n\n  if (Object.prototype.hasOwnProperty.call(file, 'mode')) {\n    file.mode = parseInt(file.mode, 8)\n  }\n\n  if (Object.prototype.hasOwnProperty.call(file, 'mtime')) {\n    file.mtime = {\n      secs: file.mtime,\n      nsecs: file.mtimeNsecs || 0\n    }\n\n    delete file.mtimeNsecs\n  }\n\n  return file\n}\n","import { CID } from 'multiformats/cid'\nimport { objectToCamelWithMetadata } from '../lib/object-to-camel-with-metadata.js'\nimport { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/files').API<HTTPClientExtraOptions>} FilesAPI\n */\nexport const createLs = configure(api => {\n  /**\n   * @type {FilesAPI[\"ls\"]}\n   */\n  async function * ls (path, options = {}) {\n    if (!path) {\n      throw new Error('ipfs.files.ls requires a path')\n    }\n\n    const res = await api.post('files/ls', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: CID.asCID(path) ? `/ipfs/${path}` : path,\n        // default long to true, diverges from go-ipfs where its false by default\n        long: true,\n        ...options,\n        stream: true\n      }),\n      headers: options.headers\n    })\n\n    for await (const result of res.ndjson()) {\n      // go-ipfs does not yet support the \"stream\" option\n      if ('Entries' in result) {\n        for (const entry of result.Entries || []) {\n          yield toCoreInterface(objectToCamelWithMetadata(entry))\n        }\n      } else {\n        yield toCoreInterface(objectToCamelWithMetadata(result))\n      }\n    }\n  }\n  return ls\n})\n\n/**\n * @param {*} entry\n */\nfunction toCoreInterface (entry) {\n  if (entry.hash) {\n    entry.cid = CID.parse(entry.hash)\n  }\n\n  delete entry.hash\n\n  entry.type = entry.type === 1 ? 'directory' : 'file'\n\n  return entry\n}\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/files').API<HTTPClientExtraOptions>} FilesAPI\n */\n\nexport const createMkdir = configure(api => {\n  /**\n   * @type {FilesAPI[\"mkdir\"]}\n   */\n  async function mkdir (path, options = {}) {\n    const res = await api.post('files/mkdir', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: path,\n        ...options\n      }),\n      headers: options.headers\n    })\n\n    await res.text()\n  }\n  return mkdir\n})\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/files').API<HTTPClientExtraOptions>} FilesAPI\n */\n\nexport const createMv = configure(api => {\n  /**\n   * @type {FilesAPI[\"mv\"]}\n   */\n  async function mv (sources, destination, options = {}) {\n    if (!Array.isArray(sources)) {\n      sources = [sources]\n    }\n\n    const res = await api.post('files/mv', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: sources.concat(destination),\n        ...options\n      }),\n      headers: options.headers\n    })\n    await res.text()\n  }\n\n  return mv\n})\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n// @ts-expect-error no types\nimport toIterable from 'stream-to-it/source.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/files').API<HTTPClientExtraOptions>} FilesAPI\n */\n\nexport const createRead = configure(api => {\n  /**\n   * @type {FilesAPI[\"read\"]}\n   */\n  async function * read (path, options = {}) {\n    const res = await api.post('files/read', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: path,\n        count: options.length,\n        ...options\n      }),\n      headers: options.headers\n    })\n\n    yield * toIterable(res.body)\n  }\n  return read\n})\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\nimport HTTP from 'ipfs-utils/src/http.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/files').API<HTTPClientExtraOptions>} FilesAPI\n */\n\nexport const createRm = configure(api => {\n  /**\n   * @type {FilesAPI[\"rm\"]}\n   */\n  async function rm (path, options = {}) {\n    const res = await api.post('files/rm', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: path,\n        ...options\n      }),\n      headers: options.headers\n    })\n\n    const body = await res.text()\n    // we don't expect text body to be ever present\n    // (if so, it means an error such as https://github.com/ipfs/go-ipfs/issues/8606)\n    if (body !== '') {\n      /** @type {Error} */\n      const error = new HTTP.HTTPError(res)\n      error.message = body\n      throw error\n    }\n  }\n  return rm\n})\n","import { CID } from 'multiformats/cid'\nimport { objectToCamelWithMetadata } from '../lib/object-to-camel-with-metadata.js'\nimport { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/files').API<HTTPClientExtraOptions>} FilesAPI\n */\n\nexport const createStat = configure(api => {\n  /**\n   * @type {FilesAPI[\"stat\"]}\n   */\n  async function stat (path, options = {}) {\n    const res = await api.post('files/stat', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: path,\n        ...options\n      }),\n      headers: options.headers\n    })\n    const data = await res.json()\n\n    data.WithLocality = data.WithLocality || false\n    return toCoreInterface(objectToCamelWithMetadata(data))\n  }\n  return stat\n})\n\n/**\n * @param {*} entry\n */\nfunction toCoreInterface (entry) {\n  entry.cid = CID.parse(entry.hash)\n  delete entry.hash\n  return entry\n}\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/files').API<HTTPClientExtraOptions>} FilesAPI\n */\n\nexport const createTouch = configure(api => {\n  /**\n   * @type {FilesAPI[\"touch\"]}\n   */\n  async function touch (path, options = {}) {\n    const res = await api.post('files/touch', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: path,\n        ...options\n      }),\n      headers: options.headers\n    })\n\n    await res.text()\n  }\n  return touch\n})\n","import { modeToString } from '../lib/mode-to-string.js'\nimport { parseMtime } from '../lib/parse-mtime.js'\nimport { configure } from '../lib/configure.js'\nimport { multipartRequest } from 'ipfs-core-utils/multipart-request'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\nimport { abortSignal } from '../lib/abort-signal.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/files').API<HTTPClientExtraOptions>} FilesAPI\n */\n\nexport const createWrite = configure(api => {\n  /**\n   * @type {FilesAPI[\"write\"]}\n   */\n  async function write (path, input, options = {}) {\n    // allow aborting requests on body errors\n    const controller = new AbortController()\n    const signal = abortSignal(controller.signal, options.signal)\n\n    const res = await api.post('files/write', {\n      signal,\n      searchParams: toUrlSearchParams({\n        arg: path,\n        streamChannels: true,\n        count: options.length,\n        ...options\n      }),\n      ...(\n        await multipartRequest([{\n          content: input,\n          path: 'arg',\n          mode: modeToString(options.mode),\n          mtime: parseMtime(options.mtime)\n        }], controller, options.headers)\n      )\n    })\n\n    await res.text()\n  }\n  return write\n})\n","import { createChmod } from './chmod.js'\nimport { createCp } from './cp.js'\nimport { createFlush } from './flush.js'\nimport { createLs } from './ls.js'\nimport { createMkdir } from './mkdir.js'\nimport { createMv } from './mv.js'\nimport { createRead } from './read.js'\nimport { createRm } from './rm.js'\nimport { createStat } from './stat.js'\nimport { createTouch } from './touch.js'\nimport { createWrite } from './write.js'\n\n/**\n * @param {import('../types').Options} config\n */\nexport function createFiles (config) {\n  return {\n    chmod: createChmod(config),\n    cp: createCp(config),\n    flush: createFlush(config),\n    ls: createLs(config),\n    mkdir: createMkdir(config),\n    mv: createMv(config),\n    read: createRead(config),\n    rm: createRm(config),\n    stat: createStat(config),\n    touch: createTouch(config),\n    write: createWrite(config)\n  }\n}\n","import { configure } from '../lib/configure.js'\nimport errCode from 'err-code'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/key').API<HTTPClientExtraOptions>} KeyAPI\n */\n\nexport const createExport = configure(api => {\n  /**\n   * @type {KeyAPI[\"export\"]}\n   */\n  const exportKey = async (name, password, options = {}) => {\n    throw errCode(new Error('Not implemented'), 'ERR_NOT_IMPLEMENTED')\n  }\n\n  return exportKey\n})\n","import { objectToCamel } from '../lib/object-to-camel.js'\nimport { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/key').API<HTTPClientExtraOptions>} KeyAPI\n */\n\nexport const createGen = configure(api => {\n  /**\n   * @type {KeyAPI[\"gen\"]}\n   */\n  async function gen (name, options) {\n    const opts = options ?? { type: 'Ed25519' }\n\n    const res = await api.post('key/gen', {\n      signal: opts.signal,\n      searchParams: toUrlSearchParams({\n        arg: name,\n        ...opts\n      }),\n      headers: opts.headers\n    })\n    const data = await res.json()\n\n    // @ts-expect-error server output is not typed\n    return objectToCamel(data)\n  }\n  return gen\n})\n","import { objectToCamel } from '../lib/object-to-camel.js'\nimport { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/key').API<HTTPClientExtraOptions>} KeyAPI\n */\n\nexport const createImport = configure(api => {\n  /**\n   * @type {KeyAPI[\"import\"]}\n   */\n  async function importKey (name, pem, password, options = {}) {\n    const res = await api.post('key/import', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: name,\n        pem,\n        password,\n        ...options\n      }),\n      headers: options.headers\n    })\n    const data = await res.json()\n\n    // @ts-expect-error server output is not typed\n    return objectToCamel(data)\n  }\n  return importKey\n})\n","import { configure } from '../lib/configure.js'\nimport errCode from 'err-code'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/key').API<HTTPClientExtraOptions>} KeyAPI\n */\n\nexport const createInfo = configure(api => {\n  /**\n   * @type {KeyAPI[\"info\"]}\n   */\n  const info = async (name, options = {}) => {\n    throw errCode(new Error('Not implemented'), 'ERR_NOT_IMPLEMENTED')\n  }\n\n  return info\n})\n","import { objectToCamel } from '../lib/object-to-camel.js'\nimport { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/key').API<HTTPClientExtraOptions>} KeyAPI\n */\n\nexport const createList = configure(api => {\n  /**\n   * @type {KeyAPI[\"list\"]}\n   */\n  async function list (options = {}) {\n    const res = await api.post('key/list', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams(options),\n      headers: options.headers\n    })\n    const data = await res.json()\n\n    return (data.Keys || []).map((/** @type {any} **/ k) => objectToCamel(k))\n  }\n  return list\n})\n","import { objectToCamel } from '../lib/object-to-camel.js'\nimport { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/key').API<HTTPClientExtraOptions>} KeyAPI\n */\n\nexport const createRename = configure(api => {\n  /**\n   * @type {KeyAPI[\"rename\"]}\n   */\n  async function rename (oldName, newName, options = {}) {\n    const res = await api.post('key/rename', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: [\n          oldName,\n          newName\n        ],\n        ...options\n      }),\n      headers: options.headers\n    })\n\n    // @ts-expect-error server output is not typed\n    return objectToCamel(await res.json())\n  }\n  return rename\n})\n","import { objectToCamel } from '../lib/object-to-camel.js'\nimport { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/key').API<HTTPClientExtraOptions>} KeyAPI\n */\n\nexport const createRm = configure(api => {\n  /**\n   * @type {KeyAPI[\"rm\"]}\n   */\n  async function rm (name, options = {}) {\n    const res = await api.post('key/rm', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: name,\n        ...options\n      }),\n      headers: options.headers\n    })\n    const data = await res.json()\n\n    // @ts-expect-error server output is not typed\n    return objectToCamel(data.Keys[0])\n  }\n  return rm\n})\n","import { createExport } from './export.js'\nimport { createGen } from './gen.js'\nimport { createImport } from './import.js'\nimport { createInfo } from './info.js'\nimport { createList } from './list.js'\nimport { createRename } from './rename.js'\nimport { createRm } from './rm.js'\n\n/**\n * @param {import('../types').Options} config\n */\nexport function createKey (config) {\n  return {\n    export: createExport(config),\n    gen: createGen(config),\n    import: createImport(config),\n    info: createInfo(config),\n    list: createList(config),\n    rename: createRename(config),\n    rm: createRm(config)\n  }\n}\n","import { objectToCamel } from '../lib/object-to-camel.js'\nimport { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/log').API<HTTPClientExtraOptions>} LogAPI\n */\n\nexport const createLevel = configure(api => {\n  /**\n   * @type {LogAPI[\"level\"]}\n   */\n  async function level (subsystem, level, options = {}) {\n    const res = await api.post('log/level', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: [\n          subsystem,\n          level\n        ],\n        ...options\n      }),\n      headers: options.headers\n    })\n\n    return objectToCamel(await res.json())\n  }\n  return level\n})\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/log').API<HTTPClientExtraOptions>} LogAPI\n */\n\nexport const createLs = configure(api => {\n  /**\n   * @type {LogAPI[\"ls\"]}\n   */\n  async function ls (options = {}) {\n    const res = await api.post('log/ls', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams(options),\n      headers: options.headers\n    })\n\n    const data = await res.json()\n    return data.Strings\n  }\n  return ls\n})\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/log').API<HTTPClientExtraOptions>} LogAPI\n */\n\nexport const createTail = configure(api => {\n  /**\n   * @type {LogAPI[\"tail\"]}\n   */\n  async function * tail (options = {}) {\n    const res = await api.post('log/tail', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams(options),\n      headers: options.headers\n    })\n\n    yield * res.ndjson()\n  }\n  return tail\n})\n","import { createLevel } from './level.js'\nimport { createLs } from './ls.js'\nimport { createTail } from './tail.js'\n\n/**\n * @param {import('../types').Options} config\n */\nexport function createLog (config) {\n  return {\n    level: createLevel(config),\n    ls: createLs(config),\n    tail: createTail(config)\n  }\n}\n","import { objectToCamel } from '../lib/object-to-camel.js'\nimport { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/name').API<HTTPClientExtraOptions>} NameAPI\n */\n\nexport const createPublish = configure(api => {\n  /**\n   * @type {NameAPI[\"publish\"]}\n   */\n  async function publish (path, options = {}) {\n    const res = await api.post('name/publish', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: `${path}`,\n        ...options\n      }),\n      headers: options.headers\n    })\n\n    // @ts-expect-error server output is not typed\n    return objectToCamel(await res.json())\n  }\n  return publish\n})\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/name').API<HTTPClientExtraOptions>} NameAPI\n */\n\nexport const createResolve = configure(api => {\n  /**\n   * @type {NameAPI[\"resolve\"]}\n   */\n  async function * resolve (path, options = {}) {\n    const res = await api.post('name/resolve', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: path,\n        stream: true,\n        ...options\n      }),\n      headers: options.headers\n    })\n\n    for await (const result of res.ndjson()) {\n      yield result.Path\n    }\n  }\n  return resolve\n})\n","import { objectToCamel } from '../../lib/object-to-camel.js'\nimport { configure } from '../../lib/configure.js'\nimport { toUrlSearchParams } from '../../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/name/pubsub').API<HTTPClientExtraOptions>} NamePubsubAPI\n */\n\nexport const createCancel = configure(api => {\n  /**\n   * @type {NamePubsubAPI[\"cancel\"]}\n   */\n  async function cancel (name, options = {}) {\n    const res = await api.post('name/pubsub/cancel', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: name,\n        ...options\n      }),\n      headers: options.headers\n    })\n\n    // @ts-expect-error server output is not typed\n    return objectToCamel(await res.json())\n  }\n  return cancel\n})\n","import { objectToCamel } from '../../lib/object-to-camel.js'\nimport { configure } from '../../lib/configure.js'\nimport { toUrlSearchParams } from '../../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/name/pubsub').API<HTTPClientExtraOptions>} NamePubsubAPI\n */\n\nexport const createState = configure(api => {\n  /**\n   * @type {NamePubsubAPI[\"state\"]}\n   */\n  async function state (options = {}) {\n    const res = await api.post('name/pubsub/state', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams(options),\n      headers: options.headers\n    })\n\n    // @ts-expect-error server output is not typed\n    return objectToCamel(await res.json())\n  }\n  return state\n})\n","import { configure } from '../../lib/configure.js'\nimport { toUrlSearchParams } from '../../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/name/pubsub').API<HTTPClientExtraOptions>} NamePubsubAPI\n */\n\nexport const createSubs = configure(api => {\n  /**\n   * @type {NamePubsubAPI[\"subs\"]}\n   */\n  async function subs (options = {}) {\n    const res = await api.post('name/pubsub/subs', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams(options),\n      headers: options.headers\n    })\n    const data = await res.json()\n\n    return data.Strings || []\n  }\n  return subs\n})\n","import { createCancel } from './cancel.js'\nimport { createState } from './state.js'\nimport { createSubs } from './subs.js'\n\n/**\n * @param {import('../../types').Options} config\n */\nexport function createPubsub (config) {\n  return {\n    cancel: createCancel(config),\n    state: createState(config),\n    subs: createSubs(config)\n  }\n}\n","import { createPublish } from './publish.js'\nimport { createResolve } from './resolve.js'\nimport { createPubsub } from './pubsub/index.js'\n\n/**\n * @param {import('../types').Options} config\n */\nexport function createName (config) {\n  return {\n    publish: createPublish(config),\n    resolve: createResolve(config),\n    pubsub: createPubsub(config)\n  }\n}\n","import { CID } from 'multiformats/cid'\nimport { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/object').API<HTTPClientExtraOptions>} ObjectAPI\n */\n\nexport const createData = configure(api => {\n  /**\n   * @type {ObjectAPI[\"data\"]}\n   */\n  async function data (cid, options = {}) {\n    const res = await api.post('object/data', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: `${cid instanceof Uint8Array ? CID.decode(cid) : cid}`,\n        ...options\n      }),\n      headers: options.headers\n    })\n    const data = await res.arrayBuffer()\n\n    return new Uint8Array(data, 0, data.byteLength)\n  }\n  return data\n})\n","import { CID } from 'multiformats/cid'\nimport { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/object').API<HTTPClientExtraOptions>} ObjectAPI\n */\n\nexport const createGet = configure(api => {\n  /**\n   * @type {ObjectAPI[\"get\"]}\n   */\n  async function get (cid, options = {}) {\n    const res = await api.post('object/get', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: `${cid instanceof Uint8Array ? CID.decode(cid) : cid}`,\n        dataEncoding: 'base64',\n        ...options\n      }),\n      headers: options.headers\n    })\n    const data = await res.json()\n\n    return {\n      Data: uint8ArrayFromString(data.Data, 'base64pad'),\n      Links: (data.Links || []).map((/** @type {any} */ link) => ({\n        Name: link.Name,\n        Hash: CID.parse(link.Hash),\n        Tsize: link.Size\n      }))\n    }\n  }\n  return get\n})\n","import { CID } from 'multiformats/cid'\nimport { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/object').API<HTTPClientExtraOptions>} ObjectAPI\n */\n\nexport const createLinks = configure(api => {\n  /**\n   * @type {ObjectAPI[\"links\"]}\n   */\n  async function links (cid, options = {}) {\n    const res = await api.post('object/links', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: `${cid instanceof Uint8Array ? CID.decode(cid) : cid}`,\n        ...options\n      }),\n      headers: options.headers\n    })\n    const data = await res.json()\n\n    return (data.Links || []).map((/** @type {any} */ l) => ({\n      Name: l.Name,\n      Tsize: l.Size,\n      Hash: CID.parse(l.Hash)\n    }))\n  }\n  return links\n})\n","import { CID } from 'multiformats/cid'\nimport { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/object').API<HTTPClientExtraOptions>} ObjectAPI\n */\n\nexport const createNew = configure(api => {\n  /**\n   * @type {ObjectAPI[\"new\"]}\n   */\n  async function newObject (options = {}) {\n    const res = await api.post('object/new', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: options.template,\n        ...options\n      }),\n      headers: options.headers\n    })\n\n    const { Hash } = await res.json()\n\n    return CID.parse(Hash)\n  }\n  return newObject\n})\n","import { configure } from '../lib/configure.js'\nimport { createPut as createDagPut } from '../dag/put.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/object').API<HTTPClientExtraOptions>} ObjectAPI\n */\n\n/**\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @param {import('../types').Options} options\n */\nexport const createPut = (codecs, options) => {\n  const fn = configure((api) => {\n    const dagPut = createDagPut(codecs, options)\n\n    /**\n     * @type {ObjectAPI[\"put\"]}\n     */\n    async function put (obj, options = {}) {\n      return dagPut(obj, {\n        ...options,\n        storeCodec: 'dag-pb',\n        hashAlg: 'sha2-256',\n        version: 1\n      })\n    }\n    return put\n  })\n\n  return fn(options)\n}\n","import { CID } from 'multiformats/cid'\nimport { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/object').API<HTTPClientExtraOptions>} ObjectAPI\n */\n\nexport const createStat = configure(api => {\n  /**\n   * @type {ObjectAPI[\"stat\"]}\n   */\n  async function stat (cid, options = {}) {\n    const res = await api.post('object/stat', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: `${cid}`,\n        ...options\n      }),\n      headers: options.headers\n    })\n\n    const output = await res.json()\n\n    return {\n      ...output,\n      Hash: CID.parse(output.Hash)\n    }\n  }\n  return stat\n})\n","import { CID } from 'multiformats/cid'\nimport { configure } from '../../lib/configure.js'\nimport { toUrlSearchParams } from '../../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/object/patch').API<HTTPClientExtraOptions>} ObjectPatchAPI\n */\n\nexport const createAddLink = configure(api => {\n  /**\n   * @type {ObjectPatchAPI[\"addLink\"]}\n   */\n  async function addLink (cid, dLink, options = {}) {\n    const res = await api.post('object/patch/add-link', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: [\n          `${cid}`,\n          // @ts-expect-error loose types\n          dLink.Name || dLink.name || '',\n          // @ts-expect-error loose types\n          (dLink.Hash || dLink.cid || '').toString() || null\n        ],\n        ...options\n      }),\n      headers: options.headers\n    })\n\n    const { Hash } = await res.json()\n\n    return CID.parse(Hash)\n  }\n\n  return addLink\n})\n","import { CID } from 'multiformats/cid'\nimport { multipartRequest } from 'ipfs-core-utils/multipart-request'\nimport { configure } from '../../lib/configure.js'\nimport { toUrlSearchParams } from '../../lib/to-url-search-params.js'\nimport { abortSignal } from '../../lib/abort-signal.js'\n\n/**\n * @typedef {import('../../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/object/patch').API<HTTPClientExtraOptions>} ObjectPatchAPI\n */\n\nexport const createAppendData = configure(api => {\n  /**\n   * @type {ObjectPatchAPI[\"appendData\"]}\n   */\n  async function appendData (cid, data, options = {}) {\n    // allow aborting requests on body errors\n    const controller = new AbortController()\n    const signal = abortSignal(controller.signal, options.signal)\n\n    const res = await api.post('object/patch/append-data', {\n      signal,\n      searchParams: toUrlSearchParams({\n        arg: `${cid}`,\n        ...options\n      }),\n      ...(\n        await multipartRequest([data], controller, options.headers)\n      )\n    })\n\n    const { Hash } = await res.json()\n\n    return CID.parse(Hash)\n  }\n  return appendData\n})\n","import { CID } from 'multiformats/cid'\nimport { configure } from '../../lib/configure.js'\nimport { toUrlSearchParams } from '../../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/object/patch').API<HTTPClientExtraOptions>} ObjectPatchAPI\n */\n\nexport const createRmLink = configure(api => {\n  /**\n   * @type {ObjectPatchAPI[\"rmLink\"]}\n   */\n  async function rmLink (cid, dLink, options = {}) {\n    const res = await api.post('object/patch/rm-link', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: [\n          `${cid}`,\n          // @ts-expect-error loose types\n          dLink.Name || dLink.name || null\n        ],\n        ...options\n      }),\n      headers: options.headers\n    })\n\n    const { Hash } = await res.json()\n\n    return CID.parse(Hash)\n  }\n  return rmLink\n})\n","import { CID } from 'multiformats/cid'\nimport { multipartRequest } from 'ipfs-core-utils/multipart-request'\nimport { configure } from '../../lib/configure.js'\nimport { toUrlSearchParams } from '../../lib/to-url-search-params.js'\nimport { abortSignal } from '../../lib/abort-signal.js'\n\n/**\n * @typedef {import('../../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/object/patch').API<HTTPClientExtraOptions>} ObjectPatchAPI\n */\n\nexport const createSetData = configure(api => {\n  /**\n   * @type {ObjectPatchAPI[\"setData\"]}\n   */\n  async function setData (cid, data, options = {}) {\n    // allow aborting requests on body errors\n    const controller = new AbortController()\n    const signal = abortSignal(controller.signal, options.signal)\n\n    const res = await api.post('object/patch/set-data', {\n      signal,\n      searchParams: toUrlSearchParams({\n        arg: [\n          `${cid}`\n        ],\n        ...options\n      }),\n      ...(\n        await multipartRequest([data], controller, options.headers)\n      )\n    })\n\n    const { Hash } = await res.json()\n\n    return CID.parse(Hash)\n  }\n  return setData\n})\n","import { createAddLink } from './add-link.js'\nimport { createAppendData } from './append-data.js'\nimport { createRmLink } from './rm-link.js'\nimport { createSetData } from './set-data.js'\n\n/**\n * @param {import('../../types').Options} config\n */\nexport function createPatch (config) {\n  return {\n    addLink: createAddLink(config),\n    appendData: createAppendData(config),\n    rmLink: createRmLink(config),\n    setData: createSetData(config)\n  }\n}\n","import { createData } from './data.js'\nimport { createGet } from './get.js'\nimport { createLinks } from './links.js'\nimport { createNew } from './new.js'\nimport { createPut } from './put.js'\nimport { createStat } from './stat.js'\nimport { createPatch } from './patch/index.js'\n\n/**\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @param {import('../types').Options} config\n */\nexport function createObject (codecs, config) {\n  return {\n    data: createData(config),\n    get: createGet(config),\n    links: createLinks(config),\n    new: createNew(config),\n    put: createPut(codecs, config),\n    stat: createStat(config),\n    patch: createPatch(config)\n  }\n}\n","import { CID } from 'multiformats/cid'\nimport { configure } from '../lib/configure.js'\nimport { normaliseInput } from 'ipfs-core-utils/pins/normalise-input'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/pin').API<HTTPClientExtraOptions>} PinAPI\n */\n\nexport const createAddAll = configure(api => {\n  /**\n   * @type {PinAPI[\"addAll\"]}\n   */\n  async function * addAll (source, options = {}) {\n    for await (const { path, recursive, metadata } of normaliseInput(source)) {\n      const res = await api.post('pin/add', {\n        signal: options.signal,\n        searchParams: toUrlSearchParams({\n          ...options,\n          arg: path,\n          recursive,\n          metadata: metadata ? JSON.stringify(metadata) : undefined,\n          stream: true\n        }),\n        headers: options.headers\n      })\n\n      for await (const pin of res.ndjson()) {\n        if (pin.Pins) { // non-streaming response\n          for (const cid of pin.Pins) {\n            yield CID.parse(cid)\n          }\n          continue\n        }\n\n        yield CID.parse(pin)\n      }\n    }\n  }\n  return addAll\n})\n","import { createAddAll } from './add-all.js'\nimport last from 'it-last'\nimport { configure } from '../lib/configure.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/pin').API<HTTPClientExtraOptions>} PinAPI\n */\n\n/**\n * @param {import('../types').Options} config\n */\nexport function createAdd (config) {\n  const all = createAddAll(config)\n\n  return configure(() => {\n    /**\n     * @type {PinAPI[\"add\"]}\n     */\n    async function add (path, options = {}) {\n      // @ts-expect-error last can return undefined\n      return last(all([{\n        path,\n        ...options\n      }], options))\n    }\n    return add\n  })(config)\n}\n","import { CID } from 'multiformats/cid'\nimport { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/pin').API<HTTPClientExtraOptions>} PinAPI\n */\n\n/**\n * @param {string} type\n * @param {string} cid\n * @param {Record<string, string>} metadata\n */\nfunction toPin (type, cid, metadata) {\n  /** @type {import('ipfs-core-types/src/pin').LsResult} */\n  const pin = {\n    type,\n    cid: CID.parse(cid)\n  }\n\n  if (metadata) {\n    pin.metadata = metadata\n  }\n\n  return pin\n}\n\nexport const createLs = configure(api => {\n  /**\n   * @type {PinAPI[\"ls\"]}\n   */\n  async function * ls (options = {}) {\n    /** @type {any[]} */\n    let paths = []\n\n    if (options.paths) {\n      paths = Array.isArray(options.paths) ? options.paths : [options.paths]\n    }\n\n    const res = await api.post('pin/ls', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        ...options,\n        arg: paths.map(path => `${path}`),\n        stream: true\n      }),\n      headers: options.headers\n    })\n\n    for await (const pin of res.ndjson()) {\n      if (pin.Keys) { // non-streaming response\n        for (const cid of Object.keys(pin.Keys)) {\n          yield toPin(pin.Keys[cid].Type, cid, pin.Keys[cid].Metadata)\n        }\n        return\n      }\n\n      yield toPin(pin.Type, pin.Cid, pin.Metadata)\n    }\n  }\n  return ls\n})\n","import { CID } from 'multiformats/cid'\nimport { configure } from '../lib/configure.js'\nimport { normaliseInput } from 'ipfs-core-utils/pins/normalise-input'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/pin').API<HTTPClientExtraOptions>} PinAPI\n */\n\nexport const createRmAll = configure(api => {\n  /**\n   * @type {PinAPI[\"rmAll\"]}\n   */\n  async function * rmAll (source, options = {}) {\n    for await (const { path, recursive } of normaliseInput(source)) {\n      const searchParams = new URLSearchParams(options.searchParams)\n      searchParams.append('arg', `${path}`)\n\n      if (recursive != null) searchParams.set('recursive', String(recursive))\n\n      const res = await api.post('pin/rm', {\n        signal: options.signal,\n        headers: options.headers,\n        searchParams: toUrlSearchParams({\n          ...options,\n          arg: `${path}`,\n          recursive\n        })\n      })\n\n      for await (const pin of res.ndjson()) {\n        if (pin.Pins) { // non-streaming response\n          yield * pin.Pins.map((/** @type {string} */ cid) => CID.parse(cid))\n          continue\n        }\n        yield CID.parse(pin)\n      }\n    }\n  }\n  return rmAll\n})\n","import { createRmAll } from './rm-all.js'\nimport last from 'it-last'\nimport { configure } from '../lib/configure.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/pin').API<HTTPClientExtraOptions>} PinAPI\n */\n\n/**\n * @param {import('../types').Options} config\n */\nexport const createRm = (config) => {\n  const all = createRmAll(config)\n\n  return configure(() => {\n    /**\n     * @type {PinAPI[\"rm\"]}\n     */\n    async function rm (path, options = {}) {\n      // @ts-expect-error last can return undefined\n      return last(all([{\n        path,\n        ...options\n      }], options))\n    }\n    return rm\n  })(config)\n}\n","import { CID } from 'multiformats/cid'\nimport { toUrlSearchParams } from '../../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('ipfs-core-types/src/pin/remote').Pin} Pin\n * @typedef {import('ipfs-core-types/src/pin/remote').AddOptions} AddOptions\n * @typedef {import('ipfs-core-types/src/pin/remote').Query} Query\n * @typedef {import('ipfs-core-types/src/pin/remote').Status} Status\n */\n\n/**\n * @param {object} json\n * @param {string} json.Name\n * @param {string} json.Cid\n * @param {Status} json.Status\n * @returns {Pin}\n */\nexport const decodePin = ({ Name: name, Status: status, Cid: cid }) => {\n  return {\n    cid: CID.parse(cid),\n    name,\n    status\n  }\n}\n\n/**\n * @param {any} service\n * @returns {string}\n */\nexport const encodeService = (service) => {\n  if (typeof service === 'string' && service !== '') {\n    return service\n  } else {\n    throw new TypeError('service name must be passed')\n  }\n}\n\n/**\n * @param {any} cid\n * @returns {string}\n */\nexport const encodeCID = (cid) => {\n  if (CID.asCID(cid)) {\n    return cid.toString()\n  } else {\n    throw new TypeError(`CID instance expected instead of ${typeof cid}`)\n  }\n}\n\n/**\n * @param {Query & { all?: boolean }} query\n * @returns {URLSearchParams}\n */\nexport const encodeQuery = ({ service, cid, name, status, all }) => {\n  const query = toUrlSearchParams({\n    service: encodeService(service),\n    name,\n    force: all ? true : undefined\n  })\n\n  if (cid) {\n    for (const value of cid) {\n      query.append('cid', encodeCID(value))\n    }\n  }\n\n  if (status) {\n    for (const value of status) {\n      query.append('status', value)\n    }\n  }\n\n  return query\n}\n\n/**\n * @param {AddOptions & {cid:CID}} options\n * @returns {URLSearchParams}\n */\nexport const encodeAddParams = ({ cid, service, background, name, origins }) => {\n  const params = toUrlSearchParams({\n    arg: encodeCID(cid),\n    service: encodeService(service),\n    name,\n    background: background ? true : undefined\n  })\n\n  if (origins) {\n    for (const origin of origins) {\n      params.append('origin', origin.toString())\n    }\n  }\n\n  return params\n}\n","import { encodeAddParams, decodePin } from './utils.js'\n\n/**\n * @typedef {import('../../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/pin/remote').API<HTTPClientExtraOptions>} RemotePiningAPI\n */\n\n/**\n * @param {import('../../lib/core').Client} client\n */\nexport function createAdd (client) {\n  /**\n   * @type {RemotePiningAPI[\"add\"]}\n   */\n  async function add (cid, { timeout, signal, headers, ...query }) {\n    const response = await client.post('pin/remote/add', {\n      timeout,\n      signal,\n      headers,\n      searchParams: encodeAddParams({ cid, ...query })\n    })\n\n    return decodePin(await response.json())\n  }\n\n  return add\n}\n","import { encodeQuery, decodePin } from './utils.js'\n\n/**\n * @typedef {import('../../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/pin/remote').API<HTTPClientExtraOptions>} RemotePiningAPI\n */\n\n/**\n * @param {import('../../lib/core').Client} client\n */\nexport function createLs (client) {\n  /**\n   * @type {RemotePiningAPI[\"ls\"]}\n   */\n  async function * ls ({ timeout, signal, headers, ...query }) {\n    const response = await client.post('pin/remote/ls', {\n      timeout,\n      signal,\n      headers,\n      searchParams: encodeQuery(query)\n    })\n\n    for await (const pin of response.ndjson()) {\n      yield decodePin(pin)\n    }\n  }\n\n  return ls\n}\n","import { encodeQuery } from './utils.js'\n\n/**\n * @typedef {import('../../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/pin/remote').API<HTTPClientExtraOptions>} RemotePiningAPI\n */\n\n/**\n * @param {import('../../lib/core').Client} client\n */\nexport function createRm (client) {\n  /**\n   * @type {RemotePiningAPI[\"rm\"]}\n   */\n  async function rm ({ timeout, signal, headers, ...query }) {\n    await client.post('pin/remote/rm', {\n      timeout,\n      signal,\n      headers,\n      searchParams: encodeQuery({\n        ...query,\n        all: false\n      })\n    })\n  }\n\n  return rm\n}\n","import { encodeQuery } from './utils.js'\n\n/**\n * @typedef {import('../../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/pin/remote').API<HTTPClientExtraOptions>} RemotePiningAPI\n */\n\n/**\n * @param {import('../../lib/core').Client} client\n */\nexport function createRmAll (client) {\n  /**\n   * @type {RemotePiningAPI[\"rmAll\"]}\n   */\n  async function rmAll ({ timeout, signal, headers, ...query }) {\n    await client.post('pin/remote/rm', {\n      timeout,\n      signal,\n      headers,\n      searchParams: encodeQuery({\n        ...query,\n        all: true\n      })\n    })\n  }\n\n  return rmAll\n}\n","/**\n * @typedef {import('ipfs-core-types/src/pin/remote/service').RemotePinServiceWithStat} RemotePinServiceWithStat\n */\n\n/**\n * @param {URL} url\n */\nexport function encodeEndpoint (url) {\n  const href = String(url)\n  if (href === 'undefined') {\n    throw Error('endpoint is required')\n  }\n  // Workaround trailing `/` issue in go-ipfs\n  // @see https://github.com/ipfs/go-ipfs/issues/7826\n  return href[href.length - 1] === '/' ? href.slice(0, -1) : href\n}\n\n/**\n * @param {any} json\n * @returns {RemotePinServiceWithStat}\n */\nexport function decodeRemoteService (json) {\n  return {\n    service: json.Service,\n    endpoint: new URL(json.ApiEndpoint),\n    ...(json.Stat && { stat: decodeStat(json.Stat) })\n  }\n}\n\n/**\n * @param {any} json\n * @returns {import('ipfs-core-types/src/pin/remote/service').Stat}\n */\nexport function decodeStat (json) {\n  switch (json.Status) {\n    case 'valid': {\n      const { Pinning, Pinned, Queued, Failed } = json.PinCount\n      return {\n        status: 'valid',\n        pinCount: {\n          queued: Queued,\n          pinning: Pinning,\n          pinned: Pinned,\n          failed: Failed\n        }\n      }\n    }\n    case 'invalid': {\n      return { status: 'invalid' }\n    }\n    default: {\n      return { status: json.Status }\n    }\n  }\n}\n","import { toUrlSearchParams } from '../../../lib/to-url-search-params.js'\nimport { encodeEndpoint } from './utils.js'\n\n/**\n * @typedef {import('../../../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/pin/remote/service').API<HTTPClientExtraOptions>} RemotePiningServiceAPI\n */\n\n/**\n * @param {import('../../../lib/core').Client} client\n */\nexport function createAdd (client) {\n  /**\n   * @type {RemotePiningServiceAPI[\"add\"]}\n   */\n  async function add (name, options) {\n    const { endpoint, key, headers, timeout, signal } = options\n\n    await client.post('pin/remote/service/add', {\n      timeout,\n      signal,\n      searchParams: toUrlSearchParams({\n        arg: [name, encodeEndpoint(endpoint), key]\n      }),\n      headers\n    })\n  }\n\n  return add\n}\n","import { toUrlSearchParams } from '../../../lib/to-url-search-params.js'\nimport { decodeRemoteService } from './utils.js'\n\n/**\n * @typedef {import('../../../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/pin/remote/service').API<HTTPClientExtraOptions>} RemotePiningServiceAPI\n */\n\n/**\n * @param {import('../../../lib/core').Client} client\n */\nexport function createLs (client) {\n  /**\n   * @type {RemotePiningServiceAPI[\"ls\"]}\n   */\n  async function ls (options = {}) {\n    // @ts-expect-error cannot derive option type from typedef\n    const { stat, headers, timeout, signal } = options\n\n    const response = await client.post('pin/remote/service/ls', {\n      timeout,\n      signal,\n      headers,\n      searchParams: stat === true ? toUrlSearchParams({ stat }) : undefined\n    })\n\n    /** @type {{RemoteServices: object[]}} */\n    const { RemoteServices } = await response.json()\n\n    return RemoteServices.map(decodeRemoteService)\n  }\n\n  return ls\n}\n","import { toUrlSearchParams } from '../../../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../../../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/pin/remote/service').API<HTTPClientExtraOptions>} RemotePiningServiceAPI\n */\n\n/**\n * @param {import('../../../lib/core').Client} client\n */\nexport function createRm (client) {\n  /**\n   * @type {RemotePiningServiceAPI[\"rm\"]}\n   */\n  async function rm (name, options = {}) {\n    await client.post('pin/remote/service/rm', {\n      signal: options.signal,\n      headers: options.headers,\n      searchParams: toUrlSearchParams({\n        arg: name\n      })\n    })\n  }\n\n  return rm\n}\n","import { Client } from '../../../lib/core.js'\nimport { createAdd } from './add.js'\nimport { createLs } from './ls.js'\nimport { createRm } from './rm.js'\n\n/**\n * @param {import('../../../types').Options} config\n */\nexport function createService (config) {\n  const client = new Client(config)\n\n  return {\n    add: createAdd(client),\n    ls: createLs(client),\n    rm: createRm(client)\n  }\n}\n","import { Client } from '../../lib/core.js'\nimport { createAdd } from './add.js'\nimport { createLs } from './ls.js'\nimport { createRm } from './rm.js'\nimport { createRmAll } from './rm-all.js'\nimport { createService } from './service/index.js'\n\n/**\n * @param {import('../../types').Options} config\n */\nexport function createRemote (config) {\n  const client = new Client(config)\n\n  return {\n    add: createAdd(client),\n    ls: createLs(client),\n    rm: createRm(client),\n    rmAll: createRmAll(client),\n    service: createService(config)\n  }\n}\n","import { createAddAll } from './add-all.js'\nimport { createAdd } from './add.js'\nimport { createLs } from './ls.js'\nimport { createRmAll } from './rm-all.js'\nimport { createRm } from './rm.js'\nimport { createRemote } from './remote/index.js'\n\n/**\n * @param {import('../types').Options} config\n */\nexport function createPin (config) {\n  return {\n    addAll: createAddAll(config),\n    add: createAdd(config),\n    ls: createLs(config),\n    rmAll: createRmAll(config),\n    rm: createRm(config),\n    remote: createRemote(config)\n  }\n}\n","import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { base64url } from 'multiformats/bases/base64'\n\n/* HTTP RPC:\n * - wraps binary data in multibase. base64url is used to avoid issues\n *   when a binary data is passed as search param in URL.\n *   Historical context: https://github.com/ipfs/go-ipfs/issues/7939\n *   Multibase wrapping introduced in: https://github.com/ipfs/go-ipfs/pull/8183\n */\n\n/**\n * @param {Array<string>} strings\n * @returns {Array<string>} strings\n */\nconst rpcArrayToTextArray = strings => {\n  if (Array.isArray(strings)) {\n    return strings.map(rpcToText)\n  }\n  return strings\n}\n\n/**\n * @param {string} mb\n * @returns {string}\n */\nconst rpcToText = mb => uint8ArrayToString(rpcToBytes(mb))\n\n/**\n * @param {string} mb\n * @returns {Uint8Array}\n */\nconst rpcToBytes = mb => base64url.decode(mb)\n\n/**\n * @param {string} mb\n * @returns {bigint}\n */\nconst rpcToBigInt = mb => BigInt(`0x${uint8ArrayToString(base64url.decode(mb), 'base16')}`)\n\n/**\n * @param {string} text\n * @returns {string}\n */\nconst textToUrlSafeRpc = text => base64url.encode(uint8ArrayFromString(text))\n\nexport { rpcArrayToTextArray, rpcToText, rpcToBytes, rpcToBigInt, textToUrlSafeRpc }\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\nimport { rpcArrayToTextArray } from '../lib/http-rpc-wire-format.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/pubsub').API<HTTPClientExtraOptions>} PubsubAPI\n */\n\nexport const createLs = configure(api => {\n  /**\n   * @type {PubsubAPI[\"ls\"]}\n   */\n  async function ls (options = {}) {\n    const { Strings } = await (await api.post('pubsub/ls', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams(options),\n      headers: options.headers\n    })).json()\n\n    return rpcArrayToTextArray(Strings) || []\n  }\n  return ls\n})\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\nimport { textToUrlSafeRpc } from '../lib/http-rpc-wire-format.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/pubsub').API<HTTPClientExtraOptions>} PubsubAPI\n */\n\nexport const createPeers = configure(api => {\n  /**\n   * @type {PubsubAPI[\"peers\"]}\n   */\n  async function peers (topic, options = {}) {\n    const res = await api.post('pubsub/peers', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: textToUrlSafeRpc(topic),\n        ...options\n      }),\n      headers: options.headers\n    })\n\n    const { Strings } = await res.json()\n\n    return Strings || []\n  }\n  return peers\n})\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\nimport { multipartRequest } from 'ipfs-core-utils/multipart-request'\nimport { abortSignal } from '../lib/abort-signal.js'\nimport { textToUrlSafeRpc } from '../lib/http-rpc-wire-format.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/pubsub').API<HTTPClientExtraOptions>} PubsubAPI\n */\n\nexport const createPublish = configure(api => {\n  /**\n   * @type {PubsubAPI[\"publish\"]}\n   */\n  async function publish (topic, data, options = {}) {\n    const searchParams = toUrlSearchParams({\n      arg: textToUrlSafeRpc(topic),\n      ...options\n    })\n\n    // allow aborting requests on body errors\n    const controller = new AbortController()\n    const signal = abortSignal(controller.signal, options.signal)\n\n    const res = await api.post('pubsub/pub', {\n      signal,\n      searchParams,\n      ...(\n        await multipartRequest([data], controller, options.headers)\n      )\n    })\n\n    await res.text()\n  }\n  return publish\n})\n","import { logger } from '@libp2p/logger'\nimport { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\nimport { textToUrlSafeRpc, rpcToText, rpcToBytes, rpcToBigInt } from '../lib/http-rpc-wire-format.js'\nimport { peerIdFromString } from '@libp2p/peer-id'\nconst log = logger('ipfs-http-client:pubsub:subscribe')\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('@libp2p/interface-pubsub').Message} Message\n * @typedef {(err: Error, fatal: boolean, msg?: Message) => void} ErrorHandlerFn\n * @typedef {import('ipfs-core-types/src/pubsub').API<HTTPClientExtraOptions & { onError?: ErrorHandlerFn }>} PubsubAPI\n * @typedef {import('../types').Options} Options\n */\n\n/**\n * @param {Options} options\n * @param {import('./subscription-tracker').SubscriptionTracker} subsTracker\n */\nexport const createSubscribe = (options, subsTracker) => {\n  return configure((api) => {\n    /**\n     * @type {PubsubAPI[\"subscribe\"]}\n     */\n    async function subscribe (topic, handler, options = {}) { // eslint-disable-line require-await\n      options.signal = subsTracker.subscribe(topic, handler, options.signal)\n\n      /** @type {(value?: any) => void} */\n      let done\n      /** @type {(error: Error) => void} */\n      let fail\n\n      const result = new Promise((resolve, reject) => {\n        done = resolve\n        fail = reject\n      })\n\n      // In Firefox, the initial call to fetch does not resolve until some data\n      // is received. If this doesn't happen within 1 second assume success\n      const ffWorkaround = setTimeout(() => done(), 1000)\n\n      // Do this async to not block Firefox\n      api.post('pubsub/sub', {\n        signal: options.signal,\n        searchParams: toUrlSearchParams({\n          arg: textToUrlSafeRpc(topic),\n          ...options\n        }),\n        headers: options.headers\n      })\n        .catch((err) => {\n          // Initial subscribe fail, ensure we clean up\n          subsTracker.unsubscribe(topic, handler)\n\n          fail(err)\n        })\n        .then((response) => {\n          clearTimeout(ffWorkaround)\n\n          if (!response) {\n            // if there was no response, the subscribe failed\n            return\n          }\n\n          readMessages(response, {\n            onMessage: (message) => {\n              if (!handler) {\n                return\n              }\n\n              if (typeof handler === 'function') {\n                handler(message)\n                return\n              }\n\n              if (typeof handler.handleEvent === 'function') {\n                handler.handleEvent(message)\n              }\n            },\n            onEnd: () => subsTracker.unsubscribe(topic, handler),\n            onError: options.onError\n          })\n\n          done()\n        })\n\n      return result\n    }\n    return subscribe\n  })(options)\n}\n\n/**\n * @param {import('ipfs-utils/src/types').ExtendedResponse} response\n * @param {object} options\n * @param {(message: Message) => void} options.onMessage\n * @param {() => void} options.onEnd\n * @param {ErrorHandlerFn} [options.onError]\n */\nasync function readMessages (response, { onMessage, onEnd, onError }) {\n  onError = onError || log\n\n  try {\n    for await (const msg of response.ndjson()) {\n      try {\n        if (!msg.from) {\n          continue\n        }\n\n        if (msg.from != null && msg.seqno != null) {\n          onMessage({\n            type: 'signed',\n            from: peerIdFromString(msg.from),\n            data: rpcToBytes(msg.data),\n            sequenceNumber: rpcToBigInt(msg.seqno),\n            topic: rpcToText(msg.topicIDs[0]),\n            key: rpcToBytes(msg.key ?? 'u'),\n            signature: rpcToBytes(msg.signature ?? 'u')\n          })\n        } else {\n          onMessage({\n            type: 'unsigned',\n            data: rpcToBytes(msg.data),\n            topic: rpcToText(msg.topicIDs[0])\n          })\n        }\n      } catch (/** @type {any} */ err) {\n        err.message = `Failed to parse pubsub message: ${err.message}`\n        onError(err, false, msg) // Not fatal\n      }\n    }\n  } catch (/** @type {any} */ err) {\n    if (!isAbortError(err)) {\n      onError(err, true) // Fatal\n    }\n  } finally {\n    onEnd()\n  }\n}\n\n/**\n * @param {Error & {type?:string}} error\n * @returns {boolean}\n */\nconst isAbortError = error => {\n  switch (error.type) {\n    case 'aborted':\n      return true\n    // It is `abort` in Electron instead of `aborted`\n    case 'abort':\n      return true\n    default:\n      // FIXME: In testing with Chrome, err.type is undefined (should not be!)\n      // Temporarily use the name property instead.\n      return error.name === 'AbortError'\n  }\n}\n","\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/pubsub').API<HTTPClientExtraOptions>} PubsubAPI\n * @typedef {import('../types').Options} Options\n */\n\n/**\n * @param {Options} options\n * @param {import('./subscription-tracker').SubscriptionTracker} subsTracker\n */\nexport const createUnsubscribe = (options, subsTracker) => {\n  /**\n   * @type {PubsubAPI[\"unsubscribe\"]}\n   */\n  async function unsubscribe (topic, handler) {\n    subsTracker.unsubscribe(topic, handler)\n  }\n  return unsubscribe\n}\n","\n/**\n * @typedef {import('@libp2p/interface-pubsub').Message} Message\n * @typedef {import('@libp2p/interfaces/events').EventHandler<Message>} MessageHandlerFn\n *\n * @typedef {object} Subscription\n * @property {MessageHandlerFn} handler\n * @property {AbortController} controller\n */\n\nexport class SubscriptionTracker {\n  constructor () {\n    /** @type {Map<string, Subscription[]>} */\n    this._subs = new Map()\n  }\n\n  /**\n   * @param {string} topic\n   * @param {MessageHandlerFn} handler\n   * @param {AbortSignal} [signal]\n   */\n  subscribe (topic, handler, signal) {\n    const topicSubs = this._subs.get(topic) || []\n\n    if (topicSubs.find(s => s.handler === handler)) {\n      throw new Error(`Already subscribed to ${topic} with this handler`)\n    }\n\n    // Create controller so a call to unsubscribe can cancel the request\n    const controller = new AbortController()\n\n    this._subs.set(topic, [{ handler, controller }].concat(topicSubs))\n\n    // If there is an external signal, forward the abort event\n    if (signal) {\n      signal.addEventListener('abort', () => this.unsubscribe(topic, handler))\n    }\n\n    return controller.signal\n  }\n\n  /**\n   * @param {string} topic\n   * @param {MessageHandlerFn} [handler]\n   */\n  unsubscribe (topic, handler) {\n    const subs = this._subs.get(topic) || []\n    let unsubs\n\n    if (handler) {\n      this._subs.set(topic, subs.filter(s => s.handler !== handler))\n      unsubs = subs.filter(s => s.handler === handler)\n    } else {\n      this._subs.set(topic, [])\n      unsubs = subs\n    }\n\n    if (!(this._subs.get(topic) || []).length) {\n      this._subs.delete(topic)\n    }\n\n    unsubs.forEach(s => s.controller.abort())\n  }\n}\n","import { createLs } from './ls.js'\nimport { createPeers } from './peers.js'\nimport { createPublish } from './publish.js'\nimport { createSubscribe } from './subscribe.js'\nimport { createUnsubscribe } from './unsubscribe.js'\nimport { SubscriptionTracker } from './subscription-tracker.js'\n\n/**\n * @param {import('../types').Options} config\n */\nexport function createPubsub (config) {\n  const subscriptionTracker = new SubscriptionTracker()\n\n  return {\n    ls: createLs(config),\n    peers: createPeers(config),\n    publish: createPublish(config),\n    subscribe: createSubscribe(config, subscriptionTracker),\n    unsubscribe: createUnsubscribe(config, subscriptionTracker)\n  }\n}\n","import { objectToCamel } from '../lib/object-to-camel.js'\nimport { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/refs').API<HTTPClientExtraOptions>} RefsAPI\n */\n\nexport const createLocal = configure(api => {\n  /**\n   * @type {RefsAPI[\"local\"]}\n   */\n  async function * refsLocal (options = {}) {\n    const res = await api.post('refs/local', {\n      signal: options.signal,\n      transform: objectToCamel,\n      searchParams: toUrlSearchParams(options),\n      headers: options.headers\n    })\n\n    yield * res.ndjson()\n  }\n  return refsLocal\n})\n","import { CID } from 'multiformats/cid'\nimport { objectToCamel } from '../lib/object-to-camel.js'\nimport { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\nimport { createLocal } from './local.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/refs').API<HTTPClientExtraOptions>} RefsAPI\n */\n\nexport const createRefs = configure((api, opts) => {\n  /**\n   * @type {RefsAPI[\"refs\"]}\n   */\n  const refs = async function * (args, options = {}) {\n    /** @type {import('ipfs-core-types/src/utils').IPFSPath[]} */\n    const argsArr = Array.isArray(args) ? args : [args]\n\n    const res = await api.post('refs', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: argsArr.map(arg => `${arg instanceof Uint8Array ? CID.decode(arg) : arg}`),\n        ...options\n      }),\n      headers: options.headers,\n      transform: objectToCamel\n    })\n\n    yield * res.ndjson()\n  }\n\n  return Object.assign(refs, {\n    local: createLocal(opts)\n  })\n})\n","import { CID } from 'multiformats/cid'\nimport { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/repo').API<HTTPClientExtraOptions>} RepoAPI\n */\n\nexport const createGc = configure(api => {\n  /**\n   * @type {RepoAPI[\"gc\"]}\n   */\n  async function * gc (options = {}) {\n    const res = await api.post('repo/gc', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams(options),\n      headers: options.headers,\n      transform: (res) => {\n        return {\n          err: res.Error ? new Error(res.Error) : null,\n          cid: (res.Key || {})['/'] ? CID.parse(res.Key['/']) : null\n        }\n      }\n    })\n\n    yield * res.ndjson()\n  }\n  return gc\n})\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/repo').API<HTTPClientExtraOptions>} RepoAPI\n */\n\nexport const createStat = configure(api => {\n  /**\n   * @type {RepoAPI[\"stat\"]}\n   */\n  async function stat (options = {}) {\n    const res = await api.post('repo/stat', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams(options),\n      headers: options.headers\n    })\n    const data = await res.json()\n\n    return {\n      numObjects: BigInt(data.NumObjects),\n      repoSize: BigInt(data.RepoSize),\n      repoPath: data.RepoPath,\n      version: data.Version,\n      storageMax: BigInt(data.StorageMax)\n    }\n  }\n  return stat\n})\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/repo').API<HTTPClientExtraOptions>} RepoAPI\n */\n\nexport const createVersion = configure(api => {\n  /**\n   * @type {RepoAPI[\"version\"]}\n   */\n  async function version (options = {}) {\n    const res = await (await api.post('repo/version', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams(options),\n      headers: options.headers\n    })).json()\n\n    return res.Version\n  }\n  return version\n})\n","import { createGc } from './gc.js'\nimport { createStat } from './stat.js'\nimport { createVersion } from './version.js'\n\n/**\n * @param {import('../types').Options} config\n */\nexport function createRepo (config) {\n  return {\n    gc: createGc(config),\n    stat: createStat(config),\n    version: createVersion(config)\n  }\n}\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/stats').API<HTTPClientExtraOptions>} StatsAPI\n */\n\nexport const createBw = configure(api => {\n  /**\n   * @type {StatsAPI[\"bw\"]}\n   */\n  async function * bw (options = {}) {\n    const res = await api.post('stats/bw', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams(options),\n      headers: options.headers,\n      transform: (stats) => ({\n        totalIn: BigInt(stats.TotalIn),\n        totalOut: BigInt(stats.TotalOut),\n        rateIn: parseFloat(stats.RateIn),\n        rateOut: parseFloat(stats.RateOut)\n      })\n    })\n\n    yield * res.ndjson()\n  }\n  return bw\n})\n","import { createStat as createBitswap } from '../bitswap/stat.js'\nimport { createStat as createRepo } from '../repo/stat.js'\nimport { createBw } from './bw.js'\n\n/**\n * @param {import('../types').Options} config\n */\nexport function createStats (config) {\n  return {\n    bitswap: createBitswap(config),\n    repo: createRepo(config),\n    bw: createBw(config)\n  }\n}\n","import { multiaddr } from '@multiformats/multiaddr'\nimport { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\nimport { peerIdFromString } from '@libp2p/peer-id'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/swarm').API<HTTPClientExtraOptions>} SwarmAPI\n */\n\nexport const createAddrs = configure(api => {\n  /**\n   * @type {SwarmAPI[\"addrs\"]}\n   */\n  async function addrs (options = {}) {\n    const res = await api.post('swarm/addrs', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams(options),\n      headers: options.headers\n    })\n\n    /** @type {{ Addrs: Record<string, string[]> }} */\n    const { Addrs } = await res.json()\n\n    return Object.keys(Addrs).map(id => ({\n      id: peerIdFromString(id),\n      addrs: (Addrs[id] || []).map(a => multiaddr(a))\n    }))\n  }\n  return addrs\n})\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/swarm').API<HTTPClientExtraOptions>} SwarmAPI\n */\n\nexport const createConnect = configure(api => {\n  /**\n   * @type {SwarmAPI[\"connect\"]}\n   */\n  async function connect (addr, options = {}) {\n    const res = await api.post('swarm/connect', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: addr,\n        ...options\n      }),\n      headers: options.headers\n    })\n    const { Strings } = await res.json()\n\n    return Strings || []\n  }\n  return connect\n})\n","import { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/swarm').API<HTTPClientExtraOptions>} SwarmAPI\n */\n\nexport const createDisconnect = configure(api => {\n  /**\n   * @type {SwarmAPI[\"disconnect\"]}\n   */\n  async function disconnect (addr, options = {}) {\n    const res = await api.post('swarm/disconnect', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: addr,\n        ...options\n      }),\n      headers: options.headers\n    })\n    const { Strings } = await res.json()\n\n    return Strings || []\n  }\n  return disconnect\n})\n","import { multiaddr } from '@multiformats/multiaddr'\nimport { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/swarm').API<HTTPClientExtraOptions>} SwarmAPI\n */\n\nexport const createLocalAddrs = configure(api => {\n  /**\n   * @type {SwarmAPI[\"localAddrs\"]}\n   */\n  async function localAddrs (options = {}) {\n    const res = await api.post('swarm/addrs/local', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams(options),\n      headers: options.headers\n    })\n\n    /** @type {{ Strings: string[] }} */\n    const { Strings } = await res.json()\n\n    return (Strings || []).map(a => multiaddr(a))\n  }\n  return localAddrs\n})\n","import { multiaddr } from '@multiformats/multiaddr'\nimport { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\nimport { peerIdFromString } from '@libp2p/peer-id'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/swarm').API<HTTPClientExtraOptions>} SwarmAPI\n */\n\nexport const createPeers = configure(api => {\n  /**\n   * @type {SwarmAPI[\"peers\"]}\n   */\n  async function peers (options = {}) {\n    const res = await api.post('swarm/peers', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams(options),\n      headers: options.headers\n    })\n\n    /** @type {{ Peers: { Peer: string, Addr: string, Muxer?: string, Latency?: string, Streams?: string[], Direction?: 0 | 1 }[] }} */\n    const { Peers } = await res.json()\n\n    return (Peers || []).map(peer => {\n      return {\n        addr: multiaddr(peer.Addr),\n        peer: peerIdFromString(peer.Peer),\n        muxer: peer.Muxer,\n        latency: peer.Latency,\n        streams: peer.Streams,\n        direction: peer.Direction == null ? undefined : peer.Direction === 0 ? 'inbound' : 'outbound'\n      }\n    })\n  }\n  return peers\n})\n","import { createAddrs } from './addrs.js'\nimport { createConnect } from './connect.js'\nimport { createDisconnect } from './disconnect.js'\nimport { createLocalAddrs } from './local-addrs.js'\nimport { createPeers } from './peers.js'\n\n/**\n * @param {import('../types').Options} config\n */\nexport function createSwarm (config) {\n  return {\n    addrs: createAddrs(config),\n    connect: createConnect(config),\n    disconnect: createDisconnect(config),\n    localAddrs: createLocalAddrs(config),\n    peers: createPeers(config)\n  }\n}\n","import { CID } from 'multiformats/cid'\nimport { objectToCamel } from './lib/object-to-camel.js'\nimport { configure } from './lib/configure.js'\nimport { multipartRequest } from 'ipfs-core-utils/multipart-request'\nimport { toUrlSearchParams } from './lib/to-url-search-params.js'\nimport { abortSignal } from './lib/abort-signal.js'\n\n/**\n * @typedef {import('ipfs-utils/src/types').ProgressFn} IPFSUtilsHttpUploadProgressFn\n * @typedef {import('ipfs-core-types/src/root').AddProgressFn} IPFSCoreAddProgressFn\n * @typedef {import('./types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/root').API<HTTPClientExtraOptions>} RootAPI\n * @typedef {import('ipfs-core-types/src/root').AddResult} AddResult\n */\n\nexport const createAddAll = configure((api) => {\n  /**\n   * @type {RootAPI[\"addAll\"]}\n   */\n  async function * addAll (source, options = {}) {\n    // allow aborting requests on body errors\n    const controller = new AbortController()\n    const signal = abortSignal(controller.signal, options.signal)\n    const { headers, body, total, parts } =\n      await multipartRequest(source, controller, options.headers)\n\n    // In browser response body only starts streaming once upload is\n    // complete, at which point all the progress updates are invalid. If\n    // length of the content is computable we can interpret progress from\n    // `{ total, loaded}` passed to `onUploadProgress` and `multipart.total`\n    // in which case we disable progress updates to be written out.\n    const [progressFn, onUploadProgress] = typeof options.progress === 'function'\n      ? createProgressHandler(total, parts, options.progress)\n      : [undefined, undefined]\n\n    const res = await api.post('add', {\n      searchParams: toUrlSearchParams({\n        'stream-channels': true,\n        ...options,\n        progress: Boolean(progressFn)\n      }),\n      onUploadProgress,\n      signal,\n      headers,\n      body\n    })\n\n    for await (let file of res.ndjson()) {\n      file = objectToCamel(file)\n\n      if (file.hash !== undefined) {\n        yield toCoreInterface(file)\n      } else if (progressFn) {\n        progressFn(file.bytes || 0, file.name)\n      }\n    }\n  }\n  return addAll\n})\n\n/**\n * Returns simple progress callback when content length isn't computable or a\n * progress event handler that calculates progress from upload progress events.\n *\n * @param {number} total\n * @param {{name:string, start:number, end:number}[]|null} parts\n * @param {IPFSCoreAddProgressFn} progress\n * @returns {[IPFSCoreAddProgressFn|undefined, IPFSUtilsHttpUploadProgressFn|undefined]}\n */\nconst createProgressHandler = (total, parts, progress) =>\n  parts ? [undefined, createOnUploadProgress(total, parts, progress)] : [progress, undefined]\n\n/**\n * Creates a progress handler that interpolates progress from upload progress\n * events and total size of the content that is added.\n *\n * @param {number} size - actual content size\n * @param {{name:string, start:number, end:number}[]} parts\n * @param {IPFSCoreAddProgressFn} progress\n * @returns {IPFSUtilsHttpUploadProgressFn}\n */\nconst createOnUploadProgress = (size, parts, progress) => {\n  let index = 0\n  const count = parts.length\n  return ({ loaded, total }) => {\n    // Derive position from the current progress.\n    const position = Math.floor(loaded / total * size)\n    while (index < count) {\n      const { start, end, name } = parts[index]\n      // If within current part range report progress and break the loop\n      if (position < end) {\n        progress(position - start, name)\n        break\n      // If passed current part range report final byte for the chunk and\n      // move to next one.\n      } else {\n        progress(end - start, name)\n        index += 1\n      }\n    }\n  }\n}\n\n/**\n * @param {object} input\n * @param {string} input.name\n * @param {string} input.hash\n * @param {string} input.size\n * @param {string} [input.mode]\n * @param {number} [input.mtime]\n * @param {number} [input.mtimeNsecs]\n */\nfunction toCoreInterface ({ name, hash, size, mode, mtime, mtimeNsecs }) {\n  /** @type {AddResult} */\n  const output = {\n    path: name,\n    cid: CID.parse(hash),\n    size: parseInt(size)\n  }\n\n  if (mode != null) {\n    output.mode = parseInt(mode, 8)\n  }\n\n  if (mtime != null) {\n    output.mtime = {\n      secs: mtime,\n      nsecs: mtimeNsecs || 0\n    }\n  }\n\n  return output\n}\n","import { createAddAll } from './add-all.js'\nimport last from 'it-last'\nimport { configure } from './lib/configure.js'\nimport { normaliseInput } from 'ipfs-core-utils/files/normalise-input-single'\n\n/**\n * @typedef {import('./types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/root').API<HTTPClientExtraOptions>} RootAPI\n */\n\n/**\n * @param {import('./types').Options} options\n */\nexport function createAdd (options) {\n  const all = createAddAll(options)\n  return configure(() => {\n    /**\n     * @type {RootAPI[\"add\"]}\n     */\n    async function add (input, options = {}) {\n      // @ts-expect-error - last may return undefined if source is empty\n      return await last(all(normaliseInput(input), options))\n    }\n    return add\n  })(options)\n}\n","import { configure } from './lib/configure.js'\nimport { toUrlSearchParams } from './lib/to-url-search-params.js'\n\n/**\n * @typedef {import('./types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/root').API<HTTPClientExtraOptions>} RootAPI\n */\n\nexport const createCat = configure(api => {\n  /**\n   * @type {RootAPI[\"cat\"]}\n   */\n  async function * cat (path, options = {}) {\n    const res = await api.post('cat', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: path.toString(),\n        ...options\n      }),\n      headers: options.headers\n    })\n\n    yield * res.iterator()\n  }\n\n  return cat\n})\n","import { configure } from './lib/configure.js'\nimport { toUrlSearchParams } from './lib/to-url-search-params.js'\n\n/**\n * @typedef {import('./types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/root').API<HTTPClientExtraOptions>} RootAPI\n */\n\nexport const createCommands = configure(api => {\n  /**\n   * @type {RootAPI[\"commands\"]}\n   */\n  const commands = async (options = {}) => {\n    const res = await api.post('commands', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams(options),\n      headers: options.headers\n    })\n\n    return res.json()\n  }\n  return commands\n})\n","import { configure } from './lib/configure.js'\nimport { toUrlSearchParams } from './lib/to-url-search-params.js'\n\n/**\n * @typedef {import('./types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/root').API<HTTPClientExtraOptions>} RootAPI\n */\n\nexport const createDns = configure(api => {\n  /**\n   * @type {RootAPI[\"dns\"]}\n   */\n  const dns = async (domain, options = {}) => {\n    const res = await api.post('dns', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: domain,\n        ...options\n      }),\n      headers: options.headers\n    })\n    const data = await res.json()\n\n    return data.Path\n  }\n\n  return dns\n})\n","import { configure } from './lib/configure.js'\n\nexport const createGetEndpointConfig = configure(api => {\n  return () => {\n    const url = new URL(api.opts.base || '')\n    return {\n      host: url.hostname,\n      port: url.port,\n      protocol: url.protocol,\n      pathname: url.pathname,\n      'api-path': url.pathname\n    }\n  }\n})\n","import { CID } from 'multiformats/cid'\nimport { configure } from './lib/configure.js'\nimport { toUrlSearchParams } from './lib/to-url-search-params.js'\n\n/**\n * @typedef {import('./types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/root').API<HTTPClientExtraOptions>} RootAPI\n */\n\nexport const createGet = configure(api => {\n  /**\n   * @type {RootAPI[\"get\"]}\n   */\n  async function * get (path, options = {}) {\n    /** @type {Record<string, any>} */\n    const opts = {\n      arg: `${path instanceof Uint8Array ? CID.decode(path) : path}`,\n      ...options\n    }\n\n    if (opts.compressionLevel) {\n      opts['compression-level'] = opts.compressionLevel\n      delete opts.compressionLevel\n    }\n\n    const res = await api.post('get', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams(opts),\n      headers: options.headers\n    })\n\n    yield * res.iterator()\n  }\n\n  return get\n})\n","import { objectToCamel } from './lib/object-to-camel.js'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { configure } from './lib/configure.js'\nimport { toUrlSearchParams } from './lib/to-url-search-params.js'\nimport { peerIdFromString } from '@libp2p/peer-id'\n\n/**\n * @typedef {import('./types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/root').API<HTTPClientExtraOptions>} RootAPI\n */\n\nexport const createId = configure(api => {\n  /**\n   * @type {RootAPI[\"id\"]}\n   */\n  async function id (options = {}) {\n    const res = await api.post('id', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: options.peerId ? options.peerId.toString() : undefined,\n        ...options\n      }),\n      headers: options.headers\n    })\n    const data = await res.json()\n\n    const output = {\n      ...objectToCamel(data)\n    }\n\n    output.id = peerIdFromString(output.id)\n\n    if (output.addresses) {\n      output.addresses = output.addresses.map((/** @type {string} */ ma) => multiaddr(ma))\n    }\n\n    // @ts-expect-error server output is not typed\n    return output\n  }\n  return id\n})\n","import { createId } from './id.js'\n\n/**\n * @typedef {import('./types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/root').API<HTTPClientExtraOptions>} RootAPI\n */\n\n/**\n * @param {import('./types').Options} options\n */\nexport const createIsOnline = options => {\n  const id = createId(options)\n\n  /**\n   * @type {RootAPI[\"isOnline\"]}\n   */\n  async function isOnline (options = {}) {\n    const res = await id(options)\n\n    return Boolean(res && res.addresses && res.addresses.length)\n  }\n  return isOnline\n}\n","import { CID } from 'multiformats/cid'\nimport { configure } from './lib/configure.js'\nimport { toUrlSearchParams } from './lib/to-url-search-params.js'\nimport { createStat } from './files/stat.js'\n\n/**\n * @typedef {import('./types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/root').API<HTTPClientExtraOptions>} RootAPI\n */\n\nexport const createLs = configure((api, opts) => {\n  /**\n   * @type {RootAPI[\"ls\"]}\n   */\n  async function * ls (path, options = {}) {\n    const pathStr = `${path instanceof Uint8Array ? CID.decode(path) : path}`\n\n    /**\n     * @param {*} link\n     */\n    async function mapLink (link) {\n      let hash = link.Hash\n\n      if (hash.includes('/')) {\n        // the hash is a path, but we need the CID\n        const ipfsPath = hash.startsWith('/ipfs/') ? hash : `/ipfs/${hash}`\n        const stats = await createStat(opts)(ipfsPath)\n\n        hash = stats.cid\n      } else {\n        hash = CID.parse(hash)\n      }\n\n      /** @type {import('ipfs-core-types/src/root').IPFSEntry} */\n      const entry = {\n        name: link.Name,\n        path: pathStr + (link.Name ? `/${link.Name}` : ''),\n        size: link.Size,\n        cid: hash,\n        type: typeOf(link)\n      }\n\n      if (link.Mode) {\n        entry.mode = parseInt(link.Mode, 8)\n      }\n\n      if (link.Mtime !== undefined && link.Mtime !== null) {\n        entry.mtime = {\n          secs: link.Mtime\n        }\n\n        if (link.MtimeNsecs !== undefined && link.MtimeNsecs !== null) {\n          entry.mtime.nsecs = link.MtimeNsecs\n        }\n      }\n\n      return entry\n    }\n\n    const res = await api.post('ls', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: pathStr,\n        ...options\n      }),\n      headers: options.headers\n    })\n\n    for await (let result of res.ndjson()) {\n      result = result.Objects\n\n      if (!result) {\n        throw new Error('expected .Objects in results')\n      }\n\n      result = result[0]\n      if (!result) {\n        throw new Error('expected one array in results.Objects')\n      }\n\n      const links = result.Links\n      if (!Array.isArray(links)) {\n        throw new Error('expected one array in results.Objects[0].Links')\n      }\n\n      if (!links.length) {\n        // no links, this is a file, yield a single result\n        yield mapLink(result)\n\n        return\n      }\n\n      yield * links.map(mapLink)\n    }\n  }\n  return ls\n})\n\n/**\n * @param {any} link\n */\nfunction typeOf (link) {\n  switch (link.Type) {\n    case 1:\n    case 5:\n      return 'dir'\n    case 2:\n      return 'file'\n    default:\n      return 'file'\n  }\n}\n","import { objectToCamel } from './lib/object-to-camel.js'\nimport { configure } from './lib/configure.js'\nimport { toUrlSearchParams } from './lib/to-url-search-params.js'\n\n/**\n * @typedef {import('./types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/root').API<HTTPClientExtraOptions>} RootAPI\n */\n\nexport const createMount = configure(api => {\n  /**\n   * @type {RootAPI[\"mount\"]}\n   */\n  async function mount (options = {}) {\n    const res = await api.post('dns', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams(options),\n      headers: options.headers\n    })\n\n    return objectToCamel(await res.json())\n  }\n  return mount\n})\n","import { objectToCamel } from './lib/object-to-camel.js'\nimport { configure } from './lib/configure.js'\nimport { toUrlSearchParams } from './lib/to-url-search-params.js'\n\n/**\n * @typedef {import('./types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/root').API<HTTPClientExtraOptions>} RootAPI\n */\n\nexport const createPing = configure(api => {\n  /**\n   * @type {RootAPI[\"ping\"]}\n   */\n  async function * ping (peerId, options = {}) {\n    const res = await api.post('ping', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: `${peerId}`,\n        ...options\n      }),\n      headers: options.headers,\n      transform: objectToCamel\n    })\n\n    yield * res.ndjson()\n  }\n  return ping\n})\n","import { configure } from './lib/configure.js'\nimport { toUrlSearchParams } from './lib/to-url-search-params.js'\n\n/**\n * @typedef {import('./types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/root').API<HTTPClientExtraOptions>} RootAPI\n */\n\nexport const createResolve = configure(api => {\n  /**\n   * @type {RootAPI[\"resolve\"]}\n   */\n  async function resolve (path, options = {}) {\n    const res = await api.post('resolve', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: path,\n        ...options\n      }),\n      headers: options.headers\n    })\n    const { Path } = await res.json()\n    return Path\n  }\n  return resolve\n})\n","import { configure } from './lib/configure.js'\nimport errCode from 'err-code'\n\n/**\n * @typedef {import('./types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/root').API<HTTPClientExtraOptions>} RootAPI\n */\n\nexport const createStart = configure(api => {\n  /**\n   * @type {RootAPI[\"start\"]}\n   */\n  const start = async (options = {}) => {\n    throw errCode(new Error('Not implemented'), 'ERR_NOT_IMPLEMENTED')\n  }\n\n  return start\n})\n","import { configure } from './lib/configure.js'\nimport { toUrlSearchParams } from './lib/to-url-search-params.js'\n\n/**\n * @typedef {import('./types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/root').API<HTTPClientExtraOptions>} RootAPI\n */\n\nexport const createStop = configure(api => {\n  /**\n   * @type {RootAPI[\"stop\"]}\n   */\n  async function stop (options = {}) {\n    const res = await api.post('shutdown', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams(options),\n      headers: options.headers\n    })\n\n    await res.text()\n  }\n  return stop\n})\n","import { objectToCamel } from './lib/object-to-camel.js'\nimport { configure } from './lib/configure.js'\nimport { toUrlSearchParams } from './lib/to-url-search-params.js'\n\n/**\n * @typedef {import('./types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/root').API<HTTPClientExtraOptions>} RootAPI\n */\n\nexport const createVersion = configure(api => {\n  /**\n   * @type {RootAPI[\"version\"]}\n   */\n  async function version (options = {}) {\n    const res = await api.post('version', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams(options),\n      headers: options.headers\n    })\n\n    // @ts-expect-error server output is not typed\n    return {\n      ...objectToCamel(await res.json()),\n      'ipfs-http-client': '1.0.0'\n    }\n  }\n\n  return version\n})\n","/* eslint-env browser */\n\nimport { Multibases } from 'ipfs-core-utils/multibases'\nimport { Multicodecs } from 'ipfs-core-utils/multicodecs'\nimport { Multihashes } from 'ipfs-core-utils/multihashes'\nimport * as dagPB from '@ipld/dag-pb'\nimport * as dagCBOR from '@ipld/dag-cbor'\nimport * as dagJSON from '@ipld/dag-json'\nimport * as dagJOSE from 'dag-jose'\nimport { identity } from 'multiformats/hashes/identity'\nimport { bases, hashes, codecs } from 'multiformats/basics'\nimport { createBitswap } from './bitswap/index.js'\nimport { createBlock } from './block/index.js'\nimport { createBootstrap } from './bootstrap/index.js'\nimport { createConfig } from './config/index.js'\nimport { createDag } from './dag/index.js'\nimport { createDht } from './dht/index.js'\nimport { createDiag } from './diag/index.js'\nimport { createFiles } from './files/index.js'\nimport { createKey } from './key/index.js'\nimport { createLog } from './log/index.js'\nimport { createName } from './name/index.js'\nimport { createObject } from './object/index.js'\nimport { createPin } from './pin/index.js'\nimport { createPubsub } from './pubsub/index.js'\nimport { createRefs } from './refs/index.js'\nimport { createRepo } from './repo/index.js'\nimport { createStats } from './stats/index.js'\nimport { createSwarm } from './swarm/index.js'\nimport { createAdd } from './add.js'\nimport { createAddAll } from './add-all.js'\nimport { createCat } from './cat.js'\nimport { createCommands } from './commands.js'\nimport { createDns } from './dns.js'\nimport { createGetEndpointConfig } from './get-endpoint-config.js'\nimport { createGet } from './get.js'\nimport { createId } from './id.js'\nimport { createIsOnline } from './is-online.js'\nimport { createLs } from './ls.js'\nimport { createMount } from './mount.js'\nimport { createPing } from './ping.js'\nimport { createResolve } from './resolve.js'\nimport { createStart } from './start.js'\nimport { createStop } from './stop.js'\nimport { createVersion } from './version.js'\nimport globSourceImport from 'ipfs-utils/src/files/glob-source.js'\n\n/**\n * @typedef {import('multiformats/codecs/interface').BlockCodec<any, any>} BlockCodec\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n * @typedef {import('multiformats/bases/interface').MultibaseCodec<any>} MultibaseCodec\n * @typedef {import('./types').Options} Options\n * @typedef {import('./types').LoadBaseFn} LoadBaseFn\n * @typedef {import('./types').LoadCodecFn} LoadCodecFn\n * @typedef {import('./types').LoadHasherFn} LoadHasherFn\n * @typedef {import('./types').IPLDOptions} IPLDOptions\n * @typedef {import('./types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('./types').EndpointConfig} EndpointConfig\n * @typedef {import('./types').IPFSHTTPClient} IPFSHTTPClient\n */\n\n/**\n * @param {Options} options\n */\nexport function create (options = {}) {\n  /**\n   * @type {BlockCodec}\n   */\n  const id = {\n    name: identity.name,\n    code: identity.code,\n    encode: (id) => id,\n    decode: (id) => id\n  }\n\n  /** @type {MultibaseCodec[]} */\n  const multibaseCodecs = Object.values(bases);\n\n  (options.ipld && options.ipld.bases ? options.ipld.bases : []).forEach(base => multibaseCodecs.push(base))\n\n  const multibases = new Multibases({\n    bases: multibaseCodecs,\n    loadBase: options.ipld && options.ipld.loadBase\n  })\n\n  /** @type {BlockCodec[]} */\n  const blockCodecs = Object.values(codecs);\n\n  [dagPB, dagCBOR, dagJSON, dagJOSE, id].concat((options.ipld && options.ipld.codecs) || []).forEach(codec => blockCodecs.push(codec))\n\n  const multicodecs = new Multicodecs({\n    codecs: blockCodecs,\n    loadCodec: options.ipld && options.ipld.loadCodec\n  })\n\n  /** @type {MultihashHasher[]} */\n  const multihashHashers = Object.values(hashes);\n\n  (options.ipld && options.ipld.hashers ? options.ipld.hashers : []).forEach(hasher => multihashHashers.push(hasher))\n\n  const multihashes = new Multihashes({\n    hashers: multihashHashers,\n    loadHasher: options.ipld && options.ipld.loadHasher\n  })\n\n  /** @type {IPFSHTTPClient} */\n  const client = {\n    add: createAdd(options),\n    addAll: createAddAll(options),\n    bitswap: createBitswap(options),\n    block: createBlock(options),\n    bootstrap: createBootstrap(options),\n    cat: createCat(options),\n    commands: createCommands(options),\n    config: createConfig(options),\n    dag: createDag(multicodecs, options),\n    dht: createDht(options),\n    diag: createDiag(options),\n    dns: createDns(options),\n    files: createFiles(options),\n    get: createGet(options),\n    getEndpointConfig: createGetEndpointConfig(options),\n    id: createId(options),\n    isOnline: createIsOnline(options),\n    key: createKey(options),\n    log: createLog(options),\n    ls: createLs(options),\n    mount: createMount(options),\n    name: createName(options),\n    object: createObject(multicodecs, options),\n    pin: createPin(options),\n    ping: createPing(options),\n    pubsub: createPubsub(options),\n    refs: createRefs(options),\n    repo: createRepo(options),\n    resolve: createResolve(options),\n    start: createStart(options),\n    stats: createStats(options),\n    stop: createStop(options),\n    swarm: createSwarm(options),\n    version: createVersion(options),\n    bases: multibases,\n    codecs: multicodecs,\n    hashers: multihashes\n  }\n\n  return client\n}\n\nexport { CID } from 'multiformats/cid'\nexport { multiaddr } from '@multiformats/multiaddr'\nexport { default as urlSource } from 'ipfs-utils/src/files/url-source.js'\nexport const globSource = globSourceImport\n"],"names":[],"sourceRoot":"","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150]}