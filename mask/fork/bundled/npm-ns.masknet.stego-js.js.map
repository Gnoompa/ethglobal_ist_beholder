{"version":3,"file":"bundled/npm-ns.masknet.stego-js.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAO;AACP;AACA;AACA;AACA,CAAC,+DAA+D;;;ACJzD,SAAS,YAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA,qDAAqD,6DAA6D;AAClH;AACA;AACA;AACO;AACP;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;;;ACpHoC;AACpC;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,qEAAqE;AAC/D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP,WAAW,YAAK;AAChB;;;ACjDA;AACA;AACA,YAAY;AACZ,aAAa;AACb,WAAW;AACJ;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;;;ACxKA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,UAAU;AAC9B,wBAAwB,UAAU;AAClC;AACA;AACA;AACA,4BAA4B,UAAU;AACtC,gCAAgC,UAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,UAAU;AAC9B,wBAAwB,UAAU;AAClC;AACA,4BAA4B,UAAU;AACtC,gCAAgC,UAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;;;AC/EuC;AACA;AACS;AACzC;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,qEAAqE;AAC/D,SAAS,mBAAS,sBAAsB,MAAM;AACrD;AACA;AACA,YAAY,IAAQ;AACpB,YAAY,KAAS;AACrB;AACA;AACA,YAAY,IAAQ;AACpB,YAAY,KAAS;AACrB;AACA;AACA,YAAY,GAAO;AACnB;AACA;AACA,YAAY,SAAoB;AAChC;AACA;AACA,+DAA+D,UAAU;AACzE;AACA;AACO,SAAS,0BAAgB,sBAAsB,MAAM;AAC5D;AACA;AACA,YAAY,IAAQ;AACpB,YAAY,MAAU;AACtB;AACA;AACA,YAAY,IAAQ;AACpB,YAAY,MAAU;AACtB;AACA;AACA,YAAY,IAAQ;AACpB;AACA;AACA,YAAY,gBAA2B;AACvC;AACA;AACA,sEAAsE,UAAU;AAChF;AACA;;;ACjDA;AACA;AACA;AACA;AACA;AACO,qBAAqB,MAAM,IAAI,MAAM;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,mBAAmB,MAAM,IAAI,MAAM;AAC1C;AACA;AACA;AACA;;;;;ACpB0D;AACC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kDAAE;AAC5B;AACP,KAAK,gBAAgB;AACrB,SAAS,kBAAkB;AAC3B,SAAS,kBAAkB;AAC3B,SAAS,kBAAkB;AAC3B,SAAS,kBAAkB;AAC3B,KAAK;AACL,KAAK,gBAAgB;AACrB,SAAS,kBAAkB;AAC3B,SAAS,kBAAkB;AAC3B,SAAS,kBAAkB;AAC3B,SAAS,kBAAkB;AAC3B,KAAK;AACL,CAAC;AACM;AACP,KAAK,kBAAkB;AACvB,KAAK,kBAAkB;AACvB,KAAK,kBAAkB;AACvB,KAAK,kBAAkB;AACvB,CAAC;AACM;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;AC1CoC;AACc;AACJ;AACH;AACO;AAC3C;AACP,2BAA2B,SAAS,wBAAwB,SAAS;AACrE;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA,QAAQ,wBAAO;AACf;AACA;AACA;AACA;AACA;AACO,mBAAmB,eAAe,IAAI,MAAM;AACnD;AACA;AACO,sBAAsB,qBAAqB,IAAI,eAAe;AACrE,oBAAoB,YAAY;AAChC,wBAAwB,WAAW;AACnC;AACA,gCAAgC,OAAO;AACvC;AACA,qCAAqC,WAAW;AAChD,yCAAyC,WAAW;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,sBAAsB;AAClC,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACO;AACP,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA,6CAA6C,eAAe;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAS;AACzB;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP,YAAY,OAAO;AACnB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,OAAO;AACnB,qBAAqB,SAAS;AAC9B,oBAAoB,iBAAiB;AACrC,mBAAmB,YAAK;AACxB,aAAa,OAAO;AACpB;AACA;;;ACnG2D;AACU;AAC9D,qBAAqB,0BAA0B;AACtD;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B,GAAG,IAAI,MAAM;AAClD,YAAY,6BAA6B;AACzC;AACA;AACA;AACA,0BAA0B,QAAQ,IAAI,KAAK,GAAG,SAAS;AACvD;AACA;AACA;AACA;AACO;AACP,YAAY,iCAAiC;AAC7C;AACA,aAAa,kBAAkB;AAC/B;AACA,aAAa,kBAAkB;AAC/B,aAAa,kBAAkB;AAC/B,aAAa,kBAAkB;AAC/B;AACA;AACA,kDAAkD,mBAAmB;AACrE;AACA;;;ACxCuC;AAChC;AACP;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,gBAAgB;AACpC;AACA,wBAAwB,oCAAoC;AAC5D;AACA;AACA;AACA;AACA;AACO;AACP,gBAAgB,MAAM;AACtB,YAAY,YAAY;AACxB;AACA;AACO;AACP,gBAAgB,MAAM;AACtB,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxFkD;AAC3C;AACP,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B,oBAAoB,iBAAiB;AACrC,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;;AClB8E;AACV;AACiD;AAC5C;AAC/B;AAC4B;AAChB;AACG;AAClD;AACP,YAAY,gGAAgG;AAC5G,4BAA4B,OAAO;AACnC;AACA,qBAAqB,QAAQ;AAC7B;AACA,iBAAiB,SAAS,CAAC,UAAU;AACrC;AACA,QAAQ,gBAAc;AACtB;AACA,+BAA+B,kBAAkB;AACjD,QAAQ,gBAAgB;AACxB,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA,uCAAuC,kBAAkB;AACzD,0BAA0B,SAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B,oBAAoB,MAAM;AAC1B,oBAAoB,MAAM;AAC1B;AACA;AACA,SAAS;AACT;AACA,gBAAgB,SAAS;AACzB;AACA,IAAI,gBAAgB;AACpB;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA,+BAA+B,SAAS;AACxC,0BAA0B,IAAI;AAC9B,gBAAgB,kBAAkB,+BAA+B,OAAO,qBAAqB,IAAI;AACjG;AACA;AACA;AACA,QAAQ,mBAAS;AACjB,QAAQ,MAAM;AACd,QAAQ,0BAAgB;AACxB;AACA,KAAK;AACL;AACA;AACO;AACP,YAAY,mCAAmC;AAC/C;AACA,gBAAgB,SAAS;AACzB;AACA,IAAI,eAAe;AACnB,aAAa,gBAAgB;AAC7B;AACA;AACA,QAAQ,mBAAS;AACjB,kBAAkB,MAAM;AACxB;AACA,KAAK;AACL,WAAW,QAAQ;AACnB;;;AC1EuC;AACK;AACK;AAC1C;AACP,YAAY,gBAAgB;AAC5B,oCAAoC,OAAO;AAC3C;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;;;ACX2D;AACpD,SAAS,eAAM;AACtB,YAAY,2BAA2B;AACvC;AACA,aAAa,kBAAkB;AAC/B;AACA,aAAa,kBAAkB;AAC/B;AACA,aAAa,kBAAkB;AAC/B;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA,4DAA4D,mBAAmB;AAC/E;AACA;;;AChBuC;AACoB;AACL;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACO,SAAS,YAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oBAAoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,YAAQ;AACxB;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB,oBAAoB,EAAE;AAC5D;AACA,wBAAwB,IAAI,oBAAoB,EAAE;AAClD,qCAAqC,oBAAoB;AACzD;AACA,yEAAyE,oBAAoB;AAC7F;AACA;AACA;AACA;AACA;AACO;AACP,kDAAkD,oBAAoB,GAAG;AACzE;AACO;AACP,0CAA0C,oBAAoB;AAC9D;AACA;AACO,SAAS,aAAS;AACzB;AACA,oBAAoB,gBAAgB;AACpC;AACA,wBAAwB,oCAAoC;AAC5D;AACA;AACA;AACA;AACA;AACO,SAAS,UAAM;AACtB,yBAAyB,eAAM;AAC/B;AACA;AACA;AACA,aAAa;AACb;AACO,SAAS,UAAM;AACtB,yBAAyB,eAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,kBAAkB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,kBAAkB;AAC7D;AACA;AACA;AACA;;;AC5X8E;AACV;AAC6E;AAChD;AAC1D;AAC+B;AACoB;AACjC;AACG;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,eAAe,eAAS;AAC/B,YAAY,gGAAgG;AAC5G,4BAA4B,OAAO;AACnC;AACA,qBAAqB,YAAQ;AAC7B,uBAAuB,UAAU;AACjC;AACA,iBAAiB,aAAS,CAAC,UAAU;AACrC;AACA;AACA,QAAQ,gBAAc;AACtB;AACA,+BAA+B,kBAAkB;AACjD,QAAQ,gBAAgB;AACxB,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA,uCAAuC,kBAAkB;AACzD,0BAA0B,SAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B,oBAAoB,MAAM;AAC1B,oBAAoB,MAAM;AAC1B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,IAAI,eAAe,aAAa,IAAI,GAAG;AACvC;AACA;AACA;AACA,KAAK;AACL,IAAI,gBAAgB;AACpB;AACA;AACA;AACA,2BAA2B,SAAS;AACpC,4BAA4B,iBAAiB;AAC7C,4BAA4B,OAAO;AACnC,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA,+BAA+B,SAAS;AACxC,0BAA0B,IAAI;AAC9B,gBAAgB,kBAAkB,+BAA+B,OAAO,qBAAqB,IAAI;AACjG;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mBAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAM;AAClB,iCAAiC,eAAM;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0BAAgB;AAC5B;AACA,YAAY,mBAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACO,eAAe,eAAS;AAC/B,YAAY,2BAA2B;AACvC;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA,IAAI,eAAe,aAAa,IAAI;AACpC;AACA,IAAI,eAAe;AACnB,aAAa,gBAAgB;AAC7B;AACA;AACA,QAAQ,mBAAS;AACjB,8CAA8C,oBAAoB;AAClE,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA,mCAAmC,UAAM;AACzC;AACA,iBAAiB,YAAY;AAC7B,sBAAsB,UAAM;AAC5B;AACA;AACA,KAAK;AACL,IAAI,iBAAiB,WAAW,IAAI;AACpC,6CAA6C,oBAAoB;AACjE,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA,WAAW,YAAQ,oBAAoB,oBAAoB;AAC3D;;;AC/KuC;AACK;AACK;AAC1C,eAAe,SAAM;AAC5B,YAAY,gBAAgB;AAC5B,oCAAoC,OAAO;AAC3C;AACA,oBAAoB,eAAS;AAC7B;AACA;AACA;AACA;;;ACXqD;AAChB;AACA;AACrC;AACA,KAAK,gBAAgB,MAAM,kBAAE;AAC7B,KAAK,gBAAgB,MAAM,kBAAE;AAC7B;AACO;AACP,YAAY,qEAAqE;AACjF;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;;AClBqD;AACD;AACA;;;ACFN;AACG;AACE;AACF;AAChB;AACH;AACvB,QAAQ,MAAM,uBAAW,EAAE,SAAS;AAC3C;AACA;AACA;AACA,yBAAyB,YAAY;AACrC,4CAA4C,MAAM;AAClD;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,0CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,KAAK;AACL;AACA,eAAe,eAAe;AAC9B,KAAK;AACL;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://mask-network/./node_modules/.pnpm/@masknet+stego-js@0.14.2/node_modules/@masknet/stego-js/esm/utils/stego-params.js","webpack://mask-network/./node_modules/.pnpm/@masknet+stego-js@0.14.2/node_modules/@masknet/stego-js/esm/utils/helper.js","webpack://mask-network/./node_modules/.pnpm/@masknet+stego-js@0.14.2/node_modules/@masknet/stego-js/esm/utils/grayscale.js","webpack://mask-network/./node_modules/.pnpm/@masknet+stego-js@0.14.2/node_modules/@masknet/stego-js/esm/fft/index.js","webpack://mask-network/./node_modules/.pnpm/@masknet+stego-js@0.14.2/node_modules/@masknet/stego-js/esm/dct/index.js","webpack://mask-network/./node_modules/.pnpm/@masknet+stego-js@0.14.2/node_modules/@masknet/stego-js/esm/dct/fastdct.js","webpack://mask-network/./node_modules/.pnpm/@masknet+stego-js@0.14.2/node_modules/@masknet/stego-js/esm/utils/transform.js","webpack://mask-network/./node_modules/.pnpm/@masknet+stego-js@0.14.2/node_modules/@masknet/stego-js/esm/utils/locator.js","webpack://mask-network/./node_modules/.pnpm/@masknet+stego-js@0.14.2/node_modules/@masknet/stego-js/esm/constant.js","webpack://mask-network/./node_modules/.pnpm/@masknet+stego-js@0.14.2/node_modules/@masknet/stego-js/esm/utils/image.js","webpack://mask-network/./node_modules/.pnpm/@masknet+stego-js@0.14.2/node_modules/@masknet/stego-js/esm/v1/position.js","webpack://mask-network/./node_modules/.pnpm/@masknet+stego-js@0.14.2/node_modules/@masknet/stego-js/esm/v1/bit.js","webpack://mask-network/./node_modules/.pnpm/@masknet+stego-js@0.14.2/node_modules/@masknet/stego-js/esm/utils/mask.js","webpack://mask-network/./node_modules/.pnpm/@masknet+stego-js@0.14.2/node_modules/@masknet/stego-js/esm/v1/stego.js","webpack://mask-network/./node_modules/.pnpm/@masknet+stego-js@0.14.2/node_modules/@masknet/stego-js/esm/v1/index.js","webpack://mask-network/./node_modules/.pnpm/@masknet+stego-js@0.14.2/node_modules/@masknet/stego-js/esm/v2/position.js","webpack://mask-network/./node_modules/.pnpm/@masknet+stego-js@0.14.2/node_modules/@masknet/stego-js/esm/v2/bit.js","webpack://mask-network/./node_modules/.pnpm/@masknet+stego-js@0.14.2/node_modules/@masknet/stego-js/esm/v2/stego.js","webpack://mask-network/./node_modules/.pnpm/@masknet+stego-js@0.14.2/node_modules/@masknet/stego-js/esm/v2/index.js","webpack://mask-network/./node_modules/.pnpm/@masknet+stego-js@0.14.2/node_modules/@masknet/stego-js/esm/utils/expose.js","webpack://mask-network/./node_modules/.pnpm/@masknet+stego-js@0.14.2/node_modules/@masknet/stego-js/esm/utils/types.js","webpack://mask-network/./node_modules/.pnpm/@masknet+stego-js@0.14.2/node_modules/@masknet/stego-js/esm/dom.js"],"sourcesContent":["export var AlgorithmVersion;\n(function (AlgorithmVersion) {\n    AlgorithmVersion[\"V1\"] = \"V1\";\n    AlgorithmVersion[\"V2\"] = \"V2\";\n})(AlgorithmVersion = AlgorithmVersion || (AlgorithmVersion = {}));\n","export function clamp(v, min, max) {\n    if (v < min)\n        return min;\n    if (v > max)\n        return max;\n    return v;\n}\nexport function hash(input) {\n    let code = 0;\n    if (input.length === 0)\n        return code;\n    for (let i = 0; i < input.length; i += 1) {\n        const char = input.charCodeAt(i);\n        code = (code << 5) - code + char;\n        code = code & code; // Convert to 32bit integer\n    }\n    return code;\n}\nexport function hashCode(input, mod, inArray) {\n    let prob = 1;\n    const code = hash(input);\n    let index = Math.abs(code) % mod;\n    while (inArray[index]) {\n        index = (index + prob * prob) % mod;\n        prob = prob > mod / 2 ? 1 : prob + 1;\n    }\n    inArray[index] = 1;\n    return [index, String(code)];\n}\nexport function shuffleGroupBy3(numbers, seed, unshuffle = false) {\n    const shuffleHelper = new Array(numbers.length / 3).fill(0).map((v, i) => i);\n    shuffle(shuffleHelper, seed, unshuffle);\n    const shuffleRes = new Array(numbers.length)\n        .fill(0)\n        .map((v, i) => numbers[3 * shuffleHelper[Math.floor(i / 3)] + (i % 3)]);\n    numbers.forEach((v, i) => {\n        numbers[i] = shuffleRes[i];\n    });\n}\nexport function unshuffleGroupBy3(numbers, seed) {\n    return shuffleGroupBy3(numbers, seed, true);\n}\nexport function shuffle(numbers, seed, unshuffle = false) {\n    const swap = (a, b) => {\n        ;\n        [numbers[a], numbers[b]] = [numbers[b], numbers[a]];\n    };\n    for (let i = unshuffle ? numbers.length - 1 : 0; (unshuffle && i >= 0) || (!unshuffle && i < numbers.length); i += unshuffle ? -1 : 1) {\n        swap(seed[i % seed.length] % numbers.length, i);\n    }\n}\nexport function filterIndices(size, predicator) {\n    const indices = [];\n    for (let i = 0; i < size * size; i += 1) {\n        if (predicator(i)) {\n            indices.push(i);\n        }\n    }\n    return indices;\n}\nexport function squareCircleIntersect(size, radius) {\n    const mid = (size + 1) / 2 - 1;\n    return filterIndices(size, (i) => {\n        const x = Math.floor(i / size);\n        const y = i % size;\n        return Math.sqrt(Math.pow(mid - x, 2) + Math.pow(mid - y, 2)) <= radius;\n    });\n}\nfunction isJPEG(buf) {\n    if (!buf || buf.length < 3) {\n        return false;\n    }\n    return buf[0] === 0xff && buf[1] === 0xd8 && buf[2] === 0xff;\n}\nfunction isPNG(buf) {\n    if (!buf || buf.length < 8) {\n        return false;\n    }\n    return (buf[0] === 0x89 &&\n        buf[1] === 0x50 &&\n        buf[2] === 0x4e &&\n        buf[3] === 0x47 &&\n        buf[4] === 0x0d &&\n        buf[5] === 0x0a &&\n        buf[6] === 0x1a &&\n        buf[7] === 0x0a);\n}\nexport function getImageType(buf) {\n    if (isJPEG(buf)) {\n        return 'image/jpeg';\n    }\n    else if (isPNG(buf)) {\n        return 'image/png';\n    }\n    return undefined;\n}\nexport function randomBits(randomSource, size) {\n    const arr = [];\n    const alignedSize = Math.min(Math.ceil(size / 8), 65536);\n    for (const number of randomSource(new Uint8Array(alignedSize))) {\n        ;\n        arr.push((number >> 0) & 1, (number >> 1) & 1, (number >> 2) & 1, (number >> 3) & 1, (number >> 4) & 1, (number >> 5) & 1, (number >> 6) & 1, (number >> 7) & 1);\n    }\n    if (arr.length > size)\n        arr.length = size;\n    if (alignedSize * 8 < size)\n        return arr.concat(randomBits(randomSource, size - alignedSize * 8));\n    return arr;\n}\n/**\n * generate a number from range [min, max] (both inclusive)\n */\nexport function rand(randomSource, min, max) {\n    const value = new Uint32Array(randomSource(new Uint8Array(4)).buffer);\n    const zero_one = value[0] / 256 ** 4;\n    return Math.floor(zero_one * (max - min + 1) + min);\n}\n","import { clamp } from './helper.js';\n// more grayscale algorithm:\n// http://www.tannerhelland.com/3643/grayscale-image-algorithm-vb6/\nexport var GrayscaleAlgorithm;\n(function (GrayscaleAlgorithm) {\n    GrayscaleAlgorithm[\"NONE\"] = \"NONE\";\n    GrayscaleAlgorithm[\"AVERAGE\"] = \"AVG\";\n    GrayscaleAlgorithm[\"LUMINANCE\"] = \"LUMA\";\n    GrayscaleAlgorithm[\"LUMINANCE_II\"] = \"LUMA_II\";\n    GrayscaleAlgorithm[\"DESATURATION\"] = \"DESATURATION\";\n    GrayscaleAlgorithm[\"MAX_DECOMPOSITION\"] = \"MAX_DE\";\n    GrayscaleAlgorithm[\"MIN_DECOMPOSITION\"] = \"MIN_DE\";\n    GrayscaleAlgorithm[\"MID_DECOMPOSITION\"] = \"MID_DE\";\n    GrayscaleAlgorithm[\"SIGNLE_R\"] = \"R\";\n    GrayscaleAlgorithm[\"SIGNLE_G\"] = \"G\";\n    GrayscaleAlgorithm[\"SIGNLE_B\"] = \"B\";\n})(GrayscaleAlgorithm = GrayscaleAlgorithm || (GrayscaleAlgorithm = {}));\nexport function grayscale(r, g, b, algorithm) {\n    switch (algorithm) {\n        case GrayscaleAlgorithm.AVERAGE:\n            return (r + g + b) / 3;\n        case GrayscaleAlgorithm.LUMINANCE:\n            return r * 0.3 + g * 0.59 + b * 0.11;\n        case GrayscaleAlgorithm.LUMINANCE_II:\n            return r * 0.2126 + g * 0.7152 + b * 0.0722;\n        case GrayscaleAlgorithm.DESATURATION:\n            return (Math.max(r, g, b) + Math.min(r, g, b)) / 2;\n        case GrayscaleAlgorithm.MAX_DECOMPOSITION:\n            return Math.max(r, g, b);\n        case GrayscaleAlgorithm.MIN_DECOMPOSITION:\n            return Math.min(r, g, b);\n        case GrayscaleAlgorithm.MID_DECOMPOSITION:\n            return [r, g, b].sort()[1];\n        case GrayscaleAlgorithm.SIGNLE_R:\n            return r;\n        case GrayscaleAlgorithm.SIGNLE_G:\n            return g;\n        case GrayscaleAlgorithm.SIGNLE_B:\n            return b;\n        default:\n            return 0;\n    }\n}\nexport function shades(r, g, b, size) {\n    const factor = 255 / (clamp(size, 2, 256) - 1);\n    return Math.floor((r + g + b) / 3 / factor + 0.5) * factor;\n}\nexport function narrow(gray, size) {\n    return clamp(Math.round(gray), size, 255 - size);\n}\n","/// fft.js\n// core operations\nlet _n = 0; // order\nlet _bitrev; // bit reversal table\nlet _cstb; // sin/cos table\nexport function init(n) {\n    if (n !== 0 && (n & (n - 1)) === 0) {\n        _n = n;\n        _initArray();\n        _makeBitReversalTable();\n        _makeCosSinTable();\n    }\n    else {\n        throw new Error('init: radix-2 required');\n    }\n}\n// 1D-FFT\nexport function fft1d(re, im) {\n    fft(re, im, 1);\n}\n// 1D-IFFT\nexport function ifft1d(re, im) {\n    const n = 1 / _n;\n    fft(re, im, -1);\n    for (let i = 0; i < _n; i += 1) {\n        re[i] *= n;\n        im[i] *= n;\n    }\n}\n// 2D-FFT\nexport function fft2d(re, im) {\n    const tre = [];\n    const tim = [];\n    let i = 0;\n    // x-axis\n    for (let y = 0; y < _n; y += 1) {\n        i = y * _n;\n        for (let x1 = 0; x1 < _n; x1 += 1) {\n            tre[x1] = re[x1 + i];\n            tim[x1] = im[x1 + i];\n        }\n        fft1d(tre, tim);\n        for (let x2 = 0; x2 < _n; x2 += 1) {\n            re[x2 + i] = tre[x2];\n            im[x2 + i] = tim[x2];\n        }\n    }\n    // y-axis\n    for (let x = 0; x < _n; x += 1) {\n        for (let y1 = 0; y1 < _n; y1 += 1) {\n            i = x + y1 * _n;\n            tre[y1] = re[i];\n            tim[y1] = im[i];\n        }\n        fft1d(tre, tim);\n        for (let y2 = 0; y2 < _n; y2 += 1) {\n            i = x + y2 * _n;\n            re[i] = tre[y2];\n            im[i] = tim[y2];\n        }\n    }\n}\n// 2D-IFFT\nexport function ifft2d(re, im) {\n    const tre = [];\n    const tim = [];\n    let i = 0;\n    // x-axis\n    for (let y = 0; y < _n; y += 1) {\n        i = y * _n;\n        for (let x1 = 0; x1 < _n; x1 += 1) {\n            tre[x1] = re[x1 + i];\n            tim[x1] = im[x1 + i];\n        }\n        ifft1d(tre, tim);\n        for (let x2 = 0; x2 < _n; x2 += 1) {\n            re[x2 + i] = tre[x2];\n            im[x2 + i] = tim[x2];\n        }\n    }\n    // y-axis\n    for (let x = 0; x < _n; x += 1) {\n        for (let y1 = 0; y1 < _n; y1 += 1) {\n            i = x + y1 * _n;\n            tre[y1] = re[i];\n            tim[y1] = im[i];\n        }\n        ifft1d(tre, tim);\n        for (let y2 = 0; y2 < _n; y2 += 1) {\n            i = x + y2 * _n;\n            re[i] = tre[y2];\n            im[i] = tim[y2];\n        }\n    }\n}\nexport function fft(re, im, inv) {\n    let d, h, ik, m, tmp, wr, wi, xr, xi;\n    const n4 = _n >> 2;\n    // bit reversal\n    for (let l = 0; l < _n; l += 1) {\n        m = _bitrev[l];\n        if (l < m) {\n            tmp = re[l];\n            re[l] = re[m];\n            re[m] = tmp;\n            tmp = im[l];\n            im[l] = im[m];\n            im[m] = tmp;\n        }\n    }\n    // butterfly operation\n    for (let k = 1; k < _n; k <<= 1) {\n        h = 0;\n        d = _n / (k << 1);\n        for (let j = 0; j < k; j += 1) {\n            wr = _cstb[h + n4];\n            wi = inv * _cstb[h];\n            for (let i = j; i < _n; i += k << 1) {\n                ik = i + k;\n                xr = wr * re[ik] + wi * im[ik];\n                xi = wr * im[ik] - wi * re[ik];\n                re[ik] = re[i] - xr;\n                re[i] += xr;\n                im[ik] = im[i] - xi;\n                im[i] += xi;\n            }\n            h += d;\n        }\n    }\n}\nfunction _initArray() {\n    _bitrev = new Uint8Array(_n);\n    _cstb = new Float64Array(_n * 1.25);\n}\nfunction _makeBitReversalTable() {\n    let i = 0, j = 0, k = 0;\n    _bitrev[0] = 0;\n    while ((i += 1) < _n) {\n        k = _n >> 1;\n        while (k <= j) {\n            j -= k;\n            k >>= 1;\n        }\n        j += k;\n        _bitrev[i] = j;\n    }\n}\nfunction _makeCosSinTable() {\n    const n2 = _n >> 1, n4 = _n >> 2, n8 = _n >> 3, n2p4 = n2 + n4;\n    let t = Math.sin(Math.PI / _n), dc = 2 * t * t, ds = Math.sqrt(dc * (2 - dc)), c = (_cstb[n4] = 1), s = (_cstb[0] = 0);\n    t = 2 * dc;\n    for (let i = 1; i < n8; i += 1) {\n        c -= dc;\n        dc += t * c;\n        s += ds;\n        ds -= t * s;\n        _cstb[i] = s;\n        _cstb[n4 - i] = c;\n    }\n    if (n8 !== 0) {\n        _cstb[n8] = Math.sqrt(0.5);\n    }\n    for (let j = 0; j < n4; j += 1) {\n        _cstb[n2 - j] = _cstb[j];\n    }\n    for (let k = 0; k < n2p4; k += 1) {\n        _cstb[k + n2] = -_cstb[k];\n    }\n}\n","// MORE:\n// https://en.wikipedia.org/wiki/JPEG\nconst ONE_SQUARE_ROOT_OF_TWO = 1 / Math.sqrt(2);\n// type-II DCT\nexport function dct(numbers, size = 8) {\n    const coefficients = [];\n    for (let v = 0; v < size; v += 1) {\n        for (let u = 0; u < size; u += 1) {\n            const au = u === 0 ? ONE_SQUARE_ROOT_OF_TWO : 1;\n            const av = v === 0 ? ONE_SQUARE_ROOT_OF_TWO : 1;\n            let sum = 0;\n            for (let y = 0; y < size; y += 1) {\n                for (let x = 0; x < size; x += 1) {\n                    sum +=\n                        numbers[y * size + x] *\n                            Math.cos(((2 * x + 1) * u * Math.PI) / 16) *\n                            Math.cos(((2 * y + 1) * v * Math.PI) / 16);\n                }\n            }\n            coefficients.push((sum * au * av) / 4);\n        }\n    }\n    // in-place update\n    for (let i = 0; i < coefficients.length; i += 1) {\n        numbers[i] = coefficients[i];\n    }\n}\n// type-III DCT\nexport function idct(coefficients, size = 8) {\n    const numbers = [];\n    for (let y = 0; y < size; y += 1) {\n        for (let x = 0; x < size; x += 1) {\n            let sum = 0;\n            for (let v = 0; v < size; v += 1) {\n                for (let u = 0; u < size; u += 1) {\n                    const au = u === 0 ? ONE_SQUARE_ROOT_OF_TWO : 1;\n                    const av = v === 0 ? ONE_SQUARE_ROOT_OF_TWO : 1;\n                    sum +=\n                        au *\n                            av *\n                            coefficients[v * size + u] *\n                            Math.cos(((2 * x + 1) * u * Math.PI) / 16) *\n                            Math.cos(((2 * y + 1) * v * Math.PI) / 16);\n                }\n            }\n            numbers.push(sum / 4);\n        }\n    }\n    // in-place update\n    for (let i = 0; i < numbers.length; i += 1) {\n        coefficients[i] = numbers[i];\n    }\n}\n","/*\n * Fast discrete cosine transform algorithms (TypeScript)\n *\n * Copyright (c) 2020 Project Nayuki. (MIT License)\n * https://www.nayuki.io/page/fast-discrete-cosine-transform-algorithms\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n * - The above copyright notice and this permission notice shall be included in\n *   all copies or substantial portions of the Software.\n * - The Software is provided \"as is\", without warranty of any kind, express or\n *   implied, including but not limited to the warranties of merchantability,\n *   fitness for a particular purpose and noninfringement. In no event shall the\n *   authors or copyright holders be liable for any claim, damages or other\n *   liability, whether in an action of contract, tort or otherwise, arising from,\n *   out of or in connection with the Software or the use or other dealings in the\n *   Software.\n */\n// DCT type II, unscaled. Algorithm by Byeong Gi Lee, 1984.\n// See: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.118.3056&rep=rep1&type=pdf#page=34\nexport function transform(vector) {\n    const n = vector.length;\n    if (n <= 0 || (n & (n - 1)) !== 0)\n        throw 'Length must be power of 2';\n    transformInternal(vector, 0, n, new Float64Array(n));\n}\nfunction transformInternal(vector, off, len, temp) {\n    if (len === 1)\n        return;\n    const halfLen = Math.floor(len / 2);\n    for (let i = 0; i < halfLen; i += 1) {\n        const x = vector[off + i];\n        const y = vector[off + len - 1 - i];\n        temp[off + i] = x + y;\n        temp[off + i + halfLen] = (x - y) / (Math.cos(((i + 0.5) * Math.PI) / len) * 2);\n    }\n    transformInternal(temp, off, halfLen, vector);\n    transformInternal(temp, off + halfLen, halfLen, vector);\n    for (let i = 0; i < halfLen - 1; i += 1) {\n        vector[off + i * 2 + 0] = temp[off + i];\n        vector[off + i * 2 + 1] = temp[off + i + halfLen] + temp[off + i + halfLen + 1];\n    }\n    vector[off + len - 2] = temp[off + halfLen - 1];\n    vector[off + len - 1] = temp[off + len - 1];\n}\n// DCT type III, unscaled. Algorithm by Byeong Gi Lee, 1984.\n// See: https://www.nayuki.io/res/fast-discrete-cosine-transform-algorithms/lee-new-algo-discrete-cosine-transform.pdf\nexport function inverseTransform(vector) {\n    const n = vector.length;\n    if (n <= 0 || (n & (n - 1)) !== 0)\n        throw 'Length must be power of 2';\n    vector[0] /= 2;\n    inverseTransformInternal(vector, 0, n, new Float64Array(n));\n    // scale\n    for (var i = 0; i < vector.length; i += 1)\n        vector[i] /= vector.length / 2.0;\n}\nfunction inverseTransformInternal(vector, off, len, temp) {\n    if (len === 1)\n        return;\n    const halfLen = Math.floor(len / 2);\n    temp[off + 0] = vector[off + 0];\n    temp[off + halfLen] = vector[off + 1];\n    for (let i = 1; i < halfLen; i += 1) {\n        temp[off + i] = vector[off + i * 2];\n        temp[off + i + halfLen] = vector[off + i * 2 - 1] + vector[off + i * 2 + 1];\n    }\n    inverseTransformInternal(temp, off, halfLen, vector);\n    inverseTransformInternal(temp, off + halfLen, halfLen, vector);\n    for (let i = 0; i < halfLen; i += 1) {\n        const x = temp[off + i];\n        const y = temp[off + i + halfLen] / (Math.cos(((i + 0.5) * Math.PI) / len) * 2);\n        vector[off + i] = x + y;\n        vector[off + len - 1 - i] = x - y;\n    }\n}\n","import * as FFT from '../fft/index.js';\nimport * as DCT from '../dct/index.js';\nimport * as fastDctLee from '../dct/fastdct.js';\nexport var TransformAlgorithm;\n(function (TransformAlgorithm) {\n    TransformAlgorithm[\"FFT1D\"] = \"FFT1D\";\n    TransformAlgorithm[\"FFT2D\"] = \"FFT2D\";\n    TransformAlgorithm[\"DCT\"] = \"DCT\";\n    TransformAlgorithm[\"FastDCT\"] = \"fastDCT\";\n})(TransformAlgorithm = TransformAlgorithm || (TransformAlgorithm = {}));\nexport function transform(re, im, algorithm, { size }) {\n    switch (algorithm) {\n        case TransformAlgorithm.FFT1D:\n            FFT.init(size);\n            FFT.fft1d(re, im);\n            break;\n        case TransformAlgorithm.FFT2D:\n            FFT.init(size);\n            FFT.fft2d(re, im);\n            break;\n        case TransformAlgorithm.DCT:\n            DCT.dct(re, size);\n            break;\n        case TransformAlgorithm.FastDCT:\n            fastDctLee.transform(re);\n            break;\n        default:\n            throw new Error(`unknown algorithm in transform: ${algorithm}`);\n    }\n}\nexport function inverseTransform(re, im, algorithm, { size }) {\n    switch (algorithm) {\n        case TransformAlgorithm.FFT1D:\n            FFT.init(size);\n            FFT.ifft1d(re, im);\n            break;\n        case TransformAlgorithm.FFT2D:\n            FFT.init(size);\n            FFT.ifft2d(re, im);\n            break;\n        case TransformAlgorithm.DCT:\n            DCT.idct(re, size);\n            break;\n        case TransformAlgorithm.FastDCT:\n            fastDctLee.inverseTransform(re);\n            break;\n        default:\n            throw new Error(`unknown algorithm in inverseTransform: ${algorithm}`);\n    }\n}\n","/**\n * Locator to coord of top left pixel inside block\n * @param locator\n * @param options\n */\nexport function loc2coord({ p, w }, { size }) {\n    return [(p % Math.floor(w / size)) * size, Math.floor(p / Math.floor(w / size)) * size];\n}\n/**\n * Locator to pixel index\n * @param locator\n * @param options\n * @param x1 x coord of top left pixel inside block\n * @param y1 y coord of top left pixel inside block\n * @param index the index of pixel inside block\n */\nexport function loc2idx({ w, c }, { size }, x1, y1, index) {\n    const x2 = index % size;\n    const y2 = Math.floor(index / size);\n    return ((y1 + y2) * w + x1 + x2) * 4 + c;\n}\n","import { TransformAlgorithm } from './utils/transform.js';\nimport { AlgorithmVersion } from './utils/stego-params.js';\nexport const CLI_NAME = 'stego-js';\nexport const MAX_WIDTH = 1960;\nexport const DEFAULT_NARROW = 0;\nexport const DEFAULT_COPIES = 3;\nexport const DEFAULT_PARAM_COPIES = 9;\nexport const DEFAULT_SIZE = 8;\nexport const TOLERANCE_NOT_SET = -1;\nexport const DEFAULT_TOLERANCE = Object.freeze({\n    [AlgorithmVersion.V1]: {\n        [TransformAlgorithm.DCT]: 100,\n        [TransformAlgorithm.FastDCT]: 500,\n        [TransformAlgorithm.FFT1D]: 128,\n        [TransformAlgorithm.FFT2D]: 500,\n    },\n    [AlgorithmVersion.V2]: {\n        [TransformAlgorithm.DCT]: 10,\n        [TransformAlgorithm.FastDCT]: 100,\n        [TransformAlgorithm.FFT1D]: 30,\n        [TransformAlgorithm.FFT2D]: 150,\n    },\n});\nexport const MAX_TOLERANCE = Object.freeze({\n    [TransformAlgorithm.DCT]: 5000,\n    [TransformAlgorithm.FastDCT]: 5000,\n    [TransformAlgorithm.FFT1D]: 5000,\n    [TransformAlgorithm.FFT2D]: 50000,\n});\nexport const DEFAULT_FAKE_MASK_PIXELS = false;\nexport const DEFAULT_EXHAUST_PIXELS = true;\nexport const DEFAULT_CROP_EDGE_PIXELS = true;\nexport const DEFAULT_ALGORITHM_VERSION = AlgorithmVersion.V2;\nexport const DEFAULT_MASK = Object.freeze([\n    137, 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82, 0, 0, 0, 1, 0, 0, 0, 1, 1, 3, 0, 0, 0, 37, 219, 86, 202,\n    0, 0, 0, 1, 115, 82, 71, 66, 1, 217, 201, 44, 127, 0, 0, 0, 9, 112, 72, 89, 115, 0, 0, 11, 19, 0, 0, 11, 19, 1, 0,\n    154, 156, 24, 0, 0, 0, 3, 80, 76, 84, 69, 255, 255, 255, 167, 196, 27, 200, 0, 0, 0, 10, 73, 68, 65, 84, 120, 156, 99,\n    96, 0, 0, 0, 2, 0, 1, 72, 175, 164, 113, 0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130,\n]);\nexport const SEED = Object.freeze([\n    76221, 13388, 20800, 80672, 15974, 87005, 71203, 84444, 16928, 51335, 94092, 83586, 37656, 2240, 26283, 1887, 93419,\n    96857, 20866, 21797, 42065, 39781, 50192, 24399, 98969, 54274, 38815, 45159, 36824,\n]);\n","import { clamp } from './helper.js';\nimport { loc2idx, loc2coord } from './locator.js';\nimport { lanczos } from '@rgba-image/lanczos';\nimport { MAX_WIDTH } from '../constant.js';\nimport { transform } from '../utils/transform.js';\nexport function preprocessImage(imageData, getScaled) {\n    if (imageData.width <= MAX_WIDTH && imageData.height <= MAX_WIDTH)\n        return imageData;\n    const scale = MAX_WIDTH / Math.max(imageData.width, imageData.height);\n    const [w, h] = [imageData.width * scale, imageData.height * scale];\n    const scaled = getScaled(w, h);\n    if (scaled) {\n        lanczos(imageData, scaled);\n        return scaled;\n    }\n    else\n        return imageData;\n}\nexport function cropImg({ width, height }, { size }) {\n    return [Math.floor(width / size) * size, Math.floor(height / size) * size];\n}\nexport function* divideImg({ width, height, data }, { size, verbose }) {\n    for (let h = 0; h < height; h += size) {\n        for (let w = 0; w < width; w += size) {\n            if (h + size <= height && w + size <= width) {\n                for (let c = 0; c < 3; c += 1) {\n                    const block = [];\n                    for (let h1 = 0; h1 < size; h1 += 1) {\n                        for (let w1 = 0; w1 < size; w1 += 1) {\n                            block[h1 * size + w1] = data[((h + h1) * width + w + w1) * 4 + c];\n                        }\n                    }\n                    if (verbose)\n                        console.warn('height: ' + h + ' width: ' + w);\n                    yield block;\n                }\n            }\n        }\n    }\n}\nexport function visitImgByPixel(imgData, visitor) {\n    const { width, height, data } = imgData;\n    for (let i = 0; i < width * height; i += 1) {\n        const p = i * 4;\n        visitor([data[p], data[p + 1], data[p + 2], data[p + 3]], p, imgData);\n    }\n}\nexport function visitImgByBlock(imgData, options, visitor) {\n    const { width: w, height: h } = imgData;\n    let c = 0;\n    let p = 0;\n    let b = 0;\n    for (const block of divideImg(imgData, options)) {\n        const bitConsumed = visitor(block, { c, p, b, w, h }, imgData);\n        c += 1;\n        if (bitConsumed) {\n            b += 1;\n        }\n        if (c === 3) {\n            p += 1;\n            c = 0;\n        }\n    }\n}\nexport function updateImgByPixel(imgData, updater) {\n    visitImgByPixel(imgData, (pixel, loc) => updateImgByPixelAt(imgData.data, updater(pixel, loc), loc));\n}\nexport function updateImgByBlock(imgData, options, updater) {\n    visitImgByBlock(imgData, options, (block, loc) => {\n        const bitConsumed = updater(block, loc, imgData);\n        if (bitConsumed) {\n            updateImgByBlockAt(imgData.data, options, block, loc);\n            if (options.verbose) {\n                console.warn('inversed block: ' + block);\n                const im = new Array(options.size * options.size);\n                transform(block, im.fill(0), options.transformAlgorithm, options);\n                console.warn(block[25], block[18]);\n            }\n        }\n        return bitConsumed;\n    });\n}\nexport function updateImgByPixelChannelAt(imgData, loc, channel, value) {\n    const { data } = imgData;\n    data[loc + channel] = value;\n}\nexport function updateImgByPixelAt(data, pixel, loc) {\n    data[loc + 0] = pixel[0];\n    data[loc + 1] = pixel[1];\n    data[loc + 2] = pixel[2];\n    data[loc + 3] = pixel[3];\n}\nexport function updateImgByBlockAt(data, options, block, loc) {\n    const { size } = options;\n    const [x1, y1] = loc2coord(loc, options);\n    for (let i = 0; i < size * size; i += 1) {\n        block[i] = clamp(Math.round(block[i]), 0, 255);\n        data[loc2idx(loc, options, x1, y1, i)] = block[i];\n    }\n}\n","import { TransformAlgorithm } from '../utils/transform.js';\nimport { hashCode, squareCircleIntersect } from '../utils/helper.js';\nexport function createAcc({ size, transformAlgorithm }) {\n    switch (transformAlgorithm) {\n        case TransformAlgorithm.FFT1D:\n            return {\n                prevPos: -1,\n                prevCode: '',\n                indices: squareCircleIntersect(size, 3),\n            };\n        default:\n            return {\n                prevPos: -1,\n                prevCode: '',\n                indices: [],\n            };\n    }\n}\nexport function getPosFromAcc(acc, { c }, { pass }) {\n    const { prevCode, prevPos, indices } = acc;\n    if (c !== 0) {\n        return prevPos;\n    }\n    const [index, code] = hashCode(`${pass}_${prevCode}`, indices.length, []);\n    acc.prevCode = code;\n    acc.prevPos = indices[index];\n    return indices[index];\n}\nexport function getPos(acc, loc, options) {\n    const { pass, size, transformAlgorithm } = options;\n    switch (transformAlgorithm) {\n        case TransformAlgorithm.FFT1D:\n            return pass ? getPosFromAcc(acc, loc, options) : (size * size + size) / 2;\n        case TransformAlgorithm.FFT2D:\n        case TransformAlgorithm.DCT:\n        case TransformAlgorithm.FastDCT:\n            return 0;\n        default:\n            throw new Error(`unknown algorithm: ${transformAlgorithm}`);\n    }\n}\n","import { getPos } from './position.js';\nexport function str2bits(text, copies) {\n    const chars = Array.from(text);\n    const bits = [];\n    const pushByte = (byte, n) => {\n        for (let i = 0; i < 8; i += 1) {\n            let j = 0;\n            while (j < n) {\n                bits.push(byte[i]);\n                j += 1;\n            }\n        }\n    };\n    for (let i = 0; i < chars.length; i += 1) {\n        const codes = Array.from(encodeURI(chars[i]));\n        for (let j = 0; j < codes.length; j += 1) {\n            const byte = [];\n            let reminder = 0;\n            let code = codes[j].charCodeAt(0);\n            do {\n                reminder = (code % 2);\n                byte.push(reminder);\n                code = code - Math.floor(code / 2) - reminder;\n            } while (code > 1);\n            byte.push(code);\n            while (byte.length < 8) {\n                byte.push(0);\n            }\n            pushByte(byte.reverse(), copies);\n        }\n    }\n    return bits;\n}\nexport function bits2str(bits, copies) {\n    let k = 128;\n    let temp = 0;\n    const chars = [];\n    const candidates = [];\n    const elect = () => (candidates.filter((c) => c === 1).length >= copies / 2 ? 1 : 0);\n    for (let i = 0; i < bits.length; i += 1) {\n        candidates.push(bits[i]);\n        if (candidates.length === copies) {\n            temp += elect() * k;\n            k /= 2;\n            candidates.length = 0;\n            // end of message\n            if (temp === 255) {\n                break;\n            }\n            if (k < 1) {\n                chars.push(String.fromCharCode(temp));\n                temp = 0;\n                k = 128;\n            }\n        }\n    }\n    try {\n        return decodeURI(chars.join(''));\n    }\n    catch (e) {\n        return '';\n    }\n}\nexport function mergeBits(dest, ...src) {\n    let k = 0;\n    for (let i = 0; i < src.length; i += 1) {\n        const bits = src[i];\n        for (let j = 0; j < bits.length && k < dest.length; j += 1, k += 1) {\n            dest[k] = bits[j];\n        }\n    }\n    return dest;\n}\nexport function getBit(block, acc, loc, options) {\n    const pos = getPos(acc, loc, options);\n    const { tolerance } = options;\n    return Math.abs(Math.round(block[pos] / tolerance) % 2);\n}\nexport function setBit(block, bits, acc, loc, options) {\n    const pos = getPos(acc, loc, options);\n    const { tolerance } = options;\n    const v = Math.floor(block[pos] / tolerance);\n    if (bits[loc.b]) {\n        block[pos] = v % 2 === 1 ? v * tolerance : (v + 1) * tolerance;\n    }\n    else {\n        block[pos] = v % 2 === 1 ? (v - 1) * tolerance : v * tolerance;\n    }\n}\n","import { loc2idx, loc2coord } from './locator.js';\nexport function isBlockVisibleAt(data, loc, options) {\n    const { size } = options;\n    const _loc = {\n        ...loc,\n        c: 0, // mask is a gray image since only red red was read\n    };\n    const [x1, y1] = loc2coord(_loc, options);\n    for (let i = 0; i < size * size; i += 1) {\n        const value = data[loc2idx(_loc, options, x1, y1, i)];\n        if (typeof value !== 'undefined' && value < 127) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function isPixelVisibleAt(data, loc) {\n    return typeof data[loc] === 'undefined' || data[loc] > 127;\n}\n","import { GrayscaleAlgorithm, grayscale, narrow } from '../utils/grayscale.js';\nimport { transform, inverseTransform } from '../utils/transform.js';\nimport { cropImg, updateImgByBlock, updateImgByPixel, visitImgByBlock, updateImgByPixelAt } from '../utils/image.js';\nimport { mergeBits, str2bits, setBit, getBit, bits2str } from './bit.js';\nimport { createAcc } from './position.js';\nimport { isPixelVisibleAt, isBlockVisibleAt } from '../utils/mask.js';\nimport { rand, randomBits } from '../utils/helper.js';\nimport { loc2idx, loc2coord } from '../utils/locator.js';\nexport async function encodeImg(imgData, maskData, options, defaultRandomSource) {\n    const { text, size, narrow: narrowSize, copies, grayscaleAlgorithm, transformAlgorithm, exhaustPixels } = options;\n    const [width, height] = cropImg(imgData, options);\n    const sizeOfBlocks = width * height * 3;\n    const textBits = str2bits(text, copies);\n    const randomSource = options.randomSource || defaultRandomSource;\n    const bits = mergeBits(randomBits(randomSource, exhaustPixels ? sizeOfBlocks : textBits.length + 8 * copies), textBits, Array(8 * copies).fill(1));\n    if (textBits.length + 8 * copies > sizeOfBlocks) {\n        process.stderr.write('bits overflow! try to shrink text or reduce copies.\\n');\n    }\n    if (grayscaleAlgorithm !== GrayscaleAlgorithm.NONE || narrowSize > 0) {\n        updateImgByPixel(imgData, ([r, g, b, a], loc) => {\n            if (!isPixelVisibleAt(maskData, loc)) {\n                return [r, g, b, a];\n            }\n            // decolor\n            if (grayscaleAlgorithm !== GrayscaleAlgorithm.NONE) {\n                const y = grayscale(r, g, b, grayscaleAlgorithm);\n                r = y;\n                g = y;\n                b = y;\n            }\n            // narrow color value\n            if (narrowSize > 0) {\n                r = narrow(r, narrowSize);\n                g = narrow(g, narrowSize);\n                b = narrow(b, narrowSize);\n            }\n            return [r, g, b, a];\n        });\n    }\n    const acc = createAcc(options);\n    const im = new Array(size * size);\n    updateImgByBlock(imgData, options, (block, loc) => {\n        if (!exhaustPixels && loc.b >= bits.length) {\n            return false;\n        }\n        if (!isBlockVisibleAt(maskData, loc, options)) {\n            if (options.fakeMaskPixels && loc.c === 0) {\n                const [x, y] = loc2coord(loc, options);\n                const g = rand(randomSource, 10, 127);\n                updateImgByPixelAt(imgData.data, [g, g, g, 255], loc2idx(loc, options, x, y, rand(randomSource, 0, 64)));\n            }\n            return false;\n        }\n        transform(block, im.fill(0), transformAlgorithm, options);\n        setBit(block, bits, acc, loc, options);\n        inverseTransform(block, im, transformAlgorithm, options);\n        return true;\n    });\n    return imgData;\n}\nexport async function decodeImg(imgData, maskData, options) {\n    const { size, copies, transformAlgorithm } = options;\n    const bits = [];\n    const acc = createAcc(options);\n    const im = new Array(size * size);\n    visitImgByBlock(imgData, options, (block, loc) => {\n        if (!isBlockVisibleAt(maskData, loc, options)) {\n            return false;\n        }\n        transform(block, im.fill(0), transformAlgorithm, options);\n        bits.push(getBit(block, acc, loc, options));\n        return true;\n    });\n    return bits2str(bits, copies);\n}\n","import { encodeImg } from './stego.js';\nimport { cropImg } from '../utils/image.js';\nexport { decodeImg as decode } from './stego.js';\nexport async function encode(imgData, maskData, options, defaultRandomSource) {\n    const { width, height } = imgData;\n    const [cropWidth, cropHeight] = cropImg(imgData, options);\n    return {\n        data: await encodeImg(imgData, maskData, options, defaultRandomSource),\n        width: options.cropEdgePixels ? cropWidth : width,\n        height: options.cropEdgePixels ? cropHeight : height,\n    };\n}\n","import { TransformAlgorithm } from '../utils/transform.js';\nexport function getPos(options) {\n    const { size, transformAlgorithm } = options;\n    switch (transformAlgorithm) {\n        case TransformAlgorithm.FFT1D:\n            return [3 * size + 1, 2 * size + 2];\n        case TransformAlgorithm.FFT2D:\n            return [3 * size + 1, 2 * size + 2];\n        case TransformAlgorithm.DCT:\n            return [3 * size + 1, 2 * size + 2];\n        case TransformAlgorithm.FastDCT:\n            return [3 * size + 1, 2 * size + 2];\n        default:\n            const _ = transformAlgorithm;\n            throw new Error(`unknown algorithm in getPos: ${transformAlgorithm}`);\n    }\n}\n","import { getPos } from './position.js';\nimport { TransformAlgorithm } from '../utils/transform.js';\nimport { DEFAULT_PARAM_COPIES } from '../constant.js';\nfunction gray_code(n) {\n    return n ^ (n >> 1);\n}\nconst URIchars = [\n    '0',\n    '1',\n    '2',\n    '3',\n    '4',\n    '5',\n    '6',\n    '7',\n    '8',\n    '9',\n    'a',\n    'b',\n    'c',\n    'd',\n    'e',\n    'f',\n    'g',\n    'h',\n    'i',\n    'j',\n    'k',\n    'l',\n    'm',\n    'n',\n    'o',\n    'p',\n    'q',\n    'r',\n    's',\n    't',\n    'u',\n    'v',\n    'w',\n    'x',\n    'y',\n    'z',\n    'A',\n    'B',\n    'C',\n    'D',\n    'E',\n    'F',\n    'J',\n    'H',\n    'I',\n    'G',\n    'K',\n    'L',\n    'M',\n    'N',\n    'O',\n    'P',\n    'Q',\n    'R',\n    'S',\n    'T',\n    'U',\n    'V',\n    'W',\n    'X',\n    'Y',\n    'Z',\n    '-',\n    '.',\n    '_',\n    '!',\n    '~',\n    '*',\n    \"'\",\n    '(',\n    ')',\n    ';',\n    ',',\n    '/',\n    '?',\n    ':',\n    '@',\n    '&',\n    '=',\n    '+',\n    '$',\n    '%',\n];\nconst URIcharCode = URIchars.map((c, i) => gray_code(2 * i));\nfunction char2code(c) {\n    return URIchars.indexOf(c) !== -1 ? URIcharCode[URIchars.indexOf(c)] : 255;\n}\nfunction code2char(c) {\n    return URIcharCode.indexOf(c) !== -1 ? URIchars[URIcharCode.indexOf(c)] : '';\n}\nfunction str2codes(text) {\n    const codes = [];\n    Array.from(text).map((char) => {\n        const URIcodes = Array.from(encodeURI(char));\n        URIcodes.map((URIcode) => codes.push(URIcharCode[URIchars.indexOf(URIcode)]));\n    });\n    return codes;\n}\nfunction codes2bits(codes, copies) {\n    const bits = [];\n    const pushByte = (byte, n) => {\n        for (let i = 0; i < 8; i += 1) {\n            let j = 0;\n            while (j < n) {\n                bits.push(byte[i]);\n                j += 1;\n            }\n        }\n    };\n    codes.map((code) => {\n        const byte = [];\n        let reminder = 0;\n        do {\n            reminder = (code % 2);\n            byte.push(reminder);\n            code = code - Math.floor(code / 2) - reminder;\n        } while (code > 1);\n        byte.push(code);\n        while (byte.length < 8) {\n            byte.push(0);\n        }\n        pushByte(byte.reverse(), 3 * Math.ceil(copies / 3));\n    });\n    return bits;\n}\nexport function str2bits(text, copies) {\n    const codes = str2codes(text);\n    return codes2bits(codes, copies);\n}\nfunction correctCharCode(rawCode, charCodes, verbose) {\n    if (verbose) {\n        const bits = rawCode.map((bits) => bits.map((richBits) => richBits.bit));\n        const diffs = rawCode.map((bits) => bits.map((richBits) => richBits.diff));\n        console.warn('[debug][rawcode] bits: ' + bits + '\\n' + diffs);\n    }\n    let code = rawCode\n        .slice()\n        .reverse()\n        .reduce((res, richBits, id) => {\n        // correct raw bit\n        const copies = richBits.length;\n        const nBit1 = richBits.filter((c) => c.bit === 1).length;\n        if (nBit1 === 0)\n            return res;\n        if (nBit1 !== copies) {\n            const conditionalSum = (richBits, v) => richBits.reduce((res, e) => (e.bit === v ? res + e.diff : res), 0);\n            const diff1 = Math.abs(conditionalSum(richBits, 1)) / nBit1;\n            const diff0 = Math.abs(conditionalSum(richBits, 0)) / (copies - nBit1);\n            if (verbose) {\n                console.warn('diff1: ' + diff1 + ' diff0: ' + diff1);\n            }\n            if (diff1 > 2 * diff0 || nBit1 > copies / 2)\n                // bit 1\n                res += 1 << id;\n        }\n        else {\n            res += 1 << id;\n        }\n        // done\n        return res;\n    }, 0);\n    if (code !== 255 && URIcharCode.indexOf(code) === -1) {\n        const percentChars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'].map((c) => char2code(c));\n        const l = charCodes.length;\n        let inPercent = false;\n        if ((l > 1 && charCodes[l - 1] === char2code('%')) || (l > 2 && charCodes[l - 2] === char2code('%')))\n            inPercent = true;\n        const countBit1 = (n) => {\n            let count = 0;\n            while (n) {\n                count += n & 1;\n                n >>= 1;\n            }\n            return count;\n        };\n        code = URIcharCode.reduce((res, c) => {\n            if (inPercent) {\n                if (percentChars.indexOf(c) === -1)\n                    return res;\n                else if (percentChars.indexOf(res) === -1)\n                    return c;\n            }\n            const dec2byte = (dec) => {\n                const byte = Array.from(dec.toString(2));\n                while (byte.length < 8) {\n                    byte.splice(0, 0, '0');\n                }\n                return byte.map((n) => Number(n));\n            };\n            const diff = (rawCode, comp) => {\n                const compBits = dec2byte(comp);\n                let bitDiff = 0;\n                let paramDiff = 0;\n                const w = [0.45, 0.35, 0.2];\n                for (let i = 0; i < rawCode.length; i += 1) {\n                    const rbit = rawCode[i].filter((c) => c.bit === 1).length;\n                    const absbitDiff = Math.abs(rbit - compBits[i] * rawCode[i].length);\n                    bitDiff += absbitDiff;\n                    paramDiff += rawCode[i].reduce((diff, b, bitId) => (b.bit !== compBits[i] ? Math.abs(b.diff) * w[bitId % 3] + diff : diff), 0);\n                }\n                // paramDiff /= bitDiff;\n                if (verbose) {\n                    console.warn(comp +\n                        ' ' +\n                        code2char(comp) +\n                        ' ' +\n                        compBits +\n                        ' bit difference: ' +\n                        bitDiff +\n                        ' param difference: ' +\n                        paramDiff +\n                        '\\n');\n                }\n                return [bitDiff, paramDiff];\n            };\n            if (countBit1(code ^ res) < countBit1(code ^ c))\n                return res;\n            else if (countBit1(code ^ res) > countBit1(code ^ c))\n                return c;\n            else {\n                const [resDiff, cDiff] = [diff(rawCode, res), diff(rawCode, c)];\n                if (resDiff[1] < cDiff[1])\n                    return res;\n                else if (resDiff[1] > cDiff[1])\n                    return c;\n                else {\n                    if (resDiff[0] < cDiff[0])\n                        return res;\n                    else\n                        return c;\n                }\n            }\n        }, 255);\n    }\n    if (verbose) {\n        const bits = rawCode.map((bits) => bits.map((richBits) => richBits.bit));\n        const diffs = rawCode.map((bits) => bits.map((richBits) => richBits.diff));\n        console.warn('elected ' + code + ' (' + code2char(code) + ') with bits: ' + bits + '\\n' + diffs);\n    }\n    return code;\n}\nexport function bits2str(richBits, copies, verbose) {\n    let k = 128;\n    let tempCharCode = 0;\n    const tempRawBits = [];\n    const charCodes = [];\n    const candidates = [];\n    for (let i = 0; i < richBits.length; i += 1) {\n        candidates.push(richBits[i]);\n        if (verbose) {\n            console.warn('bit: ' + richBits[i].bit);\n            console.warn('charId: ' + Math.floor(i / (8 * copies)) + ', bitId: ' + (i % (8 * copies)));\n        }\n        if (candidates.length === copies) {\n            tempRawBits.push(candidates.slice());\n            k /= 2;\n            candidates.length = 0;\n            if (k < 1) {\n                tempCharCode = correctCharCode(tempRawBits, charCodes, verbose);\n                // end of message\n                if (tempCharCode === 255) {\n                    break;\n                }\n                if (verbose) {\n                    console.warn('bit index: ' + i + ' char: ' + code2char(tempCharCode) + ' temp: ' + tempCharCode + '\\n');\n                }\n                charCodes.push(tempCharCode);\n                tempCharCode = 0;\n                tempRawBits.length = 0;\n                k = 128;\n            }\n            if (copies % 3 !== 0) {\n                //consume more bits\n                i += 3 - (copies % 3);\n            }\n        }\n    }\n    if (verbose)\n        console.warn('Before correctURI: ' + charCodes);\n    const chars = charCodes.map((c) => code2char(c));\n    try {\n        return decodeURI(chars.join(''));\n    }\n    catch (e) {\n        console.warn('Error when decoding:  ' + e);\n        return '';\n    }\n}\nfunction int2halfbyte(n, copies) {\n    // reverse order\n    const bytes = Array.from(n.toString(2))\n        .reverse()\n        .map((n) => Number(n));\n    while (bytes.length < 4)\n        bytes.push(0);\n    const res = [];\n    for (let i = 0; i < bytes.length; i += 1) {\n        for (let j = 0; j < copies; j += 1) {\n            res.push(bytes[i]);\n        }\n    }\n    return res;\n}\nfunction halfbyte2int(bits, copies) {\n    // bits in reverse order\n    let k = 1;\n    let temp = 0;\n    for (let i = 0; i < bits.length / DEFAULT_PARAM_COPIES; i += 1) {\n        const candidates = [];\n        for (let j = 0; j < DEFAULT_PARAM_COPIES; j += 1) {\n            candidates.push(bits[i * DEFAULT_PARAM_COPIES + j]);\n        }\n        const elect = () => (candidates.filter((c) => c === 1).length >= DEFAULT_PARAM_COPIES / 2 ? 1 : 0);\n        temp += k * elect();\n        k <<= 1;\n    }\n    return temp;\n}\nexport function param2bits(options) {\n    return int2halfbyte((options.copies - 1) / 2, DEFAULT_PARAM_COPIES); // 4 bit * copies\n}\nexport function bits2param(bits) {\n    const copies = 1 + halfbyte2int(bits, DEFAULT_PARAM_COPIES) * 2;\n    return copies;\n}\nexport function mergeBits(dest, ...src) {\n    let k = 0;\n    for (let i = 0; i < src.length; i += 1) {\n        const bits = src[i];\n        for (let j = 0; j < bits.length && k < dest.length; j += 1, k += 1) {\n            dest[k] = bits[j];\n        }\n    }\n    return dest;\n}\nexport function getBit(block, options) {\n    const [pos1, pos2] = getPos(options);\n    if (options.verbose)\n        console.warn('decoded value: ', block[pos1], block[pos2]);\n    const diff = block[pos1] - block[pos2];\n    return { bit: (diff > 0 ? 1 : 0), diff: diff };\n}\nexport function setBit(block, bit, options, tolerance) {\n    const [pos1, pos2] = getPos(options);\n    let v1 = block[pos1];\n    let v2 = block[pos2];\n    const t0 = Math.abs(v1 - v2);\n    const t = t0 > 1.5 * tolerance\n        ? 0.5 * tolerance\n        : t0 < 0.3 * tolerance\n            ? 1.5 * tolerance\n            : t0 < 0.5 * tolerance\n                ? 1.2 * tolerance\n                : tolerance;\n    [v1, v2] = v1 < v2 ? [v1 - t / 2, v2 + t / 2] : [v1 + t / 2, v2 - t / 2];\n    if (options.verbose)\n        console.warn('encoded value: ', v1, v2);\n    if (bit) {\n        //bit '1':  block[pos1] > block[pos2]\n        ;\n        [block[pos1], block[pos2]] = v1 < v2 ? [v2, v1] : [v1, v2];\n        if (options.transformAlgorithm === TransformAlgorithm.FFT2D)\n            // coefficients of fft2d are sysmetric to (size - 1 / 2, )\n            [block[72 - pos1], block[72 - pos2]] = v1 < v2 ? [v2, v1] : [v1, v2];\n    }\n    else {\n        // bit '0':  block[pos1] < block[pos2]\n        ;\n        [block[pos1], block[pos2]] = v1 < v2 ? [v1, v2] : [v2, v1];\n        if (options.transformAlgorithm === TransformAlgorithm.FFT2D)\n            // coefficients of fft2d are sysmetric to (size - 1 / 2, )\n            [block[72 - pos1], block[72 - pos2]] = v1 < v2 ? [v1, v2] : [v2, v1];\n    }\n}\n","import { GrayscaleAlgorithm, grayscale, narrow } from '../utils/grayscale.js';\nimport { transform, inverseTransform } from '../utils/transform.js';\nimport { cropImg, updateImgByBlock, updateImgByPixel, visitImgByBlock, updateImgByPixelAt, updateImgByPixelChannelAt, } from '../utils/image.js';\nimport { mergeBits, str2bits, setBit, getBit, bits2str, param2bits, bits2param } from './bit.js';\nimport { getPos } from './position.js';\nimport { isPixelVisibleAt, isBlockVisibleAt } from '../utils/mask.js';\nimport { rand, randomBits, shuffleGroupBy3, unshuffleGroupBy3 } from '../utils/helper.js';\nimport { loc2idx, loc2coord } from '../utils/locator.js';\nimport { DEFAULT_PARAM_COPIES, SEED } from '../constant.js';\nfunction getCharfromIdx(idx, copies, text) {\n    const charId = Math.floor(idx / (8 * copies));\n    const bitId = idx % (8 * copies);\n    const codes = Array.from(encodeURI(text));\n    if (charId > codes.length)\n        return 'OUT_OF_BOUND' + '(charId: ' + charId + ')';\n    else\n        return codes[charId] + '(charId: ' + charId + ', bitId: ' + bitId + ')';\n}\nexport async function encodeImg(imgData, maskData, options, defaultRandomSource) {\n    const { text, size, narrow: narrowSize, copies, grayscaleAlgorithm, transformAlgorithm, exhaustPixels } = options;\n    const [width, height] = cropImg(imgData, options);\n    const sizeOfBlocks = (width * height * 3) / (size * size);\n    const textBits = str2bits(text, copies);\n    const paramsBits = param2bits(options);\n    const randomSource = options.randomSource || defaultRandomSource;\n    const bits = mergeBits(randomBits(randomSource, sizeOfBlocks), paramsBits, textBits, Array(8 * copies).fill(1));\n    const encodeLen = textBits.length + 8 * copies;\n    if (encodeLen > sizeOfBlocks) {\n        process.stderr.write('bits overflow! try to shrink text or reduce copies.\\n');\n    }\n    if (grayscaleAlgorithm !== GrayscaleAlgorithm.NONE || narrowSize > 0) {\n        updateImgByPixel(imgData, ([r, g, b, a], loc) => {\n            if (!isPixelVisibleAt(maskData, loc)) {\n                return [r, g, b, a];\n            }\n            // decolor\n            if (grayscaleAlgorithm !== GrayscaleAlgorithm.NONE) {\n                const y = grayscale(r, g, b, grayscaleAlgorithm);\n                r = y;\n                g = y;\n                b = y;\n            }\n            // narrow color value\n            if (narrowSize > 0) {\n                r = narrow(r, narrowSize);\n                g = narrow(g, narrowSize);\n                b = narrow(b, narrowSize);\n            }\n            return [r, g, b, a];\n        });\n    }\n    const im = new Array(size * size);\n    let blockId = -1;\n    const shuffleArr = new Array(sizeOfBlocks).fill(0).map((v, i) => i);\n    shuffleGroupBy3(shuffleArr, SEED); // shuffle by binding 3 blocks together (RGB)\n    const encodedId = shuffleArr.map((v, i) => {\n        if (i < encodeLen)\n            return v;\n    });\n    updateImgByBlock(imgData, options, (block, loc) => {\n        // Remove transparency for PNG. Even though we do not encode alpha channel,\n        // the social media compression on transparant image can casue the information loss.\n        if (loc.c === 0) {\n            const [x, y] = loc2coord(loc, options);\n            for (let i = 0; i < size * size; i += 1) {\n                const idx = loc2idx(loc, options, x, y, i);\n                updateImgByPixelChannelAt(imgData, idx, 3, 255);\n            }\n        }\n        blockId += 1;\n        if (!exhaustPixels && !(blockId in encodedId)) {\n            return false;\n        }\n        if (!isBlockVisibleAt(maskData, loc, options)) {\n            if (options.fakeMaskPixels && loc.c === 0) {\n                const [x, y] = loc2coord(loc, options);\n                const g = rand(randomSource, 10, 127);\n                updateImgByPixelAt(imgData.data, [g, g, g, 255], loc2idx(loc, options, x, y, rand(randomSource, 0, 64)));\n            }\n            return false;\n        }\n        if (options.verbose) {\n            console.warn('Encode on image block (blockId: ' + blockId + '): ' + block);\n        }\n        transform(block, im.fill(0), transformAlgorithm, options);\n        const tolerance = () => {\n            const x = ((blockId * size) / 3) % loc.w;\n            const y = Math.floor((blockId * size) / 3 / loc.w) * size;\n            let t = options.tolerance;\n            if (x <= 8 || x > loc.w - 2 * size || y <= size || y > loc.h - 2 * size)\n                t = 1.5 * t;\n            if (options.verbose) {\n                console.warn('Encode with tolerance: ' + t + ' (Image size is width: ' + loc.w + ' height:' + loc.h + ')');\n            }\n            return t;\n        };\n        const t = tolerance();\n        let diff1 = 0;\n        let maxRetry = 5;\n        while (true) {\n            setBit(block, bits[shuffleArr[loc.b]], options, t);\n            const [pos1, pos2] = getPos(options);\n            diff1 = diff1 === 0 ? block[pos1] - block[pos2] : diff1;\n            if (options.verbose) {\n                const bitOrigin = shuffleArr[loc.b] < paramsBits.length\n                    ? 'PARAM_BITS'\n                    : getCharfromIdx(shuffleArr[loc.b] - paramsBits.length, copies, text);\n                console.warn('Encode bit: ' + bits[shuffleArr[loc.b]] + ' From char: ' + bitOrigin);\n                console.warn(block);\n            }\n            inverseTransform(block, im, transformAlgorithm, options);\n            const imgBlock = block.map((v) => (v < 0 ? 0 : v > 255 ? 255 : Math.round(v)));\n            transform(imgBlock, im.fill(0), transformAlgorithm, options);\n            const newDiff = imgBlock[pos1] - imgBlock[pos2];\n            if (options.verbose)\n                console.warn('After encode, the params diff is: ' +\n                    newDiff +\n                    ' (' +\n                    imgBlock[pos1] +\n                    '-' +\n                    imgBlock[pos2] +\n                    ') diff1: ' +\n                    diff1);\n            if (Math.abs(newDiff) < Math.abs(diff1 * 0.8)) {\n                if (options.verbose)\n                    console.warn('Repeat set bit with tolerance: ' + t + ' (max repeat times: ' + maxRetry + ')');\n                if ((maxRetry -= 1) === 0) {\n                    break;\n                }\n                // block = imgBlock;\n                for (let i = 0; i < size * size; i += 1)\n                    block[i] = imgBlock[i];\n                continue;\n            }\n            break;\n        }\n        return true;\n    });\n    return imgData;\n}\nexport async function decodeImg(imgData, maskData, options) {\n    const { size, transformAlgorithm } = options;\n    const richBits = [];\n    const im = new Array(size * size);\n    const [width, height] = cropImg(imgData, options);\n    const sizeOfBlocks = (width * height * 3) / (size * size);\n    const shuffleArr = new Array(sizeOfBlocks).fill(0).map((v, i) => i);\n    shuffleGroupBy3(shuffleArr, SEED);\n    let blockId = 0;\n    visitImgByBlock(imgData, options, (block, loc) => {\n        if (!isBlockVisibleAt(maskData, loc, options)) {\n            return false;\n        }\n        transform(block, im.fill(0), transformAlgorithm, options);\n        if (options.verbose && blockId >= 4 * DEFAULT_PARAM_COPIES) {\n            const i = blockId - 4 * DEFAULT_PARAM_COPIES;\n            console.warn('charId: ' +\n                Math.floor(shuffleArr[i] / (8 * options.copies)) +\n                ', bitId: ' +\n                (shuffleArr[i] % (8 * options.copies)));\n            console.warn('bit: ' + getBit(block, options).bit, block);\n        }\n        // let { bit, diff } = getBit(block, acc, options);\n        richBits.push(getBit(block, options));\n        blockId += 1;\n        return true;\n    });\n    unshuffleGroupBy3(richBits, SEED);\n    const copiesBits = richBits.slice(0, 4 * DEFAULT_PARAM_COPIES).map((v) => v.bit);\n    const copies = bits2param(copiesBits);\n    if (options.verbose) {\n        console.warn('copies is ' + copies);\n    }\n    // return bits2str(bits, 3, options.verbose);\n    return bits2str(richBits.slice(4 * DEFAULT_PARAM_COPIES), copies, options.verbose);\n}\n","import { encodeImg } from './stego.js';\nimport { cropImg } from '../utils/image.js';\nexport { decodeImg as decode } from './stego.js';\nexport async function encode(imgData, maskData, options, defaultRandomSource) {\n    const { width, height } = imgData;\n    const [cropWidth, cropHeight] = cropImg(imgData, options);\n    return {\n        data: await encodeImg(imgData, maskData, options, defaultRandomSource),\n        width: options.cropEdgePixels ? cropWidth : width,\n        height: options.cropEdgePixels ? cropHeight : height,\n    };\n}\n","import { AlgorithmVersion } from './stego-params.js';\nimport * as v1 from '../v1/index.js';\nimport * as v2 from '../v2/index.js';\nconst algorithms = {\n    [AlgorithmVersion.V1]: v1,\n    [AlgorithmVersion.V2]: v2,\n};\nexport function createAPI(_) {\n    const { preprocessImage, toPNG: toBuffer, toImageData, defaultRandomSource } = _;\n    return {\n        async encode(image, mask, options) {\n            const { data, height, width } = await algorithms[options.version].encode(preprocessImage(await toImageData(image)), preprocessImage(await toImageData(mask)).data, options, defaultRandomSource);\n            return toBuffer(data, height, width);\n        },\n        async decode(image, mask, options) {\n            return algorithms[options.version].decode(await toImageData(image), (await toImageData(mask)).data, options);\n        },\n    };\n}\n","export { AlgorithmVersion } from './stego-params.js';\nexport { GrayscaleAlgorithm } from './grayscale.js';\nexport { TransformAlgorithm } from './transform.js';\n","import { createAPI } from './utils/expose.js';\nimport { getImageType } from './utils/helper.js';\nimport { preprocessImage } from './utils/image.js';\nexport { getImageType } from './utils/helper.js';\nexport * from './utils/types.js';\nexport * from './constant.js';\nexport const { encode, decode } = createAPI({\n    toImageData(_data) {\n        return new Promise((resolve) => {\n            const data = new Uint8Array(_data);\n            const type = getImageType(data);\n            const blob = new Blob([data], { type });\n            resolve(getImageData(blob));\n        });\n    },\n    async toPNG(imgData, height = imgData.height, width = imgData.width) {\n        const canvas = createCanvas(width, height);\n        const context = canvas.getContext('2d');\n        context.putImageData(imgData, 0, 0, 0, 0, width, height);\n        if (isOffscreenCanvas(canvas)) {\n            return canvas.convertToBlob({ type: 'image/png' }).then(toUint8Array);\n        }\n        else {\n            return new Promise((resolve, reject) => {\n                canvas.toBlob((blob) => {\n                    if (blob)\n                        resolve(toUint8Array(blob));\n                    else\n                        reject(new Error('fail to convert to png'));\n                }, 'image/png');\n            });\n        }\n    },\n    preprocessImage(data) {\n        return preprocessImage(data, (w, h) => createCanvas(w, h).getContext('2d')?.createImageData(w, h) ?? null);\n    },\n    defaultRandomSource(buffer) {\n        return crypto.getRandomValues(buffer);\n    },\n});\nasync function toUint8Array(blob) {\n    const buffer = await blob.arrayBuffer();\n    return new Uint8Array(buffer);\n}\nfunction createCanvas(width, height) {\n    let canvas;\n    if (typeof OffscreenCanvas === 'function') {\n        canvas = new OffscreenCanvas(width, height);\n    }\n    else {\n        canvas = document.createElement('canvas');\n        canvas.width = width;\n        canvas.height = height;\n    }\n    return canvas;\n}\nasync function getImageData(imageBlob) {\n    let width, height;\n    let image;\n    if (typeof createImageBitmap === 'function') {\n        image = await createImageBitmap(imageBlob);\n        width = image.width;\n        height = image.height;\n    }\n    else {\n        const url = URL.createObjectURL(imageBlob);\n        image = await new Promise((resolve, reject) => {\n            const element = new Image();\n            element.addEventListener('load', () => {\n                width = element.width;\n                height = element.height;\n                resolve(element);\n            });\n            element.addEventListener('error', reject);\n            element.src = url;\n        }).finally(() => URL.revokeObjectURL(url));\n    }\n    const canvas = createCanvas(width, height);\n    const ctx = canvas.getContext('2d');\n    ctx.drawImage(image, 0, 0);\n    return ctx.getImageData(0, 0, width, height);\n}\nfunction isOffscreenCanvas(value) {\n    return typeof OffscreenCanvas === 'function' && value instanceof OffscreenCanvas;\n}\n"],"names":[],"sourceRoot":"","x_google_ignoreList":[]}