{"version":3,"file":"bundled/npm.async-call-rpc.js","mappings":"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ACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,yBAAyB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+EAA+E;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mCAAmC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,oEAAoE,oCAAoC;AACxG;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gNAAgN;AAC5N;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mOAAmO;AAC/O;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8CAA8C;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO,KAAK,OAAO,KAAK,8BAA8B,aAAa,OAAO;AACrG;AACA;AACA;AACA;AACA;AACA,sCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,kBAAkB,oBAAoB,OAAO,GAAG,OAAO,GAAG;AAC1D;AACA,6BAA6B,KAAK,OAAO;AACzC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,UAAU,IAAI,aAAa,GAAG,UAAU,OAAO,QAAQ,MAAM,iBAAiB,yCAAyC,UAAU,IAAI,aAAa,GAAG,UAAU,KAAK,QAAQ,IAAI,iBAAiB;AAChQ;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kDAAkD,IAAI,SAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iCAAiC;AAC7C;AACA;AACA;AACA,gIAAgI,GAAG;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,KAAK;;AAEuF;AAC5F","sources":["webpack://mask-network/./node_modules/.pnpm/async-call-rpc@6.3.1/node_modules/async-call-rpc/out/base.min.mjs","webpack://mask-network/./node_modules/.pnpm/async-call-rpc@6.3.1/node_modules/async-call-rpc/out/full.mjs"],"sourcesContent":["function e(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}class r extends Error{constructor(r,t,n,i){super(t),e(this,\"name\",void 0),e(this,\"code\",void 0),e(this,\"stack\",void 0),this.name=r,this.code=n,this.stack=i}}let t={},n={},i=[{},{},t,n],o=(e,r)=>{let t=i.indexOf(e);return r.message+=`Error ${t}: https://github.com/Jack-Works/async-call-rpc/wiki/Errors#`+t,r},l={__proto__:null,Error,EvalError,RangeError,ReferenceError,SyntaxError,TypeError,URIError},a=\"DOMException:\",s=(e,t,n,i)=>{try{let o=u();if(e.startsWith(a)&&o){let r=e.slice(a.length);return new o(t,r)}if(!(e in l))return new r(e,t,n,i);{let r=new l[e](t);return r.stack=i,r.code=n,r}}catch(r){return Error(`E${n} ${e}: ${t}\n${i}`)}},c=e=>(e+\"\").replace(/^.+\\n.+\\n/,\"\"),u=()=>{try{return DOMException}catch(e){}},f=e=>\"string\"==typeof e,y=e=>\"boolean\"==typeof e,p=e=>\"function\"==typeof e,d=e=>\"object\"==typeof e&&null!==e,h=\"Error\",g=void 0,m=e=>Promise.resolve(e),b=Array.isArray,w=()=>\"() => replay()\",E=(e,r,t,n)=>{let i={jsonrpc:\"2.0\",id:e,method:r,params:t,remoteStack:n};return z(i,\"id\"),N(i,\"remoteStack\"),i},P=(e,r)=>{let t={jsonrpc:\"2.0\",id:e,result:r};return z(t,\"id\"),t},$=(e,r,t,n)=>{e===g&&(e=null),Number.isNaN(r=Math.floor(r))&&(r=-1);let i={jsonrpc:\"2.0\",id:e,error:{code:r,message:t,data:n}};return z(i.error,\"data\"),i},k=(e,r)=>{let t=j({},e,r),n=t.error;return n.code=-32700,n.message=\"Parse error\",t},O=e=>$(e,-32600,\"Invalid Request\"),S=e=>$(e,-32601,\"Method not found\"),j=(e,r,t)=>{let{id:n}=e,{code:i,message:o,data:l}=t(r,e);return $(n,i,o,l)},v=(e=\"\",r=-1)=>t=>{let n=x(\"\",()=>t.message),i=x(h,(e=t.constructor)=>p(e)&&e.name),o=u();o&&t instanceof o&&(i=a+t.name),(f(t)||\"number\"==typeof t||y(t)||\"bigint\"==typeof t)&&(i=h,n=t+\"\");let l=e?{stack:e,type:i}:{type:i};return{code:r,message:n,data:l}},_=e=>{if(!d(e)||!(\"jsonrpc\"in e)||\"2.0\"!==e.jsonrpc)return!1;if(\"params\"in e){let r=e.params;if(!b(r)&&!d(r))return!1}return!0},x=(e,r)=>{try{let t=r();if(t===g)return e;return t+\"\"}catch(r){return e}},z=(e,r)=>{e[r]===g&&delete e[r]},N=(e,r)=>{e[r]||delete e[r]},A={serialization:e=>e,deserialization:e=>e},M=(e=[g,g],r,t=\"null\")=>({serialization(n){if(t&&d(n)&&\"result\"in n&&n.result===g){let e={...n};e.result=null,\"keep\"===t&&(e.undef=!0),n=e}return JSON.stringify(n,e[0],r)},deserialization(r){let t=JSON.parse(r,e[1]);return d(t)&&\"result\"in t&&null===t.result&&\"undef\"in t&&!0===t.undef&&(t.result=g,delete t.undef),t}}),C=\"AsyncCall/\",R=Symbol.for(C+\"ignored\"),W=Symbol.for(C+\"notify\"),D=Symbol.for(C+\"batch\");function J(e){return p(e)?e[W]:new Proxy(e,{get:T})}let T=(e,r)=>e[r][W];function I(e){let r=[],t=new Proxy({},{get(t,i){let o=(...t)=>e[D](r,i,...t);return o[W]=(...t)=>e[D][W](r,i,...t),o[W][W]=o[W],f(i)&&Object.defineProperty(n,i,{value:o,configurable:!0}),o}}),n={__proto__:t};return[new Proxy(n,{getPrototypeOf:()=>null,setPrototypeOf:(e,r)=>null===r}),()=>{r.length&&r.r[0](),r.length=0},(e=Error(\"Aborted\"))=>{r.length&&r.r[1](e),r.length=0}]}let q=()=>Math.random().toString(36).slice(2),F=e=>void 0===e||e,U=e=>{if(\"all\"===e)return[!0,!0,!0,!0,!0,!0];if(!y(e)){let{beCalled:r,localError:t,remoteError:n,type:i,requestReplay:o,sendLocalStack:l}=e;return[F(r),F(t),F(n),\"basic\"!==i,o,l]}return e?[!0,!0,!0,!0]:[]},B=e=>{if(!y(e)){let{methodNotFound:r,unknownMessage:t}=e;return[r,t]}return[e,e]};function G(e,r){let i,l,a,u,y=!0,$=async()=>{try{i=await e}catch(e){l=e,ei(\"AsyncCall failed to start\",e)}finally{y=!1}},x=e=>(a=e,K(e)&&e.setup(e=>ey(e).then(ep),e=>{let r=eh(e);return!!_(r)||m(r).then(_)}),H(e)&&e.on&&e.on(r=>ey(r).then(ep).then(r=>r&&e.send(r))),e),{serializer:z,key:N=\"rpc\",strict:A=!0,log:M=!0,parameterStructures:C=\"by-position\",preferLocalImplementation:J=!1,idGenerator:T=q,mapError:I,logger:F,channel:G,thenable:L}=r;e instanceof Promise?$():(i=e,y=!1);let[Q,V]=B(A),[X,Y,Z,ee,er,et]=U(M),{log:en,error:ei=en,debug:eo=en,groupCollapsed:el=en,groupEnd:ea=en,warn:es=en}=F||console,ec=new Map,eu=async e=>{if(y)await $();else if(l)return eg(l,\"\",e);let r=\"\";try{let{params:t,method:n,id:o,remoteStack:l}=e,a=n.startsWith(\"rpc.\")?Symbol.for(n):n,s=i&&i[a];if(!p(s)){if(Q)return S(o);Y&&eo(\"Missing method\",a,e);return}let u=b(t)?t:[t];r=c(Error().stack);let f=new Promise(e=>e(s.apply(i,u)));if(X){if(ee){let e=[`${N}.%c${n}%c(${u.map(()=>\"%o\").join(\", \")}%c)\n%o %c@${o}`,\"color: #d2c057\",\"\",...u,\"\",f,\"color: gray; font-style: italic;\"];if(er){let r=()=>{debugger;return s.apply(i,u)};r.toString=w,e.push(r)}l?(el(...e),en(l),ea()):en(...e)}else en(`${N}.${n}(${[...u].toString()}) @${o}`)}let y=await f;if(y===R)return;return P(o,y)}catch(t){return eg(t,r,e)}},ef=async e=>{let r=\"\",t=\"\",n=0,i=h;if(\"error\"in e){let o=e.error;r=o.message,n=o.code;let l=o.data;t=d(l)&&\"stack\"in l&&f(l.stack)?l.stack:\"<remote stack not available>\",i=d(l)&&\"type\"in l&&f(l.type)?l.type:h,Z&&(ee?ei(`${i}: ${r}(${n}) %c@${e.id}\n%c${t}`,\"color: gray\",\"\"):ei(`${i}: ${r}(${n}) @${e.id}\n${t}`))}let{id:o}=e;if(null===o||o===g||!ec.has(o))return;let[l,a,c=\"\"]=ec.get(o);ec.delete(o),\"error\"in e?a(s(i,r,n,t+\"\\n    Ð°t AsyncCall (rpc) \\n\"+c)):l(e.result)},ey=async e=>{let r;let t=g;try{if(r=await eh(e),_(r))return t=await ew(r);if(b(r)&&r.every(_)&&0!==r.length)return Promise.all(r.map(ew));if(!V)return g;{let e=r.id;return e===g&&(e=null),O(e)}}catch(e){return Y&&ei(e,r,t),k(e,I||v(e&&e.stack))}},ep=async e=>{if(e){if(!b(e))return ed(e);{let r=e.filter(e=>e&&\"id\"in e);if(0===r.length)return;return ed(r)}}},ed=z?e=>z.serialization(e):Object,eh=z?e=>z.deserialization(e):Object;G instanceof Promise?u=G.then(x):x(G);let eg=(e,r,t)=>(d(e)&&\"stack\"in e&&(e.stack=r.split(\"\\n\").reduce((e,r)=>e.replace(r+\"\\n\",\"\"),\"\"+e.stack)),Y&&ei(e),j(t,e,I||v(et?e.stack:g))),em=async(e,r=!1)=>{r&&(e=[...e]);let t=await ed(e);return(a||await u).send(t)},eb=(e,r)=>{for(let t of e)if(\"id\"in t){let e=ec.get(t.id);e&&e[1](r)}},ew=async e=>{if(\"method\"in e){let r=eu(e);if(\"id\"in e)return r;try{await r}catch(e){}return g}return ef(e)},eE=(e,r,n,l=!1)=>new Promise((a,s)=>{let u=g;if(e===D&&(u=r.shift(),e=r.shift()),\"symbol\"==typeof e){let r=Symbol.keyFor(e)||e.description;if(r){if(r.startsWith(\"rpc.\"))e=r;else throw TypeError(\"Not start with rpc.\")}}else if(e.startsWith(\"rpc.\"))throw o(t,TypeError());if(J&&!y&&f(e)){let t=i&&i[e];if(p(t))return a(t(...r))}let h=T();n=c(n);let m=\"by-name\"===C&&1===r.length&&d(r[0])?r[0]:r,b=E(l?g:h,e,m,et?n:g);if(u?(u.push(b),u.r||(u.r=[()=>em(u,!0),e=>eb(u,e)])):em(b).catch(s),l)return a();ec.set(h,[a,s,n])}),eP=(e,r)=>{let t={[r]:(...e)=>eE(r,e,Error().stack)}[r],n={[r]:(...e)=>eE(r,e,Error().stack,!0)}[r];return t[W]=n[W]=n,f(r)&&Object.defineProperty(e$,r,{value:t,configurable:!0}),t},e$={__proto__:new Proxy({},{get:eP})};return!1===L?e$.then=g:L===g&&Object.defineProperty(e$,\"then\",{configurable:!0,get(){es(o(n,TypeError(\"RPC used as Promise: \")))}}),new Proxy(e$,{getPrototypeOf:()=>null,setPrototypeOf:(e,r)=>null===r,getOwnPropertyDescriptor:(e,r)=>(r in e$||eP(e,r),Object.getOwnPropertyDescriptor(e$,r))})}let H=e=>\"send\"in e&&p(e.send),K=e=>\"setup\"in e&&p(e.setup);export{G as AsyncCall,M as JSONSerialization,A as NoSerialization,I as batch,J as notify};\n//# sourceMappingURL=base.min.mjs.map\n","/// <reference types=\"./full.d.ts\" />\nfunction _define_property$1(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nclass CustomError extends Error {\n    constructor(name, message, code, stack){\n        super(message);\n        _define_property$1(this, \"name\", void 0);\n        _define_property$1(this, \"code\", void 0);\n        _define_property$1(this, \"stack\", void 0);\n        this.name = name;\n        this.code = code;\n        this.stack = stack;\n    }\n}\nconst Err_Cannot_find_a_running_iterator_with_given_ID = {};\nconst Err_Only_string_can_be_the_RPC_method_name = {};\nconst Err_Cannot_call_method_starts_with_rpc_dot_directly = {};\nconst Err_Then_is_accessed_on_local_implementation_Please_explicitly_mark_if_it_is_thenable_in_the_options = {};\nconst Messages = [\n    Err_Cannot_find_a_running_iterator_with_given_ID,\n    Err_Only_string_can_be_the_RPC_method_name,\n    Err_Cannot_call_method_starts_with_rpc_dot_directly,\n    Err_Then_is_accessed_on_local_implementation_Please_explicitly_mark_if_it_is_thenable_in_the_options\n];\n// https://github.com/Jack-Works/async-call-rpc/wiki/Error-messages\nconst makeHostedMessage = (id, error)=>{\n    const n = Messages.indexOf(id);\n    error.message += `Error ${n}: https://github.com/Jack-Works/async-call-rpc/wiki/Errors#` + n;\n    return error;\n};\n// ! side effect\n/** These Error is defined in ECMAScript spec */ const errors = {\n    // @ts-expect-error\n    __proto__: null,\n    Error,\n    EvalError,\n    RangeError,\n    ReferenceError,\n    SyntaxError,\n    TypeError,\n    URIError\n};\nconst DOMExceptionHeader = 'DOMException:';\n/**\n * AsyncCall support somehow transfer ECMAScript Error\n */ const RecoverError = (type, message, code, stack)=>{\n    try {\n        const E = globalDOMException();\n        if (type.startsWith(DOMExceptionHeader) && E) {\n            const name = type.slice(DOMExceptionHeader.length);\n            return new E(message, name);\n        } else if (type in errors) {\n            const e = new errors[type](message);\n            e.stack = stack;\n            // @ts-expect-error\n            e.code = code;\n            return e;\n        } else {\n            return new CustomError(type, message, code, stack);\n        }\n    } catch (e) {\n        return new Error(`E${code} ${type}: ${message}\\n${stack}`);\n    }\n};\nconst removeStackHeader = (stack)=>String(stack).replace(/^.+\\n.+\\n/, '');\n// ! side effect\nconst globalDOMException = ()=>{\n    try {\n        // @ts-expect-error\n        return DOMException;\n    } catch (e) {}\n};\n\nconst isString = (x)=>typeof x === 'string';\nconst isBoolean = (x)=>typeof x === 'boolean';\nconst isFunction = (x)=>typeof x === 'function';\nconst isObject = (params)=>typeof params === 'object' && params !== null;\nconst ERROR = 'Error';\nconst undefined$1 = void 0;\nconst Object_setPrototypeOf = Object.setPrototypeOf;\nconst Promise_resolve = (x)=>Promise.resolve(x);\nconst isArray = Array.isArray;\nconst replayFunction = ()=>'() => replay()';\n\nconst jsonrpc = '2.0';\nconst Request = (id, method, params, remoteStack)=>{\n    const x = {\n        jsonrpc,\n        id,\n        method,\n        params,\n        remoteStack\n    };\n    deleteUndefined(x, 'id');\n    deleteFalsy(x, 'remoteStack');\n    return x;\n};\nconst SuccessResponse = (id, result)=>{\n    const x = {\n        jsonrpc,\n        id,\n        result\n    };\n    deleteUndefined(x, 'id');\n    return x;\n};\nconst ErrorResponse = (id, code, message, data)=>{\n    if (id === undefined$1) id = null;\n    code = Math.floor(code);\n    if (Number.isNaN(code)) code = -1;\n    const x = {\n        jsonrpc,\n        id,\n        error: {\n            code,\n            message,\n            data\n        }\n    };\n    deleteUndefined(x.error, 'data');\n    return x;\n};\n// Pre defined error in section 5.1\n// ! side effect\nconst ErrorResponseParseError = (e, mapper)=>{\n    const obj = ErrorResponseMapped({}, e, mapper);\n    const o = obj.error;\n    o.code = -32700;\n    o.message = 'Parse error';\n    return obj;\n};\n// Not using.\n// InvalidParams -32602 'Invalid params'\n// InternalError -32603 'Internal error'\nconst ErrorResponseInvalidRequest = (id)=>ErrorResponse(id, -32600, 'Invalid Request');\nconst ErrorResponseMethodNotFound = (id)=>ErrorResponse(id, -32601, 'Method not found');\nconst ErrorResponseMapped = (request, e, mapper)=>{\n    const { id  } = request;\n    const { code , message , data  } = mapper(e, request);\n    return ErrorResponse(id, code, message, data);\n};\nconst defaultErrorMapper = (stack = '', code = -1)=>(e)=>{\n        let message = toString('', ()=>e.message);\n        let type = toString(ERROR, (ctor = e.constructor)=>isFunction(ctor) && ctor.name);\n        const E = globalDOMException();\n        if (E && e instanceof E) type = DOMExceptionHeader + e.name;\n        if (isString(e) || typeof e === 'number' || isBoolean(e) || typeof e === 'bigint') {\n            type = ERROR;\n            message = String(e);\n        }\n        const data = stack ? {\n            stack,\n            type\n        } : {\n            type\n        };\n        return {\n            code,\n            message,\n            data\n        };\n    };\nconst isJSONRPCObject = (data)=>{\n    if (!isObject(data)) return false;\n    if (!('jsonrpc' in data)) return false;\n    if (data.jsonrpc !== jsonrpc) return false;\n    if ('params' in data) {\n        const params = data.params;\n        if (!isArray(params) && !isObject(params)) return false;\n    }\n    return true;\n};\nconst toString = (_default, val)=>{\n    try {\n        const v = val();\n        if (v === undefined$1) return _default;\n        return String(v);\n    } catch (e) {\n        return _default;\n    }\n};\nconst deleteUndefined = (x, key)=>{\n    if (x[key] === undefined$1) delete x[key];\n};\nconst deleteFalsy = (x, key)=>{\n    if (!x[key]) delete x[key];\n};\n\n//#region Serialization\n/**\n * Serialization implementation that do nothing\n * @remarks {@link Serialization}\n * @public\n * @deprecated Will be removed in next major version\n */ const NoSerialization = {\n    serialization (from) {\n        return from;\n    },\n    deserialization (serialized) {\n        return serialized;\n    }\n};\n/**\n * Create a serialization by JSON.parse/stringify\n *\n * @param replacerAndReceiver - Replacer and receiver of JSON.parse/stringify\n * @param space - Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.\n * @param undefinedKeepingBehavior - How to keep \"undefined\" in result of SuccessResponse?\n *\n * If it is not handled properly, JSON.stringify will emit an invalid JSON RPC object.\n *\n * Options:\n * - `\"null\"`(**default**): convert it to null.\n * - `\"keep\"`: try to keep it by additional property \"undef\".\n * - `false`: Don't keep it, let it break.\n * @remarks {@link Serialization}\n * @public\n */ const JSONSerialization = (replacerAndReceiver = [\n    undefined$1,\n    undefined$1\n], space, undefinedKeepingBehavior = 'null')=>({\n        serialization (from) {\n            if (undefinedKeepingBehavior && isObject(from) && 'result' in from && from.result === undefined$1) {\n                const alt = {\n                    ...from\n                };\n                alt.result = null;\n                if (undefinedKeepingBehavior === 'keep') alt.undef = true;\n                from = alt;\n            }\n            return JSON.stringify(from, replacerAndReceiver[0], space);\n        },\n        deserialization (serialized) {\n            const result = JSON.parse(serialized, replacerAndReceiver[1]);\n            if (isObject(result) && 'result' in result && result.result === null && 'undef' in result && result.undef === true) {\n                result.result = undefined$1;\n                delete result.undef;\n            }\n            return result;\n        }\n    } //#endregion\n    );\n\nconst i$1 = 'AsyncCall/';\n// ! side effect\nconst AsyncCallIgnoreResponse = Symbol.for(i$1 + 'ignored');\nconst AsyncCallNotify = Symbol.for(i$1 + 'notify');\nconst AsyncCallBatch = Symbol.for(i$1 + 'batch');\n\n/**\n * Wrap the AsyncCall instance to send notification.\n * @param instanceOrFnOnInstance - The AsyncCall instance or function on the AsyncCall instance\n * @example\n * const notifyOnly = notify(AsyncCall(...))\n * @public\n */ function notify(instanceOrFnOnInstance) {\n    if (isFunction(instanceOrFnOnInstance)) return instanceOrFnOnInstance[AsyncCallNotify];\n    return new Proxy(instanceOrFnOnInstance, {\n        get: notifyTrap\n    });\n}\nconst notifyTrap = (target, p)=>{\n    return target[p][AsyncCallNotify];\n};\n\n/**\n * Wrap the AsyncCall instance to use batch call.\n * @param asyncCallInstance - The AsyncCall instance\n * @example\n * const [batched, send, drop] = batch(AsyncCall(...))\n * batched.call1() // pending\n * batched.call2() // pending\n * send() // send all pending requests\n * drop() // drop all pending requests\n * @returns It will return a tuple.\n *\n * The first item is the batched version of AsyncCall instance passed in.\n *\n * The second item is a function to send all pending requests.\n *\n * The third item is a function to drop and reject all pending requests.\n * @public\n */ function batch(asyncCallInstance) {\n    const queue = [];\n    const getTrap = new Proxy({}, {\n        get (_, p) {\n            // @ts-expect-error\n            const f = (...args)=>asyncCallInstance[AsyncCallBatch](queue, p, ...args);\n            // @ts-expect-error\n            f[AsyncCallNotify] = (...args)=>// @ts-expect-error\n                asyncCallInstance[AsyncCallBatch][AsyncCallNotify](queue, p, ...args);\n            // @ts-expect-error\n            f[AsyncCallNotify][AsyncCallNotify] = f[AsyncCallNotify];\n            isString(p) && Object.defineProperty(methodContainer, p, {\n                value: f,\n                configurable: true\n            });\n            return f;\n        }\n    });\n    const methodContainer = {\n        __proto__: getTrap\n    };\n    return [\n        new Proxy(methodContainer, {\n            getPrototypeOf: ()=>null,\n            setPrototypeOf: (_, value)=>value === null\n        }),\n        ()=>{\n            queue.length && queue.r[0]();\n            queue.length = 0;\n        },\n        (error = new Error('Aborted'))=>{\n            queue.length && queue.r[1](error);\n            queue.length = 0;\n        }\n    ];\n}\n\nconst generateRandomID = ()=>Math.random().toString(36).slice(2);\n\nconst undefinedToTrue = (x)=>x === void 0 ? true : x;\nconst normalizeLogOptions = (log)=>{\n    if (log === 'all') return [\n        true,\n        true,\n        true,\n        true,\n        true,\n        true\n    ];\n    if (!isBoolean(log)) {\n        const { beCalled , localError , remoteError , type , requestReplay , sendLocalStack  } = log;\n        return [\n            undefinedToTrue(beCalled),\n            undefinedToTrue(localError),\n            undefinedToTrue(remoteError),\n            type !== 'basic',\n            requestReplay,\n            sendLocalStack\n        ];\n    }\n    if (log) return [\n        true,\n        true,\n        true,\n        true\n    ];\n    return [];\n};\nconst normalizeStrictOptions = (strict)=>{\n    if (!isBoolean(strict)) {\n        const { methodNotFound , unknownMessage  } = strict;\n        return [\n            methodNotFound,\n            unknownMessage\n        ];\n    }\n    return [\n        strict,\n        strict\n    ];\n};\n\n/**\n * Create a RPC server & client.\n *\n * @remarks\n * See {@link AsyncCallOptions}\n *\n * thisSideImplementation can be a Promise so you can write:\n *\n * ```ts\n * export const service = AsyncCall(typeof window === 'object' ? {} : import('./backend/service.js'), {})\n * ```\n *\n * @param thisSideImplementation - The implementation when this AsyncCall acts as a JSON RPC server. Can be a Promise.\n * @param options - {@link AsyncCallOptions}\n * @typeParam OtherSideImplementedFunctions - The type of the API that server expose. For any function on this interface, it will be converted to the async version.\n * @returns Same as the `OtherSideImplementedFunctions` type parameter, but every function in that interface becomes async and non-function value is removed. Method called \"then\" are also removed.\n * @public\n */ function AsyncCall(thisSideImplementation, options) {\n    let isThisSideImplementationPending = true;\n    let resolvedThisSideImplementationValue;\n    let rejectedThisSideImplementation;\n    let resolvedChannel;\n    let channelPromise;\n    // This promise should never fail\n    const awaitThisSideImplementation = async ()=>{\n        try {\n            resolvedThisSideImplementationValue = await thisSideImplementation;\n        } catch (e) {\n            rejectedThisSideImplementation = e;\n            console_error('AsyncCall failed to start', e);\n        } finally{\n            isThisSideImplementationPending = false;\n        }\n    };\n    const onChannelResolved = (channel)=>{\n        resolvedChannel = channel;\n        if (isCallbackBasedChannel(channel)) {\n            channel.setup((data)=>rawMessageReceiver(data).then(rawMessageSender), (data)=>{\n                const _ = deserialization(data);\n                if (isJSONRPCObject(_)) return true;\n                return Promise_resolve(_).then(isJSONRPCObject);\n            });\n        }\n        if (isEventBasedChannel(channel)) {\n            const m = channel;\n            m.on && m.on((_)=>rawMessageReceiver(_).then(rawMessageSender).then((x)=>x && m.send(x)));\n        }\n        return channel;\n    };\n    const { serializer , key: logKey = 'rpc' , strict =true , log =true , parameterStructures ='by-position' , preferLocalImplementation =false , idGenerator =generateRandomID , mapError , logger , channel , thenable  } = options;\n    if (thisSideImplementation instanceof Promise) awaitThisSideImplementation();\n    else {\n        resolvedThisSideImplementationValue = thisSideImplementation;\n        isThisSideImplementationPending = false;\n    }\n    const [banMethodNotFound, banUnknownMessage] = normalizeStrictOptions(strict);\n    const [log_beCalled, log_localError, log_remoteError, log_pretty, log_requestReplay, log_sendLocalStack] = normalizeLogOptions(log);\n    const { log: console_log , error: console_error = console_log , debug: console_debug = console_log , groupCollapsed: console_groupCollapsed = console_log , groupEnd: console_groupEnd = console_log , warn: console_warn = console_log  } = logger || console;\n    const requestContext = new Map();\n    const onRequest = async (data)=>{\n        if (isThisSideImplementationPending) await awaitThisSideImplementation();\n        else {\n            // not pending\n            if (rejectedThisSideImplementation) return makeErrorObject(rejectedThisSideImplementation, '', data);\n        }\n        let frameworkStack = '';\n        try {\n            const { params , method , id: req_id , remoteStack  } = data;\n            // ? We're mapping any method starts with 'rpc.' to a Symbol.for\n            const key = method.startsWith('rpc.') ? Symbol.for(method) : method;\n            const executor = resolvedThisSideImplementationValue && resolvedThisSideImplementationValue[key];\n            if (!isFunction(executor)) {\n                if (!banMethodNotFound) {\n                    if (log_localError) console_debug('Missing method', key, data);\n                    return;\n                } else return ErrorResponseMethodNotFound(req_id);\n            }\n            const args = isArray(params) ? params : [\n                params\n            ];\n            frameworkStack = removeStackHeader(new Error().stack);\n            const promise = new Promise((resolve)=>resolve(executor.apply(resolvedThisSideImplementationValue, args)));\n            if (log_beCalled) {\n                if (log_pretty) {\n                    const logArgs = [\n                        `${logKey}.%c${method}%c(${args.map(()=>'%o').join(', ')}%c)\\n%o %c@${req_id}`,\n                        'color: #d2c057',\n                        '',\n                        ...args,\n                        '',\n                        promise,\n                        'color: gray; font-style: italic;'\n                    ];\n                    if (log_requestReplay) {\n                        // This function will be logged to the console so it must be 1 line\n                        // prettier-ignore\n                        const replay = ()=>{\n                            debugger;\n                            return executor.apply(resolvedThisSideImplementationValue, args);\n                        };\n                        replay.toString = replayFunction;\n                        logArgs.push(replay);\n                    }\n                    if (remoteStack) {\n                        console_groupCollapsed(...logArgs);\n                        console_log(remoteStack);\n                        console_groupEnd();\n                    } else console_log(...logArgs);\n                } else console_log(`${logKey}.${method}(${[\n                    ...args\n                ].toString()}) @${req_id}`);\n            }\n            const result = await promise;\n            if (result === AsyncCallIgnoreResponse) return;\n            return SuccessResponse(req_id, result);\n        } catch (e) {\n            return makeErrorObject(e, frameworkStack, data);\n        }\n    };\n    const onResponse = async (data)=>{\n        let errorMessage = '', remoteErrorStack = '', errorCode = 0, errorType = ERROR;\n        if ('error' in data) {\n            const e = data.error;\n            errorMessage = e.message;\n            errorCode = e.code;\n            const detail = e.data;\n            if (isObject(detail) && 'stack' in detail && isString(detail.stack)) remoteErrorStack = detail.stack;\n            else remoteErrorStack = '<remote stack not available>';\n            if (isObject(detail) && 'type' in detail && isString(detail.type)) errorType = detail.type;\n            else errorType = ERROR;\n            if (log_remoteError) log_pretty ? console_error(`${errorType}: ${errorMessage}(${errorCode}) %c@${data.id}\\n%c${remoteErrorStack}`, 'color: gray', '') : console_error(`${errorType}: ${errorMessage}(${errorCode}) @${data.id}\\n${remoteErrorStack}`);\n        }\n        const { id  } = data;\n        if (id === null || id === undefined$1 || !requestContext.has(id)) return;\n        const [resolve, reject, localErrorStack = ''] = requestContext.get(id);\n        requestContext.delete(id);\n        if ('error' in data) {\n            reject(RecoverError(errorType, errorMessage, errorCode, // ? We use \\u0430 which looks like \"a\" to prevent browser think \"at AsyncCall\" is a real stack\n            remoteErrorStack + '\\n    \\u0430t AsyncCall (rpc) \\n' + localErrorStack));\n        } else {\n            resolve(data.result);\n        }\n        return;\n    };\n    const rawMessageReceiver = async (_)=>{\n        let data;\n        let result = undefined$1;\n        try {\n            data = await deserialization(_);\n            if (isJSONRPCObject(data)) {\n                return result = await handleSingleMessage(data);\n            } else if (isArray(data) && data.every(isJSONRPCObject) && data.length !== 0) {\n                return Promise.all(data.map(handleSingleMessage));\n            } else {\n                if (banUnknownMessage) {\n                    let id = data.id;\n                    if (id === undefined$1) id = null;\n                    return ErrorResponseInvalidRequest(id);\n                } else {\n                    // ? Ignore this message. The message channel maybe also used to transfer other message too.\n                    return undefined$1;\n                }\n            }\n        } catch (e) {\n            if (log_localError) console_error(e, data, result);\n            // todo: should check before access e.stack\n            return ErrorResponseParseError(e, mapError || defaultErrorMapper(e && e.stack));\n        }\n    };\n    const rawMessageSender = async (res)=>{\n        if (!res) return;\n        if (isArray(res)) {\n            const reply = res.filter((x)=>x && 'id' in x);\n            if (reply.length === 0) return;\n            return serialization(reply);\n        } else {\n            return serialization(res);\n        }\n    };\n    const serialization = serializer ? (x)=>serializer.serialization(x) : Object;\n    const deserialization = serializer ? (x)=>serializer.deserialization(x) : Object;\n    if (channel instanceof Promise) channelPromise = channel.then(onChannelResolved);\n    else onChannelResolved(channel);\n    const makeErrorObject = (e, frameworkStack, data)=>{\n        if (isObject(e) && 'stack' in e) e.stack = frameworkStack.split('\\n').reduce((stack, fstack)=>stack.replace(fstack + '\\n', ''), '' + e.stack);\n        if (log_localError) console_error(e);\n        return ErrorResponseMapped(data, e, mapError || defaultErrorMapper(log_sendLocalStack ? e.stack : undefined$1));\n    };\n    const sendPayload = async (payload, removeQueueR = false)=>{\n        if (removeQueueR) payload = [\n            ...payload\n        ];\n        const data = await serialization(payload);\n        return (resolvedChannel || await channelPromise).send(data);\n    };\n    const rejectsQueue = (queue, error)=>{\n        for (const x of queue){\n            if ('id' in x) {\n                const ctx = requestContext.get(x.id);\n                ctx && ctx[1](error);\n            }\n        }\n    };\n    const handleSingleMessage = async (data)=>{\n        if ('method' in data) {\n            const r = onRequest(data);\n            if ('id' in data) return r;\n            try {\n                await r;\n            } catch (e) {}\n            return undefined$1 // Does not care about return result for notifications\n            ;\n        }\n        return onResponse(data);\n    };\n    const call = (method, args, stack, notify = false)=>{\n        return new Promise((resolve, reject)=>{\n            let queue = undefined$1;\n            if (method === AsyncCallBatch) {\n                queue = args.shift();\n                method = args.shift();\n            }\n            if (typeof method === 'symbol') {\n                const RPCInternalMethod = Symbol.keyFor(method) || method.description;\n                if (RPCInternalMethod) {\n                    if (RPCInternalMethod.startsWith('rpc.')) method = RPCInternalMethod;\n                    else throw new TypeError('Not start with rpc.');\n                }\n            } else if (method.startsWith('rpc.')) {\n                throw makeHostedMessage(Err_Cannot_call_method_starts_with_rpc_dot_directly, new TypeError());\n            }\n            if (preferLocalImplementation && !isThisSideImplementationPending && isString(method)) {\n                const localImpl = resolvedThisSideImplementationValue && resolvedThisSideImplementationValue[method];\n                if (isFunction(localImpl)) return resolve(localImpl(...args));\n            }\n            const id = idGenerator();\n            stack = removeStackHeader(stack);\n            const param = parameterStructures === 'by-name' && args.length === 1 && isObject(args[0]) ? args[0] : args;\n            const request = Request(notify ? undefined$1 : id, method, param, log_sendLocalStack ? stack : undefined$1);\n            if (queue) {\n                queue.push(request);\n                if (!queue.r) queue.r = [\n                    ()=>sendPayload(queue, true),\n                    (e)=>rejectsQueue(queue, e)\n                ];\n            } else sendPayload(request).catch(reject);\n            if (notify) return resolve();\n            requestContext.set(id, [\n                resolve,\n                reject,\n                stack\n            ]);\n        });\n    };\n    const getTrap = (_, method)=>{\n        const f = {\n            // This function will be logged to the console so it must be 1 line\n            [method]: (..._)=>call(method, _, new Error().stack)\n        }[method];\n        const f2 = {\n            [method]: (..._)=>call(method, _, new Error().stack, true)\n        }[method];\n        // @ts-expect-error\n        f[AsyncCallNotify] = f2[AsyncCallNotify] = f2;\n        isString(method) && Object.defineProperty(methodContainer, method, {\n            value: f,\n            configurable: true\n        });\n        return f;\n    };\n    const methodContainer = {\n        __proto__: new Proxy({}, {\n            get: getTrap\n        })\n    };\n    if (thenable === false) methodContainer.then = undefined$1;\n    else if (thenable === undefined$1) {\n        Object.defineProperty(methodContainer, 'then', {\n            configurable: true,\n            get () {\n                console_warn(makeHostedMessage(Err_Then_is_accessed_on_local_implementation_Please_explicitly_mark_if_it_is_thenable_in_the_options, new TypeError('RPC used as Promise: ')));\n            }\n        });\n    }\n    return new Proxy(methodContainer, {\n        getPrototypeOf: ()=>null,\n        setPrototypeOf: (_, value)=>value === null,\n        // some library will treat this object as a normal object and run algorithm steps in https://tc39.es/ecma262/#sec-ordinaryget\n        getOwnPropertyDescriptor (_, method) {\n            if (!(method in methodContainer)) getTrap(_, method) // trigger [[Get]]\n            ;\n            return Object.getOwnPropertyDescriptor(methodContainer, method);\n        }\n    });\n}\nconst isEventBasedChannel = (x)=>'send' in x && isFunction(x.send);\nconst isCallbackBasedChannel = (x)=>'setup' in x && isFunction(x.setup);\n\n/**\n * See the document at https://github.com/Jack-Works/async-call/\n */ function _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nconst i = 'rpc.async-iterator.';\n// ! side effect\nconst AsyncIteratorStart = Symbol.for(i + 'start');\nconst AsyncIteratorNext = Symbol.for(i + 'next');\nconst AsyncIteratorReturn = Symbol.for(i + 'return');\nconst AsyncIteratorThrow = Symbol.for(i + 'throw');\n/**\n * The async generator version of the AsyncCall\n * @param thisSideImplementation - The implementation when this AsyncCall acts as a JSON RPC server.\n * @param options - {@link AsyncCallOptions}\n * @typeParam OtherSideImplementedFunctions - The type of the API that server expose. For any function on this interface, AsyncCall will convert it to the Promised type.\n * @remarks\n * Warning: Due to technical limitation, AsyncGeneratorCall will leak memory. Use it at your own risk.\n *\n * To use AsyncGeneratorCall, the server and the client MUST support the following JSON RPC internal methods which is pre ECMAScript async generator semantics:\n *\n * - `rpc.async-iterator.start`\n *\n * - `rpc.async-iterator.next`\n *\n * - `rpc.async-iterator.return`\n *\n * - `rpc.async-iterator.throw`\n *\n * @example\n * ```ts\n * const server = {\n *      async *generator() {\n *          let last = 0\n *          while (true) yield last++\n *      },\n * }\n * type Server = typeof server\n * const serverRPC = AsyncGeneratorCall<Server>({}, { channel })\n * async function main() {\n *      for await (const x of serverRPC.generator()) {\n *          console.log('Server yielded number', x)\n *      }\n * }\n * ```\n * @public\n */ function AsyncGeneratorCall(thisSideImplementation, options) {\n    const iterators = new Map();\n    var _options_strict;\n    const [methodNotFound] = normalizeStrictOptions((_options_strict = options.strict) !== null && _options_strict !== void 0 ? _options_strict : true);\n    const { idGenerator =generateRandomID  } = options;\n    const findIterator = (id, next)=>{\n        const it = iterators.get(id);\n        if (!it) {\n            if (methodNotFound) throw makeHostedMessage(Err_Cannot_find_a_running_iterator_with_given_ID, new Error(`Iterator ${id}, `));\n            else return AsyncCallIgnoreResponse;\n        }\n        const result = next(it);\n        isFinished(result, ()=>iterators.delete(id));\n        return result;\n    };\n    const server = {\n        async [AsyncIteratorStart] (method, args) {\n            const iteratorGenerator = (await thisSideImplementation)[method];\n            if (!isFunction(iteratorGenerator)) {\n                if (methodNotFound) throw new TypeError(method + ' is not a function');\n                else return AsyncCallIgnoreResponse;\n            }\n            const iterator = iteratorGenerator(...args);\n            const id = idGenerator();\n            iterators.set(id, iterator);\n            return id;\n        },\n        [AsyncIteratorNext] (id, val) {\n            return findIterator(id, (it)=>it.next(val));\n        },\n        [AsyncIteratorReturn] (id, val) {\n            return findIterator(id, (it)=>isFunction(it.return) && it.return(val));\n        },\n        [AsyncIteratorThrow] (id, val) {\n            return findIterator(id, (it)=>isFunction(it.throw) && it.throw(val));\n        }\n    };\n    const remote = AsyncCall(server, options);\n    const getTrap = (_, method)=>{\n        if (!isString(method)) throw makeHostedMessage(Err_Only_string_can_be_the_RPC_method_name, new TypeError(''));\n        const f = {\n            [method]: (..._)=>{\n                const id = remote[AsyncIteratorStart](method, _);\n                return new _AsyncGenerator(remote, id);\n            }\n        }[method];\n        Object.defineProperty(methodContainer, method, {\n            value: f,\n            configurable: true\n        });\n        return f;\n    };\n    const methodContainer = {\n        __proto__: new Proxy({}, {\n            get: getTrap\n        })\n    };\n    return new Proxy(methodContainer, {\n        getPrototypeOf: ()=>null,\n        setPrototypeOf: (_, val)=>val === null,\n        // some library will treat this object as a normal object and run algorithm steps in https://tc39.es/ecma262/#sec-ordinaryget\n        getOwnPropertyDescriptor (_, method) {\n            if (!(method in methodContainer)) getTrap(_, method) // trigger [[Get]]\n            ;\n            return Object.getOwnPropertyDescriptor(methodContainer, method);\n        }\n    });\n}\nclass _AsyncGenerator {\n    async return(val) {\n        if (this.d) return makeIteratorResult(true, val);\n        return this.c(this.r[AsyncIteratorReturn](await this.i, val));\n    }\n    async next(val) {\n        if (this.d) return makeIteratorResult(true);\n        return this.c(this.r[AsyncIteratorNext](await this.i, val));\n    }\n    async throw(val) {\n        if (!this.d) return this.c(this.r[AsyncIteratorThrow](await this.i, val));\n        throw val;\n    }\n    /**\n     * @param r Remote Implementation\n     * @param i id\n     */ constructor(r, i){\n        _define_property(this, \"r\", void 0);\n        _define_property(this, \"i\", void 0);\n        /** done? */ _define_property(this, \"d\", void 0);\n        /** check */ _define_property(this, \"c\", void 0);\n        this.r = r;\n        this.i = i;\n        this.d = false;\n        this.c = async (val)=>{\n            await isFinished(val, ()=>this.d = true);\n            return val;\n        };\n    }\n}\n// ! side effect\nconst EmptyAsyncGenerator = async function*() {};\nconst AsyncGeneratorConstructor = EmptyAsyncGenerator.constructor;\nconst AsyncGeneratorConstructorPrototype = AsyncGeneratorConstructor.prototype;\nObject_setPrototypeOf(_AsyncGenerator, AsyncGeneratorConstructorPrototype);\nconst AsyncGeneratorPrototype = Object.getPrototypeOf(EmptyAsyncGenerator());\nObject_setPrototypeOf(_AsyncGenerator.prototype, AsyncGeneratorPrototype);\nconst isFinished = async (result, cb)=>{\n    try {\n        const x = await result;\n        x && x.done && cb();\n    } catch (e) {}\n};\nconst makeIteratorResult = (done, value = undefined)=>({\n        done,\n        value\n    });\n\nexport { AsyncCall, AsyncGeneratorCall, JSONSerialization, NoSerialization, batch, notify };\n//# sourceMappingURL=full.mjs.map\n"],"names":[],"sourceRoot":"","x_google_ignoreList":[0,1]}