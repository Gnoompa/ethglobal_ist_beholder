{"version":3,"file":"bundled/npm-ns.chainsafe.as-sha256.js","mappings":";;;;;AAAA;AACA;AACA,mBAAmB,QAAQ;AAC3B,sCAAsC;AACtC,mCAAmC;AACnC,sCAAsC;AACtC;AACA,gCAAgC;AAChC,gCAAgC;AAChC;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B;AACA;AACA;AACA,8BAA8B,IAAI,GAAG,KAAK,GAAG,KAAK,GAAG,IAAI;AACzD;AACA,KAAK;AACL,GAAG;AACH;;;;;;;;;AC1iBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B,GAAG,6BAA6B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;;;;;;;;ACtKa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B,GAAG,sBAAsB,GAAG,gBAAgB,GAAG,cAAc,GAAG,cAAc,GAAG,6BAA6B,GAAG,6BAA6B;AACzK,eAAe,mBAAO,CAAC,KAAoB;AAC3C,qBAAqB,mBAAO,CAAC,KAAc;AAC3C,yDAAwD,EAAE,qCAAqC,8CAA8C,EAAC;AAC9I,yDAAwD,EAAE,qCAAqC,8CAA8C,EAAC;AAC9I,iCAAiC,mBAAO,CAAC,KAAU;AACnD,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1Ga;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,mBAAO,CAAC,KAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf","sources":["webpack://mask-network/./node_modules/.pnpm/@chainsafe+as-sha256@0.3.1_patch_hash=4kkjukh2xlhntgm37imygbirga/node_modules/@chainsafe/as-sha256/build/optimized.js","webpack://mask-network/./node_modules/.pnpm/@chainsafe+as-sha256@0.3.1_patch_hash=4kkjukh2xlhntgm37imygbirga/node_modules/@chainsafe/as-sha256/lib/hashObject.js","webpack://mask-network/./node_modules/.pnpm/@chainsafe+as-sha256@0.3.1_patch_hash=4kkjukh2xlhntgm37imygbirga/node_modules/@chainsafe/as-sha256/lib/index.js","webpack://mask-network/./node_modules/.pnpm/@chainsafe+as-sha256@0.3.1_patch_hash=4kkjukh2xlhntgm37imygbirga/node_modules/@chainsafe/as-sha256/lib/sha256.js"],"sourcesContent":["  var bufferView;\n  var base64ReverseLookup = new Uint8Array(123/*'z'+1*/);\n  for (var i = 25; i >= 0; --i) {\n    base64ReverseLookup[48+i] = 52+i; // '0-9'\n    base64ReverseLookup[65+i] = i; // 'A-Z'\n    base64ReverseLookup[97+i] = 26+i; // 'a-z'\n  }\n  base64ReverseLookup[43] = 62; // '+'\n  base64ReverseLookup[47] = 63; // '/'\n  /** @noinline Inlining this function would mean expanding the base64 string 4x times in the source code, which Closure seems to be happy to do. */\n  function base64DecodeToExistingUint8Array(uint8Array, offset, b64) {\n    var b1, b2, i = 0, j = offset, bLength = b64.length, end = offset + (bLength*3>>2) - (b64[bLength-2] == '=') - (b64[bLength-1] == '=');\n    for (; i < bLength; i += 4) {\n      b1 = base64ReverseLookup[b64.charCodeAt(i+1)];\n      b2 = base64ReverseLookup[b64.charCodeAt(i+2)];\n      uint8Array[j++] = base64ReverseLookup[b64.charCodeAt(i)] << 2 | b1 >> 4;\n      if (j < end) uint8Array[j++] = b1 << 4 | b2 >> 2;\n      if (j < end) uint8Array[j++] = b2 << 6 | base64ReverseLookup[b64.charCodeAt(i+3)];\n    }\n  }\nfunction initActiveSegments(imports) {\n  base64DecodeToExistingUint8Array(bufferView, 17, \"AQAAAQAAAAAAAAAAAQAAmC+KQpFEN3HP+8C1pdu16VvCVjnxEfFZpII/ktVeHKuYqgfYAVuDEr6FMSTDfQxVdF2+cv6x3oCnBtybdPGbwcFpm+SGR77vxp3BD8yhDCRvLOktqoR0StypsFzaiPl2UlE+mG3GMajIJwOwx39Zv/ML4MZHkafVUWPKBmcpKRSFCrcnOCEbLvxtLE0TDThTVHMKZbsKanYuycKBhSxykqHov6JLZhqocItLwqNRbMcZ6JLRJAaZ1oU1DvRwoGoQFsGkGQhsNx5Md0gntbywNLMMHDlKqthOT8qcW/NvLmjugo90b2OleBR4yIQIAseM+v++kOtsUKT3o/m+8nhxxg==\");\n  base64DecodeToExistingUint8Array(bufferView, 288, \"EAAAAAEAAAADAAAAEAAAACAAAAAgAAAAAAEAAEA=\");\n  base64DecodeToExistingUint8Array(bufferView, 321, \"AQAAAQAAAAAAAAAAAQAAmC+KwpFEN3HP+8C1pdu16VvCVjnxEfFZpII/ktVeHKuYqgfYAVuDEr6FMSTDfQxVdF2+cv6x3oCnBtybdPObwcFpm2SGR/7wxu3hD1TyDCRvNOlPvoTJbB5BuWH6iPkWUlHG8m1ajqhl/Bmwx57ZucMxEpqg6g7nKyOx/bA+NcfVumkwX22Xy48RD1r97h7cibY1CgR6C96dyvRYFltd4YY+fwCAiQg3MuoHpTeVq28QYUAX8daMDW07qs03vrvA2jthg2OjSNsx6QILp1zRb8r6GlIxhDMxlRrUbpB4Q23ykZzDvavMnuagybU8ti9TxkHH0qN+IwdoS5Wkdh0ZTA==\");\n  base64DecodeToExistingUint8Array(bufferView, 592, \"EAAAAAEAAAADAAAAEAAAAFABAABQAQAAAAEAAEA=\");\n  base64DecodeToExistingUint8Array(bufferView, 624, \"HAAAAAEAAAABAAAAHAAAAEkAbgB2AGEAbABpAGQAIABsAGUAbgBnAHQAaA==\");\n  base64DecodeToExistingUint8Array(bufferView, 672, \"JgAAAAEAAAABAAAAJgAAAH4AbABpAGIALwBhAHIAcgBhAHkAYgB1AGYAZgBlAHIALgB0AHM=\");\n}\nfunction wasm2js_trap() { throw new Error('abort'); }\n\nfunction asmFunc(imports) {\n var buffer = new ArrayBuffer(65536);\n var HEAP8 = new Int8Array(buffer);\n var HEAP16 = new Int16Array(buffer);\n var HEAP32 = new Int32Array(buffer);\n var HEAPU8 = new Uint8Array(buffer);\n var HEAPU16 = new Uint16Array(buffer);\n var HEAPU32 = new Uint32Array(buffer);\n var HEAPF32 = new Float32Array(buffer);\n var HEAPF64 = new Float64Array(buffer);\n var Math_imul = Math.imul;\n var Math_fround = Math.fround;\n var Math_abs = Math.abs;\n var Math_clz32 = Math.clz32;\n var Math_min = Math.min;\n var Math_max = Math.max;\n var Math_floor = Math.floor;\n var Math_ceil = Math.ceil;\n var Math_trunc = Math.trunc;\n var Math_sqrt = Math.sqrt;\n var env = imports.env;\n var fimport$0 = env.abort;\n var global$0 = 512;\n var global$1 = 0;\n var global$2 = 0;\n var global$3 = 0;\n var global$4 = 0;\n var global$5 = 0;\n var global$6 = 0;\n var global$7 = 0;\n var global$8 = 0;\n var global$9 = 0;\n var global$10 = 0;\n var global$11 = 0;\n var global$12 = 0;\n var global$13 = 0;\n var global$14 = 0;\n var global$15 = 0;\n var global$16 = 0;\n var global$17 = 0;\n var global$18 = 0;\n var global$19 = 0;\n var global$20 = 0;\n var global$21 = 0;\n var global$22 = 0;\n var global$23 = 0;\n var global$24 = 0;\n var global$25 = 0;\n var global$26 = 0;\n var global$27 = 0;\n var global$28 = 0;\n var global$29 = 0;\n var global$30 = 0;\n var global$31 = 0;\n var global$32 = 0;\n var global$33 = 0;\n function $0($0_1) {\n  $0_1 = $0_1 | 0;\n  var $1_1 = 0, $2_1 = 0;\n  $2_1 = __wasm_memory_size();\n  $1_1 = $2_1 << 16 | 0;\n  if ($0_1 >>> 0 > $1_1 >>> 0) {\n   $1_1 = ((($0_1 - $1_1 | 0) + 65535 | 0) & -65536 | 0) >>> 16 | 0;\n   if ((__wasm_memory_grow((($2_1 | 0) > ($1_1 | 0) ? $2_1 : $1_1) | 0) | 0) < (0 | 0)) {\n    if ((__wasm_memory_grow($1_1 | 0) | 0) < (0 | 0)) {\n     wasm2js_trap()\n    }\n   }\n  }\n  global$23 = $0_1;\n }\n\n function $1($0_1) {\n  $0_1 = $0_1 | 0;\n  var $1_1 = 0, $2_1 = 0, $3_1 = 0;\n  if ($0_1 >>> 0 > 1073741808 >>> 0) {\n   wasm2js_trap()\n  }\n  $2_1 = global$23 + 16 | 0;\n  $1_1 = ($0_1 + 15 | 0) & -16 | 0;\n  $3_1 = $1_1 >>> 0 > 16 >>> 0 ? $1_1 : 16;\n  $0($2_1 + $3_1 | 0 | 0);\n  $1_1 = $2_1 - 16 | 0;\n  HEAP32[$1_1 >> 2] = $3_1;\n  HEAP32[($1_1 + 4 | 0) >> 2] = 1;\n  HEAP32[($1_1 + 8 | 0) >> 2] = 0;\n  HEAP32[($1_1 + 12 | 0) >> 2] = $0_1;\n  return $2_1 | 0;\n }\n\n function $2($0_1, $1_1) {\n  $0_1 = $0_1 | 0;\n  $1_1 = $1_1 | 0;\n  var $2_1 = 0;\n  label$1 : while (1) {\n   if ($1_1) {\n    $2_1 = $0_1;\n    $0_1 = $2_1 + 1 | 0;\n    HEAP8[$2_1 >> 0] = 0;\n    $1_1 = $1_1 - 1 | 0;\n    continue label$1;\n   }\n   break label$1;\n  };\n }\n\n function $3($0_1) {\n  $0_1 = $0_1 | 0;\n  var $1_1 = 0;\n  if ($0_1 >>> 0 > 1073741808 >>> 0) {\n   fimport$0(640 | 0, 688 | 0, 54 | 0, 42 | 0);\n   wasm2js_trap();\n  }\n  $1_1 = $1($0_1 | 0) | 0;\n  $2($1_1 | 0, $0_1 | 0);\n  return $1_1 | 0;\n }\n\n function $4() {\n  global$1 = HEAP32[308 >> 2] | 0;\n  global$2 = HEAP32[612 >> 2] | 0;\n  global$22 = 736;\n  global$23 = 736;\n  global$24 = $3(64 | 0) | 0;\n  global$25 = global$24;\n  global$26 = $3(256 | 0) | 0;\n  global$27 = global$26;\n  global$28 = $3(512 | 0) | 0;\n  global$29 = global$28;\n  global$30 = $3(32 | 0) | 0;\n  global$31 = global$30;\n }\n\n function $5() {\n  global$3 = 1779033703;\n  global$4 = -1150833019;\n  global$5 = 1013904242;\n  global$6 = -1521486534;\n  global$7 = 1359893119;\n  global$8 = -1694144372;\n  global$9 = 528734635;\n  global$10 = 1541459225;\n  global$32 = 0;\n  global$33 = 0;\n }\n\n function $6($0_1, $1_1, $2_1) {\n  $0_1 = $0_1 | 0;\n  $1_1 = $1_1 | 0;\n  $2_1 = $2_1 | 0;\n  var $3_1 = 0, $4_1 = 0;\n  label$1 : {\n   $3_1 = $2_1;\n   if (($0_1 | 0) == ($1_1 | 0)) {\n    break label$1\n   }\n   if ($0_1 >>> 0 < $1_1 >>> 0) {\n    label$3 : while (1) {\n     if ($3_1) {\n      $2_1 = $0_1;\n      $0_1 = $0_1 + 1 | 0;\n      $4_1 = $1_1;\n      $1_1 = $1_1 + 1 | 0;\n      HEAP8[$2_1 >> 0] = HEAPU8[$4_1 >> 0] | 0;\n      $3_1 = $3_1 - 1 | 0;\n      continue label$3;\n     }\n     break label$3;\n    }\n   } else {\n    label$6 : while (1) {\n     if ($3_1) {\n      $3_1 = $3_1 - 1 | 0;\n      HEAP8[($3_1 + $0_1 | 0) >> 0] = HEAPU8[($1_1 + $3_1 | 0) >> 0] | 0;\n      continue label$6;\n     }\n     break label$6;\n    }\n   }\n  }\n }\n\n function $7($0_1, $1_1) {\n  $0_1 = $0_1 | 0;\n  $1_1 = $1_1 | 0;\n  var $2_1 = 0, $51 = 0, $57 = 0, $78 = 0, $103 = 0, $108 = 0, $119 = 0, $140 = 0, $145 = 0, $146 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0;\n  global$11 = global$3;\n  global$12 = global$4;\n  global$13 = global$5;\n  global$14 = global$6;\n  global$15 = global$7;\n  global$16 = global$8;\n  global$17 = global$9;\n  global$18 = global$10;\n  global$19 = 0;\n  label$1 : while (1) {\n   if (global$19 >>> 0 < 16 >>> 0) {\n    $2_1 = global$19 << 2 | 0;\n    HEAP32[($0_1 + (global$19 << 2 | 0) | 0) >> 2] = (HEAPU8[($1_1 + $2_1 | 0) >> 0] | 0) << 24 | 0 | ((HEAPU8[($1_1 + ($2_1 + 1 | 0) | 0) >> 0] | 0) << 16 | 0) | 0 | ((HEAPU8[($1_1 + ($2_1 + 2 | 0) | 0) >> 0] | 0) << 8 | 0) | 0 | (HEAPU8[($1_1 + ($2_1 + 3 | 0) | 0) >> 0] | 0) | 0;\n    global$19 = global$19 + 1 | 0;\n    continue label$1;\n   }\n   break label$1;\n  };\n  global$19 = 16;\n  label$3 : while (1) {\n   if (global$19 >>> 0 < 64 >>> 0) {\n    $51 = $0_1 + (global$19 << 2 | 0) | 0;\n    $57 = HEAP32[($0_1 + ((global$19 - 16 | 0) << 2 | 0) | 0) >> 2] | 0;\n    $1_1 = HEAP32[($0_1 + ((global$19 - 2 | 0) << 2 | 0) | 0) >> 2] | 0;\n    $78 = (HEAP32[($0_1 + ((global$19 - 7 | 0) << 2 | 0) | 0) >> 2] | 0) + (((__wasm_rotr_i32($1_1 | 0, 17 | 0) | 0) ^ (__wasm_rotr_i32($1_1 | 0, 19 | 0) | 0) | 0) ^ ($1_1 >>> 10 | 0) | 0) | 0;\n    $1_1 = HEAP32[($0_1 + ((global$19 - 15 | 0) << 2 | 0) | 0) >> 2] | 0;\n    (wasm2js_i32$0 = $51, wasm2js_i32$1 = $57 + ($78 + (((__wasm_rotr_i32($1_1 | 0, 7 | 0) | 0) ^ (__wasm_rotr_i32($1_1 | 0, 18 | 0) | 0) | 0) ^ ($1_1 >>> 3 | 0) | 0) | 0) | 0), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;\n    global$19 = global$19 + 1 | 0;\n    continue label$3;\n   }\n   break label$3;\n  };\n  global$19 = 0;\n  label$5 : while (1) {\n   if (global$19 >>> 0 < 64 >>> 0) {\n    $103 = HEAP32[($0_1 + (global$19 << 2 | 0) | 0) >> 2] | 0;\n    $108 = HEAP32[(global$1 + (global$19 << 2 | 0) | 0) >> 2] | 0;\n    $1_1 = global$15;\n    $119 = global$18 + (((__wasm_rotr_i32($1_1 | 0, 6 | 0) | 0) ^ (__wasm_rotr_i32($1_1 | 0, 11 | 0) | 0) | 0) ^ (__wasm_rotr_i32($1_1 | 0, 25 | 0) | 0) | 0) | 0;\n    $1_1 = global$15;\n    global$20 = $103 + ($108 + ($119 + (($1_1 & global$16 | 0) ^ (global$17 & ($1_1 ^ -1 | 0) | 0) | 0) | 0) | 0) | 0;\n    $1_1 = global$11;\n    $140 = ((__wasm_rotr_i32($1_1 | 0, 2 | 0) | 0) ^ (__wasm_rotr_i32($1_1 | 0, 13 | 0) | 0) | 0) ^ (__wasm_rotr_i32($1_1 | 0, 22 | 0) | 0) | 0;\n    $1_1 = global$11;\n    $2_1 = global$12;\n    $145 = $1_1 & $2_1 | 0;\n    $146 = $1_1;\n    $1_1 = global$13;\n    global$21 = $140 + (($145 ^ ($146 & $1_1 | 0) | 0) ^ ($1_1 & $2_1 | 0) | 0) | 0;\n    global$18 = global$17;\n    global$17 = global$16;\n    global$16 = global$15;\n    global$15 = global$14 + global$20 | 0;\n    global$14 = global$13;\n    global$13 = global$12;\n    global$12 = global$11;\n    global$11 = global$20 + global$21 | 0;\n    global$19 = global$19 + 1 | 0;\n    continue label$5;\n   }\n   break label$5;\n  };\n  global$3 = global$3 + global$11 | 0;\n  global$4 = global$4 + global$12 | 0;\n  global$5 = global$5 + global$13 | 0;\n  global$6 = global$6 + global$14 | 0;\n  global$7 = global$7 + global$15 | 0;\n  global$8 = global$8 + global$16 | 0;\n  global$9 = global$9 + global$17 | 0;\n  global$10 = global$10 + global$18 | 0;\n }\n\n function $8($0_1, $1_1) {\n  $0_1 = $0_1 | 0;\n  $1_1 = $1_1 | 0;\n  var $2_1 = 0, $3_1 = 0, $57 = 0;\n  global$33 = $1_1 + global$33 | 0;\n  if (global$32) {\n   if ((64 - global$32 | 0 | 0) <= ($1_1 | 0)) {\n    $6(global$25 + global$32 | 0 | 0, $0_1 | 0, 64 - global$32 | 0 | 0);\n    global$32 = global$32 + (64 - global$32 | 0) | 0;\n    $2_1 = 64 - global$32 | 0;\n    $1_1 = $1_1 - (64 - global$32 | 0) | 0;\n    $7(global$27 | 0, global$25 | 0);\n    global$32 = 0;\n   } else {\n    $6(global$25 + global$32 | 0 | 0, $0_1 | 0, $1_1 | 0);\n    global$32 = $1_1 + global$32 | 0;\n    return;\n   }\n  }\n  label$4 : while (1) {\n   if (($3_1 | 0) < (($1_1 | 0) / (64 | 0) | 0 | 0)) {\n    $7(global$27 | 0, $0_1 + $2_1 | 0 | 0);\n    $3_1 = $3_1 + 1 | 0;\n    $2_1 = $2_1 - -64 | 0;\n    continue label$4;\n   }\n   break label$4;\n  };\n  if ($1_1 & 63 | 0) {\n   $57 = $0_1 + $2_1 | 0;\n   $0_1 = $1_1 & 63 | 0;\n   $6(global$25 + global$32 | 0 | 0, $57 | 0, $0_1 | 0);\n   global$32 = $0_1 + global$32 | 0;\n  }\n }\n\n function $9($0_1) {\n  $0_1 = $0_1 | 0;\n  return __wasm_rotl_i32($0_1 & -16711936 | 0 | 0, 8 | 0) | 0 | (__wasm_rotr_i32($0_1 & 16711935 | 0 | 0, 8 | 0) | 0) | 0 | 0;\n }\n\n function $10($0_1) {\n  $0_1 = $0_1 | 0;\n  var $1_1 = 0, $2_1 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0;\n  if ((global$33 & 63 | 0 | 0) < (63 | 0)) {\n   HEAP8[(global$25 + global$32 | 0) >> 0] = 128;\n   global$32 = global$32 + 1 | 0;\n  }\n  if ((global$33 & 63 | 0 | 0) >= (56 | 0)) {\n   $1_1 = global$25 + global$32 | 0;\n   $2_1 = $1_1 + (64 - global$32 | 0) | 0;\n   label$3 : while (1) {\n    if ($1_1 >>> 0 < $2_1 >>> 0) {\n     HEAP8[$1_1 >> 0] = 0;\n     $1_1 = $1_1 + 1 | 0;\n     continue label$3;\n    }\n    break label$3;\n   };\n   $7(global$27 | 0, global$25 | 0);\n   global$32 = 0;\n  }\n  if ((global$33 & 63 | 0 | 0) >= (63 | 0)) {\n   HEAP8[(global$25 + global$32 | 0) >> 0] = 128;\n   global$32 = global$32 + 1 | 0;\n  }\n  $1_1 = global$25 + global$32 | 0;\n  $2_1 = $1_1 + (56 - global$32 | 0) | 0;\n  label$6 : while (1) {\n   if ($1_1 >>> 0 < $2_1 >>> 0) {\n    HEAP8[$1_1 >> 0] = 0;\n    $1_1 = $1_1 + 1 | 0;\n    continue label$6;\n   }\n   break label$6;\n  };\n  (wasm2js_i32$0 = global$25 + 56 | 0, wasm2js_i32$1 = $9((global$33 | 0) / (536870912 | 0) | 0 | 0) | 0), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;\n  (wasm2js_i32$0 = global$25 + 60 | 0, wasm2js_i32$1 = $9(global$33 << 3 | 0 | 0) | 0), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;\n  $7(global$27 | 0, global$25 | 0);\n  (wasm2js_i32$0 = $0_1, wasm2js_i32$1 = $9(global$3 | 0) | 0), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;\n  (wasm2js_i32$0 = $0_1 + 4 | 0, wasm2js_i32$1 = $9(global$4 | 0) | 0), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;\n  (wasm2js_i32$0 = $0_1 + 8 | 0, wasm2js_i32$1 = $9(global$5 | 0) | 0), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;\n  (wasm2js_i32$0 = $0_1 + 12 | 0, wasm2js_i32$1 = $9(global$6 | 0) | 0), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;\n  (wasm2js_i32$0 = $0_1 + 16 | 0, wasm2js_i32$1 = $9(global$7 | 0) | 0), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;\n  (wasm2js_i32$0 = $0_1 + 20 | 0, wasm2js_i32$1 = $9(global$8 | 0) | 0), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;\n  (wasm2js_i32$0 = $0_1 + 24 | 0, wasm2js_i32$1 = $9(global$9 | 0) | 0), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;\n  (wasm2js_i32$0 = $0_1 + 28 | 0, wasm2js_i32$1 = $9(global$10 | 0) | 0), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;\n }\n\n function $11($0_1) {\n  $0_1 = $0_1 | 0;\n  $5();\n  $8(global$29 | 0, $0_1 | 0);\n  $10(global$31 | 0);\n }\n\n function $12($0_1) {\n  $0_1 = $0_1 | 0;\n  var $1_1 = 0, $2_1 = 0, $17 = 0, $28 = 0, $48 = 0, $53 = 0, $54 = 0;\n  global$11 = global$3;\n  global$12 = global$4;\n  global$13 = global$5;\n  global$14 = global$6;\n  global$15 = global$7;\n  global$16 = global$8;\n  global$17 = global$9;\n  global$18 = global$10;\n  global$19 = 0;\n  label$1 : while (1) {\n   if (global$19 >>> 0 < 64 >>> 0) {\n    $17 = HEAP32[($0_1 + (global$19 << 2 | 0) | 0) >> 2] | 0;\n    $1_1 = global$15;\n    $28 = global$18 + (((__wasm_rotr_i32($1_1 | 0, 6 | 0) | 0) ^ (__wasm_rotr_i32($1_1 | 0, 11 | 0) | 0) | 0) ^ (__wasm_rotr_i32($1_1 | 0, 25 | 0) | 0) | 0) | 0;\n    $1_1 = global$15;\n    global$20 = $17 + ($28 + (($1_1 & global$16 | 0) ^ (global$17 & ($1_1 ^ -1 | 0) | 0) | 0) | 0) | 0;\n    $1_1 = global$11;\n    $48 = ((__wasm_rotr_i32($1_1 | 0, 2 | 0) | 0) ^ (__wasm_rotr_i32($1_1 | 0, 13 | 0) | 0) | 0) ^ (__wasm_rotr_i32($1_1 | 0, 22 | 0) | 0) | 0;\n    $1_1 = global$11;\n    $2_1 = global$12;\n    $53 = $1_1 & $2_1 | 0;\n    $54 = $1_1;\n    $1_1 = global$13;\n    global$21 = $48 + (($53 ^ ($54 & $1_1 | 0) | 0) ^ ($1_1 & $2_1 | 0) | 0) | 0;\n    global$18 = global$17;\n    global$17 = global$16;\n    global$16 = global$15;\n    global$15 = global$14 + global$20 | 0;\n    global$14 = global$13;\n    global$13 = global$12;\n    global$12 = global$11;\n    global$11 = global$20 + global$21 | 0;\n    global$19 = global$19 + 1 | 0;\n    continue label$1;\n   }\n   break label$1;\n  };\n  global$3 = global$3 + global$11 | 0;\n  global$4 = global$4 + global$12 | 0;\n  global$5 = global$5 + global$13 | 0;\n  global$6 = global$6 + global$14 | 0;\n  global$7 = global$7 + global$15 | 0;\n  global$8 = global$8 + global$16 | 0;\n  global$9 = global$9 + global$17 | 0;\n  global$10 = global$10 + global$18 | 0;\n }\n\n function $13($0_1, $1_1) {\n  $0_1 = $0_1 | 0;\n  $1_1 = $1_1 | 0;\n  var wasm2js_i32$0 = 0, wasm2js_i32$1 = 0;\n  $5();\n  $7(global$27 | 0, $0_1 | 0);\n  $12(global$2 | 0);\n  (wasm2js_i32$0 = $1_1, wasm2js_i32$1 = $9(global$3 | 0) | 0), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;\n  (wasm2js_i32$0 = $1_1 + 4 | 0, wasm2js_i32$1 = $9(global$4 | 0) | 0), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;\n  (wasm2js_i32$0 = $1_1 + 8 | 0, wasm2js_i32$1 = $9(global$5 | 0) | 0), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;\n  (wasm2js_i32$0 = $1_1 + 12 | 0, wasm2js_i32$1 = $9(global$6 | 0) | 0), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;\n  (wasm2js_i32$0 = $1_1 + 16 | 0, wasm2js_i32$1 = $9(global$7 | 0) | 0), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;\n  (wasm2js_i32$0 = $1_1 + 20 | 0, wasm2js_i32$1 = $9(global$8 | 0) | 0), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;\n  (wasm2js_i32$0 = $1_1 + 24 | 0, wasm2js_i32$1 = $9(global$9 | 0) | 0), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;\n  (wasm2js_i32$0 = $1_1 + 28 | 0, wasm2js_i32$1 = $9(global$10 | 0) | 0), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;\n }\n\n function $14() {\n  $4();\n }\n\n function __wasm_rotl_i32(var$0, var$1) {\n  var$0 = var$0 | 0;\n  var$1 = var$1 | 0;\n  var var$2 = 0;\n  var$2 = var$1 & 31 | 0;\n  var$1 = (0 - var$1 | 0) & 31 | 0;\n  return ((-1 >>> var$2 | 0) & var$0 | 0) << var$2 | 0 | (((-1 << var$1 | 0) & var$0 | 0) >>> var$1 | 0) | 0 | 0;\n }\n\n function __wasm_rotr_i32(var$0, var$1) {\n  var$0 = var$0 | 0;\n  var$1 = var$1 | 0;\n  var var$2 = 0;\n  var$2 = var$1 & 31 | 0;\n  var$1 = (0 - var$1 | 0) & 31 | 0;\n  return ((-1 << var$2 | 0) & var$0 | 0) >>> var$2 | 0 | (((-1 >>> var$1 | 0) & var$0 | 0) << var$1 | 0) | 0 | 0;\n }\n\n bufferView = HEAPU8;\n initActiveSegments(imports);\n $14();\n function __wasm_memory_size() {\n  return buffer.byteLength / 65536 | 0;\n }\n\n function __wasm_memory_grow(pagesToAdd) {\n  pagesToAdd = pagesToAdd | 0;\n  var oldPages = __wasm_memory_size() | 0;\n  var newPages = oldPages + pagesToAdd | 0;\n  if ((oldPages < newPages) && (newPages < 65536)) {\n   var newBuffer = new ArrayBuffer(Math_imul(newPages, 65536));\n   var newHEAP8 = new Int8Array(newBuffer);\n   newHEAP8.set(HEAP8);\n   HEAP8 = new Int8Array(newBuffer);\n   HEAP16 = new Int16Array(newBuffer);\n   HEAP32 = new Int32Array(newBuffer);\n   HEAPU8 = new Uint8Array(newBuffer);\n   HEAPU16 = new Uint16Array(newBuffer);\n   HEAPU32 = new Uint32Array(newBuffer);\n   HEAPF32 = new Float32Array(newBuffer);\n   HEAPF64 = new Float64Array(newBuffer);\n   buffer = newBuffer;\n   bufferView = HEAPU8;\n  }\n  return oldPages;\n }\n\n return {\n  \"memory\": Object.create(Object.prototype, {\n   \"grow\": {\n    \"value\": __wasm_memory_grow\n   },\n   \"buffer\": {\n    \"get\": function () {\n     return buffer;\n    }\n\n   }\n  }),\n  \"INPUT_LENGTH\": {\n   get value() {\n    return global$0;\n   },\n   set value(_global$0) {\n    global$0 = _global$0;\n   }\n  },\n  \"input\": {\n   get value() {\n    return global$28;\n   },\n   set value(_global$28) {\n    global$28 = _global$28;\n   }\n  },\n  \"output\": {\n   get value() {\n    return global$30;\n   },\n   set value(_global$30) {\n    global$30 = _global$30;\n   }\n  },\n  \"init\": $5,\n  \"update\": $8,\n  \"final\": $10,\n  \"digest\": $11,\n  \"digest64\": $13\n };\n}\n\nmodule.exports.newInstance = function newInstance() {\n  return asmFunc({\n    \"env\": {\n      abort: function (msg, file, line, col) {\n        throw Error(`abort: ${msg}:${file}:${line}:${col}`);\n      }\n    },\n  });\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.byteArrayToHashObject = exports.hashObjectToByteArray = void 0;\n/**\n * Pass 8 numbers in an object and set that to inputArray.\n * This function contains multiple same procedures but we intentionally\n * do it step by step to improve performance a bit.\n **/\nfunction hashObjectToByteArray(obj, byteArr, offset) {\n    let tmp = obj.h0;\n    byteArr[0 + offset] = tmp & 0xff;\n    tmp = tmp >> 8;\n    byteArr[1 + offset] = tmp & 0xff;\n    tmp = tmp >> 8;\n    byteArr[2 + offset] = tmp & 0xff;\n    tmp = tmp >> 8;\n    byteArr[3 + offset] = tmp & 0xff;\n    tmp = obj.h1;\n    byteArr[4 + offset] = tmp & 0xff;\n    tmp = tmp >> 8;\n    byteArr[5 + offset] = tmp & 0xff;\n    tmp = tmp >> 8;\n    byteArr[6 + offset] = tmp & 0xff;\n    tmp = tmp >> 8;\n    byteArr[7 + offset] = tmp & 0xff;\n    tmp = obj.h2;\n    byteArr[8 + offset] = tmp & 0xff;\n    tmp = tmp >> 8;\n    byteArr[9 + offset] = tmp & 0xff;\n    tmp = tmp >> 8;\n    byteArr[10 + offset] = tmp & 0xff;\n    tmp = tmp >> 8;\n    byteArr[11 + offset] = tmp & 0xff;\n    tmp = obj.h3;\n    byteArr[12 + offset] = tmp & 0xff;\n    tmp = tmp >> 8;\n    byteArr[13 + offset] = tmp & 0xff;\n    tmp = tmp >> 8;\n    byteArr[14 + offset] = tmp & 0xff;\n    tmp = tmp >> 8;\n    byteArr[15 + offset] = tmp & 0xff;\n    tmp = obj.h4;\n    byteArr[16 + offset] = tmp & 0xff;\n    tmp = tmp >> 8;\n    byteArr[17 + offset] = tmp & 0xff;\n    tmp = tmp >> 8;\n    byteArr[18 + offset] = tmp & 0xff;\n    tmp = tmp >> 8;\n    byteArr[19 + offset] = tmp & 0xff;\n    tmp = obj.h5;\n    byteArr[20 + offset] = tmp & 0xff;\n    tmp = tmp >> 8;\n    byteArr[21 + offset] = tmp & 0xff;\n    tmp = tmp >> 8;\n    byteArr[22 + offset] = tmp & 0xff;\n    tmp = tmp >> 8;\n    byteArr[23 + offset] = tmp & 0xff;\n    tmp = obj.h6;\n    byteArr[24 + offset] = tmp & 0xff;\n    tmp = tmp >> 8;\n    byteArr[25 + offset] = tmp & 0xff;\n    tmp = tmp >> 8;\n    byteArr[26 + offset] = tmp & 0xff;\n    tmp = tmp >> 8;\n    byteArr[27 + offset] = tmp & 0xff;\n    tmp = obj.h7;\n    byteArr[28 + offset] = tmp & 0xff;\n    tmp = tmp >> 8;\n    byteArr[29 + offset] = tmp & 0xff;\n    tmp = tmp >> 8;\n    byteArr[30 + offset] = tmp & 0xff;\n    tmp = tmp >> 8;\n    byteArr[31 + offset] = tmp & 0xff;\n}\nexports.hashObjectToByteArray = hashObjectToByteArray;\n/**\n * Parse outputArray into an object of 8 numbers.\n * This is the order that makes Uint32Array the same to Uint8Array\n * This function contains multiple same procedures but we intentionally\n * do it step by step to improve performance a bit.\n **/\nfunction byteArrayToHashObject(byteArr) {\n    let tmp = 0;\n    tmp |= byteArr[3] & 0xff;\n    tmp = tmp << 8;\n    tmp |= byteArr[2] & 0xff;\n    tmp = tmp << 8;\n    tmp |= byteArr[1] & 0xff;\n    tmp = tmp << 8;\n    tmp |= byteArr[0] & 0xff;\n    const h0 = tmp;\n    tmp = 0;\n    tmp |= byteArr[7] & 0xff;\n    tmp = tmp << 8;\n    tmp |= byteArr[6] & 0xff;\n    tmp = tmp << 8;\n    tmp |= byteArr[5] & 0xff;\n    tmp = tmp << 8;\n    tmp |= byteArr[4] & 0xff;\n    const h1 = tmp;\n    tmp = 0;\n    tmp |= byteArr[11] & 0xff;\n    tmp = tmp << 8;\n    tmp |= byteArr[10] & 0xff;\n    tmp = tmp << 8;\n    tmp |= byteArr[9] & 0xff;\n    tmp = tmp << 8;\n    tmp |= byteArr[8] & 0xff;\n    const h2 = tmp;\n    tmp = 0;\n    tmp |= byteArr[15] & 0xff;\n    tmp = tmp << 8;\n    tmp |= byteArr[14] & 0xff;\n    tmp = tmp << 8;\n    tmp |= byteArr[13] & 0xff;\n    tmp = tmp << 8;\n    tmp |= byteArr[12] & 0xff;\n    const h3 = tmp;\n    tmp = 0;\n    tmp |= byteArr[19] & 0xff;\n    tmp = tmp << 8;\n    tmp |= byteArr[18] & 0xff;\n    tmp = tmp << 8;\n    tmp |= byteArr[17] & 0xff;\n    tmp = tmp << 8;\n    tmp |= byteArr[16] & 0xff;\n    const h4 = tmp;\n    tmp = 0;\n    tmp |= byteArr[23] & 0xff;\n    tmp = tmp << 8;\n    tmp |= byteArr[22] & 0xff;\n    tmp = tmp << 8;\n    tmp |= byteArr[21] & 0xff;\n    tmp = tmp << 8;\n    tmp |= byteArr[20] & 0xff;\n    const h5 = tmp;\n    tmp = 0;\n    tmp |= byteArr[27] & 0xff;\n    tmp = tmp << 8;\n    tmp |= byteArr[26] & 0xff;\n    tmp = tmp << 8;\n    tmp |= byteArr[25] & 0xff;\n    tmp = tmp << 8;\n    tmp |= byteArr[24] & 0xff;\n    const h6 = tmp;\n    tmp = 0;\n    tmp |= byteArr[31] & 0xff;\n    tmp = tmp << 8;\n    tmp |= byteArr[30] & 0xff;\n    tmp = tmp << 8;\n    tmp |= byteArr[29] & 0xff;\n    tmp = tmp << 8;\n    tmp |= byteArr[28] & 0xff;\n    const h7 = tmp;\n    return {\n        h0,\n        h1,\n        h2,\n        h3,\n        h4,\n        h5,\n        h6,\n        h7,\n    };\n}\nexports.byteArrayToHashObject = byteArrayToHashObject;\n//# sourceMappingURL=hashObject.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.digest64HashObjects = exports.digest2Bytes32 = exports.digest64 = exports.digest = exports.SHA256 = exports.hashObjectToByteArray = exports.byteArrayToHashObject = void 0;\nconst wasm_1 = require(\"../build/optimized\");\nconst hashObject_1 = require(\"./hashObject\");\nObject.defineProperty(exports, \"byteArrayToHashObject\", { enumerable: true, get: function () { return hashObject_1.byteArrayToHashObject; } });\nObject.defineProperty(exports, \"hashObjectToByteArray\", { enumerable: true, get: function () { return hashObject_1.hashObjectToByteArray; } });\nconst sha256_1 = __importDefault(require(\"./sha256\"));\nexports.SHA256 = sha256_1.default;\nconst ctx = wasm_1.newInstance();\nconst wasmInputValue = ctx.input.value;\nconst wasmOutputValue = ctx.output.value;\nconst inputUint8Array = new Uint8Array(ctx.memory.buffer, wasmInputValue, ctx.INPUT_LENGTH.value);\nconst outputUint8Array = new Uint8Array(ctx.memory.buffer, wasmOutputValue, 32);\nconst inputUint32Array = new Uint32Array(ctx.memory.buffer, wasmInputValue, ctx.INPUT_LENGTH.value);\nfunction digest(data) {\n    if (data.length === 64) {\n        return digest64(data);\n    }\n    if (data.length <= ctx.INPUT_LENGTH) {\n        inputUint8Array.set(data);\n        ctx.digest(data.length);\n        const output = new Uint8Array(32);\n        output.set(outputUint8Array);\n        return output;\n    }\n    ctx.init();\n    update(data);\n    return final();\n}\nexports.digest = digest;\nfunction digest64(data) {\n    if (data.length === 64) {\n        inputUint8Array.set(data);\n        ctx.digest64(wasmInputValue, wasmOutputValue);\n        const output = new Uint8Array(32);\n        output.set(outputUint8Array);\n        return output;\n    }\n    throw new Error(\"InvalidLengthForDigest64\");\n}\nexports.digest64 = digest64;\nfunction digest2Bytes32(bytes1, bytes2) {\n    if (bytes1.length === 32 && bytes2.length === 32) {\n        inputUint8Array.set(bytes1);\n        inputUint8Array.set(bytes2, 32);\n        ctx.digest64(wasmInputValue, wasmOutputValue);\n        const output = new Uint8Array(32);\n        output.set(outputUint8Array);\n        return output;\n    }\n    throw new Error(\"InvalidLengthForDigest64\");\n}\nexports.digest2Bytes32 = digest2Bytes32;\n/**\n * Digest 2 objects, each has 8 properties from h0 to h7.\n * The performance is a little bit better than digest64 due to the use of Uint32Array\n * and the memory is a little bit better than digest64 due to no temporary Uint8Array.\n * @returns\n */\nfunction digest64HashObjects(obj1, obj2) {\n    // TODO: expect obj1 and obj2 as HashObject\n    inputUint32Array[0] = obj1.h0;\n    inputUint32Array[1] = obj1.h1;\n    inputUint32Array[2] = obj1.h2;\n    inputUint32Array[3] = obj1.h3;\n    inputUint32Array[4] = obj1.h4;\n    inputUint32Array[5] = obj1.h5;\n    inputUint32Array[6] = obj1.h6;\n    inputUint32Array[7] = obj1.h7;\n    inputUint32Array[8] = obj2.h0;\n    inputUint32Array[9] = obj2.h1;\n    inputUint32Array[10] = obj2.h2;\n    inputUint32Array[11] = obj2.h3;\n    inputUint32Array[12] = obj2.h4;\n    inputUint32Array[13] = obj2.h5;\n    inputUint32Array[14] = obj2.h6;\n    inputUint32Array[15] = obj2.h7;\n    ctx.digest64(wasmInputValue, wasmOutputValue);\n    // extracting numbers from Uint32Array causes more memory\n    return hashObject_1.byteArrayToHashObject(outputUint8Array);\n}\nexports.digest64HashObjects = digest64HashObjects;\nfunction update(data) {\n    const INPUT_LENGTH = ctx.INPUT_LENGTH.value;\n    if (data.length > INPUT_LENGTH) {\n        for (let i = 0; i < data.length; i += INPUT_LENGTH) {\n            const sliced = data.slice(i, i + INPUT_LENGTH);\n            inputUint8Array.set(sliced);\n            ctx.update(wasmInputValue, sliced.length);\n        }\n    }\n    else {\n        inputUint8Array.set(data);\n        ctx.update(wasmInputValue, data.length);\n    }\n}\nfunction final() {\n    ctx.final(wasmOutputValue);\n    const output = new Uint8Array(32);\n    output.set(outputUint8Array);\n    return output;\n}\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst wasm_1 = require(\"../build/optimized.js\");\n/**\n * Class based SHA256\n */\nclass SHA256 {\n    constructor() {\n        this.ctx = wasm_1.newInstance();\n        this.wasmInputValue = this.ctx.input.value;\n        this.wasmOutputValue = this.ctx.output.value;\n        this.uint8InputArray = new Uint8Array(this.ctx.memory.buffer, this.wasmInputValue, this.ctx.INPUT_LENGTH.value);\n        this.uint8OutputArray = new Uint8Array(this.ctx.memory.buffer, this.wasmOutputValue, 32);\n    }\n    init() {\n        this.ctx.init();\n        return this;\n    }\n    update(data) {\n        const INPUT_LENGTH = this.ctx.INPUT_LENGTH.value;\n        if (data.length > INPUT_LENGTH) {\n            for (let i = 0; i < data.length; i += INPUT_LENGTH) {\n                const sliced = data.slice(i, i + INPUT_LENGTH);\n                this.uint8InputArray.set(sliced);\n                this.ctx.update(this.wasmInputValue, sliced.length);\n            }\n        }\n        else {\n            this.uint8InputArray.set(data);\n            this.ctx.update(this.wasmInputValue, data.length);\n        }\n        return this;\n    }\n    final() {\n        this.ctx.final(this.wasmOutputValue);\n        const output = new Uint8Array(32);\n        output.set(this.uint8OutputArray);\n        return output;\n    }\n}\nexports.default = SHA256;\n//# sourceMappingURL=sha256.js.map"],"names":[],"sourceRoot":"","x_google_ignoreList":[0,1,2,3]}